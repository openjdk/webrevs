{"files":[{"patch":"@@ -219,0 +219,1 @@\n+  LOG_TAG(vmatree) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n+        _stack_storage.get(prev->val().out.reserved_stack()).print_on(stream);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-\n-private:\n@@ -50,1 +48,0 @@\n-public:\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,53 @@\n-const VMATree::RegionData VMATree::empty_regiondata{NativeCallStackStorage::StackIndex{}, mtNone};\n+\n+\/\/ Semantics\n+\/\/ This tree is used to store and track the state of virtual memory regions.\n+\/\/ The nodes in the tree are key-value pairs where the key is the memory address and the value is the State of the memory regions.\n+\/\/ The State of a region describes whether the region is released, reserved or committed, which MemTag it has and where in\n+\/\/ Hotspot (using call-stacks) it is reserved or committed.\n+\/\/ Each node holds the State of the regions to its left and right. Each memory region is described by two\n+\/\/ memory addresses for its start and end.\n+\/\/ For example, to describe the region that starts at memory address 0xA000 with size 0x1000, there will be two nodes\n+\/\/ with the keys 0xA000 (node A) and 0xB000 (node B) in the tree. The value of the key-value pairs of node A and\n+\/\/ node B describe the region's State, using right of A and left of B (<--left--A--right-->.....<--left--B--right-->...).\n+\/\/\n+\/\/ Virtual memory can be reserved, committed, uncommitted and released. For each operation a request\n+\/\/ (<from-address, to-address, operation, tag, call-stack, which-tag-to-use >) is sent to the tree to handle.\n+\/\/\n+\/\/ The expected changes are described here for each operation:\n+\/\/\n+\/\/ ### Reserve a region\n+\/\/ When a region is reserved, all the overlapping regions in the tree should:\n+\/\/   - be marked as Reserved\n+\/\/   - take MemTag of the operation\n+\/\/   - store call-stack of the request to the reserve call-stack\n+\/\/   - clear commit call-stack\n+\/\/\n+\/\/ ### Commit a region\n+\/\/ When a region is committed, all the overlapping regions in the tree should:\n+\/\/   - be marked as Committed\n+\/\/   - take MemTag of the operation or MemTag of the existing region, depends on which-tag-to-use in the request\n+\/\/   - if the region is in Released state\n+\/\/     - mark the region as both Reserved and Committed\n+\/\/     - store the call-stack of the request to the reserve call-stack\n+\/\/   - store the call-stack of the request to the commit call-stack\n+\/\/\n+\/\/ ### Uncommit a region\n+\/\/ When a region is uncommitted, all the overlapping regions in the tree should:\n+\/\/   - be ignored if the region is in Released state\n+\/\/   - be marked as Reserved\n+\/\/   - not change the MemTag\n+\/\/   - not change the reserve call-stack\n+\/\/   - clear commit call-stack\n+\/\/\n+\/\/ ### Release a region\n+\/\/ When a region is released, all the overlapping regions in the tree should:\n+\/\/   - be marked as Released\n+\/\/   - set the MemTag to mtNone\n+\/\/   - clear both reserve and commit call-stack\n+\/\/\n+\/\/ ---  Accounting\n+\/\/ After each operation, the tree should be able to report how much memory is reserved or committed per MemTag.\n+\/\/ So for each region that changes to a new State, the report should contain (separately for each tag) the amount\n+\/\/ of reserve and commit that are changed (increased or decreased) due to the operation.\n+\n+const VMATree::RegionData VMATree::empty_regiondata{NativeCallStackStorage::invalid, mtNone};\n@@ -34,1 +86,1 @@\n-  \"reserved\", \"committed\", \"released\",\n+  \"released\", \"reserved\", \"committed\"\n@@ -37,1 +89,156 @@\n-VMATree::SummaryDiff VMATree::register_mapping(position A, position B, StateType state,\n+VMATree::SIndex VMATree::get_new_reserve_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  const int op = req.op_to_index();\n+  const Operation oper = req.op();\n+  assert(op >= 0 && op < 4, \"should be\");\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {rq, rq, rq},   \/\/ op == Reserve\n+                           {es, es, es},   \/\/ op == Commit\n+                           {es, es, es}    \/\/ op == Uncommit\n+                           };\n+  \/\/ When committing a Released region, the reserve-call-stack of the region should also be as what is in the request\n+  if (oper == Operation::Commit && ex == StateType::Released) {\n+    return rq;\n+  } else {\n+    return result[op][state_to_index(ex)];\n+  }\n+}\n+\n+VMATree::SIndex VMATree::get_new_commit_callstack(const SIndex es, const StateType ex, const RequestInfo& req) const {\n+  const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+  const SIndex rq = req.callstack;\n+  const int op_index = req.op_to_index();\n+  const Operation op = req.op();\n+  assert(op_index >= 0 && op_index < 4, \"should be\");\n+                         \/\/ existing state\n+  SIndex result[4][3] = {\/\/ Rl  Rs   C\n+                           {ES, ES, ES},   \/\/ op == Release\n+                           {ES, ES, ES},   \/\/ op == Reserve\n+                           {rq, rq, rq},   \/\/ op == Commit\n+                           {ES, ES, ES}    \/\/ op == Uncommit\n+                        };\n+  return result[op_index][state_to_index(ex)];\n+}\n+\n+VMATree::StateType VMATree::get_new_state(const StateType ex, const RequestInfo& req) const {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+                            \/\/ existing state\n+  StateType result[4][3] = {\/\/ Rl  Rs   C\n+                              {Rl, Rl, Rl},   \/\/ op == Release\n+                              {Rs, Rs, Rs},   \/\/ op == Reserve\n+                              { C,  C,  C},   \/\/ op == Commit\n+                              {Rl, Rs, Rs}    \/\/ op == Uncommit\n+                           };\n+  return result[op][state_to_index(ex)];\n+}\n+\n+MemTag VMATree::get_new_tag(const MemTag ex, const RequestInfo& req) const {\n+  switch(req.op()) {\n+    case Operation::Release:\n+      return mtNone;\n+    case Operation::Reserve:\n+      return req.tag;\n+    case Operation::Commit:\n+      return req.use_tag_inplace ? ex : req.tag;\n+    case Operation::Uncommit:\n+      return ex;\n+    default:\n+      break;\n+  }\n+  return mtNone;\n+}\n+\n+void VMATree::compute_summary_diff(const SingleDiff::delta region_size,\n+                                   const MemTag current_tag,\n+                                   const StateType& ex,\n+                                   const RequestInfo& req,\n+                                   const MemTag operation_tag,\n+                                   SummaryDiff& diff) const {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  const int op = req.op_to_index();\n+  const Operation oper =  req.op();\n+  assert(op >= 0 && op < 4, \"should be\");\n+\n+  SingleDiff::delta a = region_size;\n+  \/\/ A region with size `a` has a state as <column> and an operation is requested as in <row>\n+  \/\/ The region has tag `current_tag` and the operation has tag `operation_tag`.\n+  \/\/ For each state, we decide how much to be added\/subtracted from current_tag to operation_tag. Two tables for reserve and commit.\n+  \/\/ Each pair of <x,y> in the table means add `x` to current_tag and add `y` to operation_tag. There are 3 pairs in each row for 3 states.\n+  \/\/ For example, `reserve[1][4,5]` says `-a,a` means:\n+  \/\/    - we are reserving with operation_tag a region which is already commited with current_tag\n+  \/\/    - since we are reserving, then `a` will be added to operation_tag. (`y` is `a`)\n+  \/\/    - since we uncommitting (by reserving) then `a` is to be subtracted from current_tag. (`x` is `-a`).\n+  \/\/    - amount of uncommitted size is in table `commit[1][4,5]` which is `-a,0` that means subtract `a` from current_tag.\n+                                       \/\/ existing state\n+  SingleDiff::delta reserve[4][3*2] = {\/\/ Rl    Rs     C\n+                                         {0,0, -a,0, -a,0 },   \/\/ op == Release\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Reserve\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Commit\n+                                         {0,0,  0,0,  0,0 }    \/\/ op == Uncommit\n+                                      };\n+  SingleDiff::delta commit[4][3*2] = {\/\/ Rl    Rs     C\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Release\n+                                        {0,0,  0,0, -a,0 },    \/\/ op == Reserve\n+                                        {0,a,  0,a, -a,a },    \/\/ op == Commit\n+                                        {0,0,  0,0, -a,0 }     \/\/ op == Uncommit\n+                                     };\n+  SingleDiff& from_rescom = diff.tag[NMTUtil::tag_to_index(current_tag)];\n+  SingleDiff&   to_rescom = diff.tag[NMTUtil::tag_to_index(operation_tag)];\n+  int st = state_to_index(ex);\n+  from_rescom.reserve += reserve[op][st * 2    ];\n+    to_rescom.reserve += reserve[op][st * 2 + 1];\n+  from_rescom.commit  +=  commit[op][st * 2    ];\n+    to_rescom.commit  +=  commit[op][st * 2 + 1];\n+\n+}\n+\/\/ update the region state between n1 and n2. Since n1 and n2 are pointers, any update of them will be visible from tree.\n+\/\/ If n1 is noop, it can be removed because its left region (n1->val().in) is already decided and its right state (n1->val().out) is decided here.\n+\/\/ The state of right of n2 (n2->val().out) cannot be decided here yet.\n+void VMATree::update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n+  assert(n1 != nullptr,\"sanity\");\n+  assert(n2 != nullptr,\"sanity\");\n+  \/\/.........n1......n2......\n+  \/\/          ^------^\n+  \/\/             |\n+  IntervalState exSt = n1->val().out; \/\/ existing state info\n+\n+\n+  StateType existing_state              = exSt.type();\n+  MemTag    existing_tag                = exSt.mem_tag();\n+  SIndex    existing_reserve_callstack  = exSt.reserved_stack();\n+  SIndex    existing_commit_callstack   = exSt.committed_stack();\n+\n+  StateType new_state                   = get_new_state(existing_state, req);\n+  MemTag    new_tag                     = get_new_tag(n1->val().out.mem_tag(), req);\n+  SIndex    new_reserve_callstack       = get_new_reserve_callstack(existing_reserve_callstack, existing_state, req);\n+  SIndex    new_commit_callstack        = get_new_commit_callstack(existing_commit_callstack, existing_state, req);\n+\n+  \/\/  n1........n2\n+  \/\/ out-->\n+  n1->val().out.set_tag(new_tag);\n+  n1->val().out.set_type(new_state);\n+  n1->val().out.set_reserve_stack(new_reserve_callstack);\n+  n1->val().out.set_commit_stack(new_commit_callstack);\n+\n+  \/\/  n1........n2\n+  \/\/         <--in\n+  n2->val().in.set_tag(new_tag);\n+  n2->val().in.set_type(new_state);\n+  n2->val().in.set_reserve_stack(new_reserve_callstack);\n+  n2->val().in.set_commit_stack(new_commit_callstack);\n+\n+  SingleDiff::delta region_size = n2->key() - n1->key();\n+  compute_summary_diff(region_size, existing_tag, existing_state, req, new_tag, diff);\n+}\n+\n+VMATree::SummaryDiff VMATree::register_mapping(position _A, position _B, StateType state,\n@@ -39,4 +246,2 @@\n-  assert(!use_tag_inplace || metadata.mem_tag == mtNone,\n-         \"If using use_tag_inplace, then the supplied tag should be mtNone, was instead: %s\", NMTUtil::tag_to_name(metadata.mem_tag));\n-  if (A == B) {\n-    \/\/ A 0-sized mapping isn't worth recording.\n+\n+  if (_A == _B) {\n@@ -45,1 +250,3 @@\n-\n+  assert(_A < _B, \"should be\");\n+  SummaryDiff diff;\n+  RequestInfo req{_A, _B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n@@ -54,0 +261,4 @@\n+  stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n+  stB.in.set_commit_stack(NativeCallStackStorage::invalid);\n+  VMATreap::Range rA = _tree.find_enclosing_range(_A);\n+  VMATreap::Range rB = _tree.find_enclosing_range(_B);\n@@ -55,13 +266,67 @@\n-  \/\/ First handle A.\n-  \/\/ Find closest node that is LEQ A\n-  bool LEQ_A_found = false;\n-  AddressState LEQ_A;\n-  TreapNode* leqA_n = _tree.closest_leq(A);\n-  if (leqA_n == nullptr) {\n-    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    if (use_tag_inplace) {\n-      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n-    }\n-    \/\/ No match. We add the A node directly, unless it would have no effect.\n-    if (!stA.is_noop()) {\n-      _tree.upsert(A, stA);\n+  \/\/ nodes:          .....X.......Y...Z......W........U\n+  \/\/ request:                 A------------------B\n+  \/\/ X,Y = enclosing_nodes(A)\n+  \/\/ W,U = enclosing_nodes(B)\n+  \/\/ The cases are whether or not X and Y exists and X == A. (A == Y doesn't happen since it is searched by 'lt' predicate)\n+  \/\/ The cases are whether or not W and U exists and W == B. (B == U doesn't happen since it is searched by 'lt' predicate)\n+\n+  \/\/ We update regions in 3 sections: 1) X..A..Y, 2) Y....W, 3) W..B..U\n+  \/\/ Y: is the closest node greater than A, but less than B\n+  \/\/ W: is the closest node less than B, but greater than A\n+  \/\/ The regions in [Y,W) are updated in a loop. We update X..A..Y before the loop and W..B..U after the loop.\n+  \/\/ The table below summarizes the overlap cases. The overlapping case depends on whether X, Y, W and U exist or not,\n+  \/\/ and if they exist whether they are the same or not.\n+  \/\/ In the notations here, when there is not dot ('.') between two nodes it meaans that they are the same. For example,\n+  \/\/ ...XA....Y.... means X == A.\n+\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ row  1:  .........A...YW.............B.....  \/\/ it is impossible, since it means only one node exists in the tree.\n+  \/\/ row  2:  .........A...Y..........W...B.....\n+  \/\/ row  3:  .........A...Y.............WB.....\n+\n+  \/\/ row  4:  .....X...A..................B.....\n+  \/\/ row  5:  .....X...A...YW.............B.....\n+  \/\/ row  6:  .....X...A...Y..........W...B.....\n+  \/\/ row  7:  .....X...A...Y.............WB.....\n+\n+  \/\/ row  8:  ........XA..................B.....\n+  \/\/ row  9:  ........XA...YW.............B.....\n+  \/\/ row 10:  ........XA...Y..........W...B.....\n+  \/\/ row 11:  ........XA...Y.............WB.....\n+\n+  \/\/ row 12:  .........A..................B....U\n+  \/\/ row 13:  .........A...YW.............B....U\n+  \/\/ row 14:  .........A...Y..........W...B....U\n+  \/\/ row 15:  .........A...Y.............WB....U\n+\n+  \/\/ row 16:  .....X...A..................B....U\n+  \/\/ row 17:  .....X...A...YW.............B....U\n+  \/\/ row 18:  .....X...A...Y..........W...B....U\n+  \/\/ row 19:  .....X...A...Y.............WB....U\n+\n+  \/\/ row 20:  ........XA..................B....U\n+  \/\/ row 21:  ........XA...YW.............B....U\n+  \/\/ row 22:  ........XA...Y..........W...B....U\n+  \/\/ row 23:  ........XA...Y.............WB....U\n+\n+\n+  \/\/ We intentionally did not summarize\/compress the cases to keep them as separate.\n+  \/\/ This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain\n+  \/\/ the corresponding code more easily.\n+  \/\/ Mapping of table to row, row to switch-case should be consistent. If one changes, the others have\n+  \/\/ to be updated accordingly. The sequence of dependecies is: table -> row no -> switch(row)-case -> code.\n+  \/\/ Meaning that whenever any of one item in this sequence is changed, the rest of the consequent items to\n+  \/\/ be checked\/changed.\n+\n+  TreapNode* X = rA.start;\n+  TreapNode* Y = rA.end;\n+  TreapNode* W = rB.start;\n+  TreapNode* U = rB.end;\n+  TreapNode nA{_A, stA, 0}; \/\/ the node that represents A\n+  TreapNode nB{_B, stB, 0}; \/\/ the node that represents B\n+  TreapNode* A = &nA;\n+  TreapNode* B = &nB;\n+  auto upsert_if= [&](TreapNode* node) {\n+    if (!node->val().is_noop()) {\n+      _tree.upsert(node->key(), node->val());\n@@ -69,12 +334,9 @@\n-  } else {\n-    LEQ_A_found = true;\n-    LEQ_A = AddressState{leqA_n->key(), leqA_n->val()};\n-    StateType leqA_state = leqA_n->val().out.type();\n-    StateType new_state = stA.out.type();\n-    \/\/ If we specify use_tag_inplace then the new region takes over the current tag instead of the tag in metadata.\n-    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the tag for some operations.\n-    if (use_tag_inplace) {\n-      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n-      MemTag tag = leqA_n->val().out.mem_tag();\n-      stA.out.set_tag(tag);\n-      stB.in.set_tag(tag);\n+  };\n+  \/\/ update region between n1 and n2\n+  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+    update_region(n1, n2, req, diff);\n+  };\n+  auto remove_if = [&](TreapNode* node) -> bool{\n+    if (node->val().is_noop()) {\n+      _tree.remove(node->key());\n+      return true;\n@@ -82,40 +344,14 @@\n-\n-    \/\/ Unless we know better, let B's outgoing state be the outgoing state of the node at or preceding A.\n-    \/\/ Consider the case where the found node is the start of a region enclosing [A,B)\n-    stB.out = out_state(leqA_n);\n-\n-    \/\/ Direct address match.\n-    if (leqA_n->key() == A) {\n-      \/\/ Take over in state from old address.\n-      stA.in = in_state(leqA_n);\n-\n-      \/\/ We may now be able to merge two regions:\n-      \/\/ If the node's old state matches the new, it becomes a noop. That happens, for example,\n-      \/\/ when expanding a committed area: commit [x1, A); ... commit [A, x3)\n-      \/\/ and the result should be a larger area, [x1, x3). In that case, the middle node (A and le_n)\n-      \/\/ is not needed anymore. So we just remove the old node.\n-      stB.in = stA.out;\n-      if (stA.is_noop()) {\n-        \/\/ invalidates leqA_n\n-        _tree.remove(leqA_n->key());\n-      } else {\n-        \/\/ If the state is not matching then we have different operations, such as:\n-        \/\/ reserve [x1, A); ... commit [A, x2); or\n-        \/\/ reserve [x1, A), mem_tag1; ... reserve [A, x2), mem_tag2; or\n-        \/\/ reserve [A, x1), mem_tag1; ... reserve [A, x2), mem_tag2;\n-        \/\/ then we re-use the existing out node, overwriting its old metadata.\n-        leqA_n->val() = stA;\n-      }\n-    } else {\n-      \/\/ The address must be smaller.\n-      assert(A > leqA_n->key(), \"must be\");\n-\n-      \/\/ We add a new node, but only if there would be a state change. If there would not be a\n-      \/\/ state change, we just omit the node.\n-      \/\/ That happens, for example, when reserving within an already reserved region with identical metadata.\n-      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n-      if (stA.is_noop()) {\n-        \/\/ Nothing to do.\n-      } else {\n-        \/\/ Add new node.\n-        _tree.upsert(A, stA);\n+    return false;\n+  };\n+  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n+  \/\/ update regions in [Y,W)\n+  auto update_loop = [&]() {\n+    TreapNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+      if (prev != nullptr) {\n+        update_region(prev, curr, req, diff);\n+        \/\/ during visit, structure of the tree should not be changed\n+        \/\/ keep the keys to be removed, and remove them later\n+        if (prev->val().is_noop()) {\n+          to_be_removed.push(prev->key());\n+        }\n@@ -123,2 +359,34 @@\n-    }\n-  }\n+      prev = curr;\n+    });\n+  };\n+  \/\/ update region of [A,T)\n+  auto update_A = [&](TreapNode* T) {\n+    A->val().out = A->val().in;\n+    update(A, T);\n+  };\n+  bool X_exists = X != nullptr;\n+  bool Y_exists = Y != nullptr && Y->key() <= _B;\n+  bool W_exists = W != nullptr && W->key() > _A;\n+  bool U_exists = U != nullptr;\n+  bool X_eq_A = X_exists && X->key() == _A;\n+  bool W_eq_B = W_exists && W->key() == _B;\n+  bool Y_eq_W = Y_exists && W_exists && W->key() == Y->key();\n+  int row = -1;\n+#ifdef ASSERT\n+  auto print_case = [&]() {\n+    log_trace(vmatree)(\" req: %4d---%4d\", (int)_A, (int)_B);\n+    log_trace(vmatree)(\" row: %2d\", row);\n+    log_trace(vmatree)(\" X: %4ld\", X_exists ? (long)X->key() : -1);\n+    log_trace(vmatree)(\" Y: %4ld\", Y_exists ? (long)Y->key() : -1);\n+    log_trace(vmatree)(\" W: %4ld\", W_exists ? (long)W->key() : -1);\n+    log_trace(vmatree)(\" U: %4ld\", U_exists ? (long)U->key() : -1);\n+  };\n+#endif\n+  \/\/ Order of the nodes if they exist are as: X <= A < Y <= W <= B < U\n+  \/\/             A---------------------------B\n+  \/\/       X           Y          YW         WB          U\n+  \/\/       XA          Y          YW         WB          U\n+  if (!X_exists && !Y_exists                       && !U_exists) { row =  0; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  1; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  2; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  3; }\n@@ -126,26 +394,4 @@\n-  \/\/ Now we handle B.\n-  \/\/ We first search all nodes that are (A, B]. All of these nodes\n-  \/\/ need to be deleted and summary accounted for. The last node before B determines B's outgoing state.\n-  \/\/ If there is no node between A and B, its A's incoming state.\n-  GrowableArrayCHeap<AddressState, mtNMT> to_be_deleted_inbetween_a_b;\n-  bool B_needs_insert = true;\n-\n-  \/\/ Find all nodes between (A, B] and record their addresses and values. Also update B's\n-  \/\/ outgoing state.\n-  _tree.visit_range_in_order(A + 1, B + 1, [&](TreapNode* head) {\n-    int cmp_B = PositionComparator::cmp(head->key(), B);\n-    stB.out = out_state(head);\n-    if (cmp_B < 0) {\n-      \/\/ Record all nodes preceding B.\n-      to_be_deleted_inbetween_a_b.push({head->key(), head->val()});\n-    } else if (cmp_B == 0) {\n-      \/\/ Re-purpose B node, unless it would result in a noop node, in\n-      \/\/ which case record old node at B for deletion and summary accounting.\n-      if (stB.is_noop()) {\n-        to_be_deleted_inbetween_a_b.push(AddressState{B, head->val()});\n-      } else {\n-        head->val() = stB;\n-      }\n-      B_needs_insert = false;\n-    }\n-  });\n+  if ( X_exists && !Y_exists                       && !U_exists) { row =  4; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  5; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row =  6; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B && !U_exists) { row =  7; }\n@@ -153,6 +399,4 @@\n-  \/\/ Insert B node if needed\n-  if (B_needs_insert && \/\/ Was not already inserted\n-      !stB.is_noop())   \/\/ The operation is differing\n-    {\n-    _tree.upsert(B, stB);\n-  }\n+  if ( X_eq_A   && !Y_exists                       && !U_exists) { row =  8; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B && !U_exists) { row =  9; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B && !U_exists) { row = 10; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B && !U_exists) { row = 11; }\n@@ -160,4 +404,4 @@\n-  \/\/ We now need to:\n-  \/\/ a) Delete all nodes between (A, B]. Including B in the case of a noop.\n-  \/\/ b) Perform summary accounting\n-  SummaryDiff diff;\n+  if (!X_exists && !Y_exists                       &&  U_exists) { row = 12; }\n+  if (!X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 13; }\n+  if (!X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 14; }\n+  if (!X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 15; }\n@@ -165,11 +409,4 @@\n-  if (to_be_deleted_inbetween_a_b.length() == 0 && LEQ_A_found) {\n-    \/\/ We must have smashed a hole in an existing region (or replaced it entirely).\n-    \/\/ LEQ_A < A < B <= C\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(LEQ_A.out().mem_tag())];\n-    if (LEQ_A.out().type() == StateType::Reserved) {\n-      rescom.reserve -= B - A;\n-    } else if (LEQ_A.out().type() == StateType::Committed) {\n-      rescom.commit -= B - A;\n-      rescom.reserve -= B - A;\n-    }\n-  }\n+  if ( X_exists && !Y_exists                       &&  U_exists) { row = 16; }\n+  if ( X_exists &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 17; }\n+  if ( X_exists &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 18; }\n+  if ( X_exists &&  Y_exists &&             W_eq_B &&  U_exists) { row = 19; }\n@@ -177,16 +414,4 @@\n-  \/\/ Track the previous node.\n-  AddressState prev{A, stA};\n-  for (int i = 0; i < to_be_deleted_inbetween_a_b.length(); i++) {\n-    const AddressState delete_me = to_be_deleted_inbetween_a_b.at(i);\n-    _tree.remove(delete_me.address);\n-\n-    \/\/ Perform summary accounting\n-    SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(delete_me.in().mem_tag())];\n-    if (delete_me.in().type() == StateType::Reserved) {\n-      rescom.reserve -= delete_me.address - prev.address;\n-    } else if (delete_me.in().type() == StateType::Committed) {\n-      rescom.commit -= delete_me.address - prev.address;\n-      rescom.reserve -= delete_me.address - prev.address;\n-    }\n-    prev = delete_me;\n-  }\n+  if ( X_eq_A   && !Y_exists                       &&  U_exists) { row = 20; }\n+  if ( X_eq_A   &&  Y_exists &&  Y_eq_W && !W_eq_B &&  U_exists) { row = 21; }\n+  if ( X_eq_A   &&  Y_exists && !Y_eq_W && !W_eq_B &&  U_exists) { row = 22; }\n+  if ( X_eq_A   &&  Y_exists &&             W_eq_B &&  U_exists) { row = 23; }\n@@ -194,11 +419,32 @@\n-  if (prev.address != A && prev.out().type() != StateType::Released) {\n-    \/\/ The last node wasn't released, so it must be connected to a node outside of (A, B)\n-    \/\/ A - prev - B - (some node >= B)\n-    \/\/ It might be that prev.address == B == (some node >= B), this is fine.\n-    if (prev.out().type() == StateType::Reserved) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.reserve -= B - prev.address;\n-    } else if (prev.out().type() == StateType::Committed) {\n-      SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(prev.out().mem_tag())];\n-      rescom.commit -= B - prev.address;\n-      rescom.reserve -= B - prev.address;\n+  DEBUG_ONLY(print_case();)\n+  switch(row) {\n+    \/\/ row  0:  .........A..................B.....\n+    case 0: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  1:  .........A...YW.............B.....\n+    case 1: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+    \/\/ row  2:  .........A...Y..........W...B.....\n+    case 2: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(Y);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  3:  .........A...Y.............WB.....\n+    case 3: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n@@ -206,0 +452,188 @@\n+    \/\/ row  4:  .....X...A..................B.....\n+    case 4: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    case 5: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(Y, B);\n+      remove_if(Y);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  6:  .....X...A...Y..........W...B.....\n+    case 6: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  7:  .....X...A...Y.............WB.....\n+    case 7: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row  8:  ........XA..................B.....\n+    case 8: {\n+      update(X, B);\n+      remove_if(X);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row  9:  ........XA...YW.............B.....\n+    case 9: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 10:  ........XA...Y..........W...B.....\n+    case 10: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 11:  ........XA...Y.............WB.....\n+    case 11: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 12:  .........A..................B....U\n+    case 12: {\n+      update_A(B);\n+      upsert_if(A);\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 13:  .........A...YW.............B....U\n+    case 13: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 14:  .........A...Y..........W...B....U\n+    case 14: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 15:  .........A...Y.............WB....U\n+    case 15: {\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 16:  .....X...A..................B....U\n+    case 16: {\n+      A->val().in = X->val().out;\n+      update_A(B);\n+      upsert_if(A);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    case 17: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 18:  .....X...A...Y..........W...B....U\n+    case 18: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 19:  .....X...A...Y.............WB....U\n+    case 19: {\n+      A->val().in = X->val().out;\n+      update_A(Y);\n+      upsert_if(A);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    \/\/ row 20:  ........XA..................B....U\n+    case 20: {\n+      update(X, B);\n+      remove_if(X);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    case 21: {\n+      update(X, Y);\n+      remove_if(X);\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 22:  ........XA...Y..........W...B....U\n+    case 22: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      update(W, B);\n+      remove_if(W);\n+      B->val().out = U->val().in;\n+      upsert_if(B);\n+      break;\n+    }\n+    \/\/ row 23:  ........XA...Y.............WB....U\n+    case 23: {\n+      update(X, Y);\n+      remove_if(X);\n+      update_loop();\n+      remove_if(W);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n@@ -208,7 +642,3 @@\n-  \/\/ Finally, we can register the new region [A, B)'s summary data.\n-  SingleDiff& rescom = diff.tag[NMTUtil::tag_to_index(stA.out.mem_tag())];\n-  if (state == StateType::Reserved) {\n-    rescom.reserve += B - A;\n-  } else if (state == StateType::Committed) {\n-    rescom.commit += B - A;\n-    rescom.reserve += B - A;\n+  \/\/ Remove the 'noop' nodes that found inside the loop\n+  while(to_be_removed.length() != 0) {\n+    _tree.remove(to_be_removed.pop());\n@@ -216,0 +646,1 @@\n+\n@@ -222,2 +653,2 @@\n-    out->print(\"%zu (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n-               statetype_to_string(out_state(current).type()));\n+    out->print(\"%zu (%s) - %s [%d, %d]-> \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+              statetype_to_string(out_state(current).type()), current->val().out.reserved_stack(), current->val().out.committed_stack());\n@@ -271,1 +702,1 @@\n-    RegionData new_data = RegionData(out.stack(), tag);\n+    RegionData new_data = RegionData(out.reserved_stack(), tag);\n@@ -292,1 +723,1 @@\n-      RegionData new_data = RegionData(out.stack(), tag);\n+      RegionData new_data = RegionData(out.reserved_stack(), tag);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":591,"deletions":160,"binary":false,"changes":751,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  using SIndex = NativeCallStackStorage::StackIndex;\n@@ -58,1 +59,1 @@\n-  enum class StateType : uint8_t { Reserved, Committed, Released, LAST };\n+  enum class StateType : uint8_t { Released, Reserved, Committed, LAST };\n@@ -73,1 +74,1 @@\n-    const NativeCallStackStorage::StackIndex stack_idx;\n+    const SIndex stack_idx;\n@@ -78,1 +79,1 @@\n-    RegionData(NativeCallStackStorage::StackIndex stack_idx, MemTag mem_tag)\n+    RegionData(SIndex stack_idx, MemTag mem_tag)\n@@ -94,1 +95,2 @@\n-    NativeCallStackStorage::StackIndex sidx;\n+    NativeCallStackStorage::StackIndex _reserved_stack;\n+    NativeCallStackStorage::StackIndex _committed_stack;\n@@ -97,1 +99,11 @@\n-    IntervalState() : type_tag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, _reserved_stack(NativeCallStackStorage::invalid), _committed_stack(NativeCallStackStorage::invalid) {}\n+    IntervalState(const StateType type,\n+                  const MemTag mt,\n+                  const NativeCallStackStorage::StackIndex res_stack,\n+                  const NativeCallStackStorage::StackIndex com_stack) {\n+      assert(!(type == StateType::Released) || mt == mtNone, \"Released state-type must have memory tag mtNone\");\n+      type_tag[0] = static_cast<uint8_t>(type);\n+      type_tag[1] = static_cast<uint8_t>(mt);\n+      _reserved_stack = res_stack;\n+      _committed_stack = com_stack;\n+    }\n@@ -102,1 +114,2 @@\n-      sidx = data.stack_idx;\n+      _reserved_stack = data.stack_idx;\n+      _committed_stack = NativeCallStackStorage::invalid;\n@@ -113,2 +126,5 @@\n-    RegionData regiondata() const {\n-      return RegionData{sidx, mem_tag()};\n+    RegionData reserved_regiondata() const {\n+      return RegionData{_reserved_stack, mem_tag()};\n+    }\n+    RegionData committed_regiondata() const {\n+      return RegionData{_committed_stack, mem_tag()};\n@@ -121,2 +137,33 @@\n-    NativeCallStackStorage::StackIndex stack() const {\n-     return sidx;\n+    NativeCallStackStorage::StackIndex reserved_stack() const {\n+      return _reserved_stack;\n+    }\n+\n+    NativeCallStackStorage::StackIndex committed_stack() const {\n+      return _committed_stack;\n+    }\n+\n+    void set_reserve_stack(NativeCallStackStorage::StackIndex idx) {\n+      _reserved_stack = idx;\n+    }\n+\n+    void set_commit_stack(NativeCallStackStorage::StackIndex idx) {\n+      _committed_stack = idx;\n+    }\n+\n+    bool has_reserved_stack() {\n+      return _reserved_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    bool has_committed_stack() {\n+      return _committed_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    void set_type(StateType t) {\n+      type_tag[0] = static_cast<uint8_t>(t);\n+    }\n+\n+    bool equals(const IntervalState& other) const {\n+      return mem_tag()          == other.mem_tag()          &&\n+             type()             == other.type()             &&\n+             reserved_stack()   == other.reserved_stack()   &&\n+             committed_stack()  == other.committed_stack();\n@@ -133,0 +180,5 @@\n+      if (in.type() == StateType::Released &&\n+          in.type() == out.type() &&\n+          in.mem_tag() == out.mem_tag()) {\n+        return true;\n+      }\n@@ -134,1 +186,2 @@\n-             RegionData::equals(in.regiondata(), out.regiondata());\n+             RegionData::equals(in.reserved_regiondata(), out.reserved_regiondata()) &&\n+             RegionData::equals(in.committed_regiondata(), out.committed_regiondata());\n@@ -196,0 +249,24 @@\n+  enum Operation {Release, Reserve, Commit, Uncommit};\n+  struct RequestInfo {\n+    position A, B;\n+    StateType _op;\n+    MemTag tag;\n+    SIndex callstack;\n+    bool use_tag_inplace;\n+    Operation op() const {\n+      return\n+            _op == StateType::Reserved && !use_tag_inplace  ? Operation::Reserve  :\n+            _op == StateType::Committed                     ? Operation::Commit   :\n+            _op == StateType::Reserved &&  use_tag_inplace  ? Operation::Uncommit :\n+             Operation::Release;\n+    }\n+\n+    int op_to_index() const {\n+      return\n+            _op == StateType::Reserved && !use_tag_inplace  ? 1 :\n+            _op == StateType::Committed                     ? 2 :\n+            _op == StateType::Reserved &&  use_tag_inplace  ? 3 :\n+             0;\n+    }\n+  };\n+\n@@ -198,0 +275,12 @@\n+  StateType get_new_state(const StateType existinting_state, const RequestInfo& req) const;\n+  MemTag get_new_tag(const MemTag existinting_tag, const RequestInfo& req) const;\n+  SIndex get_new_reserve_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  SIndex get_new_commit_callstack(const SIndex existinting_stack, const StateType ex, const RequestInfo& req) const;\n+  void compute_summary_diff(const SingleDiff::delta region_size, const MemTag t1, const StateType& ex, const RequestInfo& req, const MemTag new_tag, SummaryDiff& diff) const;\n+  void update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff);\n+  int state_to_index(const StateType st) const {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":100,"deletions":11,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  constexpr static const int si_len = 2;\n+  constexpr static const int si_len = 4;\n@@ -46,0 +46,2 @@\n+    stacks[2] = make_stack(0xC);\n+    stacks[3] = make_stack(0xD);\n@@ -47,1 +49,3 @@\n-    si[1] = ncs.push(stacks[0]);\n+    si[1] = ncs.push(stacks[1]);\n+    si[2] = ncs.push(stacks[2]);\n+    si[3] = ncs.push(stacks[3]);\n@@ -102,0 +106,5 @@\n+    \/\/                      900---1000\n+    \/\/                 800--900\n+    \/\/            700--800\n+    \/\/        ...\n+    \/\/ 0--100\n@@ -170,0 +179,158 @@\n+  template<int NodeCount> struct ExpectedTree {\n+    int nodes[NodeCount];\n+    MemTag tags[NodeCount + 1];\n+    VMATree::StateType states[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex res_si[NodeCount + 1];\n+    NativeCallStackStorage::StackIndex com_si[NodeCount + 1];\n+  };\n+\n+  using State = VMATree::StateType;\n+  using SIndex = VMATree::SIndex;\n+\n+  struct UpdateCallInfo {\n+    VMATree::IntervalState ex_st;\n+    VMATree::RequestInfo req;\n+    VMATree::IntervalState new_st;\n+    int reserve[2], commit[2];\n+  };\n+\n+  void call_update_region(const UpdateCallInfo upd) {\n+    VMATree::TreapNode n1{upd.req.A, {}, 0}, n2{upd.req.B, {}, 0};\n+    n1.val().out= upd.ex_st;\n+    n2.val().in = n1.val().out;\n+    Tree tree;\n+    VMATree::SummaryDiff diff;\n+    tree.update_region(&n1, &n2, upd.req, diff);\n+    int from = NMTUtil::tag_to_index(upd.ex_st.mem_tag());\n+    int   to = NMTUtil::tag_to_index(upd.new_st.mem_tag());\n+    stringStream ss;\n+    ss.print(\"Ex. State: %d, op: %d, use-tag:%d, from==to: %d\",\n+             (int)upd.ex_st.type(), (int)upd.req.op_to_index(), upd.req.use_tag_inplace, from == to);\n+    const char* failed_case = ss.base();\n+    EXPECT_EQ(n1.val().out.type(), upd.new_st.type()) << failed_case;\n+    EXPECT_EQ(n1.val().out.mem_tag(), upd.new_st.mem_tag()) << failed_case;\n+    EXPECT_EQ(n1.val().out.reserved_stack(), upd.new_st.reserved_stack()) << failed_case;\n+    EXPECT_EQ(n1.val().out.committed_stack(), upd.new_st.committed_stack()) << failed_case;\n+\n+    if (from == to) {\n+      EXPECT_EQ(diff.tag[from].reserve, upd.reserve[0] + upd.reserve[1]) << failed_case;\n+      EXPECT_EQ(diff.tag[from].commit, upd.commit[0] + upd.commit[1]) << failed_case;\n+    } else {\n+      EXPECT_EQ(diff.tag[from].reserve, upd.reserve[0]) << failed_case;\n+      EXPECT_EQ(diff.tag[from].commit, upd.commit[0]) << failed_case;\n+      EXPECT_EQ(diff.tag[to].reserve, upd.reserve[1]) << failed_case;\n+      EXPECT_EQ(diff.tag[to].commit, upd.commit[1]) << failed_case;\n+    }\n+  }\n+\n+  template<int N>\n+  void create_tree(Tree& tree, ExpectedTree<N>& et, int line_no) {\n+    using SIndex = NativeCallStackStorage::StackIndex;\n+    const SIndex ES = NativeCallStackStorage::invalid; \/\/ Empty Stack\n+    VMATree::IntervalChange st;\n+    for (int i = 0; i < N; i++) {\n+      st.in.set_type(et.states[i]);\n+      st.in.set_tag(et.tags[i]);\n+      if (et.res_si[i] >= 0) {\n+        st.in.set_reserve_stack(et.res_si[i]);\n+      } else {\n+        st.in.set_reserve_stack(ES);\n+      }\n+      if (et.com_si[i] >= 0) {\n+        st.in.set_commit_stack(et.com_si[i]);\n+      } else {\n+        st.in.set_commit_stack(ES);\n+      }\n+\n+      st.out.set_type(et.states[i+1]);\n+      st.out.set_tag(et.tags[i+1]);\n+      if (et.res_si[i+1] >= 0) {\n+        st.out.set_reserve_stack(et.res_si[i+1]);\n+      } else {\n+        st.out.set_reserve_stack(ES);\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        st.out.set_commit_stack(et.com_si[i+1]);\n+      } else {\n+        st.out.set_commit_stack(ES);\n+      }\n+      tree.tree().upsert((VMATree::position)et.nodes[i], st);\n+    }\n+    print_tree(et, line_no);\n+}\n+\n+  template <int N>\n+  void check_tree(Tree& tree, const ExpectedTree<N>& et, int line_no) {\n+    using Node = VMATree::TreapNode;\n+    auto left_released = [&](Node n) -> bool {\n+      return n.val().in.type() == VMATree::StateType::Released and\n+            n.val().in.mem_tag() == mtNone;\n+    };\n+    auto right_released = [&](Node n) -> bool {\n+      return n.val().out.type() == VMATree::StateType::Released and\n+            n.val().out.mem_tag() == mtNone;\n+    };\n+    for (int i = 0; i < N; i++) {\n+      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n+      ASSERT_TRUE(r.start != nullptr);\n+      Node node = *r.start;\n+      ASSERT_EQ(node.key(), (VMATree::position)et.nodes[i]) << \"at line \" << line_no;\n+      if (i == (N -1)) { \/\/ last node\n+        EXPECT_TRUE(right_released(node)) << \"right-of last node is not Released\";\n+        break;\n+      }\n+      if (i == 0) { \/\/ first node\n+        EXPECT_TRUE(left_released(node)) << \"left-of first node is not Released\";\n+      }\n+      stringStream ss(50);\n+      ss.print(\"test at line: %d, for node: %d\", line_no, et.nodes[i]);\n+      const char* for_this_node = ss.base();\n+      EXPECT_EQ(node.val().out.type(), et.states[i+1]) << for_this_node;\n+      EXPECT_EQ(node.val().out.mem_tag(), et.tags[i+1]) << for_this_node;\n+      if (et.res_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.reserved_stack(), et.res_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_reserved_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_reserved_stack()) << for_this_node;\n+      }\n+      if (et.com_si[i+1] >= 0) {\n+        EXPECT_EQ(node.val().out.committed_stack(), et.com_si[i+1]) << for_this_node;\n+        EXPECT_EQ(r.end->val().in.committed_stack(), et.com_si[i+1]) << for_this_node;\n+      } else {\n+        EXPECT_FALSE(node.val().out.has_committed_stack()) << for_this_node;\n+        EXPECT_FALSE(r.end->val().in.has_committed_stack()) << for_this_node;\n+      }\n+    }\n+    print_tree(et, line_no);\n+  }\n+\n+  template<int N>\n+  void print_tree(const ExpectedTree<N>& et, int line_no) {\n+    const State Rs = State::Reserved;\n+    const State Rl = State::Released;\n+    const State C = State::Committed;\n+    stringStream ss;\n+    ss.print_cr(\"Tree nodes for line %d\", line_no);\n+    ss.print_cr(\"    \/\/            1         2         3         4         5\");\n+    ss.print_cr(\"    \/\/  012345678901234567890123456789012345678901234567890\");\n+    ss.print   (\"    \/\/  \");\n+    int j = 0;\n+    for (int i = 0; i < N; i++) {\n+      char state_char = et.states[i+1] == Rl ? '.' :\n+                        et.states[i+1] == Rs ? 'r' :\n+                        et.states[i+1] ==  C ? 'C' : ' ';\n+      if (i == 0 && et.nodes[i] != 0) {\n+        for (j = 0; j < et.nodes[i]; j++) {\n+          ss.put('.');\n+        }\n+      }\n+      for (j = et.nodes[i]; i < (N - 1) && j < et.nodes[i + 1]; j++) {\n+        ss.put(state_char);\n+      }\n+    }\n+    for (; j <= 50; j++) {\n+      ss.put('.');\n+    }\n+    tty->print_cr(\"%s\", ss.base());\n+  }\n@@ -182,1 +349,1 @@\n-TEST_VM_F(NMTVMATreeTest, UseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, UseTagInplace) {\n@@ -184,5 +351,9 @@\n-  VMATree::RegionData rd1(si[0], mtTest);\n-  VMATree::RegionData rd2(si[1], mtNone);\n-  tree.reserve_mapping(0, 100, rd1);\n-  tree.commit_mapping(20, 50, rd2, true);\n-  tree.uncommit_mapping(30, 10, rd2);\n+  VMATree::RegionData rd_Test_cs0(si[0], mtTest);\n+  VMATree::RegionData rd_None_cs1(si[1], mtNone);\n+  tree.reserve_mapping(0, 100, rd_Test_cs0);\n+  \/\/ reserve:   0---------------------100\n+  \/\/ commit:        20**********70\n+  \/\/ uncommit:          30--40\n+  \/\/ post-cond: 0---20**30--40**70----100\n+  tree.commit_mapping(20, 50, rd_None_cs1, true);\n+  tree.uncommit_mapping(30, 10, rd_None_cs1);\n@@ -214,4 +385,4 @@\n-    VMATree::RegionData rd{si[0], mtTest };\n-    VMATree::RegionData rd2{si[1], mtNMT };\n-    tree.reserve_mapping(0, 100, rd);\n-    tree.reserve_mapping(100, 100, rd2);\n+    VMATree::RegionData rd_Test_cs0{si[0], mtTest};\n+    VMATree::RegionData rd_NMT_cs1{si[1], mtNMT};\n+    tree.reserve_mapping(0, 100, rd_Test_cs0);\n+    tree.reserve_mapping(100, 100, rd_NMT_cs1);\n@@ -225,4 +396,4 @@\n-    VMATree::RegionData rd{si[0], mtTest };\n-    VMATree::RegionData rd2{si[1], mtNMT };\n-    tree.commit_mapping(50, 50, rd2);\n-    tree.reserve_mapping(0, 100, rd);\n+    VMATree::RegionData rd_Test_cs0{si[0], mtTest};\n+    VMATree::RegionData rd_NMT_cs1{si[1], mtNMT};\n+    tree.commit_mapping(50, 50, rd_NMT_cs1);\n+    tree.reserve_mapping(0, 100, rd_Test_cs0);\n@@ -232,1 +403,1 @@\n-        EXPECT_EQ(x->val().out.regiondata().mem_tag, mtTest);\n+        EXPECT_EQ(x->val().out.reserved_regiondata().mem_tag, mtTest);\n@@ -241,6 +412,6 @@\n-    VMATree::RegionData rd{si[0], mtTest };\n-    VMATree::RegionData rd2{si[1], mtNMT };\n-    VMATree::RegionData rd3{si[0], mtNone };\n-    tree.reserve_mapping(0, 100, rd);\n-    tree.reserve_mapping(0, 50, rd2);\n-    tree.reserve_mapping(50, 50, rd3);\n+    VMATree::RegionData rd_Test_cs0{si[0], mtTest};\n+    VMATree::RegionData rd_NMT_cs1{si[1], mtNMT};\n+    VMATree::RegionData rd_None_cs0{si[0], mtNone};\n+    tree.reserve_mapping(0, 100, rd_Test_cs0);\n+    tree.reserve_mapping(0, 50, rd_NMT_cs1);\n+    tree.reserve_mapping(50, 50, rd_None_cs0);\n@@ -251,1 +422,1 @@\n-    Tree::RegionData rd{si[0], mtNMT};\n+    VMATree::RegionData rd_NMT_cs0{si[0], mtNMT};\n@@ -253,1 +424,1 @@\n-    tree.reserve_mapping(0, 500000, rd);\n+    tree.reserve_mapping(0, 500000, rd_NMT_cs0);\n@@ -261,2 +432,2 @@\n-    Tree::RegionData rd{si[0], mtNMT};\n-    VMATree::RegionData rd2{si[1], mtTest};\n+    VMATree::RegionData rd_NMT_cs0{si[0], mtNMT};\n+    VMATree::RegionData rd_Test_cs1{si[1], mtTest};\n@@ -264,2 +435,2 @@\n-    tree.reserve_mapping(0, 100, rd);\n-    tree.commit_mapping(0, 100, rd2);\n+    tree.reserve_mapping(0, 100, rd_NMT_cs0);\n+    tree.commit_mapping(0, 100, rd_Test_cs1);\n@@ -268,1 +439,1 @@\n-        EXPECT_EQ(mtTest, x->val().out.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().out.reserved_regiondata().mem_tag);\n@@ -271,1 +442,1 @@\n-        EXPECT_EQ(mtTest, x->val().in.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().in.reserved_regiondata().mem_tag);\n@@ -278,2 +449,2 @@\n-    Tree::RegionData rd{si[0], mtNMT};\n-    tree.reserve_mapping(0, 0, rd);\n+    VMATree::RegionData rd_NMT_cs0{si[0], mtNMT};\n+    tree.reserve_mapping(0, 0, rd_NMT_cs0);\n@@ -281,1 +452,1 @@\n-    tree.commit_mapping(0, 0, rd);\n+    tree.commit_mapping(0, 0, rd_NMT_cs0);\n@@ -292,1 +463,1 @@\n-    NCS::StackIndex stack;\n+    NCS::StackIndex reserve_stack;\n@@ -297,1 +468,1 @@\n-  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree, int line_no) {\n@@ -314,2 +485,2 @@\n-      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n-      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag()) << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag()) << \" and at test-line: \" << line_no;\n@@ -317,2 +488,2 @@\n-      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n-      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      EXPECT_EQ(expect.reserve_stack, found.start->val().out.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.reserve_stack, found.end->val().in.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n@@ -327,0 +498,2 @@\n+  NCS::StackIndex es = NCS::invalid; \/\/ empty or no stack is stored\n+\n@@ -340,1 +513,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -356,0 +529,7 @@\n+    \/\/ 0---------------------------------------------------600\n+    \/\/        100****225\n+    \/\/                           550***560\n+    \/\/                                       565***575\n+    \/\/ 0------100****225---------550***560---565***575-----600\n+    \/\/ 0------100****225---500---550***560---565***575-----600\n+    \/\/ <-------mtGC---------><-----------mtClassShared------->\n@@ -364,1 +544,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -377,1 +557,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -393,1 +573,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -406,1 +586,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -421,1 +601,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -427,1 +607,1 @@\n-        {50,  75,        mtNone, si, State::Released},\n+        {50,  75,        mtNone, es, State::Released},\n@@ -436,1 +616,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -447,1 +627,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -453,1 +633,1 @@\n-        { 1,  50, mtNone, si, State::Released},\n+        { 1,  50, mtNone, es, State::Released},\n@@ -455,1 +635,1 @@\n-        {75,  99, mtNone, si, State::Released},\n+        {75,  99, mtNone, es, State::Released},\n@@ -464,1 +644,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -471,2 +651,2 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n-    Tree::RegionData rd2(NCS::StackIndex(), mtNMT);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_NMT_cs0(NCS::StackIndex(), mtNMT);\n@@ -474,1 +654,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -477,1 +663,9 @@\n-    all_diff = tree.reserve_mapping(50, 25, rd2);\n+    all_diff = tree.reserve_mapping(50, 25, rd_NMT_cs0);\n+\/\/              1         2         3         4         5         6         7         8         9         10         11\n+\/\/    01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCC..........\n+\/\/    Legend:\n+\/\/     A - Test (reserved)\n+\/\/     B - Native Memory Tracking (reserved)\n+\/\/     C - Test (reserved)\n+\/\/     . - free\n@@ -484,1 +678,1 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n@@ -486,1 +680,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -490,0 +690,4 @@\n+\/\/            1         2         3         4         5         6         7         8         9         10        11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  ..............................................................................................................\n+\/\/  Legend:\n@@ -494,1 +698,1 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n@@ -496,1 +700,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -499,1 +709,7 @@\n-    all_diff = tree.commit_mapping(0, 100, rd);\n+    all_diff = tree.commit_mapping(0, 100, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7         8         9         10         11\n+\/\/  01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n@@ -505,1 +721,1 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n@@ -507,1 +723,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 10, rd_Test_cs0);\n+\/\/            1         2\n+\/\/  01234567890123456789\n+\/\/  AAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -509,2 +731,8 @@\n-    EXPECT_EQ(diff.reserve, 100);\n-    all_diff = tree.reserve_mapping(100, 100, rd);\n+    EXPECT_EQ(diff.reserve, 10);\n+    all_diff = tree.reserve_mapping(10, 10, rd_Test_cs0);\n+\/\/            1         2         3\n+\/\/  012345678901234567890123456789\n+\/\/  AAAAAAAAAAAAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -512,1 +740,1 @@\n-    EXPECT_EQ(100, diff.reserve);\n+    EXPECT_EQ(10, diff.reserve);\n@@ -515,2 +743,2 @@\n-  Tree::RegionData rd(NCS::StackIndex(), mtTest);\n-    Tree::RegionData rd2(NCS::StackIndex(), mtNMT);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n+    Tree::RegionData rd_NMT_cs0(NCS::StackIndex(), mtNMT);\n@@ -518,1 +746,7 @@\n-    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 100, rd);\n+    VMATree::SummaryDiff all_diff = tree.reserve_mapping(0, 10, rd_Test_cs0);\n+\/\/            1         2\n+\/\/  01234567890123456789\n+\/\/  AAAAAAAAAA..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  . - free\n@@ -520,2 +754,9 @@\n-    EXPECT_EQ(diff.reserve, 100);\n-    all_diff = tree.reserve_mapping(100, 100, rd2);\n+    EXPECT_EQ(diff.reserve, 10);\n+    all_diff = tree.reserve_mapping(10, 10, rd_NMT_cs0);\n+\/\/            1         2         3\n+\/\/  012345678901234567890123456789\n+\/\/  AAAAAAAAAABBBBBBBBBB..........\n+\/\/  Legend:\n+\/\/  A - Test (reserved)\n+\/\/  B - Native Memory Tracking (reserved)\n+\/\/  . - free\n@@ -525,1 +766,1 @@\n-    EXPECT_EQ(100, diff.reserve);\n+    EXPECT_EQ(10, diff.reserve);\n@@ -531,6 +772,24 @@\n-    Tree::RegionData rd(NCS::StackIndex(), mtTest);\n-    tree.commit_mapping(128, 128, rd);\n-    tree.commit_mapping(512, 128, rd);\n-    VMATree::SummaryDiff diff = tree.commit_mapping(0, 1024, rd);\n-    EXPECT_EQ(768, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-    EXPECT_EQ(768, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+    Tree::RegionData rd_Test_cs0(NCS::StackIndex(), mtTest);\n+    tree.commit_mapping(16, 16, rd_Test_cs0);\n+\/\/            1         2         3         4\n+\/\/  0123456789012345678901234567890123456789\n+\/\/  ................aaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    tree.commit_mapping(32, 32, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  ................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    VMATree::SummaryDiff diff = tree.commit_mapping(0, 64, rd_Test_cs0);\n+\/\/            1         2         3         4         5         6         7\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789\n+\/\/  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..........\n+\/\/  Legend:\n+\/\/  a - Test (committed)\n+\/\/  . - free\n+    EXPECT_EQ(16, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+    EXPECT_EQ(16, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n@@ -716,4 +975,15 @@\n-        const NativeCallStack& start_stack = ncss.get(startn->val().out.stack());\n-        const NativeCallStack& end_stack = ncss.get(endn->val().in.stack());\n-        ASSERT_TRUE(starti.stack.equals(start_stack));\n-        ASSERT_TRUE(endi.stack.equals(end_stack));\n+        const NativeCallStack& start_stack = ncss.get(startn->val().out.reserved_stack());\n+        const NativeCallStack& end_stack = ncss.get(endn->val().in.reserved_stack());\n+        \/\/ If start-node of a reserved region is committed, the stack is stored in the second_stack of the node.\n+        if (startn->val().out.has_committed_stack()) {\n+          const NativeCallStack& start_second_stack = ncss.get(startn->val().out.committed_stack());\n+          ASSERT_TRUE(starti.stack.equals(start_stack) || starti.stack.equals(start_second_stack));\n+        } else {\n+          ASSERT_TRUE(starti.stack.equals(start_stack));\n+        }\n+        if (endn->val().in.has_committed_stack()) {\n+          const NativeCallStack& end_second_stack = ncss.get(endn->val().in.committed_stack());\n+          ASSERT_TRUE(endi.stack.equals(end_stack) || endi.stack.equals(end_second_stack));\n+        } else {\n+          ASSERT_TRUE(endi.stack.equals(end_stack));\n+        }\n@@ -728,1 +998,1 @@\n-TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseFlagInplace) {\n+TEST_VM_F(NMTVMATreeTest, SummaryAccountingWhenUseTagInplace) {\n@@ -730,4 +1000,13 @@\n-  VMATree::RegionData rd1(si[0], mtTest);\n-  VMATree::RegionData rd2(si[1], mtNone);\n-  tree.reserve_mapping(0, 100, rd1);\n-  VMATree::SummaryDiff diff = tree.commit_mapping(0, 50, rd2, true);\n+  VMATree::RegionData rd_Test_cs0(si[0], mtTest);\n+  VMATree::RegionData rd_None_cs1(si[1], mtNone);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  ..................................................\n+  tree.reserve_mapping(0, 50, rd_Test_cs0);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+VMATree::SummaryDiff diff = tree.commit_mapping(0, 25, rd_None_cs1, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  CCCCCCCCCCCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrr\n@@ -735,2 +1014,6 @@\n-  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-  diff = tree.commit_mapping(60, 10, rd2, true);\n+  EXPECT_EQ(25, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+\n+  diff = tree.commit_mapping(30, 5, rd_None_cs1, true);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  CCCCCCCCCCCCCCCCCCCCCCCCCrrrrrCCCCCrrrrrrrrrrrrrrr\n@@ -738,2 +1021,6 @@\n-  EXPECT_EQ(10, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n-  diff = tree.uncommit_mapping(0, 50, rd2);\n+  EXPECT_EQ(5, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+\n+  diff = tree.uncommit_mapping(0, 25, rd_None_cs1);\n+\/\/            1         2         3         4         5\n+\/\/  012345678901234567890123456789012345678901234567890\n+\/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrCCCCCrrrrrrrrrrrrrrr\n@@ -741,1 +1028,960 @@\n-  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  EXPECT_EQ(-25, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+\/\/ How the memory regions are visualized:\n+\/\/            1         2         3         4         5         6         7       |\n+\/\/  0123456789012345678901234567890123456789012345678901234567890123456789        |_> memory address\n+\/\/  aaaaaaBBBBBBBcccccccDDDDDDDeeeeeeeFFFFFFFF...........................         |->some letters showing the state of the memory\n+\/\/ Legend:\n+\/\/ . - None (free\/released)\n+\/\/ r - MemTag (reserved)\n+\/\/ C - MemTag (committed)\n+\/\/ MemTag is Test if omitted.\n+\n+TEST_VM_F(NMTVMATreeTest, SeparateStacksForCommitAndReserve) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+\n+  {\/\/ Check committing into a reserved region inherits the call stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1); \/\/ reserve in an empty tree\n+    \/\/ Pre: empty tree.\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr.\n+    ExpectedTree<2> et1 = {{     0,     50        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+    tree.commit_mapping(25, 10, rd_None_cs2, true); \/\/ commit at the middle of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrCCCCCCCCCCrrrrrrrrrrrrrrr.\n+    ExpectedTree<4> et2 = {{     0,     25,     35,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+\n+    tree.commit_mapping(0, 20, rd_None_cs2, true); \/\/ commit at the beginning of the region\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCCrrrrrCCCCCCCCCCrrrrrrrrrrrrrrr.\n+    ExpectedTree<5> et3 = {{     0,     20,     25,     35,    50         },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et3, __LINE__);\n+\n+    tree.commit_mapping(40, 10, rd_None_cs2, true); \/\/ commit at the end of the region\n+    \/\/ Post:\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCCrrrrrCCCCCCCCCCrrrrrCCCCCCCCCC.\n+    ExpectedTree<6> et4 = {{     0,     20,     25,     35,     40,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , C     , Rs    , C     , Rs    , C     , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , si_2  , -1    , si_2  , -1    , si_2  , -1    }};\n+    check_tree(tree, et4, __LINE__);\n+  }\n+  {\/\/ committing overlapped regions does not destroy the old call-stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1); \/\/ reserving in an empty tree\n+    \/\/ Pre: empty tree.\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<2> et1 = {{      0  , 50         },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.commit_mapping(10, 10, rd_None_cs2, true);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<4> et2 = {{     0,     10,     20,    50         },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+\n+    SIndex si_3 = si[2];\n+    VMATree::RegionData rd_Test_cs3(si_3, mtTest);\n+    \/\/ commit with overlap at the region's start\n+    tree.commit_mapping(5, 10, rd_Test_cs3);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<5> et3 = {{     0,      5,     15,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_3  , si_2  , -1    , -1    }};\n+    check_tree(tree, et3, __LINE__);\n+\n+    SIndex si_4 = si[3];\n+    VMATree::RegionData call_stack_4(si_4, mtTest);\n+    \/\/ commit with overlap at the region's end\n+    tree.commit_mapping(15, 10, call_stack_4);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<5> et4 = {{     0,      5,     15,     25,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_3  , si_4  , -1    , -1    }};\n+    check_tree(tree, et4, __LINE__);\n+  }\n+  {\/\/ uncommit should not store any call-stack\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1);\n+\n+    tree.commit_mapping(10, 10, rd_None_cs2, true);\n+\n+    tree.commit_mapping(0, 5, rd_None_cs2, true);\n+\n+    tree.uncommit_mapping(0, 3, rd_None_cs2);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrCCrrrrrCCCCCCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<6> et1 = {{     0,     3,       5,     10,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+\n+    tree.uncommit_mapping(5, 10, rd_None_cs2);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrCCrrrrrrrrrrCCCCCrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr.\n+    ExpectedTree<6> et2 = {{     0,      3,      5,     15,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , C     , Rs    , C     , Rs    , Rl    },\n+                           {-1    , si_1  , si_1  , si_1  , si_1  , si_1  , -1    },\n+                           {-1    , -1    , si_2  , -1    , si_2  , -1    , -1    }};\n+    check_tree(tree, et2, __LINE__);\n+  }\n+  {\/\/ reserve after reserve, but only different call-stacks\n+    SIndex si_4 = si[3];\n+    VMATree::RegionData call_stack_4(si_4, mtTest);\n+\n+    Tree tree;\n+    tree.reserve_mapping(0, 50, rd_Test_cs1);\n+    tree.reserve_mapping(10, 10, call_stack_4);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<4> et1 = {{     0,     10,     20,     50        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_4  , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }};\n+    check_tree(tree, et1, __LINE__);\n+  }\n+  {\/\/ commit without reserve\n+    Tree tree;\n+    tree.commit_mapping(0, 50, rd_Test_cs1);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n+    ExpectedTree<2> et = {{     0,      50       },\n+                          {mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    },\n+                          {-1    , si_1  , -1    }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\/\/ reserve after commit\n+    Tree tree;\n+    tree.commit_mapping(0, 50, rd_None_cs2);\n+    tree.reserve_mapping(0, 50, rd_Test_cs1);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\n+    ExpectedTree<2> et = {{     0,      50       },\n+                          {mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    },\n+                          {-1    , -1    , -1    }};\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows0To3) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  \/\/ row  0:  .........A..................B.....\n+  \/\/ case of empty tree is already covered in other tests.\n+  \/\/ row 1 is impossible. See the implementation.\n+  {\n+    \/\/ row  2:  .........A...Y.......................W.....B..........\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    Tree tree;\n+    ExpectedTree<5> pre = {{    10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC..........................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     25        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  3:  .........A...Y.......................WB.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<5> pre = {{    10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 5);\n+    ExpectedTree<6> et = {{   5,      10,     12,     14,     16,      20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows4to7) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  {\n+    \/\/ row  4:  .....X...A..................B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(20, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr..........CCCCCCCCCCCCCCCCCCCC...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<4> et = {{     0,     10,     20,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  5:  .....X...A...YW.............B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrrrrrr....................................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     5,     15,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 10, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 10);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20 - 15);\n+    ExpectedTree<4> et = {{     5,     10,     15,     20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  6:  .....X...A.....Y.......................W.....B...\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,      5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCCCCCCCCC........................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<8> et = {{     0,      5,      7,    10,      12,     14,     16,     27        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  7:  .....X...A...Y.......................WB.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<7> pre = {{     0,      5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 13, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 13);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 3);\n+    ExpectedTree<8> et = {{     0,      5,      7,     10,     12,     14,     16,     20        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows8to11) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+  {\n+    \/\/ row  8:  ........XA..................B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    \/\/ nodes:   0--------50...........................\n+    \/\/            si1\n+    \/\/            -\n+    \/\/ request:          50*****************250\n+    \/\/ post:    0--------50*****************250\n+    \/\/            si1        si2\n+    \/\/            -          si2\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCCCCCCCCCCC.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<3> et = {{     0,     10,     30        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , -1    , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row  9:  ........XA....YW.............B.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.........................................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{     0,     10,       },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(0, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  CCCCCCCCCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<3> et = {{     0,     10,     20        },\n+                          {mtNone, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rl    },\n+                          {-1    , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 10:  ........XA...Y.......................W.....B...\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrrrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<6> pre = {{     5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC..........................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 25 - 20);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     25        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 11:  ........XA...Y.......................WB.....\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....rrrrrrrrrrrrrrr...............................\n+    Tree tree;\n+    ExpectedTree<6> pre = {{     5,     10,     12,     14,     16,     20        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rs    , Rl    },\n+                           {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCC...............................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 0);\n+    ExpectedTree<6> et = {{     5,     10,     12,     14,     16,     20        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows12to15) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  {\n+    \/\/ row 12:  .........A..................B.....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..............................rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    30,     40        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20);\n+    ExpectedTree<4> et = {{     5,     25,     30,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 13:  .........A...YW.............B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrrrrrrrrrrrr.....................\n+    Tree tree;\n+    ExpectedTree<2> pre = {{    10,     30        },\n+                           {mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    },\n+                           {-1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCCrrrrr.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 30 - 25);\n+    ExpectedTree<4> et = {{     5,     10,     25,     30        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 14:  .........A...Y.......................W....B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<7> pre = {{    10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, (10 - 5) + ( 25 - 20));\n+    ExpectedTree<8> et = {{     5,     10,     12,     14,     16,     25,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 15:  .........A...Y.......................WB....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  ..........rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<7> pre = {{    10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  .....CCCCCCCCCCCCCCC..........rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10 - 5);\n+    ExpectedTree<8> et = {{     5,     10,     12,     14,     16,     20,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows16to19) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+  {\n+    \/\/ row 16:  .....X...A..................B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr....................rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,    10,      30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(15, 10, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.....CCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 10);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10);\n+    ExpectedTree<6> et = {{     0,     10,     15,     25,     30,     40        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 17:  .....X...A...YW.............B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr..........rrrrrrrrrr.....................\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,     20,     30        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(15, 10, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr.....CCCCCCCCCCrrrrr.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 10);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20 - 15);\n+    ExpectedTree<6> et = {{     0,     10,     15,     20,     25,     30        },\n+                          {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , Rl    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , -1    , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 18:  ....X....A...Y.......................W....B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCCCCCCCCC...rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, (10 - 7) + (27 - 20));\n+    ExpectedTree<10> et = {{     0,      5,      7,     12,     14,     16,     20,     27,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 19:  .....X...A...Y.......................WB....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(7, 13, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr..CCCCCCCCCCCCC..........rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 13);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10 - 7);\n+    ExpectedTree<10> et = {{     0,      5,      7,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, OverlapTableRows20to23) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  using State = VMATree::StateType;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+  SIndex si_3 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  VMATree::RegionData rd_Test_cs1(si_1, mtTest);\n+  VMATree::RegionData rd_None_cs1(si_1, mtNone);\n+  VMATree::RegionData rd_Test_cs2(si_2, mtTest);\n+  VMATree::RegionData rd_None_cs2(si_2, mtNone);\n+  VMATree::RegionData rd_None_cs3(si_3, mtNone);\n+\n+  {\n+    \/\/ row 20:  ........XA..................B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr....................rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,      30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 15);\n+    ExpectedTree<5> et = {{     0,     10,     25,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 21:  ........XA...YW.............B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrr..........rrrrrrrrrr.....................\n+    Tree tree;\n+    ExpectedTree<4> pre = {{     0,     10,     20,     30        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(10, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrrrrrrCCCCCCCCCCCCCCCrrrrr.....................\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 20 - 10);\n+    ExpectedTree<5> et = {{     0,     10,     20,     25,     30        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 22:  ........XA...Y.......................W....B....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_2  , si_1  , si_2  , si_1  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 20, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCCCCCCC.....rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 20);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, (10 - 5) + (25 - 20));\n+    ExpectedTree<9> et = {{     0,      5,     12,     14,     16,     20,    25,      30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+  {\n+    \/\/ row 23:  ........XA...Y.......................WB....U\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrr.....rrrrrrrrrr..........rrrrrrrrrr...........\n+    Tree tree;\n+    ExpectedTree<9> pre = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                           {mtNone, mtTest, mtNone, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                           {Rl    , Rs    , Rl    , Rs    , Rs    , Rs    , Rs    , Rl    , Rs    , Rl    },\n+                           {-1    , si_1  , -1    , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                           {-1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    , -1    }\n+                          };\n+    create_tree(tree, pre, __LINE__);\n+    VMATree::SummaryDiff diff = tree.commit_mapping(5, 15, rd_Test_cs2, false);\n+    \/\/            1         2         3         4         5\n+    \/\/  012345678901234567890123456789012345678901234567890\n+    \/\/  rrrrrCCCCCCCCCCCCCCC..........rrrrrrrrrr...........\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].commit, 15);\n+    EXPECT_EQ(diff.tag[NMTUtil::tag_to_index(mtTest)].reserve, 10 - 5);\n+    ExpectedTree<9> et = {{     0,      5,     10,     12,     14,     16,     20,     30,     40        },\n+                          {mtNone, mtTest, mtTest, mtTest, mtTest, mtTest, mtTest, mtNone, mtTest, mtNone},\n+                          {Rl    , Rs    , C     , C     , C     , C     , C     , Rl    , Rs    , Rl    },\n+                          {-1    , si_1  , si_2  , si_1  , si_2  , si_1  , si_2  , -1    , si_1  , -1    },\n+                          {-1    , -1    , si_2  , si_2  , si_2  , si_2  , si_2  , -1    , -1    , -1    }\n+                         };\n+    check_tree(tree, et, __LINE__);\n+  }\n+\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, UpdateRegionTest) {\n+  using State = VMATree::StateType;\n+  using SIndex = VMATree::SIndex;\n+  SIndex ES = NativeCallStackStorage::invalid;\n+  SIndex s0 = si[0];\n+  SIndex s1 = si[1];\n+  SIndex s2 = si[2];\n+\n+  const State Rs = State::Reserved;\n+  const State Rl = State::Released;\n+  const State C = State::Committed;\n+  const int a = 100;\n+  const MemTag ReqTag = mtTest;\n+  const VMATree::RequestInfo       ReleaseRequest{0, a, Rl, mtNone, ES, false};\n+  const VMATree::RequestInfo       ReserveRequest{0, a, Rs, ReqTag, s2, false};\n+  const VMATree::RequestInfo        CommitRequest{0, a,  C, ReqTag, s2, false};\n+  const VMATree::RequestInfo      UncommitRequest{0, a, Rs, mtNone, ES, true};\n+  const VMATree::RequestInfo CopyTagCommitRequest{0, a,  C, ReqTag, s2, true};\n+                              \/\/  existing state           request              expected state     expected diff\n+                              \/\/ st   tag    stacks                           st   tag    stacks   reserve  commit\n+                              \/\/ --  ------  ------  ----------------------   --  ------  ------   -------  -------\n+  UpdateCallInfo  call_info[]={{{Rl, mtNone, ES, ES},        ReleaseRequest, {Rl, mtNone, ES, ES}, {0,  0}, {0,  0}},\n+                               {{Rl, mtNone, ES, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  a}, {0,  0}},\n+                               {{Rl, mtNone, ES, ES},         CommitRequest, { C, ReqTag, s2, s2}, {0,  a}, {0,  a}},\n+                               {{Rl, mtNone, ES, ES},  CopyTagCommitRequest, { C, mtNone, s2, s2}, {0,  a}, {0,  a}},\n+                               {{Rl, mtNone, ES, ES},       UncommitRequest, {Rl, mtNone, ES, ES}, {0,  0}, {0,  0}},\n+                               {{Rs,   mtGC, s0, ES},        ReleaseRequest, {Rl, mtNone, ES, ES}, {-a, 0}, {0,  0}},\n+                               {{Rs,   mtGC, s0, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {-a, a}, {0,  0}}, \/\/ diff tag\n+                               {{Rs, mtTest, s0, ES},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  0}, {0,  0}}, \/\/ same tag\n+                               {{Rs,   mtGC, s0, ES},         CommitRequest, { C, ReqTag, s0, s2}, {-a, a}, {0,  a}},\n+                               {{Rs,   mtGC, s0, ES},  CopyTagCommitRequest, { C,   mtGC, s0, s2}, {0,  0}, {0,  a}},\n+                               {{Rs,   mtGC, s0, ES},       UncommitRequest, {Rs,   mtGC, s0, ES}, {0,  0}, {0,  0}},\n+                               {{ C,   mtGC, s0, s1},        ReleaseRequest, {Rl, mtNone, ES, ES}, {-a, 0}, {-a, 0}},\n+                               {{ C,   mtGC, s0, s1},        ReserveRequest, {Rs, ReqTag, s2, ES}, {-a, a}, {-a, 0}}, \/\/ diff tag\n+                               {{ C, mtTest, s0, s1},        ReserveRequest, {Rs, ReqTag, s2, ES}, {0,  0}, {-a, 0}}, \/\/ same tag\n+                               {{ C,   mtGC, s0, s1},         CommitRequest, { C, ReqTag, s0, s2}, {-a, a}, {-a, a}},\n+                               {{ C,   mtGC, s0, s1},  CopyTagCommitRequest, { C,   mtGC, s0, s2}, {0,  0}, {-a, a}},\n+                               {{ C,   mtGC, s0, s1},       UncommitRequest, {Rs,   mtGC, s0, ES}, {0,  0}, {-a, 0}}\n+                              };\n+  for (auto ci : call_info) {\n+    call_update_region(ci);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":1338,"deletions":92,"binary":false,"changes":1430,"status":"modified"}]}