{"files":[{"patch":"@@ -94,1 +94,1 @@\n-        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n+        _stack_storage.get(prev->val().out.reserved_stack()).print_on(stream);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-\n-private:\n@@ -50,1 +48,0 @@\n-public:\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,15 @@\n+  bool is_reserve_operation = state == StateType::Reserved && !use_tag_inplace;\n+  bool is_uncommit_operation = state == StateType::Reserved && use_tag_inplace;\n+  bool is_commit_operation = state == StateType::Committed;\n+  if (is_reserve_operation) {\n+    stA.out.set_reserve_stack(metadata.stack_idx);\n+    stB.in.set_reserve_stack(metadata.stack_idx);\n+    stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n+    stA.in.set_commit_stack(NativeCallStackStorage::invalid);\n+  }\n+  if (is_commit_operation) {\n+    stA.out.set_commit_stack(metadata.stack_idx);\n+    stB.in.set_commit_stack(metadata.stack_idx);\n+    stA.out.set_reserve_stack(NativeCallStackStorage::invalid);\n+    stB.in.set_reserve_stack(NativeCallStackStorage::invalid);\n+  }\n@@ -89,0 +104,9 @@\n+      if (is_commit_operation) {\n+        if (leqA_n->val().out.has_reserved_stack()) {\n+          stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n+        }\n+      }\n+      if (is_uncommit_operation) {\n+        stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n+        stA.out.set_commit_stack(NativeCallStackStorage::invalid);\n+      }\n@@ -112,0 +136,4 @@\n+      if (is_commit_operation) {\n+        stA.out.set_reserve_stack(leqA_n->val().out.reserved_stack());\n+        stB.in.set_reserve_stack(leqA_n->val().out.reserved_stack());\n+      }\n@@ -271,1 +299,1 @@\n-    RegionData new_data = RegionData(out.stack(), tag);\n+    RegionData new_data = RegionData(out.reserved_stack(), tag);\n@@ -292,1 +320,1 @@\n-      RegionData new_data = RegionData(out.stack(), tag);\n+      RegionData new_data = RegionData(out.reserved_stack(), tag);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    NativeCallStackStorage::StackIndex sidx;\n+    NativeCallStackStorage::StackIndex _reserved_stack;\n+    NativeCallStackStorage::StackIndex _committed_stack;\n@@ -97,1 +98,1 @@\n-    IntervalState() : type_tag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, _reserved_stack(NativeCallStackStorage::invalid), _committed_stack(NativeCallStackStorage::invalid) {}\n@@ -102,1 +103,2 @@\n-      sidx = data.stack_idx;\n+      _reserved_stack = data.stack_idx;\n+      _committed_stack = NativeCallStackStorage::invalid;\n@@ -113,2 +115,5 @@\n-    RegionData regiondata() const {\n-      return RegionData{sidx, mem_tag()};\n+    RegionData reserved_regiondata() const {\n+      return RegionData{_reserved_stack, mem_tag()};\n+    }\n+    RegionData committed_regiondata() const {\n+      return RegionData{_committed_stack, mem_tag()};\n@@ -121,2 +126,22 @@\n-    NativeCallStackStorage::StackIndex stack() const {\n-     return sidx;\n+    NativeCallStackStorage::StackIndex reserved_stack() const {\n+      return _reserved_stack;\n+    }\n+\n+    NativeCallStackStorage::StackIndex committed_stack() const {\n+      return _committed_stack;\n+    }\n+\n+    void set_reserve_stack(NativeCallStackStorage::StackIndex idx) {\n+      _reserved_stack = idx;\n+    }\n+\n+    void set_commit_stack(NativeCallStackStorage::StackIndex idx) {\n+      _committed_stack = idx;\n+    }\n+\n+    bool has_reserved_stack() {\n+      return _reserved_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    bool has_committed_stack() {\n+      return _committed_stack != NativeCallStackStorage::invalid;\n@@ -134,1 +159,2 @@\n-             RegionData::equals(in.regiondata(), out.regiondata());\n+             RegionData::equals(in.reserved_regiondata(), out.reserved_regiondata()) &&\n+             RegionData::equals(in.committed_regiondata(), out.committed_regiondata());\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  constexpr static const int si_len = 2;\n+  constexpr static const int si_len = 3;\n@@ -46,0 +46,1 @@\n+    stacks[1] = make_stack(0xC);\n@@ -47,1 +48,2 @@\n-    si[1] = ncs.push(stacks[0]);\n+    si[1] = ncs.push(stacks[1]);\n+    si[2] = ncs.push(stacks[2]);\n@@ -232,1 +234,1 @@\n-        EXPECT_EQ(x->val().out.regiondata().mem_tag, mtTest);\n+        EXPECT_EQ(x->val().out.reserved_regiondata().mem_tag, mtTest);\n@@ -268,1 +270,1 @@\n-        EXPECT_EQ(mtTest, x->val().out.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().out.reserved_regiondata().mem_tag);\n@@ -271,1 +273,1 @@\n-        EXPECT_EQ(mtTest, x->val().in.regiondata().mem_tag);\n+        EXPECT_EQ(mtTest, x->val().in.reserved_regiondata().mem_tag);\n@@ -292,1 +294,1 @@\n-    NCS::StackIndex stack;\n+    NCS::StackIndex reserve_stack;\n@@ -297,1 +299,1 @@\n-  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree, int line_no) {\n@@ -317,2 +319,2 @@\n-      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n-      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      EXPECT_EQ(expect.reserve_stack, found.start->val().out.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n+      EXPECT_EQ(expect.reserve_stack, found.end->val().in.reserved_stack()) << \"Unexpected stack at region: \" << i << \" and at test-line: \" << line_no;\n@@ -340,1 +342,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -364,1 +366,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -377,1 +379,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -393,1 +395,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -406,1 +408,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -421,1 +423,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -436,1 +438,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -447,1 +449,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -464,1 +466,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -716,4 +718,15 @@\n-        const NativeCallStack& start_stack = ncss.get(startn->val().out.stack());\n-        const NativeCallStack& end_stack = ncss.get(endn->val().in.stack());\n-        ASSERT_TRUE(starti.stack.equals(start_stack));\n-        ASSERT_TRUE(endi.stack.equals(end_stack));\n+        const NativeCallStack& start_stack = ncss.get(startn->val().out.reserved_stack());\n+        const NativeCallStack& end_stack = ncss.get(endn->val().in.reserved_stack());\n+        \/\/ If start-node of a reserved region is committed, the stack is stored in the second_stack of the node.\n+        if (startn->val().out.has_committed_stack()) {\n+          const NativeCallStack& start_second_stack = ncss.get(startn->val().out.committed_stack());\n+          ASSERT_TRUE(starti.stack.equals(start_stack) || starti.stack.equals(start_second_stack));\n+        } else {\n+          ASSERT_TRUE(starti.stack.equals(start_stack));\n+        }\n+        if (endn->val().in.has_committed_stack()) {\n+          const NativeCallStack& end_second_stack = ncss.get(endn->val().in.committed_stack());\n+          ASSERT_TRUE(endi.stack.equals(end_stack) || endi.stack.equals(end_second_stack));\n+        } else {\n+          ASSERT_TRUE(endi.stack.equals(end_stack));\n+        }\n@@ -742,0 +755,100 @@\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, SeparateStacksForCommitAndReserve) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  SIndex si_1 = si[0];\n+  SIndex si_2 = si[1];\n+\n+  VMATree::RegionData call_stack_1(si_1, mtTest);\n+  VMATree::RegionData call_stack_2(si_2, mtNone);\n+  auto expected =  [&](Tree& tree, int p, SIndex reserve_stack, SIndex commit_stack, int line_no = __LINE__) {\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(p);\n+    const char* at_line = \" at line: \";\n+    if (reserve_stack >= 0) {\n+      EXPECT_EQ(r.start->val().out.reserved_stack(), reserve_stack) << at_line << line_no;\n+      EXPECT_EQ(r.end->val().in.reserved_stack(), reserve_stack) << at_line << line_no;\n+    } else {\n+      EXPECT_FALSE(r.start->val().out.has_reserved_stack()) << at_line << line_no;\n+      EXPECT_FALSE(r.end->val().in.has_reserved_stack()) << at_line << line_no;\n+    }\n+    if (commit_stack >= 0) {\n+      EXPECT_EQ(r.start->val().out.committed_stack(), commit_stack) << at_line << line_no;\n+      EXPECT_EQ(r.end->val().in.committed_stack(), commit_stack) << at_line << line_no;\n+    } else {\n+      EXPECT_FALSE(r.start->val().out.has_committed_stack()) << at_line << line_no;\n+      EXPECT_FALSE(r.end->val().in.has_committed_stack()) << at_line << line_no;\n+    }\n+  };\n+\n+  {\/\/ Check committing into a reserved region inherits the call stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 100, call_stack_1);\n+    expected(tree,  0, si_1,   -1, __LINE__);\n+\n+    tree.commit_mapping(25, 25, call_stack_2, true); \/\/ commit at the middle of the region\n+    expected(tree,  0, si_1,   -1, __LINE__);\n+    expected(tree, 25, si_1, si_2, __LINE__);\n+    expected(tree, 50, si_1,   -1, __LINE__);\n+\n+    tree.commit_mapping(0, 20, call_stack_2, true); \/\/ commit at the begin of the region\n+    expected(tree, 0, si_1, si_2, __LINE__);\n+\n+    tree.commit_mapping(80, 20, call_stack_2, true); \/\/ commit at the end of the region\n+    expected(tree, 80, si_1, si_2, __LINE__);\n+  }\n+  {\/\/ committing overlapped regions does not destroy the old call-stacks\n+    Tree tree;\n+    tree.reserve_mapping(0, 100, call_stack_1); \/\/ Nodes: 0 - 100\n+    expected(tree, 0, si_1, -1, __LINE__);\n+\n+    tree.commit_mapping(20, 20, call_stack_2, true); \/\/ Nodes: 0 - 20 - 40 - 100\n+    expected(tree,  0, si_1,   -1, __LINE__);\n+    expected(tree, 20, si_1, si_2, __LINE__);\n+\n+    SIndex si_3 = si[2];\n+    VMATree::RegionData call_stack_3(si_3, mtTest);\n+    \/\/ commit with overlap at the region's start\n+    tree.commit_mapping(10, 20, call_stack_3); \/\/ Nodes: 0 - 10 - 40 - 100\n+    expected(tree, 10, si_1, si_3, __LINE__);\n+\n+    \/\/ commit with overlap at the region's end\n+    tree.commit_mapping(30, 20, call_stack_3); \/\/ Nodes: 0 - 10 - 50 - 100\n+    expected(tree, 30, si_1, si_3, __LINE__);\n+    tree.print_on(tty);\n+  }\n+  {\/\/ uncommit should not store any call-stack\n+    Tree tree;\n+    tree.reserve_mapping(0, 100, call_stack_1);\n+    expected(tree, 0, si_1, -1, __LINE__);\n+\n+    tree.commit_mapping(20, 20, call_stack_2, true);\n+    expected(tree,  0, si_1,   -1, __LINE__);\n+    expected(tree, 20, si_1, si_2, __LINE__);\n+\n+    tree.commit_mapping(0, 10, call_stack_2, true);\n+    expected(tree, 0, si_1, si_2, __LINE__);\n+\n+    tree.uncommit_mapping(0, 5, call_stack_2);\n+    expected(tree, 0, si_1, -1, __LINE__);\n+\n+    tree.uncommit_mapping(20, 10, call_stack_2);\n+    expected(tree, 20, si_1, -1, __LINE__);\n+  }\n+  {\/\/ reserve after reserve\n+    Tree tree;\n+    tree.reserve_mapping(0, 100, call_stack_1);\n+    tree.reserve_mapping(10, 10, call_stack_2);\n+    expected(tree,  0, si_1, -1, __LINE__);\n+    expected(tree, 10, si_2, -1, __LINE__);\n+  }\n+  {\/\/ commit without reserve\n+    Tree tree;\n+    tree.commit_mapping(0, 100, call_stack_1);\n+    expected(tree, 0, -1, si_1, __LINE__);\n+  }\n+  {\/\/ reserve after commit\n+    Tree tree;\n+    tree.commit_mapping(0, 100, call_stack_1);\n+    tree.reserve_mapping(0, 100, call_stack_2);\n+    expected(tree, 0, si_2, -1, __LINE__);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":135,"deletions":22,"binary":false,"changes":157,"status":"modified"}]}