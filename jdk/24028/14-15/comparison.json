{"files":[{"patch":"@@ -37,1 +37,1 @@\n-NativeCallStackStorage::StackIndex VMATree::new_reserve_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n+NativeCallStackStorage::StackIndex VMATree::get_new_reserve_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n@@ -59,1 +59,1 @@\n-NativeCallStackStorage::StackIndex VMATree::new_commit_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n+NativeCallStackStorage::StackIndex VMATree::get_new_commit_callstack(NativeCallStackStorage::StackIndex es, StateType ex, const RequestInfo& req){\n@@ -81,1 +81,1 @@\n-VMATree::StateType VMATree::new_state(StateType ex, const RequestInfo& req) {\n+VMATree::StateType VMATree::get_new_state(StateType ex, const RequestInfo& req) {\n@@ -103,1 +103,84 @@\n-VMATree::SummaryDiff VMATree::register_mapping_new(position A, position B, StateType state,\n+void VMATree::compute_summary_diff(SingleDiff::delta region_size, MemTag t1, const StateType& ex, const RequestInfo& req, MemTag t2, SummaryDiff& diff) {\n+  const StateType Rl = StateType::Released;\n+  const StateType Rs = StateType::Reserved;\n+  const StateType C = StateType::Committed;\n+  auto st_to_index = [&](StateType st) -> int {\n+    return\n+      st == StateType::Released ? 0 :\n+      st == StateType::Reserved ? 1 :\n+      st == StateType::Committed ? 2 : -1;\n+  };\n+  const int op = req.op_to_index();\n+  assert(op >= 0 && op < 4, \"should be\");\n+\n+  SingleDiff::delta a = region_size;\n+  \/\/ A region with size `a` has a state as <column> and an operation is requested as in <row>\n+  \/\/ The region has tag `t1` and the operation has tag `t2`.\n+  \/\/ For each state, we decide how much to be added\/subtracted from t1 to t2. Two tables for reserve and commit.\n+  \/\/ Each pair of <x,y> in the table means add `x` to t1 and add `y` to t2. There are 3 pairs in each row for 3 states.\n+  \/\/ For example, `reserve[1][4,5]` says `-a,a` means:\n+  \/\/    - we are reserving with t2 a region which is already commited with t1\n+  \/\/    - since we are reserving, then `a` will be added to t2. (`y` is `a`)\n+  \/\/    - since we uncommitting (by reserving) then `a` is to be subtracted from t1. (`x` is `-a`).\n+  \/\/    - amount of uncommitted size is in table `commit[1][4,5]` which is `-a,0` that means subtract `a` from t1.\n+                                       \/\/ existing state\n+  SingleDiff::delta reserve[4][3*2] = {\/\/ Rl    Rs     C\n+                                         {0,0, -a,0, -a,0 },   \/\/ op == Release\n+                                         {0,a, -a,a, -a,a },   \/\/ op == Reserve\n+                                         {0,a,  0,0,  0,0 },   \/\/ op == Commit\n+                                         {0,0,  0,0,  0,0 }    \/\/ op == Uncommit\n+                                      };\n+  SingleDiff::delta commit[4][3*2] = {\/\/ Rl    Rs     C\n+                                        {0,0,  0,0, -a,0 },   \/\/ op == Release\n+                                        {0,a,  0,a, -a,0 },   \/\/ op == Reserve\n+                                        {0,a,  0,a, -a,a },   \/\/ op == Commit\n+                                        {0,0,  0,0, -a,0 }    \/\/ op == Uncommit\n+                                     };\n+  SingleDiff& from_rescom = diff.tag[NMTUtil::tag_to_index(t1)];\n+  SingleDiff&   to_rescom = diff.tag[NMTUtil::tag_to_index(t2)];\n+  int st = st_to_index(ex);\n+  tty->print_cr(\"%d %d %d %d %ld %ld\", (int)t1, (int)t2, op, st, from_rescom.reserve, to_rescom.reserve);\n+  from_rescom.reserve += reserve[op][st * 2    ];\n+    to_rescom.reserve += reserve[op][st * 2 + 1];\n+  from_rescom.commit  +=  commit[op][st * 2    ];\n+    to_rescom.commit  +=  commit[op][st * 2 + 1];\n+\n+}\n+\n+void VMATree::update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n+  using SIndex = NativeCallStackStorage::StackIndex;\n+  IntervalState exSt; \/\/ existing state info\n+  assert(n1 != nullptr,\"sanity\");\n+  assert(n2 != nullptr,\"sanity\");\n+  if (n1->key() == req.A) {\n+    exSt = n1->val().in;\n+  } else {\n+    exSt = n1->val().out;\n+  }\n+\n+  StateType existing_state              = exSt.type();\n+  MemTag    existing_tag                = exSt.mem_tag();\n+  SIndex    existing_reserve_callstack  = exSt.reserved_stack();\n+  SIndex    existing_commit_callstack   = exSt.committed_stack();\n+\n+  StateType new_state                   = get_new_state(existing_state, req);\n+  MemTag    new_tag                     = req.use_tag_inplace ? existing_tag : req.tag;\n+  SIndex    new_reserve_callstack       = get_new_reserve_callstack(existing_reserve_callstack, existing_state, req);\n+  SIndex    new_committ_callstack       = get_new_reserve_callstack(existing_reserve_callstack, existing_state, req);\n+\n+  n1->val().out.set_tag(new_tag);\n+  n1->val().out.set_type(new_state);\n+  n1->val().out.set_commit_stack(new_committ_callstack);\n+  n1->val().out.set_reserve_stack(new_reserve_callstack);\n+\n+  n2->val().in.set_tag(new_tag);\n+  n2->val().in.set_type(new_state);\n+  n2->val().in.set_commit_stack(new_committ_callstack);\n+  n2->val().in.set_reserve_stack(new_reserve_callstack);\n+\n+  SingleDiff::delta region_size = n2->key() - n1->key();\n+  compute_summary_diff(region_size, existing_tag, existing_state, req, new_tag, diff);\n+}\n+\n+\n+VMATree::SummaryDiff VMATree::register_mapping(position A, position B, StateType state,\n@@ -106,0 +189,3 @@\n+  if (A == B) {\n+    return SummaryDiff();\n+  }\n@@ -107,1 +193,0 @@\n-  RequestInfo req{A, B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n@@ -109,0 +194,9 @@\n+  RequestInfo req{A, B, state, metadata.mem_tag, metadata.stack_idx, use_tag_inplace};\n+  IntervalChange stA{\n+      IntervalState{StateType::Released, empty_regiondata},\n+      IntervalState{              state,   metadata}\n+  };\n+  IntervalChange stB{\n+      IntervalState{              state,   metadata},\n+      IntervalState{StateType::Released, empty_regiondata}\n+  };\n@@ -111,13 +205,87 @@\n-  bool no_node_before_A = rA.start == nullptr;\n-  bool no_node_before_B = rB.start == nullptr;\n-  bool no_overlap_before = no_node_before_A && no_node_before_B;\n-  bool no_node_after_A = rA.end == nullptr;\n-  bool no_node_after_B = rB.end == nullptr;\n-  bool no_overlap_after = no_node_after_A && no_node_after_B;\n-  bool no_overlap = no_overlap_before || no_overlap_after;\n-  \/\/ ...............X....Y.....Z.............\n-  \/\/   ^--^        ^--------------^  ^----^\n-  \/\/   no-overlap     with-overlap    no-overlap\n-  if (no_overlap) {\n-    \/\/ just insert A and B\n-    return diff;\n+  \/\/ nodes:          .....X.......Y...Z......W........U\n+  \/\/ request:                 A------------------B\n+  \/\/ X,Y = enclosing_nodes(A)\n+  \/\/ W,U = enclosing_nodes(B)\n+  \/\/ The cases are whether or not X and Y exists and X == A. (A == Y doesn't happen since it is searched by 'lt' predicate)\n+  \/\/ The cases are whether or not W and U exists and W == B. (B == U doesn't happen since it is searched by 'lt' predicate)\n+\n+  \/\/ We update regions in 3 sections: 1) X..A..Y, 2) Y....W, 3) W..B..U\n+  \/\/ The regons in [Y,W) are updated in a loop. We update X..A..Y before the loop and W..B..U after the loop.\n+  \/\/ The table below summarizes the cases and what to do.\n+  \/\/ 'update'  for a region [a,b) means call 'update_region(node a, node b, req, diff)' to update the region based on existing State and the request.\n+\n+\n+  \/\/                                                                                              Regions before loop                                         Regions in\n+  \/\/                                                             X exists     Y exists    X == A   [X,A)         [A,Y)    remove X if        upsert A if       the loop                                    to do after loop\n+  \/\/                                                             --------     --------    ------   ------        -----    ---------------    --------------   -------------  ----------------------------------------------------------------\n+  \/\/ row  0: nodes:          .........A..................B.....  no             no        --       --            --        --                 !A_is_noop()        --\n+  \/\/ row  1: nodes:          .....X...A..................B.....  yes            no        no       A.in = X.out  --        --                 !A_is_noop()        --\n+  \/\/ row  2: nodes:          .....XA.....................B.....  yes            no        yes      A.in = X.in   --        X.in == A.out      !remove_X           --\n+  \/\/ row  3: nodes:          .........A...Y...Z......W...B....U  no             yes       --       --            update    --                 !A_is_noop()       [Y,W)\n+  \/\/ row  4: nodes:          .....X...A...Y...Z......W...B....U  yes            yes       no       A.in = X.out  update    --                 !A_is_noop()       [Y,W)\n+  \/\/ row  5: nodes:          .....XA......Y...Z......W...B....U  yes            yes       yes      A.in = X.in   update    X.in == A.out      !remove_X          [Y,W)\n+  \/\/       :\n+  \/\/       :                                                     W exists     U exists    W == B                                                                             [W,B)         [B,U)            remove W if       upsert B if\n+  \/\/       :                                                     --------     --------    ------   ------------------------------------------------------------------------  -----         ------          ----------------  ---------------\n+  \/\/ row  6: nodes:          .........A..................B.....   no            no          --                                                                                --            --              --                !B.is_noop()\n+  \/\/ row  7: nodes:          .........A..................B....U   no            yes         --                                                                                --           B.out = U.in     --                !B.is_noop()\n+  \/\/ row  8: nodes:          .....X...A...Y...Z......W...B.....   yes           no          no                                                                                update        --              W.is_noop()       !B.is_noop()\n+  \/\/ row  9: nodes:          .....X...A...Y...Z......WB........   yes           no          yes                                                                               --            --              W.in == B.out     !remove_W\n+  \/\/ row 10: nodes:          .....X...A...Y...Z......W...B....U   yes           yes         no                                                                                update       B.out = U.in     W.is_noop()       !B.is_noop()\n+  \/\/ row 11: nodes:          .....X...A...Y...Z......WB.......U   yes           yes         yes                                                                               --            --              W.in == B.out     !remove_W\n+\n+  \/\/ We intentionally did not summarize\/compress the cases to have them as separate. This expanded way of describing the cases helps us to understand\/analyze\/verify\/debug\/maintain the corresponding code more easily.\n+  \/\/ Mapping of table to row, row to switch-case, 'what to do' to code should be consistent. If one changes, the others have to be updated accordingly.\n+  \/\/ The sequence of dependecies is: table -> row no -> switch(row)-case -> code. Meaning that whenever any of one item in this sequence is changed, the rest of the consequent items to be checked\/changed.\n+\n+  TreapNode* X = rA.start;\n+  TreapNode* Y = rA.end;\n+  TreapNode nA{A, stA, 0}; \/\/ the node that represents A\n+  bool X_exists = X != nullptr;\n+  bool Y_exists = Y != nullptr;\n+  bool X_eq_A = X_exists && rA.start->key() == A;\n+  int row = -1;\n+  if (!X_exists && !Y_exists           ) { row = 0; }\n+  if ( X_exists && !Y_exists && !X_eq_A) { row = 1; }\n+  if ( X_exists && !Y_exists &&  X_eq_A) { row = 2; }\n+  if (!X_exists &&  Y_exists           ) { row = 3; }\n+  if (!X_exists &&  Y_exists && !X_eq_A) { row = 4; }\n+  if ( X_exists &&  Y_exists &&  X_eq_A) { row = 5; }\n+\n+  \/\/ ************************************************************************************ Before loop\n+  switch(row) {\n+    case 0:\n+      if (!stA.is_noop()) { _tree.upsert(A, stA); }\n+      break;\n+    case 1:\n+      stA.in = X->val().out;\n+      if (!stA.is_noop()) { _tree.upsert(A, stA); }\n+      break;\n+    case 2:\n+      stA.in = X->val().in;\n+      if (X->val().in.equals(stA.out)) {\n+        _tree.remove(X->key());\n+      } else {\n+        _tree.upsert(A, stA);\n+      }\n+      break;\n+    case 3:\n+      update_region(&nA, Y, req, diff);\n+      if (!nA.val().is_noop()) { _tree.upsert(A, nA.val()); }\n+      break;\n+    case 4:\n+      stA.in = X->val().out;\n+      update_region(&nA, Y, req, diff);\n+      if (!nA.val().is_noop()) { _tree.upsert(A, nA.val()); }\n+      break;\n+    case 5:\n+      stA.in = X->val().in;\n+      update_region(&nA, Y, req, diff);\n+      if (X->val().in.equals(stA.out)) {\n+        _tree.remove(X->key());\n+      } else {\n+        _tree.upsert(A, nA.val());\n+      }\n+      break;\n+    default:\n+      break;\n@@ -125,37 +293,64 @@\n-  \/\/ finding the X....Y region that overlaps with A---B\n-  \/\/ a--A--b---c---B---d\n-  const position impossible = -1;\n-  position X =   rA.start != nullptr ? rA.start->key()\n-               : rA.end   != nullptr ? rA.end->key()\n-               : rB.start != nullptr ? rB.start->key()\n-               : rB.end   != nullptr ? rB.end->key() : impossible;\n-  assert(X != impossible, \"should not\");\n-  TreapNode* nY = _tree.closest_gt(X);\n-  assert(nY != nullptr, \"should not\");\n-  position Y = nY->key();\n-\n-  enum overlap_case {         \/\/                      ........X..............Y......................\n-                     A_B_X_Y, \/\/ A < B < X < Y           A--B\n-                     A_BX__Y, \/\/ A < B = X < Y           A----B\n-                     A_X_B_Y, \/\/ A < X < B < Y           A--------B\n-                     A_X__BY, \/\/ A < X < Y = B           A-------------------B\n-                     A_X_Y_B, \/\/ A < X < Y < B           A-----------------------B\n-                     AX_B__Y, \/\/ A = X < B < Y                A----B\n-                     AX___BY, \/\/ A = X < B = Y                A--------------B\n-                     AX_Y__B, \/\/ A = X < Y < B                A--------------------B\n-                     X_A_B_Y, \/\/ X < A < B < Y                    A---B\n-                     X_A__BY, \/\/ X < A < B = Y                    A---------B\n-                     X_A_Y_B  \/\/ X < A < Y < B                    A-------------------B\n-  };\n-  overlap_case oc;\n-  if (B < X) oc = A_B_X_Y;\n-  if (B == X) oc = A_BX__Y;\n-  switch(oc) {    \/\/                      ........X..............Y......................\n-    case A_B_X_Y: \/\/ A < B < X < Y           A--B\n-    case A_BX__Y: \/\/ A < B = X < Y           A----B\n-    case A_X_B_Y: \/\/ A < X < B < Y           A--------B\n-    case A_X__BY: \/\/ A < X < Y = B           A-------------------B\n-    case A_X_Y_B: \/\/ A < X < Y < B           A-----------------------B\n-      \/\/ decompose into A--Y and Y--B\n-      \/\/ handle A--Y here and\n-      \/\/ recursive call of the register_mapping(Y, B, ...)\n+\n+  \/\/ ************************************************************************************ Loop\n+  GrowableArrayCHeap<position, mtNMT> to_be_removed;\n+  TreapNode* prev = nullptr;\n+  _tree.visit_range_in_order(Y->key(), B + 1, [&](TreapNode* curr){\n+    if (prev != nullptr) {\n+      update_region(prev, curr, req, diff);\n+      \/\/ during visit, structure of the tree should not be changed\n+      \/\/ keep the keys to be removed, and remove them later\n+      if (prev->val().is_noop()) {\n+        to_be_removed.push(prev->key());\n+      }\n+    }\n+    prev = curr;\n+  });\n+\n+  \/\/ ************************************************************************************ After loop\n+  TreapNode* W = rB.start;\n+  TreapNode* U = rB.end;\n+  TreapNode nB{B, stB, 0}; \/\/ the node that represents B\n+  bool W_exists = W != nullptr;\n+  bool U_exists = U != nullptr;\n+  bool W_eq_B = W_exists && W->key() == B;\n+  if (!W_exists && !U_exists           ) { row = 6; }\n+  if (!W_exists &&  U_exists           ) { row = 7; }\n+  if ( W_exists && !U_exists && !W_eq_B) { row = 8; }\n+  if ( W_exists && !U_exists &&  W_eq_B) { row = 9; }\n+  if ( W_exists &&  U_exists && !W_eq_B) { row = 10; }\n+  if ( W_exists &&  U_exists &&  W_eq_B) { row = 11; }\n+  switch(row) {\n+    case 6:\n+      if (!stB.is_noop()) { _tree.upsert(B, stB); }\n+      break;\n+    case 7:\n+      stB.out = U->val().in;\n+      if (!stB.is_noop()) { _tree.upsert(B, stB); }\n+      break;\n+    case 8:\n+      update_region(W, &nB, req, diff);\n+      if (W->val().is_noop()) { _tree.remove(W->key()); }\n+      if (!nB.val().is_noop()) { _tree.upsert(B, nB.val()); }\n+      break;\n+    case 9:\n+      if (W->val().in.equals(stB.out)) {\n+        _tree.remove(W->key());\n+      } else {\n+        _tree.upsert(B, stB);\n+      }\n+      break;\n+    case 10:\n+      stB.out = U->val().in;\n+      update_region(W, &nB, req, diff);\n+      if (W->val().in.equals(stB.out)) {\n+        _tree.remove(W->key());\n+      } else {\n+        _tree.upsert(B, stB);\n+      }\n+      break;\n+    case 11:\n+      if (W->val().in.equals(stB.out)) {\n+        _tree.remove(W->key());\n+      } else {\n+        _tree.upsert(B, stB);\n+      }\n@@ -163,6 +358,1 @@\n-    case AX_B__Y: \/\/ A = X < B < Y                A----B\n-    case AX___BY: \/\/ A = X < B = Y                A--------------B\n-    case AX_Y__B: \/\/ A = X < Y < B                A--------------------B\n-    case X_A_B_Y: \/\/ X < A < B < Y                    A---B\n-    case X_A__BY: \/\/ X < A < B = Y                    A---------B\n-    case X_A_Y_B: \/\/ X < A < Y < B                    A-------------------B\n+    default:\n@@ -171,0 +361,7 @@\n+\n+\n+  \/\/ ************************************************************************************ Delete noop nodes found in the loop\n+  while(to_be_removed.length() != 0) {\n+    _tree.remove(to_be_removed.pop());\n+  }\n+\n@@ -173,2 +370,2 @@\n-VMATree::SummaryDiff VMATree::register_mapping(position A, position B, StateType state,\n-                                               const RegionData& metadata, bool use_tag_inplace) {\n+VMATree::SummaryDiff VMATree::register_mapping_new(position A, position B, StateType state,\n+                                                   const RegionData& metadata, bool use_tag_inplace) {\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":260,"deletions":63,"binary":false,"changes":323,"status":"modified"},{"patch":"@@ -149,0 +149,11 @@\n+\n+    void set_type(StateType t) {\n+      type_tag[0] = static_cast<uint8_t>(t);\n+    }\n+\n+    bool equals(const IntervalState& other) const {\n+      return mem_tag()          == other.mem_tag()          &&\n+             type()             == other.type()             &&\n+             reserved_stack()   == other.reserved_stack()   &&\n+             committed_stack()  == other.committed_stack();\n+    }\n@@ -198,1 +209,1 @@\n-    position A,B;\n+    position A, B;\n@@ -244,3 +255,5 @@\n-  StateType new_state(StateType existinting_state, const RequestInfo& req);\n-  NativeCallStackStorage::StackIndex new_reserve_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n-  NativeCallStackStorage::StackIndex new_commit_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n+  StateType get_new_state(StateType existinting_state, const RequestInfo& req);\n+  NativeCallStackStorage::StackIndex get_new_reserve_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n+  NativeCallStackStorage::StackIndex get_new_commit_callstack(NativeCallStackStorage::StackIndex existinting_stack, StateType ex, const RequestInfo& req);\n+  void compute_summary_diff(SingleDiff::delta region_size, MemTag t1, const StateType& ex, const RequestInfo& req, MemTag new_tag, SummaryDiff& diff);\n+  void update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+  return;\n@@ -505,0 +506,1 @@\n+    tree.print_on(tty);\n@@ -506,0 +508,1 @@\n+    tree.print_on(tty);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}