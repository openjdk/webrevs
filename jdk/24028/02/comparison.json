{"files":[{"patch":"@@ -94,1 +94,1 @@\n-        _stack_storage.get(prev->val().out.stack()).print_on(stream);\n+        _stack_storage.get(prev->val().out.reserved_stack()).print_on(stream);\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-\n-private:\n@@ -50,1 +48,0 @@\n-public:\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,0 +89,22 @@\n+      \/\/ For NMT reports in detail mode, separate stacks are required for Reserve and Commit operations.\n+      \/\/ So, do not touch the stack of the node since it is for Reserve operation. Instead store the new\n+      \/\/ call-stack in the secondary_stack of the node.\n+      bool memtag_changed_at_A = leqA_n->val().out.mem_tag() != leqA_n->val().in.mem_tag();\n+      bool state_changed_at_A = leqA_n->val().out.type() != leqA_n->val().in.type();\n+      bool reserved_rgn_starts_at_A = memtag_changed_at_A || state_changed_at_A;\n+      bool is_reserve_operation = state == StateType::Reserved && !use_tag_inplace;\n+      bool is_reserved_stack_filled = leqA_n->val().out.has_reserved_stack();\n+\n+      if (reserved_rgn_starts_at_A && is_reserved_stack_filled ) {\n+        if (is_reserve_operation) {    \/\/ we are not reserving a new region\n+          stA.out.set_stack(metadata.stack_idx);\n+          stB.in.set_stack(metadata.stack_idx);\n+          stA.out.set_secondary_stack(leqA_n->val().out.reserved_stack());\n+          stB.in.set_secondary_stack(leqA_n->val().out.reserved_stack());\n+        } else {\n+          stA.out.set_stack(leqA_n->val().out.reserved_stack());\n+          stB.in.set_stack(leqA_n->val().out.reserved_stack());\n+          stA.out.set_secondary_stack(metadata.stack_idx);\n+          stB.in.set_secondary_stack(metadata.stack_idx);\n+        }\n+      }\n@@ -271,1 +293,1 @@\n-    RegionData new_data = RegionData(out.stack(), tag);\n+    RegionData new_data = RegionData(out.reserved_stack(), tag);\n@@ -292,1 +314,1 @@\n-      RegionData new_data = RegionData(out.stack(), tag);\n+      RegionData new_data = RegionData(out.reserved_stack(), tag);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    NativeCallStackStorage::StackIndex sidx;\n+    NativeCallStackStorage::StackIndex primary_stack;   \/\/ call-stack of all operations\n+    NativeCallStackStorage::StackIndex secondary_stack; \/\/ call-stack when committing\/uncommitting the start-node of a reserved region\n@@ -97,1 +98,1 @@\n-    IntervalState() : type_tag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, primary_stack(NativeCallStackStorage::invalid), secondary_stack(NativeCallStackStorage::invalid) {}\n@@ -102,1 +103,2 @@\n-      sidx = data.stack_idx;\n+      primary_stack = data.stack_idx;\n+      secondary_stack = NativeCallStackStorage::invalid;\n@@ -114,1 +116,1 @@\n-      return RegionData{sidx, mem_tag()};\n+      return RegionData{primary_stack, mem_tag()};\n@@ -121,2 +123,22 @@\n-    NativeCallStackStorage::StackIndex stack() const {\n-     return sidx;\n+    NativeCallStackStorage::StackIndex reserved_stack() const {\n+      return primary_stack;\n+    }\n+\n+    NativeCallStackStorage::StackIndex committed_stack() const {\n+      return secondary_stack;\n+    }\n+\n+    void set_stack(NativeCallStackStorage::StackIndex idx) {\n+      primary_stack = idx;\n+    }\n+\n+    void set_secondary_stack(NativeCallStackStorage::StackIndex idx) {\n+      secondary_stack = idx;\n+    }\n+\n+    bool has_reserved_stack() {\n+      return primary_stack != NativeCallStackStorage::invalid;\n+    }\n+\n+    bool has_committed_stack() {\n+      return secondary_stack != NativeCallStackStorage::invalid;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    si[1] = ncs.push(stacks[0]);\n+    si[1] = ncs.push(stacks[1]);\n@@ -297,1 +297,1 @@\n-  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree, int line_no) {\n@@ -317,2 +317,2 @@\n-      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n-      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      EXPECT_EQ(expect.stack, found.start->val().out.reserved_stack()) << \"Unexpected stack at test-line: \" << line_no;\n+      EXPECT_EQ(expect.stack, found.end->val().in.reserved_stack()) << \"Unexpected stack at test-line: \" << line_no;\n@@ -340,1 +340,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -364,1 +364,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -377,1 +377,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -393,1 +393,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -406,1 +406,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -421,1 +421,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -436,1 +436,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -447,1 +447,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -464,1 +464,1 @@\n-    expect_equivalent_form(expected, tree);\n+    expect_equivalent_form(expected, tree, __LINE__);\n@@ -716,4 +716,15 @@\n-        const NativeCallStack& start_stack = ncss.get(startn->val().out.stack());\n-        const NativeCallStack& end_stack = ncss.get(endn->val().in.stack());\n-        ASSERT_TRUE(starti.stack.equals(start_stack));\n-        ASSERT_TRUE(endi.stack.equals(end_stack));\n+        const NativeCallStack& start_stack = ncss.get(startn->val().out.reserved_stack());\n+        const NativeCallStack& end_stack = ncss.get(endn->val().in.reserved_stack());\n+        \/\/ If start-node of a reserved region is committed, the stack is stored in the second_stack of the node.\n+        if (!NativeCallStackStorage::is_invalid(startn->val().out.committed_stack())) {\n+          const NativeCallStack& start_second_stack = ncss.get(startn->val().out.committed_stack());\n+          ASSERT_TRUE(starti.stack.equals(start_stack) || starti.stack.equals(start_second_stack));\n+        } else {\n+          ASSERT_TRUE(starti.stack.equals(start_stack));\n+        }\n+        if (!NativeCallStackStorage::is_invalid(endn->val().in.committed_stack())) {\n+          const NativeCallStack& end_second_stack = ncss.get(endn->val().in.committed_stack());\n+          ASSERT_TRUE(endi.stack.equals(end_stack) || endi.stack.equals(end_second_stack));\n+        } else {\n+          ASSERT_TRUE(endi.stack.equals(end_stack));\n+        }\n@@ -742,0 +753,39 @@\n+}\n+\n+TEST_VM_F(NMTVMATreeTest, SeparateStacksForCommitAndReserve) {\n+  VMATree::RegionData call_stack_1(si[0], mtTest);\n+  VMATree::RegionData call_stack_2(si[1], mtNone);\n+\n+  {\n+    Tree tree;\n+    tree.reserve_mapping(0, 100, call_stack_1);\n+    tree.commit_mapping(25, 25, call_stack_2, true);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+    EXPECT_EQ(r.start->val().out.reserved_stack(), si[0]);\n+    EXPECT_FALSE(r.start->val().out.has_committed_stack());\n+  }\n+  {\n+    Tree tree;\n+    tree.reserve_mapping(0, 100, call_stack_1);\n+    tree.reserve_mapping(10, 10, call_stack_2);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+    EXPECT_EQ(r.start->val().out.reserved_stack(), si[0]);\n+    EXPECT_EQ(r.end->val().in.reserved_stack(), si[0]);\n+  }\n+\n+  {\n+    Tree tree;\n+    tree.commit_mapping(0, 100, call_stack_1);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+    EXPECT_EQ(r.start->val().out.reserved_stack(), si[0]);\n+    EXPECT_FALSE(r.start->val().out.has_committed_stack());\n+  }\n+  {\n+    Tree tree;\n+    tree.commit_mapping(0, 100, call_stack_1);\n+    tree.reserve_mapping(0, 100, call_stack_2);\n+    VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(0);\n+    EXPECT_EQ(r.start->val().out.reserved_stack(), si[1]);\n+    EXPECT_EQ(r.end->val().in.reserved_stack(), si[1]);\n+    EXPECT_EQ(r.start->val().out.committed_stack(), si[0]);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":67,"deletions":17,"binary":false,"changes":84,"status":"modified"}]}