{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,6 @@\n+    \/**\n+     * The 'JAR index' feature has been removed, but we still need to\n+     * process existing files which have this entry.\n+     *\/\n+    static final String INDEX_NAME = \"META-INF\/INDEX.LIST\";\n+\n@@ -215,1 +221,0 @@\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.util.jar.JarIndex;\n@@ -188,1 +187,1 @@\n-            if (first.getName().equalsIgnoreCase(JarIndex.INDEX_NAME))\n+            if (first.getName().equalsIgnoreCase(JarFile.INDEX_NAME))\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarInputStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.util.jar.JarIndex;\n@@ -149,1 +148,1 @@\n-                        uname.equals(JarIndex.INDEX_NAME)) {\n+                        uname.equals(JarFile.INDEX_NAME)) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,0 @@\n-import jdk.internal.util.jar.InvalidJarIndexError;\n-import jdk.internal.util.jar.JarIndex;\n@@ -94,1 +92,0 @@\n-    private static final boolean ENABLE_JAR_INDEX;\n@@ -114,3 +111,0 @@\n-\n-        p = props.getProperty(\"jdk.net.URLClassPath.enableJarIndex\");\n-        ENABLE_JAR_INDEX = p != null ? p.equals(\"true\") || p.isEmpty() : false;\n@@ -717,1 +711,0 @@\n-        private JarIndex index;\n@@ -782,25 +775,0 @@\n-                                if (!ENABLE_JAR_INDEX) {\n-                                    return null;\n-                                }\n-                                index = JarIndex.getJarIndex(jar);\n-                                if (index != null) {\n-                                    String[] jarfiles = index.getJarFiles();\n-                                \/\/ Add all the dependent URLs to the lmap so that loaders\n-                                \/\/ will not be created for them by URLClassPath.getLoader(int)\n-                                \/\/ if the same URL occurs later on the main class path.  We set\n-                                \/\/ Loader to null here to avoid creating a Loader for each\n-                                \/\/ URL until we actually need to try to load something from them.\n-                                    for (int i = 0; i < jarfiles.length; i++) {\n-                                        try {\n-                                            @SuppressWarnings(\"deprecation\")\n-                                            URL jarURL = new URL(csu, jarfiles[i]);\n-                                            \/\/ If a non-null loader already exists, leave it alone.\n-                                            String urlNoFragString = URLUtil.urlNoFragString(jarURL);\n-                                            if (!lmap.containsKey(urlNoFragString)) {\n-                                                lmap.put(urlNoFragString, null);\n-                                            }\n-                                        } catch (MalformedURLException e) {\n-                                            continue;\n-                                        }\n-                                    }\n-                                }\n@@ -850,12 +818,0 @@\n-        \/*\n-         * Returns the index of this JarLoader if it exists.\n-         *\/\n-        JarIndex getIndex() {\n-            try {\n-                ensureOpen();\n-            } catch (IOException e) {\n-                throw new InternalError(e);\n-            }\n-            return index;\n-        }\n-\n@@ -971,6 +927,0 @@\n-            if (index == null)\n-                return null;\n-\n-            HashSet<String> visited = new HashSet<>();\n-            return getResource(name, check, visited);\n-        }\n@@ -978,112 +928,0 @@\n-        \/*\n-         * Version of getResource() that tracks the jar files that have been\n-         * visited by linking through the index files. This helper method uses\n-         * a HashSet to store the URLs of jar files that have been searched and\n-         * uses it to avoid going into an infinite loop, looking for a\n-         * non-existent resource.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        Resource getResource(final String name, boolean check,\n-                             Set<String> visited) {\n-            Resource res;\n-            String[] jarFiles;\n-            int count = 0;\n-            List<String> jarFilesList;\n-\n-            \/* If there no jar files in the index that can potential contain\n-             * this resource then return immediately.\n-             *\/\n-            if ((jarFilesList = index.get(name)) == null)\n-                return null;\n-\n-            do {\n-                int size = jarFilesList.size();\n-                jarFiles = jarFilesList.toArray(new String[size]);\n-                \/* loop through the mapped jar file list *\/\n-                while (count < size) {\n-                    String jarName = jarFiles[count++];\n-                    JarLoader newLoader;\n-                    final URL url;\n-\n-                    try{\n-                        @SuppressWarnings(\"deprecation\")\n-                        var _unused = url = new URL(csu, jarName);\n-                        String urlNoFragString = URLUtil.urlNoFragString(url);\n-                        if ((newLoader = (JarLoader)lmap.get(urlNoFragString)) == null) {\n-                            \/* no loader has been set up for this jar file\n-                             * before\n-                             *\/\n-                            newLoader = AccessController.doPrivileged(\n-                                new PrivilegedExceptionAction<>() {\n-                                    public JarLoader run() throws IOException {\n-                                        return new JarLoader(url, handler,\n-                                            lmap, acc);\n-                                    }\n-                                }, acc);\n-\n-                            \/* this newly opened jar file has its own index,\n-                             * merge it into the parent's index, taking into\n-                             * account the relative path.\n-                             *\/\n-                            JarIndex newIndex = newLoader.getIndex();\n-                            if (newIndex != null) {\n-                                int pos = jarName.lastIndexOf('\/');\n-                                newIndex.merge(this.index, (pos == -1 ?\n-                                    null : jarName.substring(0, pos + 1)));\n-                            }\n-\n-                            \/* put it in the global hashtable *\/\n-                            lmap.put(urlNoFragString, newLoader);\n-                        }\n-                    } catch (PrivilegedActionException | MalformedURLException e) {\n-                        continue;\n-                    }\n-\n-                    \/* Note that the addition of the url to the list of visited\n-                     * jars incorporates a check for presence in the hashmap\n-                     *\/\n-                    boolean visitedURL = !visited.add(URLUtil.urlNoFragString(url));\n-                    if (!visitedURL) {\n-                        try {\n-                            newLoader.ensureOpen();\n-                        } catch (IOException e) {\n-                            throw new InternalError(e);\n-                        }\n-                        final JarEntry entry = newLoader.jar.getJarEntry(name);\n-                        if (entry != null) {\n-                            return newLoader.checkResource(name, check, entry);\n-                        }\n-\n-                        \/* Verify that at least one other resource with the\n-                         * same package name as the lookedup resource is\n-                         * present in the new jar\n-                         *\/\n-                        if (!newLoader.validIndex(name)) {\n-                            \/* the mapping is wrong *\/\n-                            throw new InvalidJarIndexError(\"Invalid index\");\n-                        }\n-                    }\n-\n-                    \/* If newLoader is the current loader or if it is a\n-                     * loader that has already been searched or if the new\n-                     * loader does not have an index then skip it\n-                     * and move on to the next loader.\n-                     *\/\n-                    if (visitedURL || newLoader == this ||\n-                            newLoader.getIndex() == null) {\n-                        continue;\n-                    }\n-\n-                    \/* Process the index of the new loader\n-                     *\/\n-                    if ((res = newLoader.getResource(name, check, visited))\n-                            != null) {\n-                        return res;\n-                    }\n-                }\n-                \/\/ Get the list of jar files again as the list could have grown\n-                \/\/ due to merging of index files.\n-                jarFilesList = index.get(name);\n-\n-            \/\/ If the count is unchanged, we are done.\n-            } while (count < jarFilesList.size());\n@@ -1093,1 +931,0 @@\n-\n@@ -1099,3 +936,0 @@\n-            if (index != null) {\n-                return null;\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":1,"deletions":167,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util.jar;\n-\n-\/**\n- * Thrown if the URLClassLoader finds the INDEX.LIST file of\n- * a jar file contains incorrect information.\n- *\n- * @since 9\n- *\/\n-\n-public class InvalidJarIndexError extends Error {\n-\n-    @java.io.Serial\n-    static final long serialVersionUID = 0L;\n-\n-    \/**\n-     * Constructs an {@code InvalidJarIndexError} with no detail message.\n-     *\/\n-    public InvalidJarIndexError() {\n-        super();\n-    }\n-\n-    \/**\n-     * Constructs an {@code InvalidJarIndexError} with the specified detail message.\n-     *\n-     * @param   s   the detail message.\n-     *\/\n-    public InvalidJarIndexError(String s) {\n-        super(s);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/InvalidJarIndexError.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,333 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util.jar;\n-\n-import sun.nio.cs.UTF_8;\n-\n-import java.io.*;\n-import java.util.*;\n-import java.util.jar.*;\n-import java.util.zip.*;\n-\n-import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n-\n-\/**\n- * This class is used to maintain mappings from packages, classes\n- * and resources to their enclosing JAR files. Mappings are kept\n- * at the package level except for class or resource files that\n- * are located at the root directory. URLClassLoader uses the mapping\n- * information to determine where to fetch an extension class or\n- * resource from.\n- *\n- * @author  Zhenghua Li\n- * @since   1.3\n- *\/\n-\n-public class JarIndex {\n-\n-    \/**\n-     * The hash map that maintains mappings from\n-     * package\/class\/resource to jar file list(s)\n-     *\/\n-    private final HashMap<String, List<String>> indexMap;\n-\n-    \/**\n-     * The hash map that maintains mappings from\n-     * jar file to package\/class\/resource lists\n-     *\/\n-    private final HashMap<String, List<String>> jarMap;\n-\n-    \/*\n-     * An ordered list of jar file names.\n-     *\/\n-    private String[] jarFiles;\n-\n-    \/**\n-     * The index file name.\n-     *\/\n-    public static final String INDEX_NAME = \"META-INF\/INDEX.LIST\";\n-\n-    \/**\n-     * true if, and only if, sun.misc.JarIndex.metaInfFilenames is set to true.\n-     * If true, the names of the files in META-INF, and its subdirectories, will\n-     * be added to the index. Otherwise, just the directory names are added.\n-     *\/\n-    private static final boolean metaInfFilenames =\n-        \"true\".equals(privilegedGetProperty(\"sun.misc.JarIndex.metaInfFilenames\"));\n-\n-    \/**\n-     * Constructs a new, empty jar index.\n-     *\/\n-    public JarIndex() {\n-        indexMap = new HashMap<>();\n-        jarMap = new HashMap<>();\n-    }\n-\n-    \/**\n-     * Constructs a new index from the specified input stream.\n-     *\n-     * @param is the input stream containing the index data\n-     *\/\n-    public JarIndex(InputStream is) throws IOException {\n-        this();\n-        read(is);\n-    }\n-\n-    \/**\n-     * Constructs a new index for the specified list of jar files.\n-     *\n-     * @param files the list of jar files to construct the index from.\n-     *\/\n-    public JarIndex(String[] files) throws IOException {\n-        this();\n-        this.jarFiles = files;\n-        parseJars(files);\n-    }\n-\n-    \/**\n-     * Returns the jar index, or <code>null<\/code> if none.\n-     *\n-     * @param jar the JAR file to get the index from.\n-     * @exception IOException if an I\/O error has occurred.\n-     *\/\n-    public static JarIndex getJarIndex(JarFile jar) throws IOException {\n-        JarIndex index = null;\n-        JarEntry e = jar.getJarEntry(INDEX_NAME);\n-        \/\/ if found, then load the index\n-        if (e != null) {\n-            index = new JarIndex(jar.getInputStream(e));\n-        }\n-        return index;\n-    }\n-\n-    \/**\n-     * Returns the jar files that are defined in this index.\n-     *\/\n-    public String[] getJarFiles() {\n-        return jarFiles;\n-    }\n-\n-    \/*\n-     * Add the key, value pair to the hashmap, the value will\n-     * be put in a list which is created if necessary.\n-     *\/\n-    private void addToList(String key, String value,\n-                           HashMap<String, List<String>> t) {\n-        List<String> list = t.get(key);\n-        if (list == null) {\n-            list = new ArrayList<>(1);\n-            list.add(value);\n-            t.put(key, list);\n-        } else if (!list.contains(value)) {\n-            list.add(value);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the list of jar files that are mapped to the file.\n-     *\n-     * @param fileName the key of the mapping\n-     *\/\n-    public List<String> get(String fileName) {\n-        List<String> jarFiles;\n-        if ((jarFiles = indexMap.get(fileName)) == null) {\n-            \/* try the package name again *\/\n-            int pos;\n-            if((pos = fileName.lastIndexOf('\/')) != -1) {\n-                jarFiles = indexMap.get(fileName.substring(0, pos));\n-            }\n-        }\n-        return jarFiles;\n-    }\n-\n-    \/**\n-     * Add the mapping from the specified file to the specified\n-     * jar file. If there were no mapping for the package of the\n-     * specified file before, a new list will be created,\n-     * the jar file is added to the list and a new mapping from\n-     * the package to the jar file list is added to the hashmap.\n-     * Otherwise, the jar file will be added to the end of the\n-     * existing list.\n-     *\n-     * @param fileName the file name\n-     * @param jarName the jar file that the file is mapped to\n-     *\n-     *\/\n-    public void add(String fileName, String jarName) {\n-        String packageName;\n-        int pos;\n-        if((pos = fileName.lastIndexOf('\/')) != -1) {\n-            packageName = fileName.substring(0, pos);\n-        } else {\n-            packageName = fileName;\n-        }\n-\n-        addMapping(packageName, jarName);\n-    }\n-\n-    \/**\n-     * Same as add(String,String) except that it doesn't strip off from the\n-     * last index of '\/'. It just adds the jarItem (filename or package)\n-     * as it is received.\n-     *\/\n-    private void addMapping(String jarItem, String jarName) {\n-        \/\/ add the mapping to indexMap\n-        addToList(jarItem, jarName, indexMap);\n-\n-        \/\/ add the mapping to jarMap\n-        addToList(jarName, jarItem, jarMap);\n-     }\n-\n-    \/**\n-     * Go through all the jar files and construct the\n-     * index table.\n-     *\/\n-    private void parseJars(String[] files) throws IOException {\n-        if (files == null) {\n-            return;\n-        }\n-\n-        String currentJar = null;\n-\n-        for (int i = 0; i < files.length; i++) {\n-            currentJar = files[i];\n-            ZipFile zrf = new ZipFile(currentJar.replace\n-                                      ('\/', File.separatorChar));\n-\n-            Enumeration<? extends ZipEntry> entries = zrf.entries();\n-            while(entries.hasMoreElements()) {\n-                ZipEntry entry = entries.nextElement();\n-                String fileName = entry.getName();\n-\n-                \/\/ Skip the META-INF directory, the index, and manifest.\n-                \/\/ Any files in META-INF\/ will be indexed explicitly\n-                if (fileName.equals(\"META-INF\/\") ||\n-                    fileName.equals(INDEX_NAME) ||\n-                    fileName.equals(JarFile.MANIFEST_NAME) ||\n-                    fileName.startsWith(\"META-INF\/versions\/\"))\n-                    continue;\n-\n-                if (!metaInfFilenames || !fileName.startsWith(\"META-INF\/\")) {\n-                    add(fileName, currentJar);\n-                } else if (!entry.isDirectory()) {\n-                        \/\/ Add files under META-INF explicitly so that certain\n-                        \/\/ services, like ServiceLoader, etc, can be located\n-                        \/\/ with greater accuracy. Directories can be skipped\n-                        \/\/ since each file will be added explicitly.\n-                        addMapping(fileName, currentJar);\n-                }\n-            }\n-\n-            zrf.close();\n-        }\n-    }\n-\n-    \/**\n-     * Writes the index to the specified OutputStream\n-     *\n-     * @param out the output stream\n-     * @exception IOException if an I\/O error has occurred\n-     *\/\n-    public void write(OutputStream out) throws IOException {\n-        BufferedWriter bw = new BufferedWriter\n-            (new OutputStreamWriter(out, UTF_8.INSTANCE));\n-        bw.write(\"JarIndex-Version: 1.0\\n\\n\");\n-\n-        if (jarFiles != null) {\n-            for (int i = 0; i < jarFiles.length; i++) {\n-                \/* print out the jar file name *\/\n-                String jar = jarFiles[i];\n-                bw.write(jar + \"\\n\");\n-                List<String> jarlist = jarMap.get(jar);\n-                if (jarlist != null) {\n-                    for (String s : jarlist) {\n-                        bw.write(s + \"\\n\");\n-                    }\n-                }\n-                bw.write(\"\\n\");\n-            }\n-            bw.flush();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Reads the index from the specified InputStream.\n-     *\n-     * @param is the input stream\n-     * @exception IOException if an I\/O error has occurred\n-     *\/\n-    public void read(InputStream is) throws IOException {\n-        BufferedReader br = new BufferedReader\n-            (new InputStreamReader(is, UTF_8.INSTANCE));\n-        String line;\n-        String currentJar = null;\n-\n-        \/* an ordered list of jar file names *\/\n-        ArrayList<String> jars = new ArrayList<>();\n-\n-        \/* read until we see a .jar line *\/\n-        while((line = br.readLine()) != null && !line.endsWith(\".jar\"));\n-\n-        for(;line != null; line = br.readLine()) {\n-            if (line.isEmpty())\n-                continue;\n-\n-            if (line.endsWith(\".jar\")) {\n-                currentJar = line;\n-                jars.add(currentJar);\n-            } else {\n-                String name = line;\n-                addMapping(name, currentJar);\n-            }\n-        }\n-\n-        jarFiles = jars.toArray(new String[jars.size()]);\n-    }\n-\n-    \/**\n-     * Merges the current index into another index, taking into account\n-     * the relative path of the current index.\n-     *\n-     * @param toIndex The destination index which the current index will\n-     *                merge into.\n-     * @param path    The relative path of the this index to the destination\n-     *                index.\n-     *\n-     *\/\n-    public void merge(JarIndex toIndex, String path) {\n-        for (Map.Entry<String, List<String>> e : indexMap.entrySet()) {\n-            String packageName = e.getKey();\n-            List<String> from_list = e.getValue();\n-            for (String jarName : from_list) {\n-                if (path != null) {\n-                    jarName = path.concat(jarName);\n-                }\n-                toIndex.addMapping(packageName, jarName);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/JarIndex.java","additions":0,"deletions":333,"binary":false,"changes":333,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,2 +277,0 @@\n-    exports jdk.internal.util.jar to\n-        jdk.jartool;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.tools.jar;\n+\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.jar.*;\n+import java.util.zip.*;\n+\n+\n+\/**\n+ * This class is used to maintain mappings from packages, classes\n+ * and resources to their enclosing JAR files. Mappings are kept\n+ * at the package level except for class or resource files that\n+ * are located at the root directory.\n+ *\n+ * @author Zhenghua Li\n+ * @since 1.3\n+ *\/\n+\n+class JarIndex {\n+\n+    \/**\n+     * The hash map that maintains mappings from\n+     * package\/class\/resource to jar file list(s)\n+     *\/\n+    private final HashMap<String, List<String>> indexMap;\n+\n+    \/**\n+     * The hash map that maintains mappings from\n+     * jar file to package\/class\/resource lists\n+     *\/\n+    private final HashMap<String, List<String>> jarMap;\n+\n+    \/*\n+     * An ordered list of jar file names.\n+     *\/\n+    private String[] jarFiles;\n+\n+    \/**\n+     * The index file name.\n+     *\/\n+    static final String INDEX_NAME = \"META-INF\/INDEX.LIST\";\n+\n+    \/**\n+     * true if, and only if, sun.misc.JarIndex.metaInfFilenames is set to true.\n+     * If true, the names of the files in META-INF, and its subdirectories, will\n+     * be added to the index. Otherwise, just the directory names are added.\n+     *\/\n+    private static final boolean metaInfFilenames =\n+            \"true\".equals(System.getProperty(\"sun.misc.JarIndex.metaInfFilenames\"));\n+\n+    \/**\n+     * Constructs a new index for the specified list of jar files.\n+     *\n+     * @param files the list of jar files to construct the index from.\n+     *\/\n+    public JarIndex(String[] files) throws IOException {\n+        this.indexMap = new HashMap<>();\n+        this.jarMap = new HashMap<>();\n+        this.jarFiles = files;\n+        parseJars(files);\n+    }\n+\n+    \/*\n+     * Add the key, value pair to the hashmap, the value will\n+     * be put in a list which is created if necessary.\n+     *\/\n+    private void addToList(String key, String value,\n+                           HashMap<String, List<String>> t) {\n+        List<String> list = t.get(key);\n+        if (list == null) {\n+            list = new ArrayList<>(1);\n+            list.add(value);\n+            t.put(key, list);\n+        } else if (!list.contains(value)) {\n+            list.add(value);\n+        }\n+    }\n+\n+    \/**\n+     * Add the mapping from the specified file to the specified\n+     * jar file. If there were no mapping for the package of the\n+     * specified file before, a new list will be created,\n+     * the jar file is added to the list and a new mapping from\n+     * the package to the jar file list is added to the hashmap.\n+     * Otherwise, the jar file will be added to the end of the\n+     * existing list.\n+     *\n+     * @param fileName the file name\n+     * @param jarName the jar file that the file is mapped to\n+     *\n+     *\/\n+    private void add(String fileName, String jarName) {\n+        String packageName;\n+        int pos;\n+        if ((pos = fileName.lastIndexOf('\/')) != -1) {\n+            packageName = fileName.substring(0, pos);\n+        } else {\n+            packageName = fileName;\n+        }\n+\n+        addMapping(packageName, jarName);\n+    }\n+\n+    \/**\n+     * Same as add(String,String) except that it doesn't strip off from the\n+     * last index of '\/'. It just adds the jarItem (filename or package)\n+     * as it is received.\n+     *\/\n+    private void addMapping(String jarItem, String jarName) {\n+        \/\/ add the mapping to indexMap\n+        addToList(jarItem, jarName, indexMap);\n+\n+        \/\/ add the mapping to jarMap\n+        addToList(jarName, jarItem, jarMap);\n+     }\n+\n+    \/**\n+     * Go through all the jar files and construct the\n+     * index table.\n+     *\/\n+    private void parseJars(String[] files) throws IOException {\n+        if (files == null) {\n+            return;\n+        }\n+\n+        String currentJar = null;\n+\n+        for (int i = 0; i < files.length; i++) {\n+            currentJar = files[i];\n+            ZipFile zrf = new ZipFile(currentJar.replace\n+                                      ('\/', File.separatorChar));\n+\n+            Enumeration<? extends ZipEntry> entries = zrf.entries();\n+            while(entries.hasMoreElements()) {\n+                ZipEntry entry = entries.nextElement();\n+                String fileName = entry.getName();\n+\n+                \/\/ Skip the META-INF directory, the index, and manifest.\n+                \/\/ Any files in META-INF\/ will be indexed explicitly\n+                if (fileName.equals(\"META-INF\/\") ||\n+                    fileName.equals(INDEX_NAME) ||\n+                    fileName.equals(JarFile.MANIFEST_NAME) ||\n+                    fileName.startsWith(\"META-INF\/versions\/\"))\n+                    continue;\n+\n+                if (!metaInfFilenames || !fileName.startsWith(\"META-INF\/\")) {\n+                    add(fileName, currentJar);\n+                } else if (!entry.isDirectory()) {\n+                        \/\/ Add files under META-INF explicitly so that certain\n+                        \/\/ services, like ServiceLoader, etc, can be located\n+                        \/\/ with greater accuracy. Directories can be skipped\n+                        \/\/ since each file will be added explicitly.\n+                        addMapping(fileName, currentJar);\n+                }\n+            }\n+\n+            zrf.close();\n+        }\n+    }\n+\n+    \/**\n+     * Writes the index to the specified OutputStream\n+     *\n+     * @param out the output stream\n+     * @exception IOException if an I\/O error has occurred\n+     *\/\n+    public void write(OutputStream out) throws IOException {\n+        BufferedWriter bw = new BufferedWriter\n+                (new OutputStreamWriter(out, StandardCharsets.UTF_8));\n+        bw.write(\"JarIndex-Version: 1.0\\n\\n\");\n+\n+        if (jarFiles != null) {\n+            for (int i = 0; i < jarFiles.length; i++) {\n+                \/* print out the jar file name *\/\n+                String jar = jarFiles[i];\n+                bw.write(jar + \"\\n\");\n+                List<String> jarlist = jarMap.get(jar);\n+                if (jarlist != null) {\n+                    for (String s : jarlist) {\n+                        bw.write(s + \"\\n\");\n+                    }\n+                }\n+                bw.write(\"\\n\");\n+            }\n+            bw.flush();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/JarIndex.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-import java.util.concurrent.TimeUnit;\n+\n@@ -72,1 +72,1 @@\n-import jdk.internal.util.jar.JarIndex;\n+\n@@ -74,1 +74,0 @@\n-import java.time.ZoneOffset;\n@@ -79,1 +78,1 @@\n-import static jdk.internal.util.jar.JarIndex.INDEX_NAME;\n+import static sun.tools.jar.JarIndex.INDEX_NAME;\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @modules jdk.jartool\/sun.tools.jar java.base\/jdk.internal.util.jar\n+ * @modules jdk.jartool\/sun.tools.jar\n","filename":"test\/jdk\/java\/util\/jar\/JarFile\/mrjar\/TestVersionedStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug     6901992\n- * @summary InvalidJarIndexException due to bug in sun.misc.JarIndex.merge()\n- *          Test URLClassLoader usage of the merge method when using indexes\n- * @author  Diego Belfer\n- * @run main\/othervm -Djdk.net.URLClassPath.enableJarIndex=true JarIndexMergeForClassLoaderTest\n- *\/\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-\n-public class JarIndexMergeForClassLoaderTest {\n-    static final String slash = File.separator;\n-    static final String testClassesDir = System.getProperty(\"test.classes\", \".\");\n-    static final String jar;\n-    static final boolean debug = true;\n-    static final File tmpFolder = new File(testClassesDir);\n-\n-    static {\n-        jar = System.getProperty(\"java.home\") + slash + \"bin\" + slash + \"jar\";\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Create the jars file\n-        File jar1 = buildJar1();\n-        File jar2 = buildJar2();\n-        File jar3 = buildJar3();\n-\n-        \/\/ Index jar files in two levels: jar1 -> jar2 -> jar3\n-        createIndex(jar2.getName(), jar3.getName());\n-        createIndex(jar1.getName(), jar2.getName());\n-\n-        \/\/ Get root jar of the URLClassLoader\n-        URL url = jar1.toURI().toURL();\n-\n-        URLClassLoader classLoader = new URLClassLoader(new URL[] { url });\n-\n-        assertResource(classLoader, \"com\/jar1\/resource.file\", \"jar1\");\n-        assertResource(classLoader, \"com\/test\/resource1.file\", \"resource1\");\n-        assertResource(classLoader, \"com\/jar2\/resource.file\", \"jar2\");\n-        assertResource(classLoader, \"com\/test\/resource2.file\", \"resource2\");\n-        assertResource(classLoader, \"com\/test\/resource3.file\", \"resource3\");\n-\n-        \/*\n-         * The following two asserts failed before the fix of the bug 6901992\n-         *\/\n-        \/\/ Check that an existing file is found using the merged index\n-        assertResource(classLoader, \"com\/missing\/jar3\/resource.file\", \"jar3\");\n-        \/\/ Check that a non existent file in directory which does not contain\n-        \/\/ any file is not found and it does not throw InvalidJarIndexException\n-        assertResource(classLoader, \"com\/missing\/nofile\", null);\n-    }\n-\n-    private static File buildJar3() throws FileNotFoundException, IOException {\n-        JarBuilder jar3Builder = new JarBuilder(tmpFolder, \"jar3.jar\");\n-        jar3Builder.addResourceFile(\"com\/test\/resource3.file\", \"resource3\");\n-        jar3Builder.addResourceFile(\"com\/missing\/jar3\/resource.file\", \"jar3\");\n-        return jar3Builder.build();\n-    }\n-\n-    private static File buildJar2() throws FileNotFoundException, IOException {\n-        JarBuilder jar2Builder = new JarBuilder(tmpFolder, \"jar2.jar\");\n-        jar2Builder.addResourceFile(\"com\/jar2\/resource.file\", \"jar2\");\n-        jar2Builder.addResourceFile(\"com\/test\/resource2.file\", \"resource2\");\n-        return jar2Builder.build();\n-    }\n-\n-    private static File buildJar1() throws FileNotFoundException, IOException {\n-        JarBuilder jar1Builder = new JarBuilder(tmpFolder, \"jar1.jar\");\n-        jar1Builder.addResourceFile(\"com\/jar1\/resource.file\", \"jar1\");\n-        jar1Builder.addResourceFile(\"com\/test\/resource1.file\", \"resource1\");\n-        return jar1Builder.build();\n-    }\n-\n-    \/* create the index *\/\n-    static void createIndex(String parentJar, String childJar) {\n-        \/\/ ProcessBuilder is used so that the current directory can be set\n-        \/\/ to the directory that directly contains the jars.\n-        debug(\"Running jar to create the index for: \" + parentJar + \" and \"\n-                + childJar);\n-        ProcessBuilder pb = new ProcessBuilder(jar, \"-i\", parentJar, childJar);\n-\n-        pb.directory(tmpFolder);\n-        \/\/ pd.inheritIO();\n-        try {\n-            Process p = pb.start();\n-            if (p.waitFor() != 0)\n-                throw new RuntimeException(\"jar indexing failed\");\n-\n-            if (debug && p != null) {\n-                debugStream(p.getInputStream());\n-                debugStream(p.getErrorStream());\n-            }\n-        } catch (InterruptedException | IOException x) {\n-            throw new RuntimeException(x);\n-        }\n-    }\n-\n-    private static void debugStream(InputStream is) throws IOException {\n-        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n-            String line;\n-            while ((line = reader.readLine()) != null) {\n-                debug(line);\n-            }\n-        }\n-    }\n-\n-    private static void assertResource(URLClassLoader classLoader, String file,\n-            String expectedContent) throws IOException {\n-        InputStream fileStream = classLoader.getResourceAsStream(file);\n-\n-        if (fileStream == null && expectedContent == null) {\n-            return;\n-        }\n-        if (fileStream == null && expectedContent != null) {\n-            throw new RuntimeException(\n-                    buildMessage(file, expectedContent, null));\n-        }\n-        try {\n-            String actualContent = readAsString(fileStream);\n-\n-            if (fileStream != null && expectedContent == null) {\n-                throw new RuntimeException(buildMessage(file, null,\n-                        actualContent));\n-            }\n-            if (!expectedContent.equals(actualContent)) {\n-                throw new RuntimeException(buildMessage(file, expectedContent,\n-                        actualContent));\n-            }\n-        } finally {\n-            fileStream.close();\n-        }\n-    }\n-\n-    private static String buildMessage(String file, String expectedContent,\n-            String actualContent) {\n-        return \"Expected: \" + expectedContent + \" for: \" + file + \" was: \"\n-                + actualContent;\n-    }\n-\n-    private static String readAsString(InputStream fileStream)\n-            throws IOException {\n-        byte[] buffer = new byte[1024];\n-        int count, len = 0;\n-        while ((count = fileStream.read(buffer, len, buffer.length-len)) != -1)\n-                len += count;\n-        return new String(buffer, 0, len, \"ASCII\");\n-    }\n-\n-    static void debug(Object message) {\n-        if (debug)\n-            System.out.println(message);\n-    }\n-\n-    \/*\n-     * Helper class for building jar files\n-     *\/\n-    public static class JarBuilder {\n-        private JarOutputStream os;\n-        private File jarFile;\n-\n-        public JarBuilder(File tmpFolder, String jarName)\n-            throws FileNotFoundException, IOException\n-        {\n-            this.jarFile = new File(tmpFolder, jarName);\n-            this.os = new JarOutputStream(new FileOutputStream(jarFile));\n-        }\n-\n-        public void addResourceFile(String pathFromRoot, String content)\n-            throws IOException\n-        {\n-            JarEntry entry = new JarEntry(pathFromRoot);\n-            os.putNextEntry(entry);\n-            os.write(content.getBytes(\"ASCII\"));\n-            os.closeEntry();\n-        }\n-\n-        public File build() throws IOException {\n-            os.close();\n-            return jarFile;\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/JarIndexMergeForClassLoaderTest.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6901992\n- * @summary InvalidJarIndexException due to bug in sun.misc.JarIndex.merge()\n- * @modules java.base\/jdk.internal.util.jar\n- * @compile -XDignore.symbol.file JarIndexMergeTest.java\n- * @run main JarIndexMergeTest\n- * @author  Diego Belfer\n- *\/\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-\/\/ implementation specific API\n-import jdk.internal.util.jar.JarIndex;\n-\n-public class JarIndexMergeTest {\n-    static final String slash = File.separator;\n-    static final String testClassesDir = System.getProperty(\"test.classes\", \".\");\n-    static final File tmpFolder = new File(testClassesDir);\n-\n-    public static void main(String[] args) throws Exception {\n-        File jar1 = buildJar1();\n-        File jar2 = buildJar2();\n-\n-        JarIndex jarIndex1 = new JarIndex(new String[] { jar1.getAbsolutePath() });\n-        JarIndex jarIndex2 = new JarIndex(new String[] { jar2.getAbsolutePath() });\n-\n-        jarIndex1.merge(jarIndex2, null);\n-\n-        assertFileResolved(jarIndex2, \"com\/test1\/resource1.file\",\n-                           jar1.getAbsolutePath());\n-        assertFileResolved(jarIndex2, \"com\/test2\/resource2.file\",\n-                           jar2.getAbsolutePath());\n-    }\n-\n-    static void assertFileResolved(JarIndex jarIndex2, String file,\n-                                   String jarName) {\n-        @SuppressWarnings(\"unchecked\")\n-        List<String> jarLists = (List<String>)jarIndex2.get(file);\n-        if (jarLists == null || jarLists.size() == 0 ||\n-            !jarName.equals(jarLists.get(0))) {\n-            throw new RuntimeException(\n-                \"Unexpected result: the merged index must resolve file: \"\n-                + file);\n-        }\n-    }\n-\n-    private static File buildJar1() throws FileNotFoundException, IOException {\n-        JarBuilder jar1Builder = new JarBuilder(tmpFolder, \"jar1-merge.jar\");\n-        jar1Builder.addResourceFile(\"com\/test1\/resource1.file\", \"resource1\");\n-        return jar1Builder.build();\n-    }\n-\n-    private static File buildJar2() throws FileNotFoundException, IOException {\n-        JarBuilder jar2Builder = new JarBuilder(tmpFolder, \"jar2-merge.jar\");\n-        jar2Builder.addResourceFile(\"com\/test2\/resource2.file\", \"resource2\");\n-        return jar2Builder.build();\n-    }\n-\n-    \/*\n-     * Helper class for building jar files\n-     *\/\n-    public static class JarBuilder {\n-        private JarOutputStream os;\n-        private File jarFile;\n-\n-        public JarBuilder(File tmpFolder, String jarName)\n-            throws FileNotFoundException, IOException\n-        {\n-            this.jarFile = new File(tmpFolder, jarName);\n-            this.os = new JarOutputStream(new FileOutputStream(jarFile));\n-        }\n-\n-        public void addResourceFile(String pathFromRoot, String content)\n-            throws IOException\n-        {\n-            JarEntry entry = new JarEntry(pathFromRoot);\n-            os.putNextEntry(entry);\n-            os.write(content.getBytes(\"ASCII\"));\n-            os.closeEntry();\n-        }\n-\n-        public File build() throws IOException {\n-            os.close();\n-            return jarFile;\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/JarIndexMergeTest.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,406 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6887710\n- * @summary Verify the impact of sun.misc.JarIndex.metaInfFilenames on ServiceLoader\n- * @modules jdk.jartool\/sun.tools.jar\n- *          jdk.httpserver\n- *          jdk.compiler\n- *          jdk.zipfs\n- * @run main\/othervm -Djdk.net.URLClassPath.enableJarIndex=true Basic\n- *\/\n-\n-import java.io.IOException;\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.ServiceLoader;\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-\/**\n- * Verifies the impact of sun.misc.JarIndex.metaInfFilenames on ServiceLoader\n- * and on finding resources via Class.getResource.\n- *\n- * 1) Compile the test sources:\n- *   jarA:\n- *     META-INF\/services\/my.happy.land\n- *     com\/message\/spi\/MessageService.java\n- *     a\/A.java\n- *   jarB:\n- *     META-INF\/JAVA2.DS\n- *     META-INF\/services\/no.name.service\n- *     b\/B.java\n- *   jarC:\n- *     META-INF\/fonts.mf\n- *     META-INF\/fonts\/Company-corporate.ttf\n- *     META-INF\/fonts\/kidpr.ttf\n- *     META-INF\/services\/com.message.spi.MessageService\n- *     my\/impl\/StandardMessageService.java\n- *\n- * 2) Build three jar files a.jar, b.jar, c.jar\n- *\n- * 3) Create an index in a.jar (jar -i a.jar b.jar c.jar)\n- *      with sun.misc.JarIndex.metaInfFilenames=true\n- *\n- * 4) Start a HTTP server serving out the three jars.\n- *\n- * The test then tries to locate services\/resources within the jars using\n- * URLClassLoader. Each request to the HTTP server is recorded to ensure\n- * only the correct amount of requests are being made.\n- *\n- *\/\n-\n-public class Basic {\n-    static final String slash = File.separator;\n-    static final String[] testSources =  {\n-         \"jarA\" + slash + \"a\" + slash + \"A.java\",\n-         \"jarA\" + slash + \"com\" + slash + \"message\" + slash + \"spi\" + slash + \"MessageService.java\",\n-         \"jarB\" + slash + \"b\" + slash + \"B.java\",\n-         \"jarC\" + slash + \"my\" + slash + \"impl\" + slash + \"StandardMessageService.java\"};\n-\n-    static final String testSrc = System.getProperty(\"test.src\");\n-    static final String testSrcDir = testSrc != null ? testSrc : \".\";\n-    static final String testClasses = System.getProperty(\"test.classes\");\n-    static final String testClassesDir = testClasses != null ? testClasses : \".\";\n-\n-    static JarHttpServer httpServer;\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        \/\/ Set global url cache to false so that we can track every jar request.\n-        (new URL(\"http:\/\/localhost\/\")).openConnection().setDefaultUseCaches(false);\n-\n-        buildTest();\n-\n-        try {\n-            httpServer = new JarHttpServer(testClassesDir);\n-            httpServer.start();\n-\n-            doTest(httpServer.getAddress());\n-\n-        } catch (IOException ioe) {\n-            ioe.printStackTrace();\n-        } finally {\n-            if (httpServer != null) { httpServer.stop(2); }\n-        }\n-    }\n-\n-    static void buildTest() {\n-        \/* compile the source that will be used to generate the jars *\/\n-        for (int i=0; i<testSources.length; i++)\n-            testSources[i] = testSrcDir + slash + testSources[i];\n-\n-        compile(\"-d\" , testClassesDir,\n-                \"-sourcepath\", testSrcDir,\n-                testSources[0], testSources[1], testSources[2], testSources[3]);\n-\n-        \/* build the 3 jar files *\/\n-        jar(\"-cf\", testClassesDir + slash + \"a.jar\",\n-            \"-C\", testClassesDir, \"a\",\n-            \"-C\", testClassesDir, \"com\",\n-            \"-C\", testSrcDir + slash + \"jarA\", \"META-INF\");\n-        jar(\"-cf\", testClassesDir + slash + \"b.jar\",\n-            \"-C\", testClassesDir, \"b\",\n-            \"-C\", testSrcDir + slash + \"jarB\", \"META-INF\");\n-        jar(\"-cf\", testClassesDir + slash + \"c.jar\",\n-            \"-C\", testClassesDir, \"my\",\n-            \"-C\", testSrcDir + slash + \"jarC\", \"META-INF\");\n-\n-        \/* Create an index in a.jar for b.jar and c.jar *\/\n-        createIndex(testClassesDir);\n-    }\n-\n-    \/* run jar <args> *\/\n-    static void jar(String... args) {\n-        debug(\"Running: jar \" + Arrays.toString(args));\n-        sun.tools.jar.Main jar = new sun.tools.jar.Main(System.out, System.err, \"jar\");\n-        if (!jar.run(args)) {\n-            throw new RuntimeException(\"jar failed: args=\" + Arrays.toString(args));\n-        }\n-    }\n-\n-    \/* run javac <args> *\/\n-    static void compile(String... args) {\n-        debug(\"Running: javac \" + Arrays.toString(args));\n-        if (com.sun.tools.javac.Main.compile(args) != 0) {\n-             throw new RuntimeException(\"javac failed: args=\" + Arrays.toString(args));\n-        }\n-    }\n-\n-    static String jar;\n-    static {\n-        jar = System.getProperty(\"java.home\") + slash+  \"bin\" + slash + \"jar\";\n-    }\n-\n-    \/* create the index *\/\n-    static void createIndex(String workingDir) {\n-        \/\/ ProcessBuilder is used so that the current directory can be set\n-        \/\/ to the directory that directly contains the jars.\n-        debug(\"Running jar to create the index\");\n-        ProcessBuilder pb = new ProcessBuilder(\n-           jar, \"-J-Dsun.misc.JarIndex.metaInfFilenames=true\", \"-i\", \"a.jar\", \"b.jar\", \"c.jar\");\n-        pb.directory(new File(workingDir));\n-        \/\/pd.inheritIO();\n-        try {\n-            Process p = pb.start();\n-            if(p.waitFor() != 0)\n-                throw new RuntimeException(\"jar indexing failed\");\n-\n-            if(debug && p != null) {\n-                String line = null;\n-                BufferedReader reader =\n-                         new BufferedReader(new InputStreamReader(p.getInputStream()));\n-                while((line = reader.readLine()) != null)\n-                    debug(line);\n-                reader = new BufferedReader(new InputStreamReader(p.getErrorStream()));\n-                while((line = reader.readLine()) != null)\n-                    debug(line);\n-            }\n-        } catch(InterruptedException ie) { throw new RuntimeException(ie);\n-        } catch(IOException e) { throw new RuntimeException(e); }\n-    }\n-\n-    static final boolean debug = true;\n-\n-    static void debug(Object message) { if (debug) System.out.println(message); }\n-\n-    \/* service define in c.jar *\/\n-    static final String messageService = \"com.message.spi.MessageService\";\n-\n-    \/* a service that is not defined in any of the jars *\/\n-    static final String unknownService = \"java.lang.Object\";\n-\n-    static void doTest(InetSocketAddress serverAddress) throws IOException {\n-        URL baseURL = new URL(\"http:\/\/localhost:\" + serverAddress.getPort() + \"\/\");\n-\n-        int failed = 0;\n-\n-        \/\/ Tests using java.util.SerivceLoader\n-        if (!javaUtilServiceLoaderTest(baseURL, messageService, true, false, true)) {\n-            System.out.println(\"Test: ServiceLoader looking for \" + messageService + \", failed\");\n-            failed++;\n-        }\n-        if (!javaUtilServiceLoaderTest(baseURL, unknownService, false, false, false)) {\n-            System.out.println(\"Test: ServiceLoader looking for \" + unknownService + \" failed\");\n-            failed++;\n-        }\n-\n-        \/\/ Tests using java.lang.Class (similar to the FontManager in javafx)\n-        if (!klassLoader(baseURL, \"\/META-INF\/fonts.mf\", true, false, true)) {\n-            System.out.println(\"Test: klassLoader looking for \/META-INF\/fonts.mf failed\");\n-            failed++;\n-        }\n-        if (!klassLoader(baseURL, \"\/META-INF\/unknown.mf\", false, false, false)) {\n-            System.out.println(\"Test: klassLoader looking for \/META-INF\/unknown.mf failed\");\n-            failed++;\n-        }\n-\n-        if (failed > 0)\n-            throw new RuntimeException(\"Failed: \" + failed + \" tests\");\n-    }\n-\n-    static boolean javaUtilServiceLoaderTest(URL baseURL,\n-                                             String serviceClass,\n-                                             boolean expectToFind,\n-                                             boolean expectbDotJar,\n-                                             boolean expectcDotJar) throws IOException {\n-        debug(\"----------------------------------\");\n-        debug(\"Running test with java.util.ServiceLoader looking for \" + serviceClass);\n-        URLClassLoader loader = getLoader(baseURL);\n-        httpServer.reset();\n-\n-        Class<?> messageServiceClass = null;\n-        try {\n-            messageServiceClass = loader.loadClass(serviceClass);\n-        } catch (ClassNotFoundException cnfe) {\n-            System.err.println(cnfe);\n-            throw new RuntimeException(\"Error in test: \" + cnfe);\n-        }\n-\n-        Iterator<?> iterator = (ServiceLoader.load(messageServiceClass, loader)).iterator();\n-        if (expectToFind && !iterator.hasNext()) {\n-            debug(messageServiceClass + \" NOT found.\");\n-            return false;\n-        }\n-\n-        while (iterator.hasNext()) {\n-            debug(\"found \" + iterator.next() + \" \" + messageService);\n-        }\n-\n-        debug(\"HttpServer: \" + httpServer);\n-\n-        if (!expectbDotJar && httpServer.bDotJar > 0) {\n-            debug(\"Unexpected request sent to the httpserver for b.jar\");\n-            return false;\n-        }\n-        if (!expectcDotJar && httpServer.cDotJar > 0) {\n-            debug(\"Unexpected request sent to the httpserver for c.jar\");\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    \/* Tries to find a resource in a similar way to the font manager in javafx\n-     * com.sun.javafx.scene.text.FontManager *\/\n-    static boolean klassLoader(URL baseURL,\n-                               String resource,\n-                               boolean expectToFind,\n-                               boolean expectbDotJar,\n-                               boolean expectcDotJar) throws IOException {\n-        debug(\"----------------------------------\");\n-        debug(\"Running test looking for \" + resource);\n-        URLClassLoader loader = getLoader(baseURL);\n-        httpServer.reset();\n-\n-        Class<?> ADotAKlass = null;\n-        try {\n-            ADotAKlass = loader.loadClass(\"a.A\");\n-        } catch (ClassNotFoundException cnfe) {\n-            System.err.println(cnfe);\n-            throw new RuntimeException(\"Error in test: \" + cnfe);\n-        }\n-\n-        URL u = ADotAKlass.getResource(resource);\n-        if (expectToFind && u == null) {\n-            System.out.println(\"Expected to find \" + resource + \" but didn't\");\n-            return false;\n-        }\n-\n-        debug(\"HttpServer: \" + httpServer);\n-\n-        if (!expectbDotJar && httpServer.bDotJar > 0) {\n-            debug(\"Unexpected request sent to the httpserver for b.jar\");\n-            return false;\n-        }\n-        if (!expectcDotJar && httpServer.cDotJar > 0) {\n-            debug(\"Unexpected request sent to the httpserver for c.jar\");\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    static URLClassLoader getLoader(URL baseURL) throws IOException {\n-        ClassLoader loader = Basic.class.getClassLoader();\n-\n-        while (loader.getParent() != null)\n-            loader = loader.getParent();\n-\n-        return new URLClassLoader( new URL[]{\n-            new URL(baseURL, \"a.jar\"),\n-            new URL(baseURL, \"b.jar\"),\n-            new URL(baseURL, \"c.jar\")}, loader );\n-    }\n-\n-    \/**\n-     * HTTP Server to server the jar files.\n-     *\/\n-    static class JarHttpServer implements HttpHandler {\n-        final String docsDir;\n-        final HttpServer httpServer;\n-        int aDotJar, bDotJar, cDotJar;\n-\n-        JarHttpServer(String docsDir) throws IOException {\n-            this.docsDir = docsDir;\n-\n-            httpServer = HttpServer.create(new InetSocketAddress(0), 0);\n-            httpServer.createContext(\"\/\", this);\n-        }\n-\n-        void start() throws IOException {\n-            httpServer.start();\n-        }\n-\n-        void stop(int delay) {\n-            httpServer.stop(delay);\n-        }\n-\n-        InetSocketAddress getAddress() {\n-            return httpServer.getAddress();\n-        }\n-\n-        void reset() {\n-            aDotJar = bDotJar = cDotJar = 0;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"aDotJar=\" + aDotJar + \", bDotJar=\" + bDotJar + \", cDotJar=\" + cDotJar;\n-        }\n-\n-        public void handle(HttpExchange t) throws IOException {\n-            InputStream is = t.getRequestBody();\n-            Headers map = t.getRequestHeaders();\n-            Headers rmap = t.getResponseHeaders();\n-            URI uri = t.getRequestURI();\n-\n-            debug(\"Server: received request for \" + uri);\n-            String path = uri.getPath();\n-            if (path.endsWith(\"a.jar\"))\n-                aDotJar++;\n-            else if (path.endsWith(\"b.jar\"))\n-                bDotJar++;\n-            else if (path.endsWith(\"c.jar\"))\n-                cDotJar++;\n-            else\n-                System.out.println(\"Unexpected resource request\" + path);\n-\n-            while (is.read() != -1);\n-            is.close();\n-\n-            File file = new File(docsDir, path);\n-            if (!file.exists())\n-                throw new RuntimeException(\"Error: request for \" + file);\n-            long clen = file.length();\n-            t.sendResponseHeaders (200, clen);\n-            OutputStream os = t.getResponseBody();\n-            FileInputStream fis = new FileInputStream(file);\n-            try {\n-                byte[] buf = new byte [16 * 1024];\n-                int len;\n-                while ((len=fis.read(buf)) != -1) {\n-                    os.write (buf, 0, len);\n-                }\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-            }\n-            fis.close();\n-            os.close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/Basic.java","additions":0,"deletions":406,"binary":false,"changes":406,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n- \n-# The contents of this file do not matter. It exists\n-# simply to have a service defined in META-INF\/services.\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarA\/META-INF\/services\/my.happy.land","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package a;\n-\n-public class A {\n-    public static void hello() throws Exception {\n-        System.out.println(\"Hello from a.A\");\n-    }\n-}\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarA\/a\/A.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.message.spi;\n-\n-public interface MessageService {\n-    String message();\n-}\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarA\/com\/message\/spi\/MessageService.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-# The contents of this file do not matter. It exists\n-# simply to have a file under META-INF.\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarB\/META-INF\/JAVA2.DS","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-# The contents of this file do not matter. It exists\n-# simply to have a service defined in META-INF\/services.\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarB\/META-INF\/services\/no.name.service","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package b;\n-\n-public class B {\n-    public static void hello() {\n-        System.out.println(\"Hello from b.B\");\n-    }\n-}\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarB\/b\/B.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-corporate=\/fonts\/Company-corporate.ttf\n-crazy-looking=\/fonts\/kidpr.ttf\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarC\/META-INF\/fonts.mf","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-This is not a real font.\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarC\/META-INF\/fonts\/Company-corporate.ttf","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-This is not a real font.\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarC\/META-INF\/fonts\/kidpr.ttf","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,22 +0,0 @@\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-\n-my.impl.StandardMessageService\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarC\/META-INF\/services\/com.message.spi.MessageService","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package my.impl;\n-\n-public class StandardMessageService implements com.message.spi.MessageService {\n-    @Override\n-    public String message() {\n-        return \"This is a message from the standard message service\";\n-    }\n-}\n","filename":"test\/jdk\/sun\/misc\/JarIndex\/metaInfFilenames\/jarC\/my\/impl\/StandardMessageService.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"}]}