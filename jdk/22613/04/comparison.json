{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -199,2 +200,1 @@\n-        this.serviceMap = new ConcurrentHashMap<>();\n-        this.legacyMap = new ConcurrentHashMap<>();\n+        this.servicesMap = new ServicesMap();\n@@ -240,2 +240,1 @@\n-        this.serviceMap = new ConcurrentHashMap<>();\n-        this.legacyMap = new ConcurrentHashMap<>();\n+        this.servicesMap = new ServicesMap();\n@@ -638,1 +637,1 @@\n-    public Object get(Object key) {\n+    public synchronized Object get(Object key) {\n@@ -663,1 +662,1 @@\n-    public Enumeration<Object> keys() {\n+    public synchronized Enumeration<Object> keys() {\n@@ -670,1 +669,1 @@\n-    public Enumeration<Object> elements() {\n+    public synchronized Enumeration<Object> elements() {\n@@ -687,9 +686,0 @@\n-    \/\/ legacyMap changed since last call to getServices()\n-    private transient volatile boolean legacyChanged;\n-    \/\/ serviceMap changed since last call to getServices()\n-    private transient volatile boolean servicesChanged;\n-\n-    \/\/ Map<ServiceKey,Service>\n-    \/\/ used for services added via putService(), initialized on demand\n-    private transient Map<ServiceKey,Service> serviceMap;\n-\n@@ -702,1 +692,703 @@\n-    private transient Set<String> prngAlgos;\n+    private transient Set<ServiceKey> prngAlgos;\n+\n+    \/\/ Map of services registered by this provider. This map may be republished\n+    \/\/ (assigned to a new one instead of modified in place) when a series of\n+    \/\/ changes with the Legacy API must be seen by readers as an atomic\n+    \/\/ operation. See Providers::putAll.\n+    private transient volatile ServicesMap servicesMap;\n+\n+    \/*\n+     * This class defines a structure to store and obtain services registered by\n+     * this provider, according to the Current (preferred) and Legacy APIs.\n+     * Synchronization is required for write accesses, while reads are\n+     * lock-free.\n+     *\/\n+    private final class ServicesMap {\n+        \/*\n+         * Record to aggregate information about the lookup of a service on the\n+         * internal map. See ServicesMap::find for a description of possible\n+         * values.\n+         *\/\n+        private record MappingInfo(Service svc, ServiceKey algKey,\n+                Boolean isLegacy) {}\n+\n+        \/\/ Placeholder for a thread to mark that serviceSet values are being\n+        \/\/ computed after a services update. Only one thread at a time can\n+        \/\/ effectively assign this value.\n+        private static final Set<Service> SERVICE_SET_IN_PROGRESS = Set.of();\n+\n+        \/\/ Unmodifiable set of all services. Possible values for this field\n+        \/\/ are: 1) null (indicates that the set has to be recomputed after a\n+        \/\/ service update), 2) SERVICE_SET_IN_PROGRESS (indicates that a thread\n+        \/\/ is recomputing its value), and 3) an actual set of services.\n+        private final AtomicReference<Set<Service>> serviceSet;\n+\n+        \/\/ The internal services map, containing services registered with the\n+        \/\/ Current and the Legacy APIs. Concurrent read and write access to this\n+        \/\/ map is expected. Both algorithm and alias service keys are added to\n+        \/\/ this map.\n+        private final Map<ServiceKey, Service> services;\n+\n+        \/\/ Auxiliary set to determine if a service on the services map was added\n+        \/\/ with the Legacy API. The absence of a service key on this set is an\n+        \/\/ indication that the service was either not added or added with the\n+        \/\/ Current API. Only algorithm service keys are added to this set.\n+        private final Set<ServiceKey> legacySvcKeys;\n+\n+        \/\/ Auxiliary map to keep track of the Properties map entries that\n+        \/\/ originated entries on the internal map. This information is used to\n+        \/\/ avoid inconsistencies. Both algorithm and alias service keys are\n+        \/\/ added to this map.\n+        private final Map<ServiceKey, String> serviceProps;\n+\n+        \/\/ Auxiliary map to keep track of the Properties map entries that\n+        \/\/ originated service attributes on the internal map. This information\n+        \/\/ is used to avoid inconsistencies. Only algorithm service keys are\n+        \/\/ added to this map.\n+        private final Map<ServiceKey, Map<UString, String>> serviceAttrProps;\n+\n+        ServicesMap() {\n+            serviceSet = new AtomicReference<>();\n+            services = new ConcurrentHashMap<>();\n+            legacySvcKeys = new HashSet<>();\n+            serviceProps = new HashMap<>();\n+            serviceAttrProps = new HashMap<>();\n+        }\n+\n+        \/*\n+         * Constructor to create a thin working copy such that readers of the\n+         * original map do not notice any new changes. Used for atomic changes\n+         * with the Legacy API. See Providers::putAll.\n+         *\/\n+        ServicesMap(ServicesMap original) {\n+            serviceSet = new AtomicReference<>(original.serviceSet.get());\n+            services = new ConcurrentHashMap<>(original.services);\n+            legacySvcKeys = original.legacySvcKeys;\n+            serviceProps = original.serviceProps;\n+            serviceAttrProps = original.serviceAttrProps;\n+        }\n+\n+        \/*\n+         * Returns an unmodifiable set of available services. Recomputes\n+         * serviceSet if needed, after a service update. Both services added\n+         * with the Current and Legacy APIs are included. If no services are\n+         * found, the returned set is empty. This method is thread-safe and\n+         * lock-free.\n+         *\/\n+        Set<Service> getServices() {\n+            Set<Service> serviceSetLocal = serviceSet.compareAndExchange(\n+                    null, SERVICE_SET_IN_PROGRESS);\n+            if (serviceSetLocal == null ||\n+                    serviceSetLocal == SERVICE_SET_IN_PROGRESS) {\n+                \/\/ A cached set is not available. Instead of locking, compute\n+                \/\/ the set to be returned and, eventually, make it available\n+                \/\/ for others to use.\n+                Set<Service> newSet = computeServicesSet();\n+                if (serviceSetLocal == null) {\n+                    \/\/ We won the race to make the computed set available for\n+                    \/\/ others to use. However, only make it available if it\n+                    \/\/ is still current (in other words, there were no further\n+                    \/\/ changes). If it is not current, the next reader will\n+                    \/\/ do the job.\n+                    serviceSet.compareAndExchange(\n+                            SERVICE_SET_IN_PROGRESS, newSet);\n+                }\n+                serviceSetLocal = newSet;\n+            }\n+            return serviceSetLocal;\n+        }\n+\n+        private Set<Service> computeServicesSet() {\n+            Set<Service> set = new LinkedHashSet<>();\n+            for (Map.Entry<ServiceKey, Service> e : services.entrySet()) {\n+                Service svc = e.getValue();\n+                \/\/ Skip alias based entries and filter out invalid services.\n+                \/\/\n+                \/\/ Note: Multiple versions of the same service (reflecting\n+                \/\/ different points in time) can be generated by concurrent\n+                \/\/ writes with the Legacy API and, as a result of the\n+                \/\/ copy-on-write strategy, seen under different service keys\n+                \/\/ here. Each version has a unique object identity and, thus,\n+                \/\/ would be distinguishable for a Set<Service> set. To avoid\n+                \/\/ duplicates, we skip alias keys and use the version of the\n+                \/\/ service pointed by the algorithm key.\n+                if (e.getKey().equals(svc.algKey) && isValid(svc)) {\n+                    set.add(svc);\n+                }\n+            }\n+            return Collections.unmodifiableSet(set);\n+        }\n+\n+        \/*\n+         * Returns an available service. Both services added with the Current\n+         * and Legacy APIs are considered in the search. Thread-safe and\n+         * lock-free.\n+         *\/\n+        Service getService(ServiceKey key) {\n+            Service svc = services.get(key);\n+            return svc != null && isValid(svc) ? svc : null;\n+        }\n+\n+        \/*\n+         * Clears the internal ServicesMap state. The caller must synchronize\n+         * changes with the Properties map.\n+         *\/\n+        void clear() {\n+            serviceSet.set(null);\n+            services.clear();\n+            legacySvcKeys.clear();\n+            serviceProps.clear();\n+            serviceAttrProps.clear();\n+        }\n+\n+        \/*\n+         * Finds information about a service on the internal map. The key for\n+         * the lookup can be either algorithm or alias based. If the service is\n+         * found, svc refers to it, algKey to the algorithm service key and\n+         * isLegacy informs if the service was stored with the Current or the\n+         * Legacy API. Otherwise, svc is null, algKey refers to the key used for\n+         * the lookup and isLegacy is null.\n+         *\/\n+        private MappingInfo find(ServiceKey key) {\n+            Service svc = services.get(key);\n+            ServiceKey algKey = svc != null ? svc.algKey : key;\n+            Boolean isLegacy = svc != null ?\n+                    legacySvcKeys.contains(algKey) : null;\n+            return new MappingInfo(svc, algKey, isLegacy);\n+        }\n+\n+        \/*\n+         * Signals that there were changes on the services map and the cached\n+         * set of services need to be recomputed before use.\n+         *\/\n+        private void notifyChanges() {\n+            serviceSet.set(null);\n+        }\n+\n+        \/*\n+         * A service is invalid if it was added with the Legacy API through an\n+         * alias and does not have class information yet. We keep these services\n+         * on the internal map but filter them out for readers, so they don't\n+         * cause a NullPointerException when trying to create a new instance.\n+         *\/\n+        private boolean isValid(Service svc) {\n+            return svc.className != null;\n+        }\n+\n+        \/*\n+         * Methods to add and remove services to the map according to the\n+         * Current API. These methods update the Properties map to reflect\n+         * service changes, including algorithms, aliases and attributes.\n+         *\n+         * Services added with the Legacy API may be overwritten with these\n+         * methods.\n+         *\n+         * These methods guarantee atomicity from a service reader point of\n+         * view. In other words, a reader that gets a service will see all its\n+         * attributes and aliases as they were at time of registration.\n+         *\/\n+\n+        boolean putService(Service svc) {\n+            svc.generateServiceKeys();\n+\n+            \/\/ Define a set of algorithm and alias keys that, if already on the\n+            \/\/ services map, will be kept at all times until overwritten. This\n+            \/\/ prevents concurrent readers from seeing 'holes' on the map while\n+            \/\/ doing updates.\n+            Set<ServiceKey> keysToBeKept =\n+                    new HashSet<>(svc.aliasKeys.size() + 1);\n+            keysToBeKept.add(svc.algKey);\n+            keysToBeKept.addAll(svc.aliasKeys.keySet());\n+\n+            \/\/ The new service algorithm key may be in use already.\n+            resolveKeyConflict(svc.algKey, keysToBeKept);\n+\n+            \/\/ The service will be registered to its provider's ServicesMap.\n+            svc.registered = true;\n+\n+            \/\/ Register the new service under its algorithm service key. At this\n+            \/\/ point, readers will have access to it.\n+            services.put(svc.algKey, svc);\n+\n+            \/\/ Add an entry to the Properties map to reflect the new service\n+            \/\/ under its algorithm key, and keep track of this information for\n+            \/\/ further changes in the future (i.e. removal of the service).\n+            String propKey = svc.getType() + \".\" + svc.getAlgorithm();\n+            serviceProps.put(svc.algKey, propKey);\n+            Provider.super.put(propKey, svc.getClassName());\n+\n+            \/\/ Register the new service under its aliases.\n+            for (Map.Entry<ServiceKey, String> e : svc.aliasKeys.entrySet()) {\n+                ServiceKey aliasKey = e.getKey();\n+\n+                \/\/ The new service alias may be in use already.\n+                resolveKeyConflict(aliasKey, keysToBeKept);\n+\n+                \/\/ Register the new service under its alias service key. At this\n+                \/\/ point, readers will have access through this alias.\n+                services.put(aliasKey, svc);\n+\n+                \/\/ Add an entry to the Properties map to reflect the new service\n+                \/\/ under its alias service key, and keep track of this\n+                \/\/ information for further changes in the future (i.e. removal\n+                \/\/ of the service).\n+                propKey = ALIAS_PREFIX + svc.getType() + \".\" + e.getValue();\n+                serviceProps.put(aliasKey, propKey);\n+                Provider.super.put(propKey, svc.getAlgorithm());\n+            }\n+\n+            if (!svc.attributes.isEmpty()) {\n+                \/\/ Register the new service attributes on the Properties map and\n+                \/\/ keep track of them for further changes in the future (i.e.\n+                \/\/ removal of the service).\n+                Map<UString, String> newAttrProps =\n+                        new HashMap<>(svc.attributes.size());\n+                for (Map.Entry<UString, String> attr :\n+                        svc.attributes.entrySet()) {\n+                    propKey = svc.getType() + \".\" + svc.getAlgorithm() + \" \" +\n+                            attr.getKey().string;\n+                    newAttrProps.put(attr.getKey(), propKey);\n+                    Provider.super.put(propKey, attr.getValue());\n+                }\n+                serviceAttrProps.put(svc.algKey, newAttrProps);\n+            }\n+\n+            Provider.this.checkAndUpdateSecureRandom(svc.algKey, true);\n+\n+            return true;\n+        }\n+\n+        \/*\n+         * Handle cases in which a service key (algorithm or alias based) is in\n+         * use already. This might require modifications to a service, the\n+         * Properties map or auxiliary structures. This method must be called\n+         * from the Current API only.\n+         *\/\n+        private void resolveKeyConflict(ServiceKey key,\n+                Set<ServiceKey> keysToBeKept) {\n+            assert keysToBeKept.contains(key) :\n+                    \"Inconsistent keysToBeKept set.\";\n+            MappingInfo miByKey = find(key);\n+            if (miByKey.svc != null) {\n+                \/\/ The service key (algorithm or alias) is in use already.\n+                boolean opSucceeded = true;\n+                if (miByKey.algKey.equals(key)) {\n+                    \/\/ It is used as an algorithm. Remove the service.\n+                    opSucceeded = removeCommon(miByKey, false, keysToBeKept);\n+                } else {\n+                    \/\/ It is used as an alias.\n+                    if (miByKey.isLegacy) {\n+                        \/\/ The service was added with the Legacy API. Remove the\n+                        \/\/ alias only.\n+                        opSucceeded = removeAliasLegacy(miByKey.algKey, key,\n+                                keysToBeKept);\n+                    } else {\n+                        \/\/ The service was added with the Current API. Overwrite\n+                        \/\/ the alias entry on the services map without modifying\n+                        \/\/ the service that is currently using it.\n+\n+                        \/\/ Remove any Properties map key entry because, if no\n+                        \/\/ longer used as an alias, the entry would not be\n+                        \/\/ overwritten. Note: The serviceProps key entry will be\n+                        \/\/ overwritten later.\n+                        String oldPropKey = serviceProps.remove(key);\n+                        assert oldPropKey != null : \"Invalid alias property.\";\n+                        Provider.super.remove(oldPropKey);\n+                    }\n+                }\n+                assert opSucceeded : \"Unexpected error removing an existing \" +\n+                        \"service or alias.\";\n+            }\n+        }\n+\n+        boolean removeService(Service svc) {\n+            if (svc.algKey != null) {\n+                MappingInfo mi = find(svc.algKey);\n+                if (mi.svc != null) {\n+                    boolean opSucceeded = removeCommon(mi, false,\n+                            Collections.emptySet());\n+                    assert opSucceeded : \"Unexpected error removing an \" +\n+                            \"existing service.\";\n+                    return opSucceeded;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        \/*\n+         * Common (Current and Legacy) API methods to add and remove services.\n+         *\/\n+\n+        \/*\n+         * This method is invoked both when removing and overwriting a service.\n+         * The keysToBeKept set is used when overwriting to prevent readers from\n+         * seeing a 'hole' on the services map between removing and adding\n+         * entries.\n+         *\/\n+        private boolean removeCommon(MappingInfo mi, boolean legacyApiCall,\n+                Set<ServiceKey> keysToBeKept) {\n+            assert mi.svc != null : \"Invalid service for removal.\";\n+            if (!mi.isLegacy && legacyApiCall) {\n+                \/\/ Services added with the Current API cannot be removed with\n+                \/\/ the Legacy API.\n+                return false;\n+            }\n+\n+            if (mi.isLegacy) {\n+                legacySvcKeys.remove(mi.algKey);\n+            }\n+\n+            if (!keysToBeKept.contains(mi.algKey)) {\n+                services.remove(mi.algKey);\n+            }\n+\n+            \/\/ Update the Properties map to reflect the algorithm removal. Note:\n+            \/\/ oldPropKey may be null for services added through aliases or\n+            \/\/ attributes (Legacy API) that still don't have a class name\n+            \/\/ (invalid).\n+            String oldPropKey = serviceProps.remove(mi.algKey);\n+            if (oldPropKey != null) {\n+                Provider.super.remove(oldPropKey);\n+            }\n+\n+            \/\/ Remove registered service aliases.\n+            for (ServiceKey aliasKey : mi.svc.aliasKeys.keySet()) {\n+                if (!mi.isLegacy) {\n+                    \/\/ Services added with the Current API can have aliases\n+                    \/\/ overwritten by other services added with the same API. Do\n+                    \/\/ nothing in these cases: the alias on the services map\n+                    \/\/ does not belong to the removed service anymore.\n+                    MappingInfo miByAlias = find(aliasKey);\n+                    if (miByAlias.svc != mi.svc) {\n+                        continue;\n+                    }\n+                }\n+                if (!keysToBeKept.contains(aliasKey)) {\n+                    services.remove(aliasKey);\n+                }\n+\n+                \/\/ Update the Properties map to reflect the alias removal. Note:\n+                \/\/ oldPropKey cannot be null because aliases always have a\n+                \/\/ corresponding Properties map entry.\n+                oldPropKey = serviceProps.remove(aliasKey);\n+                assert oldPropKey != null :\n+                        \"Unexpected null Property value for an alias.\";\n+                Provider.super.remove(oldPropKey);\n+            }\n+\n+            \/\/ Remove registered service attributes.\n+            Map<UString, String> oldAttrProps =\n+                    serviceAttrProps.remove(mi.algKey);\n+            if (oldAttrProps != null) {\n+                for (String oldAttrPropKey : oldAttrProps.values()) {\n+                    \/\/ Update the Properties map to reflect the attribute\n+                    \/\/ removal. Note: oldAttrPropKey cannot be null because\n+                    \/\/ attributes always have a corresponding Properties map\n+                    \/\/ entry.\n+                    assert oldAttrPropKey != null :\n+                            \"Unexpected null Property value for an attribute.\";\n+                    Provider.super.remove(oldAttrPropKey);\n+                }\n+            }\n+\n+            notifyChanges();\n+\n+            Provider.this.checkAndUpdateSecureRandom(mi.svc.algKey, false);\n+\n+            return true;\n+        }\n+\n+        \/*\n+         * Methods to add, modify and remove services on the map according to\n+         * the Legacy API. These methods update the Properties map to reflect\n+         * service changes, including algorithms, aliases and attributes.\n+         *\n+         * Services added with the Current API cannot be overwritten with this\n+         * API.\n+         *\n+         * Notice that these methods do not guarantee atomicity in a sequence of\n+         * operations from a service reader point of view. As an example, a\n+         * service reader may get a service missing an attribute if looked up\n+         * between a writer's ServicesMap::putClassNameLegacy and\n+         * ServicesMap::putAttributeLegacy calls. For atomic changes with the\n+         * Legacy API see Provider::putAll.\n+         *\/\n+\n+        boolean putClassNameLegacy(ServiceKey key, String className,\n+                String propKey) {\n+            assert key != null && className != null && propKey != null :\n+                    \"Service information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                String canonicalPropKey = propKey;\n+                if (oldMi.svc != null) {\n+                    \/\/ The service exists. Get its Properties map entry. Note:\n+                    \/\/ Services added through an alias or an attribute may don't\n+                    \/\/ have one.\n+                    String oldPropKey = serviceProps.get(oldMi.algKey);\n+                    if (oldMi.algKey.equals(key)) {\n+                        \/\/ The service was found by an algorithm.\n+                        if (oldPropKey != null) {\n+                            \/\/ Remove any previous Properties map entry before\n+                            \/\/ adding a new one, so we handle differences in\n+                            \/\/ casing.\n+                            Provider.super.remove(oldPropKey);\n+                        }\n+                    } else {\n+                        \/\/ The service was found by an alias. Use an algorithm\n+                        \/\/ entry on the Properties map. Create a new one if it\n+                        \/\/ does not exist.\n+                        canonicalPropKey = oldPropKey != null ? oldPropKey :\n+                                newSvc.getType() + \".\" + newSvc.getAlgorithm();\n+                    }\n+                }\n+\n+                newSvc.className = className;\n+\n+                \/\/ Keep track of the Properties map entry for further changes in\n+                \/\/ the future (i.e. removal of the service).\n+                serviceProps.put(oldMi.algKey, canonicalPropKey);\n+                Provider.super.put(canonicalPropKey, className);\n+\n+                Provider.this.checkAndUpdateSecureRandom(newSvc.algKey, true);\n+\n+                return true;\n+            });\n+        }\n+\n+        boolean putAliasLegacy(ServiceKey key, ServiceKey aliasKey,\n+                String propKey) {\n+            assert key != null && aliasKey != null && propKey != null :\n+                    \"Alias information missing.\";\n+            assert key.type.equals(aliasKey.type) :\n+                    \"Inconsistent service key types.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                MappingInfo miByAlias = find(aliasKey);\n+                if (miByAlias.svc != null) {\n+                    \/\/ The alias is associated to a service on the map.\n+                    if (miByAlias.algKey.equals(aliasKey)) {\n+                        \/\/ The alias is an algorithm. Never overwrite algorithms\n+                        \/\/ with aliases from the Legacy API.\n+                        return false;\n+                    } else if (!miByAlias.isLegacy) {\n+                        \/\/ Do not remove the alias of services added with the\n+                        \/\/ Current API.\n+                        return false;\n+                    } else if (miByAlias.svc == oldMi.svc) {\n+                        \/\/ The service has the alias that we are adding. This is\n+                        \/\/ possible if, for example, the alias casing is\n+                        \/\/ changing.\n+                        \/\/\n+                        \/\/ Update the Properties map to remove the alias with\n+                        \/\/ the old casing. Note: oldPropKey cannot be null\n+                        \/\/ because aliases always have a corresponding\n+                        \/\/ Properties map entry.\n+                        String oldPropKey = serviceProps.remove(aliasKey);\n+                        assert oldPropKey != null :\n+                                \"Unexpected null Property value for an alias.\";\n+                        Provider.super.remove(oldPropKey);\n+                    } else {\n+                        \/\/ The alias belongs to a different service. Remove it\n+                        \/\/ first.\n+                        boolean opSucceeded = removeAliasLegacy(\n+                                miByAlias.algKey, aliasKey, Set.of(aliasKey));\n+                        assert opSucceeded :\n+                                \"Unexpected error removing an alias.\";\n+                    }\n+                } else {\n+                    \/\/ The alias was not found on the map.\n+                    if (aliasKey.equals(key)) {\n+                        \/\/ The alias would be equal to the algorithm for the new\n+                        \/\/ service.\n+                        return false;\n+                    }\n+                }\n+\n+                newSvc.addAliasKey(aliasKey);\n+\n+                \/\/ Keep track of the Properties map entry for further changes in\n+                \/\/ the future (i.e. removal of the service).\n+                serviceProps.put(aliasKey, propKey);\n+                \/\/ If the service to which we will add an alias was found by an\n+                \/\/ alias, use its algorithm for the Properties map entry.\n+                String canonicalAlgorithm = oldMi.algKey.equals(key) ?\n+                        key.originalAlgorithm : newSvc.getAlgorithm();\n+                Provider.super.put(propKey, canonicalAlgorithm);\n+\n+                return true;\n+            });\n+        }\n+\n+        boolean putAttributeLegacy(ServiceKey key, String attrName,\n+                String attrValue, String propKey) {\n+            assert key != null && attrName != null && attrValue != null &&\n+                    propKey != null : \"Attribute information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                String canonicalPropKey = propKey;\n+                UString attrNameKey = new UString(attrName);\n+                Map<UString, String> attrProps =\n+                        serviceAttrProps.computeIfAbsent(\n+                                oldMi.algKey, k -> new HashMap<>());\n+                assert oldMi.svc != null || attrProps.isEmpty() :\n+                        \"Inconsistent service attributes data.\";\n+                \/\/ Try to get the attribute's Properties map entry. Note:\n+                \/\/ oldPropKey can be null if the service was not found or does\n+                \/\/ not have the attribute.\n+                String oldPropKey = attrProps.get(attrNameKey);\n+                if (oldMi.algKey.equals(key)) {\n+                    \/\/ The service was found by an algorithm.\n+                    if (oldPropKey != null) {\n+                        \/\/ Remove any previous Properties map entry before\n+                        \/\/ adding a new one, so we handle differences in casing.\n+                        Provider.super.remove(oldPropKey);\n+                    }\n+                } else {\n+                    \/\/ The service was found by an alias. Use an algorithm based\n+                    \/\/ entry on the Properties map. Create a new one if it does\n+                    \/\/ not exist.\n+                    canonicalPropKey = oldPropKey != null ? oldPropKey :\n+                            newSvc.getType() + \".\" + newSvc.getAlgorithm() +\n+                            \" \" + attrName;\n+                }\n+\n+                newSvc.addAttribute(attrName, attrValue);\n+\n+                \/\/ Keep track of the Properties map entry for further changes in\n+                \/\/ the future (i.e. removal of the service).\n+                attrProps.put(attrNameKey, canonicalPropKey);\n+                Provider.super.put(canonicalPropKey, attrValue);\n+\n+                return true;\n+            });\n+        }\n+\n+        boolean removeLegacy(ServiceKey key, String className) {\n+            assert key != null && className != null :\n+                    \"Service information missing.\";\n+            MappingInfo mi = find(key);\n+            if (mi.svc != null) {\n+                assert className.equals(mi.svc.getClassName()) :\n+                        \"Unexpected class name.\";\n+                return removeCommon(mi, true, Collections.emptySet());\n+            }\n+            assert false : \"Should not reach.\";\n+            return false;\n+        }\n+\n+        boolean removeAliasLegacy(ServiceKey key, ServiceKey aliasKey) {\n+            return removeAliasLegacy(key, aliasKey, Collections.emptySet());\n+        }\n+\n+        \/*\n+         * This method is invoked both when removing and overwriting a service\n+         * alias. The keysToBeKept set is used when overwriting to prevent\n+         * readers from seeing a 'hole' on the services map between removing and\n+         * adding entries.\n+         *\/\n+        private boolean removeAliasLegacy(ServiceKey key, ServiceKey aliasKey,\n+                Set<ServiceKey> keysToBeKept) {\n+            assert key != null && aliasKey != null && keysToBeKept != null :\n+                    \"Alias information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                MappingInfo miByAlias = find(aliasKey);\n+                if (oldMi.svc != null && miByAlias.svc == oldMi.svc &&\n+                        !miByAlias.algKey.equals(aliasKey)) {\n+                    \/\/ The alias is a real alias and is associated to the\n+                    \/\/ service on the map.\n+                    if (!keysToBeKept.contains(aliasKey)) {\n+                        services.remove(aliasKey);\n+                    }\n+\n+                    newSvc.removeAliasKey(aliasKey);\n+\n+                    \/\/ Update the Properties map to reflect the alias removal.\n+                    \/\/ Note: oldPropKey cannot be null because aliases always\n+                    \/\/ have a corresponding Properties map entry.\n+                    String oldPropKey = serviceProps.remove(aliasKey);\n+                    assert oldPropKey != null : \"Invalid alias property.\";\n+                    Provider.super.remove(oldPropKey);\n+\n+                    return true;\n+                }\n+                assert false : \"Should not reach.\";\n+                return false;\n+            });\n+        }\n+\n+        boolean removeAttributeLegacy(ServiceKey key, String attrName,\n+                String attrValue) {\n+            assert key != null && attrName != null && attrValue != null :\n+                    \"Attribute information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                Map<UString, String> oldAttrProps =\n+                        serviceAttrProps.get(oldMi.algKey);\n+                if (oldAttrProps != null) {\n+                    \/\/ The service was found and has attributes.\n+                    assert oldMi.svc != null :\n+                            \"Inconsistent service attributes data.\";\n+\n+                    newSvc.removeAttribute(attrName, attrValue);\n+                    assert newSvc.getAttribute(attrName) == null :\n+                            \"Attribute was not removed from the service.\";\n+\n+                    \/\/ Update the Properties map to reflect the attribute\n+                    \/\/ removal. Note: oldPropKey cannot be null because\n+                    \/\/ attributes always have a corresponding Properties map\n+                    \/\/ entry.\n+                    String oldPropKey = oldAttrProps.remove(\n+                            new UString(attrName));\n+                    assert oldPropKey != null : \"Invalid attribute property.\";\n+                    Provider.super.remove(oldPropKey);\n+\n+                    if (oldAttrProps.isEmpty()) {\n+                        \/\/ If the removed attribute was the last one, remove the\n+                        \/\/ map.\n+                        serviceAttrProps.remove(oldMi.algKey);\n+                    }\n+\n+                    return true;\n+                }\n+                assert false : \"Should not reach.\";\n+                return false;\n+            });\n+        }\n+\n+        @FunctionalInterface\n+        private interface ServiceUpdateCallback {\n+            boolean apply(MappingInfo oldMi, Service newSvc);\n+        }\n+\n+        \/*\n+         * This method tries to find a service on the map (based on an\n+         * algorithm or alias) and pass a copy of it to an update callback\n+         * (copy-on-write). If the service found was added with the Current API,\n+         * no update should be done. If a service was not found, a new instance\n+         * may be created.\n+         *\n+         * The updated version of the service is put on the services map.\n+         * Algorithm and alias based entries pointing to the old version of the\n+         * service are overwritten.\n+         *\/\n+        private boolean updateSvc(ServiceKey key,\n+                ServiceUpdateCallback updateCb) {\n+            Service newSvc;\n+            MappingInfo oldMi = find(key);\n+            if (oldMi.svc != null) {\n+                \/\/ Service exists.\n+                if (!oldMi.isLegacy) {\n+                    \/\/ Don't update services added with the Current API.\n+                    return false;\n+                }\n+                \/\/ Create a copy of the service for a copy-on-write update.\n+                newSvc = new Service(oldMi.svc);\n+            } else {\n+                \/\/ Service does not exist.\n+                newSvc = new Service(Provider.this, key);\n+            }\n+            if (!updateCb.apply(oldMi, newSvc)) {\n+                \/\/ Something went wrong and the update should not be done.\n+                return false;\n+            }\n+\n+            \/\/ The service (or its updated version) will be registered to its\n+            \/\/ provider's ServicesMap.\n+            newSvc.registered = true;\n@@ -704,3 +1396,14 @@\n-    \/\/ Map<ServiceKey,Service>\n-    \/\/ used for services added via legacy methods, init on demand\n-    private transient Map<ServiceKey,Service> legacyMap;\n+            \/\/ Register the updated version of the service under its algorithm\n+            \/\/ and aliases on the map. This may overwrite entries or add new\n+            \/\/ ones. The previous callback should have handled the removal of an\n+            \/\/ alias.\n+            for (ServiceKey aliasKey : newSvc.aliasKeys.keySet()) {\n+                services.put(aliasKey, newSvc);\n+            }\n+\n+            assert oldMi.algKey.type.equals(newSvc.getType()) &&\n+                    oldMi.algKey.originalAlgorithm.equals(\n+                            newSvc.getAlgorithm()) : \"Invalid key.\";\n+            services.put(oldMi.algKey, newSvc);\n+\n+            legacySvcKeys.add(oldMi.algKey);\n@@ -708,3 +1411,6 @@\n-    \/\/ Set<Service>\n-    \/\/ Unmodifiable set of all services. Initialized on demand.\n-    private transient volatile Set<Service> serviceSet;\n+            \/\/ Notify a change.\n+            notifyChanges();\n+\n+            return true;\n+        }\n+    }\n@@ -723,0 +1429,13 @@\n+    \/*\n+     * Creates a copy of the Properties map that is useful to iterate when\n+     * applying changes to the original one. Notice that we are calling\n+     * super.entrySet() purposefully to avoid landing into a subclass override.\n+     *\/\n+    private Properties copyProperties() {\n+        Properties copy = new Properties(super.size());\n+        for (Map.Entry<Object, Object> entry : super.entrySet()) {\n+            copy.put(entry.getKey(), entry.getValue());\n+        }\n+        return copy;\n+    }\n+\n@@ -738,5 +1457,1 @@\n-        Map<Object,Object> copy = new HashMap<>();\n-        for (Map.Entry<Object,Object> entry : super.entrySet()) {\n-            copy.put(entry.getKey(), entry.getValue());\n-        }\n-\n+        Properties copy = copyProperties();\n@@ -752,2 +1467,1 @@\n-        this.serviceMap = new ConcurrentHashMap<>();\n-        this.legacyMap = new ConcurrentHashMap<>();\n+        this.servicesMap = new ServicesMap();\n@@ -760,8 +1474,36 @@\n-    \/\/ returns false if no update necessary, i.e. key isn't String or\n-    \/\/ is String, but it's provider-related (name\/version\/info\/className)\n-    private static boolean checkLegacy(Object key) {\n-        if (key instanceof String && ((String)key).startsWith(\"Provider.\")) {\n-            \/\/ ignore provider related updates\n-            return false;\n-        } else {\n-            return true;\n+    \/*\n+     * Enum to determine if changes to the Properties map must be applied by the\n+     * caller (UPDATE) or skipped (SKIP).\n+     *\n+     * If a change does not concern a ServicesMap, UPDATE is returned. An\n+     * example of this is when adding, modifying or removing an entry that is\n+     * not a service, alias or attribute.\n+     *\n+     * If the change concerns a ServicesMap, SKIP is returned. The change may\n+     * have been applied internally or ignored due to an error. In the former\n+     * case, Properties map entries are synchronized. In the latter, Properties\n+     * map entries are not modified.\n+     *\/\n+    private enum PropertiesMapAction {\n+        UPDATE,\n+        SKIP\n+    }\n+\n+    private PropertiesMapAction doLegacyOp(ServicesMap servicesMap, Object key,\n+            Object value, Object oldValue, OPType opType) {\n+        if (key instanceof String ks) {\n+            if (ks.startsWith(\"Provider.\")) {\n+                \/\/ Ignore provider related updates.\n+                return PropertiesMapAction.SKIP;\n+            }\n+            if (value instanceof String vs) {\n+                return parseLegacy(servicesMap, ks, vs, opType);\n+            } else if (value != null && oldValue instanceof String oldValueS &&\n+                    opType == OPType.ADD) {\n+                \/\/ An entry in the Properties map potentially concerning the\n+                \/\/ ServicesMap is about to be replaced by one that does not.\n+                \/\/ From the ServicesMap point of view, this could be equivalent\n+                \/\/ to a removal. In any case, let the caller proceed with the\n+                \/\/ Properties map update.\n+                parseLegacy(servicesMap, ks, oldValueS, OPType.REMOVE);\n+            }\n@@ -769,0 +1511,2 @@\n+        \/\/ The change does not concern a ServicesMap.\n+        return PropertiesMapAction.UPDATE;\n@@ -775,0 +1519,3 @@\n+        \/\/ For service readers to see this change as atomic, add the elements in\n+        \/\/ a local thin copy of the ServicesMap and then publish it.\n+        ServicesMap servicesMapCopy = new ServicesMap(servicesMap);\n@@ -776,1 +1523,1 @@\n-            implPut(e.getKey(), e.getValue());\n+            implPut(servicesMapCopy, e.getKey(), e.getValue());\n@@ -778,0 +1525,1 @@\n+        servicesMap = servicesMapCopy;\n@@ -780,2 +1528,6 @@\n-    private Object implRemove(Object key) {\n-        if (!checkLegacy(key)) return null;\n+    private void implClear() {\n+        servicesMap.clear();\n+        prngAlgos.clear();\n+        super.clear();\n+        putId();\n+    }\n@@ -783,5 +1535,4 @@\n-        Object o = super.remove(key);\n-        if (o instanceof String so && key instanceof String sk) {\n-            parseLegacy(sk, so, OPType.REMOVE);\n-        }\n-        return o;\n+    private Object implRemove(Object key) {\n+        Object oldValue = super.get(key);\n+        return doLegacyOp(servicesMap, key, oldValue, null, OPType.REMOVE) ==\n+                PropertiesMapAction.UPDATE ? super.remove(key) : oldValue;\n@@ -791,5 +1542,3 @@\n-        if (!checkLegacy(key)) return false;\n-\n-        boolean result = super.remove(key, value);\n-        if (result && key instanceof String sk && value instanceof String sv) {\n-            parseLegacy(sk, sv, OPType.REMOVE);\n+        if (Objects.equals(super.get(key), value) && value != null) {\n+            implRemove(key);\n+            return !super.contains(key);\n@@ -797,1 +1546,1 @@\n-        return result;\n+        return false;\n@@ -801,9 +1550,6 @@\n-        if (!checkLegacy(key)) return false;\n-\n-        boolean result = super.replace(key, oldValue, newValue);\n-        if (result && key instanceof String sk) {\n-            if (newValue instanceof String sv) {\n-                parseLegacy(sk, sv, OPType.ADD);\n-            } else if (oldValue instanceof String sv) {\n-                parseLegacy(sk, sv, OPType.REMOVE);\n-            }\n+        Objects.requireNonNull(oldValue);\n+        Objects.requireNonNull(newValue);\n+        if (super.containsKey(key) &&\n+                Objects.equals(super.get(key), oldValue)) {\n+            implPut(key, newValue);\n+            return super.get(key) == newValue;\n@@ -811,1 +1557,1 @@\n-        return result;\n+        return false;\n@@ -815,11 +1561,3 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.replace(key, value);\n-        if (key instanceof String sk) {\n-            if (o instanceof String so) {\n-                if (value instanceof String sv) {\n-                    parseLegacy(sk, sv, OPType.ADD);\n-                } else {\n-                    parseLegacy(sk, so, OPType.REMOVE);\n-                }\n-            }\n+        Objects.requireNonNull(value);\n+        if (super.containsKey(key)) {\n+            return implPut(key, value);\n@@ -827,1 +1565,1 @@\n-        return o;\n+        return null;\n@@ -833,15 +1571,3 @@\n-\n-        super.replaceAll(function);\n-        \/\/ clear out all existing mappings and start fresh\n-        legacyMap.clear();\n-        legacyChanged = true;\n-        for (Map.Entry<Object, Object> entry : super.entrySet()) {\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n-            if ((key instanceof String sk) && (value instanceof String sv)) {\n-                if (!checkLegacy(sk)) {\n-                    continue;\n-                }\n-                parseLegacy(sk, sv, OPType.ADD);\n-            }\n-        }\n+        Properties propertiesCopy = copyProperties();\n+        propertiesCopy.replaceAll(function);\n+        putAll(propertiesCopy);\n@@ -854,9 +1580,8 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.merge(key, value, remappingFunction);\n-        if (key instanceof String sk) {\n-            if (o == null) {\n-                parseLegacy(sk, null, OPType.REMOVE);\n-            } else if (o instanceof String so) {\n-                parseLegacy(sk, so, OPType.ADD);\n-            }\n+        Objects.requireNonNull(value);\n+        Object oldValue = super.get(key);\n+        Object newValue = (oldValue == null) ? value :\n+                remappingFunction.apply(oldValue, value);\n+        if (newValue == null) {\n+            implRemove(key);\n+        } else {\n+            implPut(key, newValue);\n@@ -864,1 +1589,1 @@\n-        return o;\n+        return super.get(key);\n@@ -870,10 +1595,8 @@\n-\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.compute(key, remappingFunction);\n-        if (key instanceof String sk) {\n-            if (o == null) {\n-                parseLegacy(sk, null, OPType.REMOVE);\n-            } else if (o instanceof String so) {\n-                parseLegacy(sk, so, OPType.ADD);\n-            }\n+        Object oldValue = super.get(key);\n+        Object newValue = remappingFunction.apply(key, oldValue);\n+        if (newValue != null) {\n+            implPut(key, newValue);\n+        } else if (oldValue != null) {\n+            \/\/ The Properties map cannot contain null values, so checking\n+            \/\/ super.containsKey(key) would be superfluous.\n+            implRemove(key);\n@@ -881,1 +1604,1 @@\n-        return o;\n+        return super.get(key);\n@@ -887,5 +1610,7 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.computeIfAbsent(key, mappingFunction);\n-        if (o instanceof String so && key instanceof String sk) {\n-            parseLegacy(sk, so, OPType.ADD);\n+        Object oldValue = super.get(key);\n+        if (oldValue == null) {\n+            Object newValue = mappingFunction.apply(key);\n+            if (newValue != null) {\n+                implPut(key, newValue);\n+                return super.get(key);\n+            }\n@@ -893,1 +1618,1 @@\n-        return o;\n+        return oldValue;\n@@ -899,15 +1624,9 @@\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.computeIfPresent(key, remappingFunction);\n-        if (o instanceof String so && key instanceof String sk) {\n-            parseLegacy(sk, so, OPType.ADD);\n-        }\n-        return o;\n-    }\n-\n-    private Object implPut(Object key, Object value) {\n-        if (!checkLegacy(key)) return null;\n-\n-        Object o = super.put(key, value);\n-        if (key instanceof String sk && value instanceof String sv) {\n-            parseLegacy(sk, sv, OPType.ADD);\n+        Object oldValue = super.get(key);\n+        if (oldValue != null) {\n+            Object newValue = remappingFunction.apply(key, oldValue);\n+            if (newValue != null) {\n+                implPut(key, newValue);\n+            } else {\n+                implRemove(key);\n+            }\n+            return super.get(key);\n@@ -915,1 +1634,1 @@\n-        return o;\n+        return null;\n@@ -919,1 +1638,4 @@\n-        if (!checkLegacy(key)) return null;\n+        Objects.requireNonNull(value);\n+        Object oldValue = super.get(key);\n+        return oldValue == null ? implPut(key, value) : oldValue;\n+    }\n@@ -921,6 +1643,2 @@\n-        Object o = super.putIfAbsent(key, value);\n-        if (o == null && key instanceof String sk &&\n-                value instanceof String sv) {\n-            parseLegacy(sk, sv, OPType.ADD);\n-        }\n-        return o;\n+    private Object implPut(Object key, Object value) {\n+        return implPut(servicesMap, key, value);\n@@ -929,9 +1647,5 @@\n-    private void implClear() {\n-        legacyMap.clear();\n-        serviceMap.clear();\n-        legacyChanged = false;\n-        servicesChanged = false;\n-        serviceSet = null;\n-        prngAlgos.clear();\n-        super.clear();\n-        putId();\n+    private Object implPut(ServicesMap servicesMap, Object key, Object value) {\n+        Objects.requireNonNull(value);\n+        Object oldValue = super.get(key);\n+        return doLegacyOp(servicesMap, key, value, oldValue, OPType.ADD) ==\n+                PropertiesMapAction.UPDATE ? super.put(key, value) : oldValue;\n@@ -941,1 +1655,1 @@\n-    private static class ServiceKey {\n+    private static final class ServiceKey {\n@@ -995,1 +1709,7 @@\n-    private void parseLegacy(String name, String value, OPType opType) {\n+    \/*\n+     * Parse a String entry change on the Properties map and, if concerns to the\n+     * ServicesMap, apply its corresponding operation through the Legacy API.\n+     * Returns whether the change on the Properties map should proceed or not.\n+     *\/\n+    private PropertiesMapAction parseLegacy(ServicesMap servicesMap,\n+            String propKey, String propValue, OPType opType) {\n@@ -997,1 +1717,1 @@\n-        if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {\n+        if (propKey.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {\n@@ -1000,1 +1720,1 @@\n-            String aliasKeyStr = name.substring(ALIAS_LENGTH);\n+            String aliasKeyStr = propKey.substring(ALIAS_LENGTH);\n@@ -1003,1 +1723,1 @@\n-                return;\n+                return PropertiesMapAction.UPDATE;\n@@ -1005,2 +1725,2 @@\n-            legacyChanged = true;\n-            Objects.requireNonNull(value, \"alias value should map to an alg\");\n+            Objects.requireNonNull(propValue,\n+                    \"alias value should map to an alg\");\n@@ -1009,2 +1729,1 @@\n-            ServiceKey stdKey = new ServiceKey(type, value, true);\n-            Service stdService = legacyMap.get(stdKey);\n+            ServiceKey svcKey = new ServiceKey(type, propValue, true);\n@@ -1013,22 +1732,3 @@\n-                case ADD:\n-                    \/\/ clean up old alias if present\n-                    Service prevAliasService = legacyMap.get(aliasKey);\n-                    if (prevAliasService != null) {\n-                        prevAliasService.removeAlias(aliasAlg);\n-                    }\n-                    if (stdService == null) {\n-                        \/\/ add standard mapping in order to add alias\n-                        stdService = new Service(this, type, value);\n-                        legacyMap.put(stdKey, stdService);\n-                    }\n-                    stdService.addAlias(aliasAlg);\n-                    legacyMap.put(aliasKey, stdService);\n-                    break;\n-                case REMOVE:\n-                    if (stdService != null) {\n-                        stdService.removeAlias(aliasAlg);\n-                    }\n-                    legacyMap.remove(aliasKey);\n-                    break;\n-                default:\n-                    throw new AssertionError();\n+                case ADD -> servicesMap.putAliasLegacy(svcKey, aliasKey,\n+                        propKey);\n+                case REMOVE -> servicesMap.removeAliasLegacy(svcKey, aliasKey);\n@@ -1037,1 +1737,1 @@\n-            String[] typeAndAlg = getTypeAndAlgorithm(name);\n+            String[] typeAndAlg = getTypeAndAlgorithm(propKey);\n@@ -1039,1 +1739,1 @@\n-                return;\n+                return PropertiesMapAction.UPDATE;\n@@ -1041,1 +1741,0 @@\n-            legacyChanged = true;\n@@ -1047,3 +1746,2 @@\n-                String stdAlg = typeAndAlg[1].intern();\n-                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n-                Service stdService = legacyMap.get(stdKey);\n+                String algo = typeAndAlg[1].intern();\n+                ServiceKey svcKey = new ServiceKey(type, algo, true);\n@@ -1051,26 +1749,3 @@\n-                    case ADD:\n-                        Objects.requireNonNull(value,\n-                                \"className can't be null\");\n-                        if (stdService == null) {\n-                            stdService = new Service(this, type, stdAlg);\n-                            legacyMap.put(stdKey, stdService);\n-                        }\n-                        stdService.className = value;\n-                        break;\n-                    case REMOVE:\n-                        \/\/ only remove if value also matches when non-null\n-                        if (stdService != null) {\n-                            if (value == null) {\n-                                legacyMap.remove(stdKey);\n-                            } else if (stdService.className.equals(value)) {\n-                                legacyMap.remove(stdKey, stdService);\n-                            }\n-                            \/\/ remove all corresponding alias mappings\n-                            for (String alias : stdService.getAliases()) {\n-                                legacyMap.remove(new ServiceKey(type, alias,\n-                                        true), stdService);\n-                            }\n-                        }\n-                        break;\n-                    default:\n-                        throw new AssertionError();\n+                    case ADD -> servicesMap.putClassNameLegacy(svcKey, propValue,\n+                            propKey);\n+                    case REMOVE -> servicesMap.removeLegacy(svcKey, propValue);\n@@ -1078,2 +1753,0 @@\n-                checkAndUpdateSecureRandom(type, stdAlg,\n-                        (opType != OPType.REMOVE));\n@@ -1084,1 +1757,1 @@\n-                String stdAlg = attrString.substring(0, i).intern();\n+                String algo = attrString.substring(0, i).intern();\n@@ -1091,2 +1764,1 @@\n-                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n-                Service stdService = legacyMap.get(stdKey);\n+                ServiceKey svcKey = new ServiceKey(type, algo, true);\n@@ -1094,17 +1766,4 @@\n-                    case ADD:\n-                        Objects.requireNonNull(value,\n-                                \"attribute value should not be null\");\n-\n-                        if (stdService == null) {\n-                            stdService = new Service(this, type, stdAlg);\n-                            legacyMap.put(stdKey, stdService);\n-                        }\n-                        stdService.addAttribute(attrName, value);\n-                        break;\n-                    case REMOVE:\n-                        if (stdService != null) {\n-                            stdService.removeAttribute(attrName, value);\n-                        }\n-                        break;\n-                default:\n-                    throw new AssertionError();\n+                    case ADD -> servicesMap.putAttributeLegacy(svcKey, attrName,\n+                            propValue, propKey);\n+                    case REMOVE -> servicesMap.removeAttributeLegacy(svcKey,\n+                            attrName, propValue);\n@@ -1114,0 +1773,1 @@\n+        return PropertiesMapAction.SKIP;\n@@ -1119,4 +1779,1 @@\n-     * implementation exists, this method returns {@code null}. If there are two\n-     * matching services, one added to this provider using\n-     * {@link #putService putService()} and one added via {@link #put put()},\n-     * the service added via {@link #putService putService()} is returned.\n+     * implementation exists, this method returns {@code null}.\n@@ -1145,8 +1802,1 @@\n-        Service s = serviceMap.get(key);\n-        if (s == null) {\n-            s = legacyMap.get(key);\n-            if (s != null && !s.isValid()) {\n-                legacyMap.remove(key, s);\n-                return null;\n-            }\n-        }\n+        Service s = servicesMap.getService(key);\n@@ -1185,19 +1835,1 @@\n-        if (serviceSet == null || legacyChanged || servicesChanged) {\n-            Set<Service> set = new LinkedHashSet<>();\n-            if (!serviceMap.isEmpty()) {\n-                set.addAll(serviceMap.values());\n-            }\n-            if (!legacyMap.isEmpty()) {\n-                legacyMap.entrySet().forEach(entry -> {\n-                    if (!entry.getValue().isValid()) {\n-                        legacyMap.remove(entry.getKey(), entry.getValue());\n-                    } else {\n-                        set.add(entry.getValue());\n-                    }\n-                });\n-            }\n-            serviceSet = Collections.unmodifiableSet(set);\n-            servicesChanged = false;\n-            legacyChanged = false;\n-        }\n-        return serviceSet;\n+        return servicesMap.getServices();\n@@ -1208,5 +1840,4 @@\n-     * name exists, and it was added using {@link #putService putService()},\n-     * it is replaced by the new service.\n-     * This method also places information about this service\n-     * in the provider's Hashtable values in the format described in the\n-     * {@extLink security_guide_jca\n+     * name exists, and it was added using {@link #putService putService()} or\n+     * {@link #put put()}, it is replaced by the new service. This method also\n+     * places information about this service in the provider's Hashtable\n+     * values in the format described in the {@extLink security_guide_jca\n@@ -1221,1 +1852,1 @@\n-    protected void putService(Service s) {\n+    protected synchronized void putService(Service s) {\n@@ -1233,13 +1864,1 @@\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        ServiceKey key = new ServiceKey(type, algorithm, true);\n-        implRemoveService(serviceMap.get(key));\n-        serviceMap.put(key, s);\n-        for (String alias : s.getAliases()) {\n-            serviceMap.put(new ServiceKey(type, alias, true), s);\n-        }\n-        servicesChanged = true;\n-        synchronized (this) {\n-            putPropertyStrings(s);\n-            checkAndUpdateSecureRandom(type, algorithm, true);\n-        }\n+        servicesMap.putService(s);\n@@ -1248,3 +1867,2 @@\n-    private void checkAndUpdateSecureRandom(String type, String algo,\n-            boolean doAdd) {\n-        if (type.equalsIgnoreCase(\"SecureRandom\")) {\n+    private void checkAndUpdateSecureRandom(ServiceKey algKey, boolean doAdd) {\n+        if (algKey.type.equalsIgnoreCase(\"SecureRandom\")) {\n@@ -1252,1 +1870,1 @@\n-                prngAlgos.add(algo);\n+                prngAlgos.add(algKey);\n@@ -1254,1 +1872,1 @@\n-                prngAlgos.remove(algo);\n+                prngAlgos.remove(algKey);\n@@ -1257,2 +1875,1 @@\n-                debug.println((doAdd? \"Add\":\"Remove\") +\n-                        \" SecureRandom algo \" + algo);\n+                debug.println((doAdd ? \"Add\" : \"Remove\") + \" \" + algKey);\n@@ -1269,1 +1886,1 @@\n-            String algo = prngAlgos.iterator().next();\n+            String algo = prngAlgos.iterator().next().originalAlgorithm;\n@@ -1280,38 +1897,2 @@\n-     * Put the string properties for this Service in this Provider's\n-     * Hashtable.\n-     *\/\n-    private void putPropertyStrings(Service s) {\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        \/\/ use super() to avoid other processing\n-        super.put(type + \".\" + algorithm, s.getClassName());\n-        for (String alias : s.getAliases()) {\n-            super.put(ALIAS_PREFIX + type + \".\" + alias, algorithm);\n-        }\n-        for (Map.Entry<UString,String> entry : s.attributes.entrySet()) {\n-            String key = type + \".\" + algorithm + \" \" + entry.getKey();\n-            super.put(key, entry.getValue());\n-        }\n-    }\n-\n-    \/**\n-     * Remove the string properties for this Service from this Provider's\n-     * Hashtable.\n-     *\/\n-    private void removePropertyStrings(Service s) {\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        \/\/ use super() to avoid other processing\n-        super.remove(type + \".\" + algorithm);\n-        for (String alias : s.getAliases()) {\n-            super.remove(ALIAS_PREFIX + type + \".\" + alias);\n-        }\n-        for (Map.Entry<UString,String> entry : s.attributes.entrySet()) {\n-            String key = type + \".\" + algorithm + \" \" + entry.getKey();\n-            super.remove(key);\n-        }\n-    }\n-\n-    \/**\n-     * Remove a service previously added using\n-     * {@link #putService putService()}. The specified service is removed from\n+     * Remove a service previously added using {@link #putService putService()}\n+     * or {@link #put put()}. The specified service is removed from\n@@ -1328,1 +1909,1 @@\n-    protected void removeService(Service s) {\n+    protected synchronized void removeService(Service s) {\n@@ -1336,22 +1917,1 @@\n-        implRemoveService(s);\n-    }\n-\n-    private void implRemoveService(Service s) {\n-        if ((s == null) || serviceMap.isEmpty()) {\n-            return;\n-        }\n-        String type = s.getType();\n-        String algorithm = s.getAlgorithm();\n-        ServiceKey key = new ServiceKey(type, algorithm, false);\n-        Service oldService = serviceMap.get(key);\n-        if (s != oldService) {\n-            return;\n-        }\n-        servicesChanged = true;\n-        serviceMap.remove(key);\n-        for (String alias : s.getAliases()) {\n-            serviceMap.remove(new ServiceKey(type, alias, false));\n-        }\n-\n-        removePropertyStrings(s);\n-        checkAndUpdateSecureRandom(type, algorithm, false);\n+        servicesMap.removeService(s);\n@@ -1506,1 +2066,1 @@\n-        private Map<UString,String> attributes;\n+        private Map<UString, String> attributes;\n@@ -1509,0 +2069,12 @@\n+        \/\/ For services added to a ServicesMap, their algorithm service key.\n+        \/\/ This value derives from the algorithm field. For services (still)\n+        \/\/ not added to a ServicesMap, value is null.\n+        private ServiceKey algKey;\n+\n+        \/\/ For services added to a ServicesMap, this is a map from alias service\n+        \/\/ keys to alias string values. Empty map if no aliases. While map\n+        \/\/ entries derive from the aliases field, keys are not repeated\n+        \/\/ (case-insensitive comparison) and not equal to the algorithm. For\n+        \/\/ services (still) not added to a ServicesMap, value is an empty map.\n+        private Map<ServiceKey, String> aliasKeys;\n+\n@@ -1537,4 +2109,6 @@\n-        \/\/ this constructor and these methods are used for parsing\n-        \/\/ the legacy string properties.\n-\n-        private Service(Provider provider, String type, String algorithm) {\n+        \/*\n+         * Constructor used from the ServicesMap Legacy API.\n+         *\/\n+        private Service(Provider provider, ServiceKey algKey) {\n+            assert algKey.algorithm.intern() == algKey.algorithm :\n+                    \"Algorithm should be interned.\";\n@@ -1542,2 +2116,3 @@\n-            this.type = type;\n-            this.algorithm = algorithm;\n+            this.algKey = algKey;\n+            algorithm = algKey.originalAlgorithm;\n+            type = algKey.type;\n@@ -1546,0 +2121,1 @@\n+            aliasKeys = Collections.emptyMap();\n@@ -1549,2 +2125,34 @@\n-        private boolean isValid() {\n-            return (type != null) && (algorithm != null) && (className != null);\n+        \/*\n+         * Copy constructor used from the ServicesMap Legacy API for the\n+         * copy-on-write strategy. This constructor is invoked after every\n+         * update to a service on the ServicesMap.\n+         *\/\n+        private Service(Service svc) {\n+            provider = svc.provider;\n+            type = svc.type;\n+            algorithm = svc.algorithm;\n+            algKey = svc.algKey;\n+            className = svc.className;\n+            engineDescription = svc.engineDescription;\n+            if ((Object)svc.aliases == Collections.emptyList()) {\n+                aliases = Collections.emptyList();\n+                aliasKeys = Collections.emptyMap();\n+            } else {\n+                aliases = new ArrayList<>(svc.aliases);\n+                aliasKeys = new HashMap<>(svc.aliasKeys);\n+            }\n+            if ((Object)svc.attributes == Collections.emptyMap()) {\n+                attributes = Collections.emptyMap();\n+            } else {\n+                attributes = new HashMap<>(svc.attributes);\n+            }\n+            registered = false;\n+\n+            \/\/ Do not copy cached fields because the updated service may have a\n+            \/\/ different class name or attributes and these values have to be\n+            \/\/ regenerated.\n+            classCache = null;\n+            constructorCache = null;\n+            hasKeyAttributes = null;\n+            supportedFormats = null;\n+            supportedClasses = null;\n@@ -1553,2 +2161,11 @@\n-        private void addAlias(String alias) {\n-            if (aliases.isEmpty()) {\n+        \/*\n+         * Methods used from the ServicesMap Legacy API to update a service.\n+         *\/\n+\n+        private void addAliasKey(ServiceKey aliasKey) {\n+            assert !aliasKey.equals(algKey) : \"Alias key cannot be equal to \" +\n+                    \"the algorithm.\";\n+            assert aliasKey.type.equals(type) : \"Invalid alias key type.\";\n+            assert aliasKey.algorithm.intern() == aliasKey.algorithm :\n+                    \"Alias should be interned.\";\n+            if ((Object)aliases == Collections.emptyList()) {\n@@ -1556,0 +2173,5 @@\n+                aliasKeys = new HashMap<>(2);\n+            } else if (aliasKeys.containsKey(aliasKey)) {\n+                \/\/ When overwriting aliases, remove first to handle differences\n+                \/\/ in alias string casing.\n+                removeAliasKey(aliasKey);\n@@ -1557,1 +2179,2 @@\n-            aliases.add(alias);\n+            aliases.add(aliasKey.originalAlgorithm);\n+            aliasKeys.put(aliasKey, aliasKey.originalAlgorithm);\n@@ -1560,5 +2183,5 @@\n-        private void removeAlias(String alias) {\n-            if (aliases.isEmpty()) {\n-                return;\n-            }\n-            aliases.remove(alias);\n+        private void removeAliasKey(ServiceKey aliasKey) {\n+            assert aliasKeys.containsKey(aliasKey) &&\n+                    aliases.contains(aliasKeys.get(aliasKey)) :\n+                    \"Removing nonexistent alias.\";\n+            aliases.remove(aliasKeys.remove(aliasKey));\n@@ -1567,2 +2190,2 @@\n-        void addAttribute(String type, String value) {\n-            if (attributes.isEmpty()) {\n+        private void addAttribute(String attrName, String attrValue) {\n+            if ((Object)attributes == Collections.emptyMap()) {\n@@ -1571,1 +2194,1 @@\n-            attributes.put(new UString(type), value);\n+            attributes.put(new UString(attrName), attrValue);\n@@ -1574,9 +2197,5 @@\n-        void removeAttribute(String type, String value) {\n-            if (attributes.isEmpty()) {\n-                return;\n-            }\n-            if (value == null) {\n-                attributes.remove(new UString(type));\n-            } else {\n-                attributes.remove(new UString(type), value);\n-            }\n+        private void removeAttribute(String attrName, String attrValue) {\n+            UString attrKey = new UString(attrName);\n+            assert attributes.get(attrKey) == attrValue :\n+                    \"Attribute value expected to exist with the same identity.\";\n+            attributes.remove(attrKey, attrValue);\n@@ -1602,1 +2221,1 @@\n-                Map<String,String> attributes) {\n+                Map<String, String> attributes) {\n@@ -1611,0 +2230,1 @@\n+            algKey = null;\n@@ -1617,0 +2237,1 @@\n+            aliasKeys = Collections.emptyMap();\n@@ -1621,2 +2242,3 @@\n-                for (Map.Entry<String,String> entry : attributes.entrySet()) {\n-                    this.attributes.put(new UString(entry.getKey()), entry.getValue());\n+                for (Map.Entry<String, String> entry : attributes.entrySet()) {\n+                    this.attributes.put(new UString(entry.getKey()),\n+                            entry.getValue());\n@@ -1627,0 +2249,23 @@\n+        \/*\n+         * When a Service is added to a ServicesMap with the Current API,\n+         * service and alias keys must be generated. Currently used by\n+         * ServicesMap::putService. Legacy API methods do not need to call:\n+         * they generated the algorithm key at construction time and alias\n+         * keys with Service::addAliasKey.\n+         *\/\n+        private void generateServiceKeys() {\n+            if (algKey == null) {\n+                assert (Object)aliasKeys == Collections.emptyMap() :\n+                        \"aliasKeys expected to be the empty map.\";\n+                algKey = new ServiceKey(type, algorithm, true);\n+                aliasKeys = new HashMap<>(aliases.size());\n+                for (String alias : aliases) {\n+                    ServiceKey aliasKey = new ServiceKey(type, alias, true);\n+                    if (!aliasKey.equals(algKey)) {\n+                        aliasKeys.put(aliasKey, alias);\n+                    }\n+                }\n+                aliasKeys = Collections.unmodifiableMap(aliasKeys);\n+            }\n+        }\n+\n@@ -1664,5 +2309,0 @@\n-        \/\/ internal only\n-        private List<String> getAliases() {\n-            return aliases;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":1030,"deletions":390,"binary":false,"changes":1420,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8344361\n- * @summary Restore null return for invalid services\n- *\/\n-\n-import java.security.Provider;\n-\n-public class InvalidServiceTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        Provider p1 = new LProvider(\"LegacyFormat\");\n-        \/\/ this returns a service with null class name. Helps exercise the code path\n-        Provider.Service s1 = p1.getService(\"MessageDigest\", \"SHA-1\");\n-        if (s1 != null)\n-            throw new RuntimeException(\"expecting null service\");\n-    }\n-\n-    private static class LProvider extends Provider {\n-        LProvider(String name) {\n-            super(name, \"1.0\", null);\n-            put(\"Signature.MD5withRSA\", \"com.foo.Sig\");\n-            put(\"MessageDigest.SHA-1 ImplementedIn\", \"Software\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/security\/Provider\/InvalidServiceTest.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -0,0 +1,1109 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.lang.reflect.Method;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8344361 8345139\n+ * @run main\/othervm\/timeout=60 -enablesystemassertions ServicesConsistency\n+ *\/\n+\n+public final class ServicesConsistency {\n+\n+    private static final String separatorThin = \"----------------------------\";\n+\n+    private static final String separatorThick = \"============================\";\n+\n+    private static final String aliasPrefix = \"Alg.Alias.\";\n+    private static final String sT = \"M\";\n+    private static final String algL = \"alg\";\n+    private static final String alg2L = algL + \"2\";\n+    private static final String alg2U = alg2L.toUpperCase();\n+    private static final String algPropKeyL = sT + \".\" + algL;\n+    private static final String alg2PropKeyL = sT + \".\" + alg2L;\n+    private static final String algU = algL.toUpperCase();\n+    private static final String algPropKeyU = sT + \".\" + algU;\n+    private static final String aliasL = \"alias\";\n+    private static final String aliasPropKeyL = aliasPrefix + sT + \".\" + aliasL;\n+    private static final String aliasU = aliasL.toUpperCase();\n+    private static final String aliasPropKeyU = aliasPrefix + sT + \".\" + aliasU;\n+    private static final String attrL = \"attr1\";\n+    private static final String attrU = attrL.toUpperCase();\n+    private static final String attrLAlgPropKeyL = algPropKeyL + \" \" + attrL;\n+    private static final String attrLAlgPropKeyU = algPropKeyU + \" \" + attrL;\n+    private static final String attrUAlgPropKeyL = algPropKeyL + \" \" + attrU;\n+    private static final String attrUAlgPropKeyU = algPropKeyU + \" \" + attrU;\n+    private static final String class1 = \"class1\";\n+    private static final String class2 = \"class2\";\n+    private static final String currentClass = \"currentClass\";\n+    private static final String currentClass2 = currentClass + \"2\";\n+    private static final String legacyClass = \"legacyClass\";\n+    private static final String attrValue = \"attrValue\";\n+    private static final String attrValue2 = attrValue + \"2\";\n+    private static Provider.Service s, s2;\n+\n+    private static int testsFailed = 0;\n+    private static int testsTotal = 0;\n+\n+    private static final TestProvider p;\n+\n+    static {\n+        TestProvider tmp = new TestProvider();\n+        for (Provider p : Security.getProviders()) {\n+            Security.removeProvider(p.getName());\n+        }\n+        Security.addProvider(tmp);\n+        p = tmp;\n+    }\n+\n+    private static final class TestProvider extends Provider {\n+        @Serial\n+        private static final long serialVersionUID = -6399263285569001970L;\n+\n+        static TestProvider serializationCopy() throws Throwable {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            oos.writeObject(p);\n+            ObjectInputStream ois = new ObjectInputStream(\n+                    new ByteArrayInputStream(baos.toByteArray()));\n+            return (TestProvider) ois.readObject();\n+        }\n+\n+        TestProvider() {\n+            super(\"TestProvider\", \"1.0\", \"TestProvider info\");\n+        }\n+\n+        void putService(String type, String algorithm, String className,\n+                List<String> aliases, Map<String, String> attributes) {\n+            System.out.println(\"Provider.putService(new Service(TestProvider,\" +\n+                    \" \" + type + \", \" + algorithm + \", \" + className + \", \" +\n+                    aliases + \", \" + attributes + \"))\");\n+            super.putService(new Service(this, type, algorithm, className,\n+                    aliases, attributes));\n+        }\n+\n+        @Override\n+        public void removeService(Provider.Service s) {\n+            System.out.println(\"Provider.removeService(\" + s + \")\");\n+            super.removeService(s);\n+        }\n+\n+        @Override\n+        public Object put(Object k, Object v) {\n+            return put(k, v, true);\n+        }\n+\n+        Object put(Object k, Object v, boolean print) {\n+            if (print) {\n+                System.out.println(\"Provider.put(\" + k + \", \" + v + \")\");\n+            }\n+            return super.put(k, v);\n+        }\n+\n+        void showProperties() {\n+            System.out.println();\n+            System.out.println(\"Properties map:\");\n+            System.out.println(separatorThin);\n+            for (Map.Entry<Object, Object> e : entrySet()) {\n+                Object k = e.getKey();\n+                Object v = e.getValue();\n+                if (k instanceof String ks) {\n+                    if (ks.startsWith(\"Provider.\")) {\n+                        continue;\n+                    }\n+                }\n+                System.out.println(k + \": \" + v);\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+    public static class TestSpi {\n+    }\n+\n+    public static class TestSpi2 {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        for (Method m : ServicesConsistency.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\")) {\n+                try {\n+                    printTestHeader(m.getName());\n+                    testsTotal += 1;\n+                    m.invoke(null);\n+                } catch (Throwable t) {\n+                    testsFailed += 1;\n+                    t.printStackTrace();\n+                } finally {\n+                    p.clear();\n+                }\n+            }\n+        }\n+\n+        if (testsFailed > 0) {\n+            throw new Exception(\"TESTS FAILED: \" + testsFailed + \"\/\" +\n+                    testsTotal);\n+        } else {\n+            System.out.println(\"TESTS PASSED: \" + testsTotal + \"\/\" +\n+                    testsTotal);\n+        }\n+    }\n+\n+    private static void printTestHeader(String testName) {\n+        System.out.println(separatorThin);\n+        System.out.println(testName);\n+        System.out.println(separatorThin);\n+        System.out.println();\n+    }\n+\n+    private static void printThickHeader(String title) {\n+        System.out.println(title);\n+        System.out.println(separatorThick);\n+        System.out.println();\n+    }\n+\n+    private static void assertThat(boolean condition, String errorMsg)\n+            throws Exception {\n+        if (!condition) {\n+            throw new Exception(errorMsg);\n+        }\n+    }\n+\n+    private static void propValueAssertion(String propKey, String expectedValue,\n+            String valueDesc, TestProvider p) throws Exception {\n+        Object value = p.get(propKey);\n+        assertThat(expectedValue.equals(value), \"A wrong \" + valueDesc +\n+                \" is assigned to the '\" + propKey + \"' provider property: \" +\n+                \"expecting '\" + expectedValue + \"' but was '\" + value + \"'.\");\n+    }\n+\n+    private static void assertClassnamePropValue(String propKey,\n+            String expectedValue) throws Exception {\n+        assertClassnamePropValue(propKey, expectedValue, p);\n+    }\n+\n+    private static void assertClassnamePropValue(String propKey,\n+            String expectedValue, TestProvider p) throws Exception {\n+        propValueAssertion(propKey, expectedValue, \"class name\", p);\n+    }\n+\n+    private static void assertAliasPropValue(String propKey,\n+            String expectedValue) throws Exception {\n+        propValueAssertion(propKey, expectedValue, \"algorithm\", p);\n+    }\n+\n+    private static void assertAttributePropValue(String propKey,\n+            String expectedValue) throws Exception {\n+        propValueAssertion(propKey, expectedValue, \"attribute value\", p);\n+    }\n+\n+    private static void assertPropRemoved(String propKey) throws Exception {\n+        assertThat(p.get(propKey) == null, \"Property '\" + propKey + \"' \" +\n+                \"expected to be removed but was not. Current value is '\" +\n+                p.get(propKey) + \"'.\");\n+    }\n+\n+    private static String getServiceDesc(Provider.Service svc) {\n+        return svc == null ? \"null service\" : \"service with type '\" +\n+                svc.getType() + \"' and algorithm '\" + svc.getAlgorithm() + \"'\";\n+    }\n+\n+    private static void serviceAssertionCommon(Provider.Service svc,\n+            boolean isEqual, Provider.Service svc2, String errorMsg)\n+            throws Exception {\n+        String svc2Desc = getServiceDesc(svc2);\n+        if (isEqual) {\n+            assertThat(svc == svc2, errorMsg + \" is not equal to a \" +\n+                    svc2Desc + \", and was expected to be equal.\");\n+        } else {\n+            assertThat(svc != svc2, errorMsg + \" is equal to a \" + svc2Desc +\n+                    \", and was not expected to be equal.\");\n+        }\n+    }\n+\n+    private static void lookupServiceAssertion(String type, String algorithm,\n+            boolean isEqual, Provider.Service svc2) throws Exception {\n+        serviceAssertionCommon(p.getService(type, algorithm), isEqual, svc2,\n+                \"A service looked up by type '\" + type + \"' and algorithm '\" +\n+                        algorithm + \"'\");\n+    }\n+\n+    private static void assertServiceEqual(String type, String algorithm,\n+            Provider.Service svc2) throws Exception {\n+        lookupServiceAssertion(type, algorithm, true, svc2);\n+    }\n+\n+    private static void assertServiceNotEqual(String type, String algorithm,\n+            Provider.Service svc2) throws Exception {\n+        lookupServiceAssertion(type, algorithm, false, svc2);\n+    }\n+\n+    private static void serviceAssertion(Provider.Service svc, boolean isEqual,\n+            Provider.Service svc2) throws Exception {\n+        serviceAssertionCommon(svc, isEqual, svc2, \"A \" + getServiceDesc(svc));\n+    }\n+\n+    private static void assertServiceEqual(Provider.Service svc,\n+            Provider.Service svc2) throws Exception {\n+        serviceAssertion(svc, true, svc2);\n+    }\n+\n+    private static void assertServiceNotEqual(Provider.Service svc,\n+            Provider.Service svc2) throws Exception {\n+        serviceAssertion(svc, false, svc2);\n+    }\n+\n+    private static void assertClassname(Provider.Service svc,\n+            String expectedClassName) throws Exception {\n+        assertServiceNotEqual(svc, null);\n+        String svcClassName = svc.getClassName();\n+        assertThat(expectedClassName.equals(svcClassName), \"A \" +\n+                getServiceDesc(svc) + \" was expected to have a class name \" +\n+                \"equal to '\" + expectedClassName + \"' but is equal to '\" +\n+                svcClassName + \"'.\");\n+    }\n+\n+    private static void assertAttribute(Provider.Service svc, String attrName,\n+            String expectedAttrValue) throws Exception {\n+        assertServiceNotEqual(svc, null);\n+        String attrValue = svc.getAttribute(attrName);\n+        assertThat(Objects.equals(expectedAttrValue, attrValue), \"A \" +\n+                getServiceDesc(svc) + \" was expected to have a '\" + attrName +\n+                        \"' attribute equal to '\" + expectedAttrValue + \"' but\" +\n+                        \" is equal to '\" + attrValue + \"'.\");\n+    }\n+\n+    private static void assertNotAttribute(Provider.Service svc,\n+            String attrName) throws Exception {\n+        assertAttribute(svc, attrName, null);\n+    }\n+\n+    private static void testBasicLegacyAPIOps() throws Throwable {\n+        String attrLAliasPropKeyL = sT + \".\" + aliasL + \" \" + attrU;\n+\n+        printThickHeader(\"Put an algorithm with two different cases:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(algPropKeyU, class2);\n+        p.showProperties();\n+        assertPropRemoved(algPropKeyL);\n+        assertClassnamePropValue(algPropKeyU, class2);\n+        assertClassname(p.getService(sT, algL), class2);\n+        assertClassname(p.getService(sT, algU), class2);\n+        p.clear();\n+\n+        printThickHeader(\"Assign an alias with two different cases:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(aliasPropKeyU, algL);\n+        s = p.getService(sT, algL);\n+        p.showProperties();\n+        assertPropRemoved(aliasPropKeyL);\n+        assertAliasPropValue(aliasPropKeyU, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertServiceEqual(sT, aliasU, s);\n+        assertClassname(s, class1);\n+        p.clear();\n+\n+        printThickHeader(\"Put an attribute with different algorithm cases:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(attrLAlgPropKeyU, attrValue2);\n+        p.showProperties();\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertAttributePropValue(attrLAlgPropKeyU, attrValue2);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue2);\n+        assertAttribute(p.getService(sT, algU), attrU, attrValue2);\n+        p.clear();\n+\n+        printThickHeader(\"Put an attribute with different attr name case:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(attrUAlgPropKeyL, attrValue2);\n+        p.showProperties();\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertAttributePropValue(attrUAlgPropKeyL, attrValue2);\n+        assertAttribute(p.getService(sT, algU), attrL, attrValue2);\n+        assertAttribute(p.getService(sT, algL), attrU, attrValue2);\n+        p.clear();\n+\n+        printThickHeader(\"Replace attribute by alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(attrLAliasPropKeyL, attrValue2);\n+        p.showProperties();\n+        assertPropRemoved(attrLAliasPropKeyL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue2);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue2);\n+        p.clear();\n+\n+        printThickHeader(\"Remove service:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.showProperties();\n+        p.remove(algPropKeyU);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassname(p.getService(sT, algL), class1);\n+        assertClassname(p.getService(sT, aliasL), class1);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+        p.remove(algPropKeyL);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.clear();\n+\n+        printThickHeader(\"Remove service alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.remove(aliasPropKeyU);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertServiceNotEqual(sT, aliasL, null);\n+        p.remove(aliasPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertServiceEqual(sT, aliasL, null);\n+        assertClassname(p.getService(sT, algL), class1);\n+        p.clear();\n+\n+        printThickHeader(\"Remove service attribute:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.remove(attrUAlgPropKeyL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+        p.remove(attrLAlgPropKeyU);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+        p.remove(attrLAlgPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertNotAttribute(p.getService(sT, algL), attrL);\n+    }\n+\n+    private static void testSerializationConsistencyBetweenAPIs()\n+            throws Throwable {\n+        printThickHeader(\"Before serialization:\");\n+        p.putService(sT, algL, currentClass, null, null);\n+        p.put(algPropKeyL, legacyClass);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertClassname(p.getService(sT, algL), currentClass);\n+\n+        TestProvider serialP = TestProvider.serializationCopy();\n+\n+        printThickHeader(\"After serialization:\");\n+        serialP.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass, serialP);\n+        assertClassname(serialP.getService(sT, algL), currentClass);\n+    }\n+\n+    private static void testComputeDoesNotThrowNPE() throws Throwable {\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.compute(aliasPropKeyL, (key, oldV) -> null);\n+        assertPropRemoved(aliasPropKeyL);\n+    }\n+\n+    private static void testMergeDoesNotThrowNPE() throws Throwable {\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.merge(aliasPropKeyL, algL, (oldV, newV) -> null);\n+        assertPropRemoved(aliasPropKeyL);\n+    }\n+\n+    private static void testLegacyAPIServicesOverride() throws Throwable {\n+        legacyAPIServicesOverride(false);\n+    }\n+\n+    private static void testLegacyAPIServicesOverrideDifferentCase()\n+            throws Throwable {\n+        legacyAPIServicesOverride(true);\n+    }\n+\n+    private static void legacyAPIServicesOverride(boolean differentCase)\n+            throws Throwable {\n+        String aliasAsAlgPropKey = sT + \".\" + (differentCase ? aliasU : aliasL);\n+        String algAsAliasPropKey = aliasPrefix + sT + \".\" +\n+                (differentCase ? algU : algL);\n+\n+        printThickHeader(\"A Legacy API service algorithm can override a \" +\n+                \"Legacy API service algorithm:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(s, class1);\n+        assertAttribute(s, attrL, attrValue);\n+        p.put(differentCase ? algPropKeyU : algPropKeyL, class2);\n+        p.showProperties();\n+        s2 = p.getService(sT, algL);\n+        assertClassnamePropValue(differentCase ? algPropKeyU : algPropKeyL,\n+                class2);\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyL);\n+        }\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertAliasPropValue(attrLAlgPropKeyL, attrValue);\n+        assertServiceEqual(sT, algU, s2);\n+        assertClassname(s2, class2);\n+        assertClassname(p.getService(sT, aliasL), class2);\n+        assertAttribute(s2, attrL, attrValue);\n+        p.clear();\n+\n+        printThickHeader(\"A Legacy API service algorithm is a Legacy API \" +\n+                \"service alias already. Modify the existing service through \" +\n+                \"its alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(aliasAsAlgPropKey, class2);\n+        p.showProperties();\n+        s = p.getService(sT, algL);\n+        assertClassnamePropValue(algPropKeyL, class2);\n+        assertPropRemoved(aliasAsAlgPropKey);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertClassname(p.getService(sT, aliasL), class2);\n+        assertClassname(p.getService(sT, aliasU), class2);\n+        assertClassname(s, class2);\n+        assertAttribute(s, attrL, attrValue);\n+        p.clear();\n+\n+        printThickHeader(\"A Legacy API service alias can override a Legacy \" +\n+                \"API service alias:\");\n+        p.put(algPropKeyL, class1);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(alg2PropKeyL, class2);\n+        p.put(differentCase ? aliasPropKeyU : aliasPropKeyL, alg2L);\n+        p.showProperties();\n+        s2 = p.getService(sT, alg2L);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyL);\n+        }\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertServiceEqual(sT, aliasU, s2);\n+        assertClassname(p.getService(sT, algL), class1);\n+        assertClassname(s2, class2);\n+        p.clear();\n+\n+        printThickHeader(\"A Legacy API service algorithm cannot be \" +\n+                \"overwritten by a Legacy API service alias:\");\n+        p.put(algPropKeyL, class1);\n+        s = p.getService(sT, algL);\n+        p.put(alg2PropKeyL, class2);\n+        p.put(algAsAliasPropKey, alg2L);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertPropRemoved(algAsAliasPropKey);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertClassnamePropValue(alg2PropKeyL, class2);\n+        assertServiceEqual(sT, algL, s);\n+        assertServiceEqual(sT, algU, s);\n+        assertClassname(s, class1);\n+        assertClassname(s2, class2);\n+        p.clear();\n+\n+        \/\/ Add a Current API service to test invalid overrides\n+        p.putService(sT, algL, currentClass, List.of(aliasL),\n+                Map.of(attrL, attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceNotEqual(s, null);\n+        assertServiceEqual(sT, aliasL, s);\n+        System.out.println();\n+\n+        printThickHeader(\"A Legacy API service algorithm cannot overwrite a \" +\n+                \"Current API service algorithm:\");\n+        p.put(differentCase ? algPropKeyU : algPropKeyL, legacyClass);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyU);\n+        }\n+        assertClassname(p.getService(sT, algL), currentClass);\n+        assertClassname(p.getService(sT, algU), currentClass);\n+\n+        printThickHeader(\"A Legacy API service alias cannot overwrite a \" +\n+                \"Current API service alias:\");\n+        p.put(differentCase ? aliasPropKeyU : aliasPropKeyL, alg2L);\n+        p.showProperties();\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyU);\n+        }\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(p.getService(sT, aliasL), currentClass);\n+        assertClassname(p.getService(sT, aliasU), currentClass);\n+\n+        printThickHeader(\"A Legacy API service cannot overwrite a Current API\" +\n+                \" service attribute:\");\n+        p.put(differentCase ? attrUAlgPropKeyU : attrLAlgPropKeyL, attrValue2);\n+        p.showProperties();\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        if (differentCase) {\n+            assertPropRemoved(attrUAlgPropKeyU);\n+        }\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+\n+        printThickHeader(\"A Legacy API service alias cannot overwrite a \" +\n+                \"Current API service algorithm:\");\n+        p.put(algAsAliasPropKey, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertPropRemoved(algAsAliasPropKey);\n+        assertClassname(p.getService(sT, algL), currentClass);\n+        assertClassname(p.getService(sT, algU), currentClass);\n+\n+        printThickHeader(\"A Legacy API service algorithm cannot overwrite a \" +\n+                \"Current API service alias:\");\n+        p.put(aliasAsAlgPropKey, legacyClass);\n+        p.showProperties();\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertPropRemoved(aliasAsAlgPropKey);\n+        assertClassname(p.getService(sT, aliasL), currentClass);\n+        assertClassname(p.getService(sT, aliasU), currentClass);\n+\n+        assertServiceEqual(p.getService(sT, algL), s);\n+        assertServiceEqual(p.getService(sT, aliasL), s);\n+    }\n+\n+    private static void testLegacyAPIAliasCannotBeAlgorithm() throws Throwable {\n+        p.put(aliasPropKeyL, aliasL);\n+        p.showProperties();\n+        assertPropRemoved(aliasPropKeyL);\n+        p.clear();\n+\n+        p.put(sT + \".\" + aliasU, class1);\n+        p.put(aliasPropKeyL, aliasU);\n+        p.showProperties();\n+        assertClassnamePropValue(sT + \".\" + aliasU, class1);\n+        assertPropRemoved(aliasPropKeyL);\n+    }\n+\n+    private static void testCurrentAPIServicesOverride() throws Throwable {\n+        currentAPIServicesOverride(false);\n+    }\n+\n+    private static void testCurrentAPIServicesOverrideDifferentCase()\n+            throws Throwable {\n+        currentAPIServicesOverride(true);\n+    }\n+\n+    private static void currentAPIServicesOverride(boolean differentCase)\n+            throws Throwable {\n+        printThickHeader(\"A Current API service overrides a Legacy API \" +\n+                \"service algorithm with its algorithm:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        p.put(aliasPropKeyL, algL);\n+        s = p.getService(sT, algL);\n+        p.putService(sT, differentCase ? algU : algL, currentClass, List.of(),\n+                null);\n+        s2 = p.getService(sT, differentCase ? algU : algL);\n+        p.showProperties();\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyL);\n+        }\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertClassnamePropValue(differentCase ? algPropKeyU : algPropKeyL,\n+                currentClass);\n+        assertClassname(s, legacyClass);\n+        assertClassname(s2, currentClass);\n+        assertServiceEqual(sT, aliasL, null);\n+        assertNotAttribute(s2, attrL);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Legacy API \" +\n+                \"service alias with its algorithm:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(aliasPropKeyL, algL);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        p.putService(sT, differentCase ? aliasU : aliasL, currentClass,\n+                List.of(), null);\n+        s2 = p.getService(sT, differentCase ? aliasU : aliasL);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, legacyClass);\n+        assertClassnamePropValue(sT + \".\" + (differentCase ? aliasU : aliasL),\n+                currentClass);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertClassname(p.getService(sT, algL), legacyClass);\n+        assertClassname(s2, currentClass);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Legacy API \" +\n+                \"service algorithm with its alias:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        p.putService(sT, alg2L, currentClass,\n+                List.of(differentCase ? algU : algL), null);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(alg2PropKeyL, currentClass);\n+        assertAliasPropValue(aliasPrefix + sT + \".\" + (differentCase ? algU :\n+                algL), alg2L);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertServiceEqual(sT, aliasL, null);\n+        assertServiceNotEqual(s, s2);\n+        assertServiceEqual(sT, algL, s2);\n+        assertClassname(s2, currentClass);\n+        assertNotAttribute(s2, attrL);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Legacy API alias\" +\n+                \" with its alias:\");\n+        p.put(algPropKeyL, legacyClass);\n+        p.put(aliasPropKeyL, algL);\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        p.putService(sT, alg2L, currentClass, List.of(differentCase ?\n+                aliasU : aliasL), null);\n+        s2 = p.getService(sT, alg2L);\n+        s = p.getService(sT, algL);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, legacyClass);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(alg2PropKeyL, currentClass);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyL);\n+        }\n+        assertClassname(s, legacyClass);\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertClassname(s2, currentClass);\n+        assertNotAttribute(s2, attrL);\n+        assertAttribute(s, attrL, attrValue);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service algorithm with its algorithm:\");\n+        p.putService(sT, algL, currentClass, List.of(aliasL), Map.of(attrL,\n+                attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(s, currentClass);\n+        assertAttribute(s, attrL, attrValue);\n+        p.putService(sT, differentCase ? algU : algL, currentClass2, List.of(),\n+                null);\n+        s2 = p.getService(sT, differentCase ? algU : algL);\n+        p.showProperties();\n+        assertClassnamePropValue(differentCase ? algPropKeyU : algPropKeyL,\n+                currentClass2);\n+        if (differentCase) {\n+            assertPropRemoved(algPropKeyL);\n+        }\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertClassname(s2, currentClass2);\n+        assertNotAttribute(s2, attrL);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service alias with its algorithm:\");\n+        p.putService(sT, algL, currentClass, List.of(alg2L), Map.of(attrL,\n+                attrValue));\n+        assertServiceEqual(sT, alg2L, p.getService(sT, algL));\n+        p.putService(sT, differentCase ? alg2U : alg2L, currentClass2,\n+                List.of(), null);\n+        s = p.getService(sT, algL);\n+        s2 = p.getService(sT, differentCase ? alg2U : alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(sT + \".\" + (differentCase ? alg2U : alg2L),\n+                currentClass2);\n+        assertPropRemoved(aliasPrefix + alg2PropKeyL);\n+        assertClassname(s, currentClass);\n+        assertClassname(s2, currentClass2);\n+        assertAttribute(s, attrL, attrValue);\n+        assertNotAttribute(s2, attrL);\n+        p.removeService(s);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertClassnamePropValue(sT + \".\" + (differentCase ? alg2U : alg2L),\n+                currentClass2);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(s2, p.getService(sT, differentCase ? alg2U : alg2L));\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service algorithm with its alias:\");\n+        p.putService(sT, algL, currentClass, List.of(aliasL), Map.of(attrL,\n+                attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertAttribute(s, attrL, attrValue);\n+        p.putService(sT, alg2L, currentClass2, List.of(differentCase ?\n+                algU : algL), null);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(alg2PropKeyL, currentClass2);\n+        assertAliasPropValue(aliasPrefix + sT + \".\" + (differentCase ?\n+                algU : algL), alg2L);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(aliasPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertServiceEqual(sT, algL, s2);\n+        assertServiceEqual(sT, algU, s2);\n+        assertClassname(s2, currentClass2);\n+        assertNotAttribute(s2, attrL);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.clear();\n+\n+        printThickHeader(\"A Current API service overrides a Current API \" +\n+                \"service alias with its alias:\");\n+        p.putService(sT, algL, currentClass, List.of(aliasL), Map.of(attrL,\n+                attrValue));\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertAttribute(s, attrL, attrValue);\n+        p.putService(sT, alg2L, currentClass2, List.of(differentCase ?\n+                aliasU : aliasL), null);\n+        s2 = p.getService(sT, alg2L);\n+        p.showProperties();\n+        assertClassnamePropValue(algPropKeyL, currentClass);\n+        assertClassnamePropValue(alg2PropKeyL, currentClass2);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        if (differentCase) {\n+            assertPropRemoved(aliasPropKeyL);\n+        }\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertServiceEqual(sT, algL, s);\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertServiceEqual(sT, aliasU, s2);\n+        p.removeService(s);\n+        assertPropRemoved(algPropKeyL);\n+        assertPropRemoved(attrLAlgPropKeyL);\n+        assertAliasPropValue(differentCase ? aliasPropKeyU : aliasPropKeyL,\n+                alg2L);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, s2);\n+        assertServiceEqual(sT, aliasU, s2);\n+    }\n+\n+    private static void testInvalidServiceNotReturned() throws Throwable {\n+        p.put(aliasPropKeyL, algL);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, null);\n+    }\n+\n+    private static void testInvalidCachedHasKeyAttributes() throws Throwable {\n+        invalidCachedSupportedKeyFormats(true);\n+    }\n+\n+    private static void testInvalidCachedSupportedKeyFormats()\n+            throws Throwable {\n+        invalidCachedSupportedKeyFormats(false);\n+    }\n+\n+    private static void invalidCachedSupportedKeyFormats(\n+            boolean targetingHasAttributes) throws Throwable {\n+        String sT = \"Cipher\";\n+        String algPropKeyL = sT + \".\" + algL;\n+        String attrPropKey = algPropKeyL + \" SupportedKeyFormats\";\n+        String format1 = \"format1\";\n+        String format2 = \"format2\";\n+        boolean supportsKeyFormat, supportsKeyFormat2;\n+        Key key = new Key() {\n+            @Serial\n+            private static final long serialVersionUID = 5040566397999588441L;\n+            @Override\n+            public String getAlgorithm() {\n+                return null;\n+            }\n+            @Override\n+            public String getFormat() {\n+                return format2;\n+            }\n+            @Override\n+            public byte[] getEncoded() {\n+                return new byte[0];\n+            }\n+        };\n+\n+        p.put(algPropKeyL, TestSpi.class.getName());\n+        if (!targetingHasAttributes) {\n+            p.put(attrPropKey, format2);\n+        }\n+        supportsKeyFormat = p.getService(sT, algL).supportsParameter(key);\n+        p.put(attrPropKey, format1);\n+        supportsKeyFormat2 = p.getService(sT, algL).supportsParameter(key);\n+        p.showProperties();\n+\n+        assertClassnamePropValue(algPropKeyL, TestSpi.class.getName());\n+        assertAttributePropValue(attrPropKey, format1);\n+        assertThat(supportsKeyFormat && !supportsKeyFormat2,\n+                \"supportsKeyFormat expected to be 'true' (was '\" +\n+                supportsKeyFormat + \"'), and supportsKeyFormat2 expected to \" +\n+                \"be 'false' (was '\" + supportsKeyFormat2 + \"').\");\n+    }\n+\n+    private static void testInvalidCachedClass() throws Throwable {\n+        Object testSpi, testSpi2;\n+        p.put(algPropKeyL, TestSpi.class.getName());\n+        s = p.getService(sT, algL);\n+        testSpi = s.newInstance(null);\n+        assertClassname(s, TestSpi.class.getName());\n+        p.put(algPropKeyL, TestSpi2.class.getName());\n+        s2 = p.getService(sT, algL);\n+        testSpi2 = s2.newInstance(null);\n+        assertClassname(s2, TestSpi2.class.getName());\n+        p.showProperties();\n+\n+        assertClassnamePropValue(algPropKeyL, TestSpi2.class.getName());\n+        assertThat(testSpi.getClass() == TestSpi.class && testSpi2.getClass()\n+                == TestSpi2.class, \"testSpi expected to be an instance of '\" +\n+                TestSpi.class.getSimpleName() + \"' (was an instance of '\" +\n+                testSpi.getClass().getSimpleName() + \"'), and testSpi2 \" +\n+                \"expected to be an instance of '\" +\n+                TestSpi2.class.getSimpleName() + \"' (was an instance of '\" +\n+                testSpi2.getClass().getSimpleName() + \"').\");\n+    }\n+\n+    private static void testLegacyAPIAddIsRemove() throws Throwable {\n+        Object obj = new Object();\n+        p.put(algPropKeyL, class1);\n+        p.put(algPropKeyU, obj);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertServiceNotEqual(sT, algL, null);\n+        p.showProperties();\n+        p.put(algPropKeyL, obj);\n+        p.showProperties();\n+        assertThat(p.get(algPropKeyL) == obj, \"Entry value \" +\n+                \"expected to be the Object instance added.\");\n+        assertThat(p.get(algPropKeyU) == obj, \"Entry value \" +\n+                \"expected to be the Object instance added.\");\n+        assertServiceEqual(sT, algL, null);\n+    }\n+\n+    private static void testReplaceAllIsAtomic() throws Throwable {\n+        concurrentReadWrite((Map<String, String> aliases) -> {\n+                    p.put(alg2PropKeyL, class2);\n+                    p.putAll(aliases);\n+                },\n+                (Map<String, String> aliases) ->\n+                    p.replaceAll((k, v) -> {\n+                        if (((String)k).startsWith(aliasPrefix) &&\n+                                algL.equals(v)) {\n+                            return alg2L;\n+                        }\n+                        return v;\n+                    }),\n+                (String sT, String firstAlias, String lastAlias) -> {\n+            Provider.Service s1 = p.getService(sT, firstAlias);\n+            Provider.Service s2 = p.getService(sT, lastAlias);\n+            if (s1 != null && s1.getClassName().equals(class2)) {\n+                if (s2 == null) {\n+                    throw new Exception(\"First service found, \" +\n+                            \"last service not found.\");\n+                }\n+                return true;\n+            }\n+            return false;\n+        }, \"Provider::replaceAll is not atomic.\");\n+    }\n+\n+    private static void testPutAllIsAtomic() throws Throwable {\n+        concurrentReadWrite(null, p::putAll,\n+                (String sT, String firstAlias, String lastAlias) -> {\n+            Provider.Service s1 = p.getService(sT, firstAlias);\n+            Provider.Service s2 = p.getService(sT, lastAlias);\n+            if (s1 != null) {\n+                if (s2 == null) {\n+                    throw new Exception(\"First service found, \" +\n+                            \"last service not found.\");\n+                }\n+                return true;\n+            }\n+            return false;\n+        }, \"Provider::putAll is not atomic.\");\n+    }\n+\n+    private static void testConcurrentServiceModification() throws Throwable {\n+        concurrentReadWrite(null, (Map<String, String> aliases) -> {\n+            for (Map.Entry<String, String> aliasEntry : aliases.entrySet()) {\n+                p.put(aliasEntry.getKey(), aliasEntry.getValue(), false);\n+            }\n+        }, (String sT, String firstAlias, String lastAlias) -> {\n+            Provider.Service s1 = p.getService(sT, firstAlias);\n+            if (s1 != null) {\n+                s1.toString();\n+            }\n+            return p.getService(sT, lastAlias) != null;\n+        }, \"Concurrent modification of a service compromised integrity.\");\n+    }\n+\n+    @FunctionalInterface\n+    private interface ConcurrentWriteCallback {\n+        void apply(Map<String, String> aliases);\n+    }\n+\n+    @FunctionalInterface\n+    private interface ConcurrentReadCallback {\n+        boolean apply(String sT, String firstAlias, String lastAlias)\n+                throws Throwable;\n+    }\n+\n+    private static void concurrentReadWrite(ConcurrentWriteCallback preWriteCB,\n+            ConcurrentWriteCallback writerCB, ConcurrentReadCallback readerCB,\n+            String errorMsg) throws Throwable {\n+        int lastAlias = 500;\n+        int numberOfExperiments = 10;\n+        String firstAliasL = aliasL + 0;\n+        String lastAliasL = aliasL + lastAlias;\n+        Map<String, String> aliasesMap = new LinkedHashMap<>(lastAlias + 1);\n+        for (int i = 0; i <= lastAlias; i++) {\n+            aliasesMap.put(aliasPropKeyL + i, algL);\n+        }\n+        AtomicReference<Throwable> exceptionRef = new AtomicReference<>(null);\n+        Runnable writerR = () -> writerCB.apply(aliasesMap);\n+        Runnable readerR = () -> {\n+            try {\n+                while (!readerCB.apply(sT, firstAliasL, lastAliasL));\n+            } catch (Throwable t) {\n+                exceptionRef.set(t);\n+            }\n+        };\n+        for (int i = 0; i < numberOfExperiments; i++) {\n+            p.clear();\n+            p.put(algPropKeyL, class1);\n+            Thread writerT = new Thread(writerR);\n+            Thread readerT = new Thread(readerR);\n+            if (preWriteCB != null) {\n+                preWriteCB.apply(aliasesMap);\n+            }\n+            readerT.start();\n+            writerT.start();\n+            writerT.join();\n+            readerT.join();\n+            if (exceptionRef.get() != null) {\n+                throw new Exception(errorMsg, exceptionRef.get());\n+            }\n+        }\n+    }\n+\n+    private static void testInvalidGetServiceRemoval() throws Throwable {\n+        invalidServiceRemoval(true);\n+    }\n+\n+    private static void testInvalidGetServicesRemoval() throws Throwable {\n+        invalidServiceRemoval(false);\n+    }\n+\n+    private static void invalidServiceRemoval(boolean getService)\n+            throws Throwable {\n+        p.put(aliasPropKeyL, algL);\n+        if (getService) {\n+            p.getService(sT, aliasL);\n+        } else {\n+            p.getServices();\n+        }\n+        p.put(algPropKeyL, class1);\n+        p.showProperties();\n+\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        s = p.getService(sT, aliasL);\n+        assertClassname(s, class1);\n+        assertServiceEqual(sT, algL, s);\n+    }\n+\n+    private static void testSerializationClassnameConsistency()\n+            throws Throwable {\n+        printThickHeader(\"Before serialization:\");\n+        p.put(algPropKeyU, class1);\n+        p.put(algPropKeyL, class2);\n+        s = p.getService(sT, algL);\n+        s2 = p.getService(sT, algU);\n+        p.showProperties();\n+        assertClassname(s, class2);\n+        assertClassname(s2, class2);\n+\n+        TestProvider serialP = TestProvider.serializationCopy();\n+\n+        printThickHeader(\"After serialization:\");\n+        serialP.showProperties();\n+        s = serialP.getService(sT, algL);\n+        s2 = serialP.getService(sT, algU);\n+        p.showProperties();\n+        assertClassname(s, class2);\n+        assertClassname(s2, class2);\n+    }\n+\n+    private static void testCreateServiceByAlias() throws Throwable {\n+        printThickHeader(\"Create service by alias and set classname by alias:\");\n+        p.put(aliasPropKeyL, algL);\n+        assertServiceEqual(sT, algL, null);\n+        assertServiceEqual(sT, aliasL, null);\n+        p.put(sT + \".\" + aliasL, class1);\n+        p.showProperties();\n+        assertPropRemoved(sT + \".\" + aliasL);\n+        assertAliasPropValue(aliasPropKeyL, algL);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        s = p.getService(sT, algL);\n+        assertServiceEqual(sT, aliasL, s);\n+        assertClassname(s, class1);\n+    }\n+\n+    private static void testCreateServiceByAttr() throws Throwable {\n+        printThickHeader(\"Create a service by attribute:\");\n+        p.put(attrLAlgPropKeyL, attrValue);\n+        assertServiceEqual(sT, algL, null);\n+        p.put(algPropKeyL, class1);\n+        p.showProperties();\n+        assertAttributePropValue(attrLAlgPropKeyL, attrValue);\n+        assertClassnamePropValue(algPropKeyL, class1);\n+        assertAttribute(p.getService(sT, algL), attrL, attrValue);\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Provider\/ServicesConsistency.java","additions":1109,"deletions":0,"binary":false,"changes":1109,"status":"added"}]}