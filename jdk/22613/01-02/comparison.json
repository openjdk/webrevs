{"files":[{"patch":"@@ -708,1 +708,3 @@\n-         * Enum to inform the result of an operation on the services map.\n+         * Record to aggregate information about the lookup of a service on the\n+         * internal map. See ServicesMap::find for a description of possible\n+         * values.\n@@ -710,3 +712,44 @@\n-        enum SvcOpResult {\n-            SUCCESS,\n-            ERROR\n+        private record MappingInfo(Service svc, ServiceKey algKey,\n+                Boolean isLegacy) {}\n+\n+        \/\/ Placeholder for a thread to mark that serviceSet values are being\n+        \/\/ computed after a services update. Only one thread at a time can\n+        \/\/ effectively assign this value.\n+        private static final Set<Service> SERVICE_SET_IN_PROGRESS = Set.of();\n+\n+        \/\/ Unmodifiable set of all services. Possible values for this field\n+        \/\/ are: 1) null (indicates that the set has to be recomputed after a\n+        \/\/ service update), 2) SERVICE_SET_IN_PROGRESS (indicates that a thread\n+        \/\/ is recomputing its value), and 3) an actual set of services.\n+        private final AtomicReference<Set<Service>> serviceSet;\n+\n+        \/\/ The internal services map, containing services registered with the\n+        \/\/ Current and the Legacy APIs. Concurrent read and write access to this\n+        \/\/ map is expected. Both algorithm and alias service keys are added to\n+        \/\/ this map.\n+        private final Map<ServiceKey, Service> services;\n+\n+        \/\/ Auxiliary set to determine if a service on the services map was added\n+        \/\/ with the Legacy API. The absence of a service key on this set is an\n+        \/\/ indication that the service was either not added or added with the\n+        \/\/ Current API. Only algorithm service keys are added to this set.\n+        private final Set<ServiceKey> legacySvcKeys;\n+\n+        \/\/ Auxiliary map to keep track of the Properties map entries that\n+        \/\/ originated entries on the internal map. This information is used to\n+        \/\/ avoid inconsistencies. Both algorithm and alias service keys are\n+        \/\/ added to this map.\n+        private final Map<ServiceKey, String> serviceProps;\n+\n+        \/\/ Auxiliary map to keep track of the Properties map entries that\n+        \/\/ originated service attributes on the internal map. This information\n+        \/\/ is used to avoid inconsistencies. Only algorithm service keys are\n+        \/\/ added to this map.\n+        private final Map<ServiceKey, Map<UString, String>> serviceAttrProps;\n+\n+        ServicesMap() {\n+            serviceSet = new AtomicReference<>();\n+            services = new ConcurrentHashMap<>();\n+            legacySvcKeys = new HashSet<>();\n+            serviceProps = new HashMap<>();\n+            serviceAttrProps = new HashMap<>();\n@@ -716,9 +759,3 @@\n-         * Interface to add and remove services to the map according to the\n-         * Current API. These functions update the Properties map to reflect\n-         * service changes, including algorithms, aliases and attributes.\n-         *\n-         * Services added with the Legacy API may be overwritten with this API.\n-         *\n-         * This interface guarantees atomicity from a service reader point\n-         * of view. In other words, a reader that gets a service will see all\n-         * its attributes and aliases as they were at time of registration.\n+         * Constructor to create a thin working copy such that readers of the\n+         * original map do not notice any new changes. Used for atomic changes\n+         * with the Legacy API. See Providers::putAll.\n@@ -726,3 +763,6 @@\n-        interface Current {\n-            SvcOpResult putService(Service svc);\n-            SvcOpResult removeService(Service svc);\n+        ServicesMap(ServicesMap original) {\n+            serviceSet = new AtomicReference<>(original.serviceSet.get());\n+            services = new ConcurrentHashMap<>(original.services);\n+            legacySvcKeys = original.legacySvcKeys;\n+            serviceProps = original.serviceProps;\n+            serviceAttrProps = original.serviceAttrProps;\n@@ -732,12 +772,5 @@\n-         * Interface to add, modify and remove services on the map according to\n-         * the Legacy API. These functions update the Properties map to reflect\n-         * service changes, including algorithms, aliases and attributes.\n-         *\n-         * Services added with the Current API cannot be overwritten with\n-         * this API.\n-         *\n-         * Notice that this interface does not guarantee atomicity in a\n-         * sequence of operations from a service reader point of view. As\n-         * an example, a service reader may get a service missing an attribute\n-         * if looked up between a writer's putClassName() and putAttribute()\n-         * calls. For atomic changes with the Legacy API see Provider::putAll.\n+         * Returns an unmodifiable set of available services. Recomputes\n+         * serviceSet if needed, after a service update. Both services added\n+         * with the Current and Legacy APIs are included. If no services are\n+         * found, the returned set is empty. This method is thread-safe and\n+         * lock-free.\n@@ -745,11 +778,42 @@\n-        interface Legacy {\n-            SvcOpResult putClassName(ServiceKey key, String className,\n-                    String propKey);\n-            SvcOpResult putAlias(ServiceKey key, ServiceKey aliasKey,\n-                    String propKey);\n-            SvcOpResult putAttribute(ServiceKey key, String attrName,\n-                    String attrValue, String propKey);\n-            SvcOpResult remove(ServiceKey key, String className);\n-            SvcOpResult removeAlias(ServiceKey key, ServiceKey aliasKey);\n-            SvcOpResult removeAttribute(ServiceKey key, String attrName,\n-                    String attrValue);\n+        Set<Service> getServices() {\n+            Set<Service> serviceSetLocal = serviceSet.compareAndExchange(\n+                    null, SERVICE_SET_IN_PROGRESS);\n+            if (serviceSetLocal == null ||\n+                    serviceSetLocal == SERVICE_SET_IN_PROGRESS) {\n+                \/\/ A cached set is not available. Instead of locking, compute\n+                \/\/ the set to be returned and, eventually, make it available\n+                \/\/ for others to use.\n+                Set<Service> newSet = computeServicesSet();\n+                if (serviceSetLocal == null) {\n+                    \/\/ We won the race to make the computed set available for\n+                    \/\/ others to use. However, only make it available if it\n+                    \/\/ is still current (in other words, there were no further\n+                    \/\/ changes). If it is not current, the next reader will\n+                    \/\/ do the job.\n+                    serviceSet.compareAndExchange(\n+                            SERVICE_SET_IN_PROGRESS, newSet);\n+                }\n+                serviceSetLocal = newSet;\n+            }\n+            return serviceSetLocal;\n+        }\n+\n+        private Set<Service> computeServicesSet() {\n+            Set<Service> set = new LinkedHashSet<>();\n+            for (Map.Entry<ServiceKey, Service> e : services.entrySet()) {\n+                Service svc = e.getValue();\n+                \/\/ Skip alias based entries and filter out invalid services.\n+                \/\/\n+                \/\/ Note: Multiple versions of the same service (reflecting\n+                \/\/ different points in time) can be generated by concurrent\n+                \/\/ writes with the Legacy API and, as a result of the\n+                \/\/ copy-on-write strategy, seen under different service keys\n+                \/\/ here. Each version has a unique object identity and, thus,\n+                \/\/ would be distinguishable for a Set<Service> set. To avoid\n+                \/\/ duplicates, we skip alias keys and use the version of the\n+                \/\/ service pointed by the algorithm key.\n+                if (e.getKey().equals(svc.algKey) && isValid(svc)) {\n+                    set.add(svc);\n+                }\n+            }\n+            return Collections.unmodifiableSet(set);\n@@ -759,3 +823,3 @@\n-         * This class is the internal implementation of the services map.\n-         * Services can be added or removed either through the Current or the\n-         * Legacy API.\n+         * Returns an available service. Both services added with the Current\n+         * and Legacy APIs are considered in the search. Thread-safe and\n+         * lock-free.\n@@ -763,41 +827,4 @@\n-        private final class ServicesMapImpl implements Current, Legacy {\n-            \/*\n-             * Record to aggregate information about the lookup of a service on\n-             * the internal map. See ServicesMapImpl::find for a description of\n-             * possible values.\n-             *\/\n-            private record MappingInfo(Service svc, ServiceKey algKey,\n-                    Boolean isLegacy) {}\n-\n-            \/\/ The internal services map, containing services registered with\n-            \/\/ the Current and the Legacy APIs. Concurrent read and write access\n-            \/\/ to this map is expected. Both algorithm and alias service keys\n-            \/\/ are added to this map.\n-            private final Map<ServiceKey, Service> services;\n-\n-            \/\/ Auxiliary set to determine if a service on the services map\n-            \/\/ was added with the Legacy API. The absence of a service key\n-            \/\/ on this set is an indication that the service was either not\n-            \/\/ added or added with the Current API. Only algorithm service keys\n-            \/\/ are added to this set.\n-            private final Set<ServiceKey> legacySvcKeys;\n-\n-            \/\/ Auxiliary map to keep track of the Properties map entries that\n-            \/\/ originated entries on the internal map. This information is used\n-            \/\/ to avoid inconsistencies. Both algorithm and alias service keys\n-            \/\/ are added to this map.\n-            private final Map<ServiceKey, String> serviceProps;\n-\n-            \/\/ Auxiliary map to keep track of the Properties map entries that\n-            \/\/ originated service attributes on the internal map. This\n-            \/\/ information is used to avoid inconsistencies. Only algorithm\n-            \/\/ service keys are added to this map.\n-            private final Map<ServiceKey, Map<UString, String>>\n-                    serviceAttrProps;\n-\n-            ServicesMapImpl() {\n-                services = new ConcurrentHashMap<>();\n-                legacySvcKeys = new HashSet<>();\n-                serviceProps = new HashMap<>();\n-                serviceAttrProps = new HashMap<>();\n-            }\n+        Service getService(ServiceKey key) {\n+            Service svc = services.get(key);\n+            return svc != null && isValid(svc) ? svc : null;\n+        }\n@@ -805,11 +832,11 @@\n-            \/*\n-             * Constructor to create a thin working copy such that readers of\n-             * the original map do not notice new changes. Used for atomic\n-             * changes with the Legacy API. See Providers::putAll.\n-             *\/\n-            ServicesMapImpl(ServicesMapImpl original) {\n-                services = new ConcurrentHashMap<>(original.services);\n-                legacySvcKeys = original.legacySvcKeys;\n-                serviceProps = original.serviceProps;\n-                serviceAttrProps = original.serviceAttrProps;\n-            }\n+        \/*\n+         * Clears the internal ServicesMap state. The caller must synchronize\n+         * changes with the Properties map.\n+         *\/\n+        void clear() {\n+            services.clear();\n+            legacySvcKeys.clear();\n+            serviceProps.clear();\n+            serviceAttrProps.clear();\n+            serviceSet.set(null);\n+        }\n@@ -817,15 +844,15 @@\n-            \/*\n-             * Finds information about a service on the internal map. The key\n-             * for the lookup can be either algorithm or alias based. If the\n-             * service is found, svc refers to it, algKey to the algorithm\n-             * service key and isLegacy informs if the service was stored with\n-             * the Current or the Legacy API. Otherwise, svc is null, algKey\n-             * refers to the key used for the lookup and isLegacy is null.\n-             *\/\n-            private MappingInfo find(ServiceKey key) {\n-                Service svc = services.get(key);\n-                ServiceKey algKey = svc != null ? svc.algKey : key;\n-                Boolean isLegacy = svc != null ?\n-                        legacySvcKeys.contains(algKey) : null;\n-                return new MappingInfo(svc, algKey, isLegacy);\n-            }\n+        \/*\n+         * Finds information about a service on the internal map. The key for\n+         * the lookup can be either algorithm or alias based. If the service is\n+         * found, svc refers to it, algKey to the algorithm service key and\n+         * isLegacy informs if the service was stored with the Current or the\n+         * Legacy API. Otherwise, svc is null, algKey refers to the key used for\n+         * the lookup and isLegacy is null.\n+         *\/\n+        private MappingInfo find(ServiceKey key) {\n+            Service svc = services.get(key);\n+            ServiceKey algKey = svc != null ? svc.algKey : key;\n+            Boolean isLegacy = svc != null ?\n+                    legacySvcKeys.contains(algKey) : null;\n+            return new MappingInfo(svc, algKey, isLegacy);\n+        }\n@@ -833,26 +860,7 @@\n-            \/*\n-             * Returns a set of services with services stored on the internal\n-             * map. This method can be invoked concurrently with write accesses\n-             * on the map and is lock-free.\n-             *\/\n-            Set<Service> getServices() {\n-                Set<Service> set = new LinkedHashSet<>();\n-                for (Map.Entry<ServiceKey, Service> e : services.entrySet()) {\n-                    Service svc = e.getValue();\n-                    \/\/\n-                    \/\/ Skip alias based entries and filter out invalid services.\n-                    \/\/\n-                    \/\/ Note: Multiple versions of the same service (reflecting\n-                    \/\/ different points in time) can be generated by concurrent\n-                    \/\/ writes with the Legacy API and, as a result of the\n-                    \/\/ copy-on-write strategy, seen under different service\n-                    \/\/ keys here. Each version has a unique object identity\n-                    \/\/ and, thus, would be distinguishable for a Set<Service>\n-                    \/\/ set. To avoid duplicates, we skip alias keys and use\n-                    \/\/ the version of the service pointed by the algorithm key.\n-                    if (e.getKey().equals(svc.algKey) && isValid(svc)) {\n-                        set.add(svc);\n-                    }\n-                }\n-                return set;\n-            }\n+        \/*\n+         * Signals that there were changes on the services map and the cached\n+         * set of services need to be recomputed before use.\n+         *\/\n+        private void notifyChanges() {\n+            serviceSet.set(null);\n+        }\n@@ -860,4 +868,9 @@\n-            Service getService(ServiceKey key) {\n-                Service svc = services.get(key);\n-                return svc != null && isValid(svc) ? svc : null;\n-            }\n+        \/*\n+         * A service is invalid if it was added with the Legacy API through an\n+         * alias and does not have class information yet. We keep these services\n+         * on the internal map but filter them out for readers, so they don't\n+         * cause a NullPointerException when trying to create a new instance.\n+         *\/\n+        private boolean isValid(Service svc) {\n+            return svc.className != null;\n+        }\n@@ -865,6 +878,12 @@\n-            void clear() {\n-                services.clear();\n-                legacySvcKeys.clear();\n-                serviceProps.clear();\n-                serviceAttrProps.clear();\n-            }\n+        \/*\n+         * Methods to add and remove services to the map according to the\n+         * Current API. These methods update the Properties map to reflect\n+         * service changes, including algorithms, aliases and attributes.\n+         *\n+         * Services added with the Legacy API may be overwritten with these\n+         * methods.\n+         *\n+         * These methods guarantee atomicity from a service reader point of\n+         * view. In other words, a reader that gets a service will see all its\n+         * attributes and aliases as they were at time of registration.\n+         *\/\n@@ -872,7 +891,2 @@\n-            \/*\n-             * Signals that there were changes on the services map and the\n-             * cached set of services need to be recomputed before use.\n-             *\/\n-            private void notifyChanges() {\n-                serviceSet.set(null);\n-            }\n+        boolean putService(Service svc) {\n+            svc.generateServiceKeys();\n@@ -880,10 +894,8 @@\n-            \/*\n-             * A service is invalid if it was added with the Legacy API through\n-             * an alias and does not have class information yet. We keep these\n-             * services on the internal map but filter them out for readers, so\n-             * they don't cause a NullPointerException when trying to create a\n-             * new instance.\n-             *\/\n-            private boolean isValid(Service svc) {\n-                return svc.className != null;\n-            }\n+            \/\/ Define a set of algorithm and alias keys that, if already on the\n+            \/\/ services map, will be kept at all times until overwritten. This\n+            \/\/ prevents concurrent readers from seeing 'holes' on the map while\n+            \/\/ doing updates.\n+            Set<ServiceKey> keysToBeKept =\n+                    new HashSet<>(svc.aliasKeys.size() + 1);\n+            keysToBeKept.add(svc.algKey);\n+            keysToBeKept.addAll(svc.aliasKeys.keySet());\n@@ -891,3 +903,2 @@\n-            \/*\n-             * Current API methods to add and remove services.\n-             *\/\n+            \/\/ The new service algorithm key may be in use already.\n+            resolveKeyConflict(svc.algKey, keysToBeKept);\n@@ -895,3 +906,2 @@\n-            @Override\n-            public SvcOpResult putService(Service svc) {\n-                svc.generateServiceKeys();\n+            \/\/ The service will be registered to its provider's ServicesMap.\n+            svc.registered = true;\n@@ -899,8 +909,3 @@\n-                \/\/ Define a set of algorithm and alias keys that, if already\n-                \/\/ on the services map, will be kept at all times until\n-                \/\/ overwritten. This prevents concurrent readers from seeing\n-                \/\/ 'holes' on the map while doing updates.\n-                Set<ServiceKey> keysToBeKept =\n-                        new HashSet<>(svc.aliasKeys.size() + 1);\n-                keysToBeKept.add(svc.algKey);\n-                keysToBeKept.addAll(svc.aliasKeys.keySet());\n+            \/\/ Register the new service under its algorithm service key. At this\n+            \/\/ point, readers will have access to it.\n+            services.put(svc.algKey, svc);\n@@ -908,2 +913,6 @@\n-                \/\/ The new service algorithm key may be in use already.\n-                resolveKeyConflict(svc.algKey, keysToBeKept);\n+            \/\/ Add an entry to the Properties map to reflect the new service\n+            \/\/ under its algorithm key, and keep track of this information for\n+            \/\/ further changes in the future (i.e. removal of the service).\n+            String propKey = svc.getType() + \".\" + svc.getAlgorithm();\n+            serviceProps.put(svc.algKey, propKey);\n+            Provider.super.put(propKey, svc.getClassName());\n@@ -911,2 +920,3 @@\n-                \/\/ The service will be registered to its provider's ServicesMap.\n-                svc.registered = true;\n+            \/\/ Register the new service under its aliases.\n+            for (Map.Entry<ServiceKey, String> e : svc.aliasKeys.entrySet()) {\n+                ServiceKey aliasKey = e.getKey();\n@@ -914,3 +924,6 @@\n-                \/\/ Register the new service under its algorithm service key.\n-                \/\/ At this point, readers  will have access to it.\n-                services.put(svc.algKey, svc);\n+                \/\/ The new service alias may be in use already.\n+                resolveKeyConflict(aliasKey, keysToBeKept);\n+\n+                \/\/ Register the new service under its alias service key. At this\n+                \/\/ point, readers will have access through this alias.\n+                services.put(aliasKey, svc);\n@@ -919,27 +932,7 @@\n-                \/\/ under its algorithm key, and keep track of this information\n-                \/\/ for further changes in the future (i.e. removal of the\n-                \/\/ service).\n-                String propKey = svc.getType() + \".\" + svc.getAlgorithm();\n-                serviceProps.put(svc.algKey, propKey);\n-                Provider.super.put(propKey, svc.getClassName());\n-\n-                \/\/ Register the new service under its aliases.\n-                for (Map.Entry<ServiceKey, String> e :\n-                        svc.aliasKeys.entrySet()) {\n-                    ServiceKey aliasKey = e.getKey();\n-\n-                    \/\/ The new service alias may be in use already.\n-                    resolveKeyConflict(aliasKey, keysToBeKept);\n-\n-                    \/\/ Register the new service under its alias service key. At\n-                    \/\/ this point, readers will have access through this alias.\n-                    services.put(aliasKey, svc);\n-\n-                    \/\/ Add an entry to the Properties map to reflect the new\n-                    \/\/ service under its alias service key, and keep track\n-                    \/\/ of this information for further changes in the future\n-                    \/\/ (i.e. removal of the service).\n-                    propKey = ALIAS_PREFIX + svc.getType() + \".\" + e.getValue();\n-                    serviceProps.put(aliasKey, propKey);\n-                    Provider.super.put(propKey, svc.getAlgorithm());\n-                }\n+                \/\/ under its alias service key, and keep track of this\n+                \/\/ information for further changes in the future (i.e. removal\n+                \/\/ of the service).\n+                propKey = ALIAS_PREFIX + svc.getType() + \".\" + e.getValue();\n+                serviceProps.put(aliasKey, propKey);\n+                Provider.super.put(propKey, svc.getAlgorithm());\n+            }\n@@ -947,14 +940,12 @@\n-                if (!svc.attributes.isEmpty()) {\n-                    \/\/ Register the new service attributes on the Properties map\n-                    \/\/ and keep track of them for further changes in the future\n-                    \/\/ (i.e. removal of the service).\n-                    Map<UString, String> newAttrProps =\n-                            new HashMap<>(svc.attributes.size());\n-                    for (Map.Entry<UString, String> attr :\n-                            svc.attributes.entrySet()) {\n-                        propKey = svc.getType() + \".\" + svc.getAlgorithm() +\n-                                \" \" + attr.getKey().string;\n-                        newAttrProps.put(attr.getKey(), propKey);\n-                        Provider.super.put(propKey, attr.getValue());\n-                    }\n-                    serviceAttrProps.put(svc.algKey, newAttrProps);\n+            if (!svc.attributes.isEmpty()) {\n+                \/\/ Register the new service attributes on the Properties map and\n+                \/\/ keep track of them for further changes in the future (i.e.\n+                \/\/ removal of the service).\n+                Map<UString, String> newAttrProps =\n+                        new HashMap<>(svc.attributes.size());\n+                for (Map.Entry<UString, String> attr :\n+                        svc.attributes.entrySet()) {\n+                    propKey = svc.getType() + \".\" + svc.getAlgorithm() + \" \" +\n+                            attr.getKey().string;\n+                    newAttrProps.put(attr.getKey(), propKey);\n+                    Provider.super.put(propKey, attr.getValue());\n@@ -962,0 +953,2 @@\n+                serviceAttrProps.put(svc.algKey, newAttrProps);\n+            }\n@@ -963,1 +956,1 @@\n-                Provider.this.checkAndUpdateSecureRandom(svc.algKey, true);\n+            Provider.this.checkAndUpdateSecureRandom(svc.algKey, true);\n@@ -965,2 +958,2 @@\n-                return SvcOpResult.SUCCESS;\n-            }\n+            return true;\n+        }\n@@ -968,17 +961,24 @@\n-            \/*\n-             * Handle cases in which a service key (algorithm or alias based)\n-             * is in use already. This might require modifications to a service,\n-             * the Properties map or auxiliary structures. This method must be\n-             * called from the Current API only.\n-             *\/\n-            private void resolveKeyConflict(ServiceKey key,\n-                    Set<ServiceKey> keysToBeKept) {\n-                assert keysToBeKept.contains(key) : \"Inconsistent \" +\n-                        \"keysToBeKept set.\";\n-                MappingInfo miByKey = find(key);\n-                if (miByKey.svc != null) {\n-                    \/\/ The service key (algorithm or alias) is in use already.\n-                    SvcOpResult opResult = SvcOpResult.SUCCESS;\n-                    if (miByKey.algKey.equals(key)) {\n-                        \/\/ It is used as an algorithm. Remove the service.\n-                        opResult = removeCommon(miByKey, false, keysToBeKept);\n+        \/*\n+         * Handle cases in which a service key (algorithm or alias based) is in\n+         * use already. This might require modifications to a service, the\n+         * Properties map or auxiliary structures. This method must be called\n+         * from the Current API only.\n+         *\/\n+        private void resolveKeyConflict(ServiceKey key,\n+                Set<ServiceKey> keysToBeKept) {\n+            assert keysToBeKept.contains(key) :\n+                    \"Inconsistent keysToBeKept set.\";\n+            MappingInfo miByKey = find(key);\n+            if (miByKey.svc != null) {\n+                \/\/ The service key (algorithm or alias) is in use already.\n+                boolean opSucceeded = true;\n+                if (miByKey.algKey.equals(key)) {\n+                    \/\/ It is used as an algorithm. Remove the service.\n+                    opSucceeded = removeCommon(miByKey, false, keysToBeKept);\n+                } else {\n+                    \/\/ It is used as an alias.\n+                    if (miByKey.isLegacy) {\n+                        \/\/ The service was added with the Legacy API. Remove the\n+                        \/\/ alias only.\n+                        opSucceeded = removeAliasLegacy(miByKey.algKey, key,\n+                                keysToBeKept);\n@@ -986,21 +986,11 @@\n-                        \/\/ It is used as an alias.\n-                        if (miByKey.isLegacy) {\n-                            \/\/ The service was added with the Legacy API.\n-                            \/\/ Remove the alias only.\n-                            opResult = removeAlias(miByKey.algKey, key,\n-                                    keysToBeKept);\n-                        } else {\n-                            \/\/ The service was added with the Current API.\n-                            \/\/ Overwrite the alias entry on the services map\n-                            \/\/ without modifying the service that is currently\n-                            \/\/ using it.\n-\n-                            \/\/ Remove any Properties map key entry because, if\n-                            \/\/ no longer used as an alias, the entry would not\n-                            \/\/ be overwritten. Note: The serviceProps key entry\n-                            \/\/ will be overwritten later.\n-                            String oldPropKey = serviceProps.remove(key);\n-                            assert oldPropKey != null :\n-                                    \"Invalid alias property.\";\n-                            Provider.super.remove(oldPropKey);\n-                        }\n+                        \/\/ The service was added with the Current API. Overwrite\n+                        \/\/ the alias entry on the services map without modifying\n+                        \/\/ the service that is currently using it.\n+\n+                        \/\/ Remove any Properties map key entry because, if no\n+                        \/\/ longer used as an alias, the entry would not be\n+                        \/\/ overwritten. Note: The serviceProps key entry will be\n+                        \/\/ overwritten later.\n+                        String oldPropKey = serviceProps.remove(key);\n+                        assert oldPropKey != null : \"Invalid alias property.\";\n+                        Provider.super.remove(oldPropKey);\n@@ -1008,2 +998,0 @@\n-                    assert opResult == SvcOpResult.SUCCESS : \"Unexpected\" +\n-                            \" error removing an existing service or alias.\";\n@@ -1011,0 +999,2 @@\n+                assert opSucceeded : \"Unexpected error removing an existing \" +\n+                        \"service or alias.\";\n@@ -1012,0 +1002,1 @@\n+        }\n@@ -1013,11 +1004,9 @@\n-            @Override\n-            public SvcOpResult removeService(Service svc) {\n-                if (svc.algKey != null) {\n-                    MappingInfo mi = find(svc.algKey);\n-                    if (mi.svc != null) {\n-                        SvcOpResult opResult = removeCommon(mi, false,\n-                                Collections.emptySet());\n-                        assert opResult == SvcOpResult.SUCCESS : \"Unexpected\" +\n-                                \" error removing an existing service.\";\n-                        return opResult;\n-                    }\n+        boolean removeService(Service svc) {\n+            if (svc.algKey != null) {\n+                MappingInfo mi = find(svc.algKey);\n+                if (mi.svc != null) {\n+                    boolean opSucceeded = removeCommon(mi, false,\n+                            Collections.emptySet());\n+                    assert opSucceeded : \"Unexpected error removing an \" +\n+                            \"existing service.\";\n+                    return opSucceeded;\n@@ -1025,1 +1014,0 @@\n-                return SvcOpResult.SUCCESS;\n@@ -1027,0 +1015,2 @@\n+            return true;\n+        }\n@@ -1028,23 +1018,3 @@\n-            \/*\n-             * Common (Current and Legacy) API methods to add and remove\n-             * services.\n-             *\/\n-\n-            \/*\n-             * This method is invoked both when removing and overwriting a\n-             * service. The keysToBeKept set is used when overwriting to\n-             * prevent readers from seeing a 'hole' on the services map\n-             * between removing and adding entries.\n-             *\/\n-            private SvcOpResult removeCommon(MappingInfo mi,\n-                    boolean legacyApiCall, Set<ServiceKey> keysToBeKept) {\n-                assert mi.svc != null : \"Invalid service for removal.\";\n-                if (!mi.isLegacy && legacyApiCall) {\n-                    \/\/ Services added with the Current API cannot be\n-                    \/\/ removed with the Legacy API.\n-                    return SvcOpResult.ERROR;\n-                }\n-\n-                if (mi.isLegacy) {\n-                    legacySvcKeys.remove(mi.algKey);\n-                }\n+        \/*\n+         * Common (Current and Legacy) API methods to add and remove services.\n+         *\/\n@@ -1052,3 +1022,14 @@\n-                if (!keysToBeKept.contains(mi.algKey)) {\n-                    services.remove(mi.algKey);\n-                }\n+        \/*\n+         * This method is invoked both when removing and overwriting a service.\n+         * The keysToBeKept set is used when overwriting to prevent readers from\n+         * seeing a 'hole' on the services map between removing and adding\n+         * entries.\n+         *\/\n+        private boolean removeCommon(MappingInfo mi, boolean legacyApiCall,\n+                Set<ServiceKey> keysToBeKept) {\n+            assert mi.svc != null : \"Invalid service for removal.\";\n+            if (!mi.isLegacy && legacyApiCall) {\n+                \/\/ Services added with the Current API cannot be removed with\n+                \/\/ the Legacy API.\n+                return false;\n+            }\n@@ -1056,8 +1037,3 @@\n-                \/\/ Update the Properties map to reflect the algorithm removal.\n-                \/\/ Note: oldPropKey may be null for services added through\n-                \/\/ aliases or attributes (Legacy API) that still don't have a\n-                \/\/ class name (invalid).\n-                String oldPropKey = serviceProps.remove(mi.algKey);\n-                if (oldPropKey != null) {\n-                    Provider.super.remove(oldPropKey);\n-                }\n+            if (mi.isLegacy) {\n+                legacySvcKeys.remove(mi.algKey);\n+            }\n@@ -1065,16 +1041,3 @@\n-                \/\/ Remove registered service aliases.\n-                for (ServiceKey aliasKey : mi.svc.aliasKeys.keySet()) {\n-                    if (!mi.isLegacy) {\n-                        \/\/ Services added with the Current API can have aliases\n-                        \/\/ overwritten by other services added with the same\n-                        \/\/ API. Do nothing in these cases: the alias on the\n-                        \/\/ services map does not belong to the removed service\n-                        \/\/ anymore.\n-                        MappingInfo miByAlias = find(aliasKey);\n-                        if (miByAlias.svc != mi.svc) {\n-                            continue;\n-                        }\n-                    }\n-                    if (!keysToBeKept.contains(aliasKey)) {\n-                        services.remove(aliasKey);\n-                    }\n+            if (!keysToBeKept.contains(mi.algKey)) {\n+                services.remove(mi.algKey);\n+            }\n@@ -1082,8 +1045,8 @@\n-                    \/\/ Update the Properties map to reflect the alias removal.\n-                    \/\/ Note: oldPropKey cannot be null because aliases always\n-                    \/\/ have a corresponding Properties map entry.\n-                    oldPropKey = serviceProps.remove(aliasKey);\n-                    assert oldPropKey != null : \"Unexpected null \" +\n-                            \"Property value for an alias.\";\n-                    Provider.super.remove(oldPropKey);\n-                }\n+            \/\/ Update the Properties map to reflect the algorithm removal. Note:\n+            \/\/ oldPropKey may be null for services added through aliases or\n+            \/\/ attributes (Legacy API) that still don't have a class name\n+            \/\/ (invalid).\n+            String oldPropKey = serviceProps.remove(mi.algKey);\n+            if (oldPropKey != null) {\n+                Provider.super.remove(oldPropKey);\n+            }\n@@ -1091,12 +1054,10 @@\n-                \/\/ Remove registered service attributes.\n-                Map<UString, String> oldAttrProps =\n-                        serviceAttrProps.remove(mi.algKey);\n-                if (oldAttrProps != null) {\n-                    for (String oldAttrPropKey : oldAttrProps.values()) {\n-                        \/\/ Update the Properties map to reflect the attribute\n-                        \/\/ removal. Note: oldAttrPropKey cannot be null because\n-                        \/\/ attributes always have a corresponding Properties map\n-                        \/\/ entry.\n-                        assert oldAttrPropKey != null : \"Unexpected null \" +\n-                                \"Property value for an attribute.\";\n-                        Provider.super.remove(oldAttrPropKey);\n+            \/\/ Remove registered service aliases.\n+            for (ServiceKey aliasKey : mi.svc.aliasKeys.keySet()) {\n+                if (!mi.isLegacy) {\n+                    \/\/ Services added with the Current API can have aliases\n+                    \/\/ overwritten by other services added with the same API. Do\n+                    \/\/ nothing in these cases: the alias on the services map\n+                    \/\/ does not belong to the removed service anymore.\n+                    MappingInfo miByAlias = find(aliasKey);\n+                    if (miByAlias.svc != mi.svc) {\n+                        continue;\n@@ -1105,0 +1066,3 @@\n+                if (!keysToBeKept.contains(aliasKey)) {\n+                    services.remove(aliasKey);\n+                }\n@@ -1106,5 +1070,7 @@\n-                notifyChanges();\n-\n-                Provider.this.checkAndUpdateSecureRandom(mi.svc.algKey, false);\n-\n-                return SvcOpResult.SUCCESS;\n+                \/\/ Update the Properties map to reflect the alias removal. Note:\n+                \/\/ oldPropKey cannot be null because aliases always have a\n+                \/\/ corresponding Properties map entry.\n+                oldPropKey = serviceProps.remove(aliasKey);\n+                assert oldPropKey != null :\n+                        \"Unexpected null Property value for an alias.\";\n+                Provider.super.remove(oldPropKey);\n@@ -1113,46 +1079,13 @@\n-            \/*\n-             * Legacy API methods to add, modify and remove services.\n-             *\/\n-\n-            @Override\n-            public SvcOpResult putClassName(ServiceKey key, String className,\n-                    String propKey) {\n-                assert key != null && className != null && propKey != null :\n-                        \"Service information missing.\";\n-                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n-                    String canonicalPropKey = propKey;\n-                    if (oldMi.svc != null) {\n-                        \/\/ The service exists. Get its Properties map entry.\n-                        \/\/ Note: Services added through an alias or an attribute\n-                        \/\/ may don't have one.\n-                        String oldPropKey = serviceProps.get(oldMi.algKey);\n-                        if (oldMi.algKey.equals(key)) {\n-                            \/\/ The service was found by an algorithm.\n-                            if (oldPropKey != null) {\n-                                \/\/ Remove any previous Properties map entry\n-                                \/\/ before adding a new one, so we handle\n-                                \/\/ differences in casing.\n-                                Provider.super.remove(oldPropKey);\n-                            }\n-                        } else {\n-                            \/\/ The service was found by an alias. Use an\n-                            \/\/ algorithm entry on the Properties map. Create a\n-                            \/\/ new one if it does not exist.\n-                            canonicalPropKey = oldPropKey != null ?\n-                                    oldPropKey : newSvc.getType() + \".\" +\n-                                    newSvc.getAlgorithm();\n-                        }\n-                    }\n-\n-                    newSvc.className = className;\n-\n-                    \/\/ Keep track of the Properties map entry for further\n-                    \/\/ changes in the future (i.e. removal of the service).\n-                    serviceProps.put(oldMi.algKey, canonicalPropKey);\n-                    Provider.super.put(canonicalPropKey, className);\n-\n-                    Provider.this.checkAndUpdateSecureRandom(\n-                            newSvc.algKey, true);\n-\n-                    return SvcOpResult.SUCCESS;\n-                });\n+            \/\/ Remove registered service attributes.\n+            Map<UString, String> oldAttrProps =\n+                    serviceAttrProps.remove(mi.algKey);\n+            if (oldAttrProps != null) {\n+                for (String oldAttrPropKey : oldAttrProps.values()) {\n+                    \/\/ Update the Properties map to reflect the attribute\n+                    \/\/ removal. Note: oldAttrPropKey cannot be null because\n+                    \/\/ attributes always have a corresponding Properties map\n+                    \/\/ entry.\n+                    assert oldAttrPropKey != null :\n+                            \"Unexpected null Property value for an attribute.\";\n+                    Provider.super.remove(oldAttrPropKey);\n+                }\n@@ -1161,48 +1094,1 @@\n-            @Override\n-            public SvcOpResult putAlias(ServiceKey key, ServiceKey aliasKey,\n-                    String propKey) {\n-                assert key != null && aliasKey != null && propKey != null :\n-                        \"Alias information missing.\";\n-                assert key.type.equals(aliasKey.type) :\n-                        \"Inconsistent service key types.\";\n-                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n-                    MappingInfo miByAlias = find(aliasKey);\n-                    if (miByAlias.svc != null) {\n-                        \/\/ The alias is associated to a service on the map.\n-                        if (miByAlias.algKey.equals(aliasKey)) {\n-                            \/\/ The alias is an algorithm. Never overwrite\n-                            \/\/ algorithms with aliases from the Legacy API.\n-                            return SvcOpResult.ERROR;\n-                        } else if (!miByAlias.isLegacy) {\n-                            \/\/ Do not remove the alias of services added with\n-                            \/\/ the Current API.\n-                            return SvcOpResult.ERROR;\n-                        } else if (miByAlias.svc == oldMi.svc) {\n-                            \/\/ The service has the alias that we are adding.\n-                            \/\/ This is possible if, for example, the alias\n-                            \/\/ casing is changing.\n-                            \/\/\n-                            \/\/ Update the Properties map to remove the alias\n-                            \/\/ with the old casing. Note: oldPropKey cannot be\n-                            \/\/ null because aliases always have a corresponding\n-                            \/\/ Properties map entry.\n-                            String oldPropKey = serviceProps.remove(aliasKey);\n-                            assert oldPropKey != null : \"Unexpected null \" +\n-                                    \"Property value for an alias.\";\n-                            Provider.super.remove(oldPropKey);\n-                        } else {\n-                            \/\/ The alias belongs to a different service.\n-                            \/\/ Remove it first.\n-                            SvcOpResult opResult = removeAlias(miByAlias.algKey,\n-                                    aliasKey, Set.of(aliasKey));\n-                            assert opResult == SvcOpResult.SUCCESS :\n-                                    \"Unexpected error removing an alias.\";\n-                        }\n-                    } else {\n-                        \/\/ The alias was not found on the map.\n-                        if (aliasKey.equals(key)) {\n-                            \/\/ The alias would be equal to the algorithm for\n-                            \/\/ the new service.\n-                            return SvcOpResult.ERROR;\n-                        }\n-                    }\n+            notifyChanges();\n@@ -1210,1 +1096,1 @@\n-                    newSvc.addAliasKey(aliasKey);\n+            Provider.this.checkAndUpdateSecureRandom(mi.svc.algKey, false);\n@@ -1212,8 +1098,2 @@\n-                    \/\/ Keep track of the Properties map entry for further\n-                    \/\/ changes in the future (i.e. removal of the service).\n-                    serviceProps.put(aliasKey, propKey);\n-                    \/\/ If the service to which we will add an alias was found by\n-                    \/\/ an alias, use its algorithm for the Properties map entry.\n-                    String canonicalAlgorithm = oldMi.algKey.equals(key) ?\n-                            key.originalAlgorithm : newSvc.getAlgorithm();\n-                    Provider.super.put(propKey, canonicalAlgorithm);\n+            return true;\n+        }\n@@ -1221,3 +1101,15 @@\n-                    return SvcOpResult.SUCCESS;\n-                });\n-            }\n+        \/*\n+         * Methods to add, modify and remove services on the map according to\n+         * the Legacy API. These methods update the Properties map to reflect\n+         * service changes, including algorithms, aliases and attributes.\n+         *\n+         * Services added with the Current API cannot be overwritten with this\n+         * API.\n+         *\n+         * Notice that these methods do not guarantee atomicity in a sequence of\n+         * operations from a service reader point of view. As an example, a\n+         * service reader may get a service missing an attribute if looked up\n+         * between a writer's ServicesMap::putClassNameLegacy and\n+         * ServicesMap::putAttributeLegacy calls. For atomic changes with the\n+         * Legacy API see Provider::putAll.\n+         *\/\n@@ -1225,17 +1117,11 @@\n-            @Override\n-            public SvcOpResult putAttribute(ServiceKey key, String attrName,\n-                    String attrValue, String propKey) {\n-                assert key != null && attrName != null && attrValue != null &&\n-                        propKey != null : \"Attribute information missing.\";\n-                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n-                    String canonicalPropKey = propKey;\n-                    UString attrNameKey = new UString(attrName);\n-                    Map<UString, String> attrProps =\n-                            serviceAttrProps.computeIfAbsent(\n-                                    oldMi.algKey, k -> new HashMap<>());\n-                    assert oldMi.svc != null || attrProps.isEmpty() :\n-                            \"Inconsistent service attributes data.\";\n-                    \/\/ Try to get the attribute's Properties map entry. Note:\n-                    \/\/ oldPropKey can be null if the service was not found or\n-                    \/\/ does not have the attribute.\n-                    String oldPropKey = attrProps.get(attrNameKey);\n+        boolean putClassNameLegacy(ServiceKey key, String className,\n+                String propKey) {\n+            assert key != null && className != null && propKey != null :\n+                    \"Service information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                String canonicalPropKey = propKey;\n+                if (oldMi.svc != null) {\n+                    \/\/ The service exists. Get its Properties map entry. Note:\n+                    \/\/ Services added through an alias or an attribute may don't\n+                    \/\/ have one.\n+                    String oldPropKey = serviceProps.get(oldMi.algKey);\n@@ -1252,2 +1138,2 @@\n-                        \/\/ based entry on the Properties map. Create a new one\n-                        \/\/ if it does not exist.\n+                        \/\/ entry on the Properties map. Create a new one if it\n+                        \/\/ does not exist.\n@@ -1255,2 +1141,1 @@\n-                                newSvc.getType() + \".\" + newSvc.getAlgorithm() +\n-                                \" \" + attrName;\n+                                newSvc.getType() + \".\" + newSvc.getAlgorithm();\n@@ -1258,21 +1143,0 @@\n-\n-                    newSvc.addAttribute(attrName, attrValue);\n-\n-                    \/\/ Keep track of the Properties map entry for further\n-                    \/\/ changes in the future (i.e. removal of the service).\n-                    attrProps.put(attrNameKey, canonicalPropKey);\n-                    Provider.super.put(canonicalPropKey, attrValue);\n-\n-                    return SvcOpResult.SUCCESS;\n-                });\n-            }\n-\n-            @Override\n-            public SvcOpResult remove(ServiceKey key, String className) {\n-                assert key != null && className != null :\n-                        \"Service information missing.\";\n-                MappingInfo mi = find(key);\n-                if (mi.svc != null) {\n-                    assert className.equals(mi.svc.getClassName()) :\n-                            \"Unexpected class name.\";\n-                    return removeCommon(mi, true, Collections.emptySet());\n@@ -1280,3 +1144,0 @@\n-                assert false : \"Should not reach.\";\n-                return SvcOpResult.ERROR;\n-            }\n@@ -1284,5 +1145,1 @@\n-            @Override\n-            public SvcOpResult removeAlias(ServiceKey key,\n-                    ServiceKey aliasKey) {\n-                return removeAlias(key, aliasKey, Collections.emptySet());\n-            }\n+                newSvc.className = className;\n@@ -1290,19 +1147,4 @@\n-            \/*\n-             * This method is invoked both when removing and overwriting a\n-             * service alias. The keysToBeKept set is used when overwriting to\n-             * prevent readers from seeing a 'hole' on the services map between\n-             * removing and adding entries.\n-             *\/\n-            private SvcOpResult removeAlias(ServiceKey key, ServiceKey aliasKey,\n-                    Set<ServiceKey> keysToBeKept) {\n-                assert key != null && aliasKey != null && keysToBeKept != null :\n-                        \"Alias information missing.\";\n-                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n-                    MappingInfo miByAlias = find(aliasKey);\n-                    if (oldMi.svc != null && miByAlias.svc == oldMi.svc &&\n-                            !miByAlias.algKey.equals(aliasKey)) {\n-                        \/\/ The alias is a real alias and is associated to the\n-                        \/\/ service on the map.\n-                        if (!keysToBeKept.contains(aliasKey)) {\n-                            services.remove(aliasKey);\n-                        }\n+                \/\/ Keep track of the Properties map entry for further changes in\n+                \/\/ the future (i.e. removal of the service).\n+                serviceProps.put(oldMi.algKey, canonicalPropKey);\n+                Provider.super.put(canonicalPropKey, className);\n@@ -1310,1 +1152,1 @@\n-                        newSvc.removeAliasKey(aliasKey);\n+                Provider.this.checkAndUpdateSecureRandom(newSvc.algKey, true);\n@@ -1312,4 +1154,31 @@\n-                        \/\/ Update the Properties map to reflect the alias\n-                        \/\/ removal. Note: oldPropKey cannot be null because\n-                        \/\/ aliases always have a corresponding Properties map\n-                        \/\/ entry.\n+                return true;\n+            });\n+        }\n+\n+        boolean putAliasLegacy(ServiceKey key, ServiceKey aliasKey,\n+                String propKey) {\n+            assert key != null && aliasKey != null && propKey != null :\n+                    \"Alias information missing.\";\n+            assert key.type.equals(aliasKey.type) :\n+                    \"Inconsistent service key types.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                MappingInfo miByAlias = find(aliasKey);\n+                if (miByAlias.svc != null) {\n+                    \/\/ The alias is associated to a service on the map.\n+                    if (miByAlias.algKey.equals(aliasKey)) {\n+                        \/\/ The alias is an algorithm. Never overwrite algorithms\n+                        \/\/ with aliases from the Legacy API.\n+                        return false;\n+                    } else if (!miByAlias.isLegacy) {\n+                        \/\/ Do not remove the alias of services added with the\n+                        \/\/ Current API.\n+                        return false;\n+                    } else if (miByAlias.svc == oldMi.svc) {\n+                        \/\/ The service has the alias that we are adding. This is\n+                        \/\/ possible if, for example, the alias casing is\n+                        \/\/ changing.\n+                        \/\/\n+                        \/\/ Update the Properties map to remove the alias with\n+                        \/\/ the old casing. Note: oldPropKey cannot be null\n+                        \/\/ because aliases always have a corresponding\n+                        \/\/ Properties map entry.\n@@ -1317,33 +1186,0 @@\n-                        assert oldPropKey != null : \"Invalid alias property.\";\n-                        Provider.super.remove(oldPropKey);\n-\n-                        return SvcOpResult.SUCCESS;\n-                    }\n-                    assert false : \"Should not reach.\";\n-                    return SvcOpResult.ERROR;\n-                });\n-            }\n-\n-            @Override\n-            public SvcOpResult removeAttribute(ServiceKey key,\n-                    String attrName, String attrValue) {\n-                assert key != null && attrName != null && attrValue != null :\n-                        \"Attribute information missing.\";\n-                return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n-                    Map<UString, String> oldAttrProps =\n-                            serviceAttrProps.get(oldMi.algKey);\n-                    if (oldAttrProps != null) {\n-                        \/\/ The service was found and has attributes.\n-                        assert oldMi.svc != null : \"Inconsistent service \" +\n-                                \"attributes data.\";\n-\n-                        newSvc.removeAttribute(attrName, attrValue);\n-                        assert newSvc.getAttribute(attrName) == null :\n-                                \"Attribute was not removed from the service.\";\n-\n-                        \/\/ Update the Properties map to reflect the attribute\n-                        \/\/ removal. Note: oldPropKey cannot be null because\n-                        \/\/ attributes always have a corresponding Properties\n-                        \/\/ map entry.\n-                        String oldPropKey = oldAttrProps.remove(\n-                                new UString(attrName));\n@@ -1351,1 +1187,1 @@\n-                                \"Invalid attribute property.\";\n+                                \"Unexpected null Property value for an alias.\";\n@@ -1353,39 +1189,7 @@\n-\n-                        if (oldAttrProps.isEmpty()) {\n-                            \/\/ If the removed attribute was the last one,\n-                            \/\/ remove the map.\n-                            serviceAttrProps.remove(oldMi.algKey);\n-                        }\n-\n-                        return SvcOpResult.SUCCESS;\n-                    }\n-                    assert false : \"Should not reach.\";\n-                    return SvcOpResult.ERROR;\n-                });\n-            }\n-\n-            @FunctionalInterface\n-            private interface ServiceUpdateCallback {\n-                SvcOpResult apply(MappingInfo oldMi, Service newSvc);\n-            }\n-\n-            \/*\n-             * This method tries to find a service on the map (based on an\n-             * algorithm or alias) and pass a copy of it to an update callback\n-             * (copy-on-write). If the service found was added with the Current\n-             * API, no update should be done. If a service was not found, a new\n-             * instance may be created.\n-             *\n-             * The updated version of the service is put on the services map.\n-             * Algorithm and alias based entries pointing to the old version\n-             * of the service are overwritten.\n-             *\/\n-            private SvcOpResult updateSvc(ServiceKey key,\n-                    ServiceUpdateCallback updateCb) {\n-                Service newSvc;\n-                MappingInfo oldMi = find(key);\n-                if (oldMi.svc != null) {\n-                    \/\/ Service exists.\n-                    if (!oldMi.isLegacy) {\n-                        \/\/ Don't update services added with the Current API.\n-                        return SvcOpResult.ERROR;\n+                    } else {\n+                        \/\/ The alias belongs to a different service. Remove it\n+                        \/\/ first.\n+                        boolean opSucceeded = removeAliasLegacy(\n+                                miByAlias.algKey, aliasKey, Set.of(aliasKey));\n+                        assert opSucceeded :\n+                                \"Unexpected error removing an alias.\";\n@@ -1393,2 +1197,0 @@\n-                    \/\/ Create a copy of the service for a copy-on-write update.\n-                    newSvc = new Service(oldMi.svc);\n@@ -1396,7 +1198,6 @@\n-                    \/\/ Service does not exist.\n-                    newSvc = new Service(Provider.this, key);\n-                }\n-                SvcOpResult opResult = updateCb.apply(oldMi, newSvc);\n-                if (opResult == SvcOpResult.ERROR) {\n-                    \/\/ Something went wrong and the update should not be done.\n-                    return opResult;\n+                    \/\/ The alias was not found on the map.\n+                    if (aliasKey.equals(key)) {\n+                        \/\/ The alias would be equal to the algorithm for the new\n+                        \/\/ service.\n+                        return false;\n+                    }\n@@ -1405,3 +1206,10 @@\n-                \/\/ The service (or its updated version) will be registered to\n-                \/\/ its provider's ServicesMap.\n-                newSvc.registered = true;\n+                newSvc.addAliasKey(aliasKey);\n+\n+                \/\/ Keep track of the Properties map entry for further changes in\n+                \/\/ the future (i.e. removal of the service).\n+                serviceProps.put(aliasKey, propKey);\n+                \/\/ If the service to which we will add an alias was found by an\n+                \/\/ alias, use its algorithm for the Properties map entry.\n+                String canonicalAlgorithm = oldMi.algKey.equals(key) ?\n+                        key.originalAlgorithm : newSvc.getAlgorithm();\n+                Provider.super.put(propKey, canonicalAlgorithm);\n@@ -1409,6 +1217,34 @@\n-                \/\/ Register the updated version of the service under its\n-                \/\/ algorithm and aliases on the map. This may overwrite entries\n-                \/\/ or add new ones. The previous callback should have handled\n-                \/\/ the removal of an alias.\n-                for (ServiceKey aliasKey : newSvc.aliasKeys.keySet()) {\n-                    services.put(aliasKey, newSvc);\n+                return true;\n+            });\n+        }\n+\n+        boolean putAttributeLegacy(ServiceKey key, String attrName,\n+                String attrValue, String propKey) {\n+            assert key != null && attrName != null && attrValue != null &&\n+                    propKey != null : \"Attribute information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                String canonicalPropKey = propKey;\n+                UString attrNameKey = new UString(attrName);\n+                Map<UString, String> attrProps =\n+                        serviceAttrProps.computeIfAbsent(\n+                                oldMi.algKey, k -> new HashMap<>());\n+                assert oldMi.svc != null || attrProps.isEmpty() :\n+                        \"Inconsistent service attributes data.\";\n+                \/\/ Try to get the attribute's Properties map entry. Note:\n+                \/\/ oldPropKey can be null if the service was not found or does\n+                \/\/ not have the attribute.\n+                String oldPropKey = attrProps.get(attrNameKey);\n+                if (oldMi.algKey.equals(key)) {\n+                    \/\/ The service was found by an algorithm.\n+                    if (oldPropKey != null) {\n+                        \/\/ Remove any previous Properties map entry before\n+                        \/\/ adding a new one, so we handle differences in casing.\n+                        Provider.super.remove(oldPropKey);\n+                    }\n+                } else {\n+                    \/\/ The service was found by an alias. Use an algorithm based\n+                    \/\/ entry on the Properties map. Create a new one if it does\n+                    \/\/ not exist.\n+                    canonicalPropKey = oldPropKey != null ? oldPropKey :\n+                            newSvc.getType() + \".\" + newSvc.getAlgorithm() +\n+                            \" \" + attrName;\n@@ -1417,4 +1253,1 @@\n-                assert oldMi.algKey.type.equals(newSvc.getType()) &&\n-                        oldMi.algKey.originalAlgorithm.equals(\n-                                newSvc.getAlgorithm()) : \"Invalid key.\";\n-                services.put(oldMi.algKey, newSvc);\n+                newSvc.addAttribute(attrName, attrValue);\n@@ -1422,1 +1255,4 @@\n-                legacySvcKeys.add(oldMi.algKey);\n+                \/\/ Keep track of the Properties map entry for further changes in\n+                \/\/ the future (i.e. removal of the service).\n+                attrProps.put(attrNameKey, canonicalPropKey);\n+                Provider.super.put(canonicalPropKey, attrValue);\n@@ -1424,2 +1260,3 @@\n-                \/\/ Notify a change.\n-                notifyChanges();\n+                return true;\n+            });\n+        }\n@@ -1427,1 +1264,8 @@\n-                return opResult;\n+        boolean removeLegacy(ServiceKey key, String className) {\n+            assert key != null && className != null :\n+                    \"Service information missing.\";\n+            MappingInfo mi = find(key);\n+            if (mi.svc != null) {\n+                assert className.equals(mi.svc.getClassName()) :\n+                        \"Unexpected class name.\";\n+                return removeCommon(mi, true, Collections.emptySet());\n@@ -1429,0 +1273,2 @@\n+            assert false : \"Should not reach.\";\n+            return false;\n@@ -1431,18 +1277,2 @@\n-        \/\/ Placeholder for a thread to mark that serviceSet values are being\n-        \/\/ computed after a services update. Only one thread at a time can\n-        \/\/ effectively assign this value.\n-        private static final Set<Service> SERVICE_SET_IN_PROGRESS = Set.of();\n-\n-        \/\/ Unmodifiable set of all services. Possible values for this field\n-        \/\/ are: 1) null (indicates that the set has to be recomputed after a\n-        \/\/ service update), 2) SERVICE_SET_IN_PROGRESS (indicates that a thread\n-        \/\/ is recomputing its value), and 3) an actual set of services.\n-        private final AtomicReference<Set<Service>> serviceSet;\n-\n-        \/\/ Implementation of ServicesMap that handles the Current and Legacy\n-        \/\/ APIs.\n-        private final ServicesMapImpl impl;\n-\n-        ServicesMap() {\n-            impl = new ServicesMapImpl();\n-            serviceSet = new AtomicReference<>();\n+        boolean removeAliasLegacy(ServiceKey key, ServiceKey aliasKey) {\n+            return removeAliasLegacy(key, aliasKey, Collections.emptySet());\n@@ -1452,3 +1282,4 @@\n-         * Constructor to create a thin working copy such that readers of the\n-         * original map do not notice any new changes. Used for atomic\n-         * changes with the Legacy API. See Providers::putAll.\n+         * This method is invoked both when removing and overwriting a service\n+         * alias. The keysToBeKept set is used when overwriting to prevent\n+         * readers from seeing a 'hole' on the services map between removing and\n+         * adding entries.\n@@ -1456,3 +1287,28 @@\n-        ServicesMap(ServicesMap original) {\n-            impl = new ServicesMapImpl(original.impl);\n-            serviceSet = new AtomicReference<>(original.serviceSet.get());\n+        private boolean removeAliasLegacy(ServiceKey key, ServiceKey aliasKey,\n+                Set<ServiceKey> keysToBeKept) {\n+            assert key != null && aliasKey != null && keysToBeKept != null :\n+                    \"Alias information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                MappingInfo miByAlias = find(aliasKey);\n+                if (oldMi.svc != null && miByAlias.svc == oldMi.svc &&\n+                        !miByAlias.algKey.equals(aliasKey)) {\n+                    \/\/ The alias is a real alias and is associated to the\n+                    \/\/ service on the map.\n+                    if (!keysToBeKept.contains(aliasKey)) {\n+                        services.remove(aliasKey);\n+                    }\n+\n+                    newSvc.removeAliasKey(aliasKey);\n+\n+                    \/\/ Update the Properties map to reflect the alias removal.\n+                    \/\/ Note: oldPropKey cannot be null because aliases always\n+                    \/\/ have a corresponding Properties map entry.\n+                    String oldPropKey = serviceProps.remove(aliasKey);\n+                    assert oldPropKey != null : \"Invalid alias property.\";\n+                    Provider.super.remove(oldPropKey);\n+\n+                    return true;\n+                }\n+                assert false : \"Should not reach.\";\n+                return false;\n+            });\n@@ -1461,5 +1317,36 @@\n-        \/*\n-         * Returns a Current API view of the services map.\n-         *\/\n-        Current asCurrent() {\n-            return impl;\n+        boolean removeAttributeLegacy(ServiceKey key, String attrName,\n+                String attrValue) {\n+            assert key != null && attrName != null && attrValue != null :\n+                    \"Attribute information missing.\";\n+            return updateSvc(key, (MappingInfo oldMi, Service newSvc) -> {\n+                Map<UString, String> oldAttrProps =\n+                        serviceAttrProps.get(oldMi.algKey);\n+                if (oldAttrProps != null) {\n+                    \/\/ The service was found and has attributes.\n+                    assert oldMi.svc != null :\n+                            \"Inconsistent service attributes data.\";\n+\n+                    newSvc.removeAttribute(attrName, attrValue);\n+                    assert newSvc.getAttribute(attrName) == null :\n+                            \"Attribute was not removed from the service.\";\n+\n+                    \/\/ Update the Properties map to reflect the attribute\n+                    \/\/ removal. Note: oldPropKey cannot be null because\n+                    \/\/ attributes always have a corresponding Properties map\n+                    \/\/ entry.\n+                    String oldPropKey = oldAttrProps.remove(\n+                            new UString(attrName));\n+                    assert oldPropKey != null : \"Invalid attribute property.\";\n+                    Provider.super.remove(oldPropKey);\n+\n+                    if (oldAttrProps.isEmpty()) {\n+                        \/\/ If the removed attribute was the last one, remove the\n+                        \/\/ map.\n+                        serviceAttrProps.remove(oldMi.algKey);\n+                    }\n+\n+                    return true;\n+                }\n+                assert false : \"Should not reach.\";\n+                return false;\n+            });\n@@ -1468,5 +1355,3 @@\n-        \/*\n-         * Returns a Legacy API view of the services map.\n-         *\/\n-        Legacy asLegacy() {\n-            return impl;\n+        @FunctionalInterface\n+        private interface ServiceUpdateCallback {\n+            boolean apply(MappingInfo oldMi, Service newSvc);\n@@ -1476,5 +1361,9 @@\n-         * Returns an unmodifiable set of available services. Recomputes\n-         * serviceSet if needed, after a service update. Both services added\n-         * with the Current and Legacy APIs are included. If no services are\n-         * found, the returned set is empty. This method is thread-safe and\n-         * lock-free.\n+         * This method tries to find a service on the map (based on an\n+         * algorithm or alias) and pass a copy of it to an update callback\n+         * (copy-on-write). If the service found was added with the Current API,\n+         * no update should be done. If a service was not found, a new instance\n+         * may be created.\n+         *\n+         * The updated version of the service is put on the services map.\n+         * Algorithm and alias based entries pointing to the old version of the\n+         * service are overwritten.\n@@ -1482,18 +1371,9 @@\n-        Set<Service> getServices() {\n-            Set<Service> serviceSetLocal = serviceSet.compareAndExchange(\n-                    null, SERVICE_SET_IN_PROGRESS);\n-            if (serviceSetLocal == null ||\n-                    serviceSetLocal == SERVICE_SET_IN_PROGRESS) {\n-                \/\/ A cached set is not available. Instead of locking, compute\n-                \/\/ the set to be returned and, eventually, make it available\n-                \/\/ for others to use.\n-                Set<Service> newSet = Collections.unmodifiableSet(\n-                        impl.getServices());\n-                if (serviceSetLocal == null) {\n-                    \/\/ We won the race to make the computed set available for\n-                    \/\/ others to use. However, only make it available if it\n-                    \/\/ is still current (in other words, there were no further\n-                    \/\/ changes). If it is not current, the next reader will\n-                    \/\/ do the job.\n-                    serviceSet.compareAndExchange(\n-                            SERVICE_SET_IN_PROGRESS, newSet);\n+        private boolean updateSvc(ServiceKey key,\n+                ServiceUpdateCallback updateCb) {\n+            Service newSvc;\n+            MappingInfo oldMi = find(key);\n+            if (oldMi.svc != null) {\n+                \/\/ Service exists.\n+                if (!oldMi.isLegacy) {\n+                    \/\/ Don't update services added with the Current API.\n+                    return false;\n@@ -1501,1 +1381,9 @@\n-                serviceSetLocal = newSet;\n+                \/\/ Create a copy of the service for a copy-on-write update.\n+                newSvc = new Service(oldMi.svc);\n+            } else {\n+                \/\/ Service does not exist.\n+                newSvc = new Service(Provider.this, key);\n+            }\n+            if (!updateCb.apply(oldMi, newSvc)) {\n+                \/\/ Something went wrong and the update should not be done.\n+                return false;\n@@ -1503,2 +1391,0 @@\n-            return serviceSetLocal;\n-        }\n@@ -1506,8 +1392,3 @@\n-        \/*\n-         * Returns an available service. Both services added with the Current\n-         * and Legacy APIs are considered in the search. Thread-safe and\n-         * lock-free.\n-         *\/\n-        Service getService(ServiceKey key) {\n-            return impl.getService(key);\n-        }\n+            \/\/ The service (or its updated version) will be registered to its\n+            \/\/ provider's ServicesMap.\n+            newSvc.registered = true;\n@@ -1515,7 +1396,19 @@\n-        \/*\n-         * Clears the internal ServicesMap state. The caller must synchronize\n-         * changes with the Properties map.\n-         *\/\n-        void clear() {\n-            impl.clear();\n-            serviceSet.set(null);\n+            \/\/ Register the updated version of the service under its algorithm\n+            \/\/ and aliases on the map. This may overwrite entries or add new\n+            \/\/ ones. The previous callback should have handled the removal of an\n+            \/\/ alias.\n+            for (ServiceKey aliasKey : newSvc.aliasKeys.keySet()) {\n+                services.put(aliasKey, newSvc);\n+            }\n+\n+            assert oldMi.algKey.type.equals(newSvc.getType()) &&\n+                    oldMi.algKey.originalAlgorithm.equals(\n+                            newSvc.getAlgorithm()) : \"Invalid key.\";\n+            services.put(oldMi.algKey, newSvc);\n+\n+            legacySvcKeys.add(oldMi.algKey);\n+\n+            \/\/ Notify a change.\n+            notifyChanges();\n+\n+            return true;\n@@ -1839,4 +1732,3 @@\n-                case ADD -> servicesMap.asLegacy()\n-                        .putAlias(svcKey, aliasKey, propKey);\n-                case REMOVE -> servicesMap.asLegacy()\n-                        .removeAlias(svcKey, aliasKey);\n+                case ADD -> servicesMap.putAliasLegacy(svcKey, aliasKey,\n+                        propKey);\n+                case REMOVE -> servicesMap.removeAliasLegacy(svcKey, aliasKey);\n@@ -1857,4 +1749,3 @@\n-                    case ADD -> servicesMap.asLegacy()\n-                            .putClassName(svcKey, propValue, propKey);\n-                    case REMOVE -> servicesMap.asLegacy()\n-                            .remove(svcKey, propValue);\n+                    case ADD -> servicesMap.putClassNameLegacy(svcKey, propValue,\n+                            propKey);\n+                    case REMOVE -> servicesMap.removeLegacy(svcKey, propValue);\n@@ -1875,4 +1766,4 @@\n-                    case ADD -> servicesMap.asLegacy()\n-                            .putAttribute(svcKey, attrName, propValue, propKey);\n-                    case REMOVE -> servicesMap.asLegacy()\n-                            .removeAttribute(svcKey, attrName, propValue);\n+                    case ADD -> servicesMap.putAttributeLegacy(svcKey, attrName,\n+                            propValue, propKey);\n+                    case REMOVE -> servicesMap.removeAttributeLegacy(svcKey,\n+                            attrName, propValue);\n@@ -1973,1 +1864,1 @@\n-        servicesMap.asCurrent().putService(s);\n+        servicesMap.putService(s);\n@@ -2026,1 +1917,1 @@\n-        servicesMap.asCurrent().removeService(s);\n+        servicesMap.removeService(s);\n@@ -2361,1 +2252,1 @@\n-         * ServicesMapImpl::putService. Legacy API methods do not need to call:\n+         * ServicesMap::putService. Legacy API methods do not need to call:\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":614,"deletions":723,"binary":false,"changes":1337,"status":"modified"}]}