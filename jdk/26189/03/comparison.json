{"files":[{"patch":"@@ -1735,0 +1735,60 @@\n+bool G1CollectedHeap::wait_full_mark_finished(GCCause::Cause cause,\n+                                              uint old_marking_started_before,\n+                                              uint old_marking_started_after,\n+                                              uint old_marking_completed_after) {\n+  \/\/ Request is finished if a full collection (concurrent or stw)\n+  \/\/ was started after this request and has completed, e.g.\n+  \/\/ started_before < completed_after.\n+  if (gc_counter_less_than(old_marking_started_before,\n+                           old_marking_completed_after)) {\n+    LOG_COLLECT_CONCURRENTLY_COMPLETE(cause, true);\n+    return true;\n+  }\n+\n+  if (old_marking_started_after != old_marking_completed_after) {\n+    \/\/ If there is an in-progress cycle (possibly started by us), then\n+    \/\/ wait for that cycle to complete, e.g.\n+    \/\/ while completed_now < started_after.\n+    LOG_COLLECT_CONCURRENTLY(cause, \"wait\");\n+    MonitorLocker ml(G1OldGCCount_lock);\n+    while (gc_counter_less_than(_old_marking_cycles_completed,\n+                                old_marking_started_after)) {\n+      ml.wait();\n+    }\n+    \/\/ Request is finished if the collection we just waited for was\n+    \/\/ started after this request.\n+    if (old_marking_started_before != old_marking_started_after) {\n+      LOG_COLLECT_CONCURRENTLY(cause, \"complete after wait\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ After calling wait_full_mark_finished(), this method determines whether we\n+\/\/ previously failed for ordinary reasons (concurrent cycle in progress, whitebox\n+\/\/ has control). Returns if this has been such an ordinary reason.\n+static bool should_retry_vm_op(GCCause::Cause cause,\n+                               VM_G1TryInitiateConcMark* op) {\n+  if (op->cycle_already_in_progress()) {\n+    \/\/ If VMOp failed because a cycle was already in progress, it\n+    \/\/ is now complete.  But it didn't finish this user-requested\n+    \/\/ GC, so try again.\n+    LOG_COLLECT_CONCURRENTLY(cause, \"retry after in-progress\");\n+    return true;\n+  } else if (op->whitebox_attached()) {\n+    \/\/ If WhiteBox wants control, wait for notification of a state\n+    \/\/ change in the controller, then try again.  Don't wait for\n+    \/\/ release of control, since collections may complete while in\n+    \/\/ control.  Note: This won't recognize a STW full collection\n+    \/\/ while waiting; we can't wait on multiple monitors.\n+    LOG_COLLECT_CONCURRENTLY(cause, \"whitebox control stall\");\n+    MonitorLocker ml(ConcurrentGCBreakpoints::monitor());\n+    if (ConcurrentGCBreakpoints::is_controlled()) {\n+      ml.wait();\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -1795,0 +1855,34 @@\n+    } else if (GCCause::is_codecache_requested_gc(cause)) {\n+      \/\/ For a CodeCache requested GC, before marking, progress is ensured as the\n+      \/\/ following Remark pause unloads code (and signals the requester such).\n+      \/\/ Otherwise we must ensure that it is restarted.\n+      \/\/\n+      \/\/ For a CodeCache requested GC, a successful GC operation means that\n+      \/\/ (1) marking is in progress. I.e. the VMOp started the marking or a\n+      \/\/     Remark pause is pending from a different VM op; we will potentially\n+      \/\/     abort a mixed phase if needed.\n+      \/\/ (2) a new cycle was started (by this thread or some other), or\n+      \/\/ (3) a Full GC was performed.\n+      \/\/\n+      \/\/ Cases (2) and (3) are detected together by a change to\n+      \/\/ _old_marking_cycles_started.\n+      \/\/\n+      \/\/ Compared to other \"automatic\" GCs (see below), we do not consider being\n+      \/\/ in whitebox as sufficient too because we might be anywhere within that\n+      \/\/ cycle and we need to make progress.\n+      if (op.mark_in_progress() ||\n+          (old_marking_started_before != old_marking_started_after)) {\n+        LOG_COLLECT_CONCURRENTLY_COMPLETE(cause, true);\n+        return true;\n+      }\n+\n+      if (wait_full_mark_finished(cause,\n+                                  old_marking_started_before,\n+                                  old_marking_started_after,\n+                                  old_marking_completed_after)) {\n+        return true;\n+      }\n+\n+      if (should_retry_vm_op(cause, &op)) {\n+        continue;\n+      }\n@@ -1796,0 +1890,5 @@\n+      assert(cause == GCCause::_g1_humongous_allocation ||\n+             cause == GCCause::_g1_periodic_collection ||\n+             cause == GCCause::_wb_breakpoint ||\n+             cause == GCCause::_java_lang_system_gc ||\n+             cause == GCCause::_dcmd_gc_run, \"Unsupported cause %s\", GCCause::to_string(cause));\n@@ -1807,5 +1906,0 @@\n-      \/\/\n-      \/\/ Note that (1) does not imply (4).  If we're still in the mixed\n-      \/\/ phase of an earlier concurrent collection, the request to make the\n-      \/\/ collection a concurrent start won't be honored.  If we don't check for\n-      \/\/ both conditions we'll spin doing back-to-back collections.\n@@ -1835,6 +1929,4 @@\n-      \/\/ Request is finished if a full collection (concurrent or stw)\n-      \/\/ was started after this request and has completed, e.g.\n-      \/\/ started_before < completed_after.\n-      if (gc_counter_less_than(old_marking_started_before,\n-                               old_marking_completed_after)) {\n-        LOG_COLLECT_CONCURRENTLY_COMPLETE(cause, true);\n+      if (wait_full_mark_finished(cause,\n+                                  old_marking_started_before,\n+                                  old_marking_started_after,\n+                                  old_marking_completed_after)) {\n@@ -1844,18 +1936,0 @@\n-      if (old_marking_started_after != old_marking_completed_after) {\n-        \/\/ If there is an in-progress cycle (possibly started by us), then\n-        \/\/ wait for that cycle to complete, e.g.\n-        \/\/ while completed_now < started_after.\n-        LOG_COLLECT_CONCURRENTLY(cause, \"wait\");\n-        MonitorLocker ml(G1OldGCCount_lock);\n-        while (gc_counter_less_than(_old_marking_cycles_completed,\n-                                    old_marking_started_after)) {\n-          ml.wait();\n-        }\n-        \/\/ Request is finished if the collection we just waited for was\n-        \/\/ started after this request.\n-        if (old_marking_started_before != old_marking_started_after) {\n-          LOG_COLLECT_CONCURRENTLY(cause, \"complete after wait\");\n-          return true;\n-        }\n-      }\n-\n@@ -1868,17 +1942,1 @@\n-      if (op.cycle_already_in_progress()) {\n-        \/\/ If VMOp failed because a cycle was already in progress, it\n-        \/\/ is now complete.  But it didn't finish this user-requested\n-        \/\/ GC, so try again.\n-        LOG_COLLECT_CONCURRENTLY(cause, \"retry after in-progress\");\n-        continue;\n-      } else if (op.whitebox_attached()) {\n-        \/\/ If WhiteBox wants control, wait for notification of a state\n-        \/\/ change in the controller, then try again.  Don't wait for\n-        \/\/ release of control, since collections may complete while in\n-        \/\/ control.  Note: This won't recognize a STW full collection\n-        \/\/ while waiting; we can't wait on multiple monitors.\n-        LOG_COLLECT_CONCURRENTLY(cause, \"whitebox control stall\");\n-        MonitorLocker ml(ConcurrentGCBreakpoints::monitor());\n-        if (ConcurrentGCBreakpoints::is_controlled()) {\n-          ml.wait();\n-        }\n+      if (should_retry_vm_op(cause, &op)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":104,"deletions":46,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -277,0 +277,8 @@\n+  \/\/ Wait until a full mark (either currently in progress or one that completed\n+  \/\/ after the current request) has finished. Returns whether that full mark started\n+  \/\/ after this request. If so, we typically do not need another one.\n+  bool wait_full_mark_finished(GCCause::Cause cause,\n+                               uint old_marking_started_before,\n+                               uint old_marking_started_after,\n+                               uint old_marking_completed_after);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+  \/\/ Marking is in progress. Set from start of the concurrent start pause to the\n+  \/\/ end of the Remark pause.\n+  bool _mark_in_progress;\n@@ -81,0 +84,1 @@\n+    _mark_in_progress(false),\n@@ -95,0 +99,1 @@\n+  void set_mark_in_progress(bool v) { _mark_in_progress = v; }\n@@ -109,0 +114,1 @@\n+  bool mark_in_progress() const { return _mark_in_progress; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectorState.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -594,0 +594,1 @@\n+  collector_state()->set_mark_in_progress(false);\n@@ -706,0 +707,1 @@\n+  collector_state()->set_mark_in_progress(false);\n@@ -939,0 +941,1 @@\n+    collector_state()->set_mark_in_progress(concurrent_operation_is_full_mark);\n@@ -1225,0 +1228,11 @@\n+static const char* requester_for_mixed_abort(GCCause::Cause cause) {\n+  if (cause == GCCause::_wb_breakpoint) {\n+    return \"run_to breakpoint\";\n+  } else if (GCCause::is_codecache_requested_gc(cause)) {\n+    return \"codecache\";\n+  } else {\n+    assert(G1CollectedHeap::heap()->is_user_requested_concurrent_full_gc(cause), \"must be\");\n+    return \"user\";\n+  }\n+}\n+\n@@ -1257,2 +1271,1 @@\n-               (cause == GCCause::_codecache_GC_threshold) ||\n-               (cause == GCCause::_codecache_GC_aggressive) ||\n+               GCCause::is_codecache_requested_gc(cause) ||\n@@ -1273,1 +1286,1 @@\n-                          (cause == GCCause::_wb_breakpoint) ? \"run_to breakpoint\" : \"user\");\n+                          requester_for_mixed_abort(cause));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  _mark_in_progress(false),\n@@ -86,0 +87,3 @@\n+  _mark_in_progress = g1h->collector_state()->mark_in_progress();\n+  _cycle_already_in_progress = g1h->concurrent_mark()->cm_thread()->in_progress();\n+\n@@ -94,3 +98,2 @@\n-    \/\/ there is already a concurrent marking cycle in progress.  Set flag\n-    \/\/ to notify the caller and return immediately.\n-    _cycle_already_in_progress = true;\n+    \/\/ there is already a concurrent marking cycle in progress. Flags to indicate\n+    \/\/ that were already set, so return immediately.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  bool _mark_in_progress;\n@@ -62,0 +63,1 @@\n+  bool mark_in_progress() const { return _mark_in_progress; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,5 @@\n+  inline static bool is_codecache_requested_gc(GCCause::Cause cause) {\n+      return (cause == _codecache_GC_threshold  ||\n+              cause == _codecache_GC_aggressive);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestCodeCacheUnloadDuringConcCycle\n+ * @bug 8350621\n+ * @summary Test to make sure that code cache unloading does not hang when receiving\n+ * a request to unload code cache during concurrent mark.\n+ * We do that by triggering a code cache gc request (by triggering compilations)\n+ * during concurrent mark, and verify that after the concurrent cycle additional code\n+ * cache gc requests start more concurrent cycles.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib \/testlibrary \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xmx20M -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. gc.g1.TestCodeCacheUnloadDuringConcCycle\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryUsage;\n+import java.lang.reflect.Field;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestCodeCacheUnloadDuringConcCycle {\n+    public static final String AFTER_FIRST_CYCLE_MARKER = \"Marker for this test\";\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static OutputAnalyzer runTest(String concPhase) throws Exception {\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx20M\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xlog:gc=trace,codecache\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    \"-XX:ReservedCodeCacheSize=8M\",\n+                                                                    \"-XX:StartAggressiveSweepingAt=50\",\n+                                                                    \"-XX:CompileCommand=compileonly,gc.g1.SomeClass::*\",\n+                                                                    TestCodeCacheUnloadDuringConcCycleRunner.class.getName(),\n+                                                                    concPhase);\n+        return output;\n+    }\n+\n+    private static void runAndCheckTest(String test) throws Exception {\n+        OutputAnalyzer output;\n+\n+        output = runTest(test);\n+        output.shouldHaveExitValue(0);\n+        System.out.println(output.getStdout());\n+\n+        String[] parts = output.getStdout().split(AFTER_FIRST_CYCLE_MARKER);\n+\n+        \/\/ Either \"Threshold\" or \"Aggressive\" CodeCache GC are fine for the test.\n+        final String codecacheGCStart = \"Pause Young (Concurrent Start) (CodeCache GC \";\n+\n+        boolean success = parts.length == 2 && parts[1].indexOf(codecacheGCStart) != -1;\n+        Asserts.assertTrue(success, \"Could not find a CodeCache GC Threshold GC after finishing the concurrent cycle\");\n+    }\n+\n+    private static void allTests() throws Exception {\n+        runAndCheckTest(WB.BEFORE_MARKING_COMPLETED);\n+        runAndCheckTest(WB.G1_BEFORE_REBUILD_COMPLETED);\n+        runAndCheckTest(WB.G1_BEFORE_CLEANUP_COMPLETED);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        allTests();\n+    }\n+}\n+\n+class TestCodeCacheUnloadDuringConcCycleRunner {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static void refClass(Class clazz) throws Exception {\n+        Field name = clazz.getDeclaredField(\"NAME\");\n+        name.setAccessible(true);\n+        name.get(null);\n+    }\n+\n+    private static class MyClassLoader extends URLClassLoader {\n+        public MyClassLoader(URL url) {\n+            super(new URL[]{url}, null);\n+        }\n+        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            try {\n+                return super.loadClass(name, resolve);\n+            } catch (ClassNotFoundException e) {\n+                return Class.forName(name, resolve, TestCodeCacheUnloadDuringConcCycleRunner.class.getClassLoader());\n+            }\n+        }\n+    }\n+\n+    private static void triggerCodeCacheGC() throws Exception {\n+        URL url = TestCodeCacheUnloadDuringConcCycleRunner.class.getProtectionDomain().getCodeSource().getLocation();\n+\n+        try {\n+            int i = 0;\n+            do {\n+                ClassLoader cl = new MyClassLoader(url);\n+                refClass(cl.loadClass(\"gc.g1.SomeClass\"));\n+\n+                if (i % 20 == 0) {\n+                    System.out.println(\"Compiled \" + i + \" classes\");\n+                }\n+                i++;\n+            } while (i < 200);\n+            System.out.println(\"Compilation done, compiled \" + i + \" classes\");\n+        } catch (Throwable t) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            WB.concurrentGCAcquireControl();\n+            WB.concurrentGCRunTo(args[0]);\n+\n+            System.out.println(\"Try to trigger code cache GC\");\n+\n+            triggerCodeCacheGC();\n+\n+            WB.concurrentGCRunToIdle();\n+        } finally {\n+            WB.concurrentGCReleaseControl();\n+        }\n+        System.out.println(TestCodeCacheUnloadDuringConcCycle.AFTER_FIRST_CYCLE_MARKER);\n+        Thread.sleep(1000);\n+        triggerCodeCacheGC();\n+    }\n+}\n+\n+abstract class Foo {\n+    public abstract int foo();\n+}\n+\n+class Foo1 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo2 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo3 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo4 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class SomeClass {\n+    static final String NAME = \"name\";\n+\n+    static {\n+        int res =0;\n+        Foo[] foos = new Foo[] { new Foo1(), new Foo2(), new Foo3(), new Foo4() };\n+        for (int i = 0; i < 100000; i++) {\n+            res = foos[i % foos.length].foo();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}