{"files":[{"patch":"@@ -1755,1 +1755,3 @@\n-    } else if (!GCCause::is_user_requested_gc(cause)) {\n+    } else if (!GCCause::is_user_requested_gc(cause) &&\n+               \/\/ We can only skip CodeCache requested GCs if we are before marking.\n+               (!GCCause::is_codecache_requested_gc(cause) || op.marking_in_progress()) ) {\n@@ -1761,1 +1763,2 @@\n-      \/\/ (2) a concurrent cycle was already in progress,\n+      \/\/ (2) a concurrent cycle was already in progress and we were\n+      \/\/     before the Remark pause for CodeCache requested GCs,\n@@ -1772,0 +1775,4 @@\n+      bool concurrent_cycle_ensures_progress = (GCCause::is_codecache_requested_gc(cause)\n+                                             ? op.marking_in_progress()\n+                                             : op.cycle_already_in_progress());\n+\n@@ -1773,1 +1780,1 @@\n-          op.cycle_already_in_progress() ||\n+          concurrent_cycle_ensures_progress ||\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+  \/\/ Marking is in progress. Set from start of the concurrent start pause to the\n+  \/\/ end of the Remark pause.\n+  bool _mark_in_progress;\n@@ -81,0 +84,1 @@\n+    _mark_in_progress(false),\n@@ -95,0 +99,1 @@\n+  void set_mark_in_progress(bool v) { _mark_in_progress = v; }\n@@ -109,0 +114,1 @@\n+  bool mark_in_progress() const { return _mark_in_progress; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectorState.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -596,0 +596,1 @@\n+  collector_state()->set_mark_in_progress(false);\n@@ -707,0 +708,1 @@\n+  collector_state()->set_mark_in_progress(false);\n@@ -944,0 +946,1 @@\n+    collector_state()->set_mark_in_progress(concurrent_operation_is_full_mark);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  _marking_in_progress(false),\n@@ -94,1 +95,1 @@\n-    \/\/ there is already a concurrent marking cycle in progress.  Set flag\n+    \/\/ there is already a concurrent marking cycle in progress.  Set flags\n@@ -96,0 +97,1 @@\n+    _marking_in_progress = g1h->collector_state()->mark_in_progress();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  bool _marking_in_progress;\n@@ -62,0 +63,1 @@\n+  bool marking_in_progress() const { return _marking_in_progress; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,5 @@\n+  inline static bool is_codecache_requested_gc(GCCause::Cause cause) {\n+      return (cause == _codecache_GC_threshold  ||\n+              cause == _codecache_GC_aggressive);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestCodeCacheUnloadDuringConcCycle\n+ * @bug 8350621\n+ * @summary Test to make sure that code cache unloading does not hang when receiving\n+ * a request to unload code cache during concurrent mark.\n+ * We do that by triggering a code cache gc request (by triggering compilations)\n+ * during concurrent mark, and verify that after the concurrent cycle additional code\n+ * cache gc requests start more concurrent cycles.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib \/testlibrary \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xmx20M -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. gc.g1.TestCodeCacheUnloadDuringConcCycle\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryUsage;\n+import java.lang.reflect.Field;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestCodeCacheUnloadDuringConcCycle {\n+    public static final String AFTER_FIRST_CYCLE_MARKER = \"Marker for this test\";\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static OutputAnalyzer runTest(String concPhase) throws Exception {\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx20M\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xlog:gc=trace,codecache\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    \"-XX:ReservedCodeCacheSize=8M\",\n+                                                                    \"-XX:StartAggressiveSweepingAt=50\",\n+                                                                    \"-XX:CompileCommand=compileonly,gc.g1.SomeClass::*\",\n+                                                                    TestCodeCacheUnloadDuringConcCycleRunner.class.getName(),\n+                                                                    concPhase);\n+        return output;\n+    }\n+\n+    private static void runAndCheckTest(String test) throws Exception {\n+        OutputAnalyzer output;\n+\n+        output = runTest(test);\n+        output.shouldHaveExitValue(0);\n+        System.out.println(output.getStdout());\n+\n+        String[] parts = output.getStdout().split(AFTER_FIRST_CYCLE_MARKER);\n+\n+        final String codecacheGCStart = \"Pause Young (Concurrent Start) (CodeCache GC Threshold)\";\n+\n+        boolean success = parts.length == 2 && parts[1].indexOf(codecacheGCStart) != -1;\n+        Asserts.assertTrue(success, \"Could not find a CodeCache GC Threshold GC after finishing the concurrent cycle\");\n+    }\n+\n+    private static void allTests() throws Exception {\n+        runAndCheckTest(WB.BEFORE_MARKING_COMPLETED);\n+        runAndCheckTest(WB.G1_BEFORE_REBUILD_COMPLETED);\n+        runAndCheckTest(WB.G1_BEFORE_CLEANUP_COMPLETED);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        allTests();\n+    }\n+}\n+\n+class TestCodeCacheUnloadDuringConcCycleRunner {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static void refClass(Class clazz) throws Exception {\n+        Field name = clazz.getDeclaredField(\"NAME\");\n+        name.setAccessible(true);\n+        name.get(null);\n+    }\n+\n+    private static class MyClassLoader extends URLClassLoader {\n+        public MyClassLoader(URL url) {\n+            super(new URL[]{url}, null);\n+        }\n+        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            try {\n+                return super.loadClass(name, resolve);\n+            } catch (ClassNotFoundException e) {\n+                return Class.forName(name, resolve, TestCodeCacheUnloadDuringConcCycleRunner.class.getClassLoader());\n+            }\n+        }\n+    }\n+\n+    private static void triggerCodeCacheGC() throws Exception {\n+        URL url = TestCodeCacheUnloadDuringConcCycleRunner.class.getProtectionDomain().getCodeSource().getLocation();\n+\n+        try {\n+            int i = 0;\n+            do {\n+                ClassLoader cl = new MyClassLoader(url);\n+                refClass(cl.loadClass(\"gc.g1.SomeClass\"));\n+\n+                if (i % 20 == 0) {\n+                    System.out.println(\"Compiled \" + i + \" classes\");\n+                }\n+                i++;\n+            } while (i < 200);\n+            System.out.println(\"Compilation done, compiled \" + i + \" classes\");\n+        } catch (Throwable t) {\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            WB.concurrentGCAcquireControl();\n+            WB.concurrentGCRunTo(args[0]);\n+\n+            System.out.println(\"Try to trigger code cache GC\");\n+\n+            triggerCodeCacheGC();\n+\n+            WB.concurrentGCRunToIdle();\n+        } finally {\n+            WB.concurrentGCReleaseControl();\n+        }\n+        System.out.println(TestCodeCacheUnloadDuringConcCycle.AFTER_FIRST_CYCLE_MARKER);\n+        Thread.sleep(1000);\n+        triggerCodeCacheGC();\n+    }\n+}\n+\n+abstract class Foo {\n+    public abstract int foo();\n+}\n+\n+class Foo1 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo2 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo3 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class Foo4 extends Foo {\n+    private int a;\n+    public int foo() { return a; }\n+}\n+\n+class SomeClass {\n+    static final String NAME = \"name\";\n+\n+    static {\n+        int res =0;\n+        Foo[] foos = new Foo[] { new Foo1(), new Foo2(), new Foo3(), new Foo4() };\n+        for (int i = 0; i < 100000; i++) {\n+            res = foos[i % foos.length].foo();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}