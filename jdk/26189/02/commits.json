[{"commit":{"message":"* more refactoring, comments"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp"}],"sha":"b3a9fea6a07ba8601980523b91d4594fc80c9202"},{"commit":{"message":"* kbarrett review part 2 (slightly incomplete)"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp"}],"sha":"fdf0a1483d254d0bc0ebbc63bb1c16fb01b5c84e"},{"commit":{"message":"* kbarrett review - 1"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"}],"sha":"d108975900b2e574b07c2de7c2179e8d95f2bf87"},{"commit":{"message":"* initial kbarrett refactoring"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"}],"sha":"bd763a2c47ea33931867691540d45b18b0984aa1"},{"commit":{"message":"* kbarret review:\n  - restructure code in `try_collect_concurrently`\n  - fix asserts - they only worked in the test because of whitebox being active\n  - fix comments\n* threalmdoerr review:\n  - fix test to be more lenient"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java"}],"sha":"36b023fb66d3223c1affccc2bda42c9334f8b99c"},{"commit":{"message":"* some whitespace fixes"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java"}],"sha":"348a7896ac2f32040a6af27bb41dd889212489d5"},{"commit":{"message":"8350621\n\nHi all,\n\n  please review this change to avoid CodeCache triggered GCs temporarily being ignored.\n\nIn particular, G1 does not make sure when its `collect()` method is called during a\nconcurrent cycle, that a `Remark` pause that does code unloading etc. actually occurs\nafter that request. This makes it so that some internal flag is not reset appropriately,\nstuck until the next code unloading (caused by e.g. a regular concurrent cycle being\ntriggered).\n\nTesting: tier1-5\n\nThanks,\n  Thomas"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectorState.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp"},{"filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp"},{"filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java"}],"sha":"9240022802ea8505a581ad422ec4eaff5efb7204"}]