{"files":[{"patch":"@@ -1755,5 +1755,9 @@\n-    } else if (!GCCause::is_user_requested_gc(cause) &&\n-               \/\/ We can only skip CodeCache requested GCs if we are before marking.\n-               (!GCCause::is_codecache_requested_gc(cause) || op.marking_in_progress()) ) {\n-      \/\/ For an \"automatic\" (not user-requested) collection, we just need to\n-      \/\/ ensure that progress is made.\n+    } else if (GCCause::is_codecache_requested_gc(cause) && op.marking_in_progress()) {\n+        \/\/ For a CodeCache requested GC, before marking, progress is ensured as the\n+        \/\/ following Remark pause unloads code (and signals the requestr such).\n+        \/\/ Otherwise we must ensure that it is restarted later further below.\n+        LOG_COLLECT_CONCURRENTLY_COMPLETE(cause, true);\n+        return true;\n+    } else if (!GCCause::is_user_requested_gc(cause) && !GCCause::is_codecache_requested_gc(cause)) {\n+      \/\/ For an \"automatic\" (not user-requested, non-codecache related) collection,\n+      \/\/ we just need to ensure that progress is made.\n@@ -1775,4 +1779,0 @@\n-      bool concurrent_cycle_ensures_progress = (GCCause::is_codecache_requested_gc(cause)\n-                                             ? op.marking_in_progress()\n-                                             : op.cycle_already_in_progress());\n-\n@@ -1780,1 +1780,1 @@\n-          concurrent_cycle_ensures_progress ||\n+          op.cycle_already_in_progress() ||\n@@ -1786,8 +1786,15 @@\n-    } else {                    \/\/ User-requested GC.\n-      \/\/ For a user-requested collection, we want to ensure that a complete\n-      \/\/ full collection has been performed before returning, but without\n-      \/\/ waiting for more than needed.\n-\n-      \/\/ For user-requested GCs (unlike non-UR), a successful VMOp implies a\n-      \/\/ new cycle was started.  That's good, because it's not clear what we\n-      \/\/ should do otherwise.  Trying again just does back to back GCs.\n+    } else {\n+      \/\/ GC request that needs to ensure that a complete full collection has been\n+      \/\/ performed before returning, but without waiting for more than needed.\n+      \/\/\n+      \/\/ This may either be a user-requested GC (e.g. System.gc()) or a CodeCache\n+      \/\/ requested collection where we already passed code unloading during a\n+      \/\/ concurrent cycle.\n+      \/\/\n+      \/\/ For these GCs a distinction needs to be made:\n+      \/\/ - CodeCache related GCs \"successfully\" triggered a GC,\n+      \/\/ - for other GCs (unlike non-UR), a successful VMOp implies a\n+      \/\/   new cycle was started. That's good, because it's not clear what we\n+      \/\/   should do otherwise.\n+      \/\/\n+      \/\/ In both cases, immediately trying again just does back to back GCs.\n@@ -1796,1 +1803,4 @@\n-      assert(!op.gc_succeeded() ||\n+      bool is_codecache_gc = GCCause::is_codecache_requested_gc(cause);\n+\n+      assert(is_codecache_gc ||\n+             !op.gc_succeeded() ||\n@@ -1798,1 +1808,2 @@\n-             \"invariant: succeeded %s, started before %u, started after %u\",\n+             \"invariant: codecache gc: %s succeeded %s, started before %u, started after %u\",\n+             BOOL_TO_STR(is_codecache_gc),\n@@ -1833,1 +1844,1 @@\n-      assert(!op.gc_succeeded(), \"invariant\");\n+      assert(!op.gc_succeeded() || is_codecache_gc, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-        final String codecacheGCStart = \"Pause Young (Concurrent Start) (CodeCache GC Threshold)\";\n+        \/\/ Either \"Threshold\" or \"Aggressive\" CodeCache GC are fine for the test.\n+        final String codecacheGCStart = \"Pause Young (Concurrent Start) (CodeCache GC \";\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}