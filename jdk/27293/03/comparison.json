{"files":[{"patch":"@@ -234,1 +234,0 @@\n-  DEBUG_ONLY(volatile u8 _out_of_stack_walking_iterations;)\n@@ -285,4 +284,0 @@\n-\n-  u8 out_of_stack_walking_iterations() const {\n-    return AtomicAccess::load(&_out_of_stack_walking_iterations);\n-  }\n@@ -396,1 +391,0 @@\n-        DEBUG_ONLY(AtomicAccess::inc(&_out_of_stack_walking_iterations);)\n@@ -595,7 +589,0 @@\n-\n-u8 JfrCPUTimeThreadSampling::out_of_stack_walking_iterations() {\n-  if (_instance != nullptr && _instance->_sampler != nullptr) {\n-    return _instance->_sampler->out_of_stack_walking_iterations();\n-  }\n-  return 0;\n-}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -143,2 +143,0 @@\n-\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n@@ -166,1 +164,0 @@\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2664,1 +2664,1 @@\n-WB_ENTRY(void, WB_BusyWait(JNIEnv* env, jobject wb, jint time))\n+WB_ENTRY(void, WB_BusyWaitCPUTime(JNIEnv* env, jobject wb, jint time))\n@@ -2682,8 +2682,0 @@\n-WB_ENTRY(jlong, WB_CPUSamplerOutOfStackWalkingIterations(JNIEnv* env, jobject wb))\n-  #if defined(ASSERT) && INCLUDE_JFR && defined(LINUX)\n-    return (jlong)JfrCPUTimeThreadSampling::out_of_stack_walking_iterations();\n-  #else\n-    return 0;\n-  #endif\n-WB_END\n-\n@@ -3043,1 +3035,1 @@\n-  {CC\"busyWait\", CC\"(I)V\",                            (void*)&WB_BusyWait},\n+  {CC\"busyWaitCPUTime\", CC\"(I)V\",                     (void*)&WB_BusyWaitCPUTime},\n@@ -3045,1 +3037,0 @@\n-  {CC\"cpuSamplerOutOfStackWalkingIterations\", CC\"()J\",(void*)&WB_CPUSamplerOutOfStackWalkingIterations},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.time.Instant;\n@@ -44,0 +45,7 @@\n+ *\n+ * The test starts CPU time sampling with a short interval (1ms), disabling\n+ * out-of-stack sample processing for the duration of the test.\n+ * It now runs in native for one second, to cause queue overflows,\n+ * then it comes back into Java to trigger the queue walking.\n+ * Repeats the cycle 5 times and verifies that the loss decreases significantly from the first\n+ * to the last iteration.\n@@ -57,4 +65,0 @@\n-    private static final String BURST_THREAD_NAME = \"Burst-Thread-1\";\n-\n-    static volatile boolean alive = true;\n-\n@@ -66,0 +70,1 @@\n+        private final List<Long> timeBoxEnds = new ArrayList<>();\n@@ -67,1 +72,1 @@\n-        public synchronized void addEvent(LossEvent event) {\n+        public void addEvent(LossEvent event) {\n@@ -71,1 +76,1 @@\n-        public synchronized List<LossEvent> getSortedEvents() {\n+        public List<LossEvent> getSortedEvents() {\n@@ -77,1 +82,1 @@\n-        public List<LossEvent> getEventsPerInterval(long widthMillis, long stopTimeMillis) {\n+        public List<LossEvent> getEventsPerTimeBox() {\n@@ -79,2 +84,2 @@\n-            for (long start = 0; start < stopTimeMillis; start += widthMillis) {\n-                long actualStart = Math.min(start, stopTimeMillis - widthMillis);\n+            AtomicLong previousEnd = new AtomicLong(0);\n+            for (Long timeBoxEnd : timeBoxEnds) {\n@@ -82,1 +87,1 @@\n-                                          .filter(e -> e.relativeTimeMillis >= actualStart && e.relativeTimeMillis < actualStart + widthMillis)\n+                                          .filter(e -> e.relativeTimeMillis >= previousEnd.get() && e.relativeTimeMillis < timeBoxEnd)\n@@ -85,1 +90,2 @@\n-                ret.add(new LossEvent(actualStart, lostSamples));\n+                ret.add(new LossEvent(previousEnd.get(), lostSamples));\n+                previousEnd.set(timeBoxEnd);\n@@ -90,0 +96,3 @@\n+        public void addTimeBoxEnd(long timeBoxEnd) {\n+            timeBoxEnds.add(timeBoxEnd);\n+        }\n@@ -95,2 +104,2 @@\n-            AtomicLong firstSampleTimeMillis = new AtomicLong(0);\n-            AtomicLong lastSampleTimeMillis = new AtomicLong(0);\n+            long burstThreadId = Thread.currentThread().threadId();\n+            final long startTimeMillis = Instant.now().toEpochMilli();\n@@ -99,8 +108,0 @@\n-            rs.onEvent(EventNames.CPUTimeSample, e -> {\n-                if (firstSampleTimeMillis.get() == 0 && e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    firstSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    lastSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-            });\n@@ -109,1 +110,1 @@\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n@@ -111,2 +112,2 @@\n-                    long relativeTime = firstSampleTimeMillis.get() > 0 ? (eventTime - firstSampleTimeMillis.get()) : eventTime;\n-                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime);\n+                    long relativeTime = eventTime - startTimeMillis;\n+                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime + \" start time \" + startTimeMillis);\n@@ -116,1 +117,3 @@\n-            WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n+            \/\/ we disable the out-of-stack walking so that the queue fills up and overflows\n+            \/\/ while we are in native code\n+            disableOutOfStackWalking();\n@@ -118,5 +121,2 @@\n-            \/\/ this thread runs all along\n-            Thread burstThread = new Thread(() -> WHITE_BOX.busyWait(11000));\n-            burstThread.setName(BURST_THREAD_NAME);\n-            burstThread.start();\n-            \/\/ now we toggle out-of-stack-walking off, wait 1 second and then turn it on for 500ms a few times\n+\n+\n@@ -124,13 +124,6 @@\n-                boolean supported = WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n-                if (!supported) {\n-                    System.out.println(\"Out-of-stack-walking not supported, skipping test\");\n-                    Asserts.assertFalse(true);\n-                    return;\n-                }\n-                Thread.sleep(700);\n-                long iterations = WHITE_BOX.cpuSamplerOutOfStackWalkingIterations();\n-                WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n-                Thread.sleep(300);\n-                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations) {\n-                    Thread.sleep(50); \/\/ just to make sure the stack walking really ran\n-                }\n+                \/\/ run in native for one second\n+                WHITE_BOX.busyWaitCPUTime(1000);\n+                \/\/ going out-of-native at the end of the previous call should have triggered\n+                \/\/ the safepoint handler, thereby also triggering the stack walking and creation\n+                \/\/ of the loss event\n+                lossEvents.addTimeBoxEnd(Instant.now().toEpochMilli() - startTimeMillis);\n@@ -138,0 +131,1 @@\n+\n@@ -139,1 +133,4 @@\n-            checkThatLossDecreased(lossEvents, lastSampleTimeMillis.get() - firstSampleTimeMillis.get());\n+\n+            enableOutOfStackWalking();\n+\n+            checkThatLossDecreased(lossEvents);\n@@ -143,4 +140,12 @@\n-    static void checkThatLossDecreased(LossEventCollection lossEvents, long lastSampleTimeMillis) {\n-        List<LossEvent> intervalLosses = lossEvents.getEventsPerInterval(1000, lastSampleTimeMillis);\n-        for (LossEvent interval : intervalLosses) {\n-            System.out.println(\"Lost samples in interval \" + interval.relativeTimeMillis + \": \" + interval.lostSamples);\n+    static void disableOutOfStackWalking() {\n+        Asserts.assertTrue(WHITE_BOX.cpuSamplerSetOutOfStackWalking(false), \"Out-of-stack-walking not supported\");\n+    }\n+\n+    static void enableOutOfStackWalking() {\n+        WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n+    }\n+\n+    static void checkThatLossDecreased(LossEventCollection lossEvents) {\n+        List<LossEvent> timeBoxedLosses = lossEvents.getEventsPerTimeBox();\n+        for (LossEvent timeBoxedLoss : timeBoxedLosses) {\n+            System.out.println(\"Lost samples in time box \" + timeBoxedLoss.relativeTimeMillis + \": \" + timeBoxedLoss.lostSamples);\n@@ -148,5 +153,3 @@\n-        \/\/ check that there are at least 3 intervals\n-        Asserts.assertTrue(intervalLosses.size() > 2);\n-        \/\/ check that the second to last interval has far fewer lost samples than the first\n-        Asserts.assertTrue(intervalLosses.get(intervalLosses.size() - 2).lostSamples <\n-                           intervalLosses.get(0).lostSamples \/ 2);\n+        \/\/ check that the last time box has far fewer lost samples than the first\n+        Asserts.assertTrue(timeBoxedLosses.get(timeBoxedLosses.size() - 1).lostSamples <\n+                           timeBoxedLosses.get(0).lostSamples \/ 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":56,"deletions":53,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -844,1 +844,2 @@\n-  public native void busyWait(int cpuTimeMs);\n+  public native void busyWaitCPUTime(int cpuTimeMs);\n+\n@@ -849,2 +850,0 @@\n-  public native long cpuSamplerOutOfStackWalkingIterations();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}