{"files":[{"patch":"@@ -2664,1 +2664,1 @@\n-WB_ENTRY(void, WB_BusyWait(JNIEnv* env, jobject wb, jint time))\n+WB_ENTRY(void, WB_BusyWaitCPUTime(JNIEnv* env, jobject wb, jint time))\n@@ -3043,1 +3043,1 @@\n-  {CC\"busyWait\", CC\"(I)V\",                            (void*)&WB_BusyWait},\n+  {CC\"busyWaitCPUTime\", CC\"(I)V\",                     (void*)&WB_BusyWaitCPUTime},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadMXBean;\n@@ -66,0 +68,1 @@\n+        private final List<Long> timeBoxEnds = new ArrayList<>();\n@@ -77,1 +80,1 @@\n-        public List<LossEvent> getEventsPerInterval(long widthMillis, long stopTimeMillis) {\n+        public List<LossEvent> getEventsPerTimeBox() {\n@@ -79,2 +82,2 @@\n-            for (long start = 0; start < stopTimeMillis; start += widthMillis) {\n-                long actualStart = Math.min(start, stopTimeMillis - widthMillis);\n+            AtomicLong previousEnd = new AtomicLong(0);\n+            for (Long timeBoxEnd : timeBoxEnds) {\n@@ -82,1 +85,1 @@\n-                                          .filter(e -> e.relativeTimeMillis >= actualStart && e.relativeTimeMillis < actualStart + widthMillis)\n+                                          .filter(e -> e.relativeTimeMillis >= previousEnd.get() && e.relativeTimeMillis < timeBoxEnd)\n@@ -85,1 +88,2 @@\n-                ret.add(new LossEvent(actualStart, lostSamples));\n+                ret.add(new LossEvent(previousEnd.get(), lostSamples));\n+                previousEnd.set(timeBoxEnd);\n@@ -90,0 +94,3 @@\n+        public synchronized void addTimeBoxEnd(long timeBoxEnd) {\n+            timeBoxEnds.add(timeBoxEnd);\n+        }\n@@ -95,2 +102,2 @@\n-            AtomicLong firstSampleTimeMillis = new AtomicLong(0);\n-            AtomicLong lastSampleTimeMillis = new AtomicLong(0);\n+            AtomicLong burstThreadId = new AtomicLong();\n+            final long startTimeMillis = System.currentTimeMillis();\n@@ -99,8 +106,1 @@\n-            rs.onEvent(EventNames.CPUTimeSample, e -> {\n-                if (firstSampleTimeMillis.get() == 0 && e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    firstSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    lastSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-            });\n+            rs.onEvent(EventNames.CPUTimeSample, e -> {});\n@@ -109,1 +109,1 @@\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId.get()) {\n@@ -111,2 +111,2 @@\n-                    long relativeTime = firstSampleTimeMillis.get() > 0 ? (eventTime - firstSampleTimeMillis.get()) : eventTime;\n-                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime);\n+                    long relativeTime = eventTime - startTimeMillis;\n+                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime + \" start time \" + startTimeMillis);\n@@ -119,2 +119,2 @@\n-            Thread burstThread = new Thread(() -> WHITE_BOX.busyWait(11000));\n-            burstThread.setName(BURST_THREAD_NAME);\n+            Thread burstThread = new Thread(() -> WHITE_BOX.busyWaitCPUTime(8000));\n+            burstThreadId.set(burstThread.threadId());\n@@ -122,1 +122,1 @@\n-            \/\/ now we toggle out-of-stack-walking off, wait 1 second and then turn it on for 500ms a few times\n+            \/\/ now we toggle out-of-stack-walking off, wait 700 milliseconds and then turn it on for 300 milliseconds a few times\n@@ -130,1 +130,1 @@\n-                Thread.sleep(700);\n+                waitForCPUTime(burstThread, 700);\n@@ -133,2 +133,3 @@\n-                Thread.sleep(300);\n-                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations) {\n+                waitForCPUTime(burstThread, 300);\n+                int waitIters = 0;\n+                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations && waitIters < 5) {\n@@ -136,0 +137,6 @@\n+                    waitIters++;\n+                }\n+                if (waitIters == 5) {\n+                    System.out.println(\"Timed out waiting for stack walking to be done\");\n+                    Asserts.assertFalse(true);\n+                    return;\n@@ -137,0 +144,1 @@\n+                lossEvents.addTimeBoxEnd(System.currentTimeMillis() - startTimeMillis);\n@@ -139,1 +147,9 @@\n-            checkThatLossDecreased(lossEvents, lastSampleTimeMillis.get() - firstSampleTimeMillis.get());\n+            checkThatLossDecreased(lossEvents);\n+        }\n+    }\n+\n+    static void waitForCPUTime(Thread thread, int millis) {\n+        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+        long start = bean.getCurrentThreadCpuTime();\n+        while (bean.getCurrentThreadCpuTime() - start < millis * 1_000_000) {\n+            Thread.yield();\n@@ -143,4 +159,4 @@\n-    static void checkThatLossDecreased(LossEventCollection lossEvents, long lastSampleTimeMillis) {\n-        List<LossEvent> intervalLosses = lossEvents.getEventsPerInterval(1000, lastSampleTimeMillis);\n-        for (LossEvent interval : intervalLosses) {\n-            System.out.println(\"Lost samples in interval \" + interval.relativeTimeMillis + \": \" + interval.lostSamples);\n+    static void checkThatLossDecreased(LossEventCollection lossEvents) {\n+        List<LossEvent> timeBoxedLosses = lossEvents.getEventsPerTimeBox();\n+        for (LossEvent timeBoxedLoss : timeBoxedLosses) {\n+            System.out.println(\"Lost samples in time box \" + timeBoxedLoss.relativeTimeMillis + \": \" + timeBoxedLoss.lostSamples);\n@@ -148,5 +164,5 @@\n-        \/\/ check that there are at least 3 intervals\n-        Asserts.assertTrue(intervalLosses.size() > 2);\n-        \/\/ check that the second to last interval has far fewer lost samples than the first\n-        Asserts.assertTrue(intervalLosses.get(intervalLosses.size() - 2).lostSamples <\n-                           intervalLosses.get(0).lostSamples \/ 2);\n+        \/\/ check that there are at least 3 time boxes\n+        Asserts.assertTrue(timeBoxedLosses.size() > 3);\n+        \/\/ check that the last time box has far fewer lost samples than the first\n+        Asserts.assertTrue(timeBoxedLosses.get(timeBoxedLosses.size() - 1).lostSamples <\n+                           timeBoxedLosses.get(0).lostSamples \/ 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":50,"deletions":34,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -844,1 +844,2 @@\n-  public native void busyWait(int cpuTimeMs);\n+  public native void busyWaitCPUTime(int cpuTimeMs);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}