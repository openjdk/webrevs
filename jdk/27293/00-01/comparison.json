{"files":[{"patch":"@@ -234,1 +234,0 @@\n-  DEBUG_ONLY(volatile u8 _out_of_stack_walking_iterations;)\n@@ -285,4 +284,0 @@\n-\n-  u8 out_of_stack_walking_iterations() const {\n-    return AtomicAccess::load(&_out_of_stack_walking_iterations);\n-  }\n@@ -396,1 +391,0 @@\n-        DEBUG_ONLY(AtomicAccess::inc(&_out_of_stack_walking_iterations);)\n@@ -595,7 +589,0 @@\n-\n-u8 JfrCPUTimeThreadSampling::out_of_stack_walking_iterations() {\n-  if (_instance != nullptr && _instance->_sampler != nullptr) {\n-    return _instance->_sampler->out_of_stack_walking_iterations();\n-  }\n-  return 0;\n-}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -143,2 +143,0 @@\n-\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n@@ -166,1 +164,0 @@\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2682,8 +2682,0 @@\n-WB_ENTRY(jlong, WB_CPUSamplerOutOfStackWalkingIterations(JNIEnv* env, jobject wb))\n-  #if defined(ASSERT) && INCLUDE_JFR && defined(LINUX)\n-    return (jlong)JfrCPUTimeThreadSampling::out_of_stack_walking_iterations();\n-  #else\n-    return 0;\n-  #endif\n-WB_END\n-\n@@ -3045,1 +3037,0 @@\n-  {CC\"cpuSamplerOutOfStackWalkingIterations\", CC\"()J\",(void*)&WB_CPUSamplerOutOfStackWalkingIterations},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.time.Instant;\n@@ -46,0 +47,7 @@\n+ *\n+ * The test starts CPU time sampling with a short interval (1ms), disabling\n+ * out-of-stack sample processing for the duration of the test.\n+ * It now runs in native for one second, to cause queue overflows,\n+ * then it comes back into Java to trigger the queue walking.\n+ * Repeats the cycle 5 times and verifies that the loss decreases significantly from the first\n+ * to the last iteration.\n@@ -59,4 +67,0 @@\n-    private static final String BURST_THREAD_NAME = \"Burst-Thread-1\";\n-\n-    static volatile boolean alive = true;\n-\n@@ -103,1 +107,1 @@\n-            final long startTimeMillis = System.currentTimeMillis();\n+            final long startTimeMillis = Instant.now().toEpochMilli();\n@@ -106,1 +110,0 @@\n-            rs.onEvent(EventNames.CPUTimeSample, e -> {});\n@@ -116,1 +119,3 @@\n-            WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n+            \/\/ we disable the out-of-stack walking so that the queue fills up and overflows\n+            \/\/ while we are in native code\n+            disableOutOfStackWalking();\n@@ -118,5 +123,3 @@\n-            \/\/ this thread runs all along\n-            Thread burstThread = new Thread(() -> WHITE_BOX.busyWaitCPUTime(8000));\n-            burstThreadId.set(burstThread.threadId());\n-            burstThread.start();\n-            \/\/ now we toggle out-of-stack-walking off, wait 700 milliseconds and then turn it on for 300 milliseconds a few times\n+            burstThreadId.set(Thread.currentThread().threadId());\n+\n+\n@@ -124,21 +127,6 @@\n-                boolean supported = WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n-                if (!supported) {\n-                    System.out.println(\"Out-of-stack-walking not supported, skipping test\");\n-                    Asserts.assertFalse(true);\n-                    return;\n-                }\n-                waitForCPUTime(burstThread, 700);\n-                long iterations = WHITE_BOX.cpuSamplerOutOfStackWalkingIterations();\n-                WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n-                waitForCPUTime(burstThread, 300);\n-                int waitIters = 0;\n-                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations && waitIters < 5) {\n-                    Thread.sleep(50); \/\/ just to make sure the stack walking really ran\n-                    waitIters++;\n-                }\n-                if (waitIters == 5) {\n-                    System.out.println(\"Timed out waiting for stack walking to be done\");\n-                    Asserts.assertFalse(true);\n-                    return;\n-                }\n-                lossEvents.addTimeBoxEnd(System.currentTimeMillis() - startTimeMillis);\n+                \/\/ run in native for one second\n+                WHITE_BOX.busyWaitCPUTime(1000);\n+                \/\/ going out-of-native at the end of the previous call should have triggered\n+                \/\/ the safepoint handler, thereby also triggering the stack walkingand creation\n+                \/\/ of the loss event\n+                lossEvents.addTimeBoxEnd(Instant.now().toEpochMilli() - startTimeMillis);\n@@ -146,0 +134,1 @@\n+\n@@ -147,0 +136,3 @@\n+\n+            enableOutOfStackWalking();\n+\n@@ -151,5 +143,5 @@\n-    static void waitForCPUTime(Thread thread, int millis) {\n-        ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n-        long start = bean.getCurrentThreadCpuTime();\n-        while (bean.getCurrentThreadCpuTime() - start < millis * 1_000_000) {\n-            Thread.yield();\n+    static void disableOutOfStackWalking() {\n+        boolean supported = WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n+        if (!supported) {\n+            System.out.println(\"Out-of-stack-walking not supported, skipping test\");\n+            Asserts.assertFalse(true);\n@@ -159,0 +151,4 @@\n+    static void enableOutOfStackWalking() {\n+        WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n+    }\n+\n@@ -164,2 +160,0 @@\n-        \/\/ check that there are at least 3 time boxes\n-        Asserts.assertTrue(timeBoxedLosses.size() > 3);\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":34,"deletions":40,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -850,2 +850,0 @@\n-  public native long cpuSamplerOutOfStackWalkingIterations();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}