{"files":[{"patch":"@@ -2312,1 +2312,1 @@\n-    Assembler::msubw(result, scratch, rb, ra);\n+    msubw(result, scratch, rb, ra);\n@@ -2342,1 +2342,1 @@\n-    Assembler::msub(result, scratch, rb, ra);\n+    msub(result, scratch, rb, ra);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-  WRAP(madd) WRAP(msub) WRAP(maddw) WRAP(msubw)\n+  WRAP(madd) WRAP(maddw)\n@@ -445,0 +445,28 @@\n+  inline void msub(Register Rd, Register Rn, Register Rm, Register Ra) {\n+    if (VM_Version::supports_a53mac() && Ra != zr)\n+      nop();\n+    if (VM_Version::is_neoverse_family()) {\n+      \/* On Neoverse, MSUB uses the same ALU with SDIV.\n+       * The combination of MUL\/SUB can utilize multiple ALUs,\n+       * and is much faster than MSUB. *\/\n+      mul(rscratch1, Rn, Rm);\n+      sub(Rd, Ra, rscratch1);\n+    } else {\n+      Assembler::msub(Rd, Rn, Rm, Ra);\n+    }\n+  }\n+\n+  inline void msubw(Register Rd, Register Rn, Register Rm, Register Ra) {\n+    if (VM_Version::supports_a53mac() && Ra != zr)\n+      nop();\n+    if (VM_Version::is_neoverse_family()) {\n+      \/* On Neoverse, MSUB uses the same ALU with SDIV.\n+       * The combination of MUL\/SUB can utilize multiple ALUs,\n+       * and is much faster than MSUB. *\/\n+      mulw(rscratch1, Rn, Rm);\n+      subw(Rd, Ra, rscratch1);\n+    } else {\n+      Assembler::msubw(Rd, Rn, Rm, Ra);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,7 +215,1 @@\n-  \/\/ Neoverse\n-  \/\/   N1: 0xd0c\n-  \/\/   N2: 0xd49\n-  \/\/   V1: 0xd40\n-  \/\/   V2: 0xd4f\n-  if (_cpu == CPU_ARM && (model_is(0xd0c) || model_is(0xd49) ||\n-                          model_is(0xd40) || model_is(0xd4f))) {\n+  if (is_neoverse_family()) {\n@@ -250,4 +244,1 @@\n-  \/\/ Neoverse\n-  \/\/   V1: 0xd40\n-  \/\/   V2: 0xd4f\n-  if (_cpu == CPU_ARM && (model_is(0xd40) || model_is(0xd4f))) {\n+  if (is_neoverse_v_series()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -117,0 +117,7 @@\n+enum Neoverse_CPU_Model {\n+    CPU_MODEL_NEOVERSE_N1 = 0xd0c,\n+    CPU_MODEL_NEOVERSE_N2 = 0xd49,\n+    CPU_MODEL_NEOVERSE_V1 = 0xd40,\n+    CPU_MODEL_NEOVERSE_V2 = 0xd4f,\n+};\n+\n@@ -159,0 +166,16 @@\n+  static bool is_neoverse_family() {\n+    return _cpu == CPU_ARM\n+          && (model_is(CPU_MODEL_NEOVERSE_N1) || model_is(CPU_MODEL_NEOVERSE_N2) ||\n+              model_is(CPU_MODEL_NEOVERSE_V1) || model_is(CPU_MODEL_NEOVERSE_V2));\n+  }\n+\n+  static bool is_neoverse_n_series() {\n+    return is_neoverse_family() &&\n+              (model_is(CPU_MODEL_NEOVERSE_N1) || model_is(CPU_MODEL_NEOVERSE_N2));\n+  }\n+\n+  static bool is_neoverse_v_series() {\n+    return is_neoverse_family() &&\n+              (model_is(CPU_MODEL_NEOVERSE_V1) || model_is(CPU_MODEL_NEOVERSE_V2));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}