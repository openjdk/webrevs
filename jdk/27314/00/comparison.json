{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/g1\/g1ConcurrentMarkRemarkTasks.hpp\"\n@@ -1189,173 +1190,0 @@\n-\/\/ Update per-region liveness info based on CM stats. Then, reclaim empty\n-\/\/ regions right away and select certain regions (e.g. sparse ones) for remset\n-\/\/ rebuild.\n-class G1UpdateRegionLivenessAndSelectForRebuildTask : public WorkerTask {\n-  G1CollectedHeap* _g1h;\n-  G1ConcurrentMark* _cm;\n-  G1HeapRegionClaimer _hrclaimer;\n-\n-  uint volatile _total_selected_for_rebuild;\n-\n-  \/\/ Reclaimed empty regions\n-  G1FreeRegionList _cleanup_list;\n-\n-  struct G1OnRegionClosure : public G1HeapRegionClosure {\n-    G1CollectedHeap* _g1h;\n-    G1ConcurrentMark* _cm;\n-    \/\/ The number of regions actually selected for rebuild.\n-    uint _num_selected_for_rebuild;\n-\n-    size_t _freed_bytes;\n-    uint _num_old_regions_removed;\n-    uint _num_humongous_regions_removed;\n-    G1FreeRegionList* _local_cleanup_list;\n-\n-    G1OnRegionClosure(G1CollectedHeap* g1h,\n-                      G1ConcurrentMark* cm,\n-                      G1FreeRegionList* local_cleanup_list) :\n-      _g1h(g1h),\n-      _cm(cm),\n-      _num_selected_for_rebuild(0),\n-      _freed_bytes(0),\n-      _num_old_regions_removed(0),\n-      _num_humongous_regions_removed(0),\n-      _local_cleanup_list(local_cleanup_list) {}\n-\n-    void reclaim_empty_region(G1HeapRegion* hr) {\n-      assert(!hr->has_pinned_objects(), \"precondition\");\n-      assert(hr->used() > 0, \"precondition\");\n-\n-      _freed_bytes += hr->used();\n-      hr->set_containing_set(nullptr);\n-      hr->clear_cardtable();\n-      _cm->clear_statistics(hr);\n-      G1HeapRegionPrinter::mark_reclaim(hr);\n-    }\n-\n-    void reclaim_empty_humongous_region(G1HeapRegion* hr) {\n-      assert(hr->is_starts_humongous(), \"precondition\");\n-\n-      auto on_humongous_region = [&] (G1HeapRegion* hr) {\n-        assert(hr->is_humongous(), \"precondition\");\n-\n-        reclaim_empty_region(hr);\n-        _num_humongous_regions_removed++;\n-        _g1h->free_humongous_region(hr, _local_cleanup_list);\n-      };\n-\n-      _g1h->humongous_obj_regions_iterate(hr, on_humongous_region);\n-    }\n-\n-    void reclaim_empty_old_region(G1HeapRegion* hr) {\n-      assert(hr->is_old(), \"precondition\");\n-\n-      reclaim_empty_region(hr);\n-      _num_old_regions_removed++;\n-      _g1h->free_region(hr, _local_cleanup_list);\n-    }\n-\n-    bool do_heap_region(G1HeapRegion* hr) override {\n-      G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n-      if (hr->is_starts_humongous()) {\n-        \/\/ The liveness of this humongous obj decided by either its allocation\n-        \/\/ time (allocated after conc-mark-start, i.e. live) or conc-marking.\n-        const bool is_live = _cm->top_at_mark_start(hr) == hr->bottom()\n-                          || _cm->contains_live_object(hr->hrm_index())\n-                          || hr->has_pinned_objects();\n-        if (is_live) {\n-          const bool selected_for_rebuild = tracker->update_humongous_before_rebuild(hr);\n-          auto on_humongous_region = [&] (G1HeapRegion* hr) {\n-            if (selected_for_rebuild) {\n-              _num_selected_for_rebuild++;\n-            }\n-            _cm->update_top_at_rebuild_start(hr);\n-          };\n-\n-          _g1h->humongous_obj_regions_iterate(hr, on_humongous_region);\n-        } else {\n-          reclaim_empty_humongous_region(hr);\n-        }\n-      } else if (hr->is_old()) {\n-        uint region_idx = hr->hrm_index();\n-        hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(region_idx), _cm->incoming_refs(region_idx));\n-\n-        const bool is_live = hr->live_bytes() != 0\n-                          || hr->has_pinned_objects();\n-        if (is_live) {\n-          const bool selected_for_rebuild = tracker->update_old_before_rebuild(hr);\n-          if (selected_for_rebuild) {\n-            _num_selected_for_rebuild++;\n-          }\n-          _cm->update_top_at_rebuild_start(hr);\n-        } else {\n-          reclaim_empty_old_region(hr);\n-        }\n-      }\n-\n-      return false;\n-    }\n-  };\n-\n-public:\n-  G1UpdateRegionLivenessAndSelectForRebuildTask(G1CollectedHeap* g1h,\n-                                                G1ConcurrentMark* cm,\n-                                                uint num_workers) :\n-    WorkerTask(\"G1 Update Region Liveness and Select For Rebuild\"),\n-    _g1h(g1h),\n-    _cm(cm),\n-    _hrclaimer(num_workers),\n-    _total_selected_for_rebuild(0),\n-    _cleanup_list(\"Empty Regions After Mark List\") {}\n-\n-  ~G1UpdateRegionLivenessAndSelectForRebuildTask() {\n-    if (!_cleanup_list.is_empty()) {\n-      log_debug(gc)(\"Reclaimed %u empty regions\", _cleanup_list.length());\n-      \/\/ And actually make them available.\n-      _g1h->prepend_to_freelist(&_cleanup_list);\n-    }\n-  }\n-\n-  void work(uint worker_id) override {\n-    G1FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n-    G1OnRegionClosure on_region_cl(_g1h, _cm, &local_cleanup_list);\n-    _g1h->heap_region_par_iterate_from_worker_offset(&on_region_cl, &_hrclaimer, worker_id);\n-\n-    AtomicAccess::add(&_total_selected_for_rebuild, on_region_cl._num_selected_for_rebuild);\n-\n-    \/\/ Update the old\/humongous region sets\n-    _g1h->remove_from_old_gen_sets(on_region_cl._num_old_regions_removed,\n-                                   on_region_cl._num_humongous_regions_removed);\n-\n-    {\n-      MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n-      _g1h->decrement_summary_bytes(on_region_cl._freed_bytes);\n-\n-      _cleanup_list.add_ordered(&local_cleanup_list);\n-      assert(local_cleanup_list.is_empty(), \"post-condition\");\n-    }\n-  }\n-\n-  uint total_selected_for_rebuild() const { return _total_selected_for_rebuild; }\n-\n-  static uint desired_num_workers(uint num_regions) {\n-    const uint num_regions_per_worker = 384;\n-    return (num_regions + num_regions_per_worker - 1) \/ num_regions_per_worker;\n-  }\n-};\n-\n-class G1UpdateRegionsAfterRebuild : public G1HeapRegionClosure {\n-  G1CollectedHeap* _g1h;\n-\n-public:\n-  G1UpdateRegionsAfterRebuild(G1CollectedHeap* g1h) :\n-    _g1h(g1h) {\n-  }\n-\n-  virtual bool do_heap_region(G1HeapRegion* r) {\n-    \/\/ Update the remset tracking state from updating to complete\n-    \/\/ if remembered sets have been rebuilt.\n-    _g1h->policy()->remset_tracker()->update_after_rebuild(r);\n-    return false;\n-  }\n-};\n-\n@@ -1509,0 +1337,14 @@\n+class G1UpdateRegionsAfterRebuild : public G1HeapRegionClosure {\n+  G1CollectedHeap* _g1h;\n+\n+public:\n+  G1UpdateRegionsAfterRebuild(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+\n+  bool do_heap_region(G1HeapRegion* r) override {\n+    \/\/ Update the remset tracking state from updating to complete\n+    \/\/ if remembered sets have been rebuilt.\n+    _g1h->policy()->remset_tracker()->update_after_rebuild(r);\n+    return false;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":15,"deletions":173,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMarkRemarkTasks.hpp\"\n+#include \"gc\/g1\/g1HeapRegion.inline.hpp\"\n+#include \"gc\/g1\/g1HeapRegionPrinter.hpp\"\n+#include \"gc\/g1\/g1RemSetTrackingPolicy.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+struct G1UpdateRegionLivenessAndSelectForRebuildTask::G1OnRegionClosure : public G1HeapRegionClosure {\n+  G1CollectedHeap* _g1h;\n+  G1ConcurrentMark* _cm;\n+  \/\/ The number of regions actually selected for rebuild.\n+  uint _num_selected_for_rebuild;\n+\n+  size_t _freed_bytes;\n+  uint _num_old_regions_removed;\n+  uint _num_humongous_regions_removed;\n+  G1FreeRegionList* _local_cleanup_list;\n+\n+  G1OnRegionClosure(G1CollectedHeap* g1h,\n+                    G1ConcurrentMark* cm,\n+                    G1FreeRegionList* local_cleanup_list) :\n+    _g1h(g1h),\n+    _cm(cm),\n+    _num_selected_for_rebuild(0),\n+    _freed_bytes(0),\n+    _num_old_regions_removed(0),\n+    _num_humongous_regions_removed(0),\n+    _local_cleanup_list(local_cleanup_list) {}\n+\n+  void reclaim_empty_region(G1HeapRegion* hr) {\n+    assert(!hr->has_pinned_objects(), \"precondition\");\n+    assert(hr->used() > 0, \"precondition\");\n+\n+    _freed_bytes += hr->used();\n+    hr->set_containing_set(nullptr);\n+    hr->clear_cardtable();\n+    _cm->clear_statistics(hr);\n+    G1HeapRegionPrinter::mark_reclaim(hr);\n+  }\n+\n+  void reclaim_empty_humongous_region(G1HeapRegion* hr) {\n+    assert(hr->is_starts_humongous(), \"precondition\");\n+\n+    auto on_humongous_region = [&] (G1HeapRegion* hr) {\n+      assert(hr->is_humongous(), \"precondition\");\n+\n+      reclaim_empty_region(hr);\n+      _num_humongous_regions_removed++;\n+      _g1h->free_humongous_region(hr, _local_cleanup_list);\n+    };\n+\n+    _g1h->humongous_obj_regions_iterate(hr, on_humongous_region);\n+  }\n+\n+  void reclaim_empty_old_region(G1HeapRegion* hr) {\n+    assert(hr->is_old(), \"precondition\");\n+\n+    reclaim_empty_region(hr);\n+    _num_old_regions_removed++;\n+    _g1h->free_region(hr, _local_cleanup_list);\n+  }\n+\n+  bool do_heap_region(G1HeapRegion* hr) override {\n+    G1RemSetTrackingPolicy* tracker = _g1h->policy()->remset_tracker();\n+    if (hr->is_starts_humongous()) {\n+      \/\/ The liveness of this humongous obj decided by either its allocation\n+      \/\/ time (allocated after conc-mark-start, i.e. live) or conc-marking.\n+      const bool is_live = _cm->top_at_mark_start(hr) == hr->bottom()\n+                        || _cm->contains_live_object(hr->hrm_index())\n+                        || hr->has_pinned_objects();\n+      if (is_live) {\n+        const bool selected_for_rebuild = tracker->update_humongous_before_rebuild(hr);\n+        auto on_humongous_region = [&] (G1HeapRegion* hr) {\n+          if (selected_for_rebuild) {\n+            _num_selected_for_rebuild++;\n+          }\n+          _cm->update_top_at_rebuild_start(hr);\n+        };\n+\n+        _g1h->humongous_obj_regions_iterate(hr, on_humongous_region);\n+      } else {\n+        reclaim_empty_humongous_region(hr);\n+      }\n+    } else if (hr->is_old()) {\n+      uint region_idx = hr->hrm_index();\n+      hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(region_idx), _cm->incoming_refs(region_idx));\n+\n+      const bool is_live = hr->live_bytes() != 0\n+                        || hr->has_pinned_objects();\n+      if (is_live) {\n+        const bool selected_for_rebuild = tracker->update_old_before_rebuild(hr);\n+        if (selected_for_rebuild) {\n+          _num_selected_for_rebuild++;\n+        }\n+        _cm->update_top_at_rebuild_start(hr);\n+      } else {\n+        reclaim_empty_old_region(hr);\n+      }\n+    }\n+\n+    return false;\n+  }\n+};\n+\n+G1UpdateRegionLivenessAndSelectForRebuildTask::G1UpdateRegionLivenessAndSelectForRebuildTask(G1CollectedHeap* g1h,\n+                                                                                             G1ConcurrentMark* cm,\n+                                                                                             uint num_workers) :\n+  WorkerTask(\"G1 Update Region Liveness and Select For Rebuild\"),\n+  _g1h(g1h),\n+  _cm(cm),\n+  _hrclaimer(num_workers),\n+  _total_selected_for_rebuild(0),\n+  _cleanup_list(\"Empty Regions After Mark List\") {}\n+\n+G1UpdateRegionLivenessAndSelectForRebuildTask::~G1UpdateRegionLivenessAndSelectForRebuildTask() {\n+  if (!_cleanup_list.is_empty()) {\n+    log_debug(gc)(\"Reclaimed %u empty regions\", _cleanup_list.length());\n+    \/\/ And actually make them available.\n+    _g1h->prepend_to_freelist(&_cleanup_list);\n+  }\n+}\n+\n+void G1UpdateRegionLivenessAndSelectForRebuildTask::work(uint worker_id) {\n+  G1FreeRegionList local_cleanup_list(\"Local Cleanup List\");\n+  G1OnRegionClosure on_region_cl(_g1h, _cm, &local_cleanup_list);\n+  _g1h->heap_region_par_iterate_from_worker_offset(&on_region_cl, &_hrclaimer, worker_id);\n+\n+  AtomicAccess::add(&_total_selected_for_rebuild, on_region_cl._num_selected_for_rebuild);\n+\n+  \/\/ Update the old\/humongous region sets\n+  _g1h->remove_from_old_gen_sets(on_region_cl._num_old_regions_removed,\n+                                 on_region_cl._num_humongous_regions_removed);\n+\n+  {\n+    MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    _g1h->decrement_summary_bytes(on_region_cl._freed_bytes);\n+\n+    _cleanup_list.add_ordered(&local_cleanup_list);\n+    assert(local_cleanup_list.is_empty(), \"post-condition\");\n+  }\n+}\n+\n+uint G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(uint num_regions) {\n+  const uint num_regions_per_worker = 384;\n+  return (num_regions + num_regions_per_worker - 1) \/ num_regions_per_worker;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkRemarkTasks.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CONCURRENTMARKREMARKTASKS_HPP\n+#define SHARE_GC_G1_G1CONCURRENTMARKREMARKTASKS_HPP\n+\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n+#include \"gc\/g1\/g1HeapRegionManager.hpp\"\n+#include \"gc\/g1\/g1HeapRegionSet.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+\n+class G1CollectedHeap;\n+class G1ConcurrentMark;\n+\n+\/\/ Update per-region liveness info based on CM stats. Then, reclaim empty\n+\/\/ regions right away and select certain regions (e.g. sparse ones) for remset\n+\/\/ rebuild.\n+class G1UpdateRegionLivenessAndSelectForRebuildTask : public WorkerTask {\n+  G1CollectedHeap* _g1h;\n+  G1ConcurrentMark* _cm;\n+  G1HeapRegionClaimer _hrclaimer;\n+\n+  uint volatile _total_selected_for_rebuild;\n+\n+  \/\/ Reclaimed empty regions\n+  G1FreeRegionList _cleanup_list;\n+\n+  struct G1OnRegionClosure;\n+\n+public:\n+  G1UpdateRegionLivenessAndSelectForRebuildTask(G1CollectedHeap* g1h,\n+                                                G1ConcurrentMark* cm,\n+                                                uint num_workers);\n+\n+  ~G1UpdateRegionLivenessAndSelectForRebuildTask();\n+\n+  void work(uint worker_id) override;\n+\n+  uint total_selected_for_rebuild() const { return _total_selected_for_rebuild; }\n+\n+  static uint desired_num_workers(uint num_regions);\n+};\n+\n+#endif \/* SHARE_GC_G1_G1CONCURRENTMARKREMARKTASKS_HPP *\/\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkRemarkTasks.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}