{"files":[{"patch":"@@ -4183,0 +4183,4 @@\n+        if (fitsIntoLong()) {\n+            return Long.toString(longValue(), radix);\n+        }\n+\n@@ -5124,1 +5128,1 @@\n-        if (mag.length <= 2 && bitLength() < Long.SIZE)\n+        if (fitsIntoLong())\n@@ -5130,0 +5134,4 @@\n+    private boolean fitsIntoLong() {\n+        return mag.length <= 2 && bitLength() < Long.SIZE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -111,1 +112,0 @@\n-    private byte[] data;\n@@ -323,0 +323,2 @@\n+        assert Double.isFinite(source);\n+\n@@ -327,1 +329,0 @@\n-        assert !fdConverter.isExceptional();\n@@ -329,3 +330,5 @@\n-        byte[] chars = getDataChars(26);\n-        int len = fdConverter.getChars(chars);\n-        set(isNegative, chars, len,\n+        count = fdConverter.getDigits(digits);\n+\n+        int exp = fdConverter.getDecimalExponent() - count;\n+\n+        set(isNegative, exp,\n@@ -343,1 +346,1 @@\n-    private void set(boolean isNegative, byte[] source, int len,\n+    private void set(boolean isNegative, int exp,\n@@ -349,31 +352,4 @@\n-        decimalAt = -1;\n-        count = 0;\n-        int exponent = 0;\n-        \/\/ Number of zeros between decimal point and first non-zero digit after\n-        \/\/ decimal point, for numbers < 1.\n-        int leadingZerosAfterDecimal = 0;\n-        boolean nonZeroDigitSeen = false;\n-\n-        for (int i = 0; i < len; ) {\n-            byte c = source[i++];\n-            if (c == '.') {\n-                decimalAt = count;\n-            } else if (c == 'e' || c == 'E') {\n-                exponent = parseInt(source, i, len);\n-                break;\n-            } else {\n-                if (!nonZeroDigitSeen) {\n-                    nonZeroDigitSeen = (c != '0');\n-                    if (!nonZeroDigitSeen && decimalAt != -1)\n-                        ++leadingZerosAfterDecimal;\n-                }\n-                if (nonZeroDigitSeen) {\n-                    digits[count++] = c;\n-                }\n-            }\n-        }\n-        if (decimalAt == -1) {\n-            decimalAt = count;\n-        }\n-        if (nonZeroDigitSeen) {\n-            decimalAt += exponent - leadingZerosAfterDecimal;\n+        if (!nonZeroAfterIndex(0)) {\n+            count = 0;\n+            decimalAt = 0;\n+            return;\n@@ -381,0 +357,1 @@\n+        decimalAt = count + exp;\n@@ -672,3 +649,1 @@\n-        String s = source.toString();\n-        extendDigits(s.length());\n-\n+        String s = source.unscaledValue().toString();\n@@ -676,3 +651,5 @@\n-        byte[] chars = getDataChars(len);\n-        s.getBytes(0, len, chars, 0);\n-        set(isNegative, chars, len,\n+\n+        extendDigits(len);\n+        s.getBytes(0, len, digits, 0);\n+        count = len;\n+        set(isNegative, -source.scale(),\n@@ -748,8 +725,1 @@\n-            byte[] newDigits = new byte[digits.length];\n-            System.arraycopy(digits, 0, newDigits, 0, digits.length);\n-            other.digits = newDigits;\n-\n-            \/\/ Data does not need to be copied because it does\n-            \/\/ not carry significant information. It will be recreated on demand.\n-            \/\/ Setting it to null is needed to avoid sharing across clones.\n-            other.data = null;\n+            other.digits = digits.clone();\n@@ -763,22 +733,0 @@\n-    private static int parseInt(byte[] str, int offset, int strLen) {\n-        byte c;\n-        boolean positive = true;\n-        if ((c = str[offset]) == '-') {\n-            positive = false;\n-            offset++;\n-        } else if (c == '+') {\n-            offset++;\n-        }\n-\n-        int value = 0;\n-        while (offset < strLen) {\n-            c = str[offset++];\n-            if (c >= '0' && c <= '9') {\n-                value = value * 10 + (c - '0');\n-            } else {\n-                break;\n-            }\n-        }\n-        return positive ? value : -value;\n-    }\n-\n@@ -786,0 +734,1 @@\n+    @Stable\n@@ -801,7 +750,0 @@\n-\n-    private byte[] getDataChars(int length) {\n-        if (data == null || data.length < length) {\n-            data = new byte[length];\n-        }\n-        return data;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":22,"deletions":80,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        int getDigits(char[] digits);\n+        int getDigits(byte[] digits);\n@@ -176,1 +176,1 @@\n-        public int getDigits(char[] digits) {\n+        public int getDigits(byte[] digits) {\n@@ -258,1 +258,1 @@\n-        public int getDigits(char[] digits) {\n+        public int getDigits(byte[] digits) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8354522 8358880\n+ * @bug 8354522 8358880 8367324\n@@ -92,6 +92,0 @@\n-\n-                Object data = valFromDigitList(original, \"data\");\n-                if (data != null) {\n-                    assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n-                }\n-\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/CloneTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.math.BigDecimal;\n@@ -28,0 +29,1 @@\n+import java.util.stream.DoubleStream;\n@@ -32,0 +34,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -53,0 +56,1 @@\n+    public static final int VALUES_SIZE = 13;\n@@ -54,0 +58,2 @@\n+    public BigDecimal[] bdLargeValues;\n+    public BigDecimal[] bdSmallValues;\n@@ -55,1 +61,1 @@\n-    @Setup\n+    @Setup(Level.Invocation)\n@@ -60,0 +66,8 @@\n+\n+        bdLargeValues = DoubleStream.of(values)\n+                .mapToObj(BigDecimal::new)\n+                .toArray(BigDecimal[]::new);\n+\n+        bdSmallValues = DoubleStream.of(values)\n+                .mapToObj(BigDecimal::valueOf)\n+                .toArray(BigDecimal[]::new);\n@@ -65,1 +79,1 @@\n-    @OperationsPerInvocation(13)\n+    @OperationsPerInvocation(VALUES_SIZE)\n@@ -72,0 +86,16 @@\n+    @Benchmark\n+    @OperationsPerInvocation(VALUES_SIZE)\n+    public void testSmallBigDecDefNumberFormatter(final Blackhole blackhole) {\n+        for (BigDecimal value : bdSmallValues) {\n+            blackhole.consume(this.dnf.format(value));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(VALUES_SIZE)\n+    public void testLargeBigDecDefNumberFormatter(final Blackhole blackhole) {\n+        for (BigDecimal value : bdLargeValues) {\n+            blackhole.consume(this.dnf.format(value));\n+        }\n+    }\n+\n@@ -91,0 +121,4 @@\n+\n+        public String format(final BigDecimal bd) {\n+            return this.n.format(bd);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DefFormatterBench.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"}]}