{"files":[{"patch":"@@ -4183,0 +4183,4 @@\n+        if (fitsIntoLong()) {\n+            return Long.toString(longValue(), radix);\n+        }\n+\n@@ -5124,1 +5128,1 @@\n-        if (mag.length <= 2 && bitLength() < Long.SIZE)\n+        if (fitsIntoLong())\n@@ -5130,0 +5134,4 @@\n+    private boolean fitsIntoLong() {\n+        return mag.length <= 2 && bitLength() < Long.SIZE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-    private byte[] data;\n@@ -329,3 +328,5 @@\n-        byte[] chars = getDataChars(26);\n-        int len = fdConverter.getChars(chars);\n-        set(isNegative, chars, len,\n+        count = fdConverter.getDigits(digits);\n+\n+        int exp = fdConverter.getDecimalExponent() - count;\n+\n+        set(isNegative, exp,\n@@ -343,1 +344,1 @@\n-    private void set(boolean isNegative, byte[] source, int len,\n+    private void set(boolean isNegative, int exp,\n@@ -349,31 +350,4 @@\n-        decimalAt = -1;\n-        count = 0;\n-        int exponent = 0;\n-        \/\/ Number of zeros between decimal point and first non-zero digit after\n-        \/\/ decimal point, for numbers < 1.\n-        int leadingZerosAfterDecimal = 0;\n-        boolean nonZeroDigitSeen = false;\n-\n-        for (int i = 0; i < len; ) {\n-            byte c = source[i++];\n-            if (c == '.') {\n-                decimalAt = count;\n-            } else if (c == 'e' || c == 'E') {\n-                exponent = parseInt(source, i, len);\n-                break;\n-            } else {\n-                if (!nonZeroDigitSeen) {\n-                    nonZeroDigitSeen = (c != '0');\n-                    if (!nonZeroDigitSeen && decimalAt != -1)\n-                        ++leadingZerosAfterDecimal;\n-                }\n-                if (nonZeroDigitSeen) {\n-                    digits[count++] = c;\n-                }\n-            }\n-        }\n-        if (decimalAt == -1) {\n-            decimalAt = count;\n-        }\n-        if (nonZeroDigitSeen) {\n-            decimalAt += exponent - leadingZerosAfterDecimal;\n+        if (!nonZeroAfterIndex(0)) {\n+            count = 0;\n+            decimalAt = 0;\n+            return;\n@@ -381,0 +355,1 @@\n+        decimalAt = count + exp;\n@@ -672,3 +647,1 @@\n-        String s = source.toString();\n-        extendDigits(s.length());\n-\n+        String s = source.unscaledValue().toString();\n@@ -676,3 +649,5 @@\n-        byte[] chars = getDataChars(len);\n-        s.getBytes(0, len, chars, 0);\n-        set(isNegative, chars, len,\n+\n+        extendDigits(len);\n+        s.getBytes(0, len, digits, 0);\n+        count = len;\n+        set(isNegative, -source.scale(),\n@@ -748,8 +723,1 @@\n-            byte[] newDigits = new byte[digits.length];\n-            System.arraycopy(digits, 0, newDigits, 0, digits.length);\n-            other.digits = newDigits;\n-\n-            \/\/ Data does not need to be copied because it does\n-            \/\/ not carry significant information. It will be recreated on demand.\n-            \/\/ Setting it to null is needed to avoid sharing across clones.\n-            other.data = null;\n+            other.digits = digits.clone();\n@@ -763,22 +731,0 @@\n-    private static int parseInt(byte[] str, int offset, int strLen) {\n-        byte c;\n-        boolean positive = true;\n-        if ((c = str[offset]) == '-') {\n-            positive = false;\n-            offset++;\n-        } else if (c == '+') {\n-            offset++;\n-        }\n-\n-        int value = 0;\n-        while (offset < strLen) {\n-            c = str[offset++];\n-            if (c >= '0' && c <= '9') {\n-                value = value * 10 + (c - '0');\n-            } else {\n-                break;\n-            }\n-        }\n-        return positive ? value : -value;\n-    }\n-\n@@ -801,7 +747,0 @@\n-\n-    private byte[] getDataChars(int length) {\n-        if (data == null || data.length < length) {\n-            data = new byte[length];\n-        }\n-        return data;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":18,"deletions":79,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        int getDigits(char[] digits);\n+        int getDigits(byte[] digits);\n@@ -176,1 +176,1 @@\n-        public int getDigits(char[] digits) {\n+        public int getDigits(byte[] digits) {\n@@ -258,1 +258,1 @@\n-        public int getDigits(char[] digits) {\n+        public int getDigits(byte[] digits) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,6 +92,0 @@\n-\n-                Object data = valFromDigitList(original, \"data\");\n-                if (data != null) {\n-                    assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n-                }\n-\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/CloneTest.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.math.BigDecimal;\n@@ -28,0 +29,1 @@\n+import java.util.stream.DoubleStream;\n@@ -54,0 +56,1 @@\n+    public BigDecimal[] bdValues;\n@@ -60,0 +63,5 @@\n+\n+        bdValues = DoubleStream.of(values)\n+                .mapToObj(BigDecimal::new)\n+                .toArray(BigDecimal[]::new);\n+\n@@ -72,0 +80,26 @@\n+    @Benchmark\n+    @OperationsPerInvocation(13)\n+    public void testSmallBigDecDefNumberFormatter(final Blackhole blackhole) {\n+        for (double value : values) {\n+            \/\/ bd is recreated each time to avoid the effect of internal caching\n+            \/\/ of the toString value if the BigDecimal instance was reused.\n+\n+            \/\/ This will create \"small\" BigDecimals where unscaled value fits in a long.\n+            BigDecimal bd = BigDecimal.valueOf(value);\n+            blackhole.consume(this.dnf.format(bd));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(13)\n+    public void testLargeBigDecDefNumberFormatter(final Blackhole blackhole) {\n+        for (BigDecimal value : bdValues) {\n+            \/\/ bd is recreated each time to avoid the effect of internal caching\n+            \/\/ of the toString value if the BigDecimal instance was reused.\n+\n+            BigDecimal bd = new BigDecimal(value.unscaledValue(), value.scale());\n+\n+            blackhole.consume(this.dnf.format(bd));\n+        }\n+    }\n+\n@@ -91,0 +125,4 @@\n+\n+        public String format(final BigDecimal bd) {\n+            return this.n.format(bd);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DefFormatterBench.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"}]}