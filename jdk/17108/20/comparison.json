{"files":[{"patch":"@@ -28,7 +28,6 @@\n-import jdk.internal.loader.BootLoader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.vm.annotation.Stable;\n-import sun.invoke.util.BytecodeName;\n-\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.LambdaForm.BasicType;\n@@ -45,1 +44,9 @@\n-import static java.lang.invoke.LambdaForm.*;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+import jdk.internal.loader.BootLoader;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.BytecodeName;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,1 +57,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -60,0 +66,4 @@\n+\n+    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_BoundMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n+\n@@ -407,1 +417,1 @@\n-                    end.append(classSig(type));\n+                    end.append(type.descriptorString());\n@@ -575,2 +585,3 @@\n-        private final String SPECIES_DATA = classBCName(metaType);\n-        private final String SPECIES_DATA_SIG = classSig(SPECIES_DATA);\n+\n+        private final ClassDesc CD_SPECIES_DATA = classDesc(metaType);\n+        private final MethodTypeDesc MTD_SPECIES_DATA = MethodTypeDescImpl.ofValidated(CD_SPECIES_DATA);\n@@ -598,0 +609,1 @@\n+        private static final MethodTypeDesc MTD_TRANFORM_HELPER = MethodTypeDescImpl.ofValidated(CD_MethodHandle, CD_int);\n@@ -602,65 +614,61 @@\n-            final String className = classBCName(className0);\n-            final String superClassName = classBCName(speciesData.deriveSuperClass());\n-\n-            final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-            final int NOT_ACC_PUBLIC = 0;  \/\/ not ACC_PUBLIC\n-            cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, superClassName, null);\n-\n-            final String sourceFile = className.substring(className.lastIndexOf('.')+1);\n-            cw.visitSource(sourceFile, null);\n-\n-            \/\/ emit static types and BMH_SPECIES fields\n-            FieldVisitor fw = cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, sdFieldName, SPECIES_DATA_SIG, null, null);\n-            fw.visitAnnotation(STABLE_SIG, true);\n-            fw.visitEnd();\n-\n-            \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n-            class Var {\n-                final int index;\n-                final String name;\n-                final Class<?> type;\n-                final String desc;\n-                final BasicType basicType;\n-                final int slotIndex;\n-                Var(int index, int slotIndex) {\n-                    this.index = index;\n-                    this.slotIndex = slotIndex;\n-                    name = null; type = null; desc = null;\n-                    basicType = BasicType.V_TYPE;\n-                }\n-                Var(String name, Class<?> type, Var prev) {\n-                    int slotIndex = prev.nextSlotIndex();\n-                    int index = prev.nextIndex();\n-                    if (name == null)  name = \"x\";\n-                    if (name.endsWith(\"#\"))\n-                        name = name.substring(0, name.length()-1) + index;\n-                    assert(!type.equals(void.class));\n-                    String desc = classSig(type);\n-                    BasicType basicType = BasicType.basicType(type);\n-                    this.index = index;\n-                    this.name = name;\n-                    this.type = type;\n-                    this.desc = desc;\n-                    this.basicType = basicType;\n-                    this.slotIndex = slotIndex;\n-                }\n-                Var lastOf(List<Var> vars) {\n-                    int n = vars.size();\n-                    return (n == 0 ? this : vars.get(n-1));\n-                }\n-                <X> List<Var> fromTypes(List<X> types) {\n-                    Var prev = this;\n-                    ArrayList<Var> result = new ArrayList<>(types.size());\n-                    int i = 0;\n-                    for (X x : types) {\n-                        String vn = name;\n-                        Class<?> vt;\n-                        if (x instanceof Class<?> cl) {\n-                            vt = cl;\n-                            \/\/ make the names friendlier if debugging\n-                            assert((vn = vn + \"_\" + (i++)) != null);\n-                        } else {\n-                            @SuppressWarnings(\"unchecked\")\n-                            Var v = (Var) x;\n-                            vn = v.name;\n-                            vt = v.type;\n+            final ClassDesc classDesc = ClassDesc.of(className0);\n+            final ClassDesc superClassDesc = classDesc(speciesData.deriveSuperClass());\n+            return ClassFile.of().build(classDesc, clb -> {\n+                clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                   .withSuperclass(superClassDesc)\n+                   .with(SourceFileAttribute.of(classDesc.displayName()))\n+\n+                \/\/ emit static types and BMH_SPECIES fields\n+                   .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n+\n+                \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n+                class Var {\n+                    final int index;\n+                    final String name;\n+                    final Class<?> type;\n+                    final ClassDesc desc;\n+                    final BasicType basicType;\n+                    final int slotIndex;\n+                    Var(int index, int slotIndex) {\n+                        this.index = index;\n+                        this.slotIndex = slotIndex;\n+                        name = null; type = null; desc = null;\n+                        basicType = BasicType.V_TYPE;\n+                    }\n+                    Var(String name, Class<?> type, Var prev) {\n+                        int slotIndex = prev.nextSlotIndex();\n+                        int index = prev.nextIndex();\n+                        if (name == null)  name = \"x\";\n+                        if (name.endsWith(\"#\"))\n+                            name = name.substring(0, name.length()-1) + index;\n+                        assert(!type.equals(void.class));\n+                        this.index = index;\n+                        this.name = name;\n+                        this.type = type;\n+                        this.desc = classDesc(type);\n+                        this.basicType = BasicType.basicType(type);\n+                        this.slotIndex = slotIndex;\n+                    }\n+                    Var lastOf(List<Var> vars) {\n+                        int n = vars.size();\n+                        return (n == 0 ? this : vars.get(n-1));\n+                    }\n+                    <X> List<Var> fromTypes(List<X> types) {\n+                        Var prev = this;\n+                        ArrayList<Var> result = new ArrayList<>(types.size());\n+                        int i = 0;\n+                        for (X x : types) {\n+                            String vn = name;\n+                            Class<?> vt;\n+                            if (x instanceof Class<?> cl) {\n+                                vt = cl;\n+                                \/\/ make the names friendlier if debugging\n+                                assert((vn = vn + \"_\" + (i++)) != null);\n+                            } else {\n+                                @SuppressWarnings(\"unchecked\")\n+                                Var v = (Var) x;\n+                                vn = v.name;\n+                                vt = v.type;\n+                            }\n+                            prev = new Var(vn, vt, prev);\n+                            result.add(prev);\n@@ -668,2 +676,1 @@\n-                        prev = new Var(vn, vt, prev);\n-                        result.add(prev);\n+                        return result;\n@@ -671,2 +678,0 @@\n-                    return result;\n-                }\n@@ -674,29 +679,7 @@\n-                int slotSize() { return basicType.basicTypeSlots(); }\n-                int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n-                int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n-                boolean isInHeap() { return slotIndex < 0; }\n-                void emitVarInstruction(int asmop, MethodVisitor mv) {\n-                    if (asmop == ALOAD)\n-                        asmop = typeLoadOp(basicType.basicTypeChar());\n-                    else\n-                        throw new AssertionError(\"bad op=\"+asmop+\" for desc=\"+desc);\n-                    mv.visitVarInsn(asmop, slotIndex);\n-                }\n-                public void emitFieldInsn(int asmop, MethodVisitor mv) {\n-                    mv.visitFieldInsn(asmop, className, name, desc);\n-                }\n-            }\n-\n-            final Var NO_THIS = new Var(0, 0),\n-                    AFTER_THIS = new Var(0, 1),\n-                    IN_HEAP = new Var(0, -1);\n-\n-            \/\/ figure out the field types\n-            final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n-            final List<Var> fields = new ArrayList<>(fieldTypes.size());\n-            {\n-                Var nextF = IN_HEAP;\n-                for (Class<?> ft : fieldTypes) {\n-                    String fn = chooseFieldName(ft, nextF.nextIndex());\n-                    nextF = new Var(fn, ft, nextF);\n-                    fields.add(nextF);\n+                    int slotSize() { return basicType.basicTypeSlots(); }\n+                    int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n+                    int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n+                    boolean isInHeap() { return slotIndex < 0; }\n+                    void emitLoadInstruction(CodeBuilder cob) {\n+                        cob.loadLocal(basicType.btKind, slotIndex);\n+                    }\n@@ -704,1 +687,0 @@\n-            }\n@@ -706,30 +688,14 @@\n-            \/\/ emit bound argument fields\n-            for (Var field : fields) {\n-                cw.visitField(ACC_FINAL, field.name, field.desc, null, null).visitEnd();\n-            }\n-\n-            MethodVisitor mv;\n-\n-            \/\/ emit implementation of speciesData()\n-            mv = cw.visitMethod((SPECIES_DATA_MODS & ACC_PPP) + ACC_FINAL,\n-                    SPECIES_DATA_NAME, \"()\" + SPECIES_DATA_SIG, null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, className, sdFieldName, SPECIES_DATA_SIG);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-\n-            \/\/ figure out the constructor arguments\n-            MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n-            MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n-\n-            \/\/ emit constructor\n-            {\n-                mv = cw.visitMethod(ACC_PRIVATE,\n-                        \"<init>\", methodSig(thisCtorType), null, null);\n-                mv.visitCode();\n-                mv.visitVarInsn(ALOAD, 0); \/\/ this\n-\n-                final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n-                for (Var ca : ctorArgs) {\n-                    ca.emitVarInstruction(ALOAD, mv);\n+                final Var NO_THIS = new Var(0, 0),\n+                        AFTER_THIS = new Var(0, 1),\n+                        IN_HEAP = new Var(0, -1);\n+\n+                \/\/ figure out the field types\n+                final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n+                final List<Var> fields = new ArrayList<>(fieldTypes.size());\n+                {\n+                    Var nextF = IN_HEAP;\n+                    for (Class<?> ft : fieldTypes) {\n+                        String fn = chooseFieldName(ft, nextF.nextIndex());\n+                        nextF = new Var(fn, ft, nextF);\n+                        fields.add(nextF);\n+                    }\n@@ -738,12 +704,3 @@\n-                \/\/ super(ca...)\n-                mv.visitMethodInsn(INVOKESPECIAL, superClassName,\n-                        \"<init>\", methodSig(superCtorType), false);\n-\n-                \/\/ store down fields\n-                Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n-                for (Var f : fields) {\n-                    \/\/ this.argL1 = argL1\n-                    mv.visitVarInsn(ALOAD, 0);  \/\/ this\n-                    lastFV = new Var(f.name, f.type, lastFV);\n-                    lastFV.emitVarInstruction(ALOAD, mv);\n-                    f.emitFieldInsn(PUTFIELD, mv);\n+                \/\/ emit bound argument fields\n+                for (Var field : fields) {\n+                    clb.withField(field.name, field.desc, ACC_FINAL);\n@@ -752,4 +709,4 @@\n-                mv.visitInsn(RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n+                \/\/ emit implementation of speciesData()\n+                clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                        cob -> cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                  .areturn());\n@@ -757,13 +714,3 @@\n-            \/\/ emit make()  ...factory method wrapping constructor\n-            {\n-                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n-                mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_STATIC,\n-                        \"make\", methodSig(ftryType), null, null);\n-                mv.visitCode();\n-                \/\/ make instance\n-                mv.visitTypeInsn(NEW, className);\n-                mv.visitInsn(DUP);\n-                \/\/ load factory method arguments:  ctarg... and arg...\n-                for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n-                    v.emitVarInstruction(ALOAD, mv);\n-                }\n+                \/\/ figure out the constructor arguments\n+                MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n+                MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n@@ -771,7 +718,3 @@\n-                \/\/ finally, invoke the constructor and return\n-                mv.visitMethodInsn(INVOKESPECIAL, className,\n-                        \"<init>\", methodSig(thisCtorType), false);\n-                mv.visitInsn(ARETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n+                \/\/ emit constructor\n+                clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE, cob -> {\n+                    cob.aload(0); \/\/ this\n@@ -779,35 +722,3 @@\n-            \/\/ For each transform, emit the customized override of the transform method.\n-            \/\/ This method mixes together some incoming arguments (from the transform's\n-            \/\/ static type signature) with the field types themselves, and passes\n-            \/\/ the resulting mish-mosh of values to a method handle produced by\n-            \/\/ the species itself.  (Typically this method handle is the factory\n-            \/\/ method of this species or a related one.)\n-            for (int whichtm = 0; whichtm < TRANSFORM_NAMES.size(); whichtm++) {\n-                final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n-                final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n-                final int        TMODS = TRANSFORM_MODS.get(whichtm);\n-                mv = cw.visitMethod((TMODS & ACC_PPP) | ACC_FINAL,\n-                        TNAME, TTYPE.toMethodDescriptorString(), null, E_THROWABLE);\n-                mv.visitCode();\n-                \/\/ return a call to the corresponding \"transform helper\", something like this:\n-                \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n-                mv.visitFieldInsn(GETSTATIC, className,\n-                        sdFieldName, SPECIES_DATA_SIG);\n-                emitIntConstant(whichtm, mv);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, SPECIES_DATA,\n-                        \"transformHelper\", \"(I)\" + MH_SIG, false);\n-\n-                List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n-                List<Var> tfields = new ArrayList<>(fields);\n-                \/\/ mix them up and load them for the transform helper:\n-                List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n-                List<Class<?>> helperTypes = new ArrayList<>(helperArgs.size());\n-                for (Var ha : helperArgs) {\n-                    helperTypes.add(ha.basicType.basicTypeClass());\n-                    if (ha.isInHeap()) {\n-                        assert(tfields.contains(ha));\n-                        mv.visitVarInsn(ALOAD, 0);\n-                        ha.emitFieldInsn(GETFIELD, mv);\n-                    } else {\n-                        assert(targs.contains(ha));\n-                        ha.emitVarInstruction(ALOAD, mv);\n+                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n+                    for (Var ca : ctorArgs) {\n+                        ca.emitLoadInstruction(cob);\n@@ -815,17 +726,0 @@\n-                }\n-\n-                \/\/ jump into the helper (which is probably a factory method)\n-                final Class<?> rtype = TTYPE.returnType();\n-                final BasicType rbt = BasicType.basicType(rtype);\n-                MethodType invokeBasicType = MethodType.methodType(rbt.basicTypeClass(), helperTypes);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, MH,\n-                        \"invokeBasic\", methodSig(invokeBasicType), false);\n-                if (rbt == BasicType.L_TYPE) {\n-                    mv.visitTypeInsn(CHECKCAST, classBCName(rtype));\n-                    mv.visitInsn(ARETURN);\n-                } else {\n-                    throw newInternalError(\"NYI: transform of type \"+rtype);\n-                }\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n@@ -833,4 +727,12 @@\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n-        }\n+                    \/\/ super(ca...)\n+                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n+\n+                    \/\/ store down fields\n+                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n+                    for (Var f : fields) {\n+                        \/\/ this.argL1 = argL1\n+                        cob.aload(0);  \/\/ this\n+                        lastFV = new Var(f.name, f.type, lastFV);\n+                        lastFV.emitLoadInstruction(cob);\n+                        cob.putfield(classDesc, f.name, f.desc);\n+                    }\n@@ -838,10 +740,2 @@\n-        private int typeLoadOp(char t) {\n-            return switch (t) {\n-                case 'L' -> ALOAD;\n-                case 'I' -> ILOAD;\n-                case 'J' -> LLOAD;\n-                case 'F' -> FLOAD;\n-                case 'D' -> DLOAD;\n-                default -> throw newInternalError(\"unrecognized type \" + t);\n-            };\n-        }\n+                    cob.return_();\n+                });\n@@ -849,10 +743,10 @@\n-        private void emitIntConstant(int con, MethodVisitor mv) {\n-            if (ICONST_M1 - ICONST_0 <= con && con <= ICONST_5 - ICONST_0)\n-                mv.visitInsn(ICONST_0 + con);\n-            else if (con == (byte) con)\n-                mv.visitIntInsn(BIPUSH, con);\n-            else if (con == (short) con)\n-                mv.visitIntInsn(SIPUSH, con);\n-            else {\n-                mv.visitLdcInsn(con);\n-            }\n+                \/\/ emit make()  ...factory method wrapping constructor\n+                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n+                clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC, cob -> {\n+                    \/\/ make instance\n+                    cob.new_(classDesc)\n+                       .dup();\n+                    \/\/ load factory method arguments:  ctarg... and arg...\n+                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n+                        v.emitLoadInstruction(cob);\n+                    }\n@@ -860,0 +754,56 @@\n+                    \/\/ finally, invoke the constructor and return\n+                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n+                       .areturn();\n+                });\n+\n+                \/\/ For each transform, emit the customized override of the transform method.\n+                \/\/ This method mixes together some incoming arguments (from the transform's\n+                \/\/ static type signature) with the field types themselves, and passes\n+                \/\/ the resulting mish-mosh of values to a method handle produced by\n+                \/\/ the species itself.  (Typically this method handle is the factory\n+                \/\/ method of this species or a related one.)\n+                for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n+                    final int whichtm = i;\n+                    final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n+                    final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n+                    final int        TMODS = TRANSFORM_MODS.get(whichtm);\n+                    clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, mb -> {\n+                        mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n+                          .withCode(cob -> {\n+                            \/\/ return a call to the corresponding \"transform helper\", something like this:\n+                            \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n+                            cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                               .loadConstant(whichtm)\n+                               .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n+\n+                            List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n+                            List<Var> tfields = new ArrayList<>(fields);\n+                            \/\/ mix them up and load them for the transform helper:\n+                            List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n+                            ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n+                            for (int hi = 0; hi < helperTypes.length; hi++) {\n+                                Var ha = helperArgs.get(hi);\n+                                helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n+                                if (ha.isInHeap()) {\n+                                    assert(tfields.contains(ha));\n+                                    cob.aload(0);\n+                                    cob.getfield(classDesc, ha.name, ha.desc);\n+                                } else {\n+                                    assert(targs.contains(ha));\n+                                    ha.emitLoadInstruction(cob);\n+                                }\n+                            }\n+\n+                            \/\/ jump into the helper (which is probably a factory method)\n+                            final Class<?> rtype = TTYPE.returnType();\n+                            if (!rtype.isPrimitive()) {\n+                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n+                                   .checkcast(classDesc(rtype))\n+                                   .areturn();\n+                            } else {\n+                                throw newInternalError(\"NYI: transform of type \"+rtype);\n+                            }\n+                        });\n+                    });\n+                }\n+            });\n@@ -993,27 +943,0 @@\n-    private static final String MH = \"java\/lang\/invoke\/MethodHandle\";\n-    private static final String MH_SIG = \"L\" + MH + \";\";\n-    private static final String STABLE = \"jdk\/internal\/vm\/annotation\/Stable\";\n-    private static final String STABLE_SIG = \"L\" + STABLE + \";\";\n-    private static final String[] E_THROWABLE = new String[] { \"java\/lang\/Throwable\" };\n-    static {\n-        assert(MH_SIG.equals(classSig(MethodHandle.class)));\n-        assert(MH.equals(classBCName(MethodHandle.class)));\n-    }\n-\n-    static String methodSig(MethodType mt) {\n-        return mt.toMethodDescriptorString();\n-    }\n-    static String classSig(Class<?> cls) {\n-        if (cls.isPrimitive() || cls.isArray())\n-            return MethodType.methodType(cls).toMethodDescriptorString().substring(2);\n-        return classSig(classBCName(cls));\n-    }\n-    static String classSig(String bcName) {\n-        assert(bcName.indexOf('.') < 0);\n-        assert(!bcName.endsWith(\";\"));\n-        assert(!bcName.startsWith(\"[\"));\n-        return \"L\" + bcName + \";\";\n-    }\n-    static String classBCName(Class<?> cls) {\n-        return classBCName(className(cls));\n-    }\n@@ -1024,3 +947,16 @@\n-    static String className(Class<?> cls) {\n-        assert(!cls.isArray() && !cls.isPrimitive());\n-        return cls.getName();\n+\n+    static ClassDesc classDesc(Class<?> cls) {\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+             : cls == Object.class ? CD_Object\n+             : cls == MethodType.class ? CD_MethodType\n+             : cls == LambdaForm.class ? CD_LambdaForm\n+             : cls == BoundMethodHandle.class ? CD_BoundMethodHandle\n+             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+    }\n+\n+    static MethodTypeDesc methodDesc(MethodType mt) {\n+        var params = new ClassDesc[mt.parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            params[i] = classDesc(mt.parameterType(i));\n+        }\n+        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":219,"deletions":283,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n@@ -32,0 +30,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.constant.ClassDesc;\n@@ -41,0 +42,1 @@\n+import static java.lang.classfile.ClassFile.*;\n@@ -42,2 +44,0 @@\n-import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n-import static java.lang.invoke.MethodTypeForm.*;\n@@ -45,0 +45,1 @@\n+import static java.lang.invoke.MethodTypeForm.*;\n@@ -560,13 +561,8 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(CLASSFILE_VERSION, Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n-                className, null, InvokerBytecodeGenerator.INVOKER_SUPER_NAME, null);\n-        cw.visitSource(className.substring(className.lastIndexOf('\/') + 1), null);\n-\n-        for (int i = 0; i < forms.length; i++) {\n-            InvokerBytecodeGenerator g\n-                = new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType());\n-            g.setClassWriter(cw);\n-            g.addMethod();\n-        }\n-\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.ofInternalName(className), clb -> {\n+            clb.withFlags(ACC_PRIVATE | ACC_FINAL | ACC_SUPER)\n+               .withSuperclass(InvokerBytecodeGenerator.INVOKER_SUPER_DESC)\n+               .with(SourceFileAttribute.of(className.substring(className.lastIndexOf('\/') + 1)));\n+            for (int i = 0; i < forms.length; i++) {\n+                new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType()).addMethod(clb);\n+            }\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -31,1 +30,0 @@\n-import sun.invoke.util.BytecodeDescriptor;\n@@ -36,1 +34,10 @@\n-import java.lang.constant.ConstantDescs;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.MethodBuilder;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -39,0 +46,1 @@\n+import java.util.List;\n@@ -40,2 +48,8 @@\n-\n-import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n+import java.util.function.Consumer;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -45,1 +59,4 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+import sun.invoke.util.Wrapper;\n@@ -54,3 +71,0 @@\n-    private static final String METHOD_DESCRIPTOR_VOID = Type.getMethodDescriptor(Type.VOID_TYPE);\n-    private static final String JAVA_LANG_OBJECT = \"java\/lang\/Object\";\n-    private static final String NAME_CTOR = \"<init>\";\n@@ -58,22 +72,0 @@\n-\n-    \/\/Serialization support\n-    private static final String NAME_SERIALIZED_LAMBDA = \"java\/lang\/invoke\/SerializedLambda\";\n-    private static final String NAME_NOT_SERIALIZABLE_EXCEPTION = \"java\/io\/NotSerializableException\";\n-    private static final String DESCR_METHOD_WRITE_REPLACE = \"()Ljava\/lang\/Object;\";\n-    private static final String DESCR_METHOD_WRITE_OBJECT = \"(Ljava\/io\/ObjectOutputStream;)V\";\n-    private static final String DESCR_METHOD_READ_OBJECT = \"(Ljava\/io\/ObjectInputStream;)V\";\n-\n-    private static final String NAME_METHOD_WRITE_REPLACE = \"writeReplace\";\n-    private static final String NAME_METHOD_READ_OBJECT = \"readObject\";\n-    private static final String NAME_METHOD_WRITE_OBJECT = \"writeObject\";\n-\n-    private static final String DESCR_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String DESCR_STRING = \"Ljava\/lang\/String;\";\n-    private static final String DESCR_OBJECT = \"Ljava\/lang\/Object;\";\n-    private static final String DESCR_CTOR_SERIALIZED_LAMBDA\n-            = \"(\" + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + \"I\"\n-            + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + \"[\" + DESCR_OBJECT + \")V\";\n-\n-    private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = \"(Ljava\/lang\/String;)V\";\n-    private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};\n-\n@@ -81,0 +73,15 @@\n+    private static final ClassDesc[] EMPTY_CLASSDESC_ARRAY = ConstantUtils.EMPTY_CLASSDESC;\n+\n+    \/\/ Static builders to avoid lambdas\n+    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n+        @Override\n+        public void accept(FieldBuilder fb) {\n+            fb.withFlags(flags);\n+        }\n+    };\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n@@ -88,1 +95,1 @@\n-    private static final ConstantDynamic implMethodCondy;\n+    private static final DynamicConstantDesc<?> implMethodCondy;\n@@ -101,4 +108,1 @@\n-        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n-        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n-                                         classDataMType.descriptorString(), false);\n-        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm);\n+        implMethodCondy = DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, CD_MethodHandle);\n@@ -108,1 +112,1 @@\n-    private final String implMethodClassName;        \/\/ Name of type containing implementation \"CC\"\n+    private final ClassDesc implMethodClassDesc;     \/\/ Name of type containing implementation \"CC\"\n@@ -110,1 +114,1 @@\n-    private final String implMethodDesc;             \/\/ Type descriptor for implementation methods \"(I)Ljava\/lang\/String;\"\n+    private final MethodTypeDesc implMethodDesc;     \/\/ Type descriptor for implementation methods \"(I)Ljava\/lang\/String;\"\n@@ -112,1 +116,1 @@\n-    private final ClassWriter cw;                    \/\/ ASM class writer\n+    private final MethodTypeDesc constructorTypeDesc;\/\/ Type descriptor for the generated class constructor type \"(CC)void\"\n@@ -114,2 +118,3 @@\n-    private final String[] argDescs;                 \/\/ Type descriptors for the constructor arguments\n-    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda\"\n+    private final ClassDesc[] argDescs;              \/\/ Type descriptors for the constructor arguments\n+    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda$1\"\n+    private final ClassDesc lambdaClassDesc;         \/\/ Type descriptor for the generated class \"X$$Lambda$1\"\n@@ -171,1 +176,1 @@\n-        implMethodClassName = implClass.getName().replace('.', '\/');\n+        implMethodClassDesc = implClassDesc(implClass);\n@@ -173,1 +178,1 @@\n-        implMethodDesc = implInfo.getMethodType().toMethodDescriptorString();\n+        implMethodDesc = methodDesc(implInfo.getMethodType());\n@@ -175,0 +180,1 @@\n+        constructorTypeDesc = methodDesc(constructorType);\n@@ -176,0 +182,1 @@\n+        lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n@@ -185,3 +192,2 @@\n-                               implKind == H_INVOKESPECIAL ||\n-                               implKind == H_INVOKESTATIC && implClass.isHidden();\n-        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+                               implKind == MethodHandleInfo.REF_invokeSpecial ||\n+                               implKind == MethodHandleInfo.REF_invokeStatic && implClass.isHidden();\n@@ -191,1 +197,1 @@\n-            argDescs = new String[parameterCount];\n+            argDescs = new ClassDesc[parameterCount];\n@@ -194,1 +200,1 @@\n-                argDescs[i] = BytecodeDescriptor.unparse(factoryType.parameterType(i));\n+                argDescs[i] = classDesc(factoryType.parameterType(i));\n@@ -197,1 +203,2 @@\n-            argNames = argDescs = EMPTY_STRING_ARRAY;\n+            argNames = EMPTY_STRING_ARRAY;\n+            argDescs = EMPTY_CLASSDESC_ARRAY;\n@@ -303,2 +310,2 @@\n-        String[] interfaceNames;\n-        String interfaceName = interfaceClass.getName().replace('.', '\/');\n+        List<ClassDesc> interfaces;\n+        ClassDesc interfaceDesc = classDesc(interfaceClass);\n@@ -307,1 +314,1 @@\n-            interfaceNames = new String[]{interfaceName};\n+            interfaces = List.of(interfaceDesc);\n@@ -310,2 +317,2 @@\n-            Set<String> itfs = LinkedHashSet.newLinkedHashSet(altInterfaces.length + 1);\n-            itfs.add(interfaceName);\n+            Set<ClassDesc> itfs = LinkedHashSet.newLinkedHashSet(altInterfaces.length + 1);\n+            itfs.add(interfaceDesc);\n@@ -313,1 +320,1 @@\n-                itfs.add(i.getName().replace('.', '\/'));\n+                itfs.add(classDesc(i));\n@@ -316,1 +323,1 @@\n-            interfaceNames = itfs.toArray(new String[itfs.size()]);\n+            interfaces = List.copyOf(itfs);\n@@ -318,0 +325,10 @@\n+        final boolean finalAccidentallySerializable = accidentallySerializable;\n+        final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                clb.withFlags(ACC_SUPER | ACC_FINAL | ACC_SYNTHETIC)\n+                   .withInterfaceSymbols(interfaces);\n+                \/\/ Generate final fields to be filled in by constructor\n+                for (int i = 0; i < argDescs.length; i++) {\n+                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                }\n@@ -319,12 +336,1 @@\n-        cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,\n-                 lambdaClassName, null,\n-                 JAVA_LANG_OBJECT, interfaceNames);\n-\n-        \/\/ Generate final fields to be filled in by constructor\n-        for (int i = 0; i < argDescs.length; i++) {\n-            FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,\n-                                            argNames[i],\n-                                            argDescs[i],\n-                                            null, null);\n-            fv.visitEnd();\n-        }\n+                generateConstructor(clb);\n@@ -332,1 +338,3 @@\n-        generateConstructor();\n+                if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+                    generateClassInitializer(clb);\n+                }\n@@ -334,3 +342,15 @@\n-        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n-            generateClassInitializer();\n-        }\n+                \/\/ Forward the SAM method\n+                clb.withMethod(interfaceMethodName,\n+                        methodDesc(interfaceMethodType),\n+                        ACC_PUBLIC,\n+                        forwardingMethod(interfaceMethodType));\n+\n+                \/\/ Forward the bridges\n+                if (altMethods != null) {\n+                    for (MethodType mt : altMethods) {\n+                        clb.withMethod(interfaceMethodName,\n+                                methodDesc(mt),\n+                                ACC_PUBLIC | ACC_BRIDGE,\n+                                forwardingMethod(mt));\n+                    }\n+                }\n@@ -338,11 +358,4 @@\n-        \/\/ Forward the SAM method\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n-                                          interfaceMethodType.toMethodDescriptorString(), null, null);\n-        new ForwardingMethodGenerator(mv).generate(interfaceMethodType);\n-\n-        \/\/ Forward the altMethods\n-        if (altMethods != null) {\n-            for (MethodType mt : altMethods) {\n-                mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n-                                    mt.toMethodDescriptorString(), null, null);\n-                new ForwardingMethodGenerator(mv).generate(mt);\n+                if (isSerializable)\n+                    generateSerializationFriendlyMethods(clb);\n+                else if (finalAccidentallySerializable)\n+                    generateSerializationHostileMethods(clb);\n@@ -350,8 +363,1 @@\n-        }\n-\n-        if (isSerializable)\n-            generateSerializationFriendlyMethods();\n-        else if (accidentallySerializable)\n-            generateSerializationHostileMethods();\n-\n-        cw.visitEnd();\n+        });\n@@ -361,1 +367,0 @@\n-        final byte[] classBytes = cw.toByteArray();\n@@ -376,2 +381,2 @@\n-    private void generateClassInitializer() {\n-        String lambdaTypeDescriptor = factoryType.returnType().descriptorString();\n+    private void generateClassInitializer(ClassBuilder clb) {\n+        ClassDesc lambdaTypeDescriptor = classDesc(factoryType.returnType());\n@@ -380,3 +385,1 @@\n-        FieldVisitor fv = cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,\n-                LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, null, null);\n-        fv.visitEnd();\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n@@ -385,12 +388,11 @@\n-        MethodVisitor clinit = cw.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        clinit.visitCode();\n-\n-        clinit.visitTypeInsn(NEW, lambdaClassName);\n-        clinit.visitInsn(Opcodes.DUP);\n-        assert factoryType.parameterCount() == 0;\n-        clinit.visitMethodInsn(INVOKESPECIAL, lambdaClassName, NAME_CTOR, constructorType.toMethodDescriptorString(), false);\n-        clinit.visitFieldInsn(PUTSTATIC, lambdaClassName, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor);\n-\n-        clinit.visitInsn(RETURN);\n-        clinit.visitMaxs(-1, -1);\n-        clinit.visitEnd();\n+        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                assert factoryType.parameterCount() == 0;\n+                cob.new_(lambdaClassDesc)\n+                   .dup()\n+                   .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n+                   .putstatic(lambdaClassDesc, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)\n+                   .return_();\n+            }\n+        }));\n@@ -402,1 +404,1 @@\n-    private void generateConstructor() {\n+    private void generateConstructor(ClassBuilder clb) {\n@@ -404,18 +406,36 @@\n-        MethodVisitor ctor = cw.visitMethod(ACC_PRIVATE, NAME_CTOR,\n-                                            constructorType.toMethodDescriptorString(), null, null);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JAVA_LANG_OBJECT, NAME_CTOR,\n-                             METHOD_DESCRIPTOR_VOID, false);\n-        int parameterCount = factoryType.parameterCount();\n-        for (int i = 0, lvIndex = 0; i < parameterCount; i++) {\n-            ctor.visitVarInsn(ALOAD, 0);\n-            Class<?> argType = factoryType.parameterType(i);\n-            ctor.visitVarInsn(getLoadOpcode(argType), lvIndex + 1);\n-            lvIndex += getParameterSize(argType);\n-            ctor.visitFieldInsn(PUTFIELD, lambdaClassName, argNames[i], argDescs[i]);\n-        }\n-        ctor.visitInsn(RETURN);\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new MethodBody(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        cob.aload(0)\n+                           .invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                        int parameterCount = factoryType.parameterCount();\n+                        for (int i = 0; i < parameterCount; i++) {\n+                            cob.aload(0);\n+                            Class<?> argType = factoryType.parameterType(i);\n+                            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n+                            cob.putfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                        }\n+                        cob.return_();\n+                    }\n+                }));\n+    }\n+\n+    private static class SerializationSupport {\n+        \/\/ Serialization support\n+        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final MethodTypeDesc MTD_Object = MethodTypeDescImpl.ofValidated(CD_Object);\n+        private static final MethodTypeDesc MTD_void_ObjectOutputStream = MethodTypeDescImpl.ofValidated(CD_void, CD_ObjectOutputStream);\n+        private static final MethodTypeDesc MTD_void_ObjectInputStream = MethodTypeDescImpl.ofValidated(CD_void, CD_ObjectInputStream);\n+\n+        private static final String NAME_METHOD_WRITE_REPLACE = \"writeReplace\";\n+        private static final String NAME_METHOD_READ_OBJECT = \"readObject\";\n+        private static final String NAME_METHOD_WRITE_OBJECT = \"writeObject\";\n+\n+        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final MethodTypeDesc MTD_CTOR_NOT_SERIALIZABLE_EXCEPTION = MethodTypeDescImpl.ofValidated(CD_void, CD_String);\n+        static final MethodTypeDesc MTD_CTOR_SERIALIZED_LAMBDA = MethodTypeDescImpl.ofValidated(CD_void,\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+\n@@ -427,35 +447,31 @@\n-    private void generateSerializationFriendlyMethods() {\n-        TypeConvertingMethodAdapter mv\n-                = new TypeConvertingMethodAdapter(\n-                    cw.visitMethod(ACC_PRIVATE + ACC_FINAL,\n-                    NAME_METHOD_WRITE_REPLACE, DESCR_METHOD_WRITE_REPLACE,\n-                    null, null));\n-\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, NAME_SERIALIZED_LAMBDA);\n-        mv.visitInsn(DUP);\n-        mv.visitLdcInsn(Type.getType(targetClass));\n-        mv.visitLdcInsn(factoryType.returnType().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(interfaceMethodName);\n-        mv.visitLdcInsn(interfaceMethodType.toMethodDescriptorString());\n-        mv.visitLdcInsn(implInfo.getReferenceKind());\n-        mv.visitLdcInsn(implInfo.getDeclaringClass().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(implInfo.getName());\n-        mv.visitLdcInsn(implInfo.getMethodType().toMethodDescriptorString());\n-        mv.visitLdcInsn(dynamicMethodType.toMethodDescriptorString());\n-        mv.iconst(argDescs.length);\n-        mv.visitTypeInsn(ANEWARRAY, JAVA_LANG_OBJECT);\n-        for (int i = 0; i < argDescs.length; i++) {\n-            mv.visitInsn(DUP);\n-            mv.iconst(i);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);\n-            mv.boxIfTypePrimitive(Type.getType(argDescs[i]));\n-            mv.visitInsn(AASTORE);\n-        }\n-        mv.visitMethodInsn(INVOKESPECIAL, NAME_SERIALIZED_LAMBDA, NAME_CTOR,\n-                DESCR_CTOR_SERIALIZED_LAMBDA, false);\n-        mv.visitInsn(ARETURN);\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateSerializationFriendlyMethods(ClassBuilder clb) {\n+        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new MethodBody(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        cob.new_(SerializationSupport.CD_SerializedLambda)\n+                           .dup()\n+                           .ldc(classDesc(targetClass))\n+                           .ldc(factoryType.returnType().getName().replace('.', '\/'))\n+                           .ldc(interfaceMethodName)\n+                           .ldc(interfaceMethodType.toMethodDescriptorString())\n+                           .ldc(implInfo.getReferenceKind())\n+                           .ldc(implInfo.getDeclaringClass().getName().replace('.', '\/'))\n+                           .ldc(implInfo.getName())\n+                           .ldc(implInfo.getMethodType().toMethodDescriptorString())\n+                           .ldc(dynamicMethodType.toMethodDescriptorString())\n+                           .loadConstant(argDescs.length)\n+                           .anewarray(CD_Object);\n+                        for (int i = 0; i < argDescs.length; i++) {\n+                            cob.dup()\n+                               .loadConstant(i)\n+                               .aload(0)\n+                               .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+                            cob.aastore();\n+                        }\n+                        cob.invokespecial(SerializationSupport.CD_SerializedLambda, INIT_NAME,\n+                                          SerializationSupport.MTD_CTOR_SERIALIZED_LAMBDA)\n+                           .areturn();\n+                    }\n+                }));\n@@ -467,26 +483,24 @@\n-    private void generateSerializationHostileMethods() {\n-        MethodVisitor mv = cw.visitMethod(ACC_PRIVATE + ACC_FINAL,\n-                                          NAME_METHOD_WRITE_OBJECT, DESCR_METHOD_WRITE_OBJECT,\n-                                          null, SER_HOSTILE_EXCEPTIONS);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, NAME_NOT_SERIALIZABLE_EXCEPTION);\n-        mv.visitInsn(DUP);\n-        mv.visitLdcInsn(\"Non-serializable lambda\");\n-        mv.visitMethodInsn(INVOKESPECIAL, NAME_NOT_SERIALIZABLE_EXCEPTION, NAME_CTOR,\n-                           DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION, false);\n-        mv.visitInsn(ATHROW);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PRIVATE + ACC_FINAL,\n-                            NAME_METHOD_READ_OBJECT, DESCR_METHOD_READ_OBJECT,\n-                            null, SER_HOSTILE_EXCEPTIONS);\n-        mv.visitCode();\n-        mv.visitTypeInsn(NEW, NAME_NOT_SERIALIZABLE_EXCEPTION);\n-        mv.visitInsn(DUP);\n-        mv.visitLdcInsn(\"Non-serializable lambda\");\n-        mv.visitMethodInsn(INVOKESPECIAL, NAME_NOT_SERIALIZABLE_EXCEPTION, NAME_CTOR,\n-                           DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION, false);\n-        mv.visitInsn(ATHROW);\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private void generateSerializationHostileMethods(ClassBuilder clb) {\n+        var hostileMethod = new Consumer<MethodBuilder>() {\n+            @Override\n+            public void accept(MethodBuilder mb) {\n+                ConstantPoolBuilder cp = mb.constantPool();\n+                ClassEntry nseCE = cp.classEntry(SerializationSupport.CD_NotSerializableException);\n+                mb.with(ExceptionsAttribute.of(nseCE))\n+                        .withCode(new Consumer<CodeBuilder>() {\n+                            @Override\n+                            public void accept(CodeBuilder cob) {\n+                                cob.new_(nseCE)\n+                                        .dup()\n+                                        .ldc(\"Non-serializable lambda\")\n+                                        .invokespecial(cp.methodRefEntry(nseCE, cp.nameAndTypeEntry(INIT_NAME,\n+                                                SerializationSupport.MTD_CTOR_NOT_SERIALIZABLE_EXCEPTION)))\n+                                        .athrow();\n+                            }\n+                        });\n+            }\n+        };\n+        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_OBJECT, SerializationSupport.MTD_void_ObjectOutputStream,\n+                ACC_PRIVATE + ACC_FINAL, hostileMethod);\n+        clb.withMethod(SerializationSupport.NAME_METHOD_READ_OBJECT, SerializationSupport.MTD_void_ObjectInputStream,\n+                ACC_PRIVATE + ACC_FINAL, hostileMethod);\n@@ -495,0 +509,1 @@\n+\n@@ -496,1 +511,1 @@\n-     * This class generates a method body which calls the lambda implementation\n+     * This method generates a method body which calls the lambda implementation\n@@ -499,20 +514,15 @@\n-    private class ForwardingMethodGenerator extends TypeConvertingMethodAdapter {\n-\n-        ForwardingMethodGenerator(MethodVisitor mv) {\n-            super(mv);\n-        }\n-\n-        void generate(MethodType methodType) {\n-            visitCode();\n-\n-            if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {\n-                visitTypeInsn(NEW, implMethodClassName);\n-                visitInsn(DUP);\n-            }\n-            if (useImplMethodHandle) {\n-                visitLdcInsn(implMethodCondy);\n-            }\n-            for (int i = 0; i < argNames.length; i++) {\n-                visitVarInsn(ALOAD, 0);\n-                visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);\n-            }\n+    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n+        return new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {\n+                    cob.new_(implMethodClassDesc)\n+                       .dup();\n+                }\n+                if (useImplMethodHandle) {\n+                    cob.ldc(implMethodCondy);\n+                }\n+                for (int i = 0; i < argNames.length; i++) {\n+                    cob.aload(0)\n+                       .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                }\n@@ -520,1 +530,1 @@\n-            convertArgumentTypes(methodType);\n+                convertArgumentTypes(cob, methodType);\n@@ -522,4 +532,9 @@\n-            if (useImplMethodHandle) {\n-                MethodType mtype = implInfo.getMethodType();\n-                if (implKind != MethodHandleInfo.REF_invokeStatic) {\n-                    mtype = mtype.insertParameterTypes(0, implClass);\n+                if (useImplMethodHandle) {\n+                    MethodType mtype = implInfo.getMethodType();\n+                    if (implKind != MethodHandleInfo.REF_invokeStatic) {\n+                        mtype = mtype.insertParameterTypes(0, implClass);\n+                    }\n+                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(mtype));\n+                } else {\n+                    \/\/ Invoke the method we want to forward to\n+                    cob.invoke(invocationOpcode(), implMethodClassDesc, implMethodName, implMethodDesc, implClass.isInterface());\n@@ -527,29 +542,7 @@\n-                visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n-                                \"invokeExact\", mtype.descriptorString(), false);\n-            } else {\n-                \/\/ Invoke the method we want to forward to\n-                visitMethodInsn(invocationOpcode(), implMethodClassName,\n-                                implMethodName, implMethodDesc,\n-                                implClass.isInterface());\n-            }\n-            \/\/ Convert the return value (if any) and return it\n-            \/\/ Note: if adapting from non-void to void, the 'return'\n-            \/\/ instruction will pop the unneeded result\n-            Class<?> implReturnClass = implMethodType.returnType();\n-            Class<?> samReturnClass = methodType.returnType();\n-            convertType(implReturnClass, samReturnClass, samReturnClass);\n-            visitInsn(getReturnOpcode(samReturnClass));\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS,these arguments ignored\n-            visitMaxs(-1, -1);\n-            visitEnd();\n-        }\n-\n-        private void convertArgumentTypes(MethodType samType) {\n-            int lvIndex = 0;\n-            int samParametersLength = samType.parameterCount();\n-            int captureArity = factoryType.parameterCount();\n-            for (int i = 0; i < samParametersLength; i++) {\n-                Class<?> argType = samType.parameterType(i);\n-                visitVarInsn(getLoadOpcode(argType), lvIndex + 1);\n-                lvIndex += getParameterSize(argType);\n-                convertType(argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n+                \/\/ Convert the return value (if any) and return it\n+                \/\/ Note: if adapting from non-void to void, the 'return'\n+                \/\/ instruction will pop the unneeded result\n+                Class<?> implReturnClass = implMethodType.returnType();\n+                Class<?> samReturnClass = methodType.returnType();\n+                TypeConvertingMethodAdapter.convertType(cob, implReturnClass, samReturnClass, samReturnClass);\n+                cob.return_(TypeKind.from(samReturnClass));\n@@ -557,1 +550,2 @@\n-        }\n+        });\n+    }\n@@ -559,9 +553,7 @@\n-        private int invocationOpcode() throws InternalError {\n-            return switch (implKind) {\n-                case MethodHandleInfo.REF_invokeStatic     -> INVOKESTATIC;\n-                case MethodHandleInfo.REF_newInvokeSpecial -> INVOKESPECIAL;\n-                case MethodHandleInfo.REF_invokeVirtual    -> INVOKEVIRTUAL;\n-                case MethodHandleInfo.REF_invokeInterface  -> INVOKEINTERFACE;\n-                case MethodHandleInfo.REF_invokeSpecial    -> INVOKESPECIAL;\n-                default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n-            };\n+    private void convertArgumentTypes(CodeBuilder cob, MethodType samType) {\n+        int samParametersLength = samType.parameterCount();\n+        int captureArity = factoryType.parameterCount();\n+        for (int i = 0; i < samParametersLength; i++) {\n+            Class<?> argType = samType.parameterType(i);\n+            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n+            TypeConvertingMethodAdapter.convertType(cob, argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n@@ -571,7 +563,9 @@\n-    static int getParameterSize(Class<?> c) {\n-        if (c == Void.TYPE) {\n-            return 0;\n-        } else if (c == Long.TYPE || c == Double.TYPE) {\n-            return 2;\n-        }\n-        return 1;\n+    private Opcode invocationOpcode() throws InternalError {\n+        return switch (implKind) {\n+            case MethodHandleInfo.REF_invokeStatic     -> Opcode.INVOKESTATIC;\n+            case MethodHandleInfo.REF_newInvokeSpecial -> Opcode.INVOKESPECIAL;\n+            case MethodHandleInfo.REF_invokeVirtual    -> Opcode.INVOKEVIRTUAL;\n+            case MethodHandleInfo.REF_invokeInterface  -> Opcode.INVOKEINTERFACE;\n+            case MethodHandleInfo.REF_invokeSpecial    -> Opcode.INVOKESPECIAL;\n+            default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n+        };\n@@ -580,5 +574,2 @@\n-    static int getLoadOpcode(Class<?> c) {\n-        if(c == Void.TYPE) {\n-            throw new InternalError(\"Unexpected void type of load opcode\");\n-        }\n-        return ILOAD + getOpcodeOffset(c);\n+    static ClassDesc implClassDesc(Class<?> cls) {\n+        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n@@ -587,5 +578,3 @@\n-    static int getReturnOpcode(Class<?> c) {\n-        if(c == Void.TYPE) {\n-            return RETURN;\n-        }\n-        return IRETURN + getOpcodeOffset(c);\n+    static ClassDesc classDesc(Class<?> cls) {\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n@@ -594,12 +583,4 @@\n-    private static int getOpcodeOffset(Class<?> c) {\n-        if (c.isPrimitive()) {\n-            if (c == Long.TYPE) {\n-                return 1;\n-            } else if (c == Float.TYPE) {\n-                return 2;\n-            } else if (c == Double.TYPE) {\n-                return 3;\n-            }\n-            return 0;\n-        } else {\n-            return 4;\n+    static MethodTypeDesc methodDesc(MethodType mt) {\n+        var params = new ClassDesc[mt.parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            params[i] = classDesc(mt.parameterType(i));\n@@ -607,0 +588,1 @@\n+        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n@@ -608,1 +590,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":265,"deletions":284,"binary":false,"changes":549,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -38,0 +32,10 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.SourceFileAttribute;\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.LambdaForm.BasicType;\n+import java.lang.invoke.LambdaForm.Name;\n+import java.lang.invoke.LambdaForm.NamedFunction;\n@@ -44,0 +48,1 @@\n+import java.util.function.Consumer;\n@@ -45,0 +50,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -46,2 +53,2 @@\n-import static java.lang.invoke.LambdaForm.BasicType;\n-import static java.lang.invoke.LambdaForm.BasicType.*;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -49,0 +56,1 @@\n+import static java.lang.invoke.LambdaForm.BasicType.*;\n@@ -51,1 +59,1 @@\n-import static java.lang.invoke.MethodHandles.Lookup.*;\n+import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;\n@@ -60,18 +68,16 @@\n-    private static final String MH      = \"java\/lang\/invoke\/MethodHandle\";\n-    private static final String MHI     = \"java\/lang\/invoke\/MethodHandleImpl\";\n-    private static final String LF      = \"java\/lang\/invoke\/LambdaForm\";\n-    private static final String LFN     = \"java\/lang\/invoke\/LambdaForm$Name\";\n-    private static final String CLS     = \"java\/lang\/Class\";\n-    private static final String OBJ     = \"java\/lang\/Object\";\n-    private static final String OBJARY  = \"[Ljava\/lang\/Object;\";\n-\n-    private static final String LOOP_CLAUSES = MHI + \"$LoopClauses\";\n-    private static final String MHARY2       = \"[[L\" + MH + \";\";\n-    private static final String MH_SIG       = \"L\" + MH + \";\";\n-\n-\n-    private static final String LF_SIG  = \"L\" + LF + \";\";\n-    private static final String LFN_SIG = \"L\" + LFN + \";\";\n-    private static final String LL_SIG  = \"(L\" + OBJ + \";)L\" + OBJ + \";\";\n-    private static final String LLV_SIG = \"(L\" + OBJ + \";L\" + OBJ + \";)V\";\n-    private static final String CLASS_PREFIX = LF + \"$\";\n+    private static final ClassDesc CD_CasesHolder = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n+    private static final ClassDesc CD_DirectMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n+    private static final ClassDesc CD_MethodHandleImpl = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n+    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_LambdaForm_Name = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n+    private static final ClassDesc CD_LoopClauses = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n+    private static final ClassDesc CD_Object_array  = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+    private static final ClassDesc CD_MethodHandle_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_MethodHandle_array2 = ReferenceClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n+\n+    private static final MethodTypeDesc MTD_boolean_Object = MethodTypeDescImpl.ofValidated(CD_boolean, CD_Object);\n+    private static final MethodTypeDesc MTD_Object_int = MethodTypeDescImpl.ofValidated(CD_Object, CD_int);\n+    private static final MethodTypeDesc MTD_Object_Class = MethodTypeDescImpl.ofValidated(CD_Object, CD_Class);\n+    private static final MethodTypeDesc MTD_Object_Object = MethodTypeDescImpl.ofValidated(CD_Object, CD_Object);\n+\n+    private static final String CLASS_PREFIX = \"java\/lang\/invoke\/LambdaForm$\";\n@@ -80,0 +86,15 @@\n+    \/\/ Static builders to avoid lambdas\n+    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n+        @Override\n+        public void accept(FieldBuilder fb) {\n+            fb.withFlags(ACC_STATIC | ACC_FINAL);\n+        }\n+    };\n+\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n+\n@@ -81,1 +102,1 @@\n-    static final String INVOKER_SUPER_NAME = OBJ;\n+    static final ClassDesc INVOKER_SUPER_DESC = CD_Object;\n@@ -86,0 +107,1 @@\n+    private final ClassDesc classDesc;\n@@ -95,3 +117,0 @@\n-    \/** ASM bytecode generation. *\/\n-    private ClassWriter cw;\n-    private MethodVisitor mv;\n@@ -100,4 +119,0 @@\n-    \/** Single element internal class name lookup cache. *\/\n-    private Class<?> lastClass;\n-    private String lastInternalName;\n-\n@@ -129,0 +144,1 @@\n+        this.classDesc = ClassDesc.ofInternalName(className);\n@@ -191,1 +207,1 @@\n-        final String desc;\n+        final ClassDesc desc;\n@@ -194,1 +210,1 @@\n-        ClassData(String name, String desc, Object value) {\n+        ClassData(String name, ClassDesc desc, Object value) {\n@@ -207,1 +223,1 @@\n-        String desc;\n+        ClassDesc desc;\n@@ -209,1 +225,1 @@\n-            desc = \"Ljava\/lang\/Class;\";\n+            desc = CD_Class;\n@@ -211,1 +227,1 @@\n-            desc = MH_SIG;\n+            desc = CD_MethodHandle;\n@@ -213,1 +229,1 @@\n-            desc = LF_SIG;\n+            desc = CD_LambdaForm;\n@@ -215,1 +231,1 @@\n-            desc = \"Ljava\/lang\/Object;\";\n+            desc = CD_Object;\n@@ -234,10 +250,0 @@\n-    private static String debugString(Object arg) {\n-        if (arg instanceof MethodHandle mh) {\n-            MemberName member = mh.internalMemberName();\n-            if (member != null)\n-                return member.toString();\n-            return mh.debugString();\n-        }\n-        return arg.toString();\n-    }\n-\n@@ -268,13 +274,14 @@\n-    private ClassWriter classFilePrologue() {\n-        final int NOT_ACC_PUBLIC = 0;  \/\/ not ACC_PUBLIC\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        setClassWriter(cw);\n-        cw.visit(CLASSFILE_VERSION, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,\n-                className, null, INVOKER_SUPER_NAME, null);\n-        cw.visitSource(SOURCE_PREFIX + name, null);\n-        return cw;\n-    }\n-\n-    private void methodPrologue() {\n-        String invokerDesc = invokerType.toMethodDescriptorString();\n-        mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);\n+    private byte[] classFileSetup(Consumer<? super ClassBuilder> config) {\n+        try {\n+            return ClassFile.of().build(classDesc, new Consumer<>() {\n+                @Override\n+                public void accept(ClassBuilder clb) {\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                       .withSuperclass(INVOKER_SUPER_DESC)\n+                       .with(SourceFileAttribute.of(clb.constantPool().utf8Entry(SOURCE_PREFIX + name)));\n+                    config.accept(clb);\n+                }\n+            });\n+        } catch (RuntimeException e) {\n+            throw new BytecodeGenerationException(e);\n+        }\n@@ -283,6 +290,3 @@\n-    \/**\n-     * Tear down class file generation.\n-     *\/\n-    private void methodEpilogue() {\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n+    private void methodSetup(ClassBuilder clb, Consumer<? super MethodBuilder> config) {\n+        var invokerDesc = methodDesc(invokerType);\n+        clb.withMethod(invokerName, invokerDesc, ACC_STATIC, config);\n@@ -321,1 +325,1 @@\n-    static void clinit(ClassWriter cw, String className, List<ClassData> classData) {\n+    static void clinit(ClassBuilder clb, ClassDesc classDesc, List<ClassData> classData) {\n@@ -327,75 +331,12 @@\n-            FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);\n-            fv.visitEnd();\n-        }\n-\n-        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitLdcInsn(Type.getType(\"L\" + className + \";\"));\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\",\n-                           \"classData\", \"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\", false);\n-        if (classData.size() == 1) {\n-            ClassData p = classData.get(0);\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n-            mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n-        } else {\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, \"java\/util\/List\");\n-            mv.visitVarInsn(Opcodes.ASTORE, 0);\n-            int index = 0;\n-            for (ClassData p : classData) {\n-                \/\/ initialize the static field\n-                mv.visitVarInsn(Opcodes.ALOAD, 0);\n-                emitIconstInsn(mv, index++);\n-                mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, \"java\/util\/List\",\n-                                   \"get\", \"(I)Ljava\/lang\/Object;\", true);\n-                mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));\n-                mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);\n-            }\n-        }\n-        mv.visitInsn(Opcodes.RETURN);\n-        mv.visitMaxs(2, 1);\n-        mv.visitEnd();\n-    }\n-\n-    \/*\n-     * Low-level emit helpers.\n-     *\/\n-    private void emitConst(Object con) {\n-        if (con == null) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-            return;\n-        }\n-        if (con instanceof Integer) {\n-            emitIconstInsn((int) con);\n-            return;\n-        }\n-        if (con instanceof Byte) {\n-            emitIconstInsn((byte)con);\n-            return;\n-        }\n-        if (con instanceof Short) {\n-            emitIconstInsn((short)con);\n-            return;\n-        }\n-        if (con instanceof Character) {\n-            emitIconstInsn((char)con);\n-            return;\n-        }\n-        if (con instanceof Long) {\n-            long x = (long) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2L);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Float) {\n-            float x = (float) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 2) {\n-                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n+            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n+        }\n+\n+        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                cob.loadConstant(classDesc)\n+                   .invokestatic(CD_MethodHandles, \"classData\", MTD_Object_Class);\n+                if (classData.size() == 1) {\n+                    ClassData p = classData.get(0);\n+                    cob.checkcast(p.desc)\n+                       .putstatic(classDesc, p.name, p.desc);\n@@ -403,15 +344,12 @@\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2F);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Double) {\n-            double x = (double) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2D);\n+                    cob.checkcast(CD_List)\n+                       .astore(0);\n+                    int index = 0;\n+                    var listGet = cob.constantPool().interfaceMethodRefEntry(CD_List, \"get\", MTD_Object_int);\n+                    for (ClassData p : classData) {\n+                        \/\/ initialize the static field\n+                        cob.aload(0)\n+                           .loadConstant(index++)\n+                           .invokeinterface(listGet)\n+                           .checkcast(p.desc)\n+                           .putstatic(classDesc, p.name, p.desc);\n+                    }\n@@ -419,1 +357,1 @@\n-                return;\n+                cob.return_();\n@@ -421,31 +359,1 @@\n-        }\n-        if (con instanceof Boolean) {\n-            emitIconstInsn((boolean) con ? 1 : 0);\n-            return;\n-        }\n-        \/\/ fall through:\n-        mv.visitLdcInsn(con);\n-    }\n-\n-    private void emitIconstInsn(final int cst) {\n-        emitIconstInsn(mv, cst);\n-    }\n-\n-    private static void emitIconstInsn(MethodVisitor mv, int cst) {\n-        if (cst >= -1 && cst <= 5) {\n-            mv.visitInsn(Opcodes.ICONST_0 + cst);\n-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-        } else {\n-            mv.visitLdcInsn(cst);\n-        }\n-    }\n-\n-    \/*\n-     * NOTE: These load\/store methods use the localsMap to find the correct index!\n-     *\/\n-    private void emitLoadInsn(BasicType type, int index) {\n-        int opcode = loadInsnOpcode(type);\n-        mv.visitVarInsn(opcode, localsMap[index]);\n+        }));\n@@ -454,12 +362,2 @@\n-    private int loadInsnOpcode(BasicType type) throws InternalError {\n-        return switch (type) {\n-            case I_TYPE -> Opcodes.ILOAD;\n-            case J_TYPE -> Opcodes.LLOAD;\n-            case F_TYPE -> Opcodes.FLOAD;\n-            case D_TYPE -> Opcodes.DLOAD;\n-            case L_TYPE -> Opcodes.ALOAD;\n-            default -> throw new InternalError(\"unknown type: \" + type);\n-        };\n-    }\n-    private void emitAloadInsn(int index) {\n-        emitLoadInsn(L_TYPE, index);\n+    private void emitLoadInsn(CodeBuilder cob, TypeKind type, int index) {\n+        cob.loadLocal(type, localsMap[index]);\n@@ -468,49 +366,2 @@\n-    private void emitStoreInsn(BasicType type, int index) {\n-        int opcode = storeInsnOpcode(type);\n-        mv.visitVarInsn(opcode, localsMap[index]);\n-    }\n-\n-    private int storeInsnOpcode(BasicType type) throws InternalError {\n-        return switch (type) {\n-            case I_TYPE -> Opcodes.ISTORE;\n-            case J_TYPE -> Opcodes.LSTORE;\n-            case F_TYPE -> Opcodes.FSTORE;\n-            case D_TYPE -> Opcodes.DSTORE;\n-            case L_TYPE -> Opcodes.ASTORE;\n-            default -> throw new InternalError(\"unknown type: \" + type);\n-        };\n-    }\n-    private void emitAstoreInsn(int index) {\n-        emitStoreInsn(L_TYPE, index);\n-    }\n-\n-    private byte arrayTypeCode(Wrapper elementType) {\n-        return (byte) switch (elementType) {\n-            case BOOLEAN -> Opcodes.T_BOOLEAN;\n-            case BYTE    -> Opcodes.T_BYTE;\n-            case CHAR    -> Opcodes.T_CHAR;\n-            case SHORT   -> Opcodes.T_SHORT;\n-            case INT     -> Opcodes.T_INT;\n-            case LONG    -> Opcodes.T_LONG;\n-            case FLOAT   -> Opcodes.T_FLOAT;\n-            case DOUBLE  -> Opcodes.T_DOUBLE;\n-            case OBJECT  -> 0; \/\/ in place of Opcodes.T_OBJECT\n-            default -> throw new InternalError();\n-        };\n-    }\n-\n-    private int arrayInsnOpcode(byte tcode, int aaop) throws InternalError {\n-        assert(aaop == Opcodes.AASTORE || aaop == Opcodes.AALOAD);\n-        int xas = switch (tcode) {\n-            case Opcodes.T_BOOLEAN -> Opcodes.BASTORE;\n-            case Opcodes.T_BYTE    -> Opcodes.BASTORE;\n-            case Opcodes.T_CHAR    -> Opcodes.CASTORE;\n-            case Opcodes.T_SHORT   -> Opcodes.SASTORE;\n-            case Opcodes.T_INT     -> Opcodes.IASTORE;\n-            case Opcodes.T_LONG    -> Opcodes.LASTORE;\n-            case Opcodes.T_FLOAT   -> Opcodes.FASTORE;\n-            case Opcodes.T_DOUBLE  -> Opcodes.DASTORE;\n-            case 0                 -> Opcodes.AASTORE;\n-            default -> throw new InternalError();\n-        };\n-        return xas - Opcodes.AASTORE + aaop;\n+    private void emitStoreInsn(CodeBuilder cob, TypeKind type, int index) {\n+        cob.storeLocal(type, localsMap[index]);\n@@ -524,5 +375,2 @@\n-    private void emitBoxing(Wrapper wrapper) {\n-        String owner = \"java\/lang\/\" + wrapper.wrapperType().getSimpleName();\n-        String name  = \"valueOf\";\n-        String desc  = \"(\" + wrapper.basicTypeChar() + \")L\" + owner + \";\";\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, false);\n+    private void emitBoxing(CodeBuilder cob, TypeKind tk) {\n+        TypeConvertingMethodAdapter.box(cob, tk);\n@@ -536,6 +384,9 @@\n-    private void emitUnboxing(Wrapper wrapper) {\n-        String owner = \"java\/lang\/\" + wrapper.wrapperType().getSimpleName();\n-        String name  = wrapper.primitiveSimpleName() + \"Value\";\n-        String desc  = \"()\" + wrapper.basicTypeChar();\n-        emitReferenceCast(wrapper.wrapperType(), null);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);\n+    private void emitUnboxing(CodeBuilder cob, TypeKind target) {\n+        switch (target) {\n+            case BooleanType -> emitReferenceCast(cob, Boolean.class, null);\n+            case CharType -> emitReferenceCast(cob, Character.class, null);\n+            case ByteType, DoubleType, FloatType, IntType, LongType, ShortType ->\n+                emitReferenceCast(cob, Number.class, null);\n+            default -> {}\n+        }\n+        TypeConvertingMethodAdapter.unbox(cob, target);\n@@ -552,1 +403,1 @@\n-    private void emitImplicitConversion(BasicType ptype, Class<?> pclass, Object arg) {\n+    private void emitImplicitConversion(CodeBuilder cob, BasicType ptype, Class<?> pclass, Object arg) {\n@@ -560,1 +411,1 @@\n-                        emitReferenceCast(Object.class, arg);\n+                        emitReferenceCast(cob, Object.class, arg);\n@@ -563,1 +414,1 @@\n-                emitReferenceCast(pclass, arg);\n+                emitReferenceCast(cob, pclass, arg);\n@@ -567,1 +418,1 @@\n-                    emitPrimCast(ptype.basicTypeWrapper(), Wrapper.forPrimitiveType(pclass));\n+                    emitPrimCast(cob, ptype.basicTypeKind(), TypeKind.from(pclass));\n@@ -585,1 +436,1 @@\n-    private void emitReferenceCast(Class<?> cls, Object arg) {\n+    private void emitReferenceCast(CodeBuilder cob, Class<?> cls, Object arg) {\n@@ -597,2 +448,2 @@\n-            String sig = getInternalName(cls);\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, sig);\n+            ClassDesc sig = classDesc(cls);\n+            cob.checkcast(sig);\n@@ -600,3 +451,3 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(cls), \"Ljava\/lang\/Class;\");\n-            mv.visitInsn(Opcodes.SWAP);\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, \"cast\", LL_SIG, false);\n+            cob.getstatic(classDesc, classData(cls), CD_Class)\n+               .swap()\n+               .invokevirtual(CD_Class, \"cast\", MTD_Object_Object);\n@@ -604,1 +455,1 @@\n-                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);\n+                cob.checkcast(CD_Object_array);\n@@ -606,1 +457,1 @@\n-                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);\n+                cob.checkcast(CD_Object);\n@@ -609,2 +460,2 @@\n-            mv.visitInsn(Opcodes.DUP);\n-            emitAstoreInsn(writeBack.index());\n+            cob.dup();\n+            emitStoreInsn(cob, TypeKind.ReferenceType, writeBack.index());\n@@ -614,30 +465,0 @@\n-    \/**\n-     * Emits an actual return instruction conforming to the given return type.\n-     *\/\n-    private void emitReturnInsn(BasicType type) {\n-        int opcode = switch (type) {\n-            case I_TYPE -> Opcodes.IRETURN;\n-            case J_TYPE -> Opcodes.LRETURN;\n-            case F_TYPE -> Opcodes.FRETURN;\n-            case D_TYPE -> Opcodes.DRETURN;\n-            case L_TYPE -> Opcodes.ARETURN;\n-            case V_TYPE -> Opcodes.RETURN;\n-            default -> throw new InternalError(\"unknown return type: \" + type);\n-        };\n-        mv.visitInsn(opcode);\n-    }\n-\n-    private String getInternalName(Class<?> c) {\n-        if (c == Object.class)             return OBJ;\n-        else if (c == Object[].class)      return OBJARY;\n-        else if (c == Class.class)         return CLS;\n-        else if (c == MethodHandle.class)  return MH;\n-        assert(VerifyAccess.ensureTypeVisible(c, Object.class)) : c.getName();\n-\n-        if (c == lastClass) {\n-            return lastInternalName;\n-        }\n-        lastClass = c;\n-        return lastInternalName = c.getName().replace('.', '\/');\n-    }\n-\n@@ -716,1 +537,1 @@\n-    private boolean checkActualReceiver() {\n+    private boolean checkActualReceiver(CodeBuilder cob) {\n@@ -718,3 +539,3 @@\n-        mv.visitInsn(Opcodes.DUP);\n-        mv.visitVarInsn(Opcodes.ALOAD, localsMap[0]);\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, MHI, \"assertSame\", LLV_SIG, false);\n+        cob.dup()\n+           .aload(0)\n+           .invokestatic(CD_MethodHandleImpl, \"assertSame\", MethodTypeDescImpl.ofValidated(CD_void, CD_Object, CD_Object));\n@@ -724,24 +545,5 @@\n-    static String className(String cn) {\n-        assert checkClassName(cn): \"Class not found: \" + cn;\n-        return cn;\n-    }\n-\n-    static boolean checkClassName(String cn) {\n-        Type tp = Type.getType(cn);\n-        \/\/ additional sanity so only valid \"L;\" descriptors work\n-        if (tp.getSort() != Type.OBJECT) {\n-            return false;\n-        }\n-        try {\n-            Class<?> c = Class.forName(tp.getClassName(), false, null);\n-            return true;\n-        } catch (ClassNotFoundException e) {\n-            return false;\n-        }\n-    }\n-\n-    static final String      DONTINLINE_SIG = className(\"Ljdk\/internal\/vm\/annotation\/DontInline;\");\n-    static final String     FORCEINLINE_SIG = className(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\");\n-    static final String          HIDDEN_SIG = className(\"Ljdk\/internal\/vm\/annotation\/Hidden;\");\n-    static final String INJECTEDPROFILE_SIG = className(\"Ljava\/lang\/invoke\/InjectedProfile;\");\n-    static final String     LF_COMPILED_SIG = className(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\");\n+    static final Annotation DONTINLINE      = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n+    static final Annotation FORCEINLINE     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n+    static final Annotation HIDDEN          = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n+    static final Annotation INJECTEDPROFILE = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n+    static final Annotation LF_COMPILED     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n@@ -753,6 +555,9 @@\n-        classFilePrologue();\n-        addMethod();\n-        clinit(cw, className, classData);\n-        bogusMethod(lambdaForm);\n-\n-        return toByteArray();\n+        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                addMethod(clb);\n+                clinit(clb, classDesc, classData);\n+                bogusMethod(clb, lambdaForm);\n+            }\n+        });\n+        return classFile;\n@@ -761,3 +566,4 @@\n-    void setClassWriter(ClassWriter cw) {\n-        this.cw = cw;\n-    }\n+    void addMethod(ClassBuilder clb) {\n+        methodSetup(clb, new Consumer<MethodBuilder>() {\n+            @Override\n+            public void accept(MethodBuilder mb) {\n@@ -765,2 +571,1 @@\n-    void addMethod() {\n-        methodPrologue();\n+                List<Annotation> annotations = new ArrayList<>(3);\n@@ -768,2 +573,2 @@\n-        \/\/ Suppress this method in backtraces displayed to the user.\n-        mv.visitAnnotation(HIDDEN_SIG, true);\n+                \/\/ Suppress this method in backtraces displayed to the user.\n+                annotations.add(HIDDEN);\n@@ -771,2 +576,2 @@\n-        \/\/ Mark this method as a compiled LambdaForm\n-        mv.visitAnnotation(LF_COMPILED_SIG, true);\n+                \/\/ Mark this method as a compiled LambdaForm\n+                annotations.add(LF_COMPILED);\n@@ -774,6 +579,23 @@\n-        if (lambdaForm.forceInline) {\n-            \/\/ Force inlining of this invoker method.\n-            mv.visitAnnotation(FORCEINLINE_SIG, true);\n-        } else {\n-            mv.visitAnnotation(DONTINLINE_SIG, true);\n-        }\n+                if (lambdaForm.forceInline) {\n+                    \/\/ Force inlining of this invoker method.\n+                    annotations.add(FORCEINLINE);\n+                } else {\n+                    annotations.add(DONTINLINE);\n+                }\n+                mb.accept(RuntimeVisibleAnnotationsAttribute.of(annotations));\n+\n+                classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n+\n+                mb.withCode(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        if (lambdaForm.customized != null) {\n+                            \/\/ Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute\n+                            \/\/ receiver MethodHandle (at slot #0) with an embedded constant and use it instead.\n+                            \/\/ It enables more efficient code generation in some situations, since embedded constants\n+                            \/\/ are compile-time constants for JIT compiler.\n+                            cob.getstatic(classDesc, classData(lambdaForm.customized), CD_MethodHandle)\n+                               .checkcast(CD_MethodHandle);\n+                            assert(checkActualReceiver(cob)); \/\/ expects MethodHandle on top of the stack\n+                            cob.astore(0);\n+                        }\n@@ -781,12 +603,72 @@\n-        classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n-\n-        if (lambdaForm.customized != null) {\n-            \/\/ Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute\n-            \/\/ receiver MethodHandle (at slot #0) with an embedded constant and use it instead.\n-            \/\/ It enables more efficient code generation in some situations, since embedded constants\n-            \/\/ are compile-time constants for JIT compiler.\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(lambdaForm.customized), MH_SIG);\n-            mv.visitTypeInsn(Opcodes.CHECKCAST, MH);\n-            assert(checkActualReceiver()); \/\/ expects MethodHandle on top of the stack\n-            mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);\n-        }\n+                        \/\/ iterate over the form's names, generating bytecode instructions for each\n+                        \/\/ start iterating at the first name following the arguments\n+                        Name onStack = null;\n+                        for (int i = lambdaForm.arity; i < lambdaForm.names.length; i++) {\n+                            Name name = lambdaForm.names[i];\n+\n+                            emitStoreResult(cob, onStack);\n+                            onStack = name;  \/\/ unless otherwise modified below\n+                            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();\n+                            switch (intr) {\n+                                case SELECT_ALTERNATIVE:\n+                                    assert lambdaForm.isSelectAlternative(i);\n+                                    if (PROFILE_GWT) {\n+                                        assert(name.arguments[0] instanceof Name n &&\n+                                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n+                                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(INJECTEDPROFILE)));\n+                                    }\n+                                    onStack = emitSelectAlternative(cob, name, lambdaForm.names[i+1]);\n+                                    i++;  \/\/ skip MH.invokeBasic of the selectAlternative result\n+                                    continue;\n+                                case GUARD_WITH_CATCH:\n+                                    assert lambdaForm.isGuardWithCatch(i);\n+                                    onStack = emitGuardWithCatch(cob, i);\n+                                    i += 2; \/\/ jump to the end of GWC idiom\n+                                    continue;\n+                                case TRY_FINALLY:\n+                                    assert lambdaForm.isTryFinally(i);\n+                                    onStack = emitTryFinally(cob, i);\n+                                    i += 2; \/\/ jump to the end of the TF idiom\n+                                    continue;\n+                                case TABLE_SWITCH:\n+                                    assert lambdaForm.isTableSwitch(i);\n+                                    int numCases = (Integer) name.function.intrinsicData();\n+                                    onStack = emitTableSwitch(cob, i, numCases);\n+                                    i += 2; \/\/ jump to the end of the TS idiom\n+                                    continue;\n+                                case LOOP:\n+                                    assert lambdaForm.isLoop(i);\n+                                    onStack = emitLoop(cob, i);\n+                                    i += 2; \/\/ jump to the end of the LOOP idiom\n+                                    continue;\n+                                case ARRAY_LOAD:\n+                                    emitArrayLoad(cob, name);\n+                                    continue;\n+                                case ARRAY_STORE:\n+                                    emitArrayStore(cob, name);\n+                                    continue;\n+                                case ARRAY_LENGTH:\n+                                    emitArrayLength(cob, name);\n+                                    continue;\n+                                case IDENTITY:\n+                                    assert(name.arguments.length == 1);\n+                                    emitPushArguments(cob, name, 0);\n+                                    continue;\n+                                case ZERO:\n+                                    assert(name.arguments.length == 0);\n+                                    cob.loadConstant((ConstantDesc)name.type.basicTypeWrapper().zero());\n+                                    continue;\n+                                case NONE:\n+                                    \/\/ no intrinsic associated\n+                                    break;\n+                                default:\n+                                    throw newInternalError(\"Unknown intrinsic: \"+intr);\n+                            }\n+\n+                            MemberName member = name.function.member();\n+                            if (isStaticallyInvocable(member)) {\n+                                emitStaticInvoke(cob, member, name);\n+                            } else {\n+                                emitInvoke(cob, name);\n+                            }\n+                        }\n@@ -794,16 +676,2 @@\n-        \/\/ iterate over the form's names, generating bytecode instructions for each\n-        \/\/ start iterating at the first name following the arguments\n-        Name onStack = null;\n-        for (int i = lambdaForm.arity; i < lambdaForm.names.length; i++) {\n-            Name name = lambdaForm.names[i];\n-\n-            emitStoreResult(onStack);\n-            onStack = name;  \/\/ unless otherwise modified below\n-            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();\n-            switch (intr) {\n-                case SELECT_ALTERNATIVE:\n-                    assert lambdaForm.isSelectAlternative(i);\n-                    if (PROFILE_GWT) {\n-                        assert(name.arguments[0] instanceof Name n &&\n-                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n-                        mv.visitAnnotation(INJECTEDPROFILE_SIG, true);\n+                        \/\/ return statement\n+                        emitReturn(cob, onStack);\n@@ -811,53 +679,1 @@\n-                    onStack = emitSelectAlternative(name, lambdaForm.names[i+1]);\n-                    i++;  \/\/ skip MH.invokeBasic of the selectAlternative result\n-                    continue;\n-                case GUARD_WITH_CATCH:\n-                    assert lambdaForm.isGuardWithCatch(i);\n-                    onStack = emitGuardWithCatch(i);\n-                    i += 2; \/\/ jump to the end of GWC idiom\n-                    continue;\n-                case TRY_FINALLY:\n-                    assert lambdaForm.isTryFinally(i);\n-                    onStack = emitTryFinally(i);\n-                    i += 2; \/\/ jump to the end of the TF idiom\n-                    continue;\n-                case TABLE_SWITCH:\n-                    assert lambdaForm.isTableSwitch(i);\n-                    int numCases = (Integer) name.function.intrinsicData();\n-                    onStack = emitTableSwitch(i, numCases);\n-                    i += 2; \/\/ jump to the end of the TS idiom\n-                    continue;\n-                case LOOP:\n-                    assert lambdaForm.isLoop(i);\n-                    onStack = emitLoop(i);\n-                    i += 2; \/\/ jump to the end of the LOOP idiom\n-                    continue;\n-                case ARRAY_LOAD:\n-                    emitArrayLoad(name);\n-                    continue;\n-                case ARRAY_STORE:\n-                    emitArrayStore(name);\n-                    continue;\n-                case ARRAY_LENGTH:\n-                    emitArrayLength(name);\n-                    continue;\n-                case IDENTITY:\n-                    assert(name.arguments.length == 1);\n-                    emitPushArguments(name, 0);\n-                    continue;\n-                case ZERO:\n-                    assert(name.arguments.length == 0);\n-                    emitConst(name.type.basicTypeWrapper().zero());\n-                    continue;\n-                case NONE:\n-                    \/\/ no intrinsic associated\n-                    break;\n-                default:\n-                    throw newInternalError(\"Unknown intrinsic: \"+intr);\n-            }\n-\n-            MemberName member = name.function.member();\n-            if (isStaticallyInvocable(member)) {\n-                emitStaticInvoke(member, name);\n-            } else {\n-                emitInvoke(name);\n+                });\n@@ -865,18 +681,1 @@\n-        }\n-\n-        \/\/ return statement\n-        emitReturn(onStack);\n-\n-        methodEpilogue();\n-    }\n-\n-    \/*\n-     * @throws BytecodeGenerationException if something goes wrong when\n-     *         generating the byte code\n-     *\/\n-    private byte[] toByteArray() {\n-        try {\n-            return cw.toByteArray();\n-        } catch (RuntimeException e) {\n-            throw new BytecodeGenerationException(e);\n-        }\n+        });\n@@ -895,3 +694,10 @@\n-    void emitArrayLoad(Name name)   { emitArrayOp(name, Opcodes.AALOAD);      }\n-    void emitArrayStore(Name name)  { emitArrayOp(name, Opcodes.AASTORE);     }\n-    void emitArrayLength(Name name) { emitArrayOp(name, Opcodes.ARRAYLENGTH); }\n+    void emitArrayLoad(CodeBuilder cob, Name name)   {\n+        Class<?> elementType = name.function.methodType().parameterType(0).getComponentType();\n+        assert elementType != null;\n+        emitPushArguments(cob, name, 0);\n+        if (elementType.isPrimitive()) {\n+            cob.arrayLoad(TypeKind.from(elementType));\n+        } else {\n+            cob.aaload();\n+        }\n+    }\n@@ -899,2 +705,1 @@\n-    void emitArrayOp(Name name, int arrayOpcode) {\n-        assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;\n+    void emitArrayStore(CodeBuilder cob, Name name)  {\n@@ -903,4 +708,5 @@\n-        emitPushArguments(name, 0);\n-        if (arrayOpcode != Opcodes.ARRAYLENGTH && elementType.isPrimitive()) {\n-            Wrapper w = Wrapper.forPrimitiveType(elementType);\n-            arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);\n+        emitPushArguments(cob, name, 0);\n+        if (elementType.isPrimitive()) {\n+            cob.arrayStore(TypeKind.from(elementType));\n+        } else {\n+            cob.aastore();\n@@ -908,1 +714,6 @@\n-        mv.visitInsn(arrayOpcode);\n+    }\n+\n+    void emitArrayLength(CodeBuilder cob, Name name) {\n+        assert name.function.methodType().parameterType(0).isArray();\n+        emitPushArguments(cob, name, 0);\n+        cob.arraylength();\n@@ -914,1 +725,1 @@\n-    void emitInvoke(Name name) {\n+    void emitInvoke(CodeBuilder cob, Name name) {\n@@ -920,2 +731,2 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(target), MH_SIG);\n-            emitReferenceCast(MethodHandle.class, target);\n+            cob.getstatic(classDesc, classData(target), CD_MethodHandle);\n+            emitReferenceCast(cob, MethodHandle.class, target);\n@@ -924,4 +735,4 @@\n-            emitAloadInsn(0);\n-            emitReferenceCast(MethodHandle.class, null);\n-            mv.visitFieldInsn(Opcodes.GETFIELD, MH, \"form\", LF_SIG);\n-            mv.visitFieldInsn(Opcodes.GETFIELD, LF, \"names\", LFN_SIG);\n+            cob.aload(0);\n+            emitReferenceCast(cob, MethodHandle.class, null);\n+            cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm)\n+               .getfield(CD_LambdaForm, \"names\", CD_LambdaForm_Name);\n@@ -932,1 +743,1 @@\n-        emitPushArguments(name, 0);\n+        emitPushArguments(cob, name, 0);\n@@ -936,1 +747,1 @@\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n@@ -1023,2 +834,2 @@\n-    void emitStaticInvoke(Name name) {\n-        emitStaticInvoke(name.function.member(), name);\n+    void emitStaticInvoke(CodeBuilder cob, Name name) {\n+        emitStaticInvoke(cob, name.function.member(), name);\n@@ -1030,1 +841,1 @@\n-    void emitStaticInvoke(MemberName member, Name name) {\n+    void emitStaticInvoke(CodeBuilder cob, MemberName member, Name name) {\n@@ -1033,1 +844,1 @@\n-        String cname = getInternalName(defc);\n+        ClassDesc cdesc = classDesc(defc);\n@@ -1035,1 +846,0 @@\n-        String mtype;\n@@ -1046,1 +856,1 @@\n-        emitPushArguments(name, 0);\n+        emitPushArguments(cob, name, 0);\n@@ -1050,3 +860,3 @@\n-            mtype = member.getMethodType().toMethodDescriptorString();\n-            mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,\n-                               member.getDeclaringClass().isInterface());\n+            var methodTypeDesc = methodDesc(member.getMethodType());\n+            cob.invoke(refKindOpcode(refKind), cdesc, mname, methodTypeDesc,\n+                                  member.getDeclaringClass().isInterface());\n@@ -1054,2 +864,2 @@\n-            mtype = MethodType.toFieldDescriptorString(member.getFieldType());\n-            mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);\n+            var fieldTypeDesc = classDesc(member.getFieldType());\n+            cob.fieldAccess(refKindOpcode(refKind), cdesc, mname, fieldTypeDesc);\n@@ -1067,1 +877,1 @@\n-    int refKindOpcode(byte refKind) {\n+    Opcode refKindOpcode(byte refKind) {\n@@ -1069,8 +879,8 @@\n-        case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;\n-        case REF_invokeStatic:       return Opcodes.INVOKESTATIC;\n-        case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;\n-        case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;\n-        case REF_getField:           return Opcodes.GETFIELD;\n-        case REF_putField:           return Opcodes.PUTFIELD;\n-        case REF_getStatic:          return Opcodes.GETSTATIC;\n-        case REF_putStatic:          return Opcodes.PUTSTATIC;\n+        case REF_invokeVirtual:      return Opcode.INVOKEVIRTUAL;\n+        case REF_invokeStatic:       return Opcode.INVOKESTATIC;\n+        case REF_invokeSpecial:      return Opcode.INVOKESPECIAL;\n+        case REF_invokeInterface:    return Opcode.INVOKEINTERFACE;\n+        case REF_getField:           return Opcode.GETFIELD;\n+        case REF_putField:           return Opcode.PUTFIELD;\n+        case REF_getStatic:          return Opcode.GETSTATIC;\n+        case REF_putStatic:          return Opcode.PUTSTATIC;\n@@ -1092,1 +902,1 @@\n-    private Name emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {\n+    private Name emitSelectAlternative(CodeBuilder cob, Name selectAlternativeName, Name invokeBasicName) {\n@@ -1097,2 +907,2 @@\n-        Label L_fallback = new Label();\n-        Label L_done     = new Label();\n+        Label L_fallback = cob.newLabel();\n+        Label L_done     = cob.newLabel();\n@@ -1101,1 +911,1 @@\n-        emitPushArgument(selectAlternativeName, 0);\n+        emitPushArgument(cob, selectAlternativeName, 0);\n@@ -1104,1 +914,1 @@\n-        mv.visitJumpInsn(Opcodes.IFEQ, L_fallback);\n+        cob.ifeq(L_fallback);\n@@ -1108,3 +918,3 @@\n-        emitPushArgument(selectAlternativeName, 1);  \/\/ get 2nd argument of selectAlternative\n-        emitAstoreInsn(receiver.index());  \/\/ store the MH in the receiver slot\n-        emitStaticInvoke(invokeBasicName);\n+        emitPushArgument(cob, selectAlternativeName, 1);  \/\/ get 2nd argument of selectAlternative\n+        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStaticInvoke(cob, invokeBasicName);\n@@ -1113,1 +923,1 @@\n-        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n+        cob.goto_w(L_done);\n@@ -1116,1 +926,1 @@\n-        mv.visitLabel(L_fallback);\n+        cob.labelBinding(L_fallback);\n@@ -1120,3 +930,3 @@\n-        emitPushArgument(selectAlternativeName, 2);  \/\/ get 3rd argument of selectAlternative\n-        emitAstoreInsn(receiver.index());  \/\/ store the MH in the receiver slot\n-        emitStaticInvoke(invokeBasicName);\n+        emitPushArgument(cob, selectAlternativeName, 2);  \/\/ get 3rd argument of selectAlternative\n+        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStaticInvoke(cob, invokeBasicName);\n@@ -1125,1 +935,1 @@\n-        mv.visitLabel(L_done);\n+        cob.labelBinding(L_done);\n@@ -1152,1 +962,1 @@\n-    private Name emitGuardWithCatch(int pos) {\n+    private Name emitGuardWithCatch(CodeBuilder cob, int pos) {\n@@ -1157,4 +967,4 @@\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_handler = new Label();\n-        Label L_done = new Label();\n+        Label L_startBlock = cob.newLabel();\n+        Label L_endBlock = cob.newLabel();\n+        Label L_handler = cob.newLabel();\n+        Label L_done = cob.newLabel();\n@@ -1167,1 +977,1 @@\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, \"java\/lang\/Throwable\");\n+        cob.exceptionCatch(L_startBlock, L_endBlock, L_handler, CD_Throwable);\n@@ -1170,1 +980,1 @@\n-        mv.visitLabel(L_startBlock);\n+        cob.labelBinding(L_startBlock);\n@@ -1172,5 +982,5 @@\n-        emitPushArgument(invoker, 0);\n-        emitPushArguments(args, 1); \/\/ skip 1st argument: method handle\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n-        mv.visitLabel(L_endBlock);\n-        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n+        emitPushArgument(cob, invoker, 0);\n+        emitPushArguments(cob, args, 1); \/\/ skip 1st argument: method handle\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n+        cob.labelBinding(L_endBlock);\n+        cob.goto_w(L_done);\n@@ -1179,1 +989,1 @@\n-        mv.visitLabel(L_handler);\n+        cob.labelBinding(L_handler);\n@@ -1182,1 +992,1 @@\n-        mv.visitInsn(Opcodes.DUP);\n+        cob.dup();\n@@ -1184,5 +994,5 @@\n-        emitPushArgument(invoker, 1);\n-        mv.visitInsn(Opcodes.SWAP);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java\/lang\/Class\", \"isInstance\", \"(Ljava\/lang\/Object;)Z\", false);\n-        Label L_rethrow = new Label();\n-        mv.visitJumpInsn(Opcodes.IFEQ, L_rethrow);\n+        emitPushArgument(cob, invoker, 1);\n+        cob.swap();\n+        cob.invokevirtual(CD_Class, \"isInstance\", MTD_boolean_Object);\n+        Label L_rethrow = cob.newLabel();\n+        cob.ifeq(L_rethrow);\n@@ -1192,3 +1002,3 @@\n-        emitPushArgument(invoker, 2);\n-        mv.visitInsn(Opcodes.SWAP);\n-        emitPushArguments(args, 1); \/\/ skip 1st argument: method handle\n+        emitPushArgument(cob, invoker, 2);\n+        cob.swap();\n+        emitPushArguments(cob, args, 1); \/\/ skip 1st argument: method handle\n@@ -1196,2 +1006,2 @@\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", catcherType.basicType().toMethodDescriptorString(), false);\n-        mv.visitJumpInsn(Opcodes.GOTO, L_done);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(catcherType.basicType()));\n+        cob.goto_w(L_done);\n@@ -1199,2 +1009,2 @@\n-        mv.visitLabel(L_rethrow);\n-        mv.visitInsn(Opcodes.ATHROW);\n+        cob.labelBinding(L_rethrow);\n+        cob.athrow();\n@@ -1202,1 +1012,1 @@\n-        mv.visitLabel(L_done);\n+        cob.labelBinding(L_done);\n@@ -1267,1 +1077,1 @@\n-    private Name emitTryFinally(int pos) {\n+    private Name emitTryFinally(CodeBuilder cob, int pos) {\n@@ -1272,4 +1082,4 @@\n-        Label lFrom = new Label();\n-        Label lTo = new Label();\n-        Label lCatch = new Label();\n-        Label lDone = new Label();\n+        Label lFrom = cob.newLabel();\n+        Label lTo = cob.newLabel();\n+        Label lCatch = cob.newLabel();\n+        Label lDone = cob.newLabel();\n@@ -1288,1 +1098,1 @@\n-        String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();\n+        MethodTypeDesc cleanupDesc = methodDesc(cleanupType.basicType());\n@@ -1291,1 +1101,1 @@\n-        mv.visitTryCatchBlock(lFrom, lTo, lCatch, \"java\/lang\/Throwable\");\n+        cob.exceptionCatch(lFrom, lTo, lCatch, CD_Throwable);\n@@ -1294,5 +1104,5 @@\n-        mv.visitLabel(lFrom);\n-        emitPushArgument(invoker, 0); \/\/ load target\n-        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.basicType().toMethodDescriptorString(), false);\n-        mv.visitLabel(lTo);\n+        cob.labelBinding(lFrom);\n+        emitPushArgument(cob, invoker, 0); \/\/ load target\n+        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type.basicType()));\n+        cob.labelBinding(lTo);\n@@ -1303,1 +1113,1 @@\n-            emitStoreInsn(basicReturnType, index);\n+            emitStoreInsn(cob, basicReturnType.basicTypeKind(), index);\n@@ -1305,2 +1115,2 @@\n-        emitPushArgument(invoker, 1); \/\/ load cleanup\n-        mv.visitInsn(Opcodes.ACONST_NULL);\n+        emitPushArgument(cob, invoker, 1); \/\/ load cleanup\n+        cob.loadConstant(null);\n@@ -1308,1 +1118,1 @@\n-            emitLoadInsn(basicReturnType, index);\n+            emitLoadInsn(cob, basicReturnType.basicTypeKind(), index);\n@@ -1310,3 +1120,3 @@\n-        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", cleanupDesc, false);\n-        mv.visitJumpInsn(Opcodes.GOTO, lDone);\n+        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n+        cob.goto_w(lDone);\n@@ -1315,2 +1125,2 @@\n-        mv.visitLabel(lCatch);\n-        mv.visitInsn(Opcodes.DUP);\n+        cob.labelBinding(lCatch);\n+        cob.dup();\n@@ -1319,2 +1129,2 @@\n-        emitPushArgument(invoker, 1); \/\/ load cleanup\n-        mv.visitInsn(Opcodes.SWAP);\n+        emitPushArgument(cob, invoker, 1); \/\/ load cleanup\n+        cob.swap();\n@@ -1322,1 +1132,1 @@\n-            emitZero(BasicType.basicType(returnType)); \/\/ load default for result\n+            emitZero(cob, BasicType.basicType(returnType)); \/\/ load default for result\n@@ -1324,2 +1134,2 @@\n-        emitPushArguments(args, 1); \/\/ load args (skip 0: method handle)\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", cleanupDesc, false);\n+        emitPushArguments(cob, args, 1); \/\/ load args (skip 0: method handle)\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", cleanupDesc);\n@@ -1327,1 +1137,1 @@\n-            emitPopInsn(basicReturnType);\n+            emitPopInsn(cob, basicReturnType);\n@@ -1329,1 +1139,1 @@\n-        mv.visitInsn(Opcodes.ATHROW);\n+        cob.athrow();\n@@ -1332,1 +1142,1 @@\n-        mv.visitLabel(lDone);\n+        cob.labelBinding(lDone);\n@@ -1337,8 +1147,4 @@\n-    private void emitPopInsn(BasicType type) {\n-        mv.visitInsn(popInsnOpcode(type));\n-    }\n-\n-    private static int popInsnOpcode(BasicType type) {\n-        return switch (type) {\n-            case I_TYPE, F_TYPE, L_TYPE -> Opcodes.POP;\n-            case J_TYPE, D_TYPE         -> Opcodes.POP2;\n+    private void emitPopInsn(CodeBuilder cob, BasicType type) {\n+        switch (type) {\n+            case I_TYPE, F_TYPE, L_TYPE -> cob.pop();\n+            case J_TYPE, D_TYPE -> cob.pop2();\n@@ -1346,1 +1152,1 @@\n-        };\n+        }\n@@ -1349,1 +1155,1 @@\n-    private Name emitTableSwitch(int pos, int numCases) {\n+    private Name emitTableSwitch(CodeBuilder cob, int pos, int numCases) {\n@@ -1358,1 +1164,1 @@\n-        String caseDescriptor = caseType.basicType().toMethodDescriptorString();\n+        MethodTypeDesc caseDescriptor = methodDesc(caseType.basicType());\n@@ -1360,3 +1166,2 @@\n-        emitPushArgument(invoker, 2); \/\/ push cases\n-        mv.visitFieldInsn(Opcodes.GETFIELD, \"java\/lang\/invoke\/MethodHandleImpl$CasesHolder\", \"cases\",\n-            \"[Ljava\/lang\/invoke\/MethodHandle;\");\n+        emitPushArgument(cob, invoker, 2); \/\/ push cases\n+        cob.getfield(CD_CasesHolder, \"cases\", CD_MethodHandle_array);\n@@ -1364,1 +1169,1 @@\n-        emitStoreInsn(L_TYPE, casesLocal);\n+        emitStoreInsn(cob, TypeKind.ReferenceType, casesLocal);\n@@ -1366,5 +1171,5 @@\n-        Label endLabel = new Label();\n-        Label defaultLabel = new Label();\n-        Label[] caseLabels = new Label[numCases];\n-        for (int i = 0; i < caseLabels.length; i++) {\n-            caseLabels[i] = new Label();\n+        Label endLabel = cob.newLabel();\n+        Label defaultLabel = cob.newLabel();\n+        List<SwitchCase> cases = new ArrayList<>(numCases);\n+        for (int i = 0; i < numCases; i++) {\n+            cases.add(SwitchCase.of(i, cob.newLabel()));\n@@ -1373,2 +1178,2 @@\n-        emitPushArgument(invoker, 0); \/\/ push switch input\n-        mv.visitTableSwitchInsn(0, numCases - 1, defaultLabel, caseLabels);\n+        emitPushArgument(cob, invoker, 0); \/\/ push switch input\n+        cob.tableswitch(0, numCases - 1, defaultLabel, cases);\n@@ -1376,5 +1181,5 @@\n-        mv.visitLabel(defaultLabel);\n-        emitPushArgument(invoker, 1); \/\/ push default handle\n-        emitPushArguments(args, 1); \/\/ again, skip collector\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n-        mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+        cob.labelBinding(defaultLabel);\n+        emitPushArgument(cob, invoker, 1); \/\/ push default handle\n+        emitPushArguments(cob, args, 1); \/\/ again, skip collector\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n+        cob.goto_(endLabel);\n@@ -1383,1 +1188,1 @@\n-            mv.visitLabel(caseLabels[i]);\n+            cob.labelBinding(cases.get(i).target());\n@@ -1385,3 +1190,3 @@\n-            emitLoadInsn(L_TYPE, casesLocal);\n-            emitIconstInsn(i);\n-            mv.visitInsn(Opcodes.AALOAD);\n+            emitLoadInsn(cob, TypeKind.ReferenceType, casesLocal);\n+            cob.loadConstant(i);\n+            cob.aaload();\n@@ -1390,2 +1195,2 @@\n-            emitPushArguments(args, 1); \/\/ again, skip collector\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+            emitPushArguments(cob, args, 1); \/\/ again, skip collector\n+            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n@@ -1393,1 +1198,1 @@\n-            mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+            cob.goto_(endLabel);\n@@ -1396,1 +1201,1 @@\n-        mv.visitLabel(endLabel);\n+        cob.labelBinding(endLabel);\n@@ -1483,1 +1288,1 @@\n-    private Name emitLoop(int pos) {\n+    private Name emitLoop(CodeBuilder cob, int pos) {\n@@ -1491,2 +1296,3 @@\n-        Class<?>[] loopLocalStateTypes = Stream.of(loopClauseTypes).\n-                filter(bt -> bt != BasicType.V_TYPE).map(BasicType::basicTypeClass).toArray(Class<?>[]::new);\n+        Class<?>[] loopLocalStateTypes = Stream.of(loopClauseTypes)\n+                .filter(bt -> bt != BasicType.V_TYPE)\n+                .map(BasicType::basicTypeClass).toArray(Class<?>[]::new);\n@@ -1516,2 +1322,2 @@\n-        Label lLoop = new Label();\n-        Label lDone = new Label();\n+        Label lLoop = cob.newLabel();\n+        Label lDone = cob.newLabel();\n@@ -1521,3 +1327,3 @@\n-        emitPushArgument(MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, LOOP_CLAUSES, \"clauses\", MHARY2);\n-        emitAstoreInsn(clauseDataIndex);\n+        emitPushArgument(cob, MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);\n+        cob.getfield(CD_LoopClauses, \"clauses\", CD_MethodHandle_array2);\n+        emitStoreInsn(cob, TypeKind.ReferenceType, clauseDataIndex);\n@@ -1528,1 +1334,1 @@\n-            emitLoopHandleInvoke(invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,\n@@ -1531,1 +1337,1 @@\n-                emitStoreInsn(BasicType.basicType(cInitType.returnType()), firstLoopStateIndex + state);\n+                emitStoreInsn(cob, BasicType.basicType(cInitType.returnType()).basicTypeKind(), firstLoopStateIndex + state);\n@@ -1537,1 +1343,1 @@\n-        mv.visitLabel(lLoop);\n+        cob.labelBinding(lLoop);\n@@ -1540,1 +1346,1 @@\n-            lNext = new Label();\n+            lNext = cob.newLabel();\n@@ -1546,1 +1352,1 @@\n-            emitLoopHandleInvoke(invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,\n@@ -1549,1 +1355,1 @@\n-                emitStoreInsn(BasicType.basicType(stepType.returnType()), firstLoopStateIndex + state);\n+                emitStoreInsn(cob, BasicType.basicType(stepType.returnType()).basicTypeKind(), firstLoopStateIndex + state);\n@@ -1554,1 +1360,1 @@\n-            emitLoopHandleInvoke(invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,\n@@ -1556,1 +1362,1 @@\n-            mv.visitJumpInsn(Opcodes.IFNE, lNext);\n+            cob.ifne(lNext);\n@@ -1559,1 +1365,1 @@\n-            emitLoopHandleInvoke(invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,\n+            emitLoopHandleInvoke(cob, invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,\n@@ -1561,1 +1367,1 @@\n-            mv.visitJumpInsn(Opcodes.GOTO, lDone);\n+            cob.goto_w(lDone);\n@@ -1564,1 +1370,1 @@\n-            mv.visitLabel(lNext);\n+            cob.labelBinding(lNext);\n@@ -1567,1 +1373,1 @@\n-        mv.visitJumpInsn(Opcodes.GOTO, lLoop);\n+        cob.goto_w(lLoop);\n@@ -1570,1 +1376,1 @@\n-        mv.visitLabel(lDone);\n+        cob.labelBinding(lDone);\n@@ -1591,1 +1397,1 @@\n-    private void emitLoopHandleInvoke(Name holder, int handles, int clause, Name args, boolean pushLocalState,\n+    private void emitLoopHandleInvoke(CodeBuilder cob, Name holder, int handles, int clause, Name args, boolean pushLocalState,\n@@ -1595,3 +1401,3 @@\n-        emitPushClauseArray(clauseDataSlot, handles);\n-        emitIconstInsn(clause);\n-        mv.visitInsn(Opcodes.AALOAD);\n+        emitPushClauseArray(cob, clauseDataSlot, handles);\n+        cob.loadConstant(clause);\n+        cob.aaload();\n@@ -1601,1 +1407,1 @@\n-                emitLoadInsn(BasicType.basicType(loopLocalStateTypes[s]), firstLoopStateSlot + s);\n+                emitLoadInsn(cob, BasicType.basicType(loopLocalStateTypes[s]).basicTypeKind(), firstLoopStateSlot + s);\n@@ -1605,2 +1411,2 @@\n-        emitPushArguments(args, 1);\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", type.toMethodDescriptorString(), false);\n+        emitPushArguments(cob, args, 1);\n+        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", methodDesc(type));\n@@ -1609,4 +1415,4 @@\n-    private void emitPushClauseArray(int clauseDataSlot, int which) {\n-        emitAloadInsn(clauseDataSlot);\n-        emitIconstInsn(which - 1);\n-        mv.visitInsn(Opcodes.AALOAD);\n+    private void emitPushClauseArray(CodeBuilder cob, int clauseDataSlot, int which) {\n+        emitLoadInsn(cob, TypeKind.ReferenceType, clauseDataSlot);\n+        cob.loadConstant(which - 1);\n+        cob.aaload();\n@@ -1615,7 +1421,7 @@\n-    private void emitZero(BasicType type) {\n-        mv.visitInsn(switch (type) {\n-            case I_TYPE -> Opcodes.ICONST_0;\n-            case J_TYPE -> Opcodes.LCONST_0;\n-            case F_TYPE -> Opcodes.FCONST_0;\n-            case D_TYPE -> Opcodes.DCONST_0;\n-            case L_TYPE -> Opcodes.ACONST_NULL;\n+    private void emitZero(CodeBuilder cob, BasicType type) {\n+        switch (type) {\n+            case I_TYPE -> cob.iconst_0();\n+            case J_TYPE -> cob.lconst_0();\n+            case F_TYPE -> cob.fconst_0();\n+            case D_TYPE -> cob.dconst_0();\n+            case L_TYPE -> cob.aconst_null();\n@@ -1623,1 +1429,1 @@\n-        });\n+        };\n@@ -1626,1 +1432,1 @@\n-    private void emitPushArguments(Name args, int start) {\n+    private void emitPushArguments(CodeBuilder cob, Name args, int start) {\n@@ -1629,1 +1435,1 @@\n-            emitPushArgument(type.parameterType(i), args.arguments[i]);\n+            emitPushArgument(cob, type.parameterType(i), args.arguments[i]);\n@@ -1633,1 +1439,1 @@\n-    private void emitPushArgument(Name name, int paramIndex) {\n+    private void emitPushArgument(CodeBuilder cob, Name name, int paramIndex) {\n@@ -1636,1 +1442,1 @@\n-        emitPushArgument(ptype, arg);\n+        emitPushArgument(cob, ptype, arg);\n@@ -1639,1 +1445,1 @@\n-    private void emitPushArgument(Class<?> ptype, Object arg) {\n+    private void emitPushArgument(CodeBuilder cob, Class<?> ptype, Object arg) {\n@@ -1642,6 +1448,4 @@\n-            emitLoadInsn(n.type, n.index());\n-            emitImplicitConversion(n.type, ptype, n);\n-        } else if (arg == null && bptype == L_TYPE) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-        } else if (arg instanceof String && bptype == L_TYPE) {\n-            mv.visitLdcInsn(arg);\n+            emitLoadInsn(cob, n.type.basicTypeKind(), n.index());\n+            emitImplicitConversion(cob, n.type, ptype, n);\n+        } else if ((arg == null || arg instanceof String) && bptype == L_TYPE) {\n+            cob.loadConstant((ConstantDesc)arg);\n@@ -1650,1 +1454,1 @@\n-                emitConst(arg);\n+                cob.loadConstant((ConstantDesc)arg);\n@@ -1652,2 +1456,2 @@\n-                mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(arg), \"Ljava\/lang\/Object;\");\n-                emitImplicitConversion(L_TYPE, ptype, arg);\n+                cob.getstatic(classDesc, classData(arg), CD_Object);\n+                emitImplicitConversion(cob, L_TYPE, ptype, arg);\n@@ -1661,1 +1465,1 @@\n-    private void emitStoreResult(Name name) {\n+    private void emitStoreResult(CodeBuilder cob, Name name) {\n@@ -1664,1 +1468,1 @@\n-            emitStoreInsn(name.type, name.index());\n+            emitStoreInsn(cob, name.type.basicTypeKind(), name.index());\n@@ -1671,1 +1475,1 @@\n-    private void emitReturn(Name onStack) {\n+    private void emitReturn(CodeBuilder cob, Name onStack) {\n@@ -1678,1 +1482,1 @@\n-            mv.visitInsn(Opcodes.RETURN);\n+            cob.return_();\n@@ -1685,1 +1489,1 @@\n-                emitLoadInsn(rtype, lambdaForm.result);\n+                emitLoadInsn(cob, rtype.basicTypeKind(), lambdaForm.result);\n@@ -1688,1 +1492,1 @@\n-            emitImplicitConversion(rtype, rclass, rn);\n+            emitImplicitConversion(cob, rtype, rclass, rn);\n@@ -1691,1 +1495,1 @@\n-            emitReturnInsn(rtype);\n+            cob.return_(rtype.basicTypeKind());\n@@ -1698,1 +1502,1 @@\n-    private void emitPrimCast(Wrapper from, Wrapper to) {\n+    private void emitPrimCast(CodeBuilder cob, TypeKind from, TypeKind to) {\n@@ -1711,74 +1515,4 @@\n-        if (from == to) {\n-            \/\/ no cast required, should be dead code anyway\n-            return;\n-        }\n-        if (from.isSubwordOrInt()) {\n-            \/\/ cast from {byte,short,char,int} to anything\n-            emitI2X(to);\n-        } else {\n-            \/\/ cast from {long,float,double} to anything\n-            if (to.isSubwordOrInt()) {\n-                \/\/ cast to {byte,short,char,int}\n-                emitX2I(from);\n-                if (to.bitWidth() < 32) {\n-                    \/\/ targets other than int require another conversion\n-                    emitI2X(to);\n-                }\n-            } else {\n-                \/\/ cast to {long,float,double} - this is verbose\n-                boolean error = false;\n-                switch (from) {\n-                    case LONG -> {\n-                        switch (to) {\n-                            case FLOAT  -> mv.visitInsn(Opcodes.L2F);\n-                            case DOUBLE -> mv.visitInsn(Opcodes.L2D);\n-                            default -> error = true;\n-                        }\n-                    }\n-                    case FLOAT -> {\n-                        switch (to) {\n-                            case LONG   -> mv.visitInsn(Opcodes.F2L);\n-                            case DOUBLE -> mv.visitInsn(Opcodes.F2D);\n-                            default -> error = true;\n-                        }\n-                    }\n-                    case DOUBLE -> {\n-                        switch (to) {\n-                            case LONG  -> mv.visitInsn(Opcodes.D2L);\n-                            case FLOAT -> mv.visitInsn(Opcodes.D2F);\n-                            default -> error = true;\n-                        }\n-                    }\n-                    default -> error = true;\n-                }\n-                if (error) {\n-                    throw new IllegalStateException(\"unhandled prim cast: \" + from + \"2\" + to);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void emitI2X(Wrapper type) {\n-        switch (type) {\n-        case BYTE:    mv.visitInsn(Opcodes.I2B);  break;\n-        case SHORT:   mv.visitInsn(Opcodes.I2S);  break;\n-        case CHAR:    mv.visitInsn(Opcodes.I2C);  break;\n-        case INT:     \/* naught *\/                break;\n-        case LONG:    mv.visitInsn(Opcodes.I2L);  break;\n-        case FLOAT:   mv.visitInsn(Opcodes.I2F);  break;\n-        case DOUBLE:  mv.visitInsn(Opcodes.I2D);  break;\n-        case BOOLEAN:\n-            \/\/ For compatibility with ValueConversions and explicitCastArguments:\n-            mv.visitInsn(Opcodes.ICONST_1);\n-            mv.visitInsn(Opcodes.IAND);\n-            break;\n-        default:   throw new InternalError(\"unknown type: \" + type);\n-        }\n-    }\n-\n-    private void emitX2I(Wrapper type) {\n-        switch (type) {\n-            case LONG -> mv.visitInsn(Opcodes.L2I);\n-            case FLOAT -> mv.visitInsn(Opcodes.F2I);\n-            case DOUBLE -> mv.visitInsn(Opcodes.D2I);\n-            default -> throw new InternalError(\"unknown type: \" + type);\n+        if (from != to && from != TypeKind.BooleanType) try {\n+            cob.conversion(from, to);\n+        } catch (IllegalArgumentException e) {\n+            throw new IllegalStateException(\"unhandled prim cast: \" + from + \"2\" + to);\n@@ -1801,22 +1535,52 @@\n-        classFilePrologue();\n-        methodPrologue();\n-\n-        \/\/ Suppress this method in backtraces displayed to the user.\n-        mv.visitAnnotation(HIDDEN_SIG, true);\n-\n-        \/\/ Don't inline the interpreter entry.\n-        mv.visitAnnotation(DONTINLINE_SIG, true);\n-\n-        \/\/ create parameter array\n-        emitIconstInsn(invokerType.parameterCount());\n-        mv.visitTypeInsn(Opcodes.ANEWARRAY, \"java\/lang\/Object\");\n-\n-        \/\/ fill parameter array\n-        for (int i = 0; i < invokerType.parameterCount(); i++) {\n-            Class<?> ptype = invokerType.parameterType(i);\n-            mv.visitInsn(Opcodes.DUP);\n-            emitIconstInsn(i);\n-            emitLoadInsn(basicType(ptype), i);\n-            \/\/ box if primitive type\n-            if (ptype.isPrimitive()) {\n-                emitBoxing(Wrapper.forPrimitiveType(ptype));\n+        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                methodSetup(clb, new Consumer<MethodBuilder>() {\n+                    @Override\n+                    public void accept(MethodBuilder mb) {\n+\n+                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(\n+                                HIDDEN,    \/\/ Suppress this method in backtraces displayed to the user.\n+                                DONTINLINE \/\/ Don't inline the interpreter entry.\n+                        )));\n+\n+                        mb.withCode(new Consumer<CodeBuilder>() {\n+                            @Override\n+                            public void accept(CodeBuilder cob) {\n+                                \/\/ create parameter array\n+                                cob.loadConstant(invokerType.parameterCount());\n+                                cob.anewarray(CD_Object);\n+\n+                                \/\/ fill parameter array\n+                                for (int i = 0; i < invokerType.parameterCount(); i++) {\n+                                    Class<?> ptype = invokerType.parameterType(i);\n+                                    cob.dup();\n+                                    cob.loadConstant(i);\n+                                    emitLoadInsn(cob, basicType(ptype).basicTypeKind(), i);\n+                                    \/\/ box if primitive type\n+                                    if (ptype.isPrimitive()) {\n+                                        emitBoxing(cob, TypeKind.from(ptype));\n+                                    }\n+                                    cob.aastore();\n+                                }\n+                                \/\/ invoke\n+                                cob.aload(0);\n+                                cob.getfield(CD_MethodHandle, \"form\", CD_LambdaForm);\n+                                cob.swap();  \/\/ swap form and array; avoid local variable\n+                                cob.invokevirtual(CD_LambdaForm, \"interpretWithArguments\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array));\n+\n+                                \/\/ maybe unbox\n+                                Class<?> rtype = invokerType.returnType();\n+                                TypeKind rtypeK = TypeKind.from(rtype);\n+                                if (rtype.isPrimitive() && rtype != void.class) {\n+                                    emitUnboxing(cob, rtypeK);\n+                                }\n+\n+                                \/\/ return statement\n+                                cob.return_(rtypeK);\n+                            }\n+                        });\n+                    }\n+                });\n+                clinit(clb, classDesc, classData);\n+                bogusMethod(clb, invokerType);\n@@ -1824,22 +1588,2 @@\n-            mv.visitInsn(Opcodes.AASTORE);\n-        }\n-        \/\/ invoke\n-        emitAloadInsn(0);\n-        mv.visitFieldInsn(Opcodes.GETFIELD, MH, \"form\", \"Ljava\/lang\/invoke\/LambdaForm;\");\n-        mv.visitInsn(Opcodes.SWAP);  \/\/ swap form and array; avoid local variable\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, \"interpretWithArguments\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-\n-        \/\/ maybe unbox\n-        Class<?> rtype = invokerType.returnType();\n-        if (rtype.isPrimitive() && rtype != void.class) {\n-            emitUnboxing(Wrapper.forPrimitiveType(rtype));\n-        }\n-\n-        \/\/ return statement\n-        emitReturnInsn(basicType(rtype));\n-\n-        methodEpilogue();\n-        clinit(cw, className, classData);\n-        bogusMethod(invokerType);\n-\n-        return cw.toByteArray();\n+        });\n+        return classFile;\n@@ -1860,25 +1604,59 @@\n-        classFilePrologue();\n-        methodPrologue();\n-\n-        \/\/ Suppress this method in backtraces displayed to the user.\n-        mv.visitAnnotation(HIDDEN_SIG, true);\n-\n-        \/\/ Force inlining of this invoker method.\n-        mv.visitAnnotation(FORCEINLINE_SIG, true);\n-\n-        \/\/ Load receiver\n-        emitAloadInsn(0);\n-\n-        \/\/ Load arguments from array\n-        for (int i = 0; i < dstType.parameterCount(); i++) {\n-            emitAloadInsn(1);\n-            emitIconstInsn(i);\n-            mv.visitInsn(Opcodes.AALOAD);\n-\n-            \/\/ Maybe unbox\n-            Class<?> dptype = dstType.parameterType(i);\n-            if (dptype.isPrimitive()) {\n-                Wrapper dstWrapper = Wrapper.forBasicType(dptype);\n-                Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  \/\/ narrow subword from int\n-                emitUnboxing(srcWrapper);\n-                emitPrimCast(srcWrapper, dstWrapper);\n+        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder clb) {\n+                methodSetup(clb, new Consumer<MethodBuilder>() {\n+                    @Override\n+                    public void accept(MethodBuilder mb) {\n+\n+                        mb.with(RuntimeVisibleAnnotationsAttribute.of(List.of(\n+                                HIDDEN,    \/\/ Suppress this method in backtraces displayed to the user.\n+                                FORCEINLINE \/\/ Force inlining of this invoker method.\n+                        )));\n+\n+                        mb.withCode(new Consumer<CodeBuilder>() {\n+                            @Override\n+                            public void accept(CodeBuilder cob) {\n+                                \/\/ Load receiver\n+                                cob.aload(0);\n+\n+                                \/\/ Load arguments from array\n+                                for (int i = 0; i < dstType.parameterCount(); i++) {\n+                                    cob.aload(1);\n+                                    cob.loadConstant(i);\n+                                    cob.aaload();\n+\n+                                    \/\/ Maybe unbox\n+                                    Class<?> dptype = dstType.parameterType(i);\n+                                    if (dptype.isPrimitive()) {\n+                                        TypeKind dstTK = TypeKind.from(dptype);\n+                                        TypeKind srcTK = dstTK.asLoadable();\n+                                        emitUnboxing(cob, srcTK);\n+                                        emitPrimCast(cob, srcTK, dstTK);\n+                                    }\n+                                }\n+\n+                                \/\/ Invoke\n+                                MethodTypeDesc targetDesc = methodDesc(dstType.basicType());\n+                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", targetDesc);\n+\n+                                \/\/ Box primitive types\n+                                Class<?> rtype = dstType.returnType();\n+                                if (rtype != void.class && rtype.isPrimitive()) {\n+                                    TypeKind srcTK = TypeKind.from(rtype);\n+                                    TypeKind dstTK = srcTK.asLoadable();\n+                                    \/\/ boolean casts not allowed\n+                                    emitPrimCast(cob, srcTK, dstTK);\n+                                    emitBoxing(cob, dstTK);\n+                                }\n+\n+                                \/\/ If the return type is void we return a null reference.\n+                                if (rtype == void.class) {\n+                                    cob.aconst_null();\n+                                }\n+                               cob.areturn();  \/\/ NOTE: NamedFunction invokers always return a reference value.\n+                            }\n+                        });\n+                    }\n+                });\n+                clinit(clb, classDesc, classData);\n+                bogusMethod(clb, dstType);\n@@ -1886,27 +1664,2 @@\n-        }\n-\n-        \/\/ Invoke\n-        String targetDesc = dstType.basicType().toMethodDescriptorString();\n-        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", targetDesc, false);\n-\n-        \/\/ Box primitive types\n-        Class<?> rtype = dstType.returnType();\n-        if (rtype != void.class && rtype.isPrimitive()) {\n-            Wrapper srcWrapper = Wrapper.forBasicType(rtype);\n-            Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  \/\/ widen subword to int\n-            \/\/ boolean casts not allowed\n-            emitPrimCast(srcWrapper, dstWrapper);\n-            emitBoxing(dstWrapper);\n-        }\n-\n-        \/\/ If the return type is void we return a null reference.\n-        if (rtype == void.class) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-        }\n-        emitReturnInsn(L_TYPE);  \/\/ NOTE: NamedFunction invokers always return a reference value.\n-\n-        methodEpilogue();\n-        clinit(cw, className, classData);\n-        bogusMethod(dstType);\n-\n-        return cw.toByteArray();\n+        });\n+        return classFile;\n@@ -1919,1 +1672,1 @@\n-    private void bogusMethod(Object os) {\n+    private void bogusMethod(ClassBuilder clb, Object os) {\n@@ -1921,6 +1674,24 @@\n-            mv = cw.visitMethod(Opcodes.ACC_STATIC, \"dummy\", \"()V\", null, null);\n-            mv.visitLdcInsn(os.toString());\n-            mv.visitInsn(Opcodes.POP);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cob) {\n+                    cob.loadConstant(os.toString());\n+                    cob.pop();\n+                    cob.return_();\n+                }\n+            }));\n+        }\n+    }\n+\n+    static ClassDesc classDesc(Class<?> cls) {\n+\/\/        assert(VerifyAccess.isTypeVisible(cls, Object.class)) : cls.getName();\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+             : cls == MethodHandle.class ? CD_MethodHandle\n+             : cls == DirectMethodHandle.class ? CD_DirectMethodHandle\n+             : cls == Object.class ? CD_Object\n+             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+    }\n+\n+    static MethodTypeDesc methodDesc(MethodType mt) {\n+        var params = new ClassDesc[mt.parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            params[i] = classDesc(mt.parameterType(i));\n@@ -1928,0 +1699,1 @@\n+        return MethodTypeDescImpl.ofValidated(classDesc(mt.returnType()), params);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":613,"deletions":841,"binary":false,"changes":1454,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.TypeKind;\n@@ -140,6 +141,6 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT),  \/\/ all reference types\n-        I_TYPE('I', int.class,    Wrapper.INT),\n-        J_TYPE('J', long.class,   Wrapper.LONG),\n-        F_TYPE('F', float.class,  Wrapper.FLOAT),\n-        D_TYPE('D', double.class, Wrapper.DOUBLE),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID);    \/\/ not valid in all contexts\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.ReferenceType), \/\/ all reference types\n+        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.IntType),\n+        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LongType),\n+        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FloatType),\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DoubleType),  \/\/ all primitive types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VoidType);    \/\/ not valid in all contexts\n@@ -156,0 +157,1 @@\n+        final TypeKind btKind;\n@@ -157,1 +159,1 @@\n-        private BasicType(char btChar, Class<?> btClass, Wrapper wrapper) {\n+        private BasicType(char btChar, Class<?> btClass, Wrapper wrapper, TypeKind typeKind) {\n@@ -161,0 +163,1 @@\n+            this.btKind = typeKind;\n@@ -172,0 +175,3 @@\n+        TypeKind basicTypeKind() {\n+            return btKind;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -31,1 +33,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n@@ -42,0 +43,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n@@ -59,0 +62,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -65,1 +70,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -1038,2 +1042,4 @@\n-        private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);\n-        private static MethodType REFLECT_INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object.class, Object[].class);\n+\n+        private static final ClassDesc CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);\n+        private static final MethodType REFLECT_INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object.class, Object[].class);\n@@ -1253,2 +1259,0 @@\n-            ClassWriter cw = new ClassWriter(0);\n-\n@@ -1268,33 +1272,19 @@\n-            cw.visit(CLASSFILE_VERSION, ACC_PRIVATE | ACC_SUPER, \"InjectedInvoker\", null, \"java\/lang\/Object\", null);\n-            {\n-                var mv = cw.visitMethod(ACC_STATIC, \"invoke_V\",\n-                        \"(Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n-                        null, null);\n-\n-                mv.visitCode();\n-                mv.visitVarInsn(ALOAD, 0);\n-                mv.visitVarInsn(ALOAD, 1);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n-                        \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-                mv.visitInsn(ARETURN);\n-                mv.visitMaxs(2, 2);\n-                mv.visitEnd();\n-\n-                cw.visitEnd();\n-            }\n-\n-            {\n-                var mv = cw.visitMethod(ACC_STATIC, \"reflect_invoke_V\",\n-                        \"(Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n-                        null, null);\n-                mv.visitCode();\n-                mv.visitVarInsn(ALOAD, 0);\n-                mv.visitVarInsn(ALOAD, 1);\n-                mv.visitVarInsn(ALOAD, 2);\n-                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n-                        \"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-                mv.visitInsn(ARETURN);\n-                mv.visitMaxs(3, 3);\n-                mv.visitEnd();\n-            }\n-            return cw.toByteArray();\n+            return ClassFile.of().build(ReferenceClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n+                    .withFlags(ACC_PRIVATE | ACC_SUPER)\n+                    .withMethodBody(\n+                        \"invoke_V\",\n+                        MethodTypeDescImpl.ofValidated(CD_Object, CD_MethodHandle, CD_Object_array),\n+                        ACC_STATIC,\n+                        cob -> cob.aload(0)\n+                                  .aload(1)\n+                                  .invokevirtual(CD_MethodHandle, \"invokeExact\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object_array))\n+                                  .areturn())\n+                    .withMethodBody(\n+                        \"reflect_invoke_V\",\n+                        MethodTypeDescImpl.ofValidated(CD_Object, CD_MethodHandle, CD_Object, CD_Object_array),\n+                        ACC_STATIC,\n+                        cob -> cob.aload(0)\n+                                  .aload(1)\n+                                  .aload(2)\n+                                  .invokevirtual(CD_MethodHandle, \"invokeExact\", MethodTypeDescImpl.ofValidated(CD_Object, CD_Object, CD_Object_array))\n+                                  .areturn()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":29,"deletions":39,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -45,0 +42,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -47,0 +45,1 @@\n+import java.lang.invoke.MethodHandleImpl.Intrinsic;\n@@ -65,0 +64,1 @@\n+import static java.lang.classfile.ClassFile.*;\n@@ -66,1 +66,0 @@\n-import static java.lang.invoke.MethodHandleImpl.Intrinsic;\n@@ -2291,15 +2290,4 @@\n-                    ClassReader reader = new ClassReader(bytes);\n-                    \/\/ ClassReader does not check if `this_class` is CONSTANT_Class_info\n-                    \/\/ workaround to read `this_class` using readConst and validate the value\n-                    int thisClass = reader.readUnsignedShort(reader.header + 2);\n-                    Object constant = reader.readConst(thisClass, new char[reader.getMaxStringLength()]);\n-                    if (!(constant instanceof Type type)) {\n-                        throw new ClassFormatError(\"this_class item: #\" + thisClass + \" not a CONSTANT_Class_info\");\n-                    }\n-                    if (!type.getDescriptor().startsWith(\"L\")) {\n-                        throw new ClassFormatError(\"this_class item: #\" + thisClass + \" not a CONSTANT_Class_info\");\n-                    }\n-                    name = type.getInternalName();\n-                    accessFlags = reader.readUnsignedShort(reader.header);\n-                } catch (RuntimeException e) {\n-                    \/\/ ASM exceptions are poorly specified\n+                    ClassModel cm = java.lang.classfile.ClassFile.of().parse(bytes);\n+                    name = cm.thisClass().asInternalName();\n+                    accessFlags = cm.flags().flagsMask();\n+                } catch (IllegalArgumentException e) {\n@@ -2311,1 +2299,1 @@\n-                if ((accessFlags & Opcodes.ACC_MODULE) != 0) {\n+                if ((accessFlags & ACC_MODULE) != 0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1294,7 +1294,2 @@\n-        try {\n-            return Optional.of(MethodTypeDesc.of(returnType().describeConstable().orElseThrow(),\n-                                                 Stream.of(parameterArray())\n-                                                      .map(p -> p.describeConstable().orElseThrow())\n-                                                      .toArray(ClassDesc[]::new)));\n-        }\n-        catch (NoSuchElementException e) {\n+        var retDesc = returnType().describeConstable();\n+        if (retDesc.isEmpty())\n@@ -1302,0 +1297,10 @@\n+\n+        if (parameterCount() == 0)\n+            return Optional.of(MethodTypeDesc.of(retDesc.get()));\n+\n+        var params = new ClassDesc[parameterCount()];\n+        for (int i = 0; i < params.length; i++) {\n+            var paramDesc = parameterType(i).describeConstable();\n+            if (paramDesc.isEmpty())\n+                return Optional.empty();\n+            params[i] = paramDesc.get();\n@@ -1303,0 +1308,1 @@\n+        return Optional.of(MethodTypeDesc.of(retDesc.get(), params));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,4 +28,7 @@\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import sun.invoke.util.BytecodeDescriptor;\n+import java.lang.constant.ClassDesc;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -33,1 +36,0 @@\n-import static sun.invoke.util.Wrapper.*;\n@@ -35,1 +37,1 @@\n-class TypeConvertingMethodAdapter extends MethodVisitor {\n+import static java.lang.constant.ConstantDescs.*;\n@@ -37,31 +39,1 @@\n-    TypeConvertingMethodAdapter(MethodVisitor mv) {\n-        super(Opcodes.ASM7, mv);\n-    }\n-\n-    private static final int NUM_WRAPPERS = Wrapper.COUNT;\n-\n-    private static final String NAME_OBJECT = \"java\/lang\/Object\";\n-    private static final String WRAPPER_PREFIX = \"Ljava\/lang\/\";\n-\n-    \/\/ Same for all primitives; name of the boxing method\n-    private static final String NAME_BOX_METHOD = \"valueOf\";\n-\n-    \/\/ Table of opcodes for widening primitive conversions; NOP = no conversion\n-    private static final int[][] wideningOpcodes = new int[NUM_WRAPPERS][NUM_WRAPPERS];\n-\n-    private static final Wrapper[] FROM_WRAPPER_NAME = new Wrapper[16];\n-\n-    \/\/ Table of wrappers for primitives, indexed by ASM type sorts\n-    private static final Wrapper[] FROM_TYPE_SORT = new Wrapper[12];\n-\n-    static {\n-        for (Wrapper w : Wrapper.values()) {\n-            if (w.basicTypeChar() != 'L') {\n-                int wi = hashWrapperName(w.wrapperSimpleName());\n-                assert (FROM_WRAPPER_NAME[wi] == null);\n-                FROM_WRAPPER_NAME[wi] = w;\n-            }\n-        }\n-\n-        \/\/ wideningOpcodes[][] will be NOP-initialized by default\n-        assert(Opcodes.NOP == 0);\n+class TypeConvertingMethodAdapter {\n@@ -69,7 +41,2 @@\n-        initWidening(LONG,   Opcodes.I2L, BYTE, SHORT, INT, CHAR);\n-        initWidening(LONG,   Opcodes.F2L, FLOAT);\n-        initWidening(FLOAT,  Opcodes.I2F, BYTE, SHORT, INT, CHAR);\n-        initWidening(FLOAT,  Opcodes.L2F, LONG);\n-        initWidening(DOUBLE, Opcodes.I2D, BYTE, SHORT, INT, CHAR);\n-        initWidening(DOUBLE, Opcodes.F2D, FLOAT);\n-        initWidening(DOUBLE, Opcodes.L2D, LONG);\n+    private static class BoxHolder {\n+        private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -77,13 +44,2 @@\n-        FROM_TYPE_SORT[Type.BYTE] = Wrapper.BYTE;\n-        FROM_TYPE_SORT[Type.SHORT] = Wrapper.SHORT;\n-        FROM_TYPE_SORT[Type.INT] = Wrapper.INT;\n-        FROM_TYPE_SORT[Type.LONG] = Wrapper.LONG;\n-        FROM_TYPE_SORT[Type.CHAR] = Wrapper.CHAR;\n-        FROM_TYPE_SORT[Type.FLOAT] = Wrapper.FLOAT;\n-        FROM_TYPE_SORT[Type.DOUBLE] = Wrapper.DOUBLE;\n-        FROM_TYPE_SORT[Type.BOOLEAN] = Wrapper.BOOLEAN;\n-    }\n-\n-    private static void initWidening(Wrapper to, int opcode, Wrapper... from) {\n-        for (Wrapper f : from) {\n-            wideningOpcodes[f.ordinal()][to.ordinal()] = opcode;\n+        private static MethodRefEntry box(ClassDesc primitive, ClassDesc target) {\n+            return CP.methodRefEntry(target, \"valueOf\", MethodTypeDescImpl.ofValidated(target, primitive));\n@@ -91,1 +47,0 @@\n-    }\n@@ -93,8 +48,11 @@\n-    \/**\n-     * Class name to Wrapper hash, derived from Wrapper.hashWrap()\n-     * @param xn\n-     * @return The hash code 0-15\n-     *\/\n-    private static int hashWrapperName(String xn) {\n-        if (xn.length() < 3) {\n-            return 0;\n+        private static final MethodRefEntry BOX_BOOLEAN = box(CD_boolean, CD_Boolean),\n+                                            BOX_BYTE    = box(CD_byte, CD_Byte),\n+                                            BOX_SHORT   = box(CD_short, CD_Short),\n+                                            BOX_CHAR    = box(CD_char, CD_Character),\n+                                            BOX_INT     = box(CD_int, CD_Integer),\n+                                            BOX_LONG    = box(CD_long, CD_Long),\n+                                            BOX_FLOAT   = box(CD_float, CD_Float),\n+                                            BOX_DOUBLE  = box(CD_double, CD_Double);\n+\n+        private static MethodRefEntry unbox(ClassDesc owner, String methodName, ClassDesc primitiveTarget) {\n+            return CP.methodRefEntry(owner, methodName, MethodTypeDescImpl.ofValidated(primitiveTarget));\n@@ -102,19 +60,0 @@\n-        return (3 * xn.charAt(1) + xn.charAt(2)) % 16;\n-    }\n-\n-    private Wrapper wrapperOrNullFromDescriptor(String desc) {\n-        if (!desc.startsWith(WRAPPER_PREFIX)) {\n-            \/\/ Not a class type (array or method), so not a boxed type\n-            \/\/ or not in the right package\n-            return null;\n-        }\n-        \/\/ Pare it down to the simple class name\n-        String cname = desc.substring(WRAPPER_PREFIX.length(), desc.length() - 1);\n-        \/\/ Hash to a Wrapper\n-        Wrapper w = FROM_WRAPPER_NAME[hashWrapperName(cname)];\n-        if (w == null || w.wrapperSimpleName().equals(cname)) {\n-            return w;\n-        } else {\n-            return null;\n-        }\n-    }\n@@ -122,2 +61,8 @@\n-    private static String wrapperName(Wrapper w) {\n-        return \"java\/lang\/\" + w.wrapperSimpleName();\n+        private static final MethodRefEntry UNBOX_BOOLEAN = unbox(CD_Boolean, \"booleanValue\", CD_boolean),\n+                                            UNBOX_BYTE    = unbox(CD_Number, \"byteValue\", CD_byte),\n+                                            UNBOX_SHORT   = unbox(CD_Number, \"shortValue\", CD_short),\n+                                            UNBOX_CHAR    = unbox(CD_Character, \"charValue\", CD_char),\n+                                            UNBOX_INT     = unbox(CD_Number, \"intValue\", CD_int),\n+                                            UNBOX_LONG    = unbox(CD_Number, \"longValue\", CD_long),\n+                                            UNBOX_FLOAT   = unbox(CD_Number, \"floatValue\", CD_float),\n+                                            UNBOX_DOUBLE  = unbox(CD_Number, \"doubleValue\", CD_double);\n@@ -126,2 +71,10 @@\n-    private static String unboxMethod(Wrapper w) {\n-        return w.primitiveSimpleName() + \"Value\";\n+    private static TypeKind primitiveTypeKindFromClass(Class<?> type) {\n+        if (type == int.class)     return TypeKind.IntType;\n+        if (type == long.class)    return TypeKind.LongType;\n+        if (type == boolean.class) return TypeKind.BooleanType;\n+        if (type == short.class)   return TypeKind.ShortType;\n+        if (type == byte.class)    return TypeKind.ByteType;\n+        if (type == char.class)    return TypeKind.CharType;\n+        if (type == float.class)   return TypeKind.FloatType;\n+        if (type == double.class)  return TypeKind.DoubleType;\n+        return null;\n@@ -130,2 +83,2 @@\n-    private static String boxingDescriptor(Wrapper w) {\n-        return \"(\" + w.basicTypeChar() + \")L\" + wrapperName(w) + \";\";\n+    static void boxIfTypePrimitive(CodeBuilder cob, TypeKind tk) {\n+        box(cob, tk);\n@@ -134,12 +87,3 @@\n-    private static String unboxingDescriptor(Wrapper w) {\n-        return \"()\" + w.basicTypeChar();\n-    }\n-\n-    void boxIfTypePrimitive(Type t) {\n-        Wrapper w = FROM_TYPE_SORT[t.getSort()];\n-        if (w != null) {\n-            box(w);\n-        }\n-    }\n-\n-    void widen(Wrapper ws, Wrapper wt) {\n+    static void widen(CodeBuilder cob, TypeKind ws, TypeKind wt) {\n+        ws = ws.asLoadable();\n+        wt = wt.asLoadable();\n@@ -147,4 +91,1 @@\n-            int opcode = wideningOpcodes[ws.ordinal()][wt.ordinal()];\n-            if (opcode != Opcodes.NOP) {\n-                visitInsn(opcode);\n-            }\n+            cob.conversion(ws, wt);\n@@ -154,27 +95,10 @@\n-    void box(Wrapper w) {\n-        visitMethodInsn(Opcodes.INVOKESTATIC,\n-                wrapperName(w),\n-                NAME_BOX_METHOD,\n-                boxingDescriptor(w), false);\n-    }\n-\n-    \/**\n-     * Convert types by unboxing. The source type is known to be a primitive wrapper.\n-     * @param sname A primitive wrapper corresponding to wrapped reference source type\n-     * @param wt A primitive wrapper being converted to\n-     *\/\n-    void unbox(String sname, Wrapper wt) {\n-        visitMethodInsn(Opcodes.INVOKEVIRTUAL,\n-                sname,\n-                unboxMethod(wt),\n-                unboxingDescriptor(wt), false);\n-    }\n-\n-    private String descriptorToName(String desc) {\n-        int last = desc.length() - 1;\n-        if (desc.charAt(0) == 'L' && desc.charAt(last) == ';') {\n-            \/\/ In descriptor form\n-            return desc.substring(1, last);\n-        } else {\n-            \/\/ Already in internal name form\n-            return desc;\n+    static void box(CodeBuilder cob, TypeKind tk) {\n+        switch (tk) {\n+            case BooleanType -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n+            case ByteType    -> cob.invokestatic(BoxHolder.BOX_BYTE);\n+            case CharType    -> cob.invokestatic(BoxHolder.BOX_CHAR);\n+            case DoubleType  -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n+            case FloatType   -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n+            case IntType     -> cob.invokestatic(BoxHolder.BOX_INT);\n+            case LongType    -> cob.invokestatic(BoxHolder.BOX_LONG);\n+            case ShortType   -> cob.invokestatic(BoxHolder.BOX_SHORT);\n@@ -184,5 +108,10 @@\n-    void cast(String ds, String dt) {\n-        String ns = descriptorToName(ds);\n-        String nt = descriptorToName(dt);\n-        if (!nt.equals(ns) && !nt.equals(NAME_OBJECT)) {\n-            visitTypeInsn(Opcodes.CHECKCAST, nt);\n+    static void unbox(CodeBuilder cob, TypeKind to) {\n+        switch (to) {\n+            case BooleanType -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n+            case ByteType    -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n+            case CharType    -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n+            case DoubleType  -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n+            case FloatType   -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n+            case IntType     -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n+            case LongType    -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n+            case ShortType   -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n@@ -192,4 +121,3 @@\n-    private Wrapper toWrapper(String desc) {\n-        char first = desc.charAt(0);\n-        if (first == '[' || first == '(') {\n-            first = 'L';\n+    static void cast(CodeBuilder cob, ClassDesc dt) {\n+        if (!dt.equals(CD_Object)) {\n+            cob.checkcast(dt);\n@@ -197,1 +125,0 @@\n-        return Wrapper.forBasicType(first);\n@@ -207,1 +134,1 @@\n-    void convertType(Class<?> arg, Class<?> target, Class<?> functional) {\n+    static void convertType(CodeBuilder cob, Class<?> arg, Class<?> target, Class<?> functional) {\n@@ -215,1 +142,0 @@\n-            Wrapper wArg = Wrapper.forPrimitiveType(arg);\n@@ -218,1 +144,1 @@\n-                widen(wArg, Wrapper.forPrimitiveType(target));\n+                widen(cob, TypeKind.from(arg), TypeKind.from(target));\n@@ -221,3 +147,2 @@\n-                String dTarget = BytecodeDescriptor.unparse(target);\n-                Wrapper wPrimTarget = wrapperOrNullFromDescriptor(dTarget);\n-                if (wPrimTarget != null) {\n+                TypeKind wPrimTk = primitiveTypeKindFromClass(target);\n+                if (wPrimTk != null) {\n@@ -225,2 +150,2 @@\n-                    widen(wArg, wPrimTarget);\n-                    box(wPrimTarget);\n+                    widen(cob, TypeKind.from(arg), wPrimTk);\n+                    box(cob, wPrimTk);\n@@ -229,2 +154,2 @@\n-                    box(wArg);\n-                    cast(wrapperName(wArg), dTarget);\n+                    box(cob, TypeKind.from(arg));\n+                    cast(cob, classDesc(target));\n@@ -234,4 +159,3 @@\n-            String dArg = BytecodeDescriptor.unparse(arg);\n-            String dSrc;\n-            if (functional.isPrimitive()) {\n-                dSrc = dArg;\n+            Class<?> src;\n+            if (arg == functional || functional.isPrimitive()) {\n+                src = arg;\n@@ -240,2 +164,2 @@\n-                dSrc = BytecodeDescriptor.unparse(functional);\n-                cast(dArg, dSrc);\n+                src = functional;\n+                cast(cob, classDesc(functional));\n@@ -243,1 +167,0 @@\n-            String dTarget = BytecodeDescriptor.unparse(target);\n@@ -245,1 +168,0 @@\n-                Wrapper wTarget = toWrapper(dTarget);\n@@ -247,1 +169,1 @@\n-                Wrapper wps = wrapperOrNullFromDescriptor(dSrc);\n+                TypeKind wps = primitiveTypeKindFromClass(src);\n@@ -249,1 +171,1 @@\n-                    if (wps.isSigned() || wps.isFloating()) {\n+                    if (src != Character.class && src != Boolean.class) {\n@@ -251,1 +173,1 @@\n-                        unbox(wrapperName(wps), wTarget);\n+                        unbox(cob, TypeKind.from(target));\n@@ -254,2 +176,2 @@\n-                        unbox(wrapperName(wps), wps);\n-                        widen(wps, wTarget);\n+                        unbox(cob, wps);\n+                        widen(cob, wps, TypeKind.from(target));\n@@ -260,4 +182,4 @@\n-                    String intermediate;\n-                    if (wTarget.isSigned() || wTarget.isFloating()) {\n-                        \/\/ Boxed number to primitive\n-                        intermediate = \"java\/lang\/Number\";\n+                    if (target == char.class) {\n+                        cast(cob, CD_Character);\n+                    } else if (target == boolean.class) {\n+                        cast(cob, CD_Boolean);\n@@ -265,2 +187,2 @@\n-                        \/\/ Character or Boolean\n-                        intermediate = wrapperName(wTarget);\n+                        \/\/ Boxed number to primitive\n+                        cast(cob, CD_Number);\n@@ -268,2 +190,1 @@\n-                    cast(dSrc, intermediate);\n-                    unbox(intermediate, wTarget);\n+                    unbox(cob, TypeKind.from(target));\n@@ -273,1 +194,3 @@\n-                cast(dSrc, dTarget);\n+                if (src != target) {\n+                    cast(cob, classDesc(target));\n+                }\n@@ -278,16 +201,5 @@\n-    \/**\n-     * The following method is copied from\n-     * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small\n-     * and fast Java bytecode manipulation framework.\n-     * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.\n-     *\/\n-    void iconst(final int cst) {\n-        if (cst >= -1 && cst <= 5) {\n-            mv.visitInsn(Opcodes.ICONST_0 + cst);\n-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-        } else {\n-            mv.visitLdcInsn(cst);\n-        }\n+    static ClassDesc classDesc(Class<?> cls) {\n+        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n+             : cls == Object.class ? CD_Object\n+             : cls == String.class ? CD_String\n+             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":104,"deletions":192,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -28,4 +28,3 @@\n-import java.lang.classfile.constantpool.InvokeDynamicEntry;\n-import java.lang.constant.ClassDesc;\n-import static java.lang.constant.ConstantDescs.*;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.BufWriter;\n@@ -33,0 +32,2 @@\n+import java.lang.classfile.Label;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -35,1 +36,0 @@\n-import java.lang.classfile.constantpool.MemberRefEntry;\n@@ -37,0 +37,4 @@\n+import java.lang.classfile.constantpool.InvokeDynamicEntry;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -44,1 +48,1 @@\n-import java.lang.classfile.Attribute;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -47,6 +51,1 @@\n-import static jdk.internal.constant.ConstantUtils.binaryNameToDesc;\n-\n-import java.lang.classfile.BufWriter;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n-import java.lang.classfile.Attributes;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -1252,8 +1251,8 @@\n-            INT_ARRAY_TYPE = referenceType(CD_int.arrayType()),\n-            BOOLEAN_ARRAY_TYPE = referenceType(CD_boolean.arrayType()),\n-            BYTE_ARRAY_TYPE = referenceType(CD_byte.arrayType()),\n-            CHAR_ARRAY_TYPE = referenceType(CD_char.arrayType()),\n-            SHORT_ARRAY_TYPE = referenceType(CD_short.arrayType()),\n-            LONG_ARRAY_TYPE = referenceType(CD_long.arrayType()),\n-            DOUBLE_ARRAY_TYPE = referenceType(CD_double.arrayType()),\n-            FLOAT_ARRAY_TYPE = referenceType(CD_float.arrayType()),\n+            INT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[I\")),\n+            BOOLEAN_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[Z\")),\n+            BYTE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[B\")),\n+            CHAR_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[C\")),\n+            SHORT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[S\")),\n+            LONG_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[J\")),\n+            DOUBLE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[D\")),\n+            FLOAT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[F\")),\n@@ -1324,2 +1323,2 @@\n-        private static final ClassDesc CD_Cloneable = binaryNameToDesc(\"java.lang.Cloneable\");\n-        private static final ClassDesc CD_Serializable = binaryNameToDesc(\"java.io.Serializable\");\n+        private static final ClassDesc CD_Cloneable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n+        private static final ClassDesc CD_Serializable = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"}]}