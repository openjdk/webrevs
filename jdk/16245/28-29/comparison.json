{"files":[{"patch":"@@ -2919,1 +2919,2 @@\n-  Node* merged_input_value(const Node_List& merge_list, const int new_memory_size);\n+  Node* merged_input_value(const Node_List& merge_list);\n+  StoreNode* make_merged_store(const Node_List& merge_list, Node* new_input_value);\n@@ -2949,1 +2950,0 @@\n-  \/\/ Collect list of stores\n@@ -2953,1 +2953,0 @@\n-  int new_memory_size = _store->memory_size() * merge_list.size();\n@@ -2955,1 +2954,1 @@\n-  Node* new_input_value = merged_input_value(merge_list, new_memory_size);\n+  Node* new_input_value = merged_input_value(merge_list);\n@@ -2958,20 +2957,1 @@\n-  Node* first    = merge_list.at(merge_list.size()-1);\n-  Node* new_ctrl = _store->in(MemNode::Control); \/\/ must take last: after all RangeChecks\n-  Node* new_mem  = first->in(MemNode::Memory);\n-  Node* new_adr  = first->in(MemNode::Address);\n-  const TypePtr* new_adr_type = _store->adr_type();\n-  BasicType bt = T_ILLEGAL;\n-  switch (new_memory_size) {\n-    case 2: bt = T_SHORT; break;\n-    case 4: bt = T_INT;   break;\n-    case 8: bt = T_LONG;  break;\n-  }\n-\n-  StoreNode* new_store = StoreNode::make(*_phase, new_ctrl, new_mem, new_adr,\n-                                         new_adr_type, new_input_value, bt, MemNode::unordered);\n-  \/\/ Marking the store mismatched is sufficient to prevent reordering, since array stores\n-  \/\/ are all on the same slice. Hence, we need no barriers.\n-  new_store->set_mismatched_access();\n-\n-  \/\/ Constants above may now also be be packed -> put candidate on worklist\n-  _phase->is_IterGVN()->_worklist.push(new_mem);\n+  StoreNode* new_store = make_merged_store(merge_list, new_input_value);\n@@ -3253,1 +3233,2 @@\n-Node* MergePrimitiveArrayStores::merged_input_value(const Node_List& merge_list, const int new_memory_size) {\n+Node* MergePrimitiveArrayStores::merged_input_value(const Node_List& merge_list) {\n+  int new_memory_size = _store->memory_size() * merge_list.size();\n@@ -3304,0 +3285,26 @@\n+StoreNode* MergePrimitiveArrayStores::make_merged_store(const Node_List& merge_list, Node* new_input_value) {\n+  Node* first    = merge_list.at(merge_list.size()-1);\n+  Node* new_ctrl = _store->in(MemNode::Control); \/\/ must take last: after all RangeChecks\n+  Node* new_mem  = first->in(MemNode::Memory);\n+  Node* new_adr  = first->in(MemNode::Address);\n+  const TypePtr* new_adr_type = _store->adr_type();\n+  BasicType bt = T_ILLEGAL;\n+  int new_memory_size = _store->memory_size() * merge_list.size();\n+  switch (new_memory_size) {\n+    case 2: bt = T_SHORT; break;\n+    case 4: bt = T_INT;   break;\n+    case 8: bt = T_LONG;  break;\n+  }\n+\n+  StoreNode* new_store = StoreNode::make(*_phase, new_ctrl, new_mem, new_adr,\n+                                         new_adr_type, new_input_value, bt, MemNode::unordered);\n+  \/\/ Marking the store mismatched is sufficient to prevent reordering, since array stores\n+  \/\/ are all on the same slice. Hence, we need no barriers.\n+  new_store->set_mismatched_access();\n+\n+  \/\/ Constants above may now also be be packed -> put candidate on worklist\n+  _phase->is_IterGVN()->_worklist.push(new_mem);\n+\n+  return new_store;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"}]}