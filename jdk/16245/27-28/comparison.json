{"files":[{"patch":"@@ -2688,2 +2688,6 @@\n-\/\/ Class to parse array pointers of the form:\n-\/\/ pointer = base + constant_offset + (int_offset << int_offset_shift) + sum(other_offsets)\n+\/\/ Class to parse array pointers, and determine if they are adjacent. We parse the form:\n+\/\/\n+\/\/   pointer =   base\n+\/\/             + constant_offset\n+\/\/             + LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+\/\/             + sum(other_offsets)\n@@ -2691,1 +2695,0 @@\n-\/\/ The goal is to check if two such ArrayPointers are adjacent for a load or store.\n@@ -2694,3 +2697,3 @@\n-\/\/       the LShiftL(ConvI2L(...)) pattern. For this, we convert \"ConvI2L(x + int_con)\" to\n-\/\/       \"ConvI2L(x) + int_con\", which is only safe if we can assume that either all compared\n-\/\/       addresses have an overflow for \"x + int_con\" or none.\n+\/\/       the \"LShiftL(ConvI2L(...))\" pattern. We convert \"ConvI2L(int_offset + int_con)\" to\n+\/\/       \"ConvI2L(int_offset) + int_con\", which is only safe if we can assume that either all\n+\/\/       compared addresses have an overflow for \"int_offset + int_con\" or none.\n@@ -2701,0 +2704,8 @@\n+\/\/\n+\/\/   constant_offset += LShiftL( ConvI2L(int_con), int_offset_shift)\n+\/\/\n+\/\/   pointer =   base\n+\/\/             + constant_offset\n+\/\/             + LShiftL( ConvI2L(int_offset), int_offset_shift)\n+\/\/             + sum(other_offsets)\n+\/\/\n@@ -2773,1 +2784,6 @@\n-    \/\/ pointer = base + constant_offset + (int_offset << int_offset_shift) + sum(other_offsets)\n+    \/\/\n+    \/\/   pointer =   base\n+    \/\/             + constant_offset\n+    \/\/             + LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+    \/\/             + sum(other_offsets)\n+    \/\/\n@@ -2902,1 +2918,2 @@\n-  Node* merged_input_value(const Node_List& merge_listi, const int new_memory_size);\n+  void collect_merge_list(Node_List& merge_list) const;\n+  Node* merged_input_value(const Node_List& merge_list, const int new_memory_size);\n@@ -2919,1 +2936,2 @@\n-  \/\/ If we can merge with use, then we must process use first.\n+  \/\/ The _store must be the \"last\" store in a chain. If we find a use we could merge with\n+  \/\/ then that use or a store further down is the \"last\" store.\n@@ -2925,1 +2943,1 @@\n-  \/\/ Check if we can merge with at least one def.\n+  \/\/ Check if we can merge with at least one def, so that we have at least 2 stores to merge.\n@@ -2931,1 +2949,1 @@\n-  \/\/ Now we know we can merge at least two stores.\n+  \/\/ Collect list of stores\n@@ -2934,27 +2952,1 @@\n-\n-  uint merge_list_max_size = 8 \/ _store->memory_size();\n-  assert(merge_list_max_size >= 2 &&\n-         merge_list_max_size <= 8 &&\n-         is_power_of_2(merge_list_max_size),\n-         \"must be 2, 4 or 8\");\n-\n-  \/\/ Collect list of stores\n-  StoreNode* current = _store;\n-  merge_list.push(current);\n-  while (current != nullptr && merge_list.size() < merge_list_max_size) {\n-    Status status = find_adjacent_def_store(current);\n-    current = status.found_store();\n-    if (current != nullptr) {\n-      merge_list.push(current);\n-\n-      \/\/ We can have at most one RangeCheck.\n-      if (status.found_range_check()) {\n-        break;\n-      }\n-    }\n-  }\n-\n-  \/\/ Truncate the merge_list to a power of 2.\n-  uint pow2size = round_down_power_of_2(merge_list.size());\n-  assert(pow2size >= 2, \"must be merging at least 2 stores\");\n-  while (merge_list.size() > pow2size) { merge_list.pop(); }\n+  collect_merge_list(merge_list);\n@@ -3230,0 +3222,30 @@\n+void MergePrimitiveArrayStores::collect_merge_list(Node_List& merge_list) const {\n+  \/\/ The merged store can be at most 8 bytes.\n+  const uint merge_list_max_size = 8 \/ _store->memory_size();\n+  assert(merge_list_max_size >= 2 &&\n+         merge_list_max_size <= 8 &&\n+         is_power_of_2(merge_list_max_size),\n+         \"must be 2, 4 or 8\");\n+\n+  \/\/ Collect list of stores\n+  StoreNode* current = _store;\n+  merge_list.push(current);\n+  while (current != nullptr && merge_list.size() < merge_list_max_size) {\n+    Status status = find_adjacent_def_store(current);\n+    current = status.found_store();\n+    if (current != nullptr) {\n+      merge_list.push(current);\n+\n+      \/\/ We can have at most one RangeCheck.\n+      if (status.found_range_check()) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/\/ Truncate the merge_list to a power of 2.\n+  const uint pow2size = round_down_power_of_2(merge_list.size());\n+  assert(pow2size >= 2, \"must be merging at least 2 stores\");\n+  while (merge_list.size() > pow2size) { merge_list.pop(); }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":60,"deletions":38,"binary":false,"changes":98,"status":"modified"}]}