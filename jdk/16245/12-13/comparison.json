{"files":[{"patch":"@@ -2884,1 +2884,2 @@\n-    tty->print_cr(\"[TraceMergeStores]: Replace\");\n+    stringStream ss;\n+    ss.print_cr(\"[TraceMergeStores]: Replace\");\n@@ -2886,1 +2887,1 @@\n-      merge_list.at(i)->dump();\n+      merge_list.at(i)->dump(\"\\n\", false, &ss);\n@@ -2888,2 +2889,3 @@\n-    tty->print_cr(\"[TraceMergeStores]: with\");\n-    new_store->dump();\n+    ss.print_cr(\"[TraceMergeStores]: with\");\n+    new_store->dump(\"\\n\", false, &ss);\n+    tty->print(\"%s\", ss.as_string());\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        Object[] run();\n+        Object[] run(boolean isWarmUp, int rnd);\n@@ -77,1 +77,2 @@\n-                                   \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+                                   \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-Xbatch\");\n@@ -82,10 +83,10 @@\n-        testGroups.get(\"test1\").put(\"test1R\", () -> { return test1R(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1a\", () -> { return test1a(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1b\", () -> { return test1b(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1c\", () -> { return test1c(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1d\", () -> { return test1d(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1e\", () -> { return test1e(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1f\", () -> { return test1f(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1g\", () -> { return test1g(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1h\", () -> { return test1h(aB.clone()); });\n-        testGroups.get(\"test1\").put(\"test1i\", () -> { return test1i(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1R\", (_,_) -> { return test1R(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1a\", (_,_) -> { return test1a(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1b\", (_,_) -> { return test1b(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1c\", (_,_) -> { return test1c(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1d\", (_,_) -> { return test1d(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1e\", (_,_) -> { return test1e(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1f\", (_,_) -> { return test1f(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1g\", (_,_) -> { return test1g(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1h\", (_,_) -> { return test1h(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1i\", (_,_) -> { return test1i(aB.clone()); });\n@@ -94,6 +95,6 @@\n-        testGroups.get(\"test2\").put(\"test2R\", () -> { return test2R(aB.clone(), offset1, vL1); });\n-        testGroups.get(\"test2\").put(\"test2a\", () -> { return test2a(aB.clone(), offset1, vL1); });\n-        testGroups.get(\"test2\").put(\"test2b\", () -> { return test2b(aB.clone(), offset1, vL1); });\n-        testGroups.get(\"test2\").put(\"test2c\", () -> { return test2c(aB.clone(), offset1, vL1); });\n-        testGroups.get(\"test2\").put(\"test2d\", () -> { return test2d(aB.clone(), offset1, vL1); });\n-        testGroups.get(\"test2\").put(\"test2e\", () -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2R\", (_,_) -> { return test2R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2a\", (_,_) -> { return test2a(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2b\", (_,_) -> { return test2b(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2c\", (_,_) -> { return test2c(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2d\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2d(aB.clone(), offset1, vL1); });\n@@ -102,2 +103,2 @@\n-        testGroups.get(\"test3\").put(\"test3R\", () -> { return test3R(aB.clone(), offset1, vL1); });\n-        testGroups.get(\"test3\").put(\"test3a\", () -> { return test3a(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test3\").put(\"test3R\", (_,_) -> { return test3R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test3\").put(\"test3a\", (_,_) -> { return test3a(aB.clone(), offset1, vL1); });\n@@ -106,2 +107,2 @@\n-        testGroups.get(\"test4\").put(\"test4R\", () -> { return test4R(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n-        testGroups.get(\"test4\").put(\"test4a\", () -> { return test4a(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+        testGroups.get(\"test4\").put(\"test4R\", (_,_) -> { return test4R(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+        testGroups.get(\"test4\").put(\"test4a\", (_,_) -> { return test4a(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n@@ -110,2 +111,2 @@\n-        testGroups.get(\"test5\").put(\"test5R\", () -> { return test5R(aB.clone(), offset1); });\n-        testGroups.get(\"test5\").put(\"test5a\", () -> { return test5a(aB.clone(), offset1); });\n+        testGroups.get(\"test5\").put(\"test5R\", (_,_) -> { return test5R(aB.clone(), offset1); });\n+        testGroups.get(\"test5\").put(\"test5a\", (_,_) -> { return test5a(aB.clone(), offset1); });\n@@ -114,2 +115,2 @@\n-        testGroups.get(\"test6\").put(\"test6R\", () -> { return test6R(aB.clone(), bB.clone(), offset1, offset2); });\n-        testGroups.get(\"test6\").put(\"test6a\", () -> { return test6a(aB.clone(), bB.clone(), offset1, offset2); });\n+        testGroups.get(\"test6\").put(\"test6R\", (_,_) -> { return test6R(aB.clone(), bB.clone(), offset1, offset2); });\n+        testGroups.get(\"test6\").put(\"test6a\", (_,_) -> { return test6a(aB.clone(), bB.clone(), offset1, offset2); });\n@@ -118,2 +119,2 @@\n-        testGroups.get(\"test100\").put(\"test100R\", () -> { return test100R(aS.clone(), offset1); });\n-        testGroups.get(\"test100\").put(\"test100a\", () -> { return test100a(aS.clone(), offset1); });\n+        testGroups.get(\"test100\").put(\"test100R\", (_,_) -> { return test100R(aS.clone(), offset1); });\n+        testGroups.get(\"test100\").put(\"test100a\", (_,_) -> { return test100a(aS.clone(), offset1); });\n@@ -122,2 +123,2 @@\n-        testGroups.get(\"test101\").put(\"test101R\", () -> { return test101R(aS.clone(), offset1); });\n-        testGroups.get(\"test101\").put(\"test101a\", () -> { return test101a(aS.clone(), offset1); });\n+        testGroups.get(\"test101\").put(\"test101R\", (_,_) -> { return test101R(aS.clone(), offset1); });\n+        testGroups.get(\"test101\").put(\"test101a\", (_,_) -> { return test101a(aS.clone(), offset1); });\n@@ -126,2 +127,2 @@\n-        testGroups.get(\"test102\").put(\"test102R\", () -> { return test102R(aS.clone(), offset1, vL1, vI1, vS1); });\n-        testGroups.get(\"test102\").put(\"test102a\", () -> { return test102a(aS.clone(), offset1, vL1, vI1, vS1); });\n+        testGroups.get(\"test102\").put(\"test102R\", (_,_) -> { return test102R(aS.clone(), offset1, vL1, vI1, vS1); });\n+        testGroups.get(\"test102\").put(\"test102a\", (_,_) -> { return test102a(aS.clone(), offset1, vL1, vI1, vS1); });\n@@ -130,2 +131,2 @@\n-        testGroups.get(\"test200\").put(\"test200R\", () -> { return test200R(aI.clone(), offset1); });\n-        testGroups.get(\"test200\").put(\"test200a\", () -> { return test200a(aI.clone(), offset1); });\n+        testGroups.get(\"test200\").put(\"test200R\", (_,_) -> { return test200R(aI.clone(), offset1); });\n+        testGroups.get(\"test200\").put(\"test200a\", (_,_) -> { return test200a(aI.clone(), offset1); });\n@@ -134,2 +135,2 @@\n-        testGroups.get(\"test201\").put(\"test201R\", () -> { return test201R(aI.clone(), offset1); });\n-        testGroups.get(\"test201\").put(\"test201a\", () -> { return test201a(aI.clone(), offset1); });\n+        testGroups.get(\"test201\").put(\"test201R\", (_,_) -> { return test201R(aI.clone(), offset1); });\n+        testGroups.get(\"test201\").put(\"test201a\", (_,_) -> { return test201a(aI.clone(), offset1); });\n@@ -138,2 +139,2 @@\n-        testGroups.get(\"test202\").put(\"test202R\", () -> { return test202R(aI.clone(), offset1, vL1, vI1); });\n-        testGroups.get(\"test202\").put(\"test202a\", () -> { return test202a(aI.clone(), offset1, vL1, vI1); });\n+        testGroups.get(\"test202\").put(\"test202R\", (_,_) -> { return test202R(aI.clone(), offset1, vL1, vI1); });\n+        testGroups.get(\"test202\").put(\"test202a\", (_,_) -> { return test202a(aI.clone(), offset1, vL1, vI1); });\n@@ -142,2 +143,2 @@\n-        testGroups.get(\"test300\").put(\"test300R\", () -> { return test300R(aI.clone()); });\n-        testGroups.get(\"test300\").put(\"test300a\", () -> { return test300a(aI.clone()); });\n+        testGroups.get(\"test300\").put(\"test300R\", (_,_) -> { return test300R(aI.clone()); });\n+        testGroups.get(\"test300\").put(\"test300a\", (_,_) -> { return test300a(aI.clone()); });\n@@ -146,2 +147,19 @@\n-        testGroups.get(\"test400\").put(\"test400R\", () -> { return test400R(aI.clone()); });\n-        testGroups.get(\"test400\").put(\"test400a\", () -> { return test400a(aI.clone()); });\n+        testGroups.get(\"test400\").put(\"test400R\", (_,_) -> { return test400R(aI.clone()); });\n+        testGroups.get(\"test400\").put(\"test400a\", (_,_) -> { return test400a(aI.clone()); });\n+\n+        testGroups.put(\"test500\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test500\").put(\"test500R\", (w,r) -> { return test500R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test500\").put(\"test500a\", (w,r) -> { return test500a(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test501\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test501\").put(\"test500R\", (w,r) -> { return test500R(aB.clone(), RANGE - 20 + (Math.abs(r) % 30), vL1); });\n+        testGroups.get(\"test501\").put(\"test501a\", (w,r) -> { return test501a(aB.clone(), RANGE - 20 + (Math.abs(r) % 30), vL1); });\n+        \/\/                                                                               +-----------------------------+\n+        \/\/ Create offsets that are sometimes going to pass all RangeChecks, and sometimes one, and sometimes none.\n+\n+        testGroups.put(\"test502\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test502\").put(\"test500R\", (w,r) -> { return test500R(aB.clone(), w ? offset1 : RANGE - 20 + (Math.abs(r) % 30), vL1); });\n+        testGroups.get(\"test502\").put(\"test502a\", (w,r) -> { return test502a(aB.clone(), w ? offset1 : RANGE - 20 + (Math.abs(r) % 30), vL1); });\n+        \/\/                                                                                   +-----+   +-----------------------------+\n+        \/\/ First use something in range, and after warmup randomize going outside the range.\n+        \/\/ This should first trigger optimized compilation (merge strores), and then deopt and compile without merging.\n@@ -150,1 +168,1 @@\n-    @Warmup(100)\n+    @Warmup(10)\n@@ -176,38 +194,47 @@\n-                 \"test400a\"})\n-    public void runTests() {\n-        \/\/ Write random values to inputs\n-        set_random(aB);\n-        set_random(bB);\n-        set_random(aS);\n-        set_random(bS);\n-        set_random(aI);\n-        set_random(bI);\n-        set_random(aL);\n-        set_random(bL);\n-\n-        offset1 = Math.abs(RANDOM.nextInt()) % 100;\n-        offset2 = Math.abs(RANDOM.nextInt()) % 100;\n-        vB1 = (byte)RANDOM.nextInt();\n-        vB2 = (byte)RANDOM.nextInt();\n-        vS1 = (short)RANDOM.nextInt();\n-        vS2 = (short)RANDOM.nextInt();\n-        vI1 = RANDOM.nextInt();\n-        vI2 = RANDOM.nextInt();\n-        vL1 = RANDOM.nextLong();\n-        vL2 = RANDOM.nextLong();\n-\n-        \/\/ Run all tests\n-        for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n-            String group_name = group_entry.getKey();\n-            Map<String, TestFunction> group = group_entry.getValue();\n-            Object[] gold = null;\n-            String gold_name = \"NONE\";\n-            for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n-                String name = entry.getKey();\n-                TestFunction test = entry.getValue();\n-                Object[] result = test.run();\n-                if (gold == null) {\n-                    gold = result;\n-                    gold_name = name;\n-                } else {\n-                    verify(\"group \" + group_name + \", gold \" + gold_name + \", test \" + name, gold, result);\n+                 \"test400a\",\n+                 \"test500a\",\n+                 \"test501a\",\n+                 \"test502a\"})\n+    public void runTests(RunInfo info) {\n+        \/\/ Repeat many times, so that we also have multiple iterations for post-warmup\n+        for (int iter = 0; iter < 100; iter++) {\n+            \/\/ Write random values to inputs\n+            set_random(aB);\n+            set_random(bB);\n+            set_random(aS);\n+            set_random(bS);\n+            set_random(aI);\n+            set_random(bI);\n+            set_random(aL);\n+            set_random(bL);\n+\n+            offset1 = Math.abs(RANDOM.nextInt()) % 100;\n+            offset2 = Math.abs(RANDOM.nextInt()) % 100;\n+            vB1 = (byte)RANDOM.nextInt();\n+            vB2 = (byte)RANDOM.nextInt();\n+            vS1 = (short)RANDOM.nextInt();\n+            vS2 = (short)RANDOM.nextInt();\n+            vI1 = RANDOM.nextInt();\n+            vI2 = RANDOM.nextInt();\n+            vL1 = RANDOM.nextLong();\n+            vL2 = RANDOM.nextLong();\n+\n+            boolean isWarmUp = info.isWarmUp();\n+            int rnd = RANDOM.nextInt();\n+\n+            \/\/ Run all tests\n+            for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n+                String group_name = group_entry.getKey();\n+                Map<String, TestFunction> group = group_entry.getValue();\n+                Object[] gold = null;\n+                String gold_name = \"NONE\";\n+                for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n+                    String name = entry.getKey();\n+                    TestFunction test = entry.getValue();\n+                    Object[] result = test.run(isWarmUp, rnd);\n+                    if (gold == null) {\n+                        gold = result;\n+                        gold_name = name;\n+                    } else {\n+                        verify(\"group \" + group_name + \", gold \" + gold_name + \", test \" + name, gold, result);\n+                    }\n@@ -1045,0 +1072,113 @@\n+\n+    @DontCompile\n+    \/\/ The 500-series has all the same code, but is executed with different inputs:\n+    \/\/ 500a: never violate a RangeCheck -> expect will always merge stores\n+    \/\/ 501a: randomly violate RangeCheck, also during warmup -> never merge stores\n+    \/\/ 502a: during warmup never violate RangeCheck -> compile once with merged stores\n+    \/\/       but then after warmup violate RangeCheck -> recompile without merged stores\n+    static Object[] test500R(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ for RangeCheck trap\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"}) \/\/ expect merged\n+    static Object[] test500a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test501a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test502a(byte[] a, int offset, long v) {\n+        int idx = 0;\n+        try {\n+            a[offset + 0] = (byte)(v >> 0);\n+            idx = 1;\n+            a[offset + 1] = (byte)(v >> 8);\n+            idx = 2;\n+            a[offset + 2] = (byte)(v >> 16);\n+            idx = 3;\n+            a[offset + 3] = (byte)(v >> 24);\n+            idx = 4;\n+            a[offset + 4] = (byte)(v >> 32);\n+            idx = 5;\n+            a[offset + 5] = (byte)(v >> 40);\n+            idx = 6;\n+            a[offset + 6] = (byte)(v >> 48);\n+            idx = 7;\n+            a[offset + 7] = (byte)(v >> 56);\n+            idx = 8;\n+        } catch (ArrayIndexOutOfBoundsException _) {}\n+        return new Object[]{ a, new int[]{ idx } };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":221,"deletions":81,"binary":false,"changes":302,"status":"modified"}]}