{"files":[{"patch":"@@ -2919,2 +2919,2 @@\n-  Node* merged_input_value(const Node_List& merge_list);\n-  StoreNode* make_merged_store(const Node_List& merge_list, Node* new_input_value);\n+  Node* make_merged_input_value(const Node_List& merge_list);\n+  StoreNode* make_merged_store(const Node_List& merge_list, Node* merged_input_value);\n@@ -2954,2 +2954,2 @@\n-  Node* new_input_value = merged_input_value(merge_list);\n-  if (new_input_value == nullptr) { return nullptr; }\n+  Node* merged_input_value = make_merged_input_value(merge_list);\n+  if (merged_input_value == nullptr) { return nullptr; }\n@@ -2957,1 +2957,1 @@\n-  StoreNode* new_store = make_merged_store(merge_list, new_input_value);\n+  StoreNode* merged_store = make_merged_store(merge_list, merged_input_value);\n@@ -2967,1 +2967,1 @@\n-    new_store->dump(\"\\n\", false, &ss);\n+    merged_store->dump(\"\\n\", false, &ss);\n@@ -2972,1 +2972,1 @@\n-  return new_store;\n+  return merged_store;\n@@ -3233,1 +3233,1 @@\n-Node* MergePrimitiveArrayStores::merged_input_value(const Node_List& merge_list) {\n+Node* MergePrimitiveArrayStores::make_merged_input_value(const Node_List& merge_list) {\n@@ -3236,1 +3236,1 @@\n-  Node* new_input_value = nullptr;\n+  Node* merged_input_value = nullptr;\n@@ -3247,1 +3247,1 @@\n-    new_input_value = _phase->longcon(con);\n+    merged_input_value = _phase->longcon(con);\n@@ -3253,1 +3253,1 @@\n-    new_input_value = first->in(MemNode::ValueIn);\n+    merged_input_value = first->in(MemNode::ValueIn);\n@@ -3258,1 +3258,1 @@\n-    if (new_input_value != base_last && new_input_value->Opcode() == Op_ConvL2I) {\n+    if (merged_input_value != base_last && merged_input_value->Opcode() == Op_ConvL2I) {\n@@ -3260,1 +3260,1 @@\n-      new_input_value = new_input_value->in(1);\n+      merged_input_value = merged_input_value->in(1);\n@@ -3262,2 +3262,2 @@\n-    if (new_input_value != base_last) {\n-      \/\/ new_input_value is not the base\n+    if (merged_input_value != base_last) {\n+      \/\/ merged_input_value is not the base\n@@ -3268,1 +3268,1 @@\n-  if (_phase->type(new_input_value)->isa_long() != nullptr && new_memory_size <= 4) {\n+  if (_phase->type(merged_input_value)->isa_long() != nullptr && new_memory_size <= 4) {\n@@ -3275,9 +3275,38 @@\n-    new_input_value = _phase->transform(new ConvL2INode(new_input_value));\n-  }\n-\n-  assert((_phase->type(new_input_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n-         (_phase->type(new_input_value)->isa_long() != nullptr && new_memory_size == 8),\n-         \"new_input_value is either int or long, and new_memory_size is small enough\");\n-\n-  return new_input_value;\n-}\n+    merged_input_value = _phase->transform(new ConvL2INode(merged_input_value));\n+  }\n+\n+  assert((_phase->type(merged_input_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n+         (_phase->type(merged_input_value)->isa_long() != nullptr && new_memory_size == 8),\n+         \"merged_input_value is either int or long, and new_memory_size is small enough\");\n+\n+  return merged_input_value;\n+}\n+\n+\/\/                                                                                                          \/\/\n+\/\/ first_ctrl    first_mem   first_adr                first_ctrl    first_mem         first_adr             \/\/\n+\/\/  |                |           |                     |                |                 |                 \/\/\n+\/\/  |                |           |                     |                +---------------+ |                 \/\/\n+\/\/  |                |           |                     |                |               | |                 \/\/\n+\/\/  |                | +---------+                     |                | +---------------+                 \/\/\n+\/\/  |                | |                               |                | |             | |                 \/\/\n+\/\/  +--------------+ | |  v1                           +------------------------------+ | |  v1             \/\/\n+\/\/  |              | | |  |                            |                | |           | | |  |              \/\/\n+\/\/ RangeCheck     first_store                         RangeCheck        | |          first_store            \/\/\n+\/\/  |                |  |                              |                | |                |                \/\/\n+\/\/ last_ctrl         |  +----> unc_trap               last_ctrl         | |                +----> unc_trap  \/\/\n+\/\/  |                |                       ===>      |                | |                                 \/\/\n+\/\/  +--------------+ | a2 v2                           |                | |                                 \/\/\n+\/\/  |              | | |  |                            |                | |                                 \/\/\n+\/\/  |             second_store                         |                | |                                 \/\/\n+\/\/  |                |                                 |                | | [v1 v2   ...   vn]              \/\/\n+\/\/ ...              ...                                |                | |         |                       \/\/\n+\/\/  |                |                                 |                | |         v                       \/\/\n+\/\/  +--------------+ | an vn                           +--------------+ | | merged_input_value              \/\/\n+\/\/                 | | |  |                                           | | |  |                              \/\/\n+\/\/                last_store (= _store)                              merged_store                           \/\/\n+\/\/                                                                                                          \/\/\n+StoreNode* MergePrimitiveArrayStores::make_merged_store(const Node_List& merge_list, Node* merged_input_value) {\n+  Node* first_store = merge_list.at(merge_list.size()-1);\n+  Node* last_ctrl   = _store->in(MemNode::Control); \/\/ after (optional) RangeCheck\n+  Node* first_mem   = first_store->in(MemNode::Memory);\n+  Node* first_adr   = first_store->in(MemNode::Address);\n@@ -3285,5 +3314,0 @@\n-StoreNode* MergePrimitiveArrayStores::make_merged_store(const Node_List& merge_list, Node* new_input_value) {\n-  Node* first    = merge_list.at(merge_list.size()-1);\n-  Node* new_ctrl = _store->in(MemNode::Control); \/\/ must take last: after all RangeChecks\n-  Node* new_mem  = first->in(MemNode::Memory);\n-  Node* new_adr  = first->in(MemNode::Address);\n@@ -3291,1 +3315,1 @@\n-  BasicType bt = T_ILLEGAL;\n+\n@@ -3293,0 +3317,1 @@\n+  BasicType bt = T_ILLEGAL;\n@@ -3299,2 +3324,3 @@\n-  StoreNode* new_store = StoreNode::make(*_phase, new_ctrl, new_mem, new_adr,\n-                                         new_adr_type, new_input_value, bt, MemNode::unordered);\n+  StoreNode* merged_store = StoreNode::make(*_phase, last_ctrl, first_mem, first_adr,\n+                                            new_adr_type, merged_input_value, bt, MemNode::unordered);\n+\n@@ -3303,1 +3329,1 @@\n-  new_store->set_mismatched_access();\n+  merged_store->set_mismatched_access();\n@@ -3306,1 +3332,1 @@\n-  _phase->is_IterGVN()->_worklist.push(new_mem);\n+  _phase->is_IterGVN()->_worklist.push(first_mem);\n@@ -3308,1 +3334,1 @@\n-  return new_store;\n+  return merged_store;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":62,"deletions":36,"binary":false,"changes":98,"status":"modified"}]}