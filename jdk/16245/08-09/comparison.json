{"files":[{"patch":"@@ -2942,3 +2942,0 @@\n-\/\/ TODO description of structure\n-\/\/ TODO why ok to take constant out of ConvI2L?\n-\/\/\n@@ -2949,3 +2946,9 @@\n-\/\/ Note: we accumulate all constant offsets into constant_offset, even the int constant\n-\/\/       behind the LShiftL(ConvI2L(...)) pattern. TODO overflow\n-\/\/ TODO only works for arrays?\n+\/\/\n+\/\/ Note: we accumulate all constant offsets into constant_offset, even the int constant behind\n+\/\/       the LShiftL(ConvI2L(...)) pattern. For this, we convert \"ConvI2L(x + int_con)\" to\n+\/\/       \"ConvI2L(x) + int_con\", which is only safe if we can assume that either all compared\n+\/\/       addresses have an overflow for \"x + int_con\" or none.\n+\/\/       For loads and stores on arrays, we know that if one overflows and the other not, then\n+\/\/       the two addresses lay almost max_int indices apart, but the maximal array size is\n+\/\/       only about half of that. Therefore, the RangeCheck on at least one of them must have\n+\/\/       failed.\n@@ -2955,1 +2958,1 @@\n-  const AddPNode* _pointer;      \/\/ The final pointer to the position in the array\n+  const Node* _pointer;          \/\/ The final pointer to the position in the array\n@@ -2963,1 +2966,1 @@\n-               const AddPNode* pointer,\n+               const Node* pointer,\n@@ -2977,1 +2980,1 @@\n-    assert(is_valid == (_pointer != nullptr), \"have pointer exactly if valid\");\n+    assert(_pointer != nullptr, \"must always have pointer\");\n@@ -2982,2 +2985,2 @@\n-  static ArrayPointer make_invalid() {\n-    return ArrayPointer(false, nullptr, nullptr, 0, nullptr, 0, nullptr);\n+  static ArrayPointer make_invalid(const Node* pointer) {\n+    return ArrayPointer(false, pointer, nullptr, 0, nullptr, 0, nullptr);\n@@ -3009,2 +3012,2 @@\n-  static ArrayPointer make(const AddPNode* pointer) {\n-    if (pointer == nullptr) { return ArrayPointer::make_invalid(); }\n+  static ArrayPointer make(const Node* pointer) {\n+    if (!pointer->is_AddP()) { return ArrayPointer::make_invalid(pointer); }\n@@ -3013,1 +3016,1 @@\n-    if (base == nullptr) { return ArrayPointer::make_invalid(); }\n+    if (base == nullptr) { return ArrayPointer::make_invalid(pointer); }\n@@ -3017,1 +3020,1 @@\n-    int count = pointer->unpack_offsets(offsets, search_depth);\n+    int count = pointer->as_AddP()->unpack_offsets(offsets, search_depth);\n@@ -3020,1 +3023,1 @@\n-    if (count <= 0) { return ArrayPointer::make_invalid(); }\n+    if (count <= 0) { return ArrayPointer::make_invalid(pointer); }\n@@ -3055,0 +3058,2 @@\n+    if (!_is_valid || !other._is_valid) { return false; }\n+\n@@ -3077,0 +3082,4 @@\n+    if (!_is_valid) {\n+      tty->print(\"ArrayPointer[%d %s, invalid]\", _pointer->_idx, _pointer->Name());\n+      return;\n+    }\n@@ -3162,22 +3171,4 @@\n-  \/\/ Check address compatibility. We expect patterns like this:\n-  \/\/\n-  \/\/   AddP(AddP(AddP(AddP(base, o2), o2), o1), con)\n-  \/\/\n-  \/\/ Two addresses are adjacent, if they share a base and all offsets (o1, o2, ...)\n-  \/\/ are the same, and the constants have an exact difference of the memory_size.\n-  AddPNode* adr_s1 = s1->in(MemNode::Address)->isa_AddP();\n-  AddPNode* adr_s2 = s2->in(MemNode::Address)->isa_AddP();\n-\n-  \/\/ TODO remove\n-  \/\/tty->print_cr(\"Check:\");\n-  \/\/adr_s1->dump_bfs(5,0,\"#d\");\n-  \/\/adr_s2->dump_bfs(5,0,\"#d\");\n-\n-  ArrayPointer ap1 = ArrayPointer::make(adr_s1);\n-  ArrayPointer ap2 = ArrayPointer::make(adr_s2);\n-  \/\/ TODO remove\n-  \/\/ap1.dump();\n-  \/\/ap2.dump();\n-  \/\/tty->print_cr(\"is_adjacent_to: %d\", ap2.is_adjacent_to(ap1, s1->memory_size()));\n-  \/\/tty->print_cr(\"is_adjacent_to: %d\", ap1.is_adjacent_to(ap2, s1->memory_size()));\n-  if (!ap2.is_adjacent_to(ap1, s1->memory_size())) {\n+  \/\/ Check address adjacency\n+  ArrayPointer array_pointer1 = ArrayPointer::make(s1->in(MemNode::Address));\n+  ArrayPointer array_pointer2 = ArrayPointer::make(s2->in(MemNode::Address));\n+  if (!array_pointer2.is_adjacent_to(array_pointer1, s1->memory_size())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":29,"deletions":38,"binary":false,"changes":67,"status":"modified"}]}