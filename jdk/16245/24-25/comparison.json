{"files":[{"patch":"@@ -2901,0 +2901,2 @@\n+\n+  Node* merged_input_value(const Node_List& merge_listi, const int new_memory_size);\n@@ -2903,0 +2905,1 @@\n+\/\/ TODO desc\n@@ -2955,1 +2958,2 @@\n-  int pow2size = round_down_power_of_2(merge_list.size());\n+  \/\/ Truncate the merge_list to a power of 2.\n+  uint pow2size = round_down_power_of_2(merge_list.size());\n@@ -2957,0 +2961,2 @@\n+  while (merge_list.size() > pow2size) { merge_list.pop(); }\n+  int new_memory_size = _store->memory_size() * merge_list.size();\n@@ -2958,36 +2964,1 @@\n-  \/\/ TODO maybe put in its own method\n-  \/\/ Create \/ find new value:\n-  Node* new_value = nullptr;\n-  int new_memory_size = _store->memory_size() * pow2size;\n-  if (_store->in(MemNode::ValueIn)->Opcode() == Op_ConI) {\n-    \/\/ Collect all constants\n-    jlong con = 0;\n-    jlong bits_per_store = _store->memory_size() * 8;\n-    jlong mask = (((jlong)1) << bits_per_store) - 1;\n-    for (int i = 0; i < pow2size; i++) {\n-      jlong con_i = merge_list.at(i)->in(MemNode::ValueIn)->get_int();\n-      con = con << bits_per_store;\n-      con = con | (mask & con_i);\n-    }\n-    new_value = _phase->longcon(con);\n-  } else {\n-    \/\/ TODO description\n-    Node* first = merge_list.at(pow2size-1);\n-    new_value = first->in(MemNode::ValueIn);\n-    Node const* base_last;\n-    jint shift_last;\n-    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n-    assert(is_true, \"must detect con RShift\");\n-    if (new_value != base_last && new_value->Opcode() == Op_ConvL2I) {\n-      \/\/ look through\n-      new_value = new_value->in(1);\n-    }\n-    if (new_value != base_last) {\n-      \/\/ new_value is not the base\n-      return nullptr;\n-    }\n-  }\n-\n-  if (_phase->type(new_value)->isa_long() != nullptr && new_memory_size <= 4) {\n-    new_value = _phase->transform(new ConvL2INode(new_value));\n-  }\n+  Node* new_value = merged_input_value(merge_list, new_memory_size);\n@@ -2995,5 +2966,1 @@\n-  assert((_phase->type(new_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n-         (_phase->type(new_value)->isa_long() != nullptr && new_memory_size == 8),\n-         \"new_value is either int or long, and new_memory_size is small enough\");\n-\n-  Node* first = merge_list.at(pow2size-1);\n+  Node* first    = merge_list.at(merge_list.size()-1);\n@@ -3024,1 +2991,1 @@\n-    for (int i = pow2size - 1; i >= 0; i--) {\n+    for (int i = (int)merge_list.size() - 1; i >= 0; i--) {\n@@ -3262,0 +3229,52 @@\n+\/\/ Merge the input values of the smaller stores to a single larger input value.\n+Node* MergePrimitiveArrayStores::merged_input_value(const Node_List& merge_list, const int new_memory_size) {\n+  Node* first = merge_list.at(merge_list.size()-1);\n+  Node* new_value = nullptr;\n+  if (_store->in(MemNode::ValueIn)->Opcode() == Op_ConI) {\n+    \/\/ Pattern: [ConI, ConI, ...] -> new constant\n+    jlong con = 0;\n+    jlong bits_per_store = _store->memory_size() * 8;\n+    jlong mask = (((jlong)1) << bits_per_store) - 1;\n+    for (uint i = 0; i < merge_list.size(); i++) {\n+      jlong con_i = merge_list.at(i)->in(MemNode::ValueIn)->get_int();\n+      con = con << bits_per_store;\n+      con = con | (mask & con_i);\n+    }\n+    new_value = _phase->longcon(con);\n+  } else {\n+    \/\/ Pattern: [base >> 24, base >> 16, base >> 8, base] -> base\n+    \/\/             |                                  |\n+    \/\/           _store                             first\n+    \/\/\n+    new_value = first->in(MemNode::ValueIn);\n+    Node const* base_last;\n+    jint shift_last;\n+    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n+    assert(is_true, \"must detect con RShift\");\n+    if (new_value != base_last && new_value->Opcode() == Op_ConvL2I) {\n+      \/\/ look through\n+      new_value = new_value->in(1);\n+    }\n+    if (new_value != base_last) {\n+      \/\/ new_value is not the base\n+      return nullptr;\n+    }\n+  }\n+\n+  if (_phase->type(new_value)->isa_long() != nullptr && new_memory_size <= 4) {\n+    \/\/ Example:\n+    \/\/\n+    \/\/   long base = ...;\n+    \/\/   a[0] = (byte)(base >> 0);\n+    \/\/   a[1] = (byte)(base >> 8);\n+    \/\/\n+    new_value = _phase->transform(new ConvL2INode(new_value));\n+  }\n+\n+  assert((_phase->type(new_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n+         (_phase->type(new_value)->isa_long() != nullptr && new_memory_size == 8),\n+         \"new_value is either int or long, and new_memory_size is small enough\");\n+\n+  return new_value;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":62,"deletions":43,"binary":false,"changes":105,"status":"modified"}]}