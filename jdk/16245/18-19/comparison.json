{"files":[{"patch":"@@ -2889,1 +2889,3 @@\n-  bool is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) const; \/\/ TODO static\n+  bool is_adjacent_pair(const StoreNode* use_store, const StoreNode* def_store) const;\n+  bool is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const;\n+  static bool is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out);\n@@ -2910,2 +2912,0 @@\n-  \/\/ TODO more checks about array and element type?\n-\n@@ -2924,0 +2924,2 @@\n+  \/\/ TODO\n+\n@@ -2955,1 +2957,5 @@\n-  \/\/ TODO value adjacent\n+  if (!is_adjacent_input_pair(def_store->in(MemNode::ValueIn),\n+                              use_store->in(MemNode::ValueIn),\n+                              def_store->memory_size())) {\n+    return false;\n+  }\n@@ -2967,0 +2973,58 @@\n+bool MergePrimitiveArrayStores::is_adjacent_input_pair(const Node* n1, const Node* n2, const int memory_size) const {\n+  \/\/ Pattern: [n1 = ConI, n2 = ConI]\n+  if (n1->Opcode() == Op_ConI) {\n+    return n2->Opcode() == Op_ConI;\n+  }\n+\n+  \/\/ Pattern: [n1 = base >> shift, n2 = base >> (shift + memory_size)]\n+  Node const* base_n2;\n+  jint shift_n2;\n+  if (!is_con_RShift(n2, base_n2, shift_n2)) {\n+    return false;\n+  }\n+  Node const* base_n1;\n+  jint shift_n1;\n+  if (n1->Opcode() == Op_ConvL2I) {\n+    \/\/ look through\n+    n1 = n1->in(1);\n+  }\n+  if (n1 == base_n2) {\n+    \/\/ This is the \"shift by zero\" case.\n+    base_n1 = n1;\n+    shift_n1 = 0;\n+  } else if (!is_con_RShift(n1, base_n1, shift_n1)) {\n+    return false;\n+  }\n+  int bits_per_store = memory_size * 8;\n+  if (base_n1 != base_n2 ||\n+      shift_n1 + bits_per_store != shift_n2 ||\n+      shift_n1 % bits_per_store != 0) {\n+    return false;\n+  }\n+\n+  \/\/ both load from same value with correct shift\n+  return true;\n+}\n+\n+bool MergePrimitiveArrayStores::is_con_RShift(const Node* n, Node const*& base_out, jint& shift_out) {\n+  assert(n != nullptr, \"precondition\");\n+\n+  int opc = n->Opcode();\n+  if (opc == Op_ConvL2I) {\n+    n = n->in(1);\n+    opc = n->Opcode();\n+  }\n+\n+  if ((opc == Op_RShiftI ||\n+       opc == Op_RShiftL ||\n+       opc == Op_URShiftI ||\n+       opc == Op_URShiftL) &&\n+      n->in(2)->is_ConI()) {\n+    base_out = n->in(1);\n+    shift_out = n->in(2)->get_int();\n+    assert(shift_out >= 0, \"must be positive\");\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -3295,91 +3359,0 @@\n-StoreNode* StoreNode::can_merge_primitive_array_store_with_def(PhaseGVN* phase, bool check_use) {\n-  int opc = Opcode();\n-  assert(opc == Op_StoreB || opc == Op_StoreC || opc == Op_StoreI, \"precondition\");\n-\n-  StoreNode* def = in(MemNode::Memory)->isa_Store();\n-  if (def == nullptr ||\n-      def->Opcode() != opc ||\n-      def->adr_type()->isa_aryptr() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  StoreNode* s1 = this;\n-  StoreNode* s2 = def->as_Store();\n-  assert(s1->memory_size() == s2->memory_size(), \"same size\");\n-\n-  \/\/ Check ctrl compatibility\n-  Node* ctrl_s1 = s1->in(MemNode::Control);\n-  Node* ctrl_s2 = s2->in(MemNode::Control);\n-  if (ctrl_s1 != ctrl_s2) {\n-    \/\/ See if we can bypass a RangeCheck\n-    if (!ctrl_s1->is_IfProj() ||\n-        !ctrl_s1->in(0)->is_RangeCheck() ||\n-        ctrl_s1->in(0)->outcnt() != 2) {\n-      return nullptr;\n-    }\n-    ProjNode* other_proj = ctrl_s1->as_IfProj()->other_if_proj();\n-    if (other_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) == nullptr ||\n-        ctrl_s1->in(0)->in(0) != ctrl_s2) {\n-      return nullptr;\n-    }\n-    \/\/ Success, we skipped a RangeCheck\n-  }\n-\n-  \/\/ Check value compatibility\n-  Node* value_s1 = s1->in(MemNode::ValueIn);\n-  Node* value_s2 = s2->in(MemNode::ValueIn);\n-\n-  if (value_s1->Opcode() == Op_ConI) {\n-    if (value_s2->Opcode() != Op_ConI) {\n-      return nullptr;\n-    }\n-    \/\/ both are int con\n-  } else {\n-    Node* base_s1;\n-    jint shift_s1;\n-    if (!is_con_RShift(value_s1, base_s1, shift_s1)) {\n-      return nullptr;\n-    }\n-    Node* base_s2;\n-    jint shift_s2;\n-    if (value_s2->Opcode() == Op_ConvL2I) {\n-      \/\/ look through\n-      value_s2 = value_s2->in(1);\n-    }\n-    if (value_s2 == base_s1) {\n-      \/\/ This is the \"shift by zero\" case.\n-      base_s2 = value_s2;\n-      shift_s2 = 0;\n-    } else if (!is_con_RShift(value_s2, base_s2, shift_s2)) {\n-      return nullptr;\n-    }\n-    int bits_per_store = memory_size() * 8;\n-    if (base_s1 != base_s2 ||\n-        shift_s2 + bits_per_store != shift_s1 ||\n-        shift_s1 % bits_per_store != 0) {\n-      return nullptr;\n-    }\n-    \/\/ both load from same value with correct shift\n-  }\n-\n-  \/\/ Check address adjacency\n-  \/\/ -> make sure that we are operating on an array, and the sizes match.\n-  int size_ptr1 = type2aelembytes(s1->adr_type()->is_aryptr()->elem()->array_element_basic_type());\n-  int size_ptr2 = type2aelembytes(s2->adr_type()->is_aryptr()->elem()->array_element_basic_type());\n-  if (size_ptr1 != size_ptr2 ||\n-      size_ptr1 != s1->memory_size() ||\n-      s1->memory_size() != s2->memory_size()) {\n-    return nullptr;\n-  }\n-  {\n-    ResourceMark rm;\n-    ArrayPointer array_pointer1 = ArrayPointer::make(phase, s1->in(MemNode::Address));\n-    ArrayPointer array_pointer2 = ArrayPointer::make(phase, s2->in(MemNode::Address));\n-    if (!array_pointer2.is_adjacent_to_and_before(array_pointer1, s1->memory_size())) {\n-      return nullptr;\n-    }\n-  }\n-\n-  return s2;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":68,"deletions":95,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -577,2 +577,0 @@\n-  StoreNode* can_merge_primitive_array_store_with_def(PhaseGVN* phase, bool check_use);\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1271,22 +1271,0 @@\n-bool is_con_RShift(Node* n, Node*& base_out, jint& shift_out) {\n-  assert(n != nullptr, \"precondition\");\n-\n-  int opc = n->Opcode();\n-  if (opc == Op_ConvL2I) {\n-    n = n->in(1);\n-    opc = n->Opcode();\n-  }\n-\n-  if ((opc == Op_RShiftI ||\n-       opc == Op_RShiftL ||\n-       opc == Op_URShiftI ||\n-       opc == Op_URShiftL) &&\n-      n->in(2)->is_ConI()) {\n-    base_out = n->in(1);\n-    shift_out = n->in(2)->get_int();\n-    assert(shift_out >= 0, \"must be positive\");\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -290,2 +290,0 @@\n-bool is_con_RShift(Node* n, Node*& base_out, jint& shift_out);\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}