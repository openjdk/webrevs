{"files":[{"patch":"@@ -727,1 +727,1 @@\n-int AddPNode::unpack_offsets(Node* elements[], int length) {\n+int AddPNode::unpack_offsets(Node* elements[], int length) const {\n@@ -729,1 +729,1 @@\n-  Node* addr = this;\n+  Node const* addr = this;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-  int unpack_offsets(Node* elements[], int length);\n+  int unpack_offsets(Node* elements[], int length) const;\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2446,0 +2446,12 @@\n+#ifdef VM_LITTLE_ENDIAN\n+  if (MergeStores && UseUnalignedAccesses) {\n+    assert(!C->merge_stores_phase(), \"merge store phase not yet set\");\n+    C->gather_nodes_for_merge_stores(igvn);\n+    C->set_merge_stores_phase(true);\n+    igvn.optimize();\n+    C->set_merge_stores_phase(false);\n+  }\n+#endif\n+\n+  if (failing())  return;\n+\n@@ -2479,10 +2491,0 @@\n-#ifdef VM_LITTLE_ENDIAN\n-  if (MergeStores && UseUnalignedAccesses) {\n-    assert(!C->merge_stores_phase(), \"merge store phase not yet set\");\n-    C->gather_nodes_for_merge_stores(igvn);\n-    C->set_merge_stores_phase(true);\n-    igvn.optimize();\n-    C->set_merge_stores_phase(false);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2942,0 +2942,145 @@\n+\/\/ TODO description of structure\n+\/\/ TODO why ok to take constant out of ConvI2L?\n+class ArrayPointer {\n+private:\n+  const bool _is_valid;          \/\/ The parsing succeeded\n+  const AddPNode* _pointer;      \/\/ The final pointer to the position in the array\n+  const Node* _base;             \/\/ Base address of the array\n+  const jlong _constant_offset;  \/\/ Sum of collected constant offsets\n+  const Node* _int_offset; \/\/ Offset behind LShiftL and ConvI2L\n+  const jint _int_offset_shift;  \/\/ Shift value for int_offset\n+  const GrowableArray<Node*>* _other_offsets; \/\/ List of other AddP offsets\n+\n+  ArrayPointer(const bool is_valid,\n+               const AddPNode* pointer,\n+               const Node* base,\n+               const jlong constant_offset,\n+               const Node* int_offset,\n+               const jint int_offset_shift,\n+               const GrowableArray<Node*>* other_offsets) :\n+      _is_valid(is_valid),\n+      _pointer(pointer),\n+      _base(base),\n+      _constant_offset(constant_offset),\n+      _int_offset(int_offset),\n+      _int_offset_shift(int_offset_shift),\n+      _other_offsets(other_offsets)\n+  {\n+    assert(is_valid == (_pointer != nullptr), \"have pointer exactly if valid\");\n+    assert(is_valid == (_base != nullptr), \"have base exactly if valid\");\n+    assert(is_valid == (_int_offset != nullptr), \"have int_offset exactly if valid\");\n+    assert(is_valid == (_other_offsets != nullptr), \"have other_offsets exactly if valid\");\n+  }\n+\n+  static ArrayPointer make_invalid() {\n+    return ArrayPointer(false, nullptr, nullptr, 0, nullptr, 0, nullptr);\n+  }\n+\n+  static bool parse_int_offset(Node* offset, Node*& int_offset, jint& int_offset_shift) {\n+    \/\/ offset = LShiftL( ConvI2L(int_offset), int_offset_shift)\n+    if (offset->Opcode() == Op_LShiftL &&\n+        offset->in(1)->Opcode() == Op_ConvI2L &&\n+        offset->in(2)->Opcode() == Op_ConI) {\n+      int_offset = offset->in(1)->in(1); \/\/ LShiftL -> ConvI2L -> int_offset\n+      int_offset_shift = offset->in(2)->get_int(); \/\/ LShiftL -> int_offset_shift\n+      return true;\n+    }\n+\n+    \/\/ offset = ConvI2L(int_offset) = LShiftL( ConvI2L(int_offset), 0)\n+    if (offset->Opcode() == Op_ConvI2L) {\n+      int_offset = offset->in(1);\n+      int_offset_shift = 0;\n+      return true;\n+    }\n+\n+    \/\/ parse failed\n+    return false;\n+  }\n+\n+public:\n+  \/\/ Parse the structure above the pointer\n+  static ArrayPointer make(const AddPNode* pointer) {\n+    if (pointer == nullptr) { return ArrayPointer::make_invalid(); }\n+\n+    const Node* base = pointer->in(AddPNode::Base);\n+    if (base == nullptr) { return ArrayPointer::make_invalid(); }\n+\n+    const int search_depth = 5;\n+    Node* offsets[search_depth];\n+    int count = pointer->unpack_offsets(offsets, search_depth);\n+\n+    \/\/ We expect at least a constant each\n+    if (count <= 0) { return ArrayPointer::make_invalid(); }\n+\n+    \/\/ We extract the form:\n+    \/\/ pointer = base + const_offset + (int_offset << int_offset_shift) + sum(other_offsets)\n+    jlong constant_offset = 0;\n+    Node* int_offset = nullptr;\n+    jint int_offset_shift = 0;\n+    GrowableArray<Node*>* other_offsets = new GrowableArray<Node*>(count);\n+\n+    for (int i = 0; i < count; i++) {\n+      Node* offset = offsets[i];\n+      if (offset->Opcode() == Op_ConI) {\n+        \/\/ Constant int offset\n+        constant_offset += offset->get_int();\n+      } else if (offset->Opcode() == Op_ConL) {\n+        \/\/ Constant long offset\n+        constant_offset += offset->get_long();\n+      } else if(int_offset == nullptr && parse_int_offset(offset, int_offset, int_offset_shift)) {\n+        \/\/ LShiftL( ConvI2L(int_offset), int_offset_shift)\n+        int_offset = int_offset->uncast();\n+        if (int_offset->Opcode() == Op_AddI && int_offset->in(2)->Opcode() == Op_ConI) {\n+          \/\/ LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+          constant_offset += ((jlong)int_offset->in(2)->get_int()) << int_offset_shift;\n+          int_offset = int_offset->in(1);\n+        }\n+      } else {\n+        \/\/ All others\n+        other_offsets->append(offset);\n+      }\n+    }\n+\n+    return ArrayPointer(true, pointer, base, constant_offset, int_offset, int_offset_shift, other_offsets);\n+  }\n+\n+  bool is_adjacent_to(const ArrayPointer& other, const jlong data_size) const {\n+    \/\/ Offset adjacent?\n+    if (this->_constant_offset + data_size != other._constant_offset) { return false; }\n+\n+    \/\/ All other components identical?\n+    if (this->_base != other._base ||\n+        this->_int_offset != other._int_offset ||\n+        this->_int_offset_shift != other._int_offset_shift ||\n+        this->_other_offsets->length() != other._other_offsets->length()) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < this->_other_offsets->length(); i++) {\n+      Node* o1 = this->_other_offsets->at(i);\n+      Node* o2 = other._other_offsets->at(i);\n+      if (o1 != o2) { return false; }\n+    }\n+\n+    return true;\n+  }\n+\n+#ifndef PRODUCT\n+  void dump() {\n+    tty->print(\"ArrayPointer[%d %s, base[%d %s] + %ld\",\n+               _pointer->_idx, _pointer->Name(),\n+               _base->_idx, _base->Name(),\n+               _constant_offset);\n+    if (_int_offset != 0) {\n+      tty->print(\" + I2L[%d %s] << %d\",\n+                 _int_offset->_idx, _int_offset->Name(), _int_offset_shift);\n+    }\n+    for (int i = 0; i < _other_offsets->length(); i++) {\n+      Node* n = _other_offsets->at(i);\n+      tty->print(\" + [%d %s]\", n->_idx, n->Name());\n+    }\n+    tty->print_cr(\"]\");\n+  }\n+#endif\n+};\n+\n@@ -3019,52 +3164,13 @@\n-  \/\/ Must have the same base\n-  if (adr_s1 == nullptr ||\n-      adr_s2 == nullptr ||\n-      adr_s1->in(AddPNode::Base) != adr_s2->in(AddPNode::Base)) {\n-    return nullptr;\n-  }\n-\n-  const int search_depth = 5;\n-  Node* adr_offsets_s1[search_depth];\n-  Node* adr_offsets_s2[search_depth];\n-  int count_s1 = adr_s1->unpack_offsets(adr_offsets_s1, search_depth);\n-  int count_s2 = adr_s2->unpack_offsets(adr_offsets_s2, search_depth);\n-\n-  \/\/ Must have same number of offsets, and at least a constant each\n-  if (count_s1 != count_s2 || count_s1 <= 0 ||\n-      !adr_offsets_s1[0]->is_Con() ||\n-      !adr_offsets_s2[0]->is_Con()) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Constants must have correct offset\n-  const Type* c1_t = phase->type(adr_offsets_s1[0]);\n-  const Type* c2_t = phase->type(adr_offsets_s2[0]);\n-  assert(c1_t->isa_int() || c1_t->isa_long(), \"int or long\");\n-  assert(c2_t->isa_int() || c2_t->isa_long(), \"int or long\");\n-  jlong c1 = c1_t->isa_int() ? c1_t->is_int()->get_con() : c1_t->is_long()->get_con();\n-  jlong c2 = c2_t->isa_int() ? c2_t->is_int()->get_con() : c2_t->is_long()->get_con();\n-  if (c2 + s2->memory_size() != c1) {\n-    return nullptr;\n-  }\n-\n-  \/\/ All other offsets must be the same\n-  for (int i = 1; i < count_s1; i++) {\n-    Node* o1 = adr_offsets_s1[i];\n-    Node* o2 = adr_offsets_s2[i];\n-    if (o1 == o2) { continue; }\n-    \/\/ Sometimes the same values hide behind ConvI2L that are only different in\n-    \/\/ their internal type. This can happen if they come from range checks with\n-    \/\/ different offsets. This prevents commoning of the use nodes.\n-    \/\/ Additionally, for array accesses with memory_size larger than 1, we may\n-    \/\/ have a LShiftL node on that path.\n-    if (o1->Opcode() == Op_LShiftL &&\n-        o2->Opcode() == Op_LShiftL &&\n-        o1->in(2) == o2->in(2)) {\n-      o1 = o1->in(1);\n-      o2 = o2->in(1);\n-    }\n-    if (o1->Opcode() == Op_ConvI2L &&\n-        o2->Opcode() == Op_ConvI2L &&\n-        o1->in(1) == o2->in(1)) {\n-      continue;\n-    }\n+  \/\/ TODO remove\n+  \/\/tty->print_cr(\"Check:\");\n+  \/\/adr_s1->dump_bfs(5,0,\"#d\");\n+  \/\/adr_s2->dump_bfs(5,0,\"#d\");\n+\n+  ArrayPointer ap1 = ArrayPointer::make(adr_s1);\n+  ArrayPointer ap2 = ArrayPointer::make(adr_s2);\n+  \/\/ TODO remove\n+  \/\/ap1.dump();\n+  \/\/ap2.dump();\n+  \/\/tty->print_cr(\"is_adjacent_to: %d\", ap2.is_adjacent_to(ap1, s1->memory_size()));\n+  \/\/tty->print_cr(\"is_adjacent_to: %d\", ap1.is_adjacent_to(ap2, s1->memory_size()));\n+  if (!ap2.is_adjacent_to(ap1, s1->memory_size())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":158,"deletions":52,"binary":false,"changes":210,"status":"modified"}]}