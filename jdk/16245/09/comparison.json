{"files":[{"patch":"@@ -104,0 +104,1 @@\n+        --add-exports java.base\/jdk.internal.util=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-int AddPNode::unpack_offsets(Node* elements[], int length) {\n+int AddPNode::unpack_offsets(Node* elements[], int length) const {\n@@ -729,1 +729,1 @@\n-  Node* addr = this;\n+  Node const* addr = this;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-  int unpack_offsets(Node* elements[], int length);\n+  int unpack_offsets(Node* elements[], int length) const;\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,0 +357,6 @@\n+  product(bool, MergeStores, true, DIAGNOSTIC,                              \\\n+          \"Optimize stores by combining values into larger store\")          \\\n+                                                                            \\\n+  develop(bool, TraceMergeStores, false,                                    \\\n+          \"Trace creation of merged stores\")                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -625,0 +625,1 @@\n+                  _merge_stores_phase(false),\n@@ -916,0 +917,1 @@\n+    _merge_stores_phase(false),\n@@ -2444,0 +2446,12 @@\n+#ifdef VM_LITTLE_ENDIAN\n+  if (MergeStores && UseUnalignedAccesses) {\n+    assert(!C->merge_stores_phase(), \"merge store phase not yet set\");\n+    C->gather_nodes_for_merge_stores(igvn);\n+    C->set_merge_stores_phase(true);\n+    igvn.optimize();\n+    C->set_merge_stores_phase(false);\n+  }\n+#endif\n+\n+  if (failing())  return;\n+\n@@ -2923,0 +2937,18 @@\n+void Compile::gather_nodes_for_merge_stores(PhaseIterGVN &igvn) {\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(root());\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist[i];\n+    int opc = n->Opcode();\n+    if (opc == Op_StoreB || opc == Op_StoreC || opc == Op_StoreI) {\n+      igvn._worklist.push(n);\n+    }\n+    for (uint i = 0; i < n->len(); i++) {\n+      if (n->in(i) != nullptr) {\n+        worklist.push(n->in(i));\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -321,0 +321,2 @@\n+  bool                  _merge_stores_phase;    \/\/ True during merge stores phase\n+\n@@ -788,0 +790,3 @@\n+  bool merge_stores_phase() { return _merge_stores_phase;  }\n+  void set_merge_stores_phase(bool b) { _merge_stores_phase = b;  }\n+\n@@ -1213,0 +1218,2 @@\n+  void gather_nodes_for_merge_stores(PhaseIterGVN &igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2764,0 +2764,5 @@\n+  if (phase->C->merge_stores_phase()) {\n+    Node* progress = Ideal_merge_stores(phase);\n+    if (progress != nullptr) { return progress; }\n+  }\n+\n@@ -2767,0 +2772,418 @@\n+\/\/ Link together multiple stores (B\/S\/C\/I) into a longer one.\n+Node* StoreNode::Ideal_merge_stores(PhaseGVN* phase) {\n+  int opc = Opcode();\n+  if (opc != Op_StoreB && opc != Op_StoreC && opc != Op_StoreI) {\n+    return nullptr;\n+  }\n+\n+  \/\/ If we can merge with use, then we must process use first.\n+  StoreNode* use = can_merge_with_use(phase, true);\n+  if (use != nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Check if we can merge with at least one def.\n+  StoreNode* def = can_merge_with_def(phase, true);\n+  if (def == nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Now we know we can merge at least two stores.\n+  ResourceMark rm;\n+  Node_List merge_list;\n+  merge_list.push(this);\n+\n+  uint merge_list_max_size = 8 \/ memory_size();\n+  assert(merge_list_max_size >= 2 &&\n+         merge_list_max_size <= 8 &&\n+         is_power_of_2(merge_list_max_size),\n+         \"must be 2, 4 or 8\");\n+\n+  \/\/ Collect list of stores\n+  while (def != nullptr && merge_list.size() <= merge_list_max_size) {\n+    merge_list.push(def);\n+    def = def->can_merge_with_def(phase, true);\n+  }\n+\n+  int pow2size = round_down_power_of_2(merge_list.size());\n+  assert(pow2size >= 2, \"must be merging at least 2 stores\");\n+\n+  \/\/ Create \/ find new value:\n+  Node* new_value = nullptr;\n+  int new_memory_size = memory_size() * pow2size;\n+  if (in(MemNode::ValueIn)->Opcode() == Op_ConI) {\n+    \/\/ Collect all constants\n+    jlong con = 0;\n+    jlong bits_per_store = memory_size() * 8;\n+    jlong mask = (((jlong)1) << bits_per_store) - 1;\n+    for (int i = 0; i < pow2size; i++) {\n+      jlong con_i = merge_list.at(i)->in(MemNode::ValueIn)->get_int();\n+      con = con << bits_per_store;\n+      con = con | (mask & con_i);\n+    }\n+    new_value = phase->longcon(con);\n+  } else {\n+    Node* first = merge_list.at(pow2size-1);\n+    new_value = first->in(MemNode::ValueIn);\n+    Node* base_last;\n+    jint shift_last;\n+    bool is_true = is_con_RShift(in(MemNode::ValueIn), base_last, shift_last);\n+    assert(is_true, \"must detect con RShift\");\n+    if (new_value != base_last && new_value->Opcode() == Op_ConvL2I) {\n+      \/\/ look through\n+      new_value = new_value->in(1);\n+    }\n+    if (new_value != base_last) {\n+      \/\/ new_value is not the base\n+      return nullptr;\n+    }\n+  }\n+\n+  if (phase->type(new_value)->isa_long() != nullptr && new_memory_size <= 4) {\n+    new_value = phase->transform(new ConvL2INode(new_value));\n+  }\n+\n+  assert((phase->type(new_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n+         (phase->type(new_value)->isa_long() != nullptr && new_memory_size == 8),\n+         \"new_value is either int or long, and new_memory_size is small enough\");\n+\n+  Node* first = merge_list.at(pow2size-1);\n+  Node* new_ctrl = in(MemNode::Control); \/\/ must take last: after all RangeChecks\n+  Node* new_mem  = first->in(MemNode::Memory);\n+  Node* new_adr  = first->in(MemNode::Address);\n+  const TypePtr* atp = TypeRawPtr::BOTTOM;\n+  BasicType bt = T_ILLEGAL;\n+  switch (new_memory_size) {\n+    case 2: bt = T_SHORT; break;\n+    case 4: bt = T_INT;   break;\n+    case 8: bt = T_LONG;  break;\n+  }\n+\n+  StoreNode* new_store = StoreNode::make(*phase, new_ctrl, new_mem, new_adr,\n+                                         atp, new_value, bt, MemNode::unordered);\n+  new_store->set_mismatched_access();\n+\n+  \/\/ Constants above may now also be be packed -> put candidate on worklist\n+  phase->is_IterGVN()->_worklist.push(new_mem);\n+\n+#ifdef ASSERT\n+  if (TraceMergeStores) {\n+    tty->print_cr(\"[TraceMergeStores]: Replace\");\n+    for (int i = pow2size - 1; i >= 0; i--) {\n+      merge_list.at(i)->dump();\n+    }\n+    tty->print_cr(\"[TraceMergeStores]: with\");\n+    new_store->dump();\n+  }\n+#endif\n+\n+  return new_store;\n+}\n+\n+StoreNode* StoreNode::can_merge_with_use(PhaseGVN* phase, bool check_def) {\n+  int opc = Opcode();\n+  assert(opc == Op_StoreB || opc == Op_StoreC || opc == Op_StoreI, \"precondition\");\n+\n+  \/\/ Uses should be:\n+  \/\/ 1) the other StoreNode\n+  \/\/ 2) optionally a MergeMem from the uncommon trap\n+  if (outcnt() > 2) {\n+    return nullptr;\n+  }\n+\n+  StoreNode* use_store = nullptr;\n+  MergeMemNode* merge_mem = nullptr;\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* use = fast_out(i);\n+    if (use->Opcode() == opc && use_store == nullptr) {\n+      use_store = use->as_Store();\n+    } else if (use->is_MergeMem() && merge_mem == nullptr) {\n+      merge_mem = use->as_MergeMem();\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+  if (use_store == nullptr) {\n+    return nullptr;\n+  }\n+  if (merge_mem != nullptr) {\n+    \/\/ Check that merge_mem only leads to the uncommon trap between\n+    \/\/ the two stores.\n+    if (merge_mem->outcnt() != 1) {\n+      return nullptr;\n+    }\n+    Node* ctrl_s1 = use_store->in(MemNode::Control);\n+    Node* ctrl_s2 = this->in(MemNode::Control);\n+    if (!ctrl_s1->is_IfProj() ||\n+        !ctrl_s1->in(0)->is_RangeCheck() ||\n+        ctrl_s1->in(0)->outcnt() != 2) {\n+      return nullptr;\n+    }\n+    ProjNode* other_proj = ctrl_s1->as_IfProj()->other_if_proj();\n+    Node* trap = other_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check);\n+    if (trap != merge_mem->unique_out() ||\n+        ctrl_s1->in(0)->in(0) != ctrl_s2) {\n+      return nullptr;\n+    }\n+  }\n+\n+  \/\/ Having checked \"def -> use\", we now check \"use -> def\".\n+  if (check_def) {\n+    StoreNode* use_def = use_store->can_merge_with_def(phase, false);\n+    if (use_def == nullptr) {\n+      return nullptr;\n+    }\n+    assert(use_def == this, \"def of use is this\");\n+  }\n+\n+  return use_store;\n+}\n+\n+\/\/ Class to parse array pointers of the form:\n+\/\/ pointer = base + constant_offset + (int_offset << int_offset_shift) + sum(other_offsets)\n+\/\/\n+\/\/ The goal is to check if two such ArrayPointers are adjacent for a load or store.\n+\/\/\n+\/\/ Note: we accumulate all constant offsets into constant_offset, even the int constant behind\n+\/\/       the LShiftL(ConvI2L(...)) pattern. For this, we convert \"ConvI2L(x + int_con)\" to\n+\/\/       \"ConvI2L(x) + int_con\", which is only safe if we can assume that either all compared\n+\/\/       addresses have an overflow for \"x + int_con\" or none.\n+\/\/       For loads and stores on arrays, we know that if one overflows and the other not, then\n+\/\/       the two addresses lay almost max_int indices apart, but the maximal array size is\n+\/\/       only about half of that. Therefore, the RangeCheck on at least one of them must have\n+\/\/       failed.\n+class ArrayPointer {\n+private:\n+  const bool _is_valid;          \/\/ The parsing succeeded\n+  const Node* _pointer;          \/\/ The final pointer to the position in the array\n+  const Node* _base;             \/\/ Base address of the array\n+  const jlong _constant_offset;  \/\/ Sum of collected constant offsets\n+  const Node* _int_offset;       \/\/ (optional) Offset behind LShiftL and ConvI2L\n+  const jint _int_offset_shift;  \/\/ (optional) Shift value for int_offset\n+  const GrowableArray<Node*>* _other_offsets; \/\/ List of other AddP offsets\n+\n+  ArrayPointer(const bool is_valid,\n+               const Node* pointer,\n+               const Node* base,\n+               const jlong constant_offset,\n+               const Node* int_offset,\n+               const jint int_offset_shift,\n+               const GrowableArray<Node*>* other_offsets) :\n+      _is_valid(is_valid),\n+      _pointer(pointer),\n+      _base(base),\n+      _constant_offset(constant_offset),\n+      _int_offset(int_offset),\n+      _int_offset_shift(int_offset_shift),\n+      _other_offsets(other_offsets)\n+  {\n+    assert(_pointer != nullptr, \"must always have pointer\");\n+    assert(is_valid == (_base != nullptr), \"have base exactly if valid\");\n+    assert(is_valid == (_other_offsets != nullptr), \"have other_offsets exactly if valid\");\n+  }\n+\n+  static ArrayPointer make_invalid(const Node* pointer) {\n+    return ArrayPointer(false, pointer, nullptr, 0, nullptr, 0, nullptr);\n+  }\n+\n+  static bool parse_int_offset(Node* offset, Node*& int_offset, jint& int_offset_shift) {\n+    \/\/ offset = LShiftL( ConvI2L(int_offset), int_offset_shift)\n+    if (offset->Opcode() == Op_LShiftL &&\n+        offset->in(1)->Opcode() == Op_ConvI2L &&\n+        offset->in(2)->Opcode() == Op_ConI) {\n+      int_offset = offset->in(1)->in(1); \/\/ LShiftL -> ConvI2L -> int_offset\n+      int_offset_shift = offset->in(2)->get_int(); \/\/ LShiftL -> int_offset_shift\n+      return true;\n+    }\n+\n+    \/\/ offset = ConvI2L(int_offset) = LShiftL( ConvI2L(int_offset), 0)\n+    if (offset->Opcode() == Op_ConvI2L) {\n+      int_offset = offset->in(1);\n+      int_offset_shift = 0;\n+      return true;\n+    }\n+\n+    \/\/ parse failed\n+    return false;\n+  }\n+\n+public:\n+  \/\/ Parse the structure above the pointer\n+  static ArrayPointer make(const Node* pointer) {\n+    if (!pointer->is_AddP()) { return ArrayPointer::make_invalid(pointer); }\n+\n+    const Node* base = pointer->in(AddPNode::Base);\n+    if (base == nullptr) { return ArrayPointer::make_invalid(pointer); }\n+\n+    const int search_depth = 5;\n+    Node* offsets[search_depth];\n+    int count = pointer->as_AddP()->unpack_offsets(offsets, search_depth);\n+\n+    \/\/ We expect at least a constant each\n+    if (count <= 0) { return ArrayPointer::make_invalid(pointer); }\n+\n+    \/\/ We extract the form:\n+    \/\/ pointer = base + constant_offset + (int_offset << int_offset_shift) + sum(other_offsets)\n+    jlong constant_offset = 0;\n+    Node* int_offset = nullptr;\n+    jint int_offset_shift = 0;\n+    GrowableArray<Node*>* other_offsets = new GrowableArray<Node*>(count);\n+\n+    for (int i = 0; i < count; i++) {\n+      Node* offset = offsets[i];\n+      if (offset->Opcode() == Op_ConI) {\n+        \/\/ Constant int offset\n+        constant_offset += offset->get_int();\n+      } else if (offset->Opcode() == Op_ConL) {\n+        \/\/ Constant long offset\n+        constant_offset += offset->get_long();\n+      } else if(int_offset == nullptr && parse_int_offset(offset, int_offset, int_offset_shift)) {\n+        \/\/ LShiftL( ConvI2L(int_offset), int_offset_shift)\n+        int_offset = int_offset->uncast();\n+        if (int_offset->Opcode() == Op_AddI && int_offset->in(2)->Opcode() == Op_ConI) {\n+          \/\/ LShiftL( ConvI2L(int_offset + int_con), int_offset_shift)\n+          constant_offset += ((jlong)int_offset->in(2)->get_int()) << int_offset_shift;\n+          int_offset = int_offset->in(1);\n+        }\n+      } else {\n+        \/\/ All others\n+        other_offsets->append(offset);\n+      }\n+    }\n+\n+    return ArrayPointer(true, pointer, base, constant_offset, int_offset, int_offset_shift, other_offsets);\n+  }\n+\n+  bool is_adjacent_to(const ArrayPointer& other, const jlong data_size) const {\n+    if (!_is_valid || !other._is_valid) { return false; }\n+\n+    \/\/ Offset adjacent?\n+    if (this->_constant_offset + data_size != other._constant_offset) { return false; }\n+\n+    \/\/ All other components identical?\n+    if (this->_base != other._base ||\n+        this->_int_offset != other._int_offset ||\n+        this->_int_offset_shift != other._int_offset_shift ||\n+        this->_other_offsets->length() != other._other_offsets->length()) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < this->_other_offsets->length(); i++) {\n+      Node* o1 = this->_other_offsets->at(i);\n+      Node* o2 = other._other_offsets->at(i);\n+      if (o1 != o2) { return false; }\n+    }\n+\n+    return true;\n+  }\n+\n+#ifndef PRODUCT\n+  void dump() {\n+    if (!_is_valid) {\n+      tty->print(\"ArrayPointer[%d %s, invalid]\", _pointer->_idx, _pointer->Name());\n+      return;\n+    }\n+    tty->print(\"ArrayPointer[%d %s, base[%d %s] + %ld\",\n+               _pointer->_idx, _pointer->Name(),\n+               _base->_idx, _base->Name(),\n+               _constant_offset);\n+    if (_int_offset != 0) {\n+      tty->print(\" + I2L[%d %s] << %d\",\n+                 _int_offset->_idx, _int_offset->Name(), _int_offset_shift);\n+    }\n+    for (int i = 0; i < _other_offsets->length(); i++) {\n+      Node* n = _other_offsets->at(i);\n+      tty->print(\" + [%d %s]\", n->_idx, n->Name());\n+    }\n+    tty->print_cr(\"]\");\n+  }\n+#endif\n+};\n+\n+StoreNode* StoreNode::can_merge_with_def(PhaseGVN* phase, bool check_use) {\n+  int opc = Opcode();\n+  assert(opc == Op_StoreB || opc == Op_StoreC || opc == Op_StoreI, \"precondition\");\n+\n+  StoreNode* def = in(MemNode::Memory)->isa_Store();\n+  if (def == nullptr || def->Opcode() != opc) {\n+    return nullptr;\n+  }\n+\n+  StoreNode* s1 = this;\n+  StoreNode* s2 = def->as_Store();\n+  assert(s1->memory_size() == s2->memory_size(), \"same size\");\n+\n+  \/\/ Check ctrl compatibility\n+  Node* ctrl_s1 = s1->in(MemNode::Control);\n+  Node* ctrl_s2 = s2->in(MemNode::Control);\n+  if (ctrl_s1 != ctrl_s2) {\n+    \/\/ See if we can bypass a RangeCheck\n+    if (!ctrl_s1->is_IfProj() ||\n+        !ctrl_s1->in(0)->is_RangeCheck() ||\n+        ctrl_s1->in(0)->outcnt() != 2) {\n+      return nullptr;\n+    }\n+    ProjNode* other_proj = ctrl_s1->as_IfProj()->other_if_proj();\n+    if (other_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) == nullptr ||\n+        ctrl_s1->in(0)->in(0) != ctrl_s2) {\n+      return nullptr;\n+    }\n+    \/\/ Success, we skipped a RangeCheck\n+  }\n+\n+  \/\/ Check value compatibility\n+  Node* value_s1 = s1->in(MemNode::ValueIn);\n+  Node* value_s2 = s2->in(MemNode::ValueIn);\n+\n+  if (value_s1->Opcode() == Op_ConI) {\n+    if (value_s2->Opcode() != Op_ConI) {\n+      return nullptr;\n+    }\n+    \/\/ both are int con\n+  } else {\n+    Node* base_s1;\n+    jint shift_s1;\n+    if (!is_con_RShift(value_s1, base_s1, shift_s1)) {\n+      return nullptr;\n+    }\n+    Node* base_s2;\n+    jint shift_s2;\n+    if (value_s2->Opcode() == Op_ConvL2I) {\n+      \/\/ look through\n+      value_s2 = value_s2->in(1);\n+    }\n+    if (value_s2 == base_s1) {\n+      \/\/ This is the \"shift by zero\" case.\n+      base_s2 = value_s2;\n+      shift_s2 = 0;\n+    } else if (!is_con_RShift(value_s2, base_s2, shift_s2)) {\n+      return nullptr;\n+    }\n+    int bits_per_store = memory_size() * 8;\n+    if (base_s1 != base_s2 ||\n+        shift_s2 + bits_per_store != shift_s1 ||\n+        shift_s1 % bits_per_store != 0) {\n+      return nullptr;\n+    }\n+    \/\/ both load from same value with correct shift\n+  }\n+\n+  \/\/ Check address adjacency\n+  ArrayPointer array_pointer1 = ArrayPointer::make(s1->in(MemNode::Address));\n+  ArrayPointer array_pointer2 = ArrayPointer::make(s2->in(MemNode::Address));\n+  if (!array_pointer2.is_adjacent_to(array_pointer1, s1->memory_size())) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Having checked \"use -> def\", we now check \"def -> use\".\n+  if (check_use) {\n+    StoreNode* def_use = s2->can_merge_with_use(phase, false);\n+    if (def_use == nullptr) {\n+      return nullptr;\n+    }\n+    assert(def_use == this, \"use of def is this\");\n+  }\n+\n+  return s2;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":423,"deletions":0,"binary":false,"changes":423,"status":"modified"},{"patch":"@@ -574,0 +574,4 @@\n+  Node* Ideal_merge_stores(PhaseGVN* phase);\n+  StoreNode* can_merge_with_use(PhaseGVN* phase, bool check_def);\n+  StoreNode* can_merge_with_def(PhaseGVN* phase, bool check_use);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1201,0 +1201,22 @@\n+bool is_con_RShift(Node* n, Node*& base_out, jint& shift_out) {\n+  assert(n != nullptr, \"precondition\");\n+\n+  int opc = n->Opcode();\n+  if (opc == Op_ConvL2I) {\n+    n = n->in(1);\n+    opc = n->Opcode();\n+  }\n+\n+  if ((opc == Op_RShiftI ||\n+       opc == Op_RShiftL ||\n+       opc == Op_URShiftI ||\n+       opc == Op_URShiftL) &&\n+      n->in(2)->is_ConI()) {\n+    base_out = n->in(1);\n+    shift_out = n->in(2)->get_int();\n+    assert(shift_out >= 0, \"must be positive\");\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -289,0 +289,2 @@\n+bool is_con_RShift(Node* n, Node*& base_out, jint& shift_out);\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2276,1 +2276,9 @@\n-  assert( igvn->hash_find(this) != this, \"Need to remove from hash before changing edges\" );\n+#ifdef ASSERT\n+  if (igvn->hash_find(this) == this) {\n+    tty->print_cr(\"Need to remove from hash before changing edges\");\n+    this->dump(1);\n+    tty->print_cr(\"Set at i = %d\", i);\n+    n->dump();\n+    assert(false, \"Need to remove from hash before changing edges\");\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,980 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8318446\n+ * @summary Test merging of consecutive stores\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestMergeStores\n+ *\/\n+\n+public class TestMergeStores {\n+    static int RANGE = 1000;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB = new byte[RANGE];\n+    byte[] bB = new byte[RANGE];\n+    short[] aS = new short[RANGE];\n+    short[] bS = new short[RANGE];\n+    int[] aI = new int[RANGE];\n+    int[] bI = new int[RANGE];\n+    long[] aL = new long[RANGE];\n+    long[] bL = new long[RANGE];\n+\n+    int offset1;\n+    int offset2;\n+    byte vB1;\n+    byte vB2;\n+    short vS1;\n+    short vS2;\n+    int vI1;\n+    int vI2;\n+    long vL1;\n+    long vL2;\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    Map<String, Map<String, TestFunction>> testGroups = new HashMap<String, Map<String, TestFunction>>();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\",\n+                                   \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+    }\n+\n+    public TestMergeStores() {\n+        testGroups.put(\"test1\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test1\").put(\"test1R\", () -> { return test1R(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1a\", () -> { return test1a(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1b\", () -> { return test1b(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1c\", () -> { return test1c(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1d\", () -> { return test1d(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1e\", () -> { return test1e(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1f\", () -> { return test1f(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1g\", () -> { return test1g(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1h\", () -> { return test1h(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1i\", () -> { return test1i(aB.clone()); });\n+\n+        testGroups.put(\"test2\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2\").put(\"test2R\", () -> { return test2R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2a\", () -> { return test2a(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2b\", () -> { return test2b(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2c\", () -> { return test2c(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2d\", () -> { return test2d(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test2\").put(\"test2e\", () -> { return test2d(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test3\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test3\").put(\"test3R\", () -> { return test3R(aB.clone(), offset1, vL1); });\n+        testGroups.get(\"test3\").put(\"test3a\", () -> { return test3a(aB.clone(), offset1, vL1); });\n+\n+        testGroups.put(\"test4\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test4\").put(\"test4R\", () -> { return test4R(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+        testGroups.get(\"test4\").put(\"test4a\", () -> { return test4a(aB.clone(), offset1, vL1, vI1, vS1, vB1); });\n+\n+        testGroups.put(\"test5\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test5\").put(\"test5R\", () -> { return test5R(aB.clone(), offset1); });\n+        testGroups.get(\"test5\").put(\"test5a\", () -> { return test5a(aB.clone(), offset1); });\n+\n+        testGroups.put(\"test6\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test6\").put(\"test6R\", () -> { return test6R(aB.clone(), bB.clone(), offset1, offset2); });\n+        testGroups.get(\"test6\").put(\"test6a\", () -> { return test6a(aB.clone(), bB.clone(), offset1, offset2); });\n+\n+        testGroups.put(\"test100\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test100\").put(\"test100R\", () -> { return test100R(aS.clone(), offset1); });\n+        testGroups.get(\"test100\").put(\"test100a\", () -> { return test100a(aS.clone(), offset1); });\n+\n+        testGroups.put(\"test101\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test101\").put(\"test101R\", () -> { return test101R(aS.clone(), offset1); });\n+        testGroups.get(\"test101\").put(\"test101a\", () -> { return test101a(aS.clone(), offset1); });\n+\n+        testGroups.put(\"test102\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test102\").put(\"test102R\", () -> { return test102R(aS.clone(), offset1, vL1, vI1, vS1); });\n+        testGroups.get(\"test102\").put(\"test102a\", () -> { return test102a(aS.clone(), offset1, vL1, vI1, vS1); });\n+\n+        testGroups.put(\"test200\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test200\").put(\"test200R\", () -> { return test200R(aI.clone(), offset1); });\n+        testGroups.get(\"test200\").put(\"test200a\", () -> { return test200a(aI.clone(), offset1); });\n+\n+        testGroups.put(\"test201\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test201\").put(\"test201R\", () -> { return test201R(aI.clone(), offset1); });\n+        testGroups.get(\"test201\").put(\"test201a\", () -> { return test201a(aI.clone(), offset1); });\n+\n+        testGroups.put(\"test202\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test202\").put(\"test202R\", () -> { return test202R(aI.clone(), offset1, vL1, vI1); });\n+        testGroups.get(\"test202\").put(\"test202a\", () -> { return test202a(aI.clone(), offset1, vL1, vI1); });\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test1a\",\n+                 \"test1b\",\n+                 \"test1c\",\n+                 \"test1d\",\n+                 \"test1e\",\n+                 \"test1f\",\n+                 \"test1g\",\n+                 \"test1h\",\n+                 \"test1i\",\n+                 \"test2a\",\n+                 \"test2b\",\n+                 \"test2c\",\n+                 \"test2d\",\n+                 \"test2e\",\n+                 \"test3a\",\n+                 \"test4a\",\n+                 \"test5a\",\n+                 \"test6a\",\n+                 \"test100a\",\n+                 \"test101a\",\n+                 \"test102a\",\n+                 \"test200a\",\n+                 \"test201a\",\n+                 \"test202a\"})\n+    public void runTests() {\n+        \/\/ Write random values to inputs\n+        set_random(aB);\n+        set_random(bB);\n+        set_random(aS);\n+        set_random(bS);\n+        set_random(aI);\n+        set_random(bI);\n+        set_random(aL);\n+        set_random(bL);\n+\n+        offset1 = Math.abs(RANDOM.nextInt()) % 100;\n+        offset2 = Math.abs(RANDOM.nextInt()) % 100;\n+        vB1 = (byte)RANDOM.nextInt();\n+        vB2 = (byte)RANDOM.nextInt();\n+        vS1 = (short)RANDOM.nextInt();\n+        vS2 = (short)RANDOM.nextInt();\n+        vI1 = RANDOM.nextInt();\n+        vI2 = RANDOM.nextInt();\n+        vL1 = RANDOM.nextLong();\n+        vL2 = RANDOM.nextLong();\n+\n+        \/\/ Run all tests\n+        for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n+            String group_name = group_entry.getKey();\n+            Map<String, TestFunction> group = group_entry.getValue();\n+            Object[] gold = null;\n+            String gold_name = \"NONE\";\n+            for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                Object[] result = test.run();\n+                if (gold == null) {\n+                    gold = result;\n+                    gold_name = name;\n+                } else {\n+                    verify(\"group \" + group_name + \", gold \" + gold_name + \", test \" + name, gold, result);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" = \" + String.format(\"%02X\", g[j] & 0xFF) +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j] +\n+                                           \" = \" + String.format(\"%02X\", r[j] & 0xFF));\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void set_random(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+    }\n+\n+    \/\/ -------------------------------------------\n+    \/\/ -------     Little-Endian API    ----------\n+    \/\/ -------------------------------------------\n+    \/\/ Note: I had to add @ForceInline because otherwise it would sometimes\n+    \/\/       not inline nested method calls.\n+\n+    \/\/ Store a short LE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeShortLE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0),\n+                                  (byte)(value >> 8));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeIntLE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    @ForceInline\n+    static void storeLongLE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 56));\n+    }\n+\n+    \/\/ Store 2 bytes into an array\n+    @ForceInline\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+    }\n+\n+    \/\/ Store 4 bytes into an array\n+    @ForceInline\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+    }\n+\n+    \/\/ Store 8 bytes into an array\n+    @ForceInline\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3,\n+                                                     byte b4, byte b5, byte b6, byte b7) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+        bytes[offset + 4] = b4;\n+        bytes[offset + 5] = b5;\n+        bytes[offset + 6] = b6;\n+        bytes[offset + 7] = b7;\n+    }\n+\n+    @DontCompile\n+    static Object[] test1R(byte[] a) {\n+        a[0] = (byte)0xbe;\n+        a[1] = (byte)0xba;\n+        a[2] = (byte)0xad;\n+        a[3] = (byte)0xba;\n+        a[4] = (byte)0xef;\n+        a[5] = (byte)0xbe;\n+        a[6] = (byte)0xad;\n+        a[7] = (byte)0xde;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test1a(byte[] a) {\n+        a[0] = (byte)0xbe;\n+        a[1] = (byte)0xba;\n+        a[2] = (byte)0xad;\n+        a[3] = (byte)0xba;\n+        a[4] = (byte)0xef;\n+        a[5] = (byte)0xbe;\n+        a[6] = (byte)0xad;\n+        a[7] = (byte)0xde;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test1b(byte[] a) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, 0xdeadbeefbaadbabeL);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test1c(byte[] a) {\n+        storeLongLE(a, 0, 0xdeadbeefbaadbabeL);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test1d(byte[] a) {\n+        storeIntLE(a, 0, 0xbaadbabe);\n+        storeIntLE(a, 4, 0xdeadbeef);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test1e(byte[] a) {\n+        storeShortLE(a, 0, (short)0xbabe);\n+        storeShortLE(a, 2, (short)0xbaad);\n+        storeShortLE(a, 4, (short)0xbeef);\n+        storeShortLE(a, 6, (short)0xdead);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test1f(byte[] a) {\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Do not optimize these, just to be sure we do not mess with store ordering.\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"})\n+    static Object[] test1g(byte[] a) {\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByteRelease(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Do not optimize these, just to be sure we do not mess with store ordering.\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"})\n+    static Object[] test1h(byte[] a) {\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ Do not optimize these, just to be sure we do not mess with store ordering.\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\"})\n+    static Object[] test1i(byte[] a) {\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByteOpaque(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test2R(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        a[offset + 6] = (byte)(v >> 48);\n+        a[offset + 7] = (byte)(v >> 56);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test2a(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 32);\n+        a[offset + 5] = (byte)(v >> 40);\n+        a[offset + 6] = (byte)(v >> 48);\n+        a[offset + 7] = (byte)(v >> 56);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test2b(byte[] a, int offset, long v) {\n+        \/\/ Add custom null check, to ensure the unsafe access always recognizes its type as an array store\n+        if (a == null) {return null;}\n+        UNSAFE.putLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test2c(byte[] a, int offset, long v) {\n+        storeLongLE(a, offset, v);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> int -> byte does not work\n+    static Object[] test2d(byte[] a, int offset, long v) {\n+        storeIntLE(a, offset + 0, (int)(v >> 0));\n+        storeIntLE(a, offset + 4, (int)(v >> 32));\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ No optimization, casting long -> short -> byte does not work\n+    static Object[] test2e(byte[] a, int offset, long v) {\n+        storeShortLE(a, offset + 0, (short)(v >> 0));\n+        storeShortLE(a, offset + 2, (short)(v >> 16));\n+        storeShortLE(a, offset + 4, (short)(v >> 32));\n+        storeShortLE(a, offset + 6, (short)(v >> 48));\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test3R(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 0);\n+        a[offset + 5] = (byte)(v >> 8);\n+        a[offset + 6] = (byte)(v >> 16);\n+        a[offset + 7] = (byte)(v >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"})\n+    static Object[] test3a(byte[] a, int offset, long v) {\n+        a[offset + 0] = (byte)(v >> 0);\n+        a[offset + 1] = (byte)(v >> 8);\n+        a[offset + 2] = (byte)(v >> 16);\n+        a[offset + 3] = (byte)(v >> 24);\n+        a[offset + 4] = (byte)(v >> 0);\n+        a[offset + 5] = (byte)(v >> 8);\n+        a[offset + 6] = (byte)(v >> 16);\n+        a[offset + 7] = (byte)(v >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test4R(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00;\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 0);\n+        a[offset +  5] = (byte)(v1 >> 8);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 0);\n+        a[offset + 11] = (byte)(v2 >> 8);\n+        a[offset + 12] = (byte)(v2 >> 16);\n+        a[offset + 13] = (byte)(v2 >> 24);\n+        a[offset + 14] = (byte)(v3 >> 0);\n+        a[offset + 15] = (byte)(v3 >> 8);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+ 1 for uncommon trap)\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test4a(byte[] a, int offset, long v1, int v2, short v3, byte v4) {\n+        a[offset +  0] = (byte)0x00; \/\/ individual load expected to go into state of RC\n+        a[offset +  1] = (byte)0xFF;\n+        a[offset +  2] = v4;\n+        a[offset +  3] = (byte)0x42;\n+        a[offset +  4] = (byte)(v1 >> 0);\n+        a[offset +  5] = (byte)(v1 >> 8);\n+        a[offset +  6] = (byte)0xAB;\n+        a[offset +  7] = (byte)0xCD;\n+        a[offset +  8] = (byte)0xEF;\n+        a[offset +  9] = (byte)0x01;\n+        a[offset + 10] = (byte)(v2 >> 0);\n+        a[offset + 11] = (byte)(v2 >> 8);\n+        a[offset + 12] = (byte)(v2 >> 16);\n+        a[offset + 13] = (byte)(v2 >> 24);\n+        a[offset + 14] = (byte)(v3 >> 0);\n+        a[offset + 15] = (byte)(v3 >> 8);\n+        a[offset + 16] = (byte)0xEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test5R(byte[] a, int offset) {\n+        a[offset +  0] = (byte)0x01;\n+        a[offset +  1] = (byte)0x02;\n+        a[offset +  2] = (byte)0x03;\n+        a[offset +  3] = (byte)0x04;\n+        a[offset +  4] = (byte)0x11;\n+        a[offset +  5] = (byte)0x22;\n+        a[offset +  6] = (byte)0x33;\n+        a[offset +  7] = (byte)0x44;\n+        a[offset +  8] = (byte)0x55;\n+        a[offset +  9] = (byte)0x66;\n+        a[offset + 10] = (byte)0x77;\n+        a[offset + 11] = (byte)0xAA;\n+        a[offset + 12] = (byte)0xBB;\n+        a[offset + 13] = (byte)0xCC;\n+        a[offset + 14] = (byte)0xDD;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"})\n+    static Object[] test5a(byte[] a, int offset) {\n+        a[offset +  0] = (byte)0x01;\n+        a[offset +  1] = (byte)0x02;\n+        a[offset +  2] = (byte)0x03;\n+        a[offset +  3] = (byte)0x04;\n+        a[offset +  4] = (byte)0x11;\n+        a[offset +  5] = (byte)0x22;\n+        a[offset +  6] = (byte)0x33;\n+        a[offset +  7] = (byte)0x44;\n+        a[offset +  8] = (byte)0x55;\n+        a[offset +  9] = (byte)0x66;\n+        a[offset + 10] = (byte)0x77;\n+        a[offset + 11] = (byte)0xAA;\n+        a[offset + 12] = (byte)0xBB;\n+        a[offset + 13] = (byte)0xCC;\n+        a[offset + 14] = (byte)0xDD;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test6R(byte[] a, byte[] b, int offset1, int offset2) {\n+        a[offset1 +  1] = (byte)0x02;\n+        a[offset1 +  3] = (byte)0x04;\n+        b[offset1 +  4] = (byte)0x11;\n+        a[offset1 +  5] = (byte)0x22;\n+        a[offset2 +  6] = (byte)0x33;\n+        a[offset1 +  7] = (byte)0x44;\n+        b[offset1 +  8] = (byte)0x55;\n+        b[offset1 + 10] = (byte)0x66;\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test6a(byte[] a, byte[] b, int offset1, int offset2) {\n+        a[offset1 +  1] = (byte)0x02;\n+        a[offset1 +  3] = (byte)0x04;\n+        b[offset1 +  4] = (byte)0x11;\n+        a[offset1 +  5] = (byte)0x22;\n+        a[offset2 +  6] = (byte)0x33;\n+        a[offset1 +  7] = (byte)0x44;\n+        b[offset1 +  8] = (byte)0x55;\n+        b[offset1 + 10] = (byte)0x66;\n+        return new Object[]{ a, b };\n+    }\n+\n+    @DontCompile\n+    static Object[] test100R(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100;\n+        a[offset +  1] = (short)0x0200;\n+        a[offset +  2] = (short)0x0311;\n+        a[offset +  3] = (short)0x0400;\n+        a[offset +  4] = (short)0x1100;\n+        a[offset +  5] = (short)0x2233;\n+        a[offset +  6] = (short)0x3300;\n+        a[offset +  7] = (short)0x4400;\n+        a[offset +  8] = (short)0x5599;\n+        a[offset +  9] = (short)0x6600;\n+        a[offset + 10] = (short)0x7700;\n+        a[offset + 11] = (short)0xAACC;\n+        a[offset + 12] = (short)0xBB00;\n+        a[offset + 13] = (short)0xCC00;\n+        a[offset + 14] = (short)0xDDFF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\"})\n+    static Object[] test100a(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100; \/\/ stays unchanged -> both used for RC and Return path\n+        a[offset +  1] = (short)0x0200; \/\/    I\n+        a[offset +  2] = (short)0x0311; \/\/    I\n+        a[offset +  3] = (short)0x0400; \/\/   L\n+        a[offset +  4] = (short)0x1100; \/\/   L\n+        a[offset +  5] = (short)0x2233; \/\/   L\n+        a[offset +  6] = (short)0x3300; \/\/   L\n+        a[offset +  7] = (short)0x4400; \/\/  L\n+        a[offset +  8] = (short)0x5599; \/\/  L\n+        a[offset +  9] = (short)0x6600; \/\/  L\n+        a[offset + 10] = (short)0x7700; \/\/  L\n+        a[offset + 11] = (short)0xAACC; \/\/ L\n+        a[offset + 12] = (short)0xBB00; \/\/ L\n+        a[offset + 13] = (short)0xCC00; \/\/ L\n+        a[offset + 14] = (short)0xDDFF; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test101R(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100;\n+        a[offset +  1] = (short)0x0200;\n+        a[offset +  2] = (short)0x0311;\n+        a[offset +  3] = (short)0x0400;\n+        a[offset +  4] = (short)0x1100;\n+        a[offset +  5] = (short)0x2233;\n+        a[offset +  6] = (short)0x3300;\n+        a[offset +  7] = (short)0x4400;\n+        a[offset +  8] = (short)0x5599;\n+        a[offset +  9] = (short)0x6600;\n+        a[offset + 10] = (short)0x7700;\n+        a[offset + 11] = (short)0xAACC;\n+        a[offset + 12] = (short)0xBB00;\n+        a[offset + 13] = (short)0xCC00;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ only for RC\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\"})\n+    static Object[] test101a(short[] a, int offset) {\n+        a[offset +  0] = (short)0x0100; \/\/    I plus kept unchanged for RC\n+        a[offset +  1] = (short)0x0200; \/\/    I\n+        a[offset +  2] = (short)0x0311; \/\/   L\n+        a[offset +  3] = (short)0x0400; \/\/   L\n+        a[offset +  4] = (short)0x1100; \/\/   L\n+        a[offset +  5] = (short)0x2233; \/\/   L\n+        a[offset +  6] = (short)0x3300; \/\/  L\n+        a[offset +  7] = (short)0x4400; \/\/  L\n+        a[offset +  8] = (short)0x5599; \/\/  L\n+        a[offset +  9] = (short)0x6600; \/\/  L\n+        a[offset + 10] = (short)0x7700; \/\/ L\n+        a[offset + 11] = (short)0xAACC; \/\/ L\n+        a[offset + 12] = (short)0xBB00; \/\/ L\n+        a[offset + 13] = (short)0xCC00; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test102R(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000;\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >>  0);\n+        a[offset +  5] = (short)(v1 >> 16);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 0);\n+        a[offset + 11] = (short)(v1 >> 16);\n+        a[offset + 12] = (short)(v1 >> 32);\n+        a[offset + 13] = (short)(v1 >> 48);\n+        a[offset + 14] = (short)(v2 >> 0);\n+        a[offset + 15] = (short)(v2 >> 16);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\", \/\/ 3 (+1 that goes into RC)\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\"})\n+    static Object[] test102a(short[] a, int offset, long v1, int v2, short v3) {\n+        a[offset +  0] = (short)0x0000; \/\/ store goes into RC\n+        a[offset +  1] = (short)0xFFFF;\n+        a[offset +  2] = v3;\n+        a[offset +  3] = (short)0x4242;\n+        a[offset +  4] = (short)(v1 >>  0);\n+        a[offset +  5] = (short)(v1 >> 16);\n+        a[offset +  6] = (short)0xAB11;\n+        a[offset +  7] = (short)0xCD36;\n+        a[offset +  8] = (short)0xEF89;\n+        a[offset +  9] = (short)0x0156;\n+        a[offset + 10] = (short)(v1 >> 0);\n+        a[offset + 11] = (short)(v1 >> 16);\n+        a[offset + 12] = (short)(v1 >> 32);\n+        a[offset + 13] = (short)(v1 >> 48);\n+        a[offset + 14] = (short)(v2 >> 0);\n+        a[offset + 15] = (short)(v2 >> 16);\n+        a[offset + 16] = (short)0xEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test200R(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236;\n+        a[offset +  1] = 0x02001284;\n+        a[offset +  2] = 0x03111235;\n+        a[offset +  3] = 0x04001294;\n+        a[offset +  4] = 0x11001234;\n+        a[offset +  5] = 0x22331332;\n+        a[offset +  6] = 0x33001234;\n+        a[offset +  7] = 0x44001432;\n+        a[offset +  8] = 0x55991234;\n+        a[offset +  9] = 0x66001233;\n+        a[offset + 10] = 0x77001434;\n+        a[offset + 11] = 0xAACC1234;\n+        a[offset + 12] = 0xBB001434;\n+        a[offset + 13] = 0xCC001236;\n+        a[offset + 14] = 0xDDFF1534;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\"})\n+    static Object[] test200a(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236; \/\/ stays unchanged -> both used for RC and Return path\n+        a[offset +  1] = 0x02001284; \/\/       L\n+        a[offset +  2] = 0x03111235; \/\/       L\n+        a[offset +  3] = 0x04001294; \/\/      L\n+        a[offset +  4] = 0x11001234; \/\/      L\n+        a[offset +  5] = 0x22331332; \/\/     L\n+        a[offset +  6] = 0x33001234; \/\/     L\n+        a[offset +  7] = 0x44001432; \/\/    L\n+        a[offset +  8] = 0x55991234; \/\/    L\n+        a[offset +  9] = 0x66001233; \/\/   L\n+        a[offset + 10] = 0x77001434; \/\/   L\n+        a[offset + 11] = 0xAACC1234; \/\/  L\n+        a[offset + 12] = 0xBB001434; \/\/  L\n+        a[offset + 13] = 0xCC001236; \/\/ L\n+        a[offset + 14] = 0xDDFF1534; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test201R(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236;\n+        a[offset +  1] = 0x02001284;\n+        a[offset +  2] = 0x03111235;\n+        a[offset +  3] = 0x04001294;\n+        a[offset +  4] = 0x11001234;\n+        a[offset +  5] = 0x22331332;\n+        a[offset +  6] = 0x33001234;\n+        a[offset +  7] = 0x44001432;\n+        a[offset +  8] = 0x55991234;\n+        a[offset +  9] = 0x66001233;\n+        a[offset + 10] = 0x77001434;\n+        a[offset + 11] = 0xAACC1234;\n+        a[offset + 12] = 0xBB001434;\n+        a[offset + 13] = 0xCC001236;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\", \/\/ only for RC\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\"})\n+    static Object[] test201a(int[] a, int offset) {\n+        a[offset +  0] = 0x01001236; \/\/       L and also kept unchanged for RC\n+        a[offset +  1] = 0x02001284; \/\/       L\n+        a[offset +  2] = 0x03111235; \/\/      L\n+        a[offset +  3] = 0x04001294; \/\/      L\n+        a[offset +  4] = 0x11001234; \/\/     L\n+        a[offset +  5] = 0x22331332; \/\/     L\n+        a[offset +  6] = 0x33001234; \/\/    L\n+        a[offset +  7] = 0x44001432; \/\/    L\n+        a[offset +  8] = 0x55991234; \/\/   L\n+        a[offset +  9] = 0x66001233; \/\/   L\n+        a[offset + 10] = 0x77001434; \/\/  L\n+        a[offset + 11] = 0xAACC1234; \/\/  L\n+        a[offset + 12] = 0xBB001434; \/\/ L\n+        a[offset + 13] = 0xCC001236; \/\/ L\n+        return new Object[]{ a };\n+    }\n+\n+    @DontCompile\n+    static Object[] test202R(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000;\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >>  0);\n+        a[offset +  5] = (int)(v1 >> 32);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 0);\n+        a[offset + 11] = (int)(v1 >> 32);\n+        a[offset + 12] = (int)(v1 >> 0);\n+        a[offset + 13] = (int)(v1 >> 32);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\", \/\/ 5 (+1 that goes into RC)\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\"})\n+    static Object[] test202a(int[] a, int offset, long v1, int v2) {\n+        a[offset +  0] = 0x00000000; \/\/ merged with store below, but also kept unchanged for RC\n+        a[offset +  1] = 0xFFFFFFFF;\n+        a[offset +  2] = v2;\n+        a[offset +  3] = 0x42424242;\n+        a[offset +  4] = (int)(v1 >>  0);\n+        a[offset +  5] = (int)(v1 >> 32);\n+        a[offset +  6] = 0xAB110129;\n+        a[offset +  7] = 0xCD360183;\n+        a[offset +  8] = 0xEF890173;\n+        a[offset +  9] = 0x01560124;\n+        a[offset + 10] = (int)(v1 >> 0);\n+        a[offset + 11] = (int)(v1 >> 32);\n+        a[offset + 12] = (int)(v1 >> 0);\n+        a[offset + 13] = (int)(v1 >> 32);\n+        a[offset + 14] = v2;\n+        a[offset + 15] = v2;\n+        a[offset + 16] = 0xEFEFEFEF;\n+        return new Object[]{ a };\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":980,"deletions":0,"binary":false,"changes":980,"status":"added"},{"patch":"@@ -0,0 +1,696 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ByteArrayLittleEndian;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 3, time = 3)\n+@Fork(value = 3, jvmArgsAppend = {\n+        \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.util=ALL-UNNAMED\"})\n+@State(Scope.Benchmark)\n+public class MergeStores {\n+\n+    public static final int RANGE = 100;\n+\n+    static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @Param(\"1\")\n+    public static short vS;\n+\n+    @Param(\"1\")\n+    public static int vI;\n+\n+    @Param(\"1\")\n+    public static long vL;\n+\n+    public static int offset = 5;\n+    public static byte[]  aB = new byte[RANGE];\n+    public static short[] aS = new short[RANGE];\n+    public static int[]   aI = new int[RANGE];\n+\n+    \/\/ -------------------------------------------\n+    \/\/ -------     Little-Endian API    ----------\n+    \/\/ -------------------------------------------\n+\n+    \/\/ Store a short LE into an array using store bytes in an array\n+    static void storeShortLE(byte[] bytes, int offset, short value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0),\n+                                  (byte)(value >> 8));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    static void storeIntLE(byte[] bytes, int offset, int value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24));\n+    }\n+\n+    \/\/ Store an int LE into an array using store bytes in an array\n+    static void storeLongLE(byte[] bytes, int offset, long value) {\n+        storeBytes(bytes, offset, (byte)(value >> 0 ),\n+                                  (byte)(value >> 8 ),\n+                                  (byte)(value >> 16),\n+                                  (byte)(value >> 24),\n+                                  (byte)(value >> 32),\n+                                  (byte)(value >> 40),\n+                                  (byte)(value >> 48),\n+                                  (byte)(value >> 56));\n+    }\n+\n+    \/\/ Store 2 bytes into an array\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+    }\n+\n+    \/\/ Store 4 bytes into an array\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+    }\n+\n+    \/\/ Store 8 bytes into an array\n+    static void storeBytes(byte[] bytes, int offset, byte b0, byte b1, byte b2, byte b3,\n+                                                     byte b4, byte b5, byte b6, byte b7) {\n+        bytes[offset + 0] = b0;\n+        bytes[offset + 1] = b1;\n+        bytes[offset + 2] = b2;\n+        bytes[offset + 3] = b3;\n+        bytes[offset + 4] = b4;\n+        bytes[offset + 5] = b5;\n+        bytes[offset + 6] = b6;\n+        bytes[offset + 7] = b7;\n+    }\n+\n+    \/\/ -------------------------------- BENCHMARKS --------------------------------\n+\n+    @Benchmark\n+    public void baseline() {\n+    }\n+\n+    @Benchmark\n+    public byte[] baseline_allocate() {\n+        byte[] aB = new byte[RANGE];\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_adr0_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[0] = (byte)0x01;\n+        aB[1] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_adr1_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[1] = (byte)0x01;\n+        aB[2] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setShort(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeShortLE(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_unsafe() {\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setShort(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_con_offs_nonalloc_leapi() {\n+        storeShortLE(aB, offset, (short)0x0201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vS >> 0 );\n+        aB[offset + 1] = (byte)(vS >> 8 );\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setShort(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeShortLE(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vS >> 0 );\n+        aB[offset + 1] = (byte)(vS >> 8 );\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_unsafe() {\n+        UNSAFE.putShortUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setShort(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B2_S_offs_nonalloc_leapi() {\n+        storeShortLE(aB, offset, vS);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_adr0_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[0] = (byte)0x01;\n+        aB[1] = (byte)0x02;\n+        aB[2] = (byte)0x03;\n+        aB[3] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_adr1_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[1] = (byte)0x01;\n+        aB[2] = (byte)0x02;\n+        aB[3] = (byte)0x03;\n+        aB[4] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setInt(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeIntLE(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_unsafe() {\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setInt(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_con_offs_nonalloc_leapi() {\n+        storeIntLE(aB, offset, 0x04030201);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setInt(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeIntLE(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_unsafe() {\n+        UNSAFE.putIntUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setInt(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B4_I_offs_nonalloc_leapi() {\n+        storeIntLE(aB, offset, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_adr0_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[0] = (byte)0x01;\n+        aB[1] = (byte)0x02;\n+        aB[2] = (byte)0x03;\n+        aB[3] = (byte)0x04;\n+        aB[4] = (byte)0x05;\n+        aB[5] = (byte)0x06;\n+        aB[6] = (byte)0x07;\n+        aB[7] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_adr1_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[1] = (byte)0x01;\n+        aB[2] = (byte)0x02;\n+        aB[3] = (byte)0x03;\n+        aB[4] = (byte)0x04;\n+        aB[5] = (byte)0x05;\n+        aB[6] = (byte)0x06;\n+        aB[7] = (byte)0x07;\n+        aB[8] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        aB[offset + 4] = (byte)0x05;\n+        aB[offset + 5] = (byte)0x06;\n+        aB[offset + 6] = (byte)0x07;\n+        aB[offset + 7] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setLong(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeLongLE(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)0x01;\n+        aB[offset + 1] = (byte)0x02;\n+        aB[offset + 2] = (byte)0x03;\n+        aB[offset + 3] = (byte)0x04;\n+        aB[offset + 4] = (byte)0x05;\n+        aB[offset + 5] = (byte)0x06;\n+        aB[offset + 6] = (byte)0x07;\n+        aB[offset + 7] = (byte)0x08;\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_unsafe() {\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setLong(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_con_offs_nonalloc_leapi() {\n+        storeLongLE(aB, offset, 0x0807060504030201L);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vL >> 0 );\n+        aB[offset + 1] = (byte)(vL >> 8 );\n+        aB[offset + 2] = (byte)(vL >> 16);\n+        aB[offset + 3] = (byte)(vL >> 24);\n+        aB[offset + 4] = (byte)(vL >> 32);\n+        aB[offset + 5] = (byte)(vL >> 40);\n+        aB[offset + 6] = (byte)(vL >> 48);\n+        aB[offset + 7] = (byte)(vL >> 56);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setLong(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeLongLE(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vL >> 0 );\n+        aB[offset + 1] = (byte)(vL >> 8 );\n+        aB[offset + 2] = (byte)(vL >> 16);\n+        aB[offset + 3] = (byte)(vL >> 24);\n+        aB[offset + 4] = (byte)(vL >> 32);\n+        aB[offset + 5] = (byte)(vL >> 40);\n+        aB[offset + 6] = (byte)(vL >> 48);\n+        aB[offset + 7] = (byte)(vL >> 56);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_unsafe() {\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setLong(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_L_offs_nonalloc_leapi() {\n+        storeLongLE(aB, offset, vL);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_direct() {\n+        byte[] aB = new byte[RANGE];\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        aB[offset + 4] = (byte)(vI >> 0 );\n+        aB[offset + 5] = (byte)(vI >> 8 );\n+        aB[offset + 6] = (byte)(vI >> 16);\n+        aB[offset + 7] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_unsafe() {\n+        byte[] aB = new byte[RANGE];\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 0, vI);\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_bale() {\n+        byte[] aB = new byte[RANGE];\n+        ByteArrayLittleEndian.setInt(aB, offset + 0, vI);\n+        ByteArrayLittleEndian.setInt(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_allocate_leapi() {\n+        byte[] aB = new byte[RANGE];\n+        storeIntLE(aB, offset + 0, vI);\n+        storeIntLE(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_direct() {\n+        aB[offset + 0] = (byte)(vI >> 0 );\n+        aB[offset + 1] = (byte)(vI >> 8 );\n+        aB[offset + 2] = (byte)(vI >> 16);\n+        aB[offset + 3] = (byte)(vI >> 24);\n+        aB[offset + 4] = (byte)(vI >> 0 );\n+        aB[offset + 5] = (byte)(vI >> 8 );\n+        aB[offset + 6] = (byte)(vI >> 16);\n+        aB[offset + 7] = (byte)(vI >> 24);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_unsafe() {\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 0, vI);\n+        UNSAFE.putLongUnaligned(aB, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_bale() {\n+        ByteArrayLittleEndian.setInt(aB, offset + 0, vI);\n+        ByteArrayLittleEndian.setInt(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public byte[] store_B8_I2_offs_nonalloc_leapi() {\n+        storeIntLE(aB, offset + 0, vI);\n+        storeIntLE(aB, offset + 4, vI);\n+        return aB;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S2_con_offs_allocate_direct() {\n+        short[] aS = new short[RANGE];\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S2_con_offs_nonalloc_direct() {\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S4_con_offs_allocate_direct() {\n+        short[] aS = new short[RANGE];\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        aS[offset + 2] = (short)0x0506;\n+        aS[offset + 3] = (short)0x0708;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public short[] store_S4_con_offs_nonalloc_direct() {\n+        aS[offset + 0] = (short)0x0102;\n+        aS[offset + 1] = (short)0x0304;\n+        aS[offset + 2] = (short)0x0506;\n+        aS[offset + 3] = (short)0x0708;\n+        return aS;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_con_offs_allocate_direct() {\n+        int[] aI = new int[RANGE];\n+        aI[offset + 0] = 0x01020304;\n+        aI[offset + 1] = 0x05060708;\n+        return aI;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_con_offs_nonalloc_direct() {\n+        aI[offset + 0] = 0x01020304;\n+        aI[offset + 1] = 0x05060708;\n+        return aI;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_zero_offs_allocate_direct() {\n+        int[] aI = new int[RANGE];\n+        aI[offset + 0] = 0;\n+        aI[offset + 1] = 0;\n+        return aI;\n+    }\n+\n+    @Benchmark\n+    public int[] store_I2_zero_offs_nonalloc_direct() {\n+        aI[offset + 0] = 0;\n+        aI[offset + 1] = 0;\n+        return aI;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStores.java","additions":696,"deletions":0,"binary":false,"changes":696,"status":"added"}]}