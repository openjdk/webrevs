{"files":[{"patch":"@@ -2767,1 +2767,1 @@\n-      Node* progress = Ideal_merge_stores(phase);\n+      Node* progress = Ideal_merge_primitive_array_stores(phase);\n@@ -2779,1 +2779,1 @@\n-Node* StoreNode::Ideal_merge_stores(PhaseGVN* phase) {\n+Node* StoreNode::Ideal_merge_primitive_array_stores(PhaseGVN* phase) {\n@@ -2785,0 +2785,5 @@\n+  \/\/ Only merge stores on arrays.\n+  if (adr_type()->isa_aryptr() == nullptr) {\n+    return nullptr;\n+  }\n+\n@@ -2786,1 +2791,1 @@\n-  StoreNode* use = can_merge_with_use(phase, true);\n+  StoreNode* use = can_merge_primitive_array_store_with_use(phase, true);\n@@ -2792,1 +2797,1 @@\n-  StoreNode* def = can_merge_with_def(phase, true);\n+  StoreNode* def = can_merge_primitive_array_store_with_def(phase, true);\n@@ -2811,1 +2816,1 @@\n-    def = def->can_merge_with_def(phase, true);\n+    def = def->can_merge_primitive_array_store_with_def(phase, true);\n@@ -2860,1 +2865,1 @@\n-  const TypePtr* atp = TypeRawPtr::BOTTOM;\n+  const TypePtr* new_adr_type = adr_type();\n@@ -2869,1 +2874,3 @@\n-                                         atp, new_value, bt, MemNode::unordered);\n+                                         new_adr_type, new_value, bt, MemNode::unordered);\n+  \/\/ Marking the store mismatched is sufficient to prevent reordering, since array stores\n+  \/\/ are all on the same slice. Hence, we need no barriers.\n@@ -2889,1 +2896,1 @@\n-StoreNode* StoreNode::can_merge_with_use(PhaseGVN* phase, bool check_def) {\n+StoreNode* StoreNode::can_merge_primitive_array_store_with_use(PhaseGVN* phase, bool check_def) {\n@@ -2938,1 +2945,1 @@\n-    StoreNode* use_def = use_store->can_merge_with_def(phase, false);\n+    StoreNode* use_def = use_store->can_merge_primitive_array_store_with_def(phase, false);\n@@ -3018,1 +3025,2 @@\n-  static ArrayPointer make(const Node* pointer) {\n+  static ArrayPointer make(PhaseGVN* phase, const Node* pointer) {\n+    assert(phase->type(pointer)->isa_aryptr() != nullptr, \"must be array pointer\");\n@@ -3109,1 +3117,1 @@\n-StoreNode* StoreNode::can_merge_with_def(PhaseGVN* phase, bool check_use) {\n+StoreNode* StoreNode::can_merge_primitive_array_store_with_def(PhaseGVN* phase, bool check_use) {\n@@ -3114,1 +3122,3 @@\n-  if (def == nullptr || def->Opcode() != opc) {\n+  if (def == nullptr ||\n+      def->Opcode() != opc ||\n+      def->adr_type()->isa_aryptr() == nullptr) {\n@@ -3178,0 +3188,8 @@\n+  \/\/ -> make sure that we are operating on an array, and the sizes match.\n+  int size_ptr1 = type2aelembytes(s1->adr_type()->is_aryptr()->elem()->array_element_basic_type());\n+  int size_ptr2 = type2aelembytes(s2->adr_type()->is_aryptr()->elem()->array_element_basic_type());\n+  if (size_ptr1 != size_ptr2 ||\n+      size_ptr1 != s1->memory_size() ||\n+      s1->memory_size() != s2->memory_size()) {\n+    return nullptr;\n+  }\n@@ -3180,2 +3198,2 @@\n-    ArrayPointer array_pointer1 = ArrayPointer::make(s1->in(MemNode::Address));\n-    ArrayPointer array_pointer2 = ArrayPointer::make(s2->in(MemNode::Address));\n+    ArrayPointer array_pointer1 = ArrayPointer::make(phase, s1->in(MemNode::Address));\n+    ArrayPointer array_pointer2 = ArrayPointer::make(phase, s2->in(MemNode::Address));\n@@ -3189,1 +3207,1 @@\n-    StoreNode* def_use = s2->can_merge_with_use(phase, false);\n+    StoreNode* def_use = s2->can_merge_primitive_array_store_with_use(phase, false);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -574,3 +574,3 @@\n-  Node* Ideal_merge_stores(PhaseGVN* phase);\n-  StoreNode* can_merge_with_use(PhaseGVN* phase, bool check_def);\n-  StoreNode* can_merge_with_def(PhaseGVN* phase, bool check_use);\n+  Node* Ideal_merge_primitive_array_stores(PhaseGVN* phase);\n+  StoreNode* can_merge_primitive_array_store_with_use(PhaseGVN* phase, bool check_def);\n+  StoreNode* can_merge_primitive_array_store_with_def(PhaseGVN* phase, bool check_use);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,4 @@\n+\n+        testGroups.put(\"test400\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test400\").put(\"test400R\", () -> { return test400R(aI.clone()); });\n+        testGroups.get(\"test400\").put(\"test400a\", () -> { return test400a(aI.clone()); });\n@@ -171,1 +175,2 @@\n-                 \"test300a\"})\n+                 \"test300a\",\n+                 \"test400a\"})\n@@ -1005,0 +1010,35 @@\n+\n+    @DontCompile\n+    static Object[] test400R(int[] a) {\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/ We must be careful with mismatched accesses on arrays:\n+    \/\/ An int-array can have about 2x max_int size, and hence if we address bytes in it, we can have int-overflows.\n+    \/\/ We might consider addresses (x + 0) and (x + 1) as adjacent, even if x = max_int, and therefore the second\n+    \/\/ address overflows and is not adjacent at all.\n+    \/\/ Therefore, we should only consider stores that have the same size as the element type of the array.\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\", \/\/ no merging\n+                  IRNode.STORE_C_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test400a(int[] a) {\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 0, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 1, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 2, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 3, (byte)0xba);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 4, (byte)0xef);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 5, (byte)0xbe);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 6, (byte)0xad);\n+        UNSAFE.putByte(a, UNSAFE.ARRAY_INT_BASE_OFFSET + 7, (byte)0xde);\n+        return new Object[]{ a };\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"}]}