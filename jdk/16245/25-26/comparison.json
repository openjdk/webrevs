{"files":[{"patch":"@@ -2905,1 +2905,0 @@\n-\/\/ TODO desc\n@@ -2964,1 +2963,2 @@\n-  Node* new_value = merged_input_value(merge_list, new_memory_size);\n+  Node* new_input_value = merged_input_value(merge_list, new_memory_size);\n+  if (new_input_value == nullptr) { return nullptr; }\n@@ -2979,1 +2979,1 @@\n-                                         new_adr_type, new_value, bt, MemNode::unordered);\n+                                         new_adr_type, new_input_value, bt, MemNode::unordered);\n@@ -3232,1 +3232,1 @@\n-  Node* new_value = nullptr;\n+  Node* new_input_value = nullptr;\n@@ -3243,1 +3243,1 @@\n-    new_value = _phase->longcon(con);\n+    new_input_value = _phase->longcon(con);\n@@ -3249,1 +3249,1 @@\n-    new_value = first->in(MemNode::ValueIn);\n+    new_input_value = first->in(MemNode::ValueIn);\n@@ -3254,1 +3254,1 @@\n-    if (new_value != base_last && new_value->Opcode() == Op_ConvL2I) {\n+    if (new_input_value != base_last && new_input_value->Opcode() == Op_ConvL2I) {\n@@ -3256,1 +3256,1 @@\n-      new_value = new_value->in(1);\n+      new_input_value = new_input_value->in(1);\n@@ -3258,2 +3258,2 @@\n-    if (new_value != base_last) {\n-      \/\/ new_value is not the base\n+    if (new_input_value != base_last) {\n+      \/\/ new_input_value is not the base\n@@ -3264,1 +3264,1 @@\n-  if (_phase->type(new_value)->isa_long() != nullptr && new_memory_size <= 4) {\n+  if (_phase->type(new_input_value)->isa_long() != nullptr && new_memory_size <= 4) {\n@@ -3271,1 +3271,1 @@\n-    new_value = _phase->transform(new ConvL2INode(new_value));\n+    new_input_value = _phase->transform(new ConvL2INode(new_input_value));\n@@ -3274,3 +3274,3 @@\n-  assert((_phase->type(new_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n-         (_phase->type(new_value)->isa_long() != nullptr && new_memory_size == 8),\n-         \"new_value is either int or long, and new_memory_size is small enough\");\n+  assert((_phase->type(new_input_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n+         (_phase->type(new_input_value)->isa_long() != nullptr && new_memory_size == 8),\n+         \"new_input_value is either int or long, and new_memory_size is small enough\");\n@@ -3278,1 +3278,1 @@\n-  return new_value;\n+  return new_input_value;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -117,0 +117,4 @@\n+        testGroups.put(\"test7\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test7\").put(\"test7R\", (_,_) -> { return test7R(aB.clone(), offset1, vI1); });\n+        testGroups.get(\"test7\").put(\"test7a\", (_,_) -> { return test7a(aB.clone(), offset1, vI1); });\n+\n@@ -187,0 +191,1 @@\n+                 \"test7a\",\n@@ -747,0 +752,20 @@\n+    @DontCompile\n+    static Object[] test7R(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 8);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 24);\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_B_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+                  IRNode.STORE_C_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+                  IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"})\n+    static Object[] test7a(byte[] a, int offset1, int v1) {\n+        a[offset1 +  1] = (byte)(v1 >> 8);\n+        a[offset1 +  2] = (byte)(v1 >> 16);\n+        a[offset1 +  3] = (byte)(v1 >> 24);\n+        return new Object[]{ a };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"}]}