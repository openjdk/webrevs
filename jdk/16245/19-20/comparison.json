{"files":[{"patch":"@@ -2907,2 +2907,4 @@\n-  \/\/ Only merge stores on arrays.\n-  if (_store->adr_type()->isa_aryptr() == nullptr) {\n+  \/\/ Only merge stores on arrays, and the stores must have the same size as the elements.\n+  const TypeAryPtr* aryptr_t = _store->adr_type()->is_aryptr();\n+  if (aryptr_t == nullptr ||\n+      type2aelembytes(aryptr_t->elem()->array_element_basic_type()) != _store->memory_size()) {\n@@ -2924,1 +2926,3 @@\n-  \/\/ TODO\n+  \/\/ Now we know we can merge at least two stores.\n+  ResourceMark rm;\n+  Node_List merge_list;\n@@ -2926,3 +2930,99 @@\n-  tty->print_cr(\"maybe!\");\n-  _store->dump();\n-  return nullptr;\n+  uint merge_list_max_size = 8 \/ _store->memory_size();\n+  assert(merge_list_max_size >= 2 &&\n+         merge_list_max_size <= 8 &&\n+         is_power_of_2(merge_list_max_size),\n+         \"must be 2, 4 or 8\");\n+\n+  \/\/ Collect list of stores\n+  StoreNode* current = _store;\n+  while (current != nullptr && merge_list.size() <= merge_list_max_size) {\n+    merge_list.push(current);\n+    Status status = find_adjacent_def_store(current);\n+    current = status.found_store();\n+\n+    \/\/ We can have at most one RangeCheck.\n+    if (status.found_range_check()) {\n+      merge_list.push(current);\n+      break;\n+    }\n+  }\n+\n+  int pow2size = round_down_power_of_2(merge_list.size());\n+  assert(pow2size >= 2, \"must be merging at least 2 stores\");\n+\n+  \/\/ TODO maybe put in its own method\n+  \/\/ Create \/ find new value:\n+  Node* new_value = nullptr;\n+  int new_memory_size = _store->memory_size() * pow2size;\n+  if (_store->in(MemNode::ValueIn)->Opcode() == Op_ConI) {\n+    \/\/ Collect all constants\n+    jlong con = 0;\n+    jlong bits_per_store = _store->memory_size() * 8;\n+    jlong mask = (((jlong)1) << bits_per_store) - 1;\n+    for (int i = 0; i < pow2size; i++) {\n+      jlong con_i = merge_list.at(i)->in(MemNode::ValueIn)->get_int();\n+      con = con << bits_per_store;\n+      con = con | (mask & con_i);\n+    }\n+    new_value = _phase->longcon(con);\n+  } else {\n+    \/\/ TODO description\n+    Node* first = merge_list.at(pow2size-1);\n+    new_value = first->in(MemNode::ValueIn);\n+    Node const* base_last;\n+    jint shift_last;\n+    bool is_true = is_con_RShift(_store->in(MemNode::ValueIn), base_last, shift_last);\n+    assert(is_true, \"must detect con RShift\");\n+    if (new_value != base_last && new_value->Opcode() == Op_ConvL2I) {\n+      \/\/ look through\n+      new_value = new_value->in(1);\n+    }\n+    if (new_value != base_last) {\n+      \/\/ new_value is not the base\n+      return nullptr;\n+    }\n+  }\n+\n+  if (_phase->type(new_value)->isa_long() != nullptr && new_memory_size <= 4) {\n+    new_value = _phase->transform(new ConvL2INode(new_value));\n+  }\n+\n+  assert((_phase->type(new_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n+         (_phase->type(new_value)->isa_long() != nullptr && new_memory_size == 8),\n+         \"new_value is either int or long, and new_memory_size is small enough\");\n+\n+  Node* first = merge_list.at(pow2size-1);\n+  Node* new_ctrl = _store->in(MemNode::Control); \/\/ must take last: after all RangeChecks\n+  Node* new_mem  = first->in(MemNode::Memory);\n+  Node* new_adr  = first->in(MemNode::Address);\n+  const TypePtr* new_adr_type = _store->adr_type();\n+  BasicType bt = T_ILLEGAL;\n+  switch (new_memory_size) {\n+    case 2: bt = T_SHORT; break;\n+    case 4: bt = T_INT;   break;\n+    case 8: bt = T_LONG;  break;\n+  }\n+\n+  StoreNode* new_store = StoreNode::make(*_phase, new_ctrl, new_mem, new_adr,\n+                                         new_adr_type, new_value, bt, MemNode::unordered);\n+  \/\/ Marking the store mismatched is sufficient to prevent reordering, since array stores\n+  \/\/ are all on the same slice. Hence, we need no barriers.\n+  new_store->set_mismatched_access();\n+\n+  \/\/ Constants above may now also be be packed -> put candidate on worklist\n+  _phase->is_IterGVN()->_worklist.push(new_mem);\n+\n+#ifdef ASSERT\n+  if (TraceMergeStores) {\n+    stringStream ss;\n+    ss.print_cr(\"[TraceMergeStores]: Replace\");\n+    for (int i = pow2size - 1; i >= 0; i--) {\n+      merge_list.at(i)->dump(\"\\n\", false, &ss);\n+    }\n+    ss.print_cr(\"[TraceMergeStores]: with\");\n+    new_store->dump(\"\\n\", false, &ss);\n+    tty->print(\"%s\", ss.as_string());\n+  }\n+#endif\n+\n+  return new_store;\n@@ -2944,4 +3044,4 @@\n-  const TypeAryPtr* ary_t1 = _store->adr_type()->is_aryptr();\n-  const TypeAryPtr* ary_t2 = other_store->adr_type()->is_aryptr();\n-  int size1 = type2aelembytes(ary_t1->elem()->array_element_basic_type());\n-  int size2 = type2aelembytes(ary_t2->elem()->array_element_basic_type());\n+  const TypeAryPtr* aryptr_t1 = _store->adr_type()->is_aryptr();\n+  const TypeAryPtr* aryptr_t2 = other_store->adr_type()->is_aryptr();\n+  int size1 = type2aelembytes(aryptr_t1->elem()->array_element_basic_type());\n+  int size2 = type2aelembytes(aryptr_t2->elem()->array_element_basic_type());\n@@ -3263,96 +3363,0 @@\n-\/\/  \/\/ Now we know we can merge at least two stores.\n-\/\/  ResourceMark rm;\n-\/\/  Node_List merge_list;\n-\/\/  merge_list.push(this);\n-\/\/\n-\/\/  uint merge_list_max_size = 8 \/ memory_size();\n-\/\/  assert(merge_list_max_size >= 2 &&\n-\/\/         merge_list_max_size <= 8 &&\n-\/\/         is_power_of_2(merge_list_max_size),\n-\/\/         \"must be 2, 4 or 8\");\n-\/\/\n-\/\/  \/\/ Collect list of stores\n-\/\/  while (def != nullptr && merge_list.size() <= merge_list_max_size) {\n-\/\/    merge_list.push(def);\n-\/\/    def = def->can_merge_primitive_array_store_with_def(phase, true);\n-\/\/  }\n-\/\/\n-\/\/  int pow2size = round_down_power_of_2(merge_list.size());\n-\/\/  assert(pow2size >= 2, \"must be merging at least 2 stores\");\n-\/\/\n-\/\/  \/\/ Create \/ find new value:\n-\/\/  Node* new_value = nullptr;\n-\/\/  int new_memory_size = memory_size() * pow2size;\n-\/\/  if (in(MemNode::ValueIn)->Opcode() == Op_ConI) {\n-\/\/    \/\/ Collect all constants\n-\/\/    jlong con = 0;\n-\/\/    jlong bits_per_store = memory_size() * 8;\n-\/\/    jlong mask = (((jlong)1) << bits_per_store) - 1;\n-\/\/    for (int i = 0; i < pow2size; i++) {\n-\/\/      jlong con_i = merge_list.at(i)->in(MemNode::ValueIn)->get_int();\n-\/\/      con = con << bits_per_store;\n-\/\/      con = con | (mask & con_i);\n-\/\/    }\n-\/\/    new_value = phase->longcon(con);\n-\/\/  } else {\n-\/\/    Node* first = merge_list.at(pow2size-1);\n-\/\/    new_value = first->in(MemNode::ValueIn);\n-\/\/    Node* base_last;\n-\/\/    jint shift_last;\n-\/\/    bool is_true = is_con_RShift(in(MemNode::ValueIn), base_last, shift_last);\n-\/\/    assert(is_true, \"must detect con RShift\");\n-\/\/    if (new_value != base_last && new_value->Opcode() == Op_ConvL2I) {\n-\/\/      \/\/ look through\n-\/\/      new_value = new_value->in(1);\n-\/\/    }\n-\/\/    if (new_value != base_last) {\n-\/\/      \/\/ new_value is not the base\n-\/\/      return nullptr;\n-\/\/    }\n-\/\/  }\n-\/\/\n-\/\/  if (phase->type(new_value)->isa_long() != nullptr && new_memory_size <= 4) {\n-\/\/    new_value = phase->transform(new ConvL2INode(new_value));\n-\/\/  }\n-\/\/\n-\/\/  assert((phase->type(new_value)->isa_int() != nullptr && new_memory_size <= 4) ||\n-\/\/         (phase->type(new_value)->isa_long() != nullptr && new_memory_size == 8),\n-\/\/         \"new_value is either int or long, and new_memory_size is small enough\");\n-\/\/\n-\/\/  Node* first = merge_list.at(pow2size-1);\n-\/\/  Node* new_ctrl = in(MemNode::Control); \/\/ must take last: after all RangeChecks\n-\/\/  Node* new_mem  = first->in(MemNode::Memory);\n-\/\/  Node* new_adr  = first->in(MemNode::Address);\n-\/\/  const TypePtr* new_adr_type = adr_type();\n-\/\/  BasicType bt = T_ILLEGAL;\n-\/\/  switch (new_memory_size) {\n-\/\/    case 2: bt = T_SHORT; break;\n-\/\/    case 4: bt = T_INT;   break;\n-\/\/    case 8: bt = T_LONG;  break;\n-\/\/  }\n-\/\/\n-\/\/  StoreNode* new_store = StoreNode::make(*phase, new_ctrl, new_mem, new_adr,\n-\/\/                                         new_adr_type, new_value, bt, MemNode::unordered);\n-\/\/  \/\/ Marking the store mismatched is sufficient to prevent reordering, since array stores\n-\/\/  \/\/ are all on the same slice. Hence, we need no barriers.\n-\/\/  new_store->set_mismatched_access();\n-\/\/\n-\/\/  \/\/ Constants above may now also be be packed -> put candidate on worklist\n-\/\/  phase->is_IterGVN()->_worklist.push(new_mem);\n-\/\/\n-\/\/#ifdef ASSERT\n-\/\/  if (TraceMergeStores) {\n-\/\/    stringStream ss;\n-\/\/    ss.print_cr(\"[TraceMergeStores]: Replace\");\n-\/\/    for (int i = pow2size - 1; i >= 0; i--) {\n-\/\/      merge_list.at(i)->dump(\"\\n\", false, &ss);\n-\/\/    }\n-\/\/    ss.print_cr(\"[TraceMergeStores]: with\");\n-\/\/    new_store->dump(\"\\n\", false, &ss);\n-\/\/    tty->print(\"%s\", ss.as_string());\n-\/\/  }\n-\/\/#endif\n-\/\/\n-\/\/  return new_store;\n-\/\/}\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":110,"deletions":106,"binary":false,"changes":216,"status":"modified"}]}