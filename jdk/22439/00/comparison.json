{"files":[{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketImpl;\n+import java.net.SocketImplFactory;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @summary verifies that the socket is closed on constructor failures\n+ * @library \/test\/lib\n+ * @run junit\/othervm --add-opens java.base\/java.net=ALL-UNNAMED CtorFailTest\n+ *\/\n+class CtorFailTest {\n+\n+    private static final VarHandle SOCKET_IMPL_FACTORY_HANDLE = createSocketImplFactoryHandle();\n+\n+    private static final int DEAD_SERVER_PORT = 0xDEAD;\n+\n+    private static VarHandle createSocketImplFactoryHandle() {\n+        try {\n+            Field field = Socket.class.getDeclaredField(\"factory\");\n+            field.setAccessible(true);\n+            return MethodHandles\n+                    .privateLookupIn(Socket.class, MethodHandles.lookup())\n+                    .findStaticVarHandle(Socket.class, \"factory\", SocketImplFactory.class);\n+        } catch (NoSuchFieldException | IllegalAccessException exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withSocketImplFactory(SocketImplFactory newFactory, Executable executable) throws Throwable {\n+        SocketImplFactory oldFactory = (SocketImplFactory) SOCKET_IMPL_FACTORY_HANDLE.getAndSet(newFactory);\n+        try {\n+            executable.execute();\n+        } finally {\n+            SOCKET_IMPL_FACTORY_HANDLE.set(oldFactory);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    @SuppressWarnings(\"resource\")\n+    void test(Exception bindException, Exception connectException) throws Throwable {\n+\n+        \/\/ Create a socket using the mock `SocketImpl` configured to fail\n+        MockSocketImpl socketImpl = new MockSocketImpl(bindException, connectException);\n+        withSocketImplFactory(() -> socketImpl, () -> {\n+\n+            \/\/ Trigger the failure\n+            Exception caughtException = assertThrows(Exception.class, () -> {\n+                \/\/ Address and port are mostly ineffective.\n+                \/\/ They just need to be _valid enough_ to reach to the point where both `SocketImpl#bind()` and `SocketImpl#connect()` are invoked.\n+                \/\/ Failure will be triggered by the injected `SocketImpl`.\n+                InetAddress serverAddress = InetAddress.getLoopbackAddress();\n+                new Socket(serverAddress, DEAD_SERVER_PORT, null, 0);\n+            });\n+\n+            \/\/ Run verifications\n+            Exception expectedException = bindException != null ? bindException : connectException;\n+            assertSame(expectedException, caughtException);\n+            assertEquals(1, socketImpl.closeInvocationCounter.get());\n+\n+        });\n+\n+    }\n+\n+    static List<Arguments> testCases() {\n+        String exceptionMessage = \"intentional test failure\";\n+        return List.of(\n+                Arguments.of(new IOException(exceptionMessage), null),\n+                Arguments.of(null, new IOException(exceptionMessage)),\n+                Arguments.of(new IllegalArgumentException(exceptionMessage), null),\n+                Arguments.of(null, new IllegalArgumentException(exceptionMessage)));\n+    }\n+\n+    private static final class MockSocketImpl extends SocketImpl {\n+\n+        private final AtomicInteger closeInvocationCounter = new AtomicInteger(0);\n+\n+        private final Exception bindException;\n+\n+        private final Exception connectException;\n+\n+        private MockSocketImpl(Exception bindException, Exception connectException) {\n+            this.bindException = bindException;\n+            this.connectException = connectException;\n+        }\n+\n+        @Override\n+        protected void create(boolean stream) {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        protected void bind(InetAddress host, int port) throws IOException {\n+            throwIfPresent(bindException);\n+        }\n+\n+        @Override\n+        protected void connect(SocketAddress address, int timeoutMillis) throws IOException {\n+            throwIfPresent(connectException);\n+        }\n+\n+        private void throwIfPresent(Exception exception) throws IOException {\n+            if (exception != null) {\n+                switch (exception) {\n+                    case IOException error -> throw error;\n+                    case RuntimeException error -> throw error;\n+                    default -> throw new IllegalStateException(\n+                            \"unknown exception type: \" + exception.getClass().getCanonicalName());\n+                }\n+            }\n+        }\n+\n+        \/\/ Rest of the `SocketImpl` methods should not be used, hence overriding them to throw `UOE`\n+\n+        @Override\n+        protected void close() {\n+            closeInvocationCounter.incrementAndGet();\n+        }\n+\n+        @Override\n+        protected void connect(String host, int port) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void connect(InetAddress address, int port) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void listen(int backlog) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void accept(SocketImpl impl) {\n+            throw new UnsupportedOperationException();\n+\n+        }\n+\n+        @Override\n+        protected InputStream getInputStream() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected OutputStream getOutputStream() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected int available() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void sendUrgentData(int data) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setOption(int optID, Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Object getOption(int optID) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/CtorFailTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}