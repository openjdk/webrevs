{"files":[{"patch":"@@ -1512,25 +1512,1 @@\n-        int width = r.getWidth();\n-        int height = r.getHeight();\n-        int startX = r.getMinX();\n-        int startY = r.getMinY();\n-\n-        int[] tdata = null;\n-\n-        \/\/ Clip to the current Raster\n-        Rectangle rclip = new Rectangle(startX, startY, width, height);\n-        Rectangle bclip = new Rectangle(0, 0, raster.width, raster.height);\n-        Rectangle intersect = rclip.intersection(bclip);\n-        if (intersect.isEmpty()) {\n-            return;\n-        }\n-        width = intersect.width;\n-        height = intersect.height;\n-        startX = intersect.x;\n-        startY = intersect.y;\n-\n-        \/\/ remind use get\/setDataElements for speed if Rasters are\n-        \/\/ compatible\n-        for (int i = startY; i < startY+height; i++)  {\n-            tdata = r.getPixels(startX,i,width,1,tdata);\n-            raster.setPixels(startX,i,width,1, tdata);\n-        }\n+        raster.setRect(r);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/BufferedImage.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -425,2 +425,0 @@\n-        int width  = srcRaster.getWidth();\n-        int height = srcRaster.getHeight();\n@@ -429,24 +427,3 @@\n-        int dstOffX = dx+srcOffX;\n-        int dstOffY = dy+srcOffY;\n-\n-        \/\/ Clip to this raster\n-        if (dstOffX < this.minX) {\n-            int skipX = this.minX - dstOffX;\n-            width -= skipX;\n-            srcOffX += skipX;\n-            dstOffX = this.minX;\n-        }\n-        if (dstOffY < this.minY) {\n-            int skipY = this.minY - dstOffY;\n-            height -= skipY;\n-            srcOffY += skipY;\n-            dstOffY = this.minY;\n-        }\n-        if (dstOffX+width > this.minX+this.width) {\n-            width = this.minX + this.width - dstOffX;\n-        }\n-        if (dstOffY+height > this.minY+this.height) {\n-            height = this.minY + this.height - dstOffY;\n-        }\n-\n-        if (width <= 0 || height <= 0) {\n+        Rectangle bsrc = new Rectangle(dx+srcOffX, dy+srcOffY, srcRaster.getWidth(), srcRaster.getHeight());\n+        Rectangle clip = bsrc.intersection(new Rectangle(minX, minY, width, height));\n+        if (clip.isEmpty()) {\n@@ -455,0 +432,6 @@\n+        srcOffX += clip.x - bsrc.x;\n+        srcOffY += clip.y - bsrc.y;\n+        final int dstOffX = clip.x;\n+        final int dstOffY = clip.y;\n+        final int width   = clip.width;\n+        final int height  = clip.height;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/WritableRaster.java","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BandedSampleModel;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.DataBufferFloat;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @author Martin Desruisseaux\n+ *\/\n+public final class SetData {\n+    private static final int WIDTH = 3, HEIGHT = 2;\n+\n+    private static final int TRANSLATE_X = -2, TRANSLATE_Y = -3;\n+\n+    public static void main(final String[] args) {\n+        testWithIntegers();\n+        testWithFloats();\n+        testTranslatedSource();\n+    }\n+\n+    private static void testWithIntegers() {\n+        var data   = new int[] {4, 8, 2, 7, 9, 1};\n+        var empty  = new DataBufferInt(WIDTH*HEIGHT);\n+        var buffer = new DataBufferInt(data, WIDTH*HEIGHT);\n+        buffer = (DataBufferInt) writeAndRead(buffer, empty);\n+        if (!Arrays.equals(data, buffer.getData())) {\n+            throw new AssertionError(\"Pixel values are not equal.\");\n+        }\n+    }\n+\n+    private static void testWithFloats() {\n+        var data   = new float[] {0.4f, 0.8f, 0.2f, 0.7f, 0.9f, 0.1f};\n+        var empty  = new DataBufferFloat(WIDTH*HEIGHT);\n+        var buffer = new DataBufferFloat(data, WIDTH*HEIGHT);\n+        buffer = (DataBufferFloat) writeAndRead(buffer, empty);\n+        if (!Arrays.equals(data, buffer.getData())) {\n+            throw new AssertionError(\"Pixel values are not equal.\");\n+        }\n+    }\n+\n+    private static DataBuffer writeAndRead(DataBuffer buffer, DataBuffer empty) {\n+        \/*\n+         * Prepare an image with all pixels initialized to zero.\n+         *\/\n+        var dt = buffer.getDataType();\n+        var cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);\n+        var cm = new ComponentColorModel(cs, false, false, Transparency.OPAQUE, dt);\n+        var sm = new BandedSampleModel(dt, WIDTH, HEIGHT, 1);\n+        var wr = Raster.createWritableRaster(sm, empty, null);\n+        var im = new BufferedImage(cm, wr, false, null);\n+        \/*\n+         * Write data provided by the data buffer.\n+         *\/\n+        wr = Raster.createWritableRaster(sm, buffer, null);\n+        im.setData(wr);\n+        return im.getRaster().getDataBuffer();\n+    }\n+\n+    private static void testTranslatedSource() {\n+        var source = WritableRaster.createBandedRaster(\n+                DataBuffer.TYPE_BYTE,\n+                WIDTH  - TRANSLATE_X + 2,\n+                HEIGHT - TRANSLATE_Y + 1, 1,\n+                new Point(TRANSLATE_X, TRANSLATE_Y));\n+\n+        for (int y=0; y<HEIGHT; y++) {\n+            for (int x=0; x<WIDTH; x++) {\n+                source.setSample(x, y, 0, (y+1)*10 + (x+1));\n+            }\n+        }\n+        var expected = new byte[] {\n+            11, 12, 13,\n+            21, 22, 23\n+        };\n+        var im = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_BYTE_GRAY);\n+        im.setData(source);\n+        var actual = ((DataBufferByte) im.getRaster().getDataBuffer()).getData();\n+        if (!Arrays.equals(expected, actual)) {\n+            throw new AssertionError(\"Pixel values are not equal.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/BufferedImage\/SetData.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}