{"files":[{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8349759\n+ * @summary Fix CertificateBuilder and SimpleOCSPServer test utilities to\n+ *          support PQC algorithms\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.provider.certpath\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm CPVAlgTestWithOCSP RSA\n+ * @run main\/othervm CPVAlgTestWithOCSP RSA:3072\n+ * @run main\/othervm CPVAlgTestWithOCSP DSA\n+ * @run main\/othervm CPVAlgTestWithOCSP DSA:3072\n+ * @run main\/othervm CPVAlgTestWithOCSP RSASSA-PSS\n+ * @run main\/othervm CPVAlgTestWithOCSP RSASSA-PSS:3072\n+ * @run main\/othervm CPVAlgTestWithOCSP RSASSA-PSS:4096:SHA-512:SHA3-384:128:1\n+ * @run main\/othervm CPVAlgTestWithOCSP EC\n+ * @run main\/othervm CPVAlgTestWithOCSP EC:secp521r1\n+ * @run main\/othervm CPVAlgTestWithOCSP Ed25519\n+ * @run main\/othervm CPVAlgTestWithOCSP ML-DSA-65\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.security.cert.Certificate;\n+import java.security.spec.*;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.security.SimpleOCSPServer;\n+import jdk.test.lib.security.CertificateBuilder;\n+\n+import static java.security.cert.PKIXRevocationChecker.Option.NO_FALLBACK;\n+\n+public class CPVAlgTestWithOCSP {\n+\n+    static final String passwd = \"passphrase\";\n+    static final String ROOT_ALIAS = \"root\";\n+    static final boolean[] CA_KU_FLAGS = {true, false, false, false, false,\n+            true, true, false, false};\n+    static final boolean[] EE_KU_FLAGS = {true, false, false, false, false,\n+            false, false, false, false};\n+    static final List<String> EE_EKU_OIDS = List.of(\"1.3.6.1.5.5.7.3.1\",\n+            \"1.3.6.1.5.5.7.3.2\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args == null || args.length < 1) {\n+            throw new RuntimeException(\n+                    \"Usage: CPVAlgTestWithOCSP <IssKeyAlg>\");\n+        }\n+        String keyGenAlg = args[0];\n+\n+        \/\/ Generate Root and EE keys\n+        KeyPairGenerator keyGen = getKpGen(keyGenAlg);\n+        KeyPair rootCaKP = keyGen.genKeyPair();\n+        KeyPair eeKp = keyGen.genKeyPair();\n+\n+        \/\/ Set up the Root CA Cert\n+        \/\/ Make a 3 year validity starting from 60 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+        long end = start + TimeUnit.DAYS.toMillis(1085);\n+        CertificateBuilder cbld = new CertificateBuilder();\n+        cbld.setSubjectName(\"CN=Root CA Cert, O=SomeCompany\").\n+                setPublicKey(rootCaKP.getPublic()).\n+                setSerialNumber(new BigInteger(\"1\")).\n+                setValidity(new Date(start), new Date(end)).\n+                addSubjectKeyIdExt(rootCaKP.getPublic()).\n+                addAuthorityKeyIdExt(rootCaKP.getPublic()).\n+                addBasicConstraintsExt(true, true, -1).\n+                addKeyUsageExt(CA_KU_FLAGS);\n+\n+        \/\/ Make our Root CA Cert!\n+        X509Certificate rootCert = cbld.build(null, rootCaKP.getPrivate());\n+        log(\"Root CA Created:\\n%s\", rootCert);\n+\n+        \/\/ Now build a keystore and add the keys and cert\n+        KeyStore.Builder keyStoreBuilder =\n+                KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                new KeyStore.PasswordProtection(\"adminadmin0\".toCharArray()));\n+        KeyStore rootKeystore = keyStoreBuilder.getKeyStore();\n+        Certificate[] rootChain = {rootCert};\n+        rootKeystore.setKeyEntry(ROOT_ALIAS, rootCaKP.getPrivate(),\n+                passwd.toCharArray(), rootChain);\n+\n+        \/\/ Now fire up the OCSP responder\n+        SimpleOCSPServer rootOcsp = new SimpleOCSPServer(rootKeystore,\n+                passwd, ROOT_ALIAS, null);\n+        rootOcsp.enableLog(true);\n+        rootOcsp.setNextUpdateInterval(3600);\n+        rootOcsp.start();\n+\n+        \/\/ Wait 60 seconds for server ready\n+        boolean readyStatus = rootOcsp.awaitServerReady(60, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n+        }\n+        int rootOcspPort = rootOcsp.getPort();\n+        String rootRespURI = \"http:\/\/localhost:\" + rootOcspPort;\n+        log(\"Root OCSP Responder URI is %s\", rootRespURI);\n+\n+        \/\/ Let's make an EE cert\n+        \/\/ Make a 1 year validity starting from 60 days ago\n+        start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+        end = start + TimeUnit.DAYS.toMillis(365);\n+        cbld.reset().setSubjectName(\"CN=Brave Sir Robin, O=SomeCompany\").\n+                setPublicKey(eeKp.getPublic()).\n+                setValidity(new Date(start), new Date(end)).\n+                addSubjectKeyIdExt(eeKp.getPublic()).\n+                addAuthorityKeyIdExt(rootCaKP.getPublic()).\n+                addKeyUsageExt(EE_KU_FLAGS).\n+                addExtendedKeyUsageExt(EE_EKU_OIDS).\n+                addSubjectAltNameDNSExt(Collections.singletonList(\"localhost\")).\n+                addAIAExt(Collections.singletonList(rootRespURI));\n+        X509Certificate eeCert = cbld.build(rootCert, rootCaKP.getPrivate());\n+        log(\"EE CA Created:\\n%s\", eeCert);\n+\n+        \/\/ Provide end entity cert revocation info to the Root CA\n+        \/\/ OCSP responder.\n+        Map<BigInteger, SimpleOCSPServer.CertStatusInfo> revInfo =\n+                new HashMap<>();\n+        revInfo.put(eeCert.getSerialNumber(),\n+                new SimpleOCSPServer.CertStatusInfo(\n+                        SimpleOCSPServer.CertStatus.CERT_STATUS_GOOD));\n+        rootOcsp.updateStatusDb(revInfo);\n+\n+        \/\/ validate chain\n+        CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n+        PKIXRevocationChecker prc =\n+                (PKIXRevocationChecker) cpv.getRevocationChecker();\n+        prc.setOptions(EnumSet.of(NO_FALLBACK));\n+        PKIXParameters params =\n+                new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n+        params.addCertPathChecker(prc);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        CertPath cp = cf.generateCertPath(List.of(eeCert));\n+        cpv.validate(cp, params);\n+    }\n+\n+    private static KeyPairGenerator getKpGen(String keyGenAlg)\n+            throws GeneralSecurityException {\n+        String[] algComps = keyGenAlg.split(\":\");\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(algComps[0]);\n+        int bitLen;\n+\n+        \/\/ Handle any parameters in additional tokenized fields\n+        switch (algComps[0].toUpperCase()) {\n+            case \"EC\":\n+                \/\/ The curve name will be the second token, or secp256r1\n+                \/\/ if not provided.\n+                String curveName = (algComps.length >= 2) ? algComps[1] :\n+                        \"secp256r1\";\n+                kpg.initialize(new ECGenParameterSpec(curveName));\n+                break;\n+            case \"RSA\":\n+            case \"DSA\":\n+                \/\/ Form is RSA|DSA[:<KeyBitLen>]\n+                bitLen = (algComps.length >= 2) ?\n+                        Integer.parseInt(algComps[1]) : 2048;\n+                kpg.initialize(bitLen);\n+                break;\n+            case \"RSASSA-PSS\":\n+                \/\/ Form is RSASSA-PSS[:<KeyBitLen>[:HASH:MGFHASH:SALTLEN:TR]]\n+                switch (algComps.length) {\n+                    case 1:     \/\/ Default key length and parameters\n+                        kpg.initialize(2048);\n+                        break;\n+                    case 2:     \/\/ Specified key length, default params\n+                        kpg.initialize(Integer.parseInt(algComps[1]));\n+                        break;\n+                    default:    \/\/ len > 2, key length and specified parameters\n+                        bitLen = Integer.parseInt(algComps[1]);\n+                        String hashAlg = algComps[2];\n+                        MGF1ParameterSpec mSpec = (algComps.length >= 4) ?\n+                                new MGF1ParameterSpec(algComps[3]) :\n+                                MGF1ParameterSpec.SHA256;\n+                        int saltLen = (algComps.length >= 5) ?\n+                                Integer.parseInt(algComps[4]) : 32;\n+                        int trail = (algComps.length >= 6) ?\n+                                Integer.parseInt(algComps[5]) :\n+                                PSSParameterSpec.TRAILER_FIELD_BC;\n+                        PSSParameterSpec pSpec = new PSSParameterSpec(hashAlg,\n+                                \"MGF1\", mSpec, saltLen, trail);\n+                        kpg.initialize(new RSAKeyGenParameterSpec(bitLen,\n+                                RSAKeyGenParameterSpec.F4, pSpec));\n+                        break;\n+                }\n+\n+            \/\/ Default: just use the KPG as-is, no additional init needed.\n+    }\n+\n+        return kpg;\n+    }\n+\n+    \/**\n+     * Log a message on stdout\n+     *\n+     * @param format the format string for the log entry\n+     * @param args zero or more arguments corresponding to the format string\n+     *\/\n+    private static void log(String format, Object ... args) {\n+        System.out.format(format + \"\\n\", args);\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/security\/CPVAlgTestWithOCSP.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -54,1 +54,0 @@\n-import sun.security.x509.SerialNumber;\n@@ -392,1 +391,24 @@\n-     * Build the certificate.\n+     * Build the certificate using the default algorithm for the provided\n+     * signing key.\n+     *\n+     * @param issuerCert The certificate of the issuing authority, or\n+     * {@code null} if the resulting certificate is self-signed.\n+     * @param issuerKey The private key of the issuing authority\n+     *\n+     * @return The resulting {@link X509Certificate}\n+     *\n+     * @throws IOException if an encoding error occurs.\n+     * @throws CertificateException If the certificate cannot be generated\n+     * by the underlying {@link CertificateFactory}\n+     * @throws NoSuchAlgorithmException If an invalid signature algorithm\n+     * is provided.\n+     *\/\n+    public X509Certificate build(X509Certificate issuerCert,\n+            PrivateKey issuerKey) throws IOException, CertificateException,\n+            NoSuchAlgorithmException {\n+        return build(issuerCert, issuerKey,\n+                SignatureUtil.getDefaultSigAlgForKey(issuerKey));\n+    }\n+\n+    \/**\n+     * Build the certificate using the key and specified signing algorithm.\n@@ -410,2 +432,0 @@\n-        \/\/ TODO: add some basic checks (key usage, basic constraints maybe)\n-\n@@ -442,1 +462,1 @@\n-        AlgorithmId signAlg = AlgorithmId.get(algName);\n+        AlgorithmId signAlg;\n@@ -447,2 +467,1 @@\n-            Signature sig = SignatureUtil.fromKey(signAlg.getName(), issuerKey, (Provider)null);\n-            \/\/ Rewrite signAlg, RSASSA-PSS needs some parameters.\n+            Signature sig = SignatureUtil.fromKey(algName, issuerKey, \"\");\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -64,1 +65,1 @@\n-    public static enum CertStatus {\n+    public enum CertStatus {\n@@ -72,1 +73,1 @@\n-    private InetAddress listenAddress;\n+    private final InetAddress listenAddress;\n@@ -76,4 +77,4 @@\n-    private KeyStore keystore;\n-    private X509Certificate issuerCert;\n-    private X509Certificate signerCert;\n-    private PrivateKey signerKey;\n+    private final KeyStore keystore;\n+    private final X509Certificate issuerCert;\n+    private final X509Certificate signerCert;\n+    private final PrivateKey signerKey;\n@@ -94,3 +95,3 @@\n-    private ResponderId respId;\n-    private AlgorithmId sigAlgId;\n-    private Map<CertId, CertStatusInfo> statusDb =\n+    private final ResponderId respId;\n+    private String sigAlgName;\n+    private final Map<CertId, CertStatusInfo> statusDb =\n@@ -143,1 +144,1 @@\n-        Objects.requireNonNull(ks, \"Null keystore provided\");\n+        keystore = Objects.requireNonNull(ks, \"Null keystore provided\");\n@@ -148,2 +149,1 @@\n-        keystore = ks;\n-        issuerCert = (X509Certificate)ks.getCertificate(issuerAlias);\n+        issuerCert = (X509Certificate)keystore.getCertificate(issuerAlias);\n@@ -156,1 +156,1 @@\n-            signerCert = (X509Certificate)ks.getCertificate(signerAlias);\n+            signerCert = (X509Certificate)keystore.getCertificate(signerAlias);\n@@ -161,1 +161,1 @@\n-            signerKey = (PrivateKey)ks.getKey(signerAlias,\n+            signerKey = (PrivateKey)keystore.getKey(signerAlias,\n@@ -169,1 +169,1 @@\n-            signerKey = (PrivateKey)ks.getKey(issuerAlias,\n+            signerKey = (PrivateKey)keystore.getKey(issuerAlias,\n@@ -176,1 +176,1 @@\n-        sigAlgId = AlgorithmId.get(SignatureUtil.getDefaultSigAlgForKey(signerKey));\n+        sigAlgName = SignatureUtil.getDefaultSigAlgForKey(signerKey);\n@@ -498,2 +498,8 @@\n-            sigAlgId = AlgorithmId.get(algName);\n-            log(\"Signature algorithm set to \" + sigAlgId.getName());\n+            \/\/ We don't care about the AlgorithmId object, we're just\n+            \/\/ using it to validate the algName parameter.\n+            AlgorithmId.get(algName);\n+            sigAlgName = algName;\n+            log(\"Signature algorithm set to \" + algName);\n+        } else {\n+            log(\"Signature algorithm cannot be set on a running server, \" +\n+                    \"stop the server first\");\n@@ -607,1 +613,1 @@\n-        private CertStatus certStatusType;\n+        private final CertStatus certStatusType;\n@@ -609,1 +615,1 @@\n-        private Date revocationTime;\n+        private final Date revocationTime;\n@@ -748,1 +754,1 @@\n-                LocalOcspRequest ocspReq = null;\n+                LocalOcspRequest ocspReq;\n@@ -797,1 +803,1 @@\n-            } catch (IOException | CertificateException exc) {\n+            } catch (IOException | GeneralSecurityException exc) {\n@@ -829,0 +835,1 @@\n+            log(resp.toString());\n@@ -830,1 +837,1 @@\n-            out.write(sb.toString().getBytes(\"UTF-8\"));\n+            out.write(sb.toString().getBytes(StandardCharsets.UTF_8));\n@@ -832,1 +839,0 @@\n-            log(resp.toString());\n@@ -943,1 +949,1 @@\n-                            \"UTF-8\")));\n+                            StandardCharsets.UTF_8)));\n@@ -977,2 +983,1 @@\n-\n-            return new String(bos.toByteArray(), \"UTF-8\");\n+            return bos.toString(StandardCharsets.UTF_8);\n@@ -1055,1 +1060,0 @@\n-                int i = 0;\n@@ -1134,1 +1138,1 @@\n-         * {@cpde X509Certificate} objects.\n+         * {@code X509Certificate} objects.\n@@ -1298,1 +1302,2 @@\n-        private final byte[] encodedResponse;\n+        private final Signature signEngine;\n+        private final AlgorithmId sigAlgId;\n@@ -1308,0 +1313,2 @@\n+         * @throws GeneralSecurityException if errors occur while obtaining\n+         * the signature object or any algorithm identifier parameters.\n@@ -1310,1 +1317,1 @@\n-                throws IOException {\n+                throws IOException, GeneralSecurityException {\n@@ -1327,0 +1334,2 @@\n+         * @throws GeneralSecurityException if errors occur while obtaining\n+         * the signature object or any algorithm identifier parameters.\n@@ -1330,1 +1339,2 @@\n-                Map<String, Extension> reqExtensions) throws IOException {\n+                Map<String, Extension> reqExtensions)\n+                throws IOException, GeneralSecurityException {\n@@ -1351,0 +1361,4 @@\n+                \/\/ Create the signature object and AlgorithmId that we'll use\n+                \/\/ later to create the signature on this response.\n+                signEngine = SignatureUtil.fromKey(sigAlgName, signerKey, \"\");\n+                sigAlgId = SignatureUtil.fromSignature(signEngine, signerKey);\n@@ -1356,0 +1370,2 @@\n+                signEngine = null;\n+                sigAlgId = null;\n@@ -1357,1 +1373,0 @@\n-            encodedResponse = this.getBytes();\n@@ -1439,7 +1454,3 @@\n-                \/\/ Create the signature\n-                Signature sig = SignatureUtil.fromKey(\n-                        sigAlgId.getName(), signerKey, (Provider)null);\n-                sig.update(tbsResponseBytes);\n-                signature = sig.sign();\n-                \/\/ Rewrite signAlg, RSASSA-PSS needs some parameters.\n-                sigAlgId = SignatureUtil.fromSignature(sig, signerKey);\n+                \/\/ Create the signature with the initialized Signature object\n+                signEngine.update(tbsResponseBytes);\n+                signature = signEngine.sign();\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SimpleOCSPServer.java","additions":51,"deletions":40,"binary":false,"changes":91,"status":"modified"}]}