{"files":[{"patch":"@@ -0,0 +1,67 @@\n+package jdk.jfr;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Event field annotation, specifies that the value carries contextual\n+ * information.\n+ * <p>\n+ * Contextual information is data that applies to all events happening in the\n+ * same thread from the beginning to the end of the event with a field annotated\n+ * with {@code Contextual}.\n+ * <p>\n+ * For example, to trace requests or transactions in a system, a trace event can\n+ * be created to provide context.\n+ * {@snippet class = \"Snippets\" region = \"ContextualTrace\"}\n+ * <p>\n+ * To track details within an order service, an order event can be created where\n+ * only the order ID provides context.\n+ * {@snippet class = \"Snippets\" region = \"ContextualOrder\"}\n+ * <p>\n+ * If an order in the order service stalls due to lock contention, a user\n+ * interface can display contextual information together with the\n+ * JavaMonitorEnter event to simplify troubleshooting, for example:\n+ * {@snippet lang=text :\n+ *   $ jfr print --events JavaMonitorEnter recording.jfr\n+ *   jdk.JavaMonitorEnter {\n+ *     Context: Trace.id = \"00-0af7651916cd43dd8448eb211c80319c-00f067aa0ba902b7-01\"\n+ *     Context: Trace.name = \"POST \/checkout\/place-order\"\n+ *     Context: Order.id = 314159\n+ *     startTime = 17:51:29.038 (2025-02-07)\n+ *     duration = 50.56 ms\n+ *     monitorClass = java.util.ArrayDeque (classLoader = bootstrap)\n+ *    previousOwner = \"Order Thread\" (javaThreadId = 56209, virtual = true)\n+ *    address = 0x60000232ECB0\n+ *    eventThread = \"Order Thread\" (javaThreadId = 52613, virtual = true)\n+ *    stackTrace = [\n+ *      java.util.zip.ZipFile$CleanableResource.getInflater() line: 685\n+ *      java.util.zip.ZipFile$ZipFileInflaterInputStream.<init>(ZipFile) line: 388\n+ *      java.util.zip.ZipFile.getInputStream(ZipEntry) line: 355\n+ *      java.util.jar.JarFile.getInputStream(ZipEntry) line: 833\n+ *      ...\n+ *    ]\n+ *   }\n+ * }\n+ * <p>\n+ * The difference between {@link Relational} and {@link Contextual} annotations\n+ * is that {@link Relational} ties event data together to form a global data\n+ * structure, similar to a foreign key in a relational database, but\n+ * {@link Contextual} represents a state that applies to all events that happen\n+ * at the same time, in the same thread. A field can be both contextual and\n+ * relational at the same time.\n+ * <p>\n+ * A contextual field may incur overhead on a parser reading a recording file,\n+ * since it must track active context, so it should be used sparingly and only\n+ * where appropriate.\n+ *\n+ * @since 25\n+ *\/\n+@MetadataDefinition\n+@Label(\"Context\")\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.FIELD})\n+public @interface Contextual {\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Contextual.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.jfr.Contextual;\n@@ -38,0 +39,1 @@\n+    @Contextual\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTraceEvent.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,1 +208,5 @@\n-                    pEventType.setFields(nativeType.getFields());\n+                    PrivateAccess access = PrivateAccess.getInstance();\n+                    for (int i = 0; i < nativeFields.size(); i++) {\n+                        access.setAnnotations(nativeFields.get(i), eventFields.get(i).getAnnotationElements());\n+                    }\n+                    pEventType.setFields(nativeFields);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,0 +30,1 @@\n+import java.nio.file.Path;\n@@ -30,0 +32,1 @@\n+import java.time.Instant;\n@@ -33,0 +36,3 @@\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n@@ -34,0 +40,3 @@\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.SequencedSet;\n@@ -36,0 +45,1 @@\n+import jdk.jfr.Contextual;\n@@ -37,0 +47,1 @@\n+import jdk.jfr.EventType;\n@@ -49,1 +60,1 @@\n-import jdk.jfr.internal.Type;\n+import jdk.jfr.consumer.RecordingFile;\n@@ -58,1 +69,37 @@\n-    private static final String TYPE_OLD_OBJECT = Type.TYPES_PREFIX + \"OldObject\";\n+    private static record Timestamp(RecordedEvent event, long seconds, int nanosCompare, boolean contextual) implements Comparable<Timestamp> {\n+        \/\/ If the start timestamp from a contextual event has the same start timestamp\n+        \/\/ as an ordinary instant event, the contextual event should be processed first\n+        \/\/ One way to ensure this is to multiply the nanos value and add 1 ns to the end\n+        \/\/ timestamp so the context event always comes first in a comparison.\n+        \/\/ This also prevents a contextual start time to be processed after a contextual\n+        \/\/ end time, if the event is instantaneous.\n+        public static Timestamp createStart(RecordedEvent event, boolean contextual) {\n+            Instant time = event.getStartTime(); \/\/ Method allocates, so store seconds and nanos\n+            return new Timestamp(event, time.getEpochSecond(), 2 * time.getNano(), contextual);\n+        }\n+\n+        public static Timestamp createEnd(RecordedEvent event, boolean contextual) {\n+            Instant time = event.getEndTime(); \/\/ Method allocates, so store seconds and nanos\n+            return new Timestamp(event, time.getEpochSecond(), 2 * time.getNano() + 1, contextual);\n+        }\n+\n+        public boolean start() {\n+            return (nanosCompare & 1L) == 0;\n+        }\n+\n+        @Override\n+        public int compareTo(Timestamp that) {\n+            \/\/ This is taken from Instant::compareTo\n+            int cmp = Long.compare(seconds, that.seconds);\n+            if (cmp != 0) {\n+                return cmp;\n+            }\n+            return nanosCompare - that.nanosCompare;\n+        }\n+    }\n+\n+    private static record TypeInformation(Long id, List<ValueDescriptor> contextualFields, boolean contextual, String simpleName) {\n+    }\n+\n+    private static final SequencedSet<RecordedEvent> EMPTY_SET = new LinkedHashSet<>();\n+    private static final String TYPE_OLD_OBJECT = \"jdk.types.OldObject\";\n@@ -62,0 +109,14 @@\n+    \/\/ Rationale for using one million events in the window.\n+    \/\/ Events in JFR arrive in batches. The commit time (end time) of an\n+    \/\/ event in batch N typically doesn't come before any events in batch N - 1,\n+    \/\/ but it can't be ruled out completely. Data is also partitioned into chunks,\n+    \/\/ typically 16 MB each. Within a chunk, there must be at least one batch.\n+    \/\/ The size of an event is typically more than 16 bytes, so an\n+    \/\/ EVENT_WINDOW_SIZE of 1 000 000 events will likely cover more than one batch.\n+    \/\/ Having at least two batches in a window avoids boundary issues.\n+    \/\/ At the same time, a too large window, means it will take more time\n+    \/\/ before the first event is printed and the tool will feel unresponsive.\n+    private static final int EVENT_WINDOW_SIZE = 1_000_000;\n+    private final PriorityQueue<Timestamp> timeline = new PriorityQueue<>(EVENT_WINDOW_SIZE + 4);\n+    private final Map<Long, TypeInformation> typeInformation = new HashMap<>();\n+    private final Map<Long, SequencedSet<RecordedEvent>> contexts = new HashMap<>();\n@@ -74,0 +135,87 @@\n+    void print(Path source) throws IOException {\n+        printBegin();\n+        int counter = 0;\n+        try (RecordingFile file = new RecordingFile(source)) {\n+            while (file.hasMoreEvents()) {\n+                RecordedEvent event = file.readEvent();\n+                if (typeInformation(event).contextual()) {\n+                    timeline.add(Timestamp.createStart(event, true));\n+                    timeline.add(Timestamp.createEnd(event, true));\n+                }\n+                if (acceptEvent(event)) {\n+                    timeline.add(Timestamp.createEnd(event, false));\n+                }\n+                \/\/ There should not be a limit on the size of the recording files that\n+                \/\/ the 'jfr' tool can process. To avoid OutOfMemoryError and time complexity\n+                \/\/ issues on large recordings, a window size must be set when sorting\n+                \/\/ and processing contextual events.\n+                while (timeline.size() > EVENT_WINDOW_SIZE) {\n+                    print(timeline.remove());\n+                    flush(false);\n+                }\n+                if ((++counter % EVENT_WINDOW_SIZE) == 0) {\n+                    contexts.entrySet().removeIf(c -> c.getValue().isEmpty());\n+                }\n+            }\n+            while (!timeline.isEmpty()) {\n+                print(timeline.remove());\n+            }\n+        }\n+        printEnd();\n+        flush(true);\n+    }\n+\n+    private TypeInformation typeInformation(RecordedEvent event) {\n+        long id = event.getEventType().getId();\n+        TypeInformation ti = typeInformation.get(id);\n+        if (ti == null) {\n+            ti = createTypeInformation(event.getEventType());\n+            typeInformation.put(ti.id(), ti);\n+        }\n+        return ti;\n+    }\n+\n+    private TypeInformation createTypeInformation(EventType eventType) {\n+        ArrayList<ValueDescriptor> contextualFields = new ArrayList<>();\n+        for (ValueDescriptor v : eventType.getFields()) {\n+            if (v.getAnnotation(Contextual.class) != null) {\n+                contextualFields.add(v);\n+            }\n+        }\n+        contextualFields.trimToSize();\n+        String name = eventType.getName();\n+        String simpleName = name.substring(name.lastIndexOf(\".\") + 1);\n+        boolean contextual = contextualFields.size() > 0;\n+        return new TypeInformation(eventType.getId(), contextualFields, contextual, simpleName);\n+    }\n+\n+    private void print(Timestamp t) {\n+        RecordedEvent event = t.event();\n+        RecordedThread rt = event.getThread();\n+        if (rt != null) {\n+            processThreadedTimestamp(rt, t);\n+        } else {\n+            if (!t.contextual()) {\n+                print(event);\n+            }\n+        }\n+    }\n+\n+    public void processThreadedTimestamp(RecordedThread thread, Timestamp t) {\n+        RecordedEvent event = t.event();\n+        var contextEvents = contexts.computeIfAbsent(thread.getId(), k -> new LinkedHashSet<>(1));\n+        if (t.contextual) {\n+            if (t.start()) {\n+                contextEvents.add(event);\n+            } else {\n+                contextEvents.remove(event);\n+            }\n+            return;\n+        }\n+        if (typeInformation(event).contextual()) {\n+            print(event);\n+        } else {\n+            print(event, contextEvents);\n+        }\n+    }\n+\n@@ -76,4 +224,1 @@\n-        for (RecordedEvent e : events) {\n-            print(e);\n-            flush(false);\n-        }\n+        throw new InternalError(\"Should not reach here!\");\n@@ -83,0 +228,4 @@\n+        print(event, EMPTY_SET);\n+    }\n+\n+    public void print(RecordedEvent event, SequencedSet<RecordedEvent> context) {\n@@ -87,0 +236,3 @@\n+        if (!context.isEmpty()) {\n+            printContexts(context);\n+        }\n@@ -109,0 +261,16 @@\n+    private void printContexts(SequencedSet<RecordedEvent> contextEvents) {\n+        for (RecordedEvent e : contextEvents) {\n+            printContextFields(e);\n+        }\n+    }\n+\n+    private void printContextFields(RecordedEvent contextEvent) {\n+        TypeInformation ti = typeInformation(contextEvent);\n+        for (ValueDescriptor v : ti.contextualFields()) {\n+            printIndent();\n+            String name = \"Context: \" + ti.simpleName() + \".\" + v.getName();\n+            print(name, \" = \");\n+            printValue(getValue(contextEvent, v), v, \"\");\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":175,"deletions":7,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.jfr.Contextual;\n@@ -254,0 +255,33 @@\n+    \/\/ @start region=\"ContextualTrace\"\n+    @Label(\"Trace\")\n+    @Name(\"com.example.Trace\")\n+    class TraceEvent extends Event {\n+        @Label(\"ID\")\n+        @Contextual\n+        String id;\n+\n+        @Label(\"Name\")\n+        @Contextual\n+        String name;\n+    }\n+    \/\/ @end\n+\n+    void hello() {\n+        \/\/ @start region=\"ContextualOrder\"\n+        @Label(\"Order\")\n+        @Name(\"com.example.Order\")\n+        class OrderEvent extends Event {\n+            @Label(\"Order ID\")\n+            @Contextual\n+            long id;\n+\n+            @Label(\"Order Date\")\n+            @Timestamp(Timestamp.MILLISECONDS_SINCE_EPOCH)\n+            long date;\n+\n+            @Label(\"Payment Method\")\n+            String paymentMethod;\n+        }\n+        \/\/ @end\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/snippet-files\/Snippets.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.tool;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.Contextual;\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.StackTrace;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.tool.TestPrintContextual\n+ *\/\n+public class TestPrintContextual {\n+    private static final int WINDOW_SIZE = 1_000_000;\n+    private static final String CONTEXT_MARKER = \"Context: \";\n+\n+    private static final class PrintedEvent {\n+        private final List<Map.Entry<String, String>> contextValues = new ArrayList<>();\n+        private final List<Map.Entry<String, String>> values = new ArrayList<>();\n+        private final String name;\n+\n+        public PrintedEvent(String name) {\n+            this.name = name;\n+        }\n+\n+        public void addValue(String key, String value) {\n+            values.add(new AbstractMap.SimpleEntry<>(key, value));\n+        }\n+\n+        public void addContextValue(String key, String value) {\n+            contextValues.add(new AbstractMap.SimpleEntry<>(key, value));\n+        }\n+\n+        public List<Map.Entry<String, String>> getContextValues() {\n+            return contextValues;\n+        }\n+\n+        public String getContextValue(String key) {\n+            for (var entry : contextValues) {\n+                if (entry.getKey().equals(key)) {\n+                    return entry.getValue();\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    @Name(\"Span\")\n+    static class SpanEvent extends Event {\n+        @Contextual\n+        String name;\n+        @Contextual\n+        long spanId;\n+    }\n+\n+    @Name(\"Trace\")\n+    static class TraceEvent extends Event {\n+        long traceId;\n+        @Contextual\n+        String name;\n+    }\n+\n+    @Name(\"Filler\")\n+    @StackTrace(false)\n+    static class FillerEvent extends Event {\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        testContextValues();\n+        testInterleaved();\n+        testDeepContext();\n+        testThreadedContext();\n+        testFiltered();\n+    }\n+\n+    \/\/ Tests that context values are injected into non-contextual events\n+    private static void testContextValues() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Trace\").withoutStackTrace();\n+            r.enable(\"Span\").withoutStackTrace();\n+            r.enable(\"jdk.SystemGC\").withoutStackTrace();\n+            r.start();\n+\n+            SpanEvent span = new SpanEvent();\n+            span.name = \"span\";\n+            span.spanId = 4711;\n+            span.begin();\n+            System.gc();\n+            span.commit();\n+\n+            TraceEvent trace = new TraceEvent();\n+            trace.name = \"trace\";\n+            trace.traceId = 17;\n+            trace.begin();\n+            System.gc();\n+            trace.commit();\n+\n+            r.stop();\n+\n+            List<PrintedEvent> events = dumpPrintedEvents(r, Path.of(\"context-values.jfr\"));\n+\n+            PrintedEvent e0 = events.get(0);\n+            assertName(e0, \"jdk.SystemGC\");\n+            assertContextValue(e0, \"Span.name\", \"span\");\n+            assertContextValue(e0, \"Span.spanId\", \"4711\");\n+\n+            PrintedEvent e1 = events.get(1);\n+            assertName(e1, \"Span\");\n+            assertMissingContextValues(e1);\n+\n+            PrintedEvent e2 = events.get(2);\n+            assertName(e2, \"jdk.SystemGC\");\n+            assertContextValue(e2, \"Trace.name\", \"trace\");\n+            assertMissingContextValue(e2, \"Trace.traceId\");\n+\n+            PrintedEvent e3 = events.get(3);\n+            assertName(e3, \"Trace\");\n+            assertMissingContextValues(e3);\n+        }\n+    }\n+\n+    \/\/ Tests that two contexts can interleave and injection still works\n+    private static void testInterleaved() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Trace\").withoutStackTrace();\n+            r.enable(\"Span\").withoutStackTrace();\n+            r.enable(\"jdk.SystemGC\").withoutStackTrace();\n+            r.start();\n+\n+            System.gc(); \/\/ Event 0\n+            SpanEvent span = new SpanEvent();\n+            span.name = \"span\";\n+            span.spanId = 56;\n+            span.begin();\n+            System.gc(); \/\/ Event 1\n+            TraceEvent trace = new TraceEvent();\n+            trace.name = \"trace\";\n+            trace.traceId = 58;\n+            trace.begin();\n+            System.gc(); \/\/ Event 2\n+            span.commit(); \/\/ Event 3\n+            System.gc(); \/\/ Event 4\n+            trace.commit(); \/\/ Event 5\n+            System.gc(); \/\/ Event 6\n+\n+            r.stop();\n+\n+            List<PrintedEvent> events = dumpPrintedEvents(r, Path.of(\"interleaved.jfr\"));\n+\n+            PrintedEvent e0 = events.get(0);\n+            assertName(e0, \"jdk.SystemGC\");\n+            assertMissingContextValues(e0);\n+\n+            PrintedEvent e1 = events.get(1);\n+            assertName(e1, \"jdk.SystemGC\");\n+            assertContextValue(e1, \"Span.name\", \"span\");\n+            assertContextValue(e1, \"Span.spanId\", \"56\");\n+            assertMissingContextValue(e1, \"trace.name\");\n+\n+            PrintedEvent e2 = events.get(2);\n+            assertName(e2, \"jdk.SystemGC\");\n+            assertContextValue(e2, \"Span.name\", \"span\");\n+            assertContextValue(e2, \"Span.spanId\", \"56\");\n+            assertContextValue(e2, \"Trace.name\", \"trace\");\n+\n+            PrintedEvent e3 = events.get(3);\n+            assertName(e3, \"Span\");\n+\n+            PrintedEvent e4 = events.get(4);\n+            assertName(e4, \"jdk.SystemGC\");\n+            assertMissingContextValue(e4, \"Span.name\");\n+            assertMissingContextValue(e4, \"Span.spanId\");\n+            assertContextValue(e4, \"Trace.name\", \"trace\");\n+\n+            PrintedEvent e5 = events.get(5);\n+            assertName(e5, \"Trace\");\n+\n+            PrintedEvent e6 = events.get(6);\n+            assertName(e6, \"jdk.SystemGC\");\n+            assertMissingContextValues(e6);\n+        }\n+    }\n+\n+    \/\/ Tests hundred nested contexts in one event\n+    private static void testDeepContext() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Trace\").withoutStackTrace();\n+            r.enable(\"Span\").withoutStackTrace();\n+            r.enable(\"jdk.SystemGC\").withoutStackTrace();\n+            r.start();\n+            TraceEvent trace = new TraceEvent();\n+            trace.name = \"trace\";\n+            trace.traceId = 58;\n+            trace.begin();\n+            span(99);\n+            trace.commit();\n+            r.stop();\n+            List<PrintedEvent> events = dumpPrintedEvents(r, Path.of(\"deep-context.jfr\"));\n+\n+            PrintedEvent e0 = events.get(0);\n+            assertName(e0, \"jdk.SystemGC\");\n+            int counter = 100;\n+            for (var e : e0.getContextValues()) {\n+                String key = e.getKey();\n+                String value = e.getValue();\n+                if (counter == 100) {\n+                    if (!key.equals(\"Trace.name\")) {\n+                        throw new Exception(\"Expected trace context to be printed first, but name was \" + key);\n+                    }\n+                    if (\"name\".equals(value)) {\n+                        throw new Exception(\"Expected trace context name to be 'trace', but was \" + value);\n+                    }\n+                    counter--;\n+                    continue;\n+                }\n+                if (key.equals(\"Span.spanId\")) {\n+                    if (!String.valueOf(counter).equals(value)) {\n+                        throw new Exception(\"Expected spanId to be \" + counter + \", but was \" + value);\n+                    }\n+                    counter--;\n+                    continue;\n+                }\n+                if (!key.equals(\"Span.name\")) {\n+                    throw new Exception(\"Expected span context name, but was \" + key);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void span(int depth) {\n+        SpanEvent span = new SpanEvent();\n+        span.name = \"span\";\n+        span.spanId = depth;\n+        span.begin();\n+        if (depth == 0) {\n+            System.gc();\n+            return;\n+        }\n+        span(depth - 1);\n+        span.commit();\n+    }\n+\n+    \/\/ Tests that context values are only inhjected into events in the same thread.\n+    private static void testThreadedContext() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Trace\").withoutStackTrace();\n+            r.enable(\"jdk.SystemGC\").withoutStackTrace();\n+            r.start();\n+            TraceEvent trace = new TraceEvent();\n+            trace.name = \"trace\";\n+            trace.traceId = 42;\n+            trace.begin();\n+            Thread t = Thread.ofPlatform().name(\"not-main\").start(() -> {\n+                System.gc();\n+            });\n+            t.join();\n+            System.gc();\n+            trace.commit();\n+            r.stop();\n+\n+            List<PrintedEvent> events = dumpPrintedEvents(r, Path.of(\"threaded-context.jfr\"));\n+\n+            PrintedEvent e0 = events.get(0);\n+            assertName(e0, \"jdk.SystemGC\");\n+            assertMissingContextValues(e0);\n+\n+            PrintedEvent e1 = events.get(1);\n+            assertName(e1, \"jdk.SystemGC\");\n+            assertContextValue(e1, \"Trace.name\", \"trace\");\n+\n+            PrintedEvent e2 = events.get(2);\n+            assertName(e2, \"Trace\");\n+            assertMissingContextValues(e2);\n+        }\n+    }\n+\n+    \/\/ Tests that context values are injected when context events are filtered out\n+    private static void testFiltered() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Trace\").withoutStackTrace();\n+            r.enable(\"jdk.SystemGC\").withoutStackTrace();\n+            r.start();\n+\n+            TraceEvent trace = new TraceEvent();\n+            trace.name = \"trace\";\n+            trace.traceId = 22;\n+            trace.begin();\n+            SpanEvent span = new SpanEvent();\n+            span.spanId = 11;\n+            span.name = \"span\";\n+            span.begin();\n+\n+            System.gc();\n+\n+            span.commit();\n+            trace.commit();\n+\n+            r.stop();\n+            Path file = Path.of(\"filtered.jfr\");\n+            r.dump(file);\n+            List<PrintedEvent> events = parseEvents(readPrintedLines(file, \"--events\", \"jdk.SystemGC\"));\n+            if (events.size() != 1) {\n+                throw new Exception(\"Only expected one event\");\n+            }\n+            PrintedEvent e0 = events.get(0);\n+            assertName(e0, \"jdk.SystemGC\");\n+            assertContextValue(e0, \"Trace.name\", \"trace\");\n+            assertContextValue(e0, \"Span.name\", \"span\");\n+            assertContextValue(e0, \"Span.spanId\", \"11\");\n+        }\n+    }\n+\n+    private static void assertName(PrintedEvent event, String name) throws Exception {\n+        if (!event.name.equals(name)) {\n+            throw new Exception(\"Expected event name \" + name + \", but was \" + event.name);\n+        }\n+    }\n+\n+    private static void assertContextValue(PrintedEvent event, String field, String expectedValue) throws Exception {\n+        String value = event.getContextValue(field);\n+        if (value == null) {\n+            throw new Exception(\"No value found for field \" + field + \" in event \" + event.name);\n+        }\n+        if (!expectedValue.equals(value)) {\n+            throw new Exception(\"Expected context value \" + expectedValue + \" for \" + field + \", it was \" + value);\n+        }\n+    }\n+\n+    private static void assertMissingContextValue(PrintedEvent event, String field) throws Exception {\n+        if (event.getContextValue(field) != null) {\n+            throw new Exception(\"Didn't expect to find context field \" + field);\n+        }\n+    }\n+\n+    private static void assertMissingContextValues(PrintedEvent event) throws Exception {\n+        if (!event.contextValues.isEmpty()) {\n+            throw new Exception(\"Didn't expect context values in event \" + event.name);\n+        }\n+    }\n+\n+    private static List<PrintedEvent> dumpPrintedEvents(Recording r, Path file) throws Exception {\n+        r.dump(file);\n+        return parseEvents(readPrintedLines(file));\n+    }\n+\n+    private static List<PrintedEvent> parseEvents(List<String> lines) {\n+        List<PrintedEvent> events = new ArrayList<>();\n+        PrintedEvent pe = null;\n+        for (String line : lines) {\n+            if (line.endsWith(\"{\")) {\n+                String[] texts = line.split(\" \");\n+                pe = new PrintedEvent(texts[0]);\n+                events.add(pe);\n+            } else if (line.startsWith(\"}\")) {\n+                pe = null;\n+            } else if (pe != null) {\n+                int index = line.indexOf(\"=\");\n+                String field = line.substring(0, index).trim();\n+                String value = line.substring(index + 1).trim();\n+                if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n+                    value = value.substring(1, value.length() - 1);\n+                }\n+                if (field.startsWith(CONTEXT_MARKER)) {\n+                    pe.addContextValue(field.substring(CONTEXT_MARKER.length()), value);\n+                } else {\n+                    pe.addValue(field, value);\n+                }\n+            }\n+        }\n+        return events;\n+    }\n+\n+    private static List<String> readPrintedLines(Path file, String... options) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jfr\");\n+        launcher.addToolArg(\"print\");\n+        for (String option : options) {\n+            launcher.addToolArg(option);\n+        }\n+        launcher.addToolArg(file.toAbsolutePath().toString());\n+        OutputAnalyzer output = ProcessTools.executeCommand(launcher.getCommand());\n+        return output.asLines();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestPrintContextual.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"}]}