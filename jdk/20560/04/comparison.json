{"files":[{"patch":"@@ -434,1 +434,1 @@\n-\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen).\n+\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, size_t buflen).\n@@ -437,1 +437,1 @@\n-void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, int utf8_length) {\n+void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length) {\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  static void put_utf8(outputStream* st, const char* utf8_string, int utf8_length);\n+  static void put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,2 @@\n-    char* expected = UNICODE::as_utf8(unicode, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    char* expected = UNICODE::as_utf8(unicode, utf8_len);\n@@ -349,1 +350,1 @@\n-  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), false)) {\n@@ -557,1 +558,1 @@\n-  int result_length;\n+  size_t result_length;\n@@ -569,2 +570,2 @@\n-  assert(result_length >= length + 1, \"must not be shorter\");\n-  assert(result_length == (int)strlen(result) + 1, \"must match\");\n+  assert(result_length >= (size_t)length + 1, \"must not be shorter\");\n+  assert(result_length == strlen(result) + 1, \"must match\");\n@@ -585,2 +586,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    Symbol* sym = SymbolTable::new_symbol(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    Symbol* sym = SymbolTable::new_symbol(base, checked_cast<int>(utf8_len));\n@@ -601,2 +603,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    return SymbolTable::probe(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    return SymbolTable::probe(base, checked_cast<int>(utf8_len));\n@@ -606,1 +609,1 @@\n-int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n+size_t java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n@@ -620,1 +623,1 @@\n-int java_lang_String::utf8_length(oop java_string) {\n+size_t java_lang_String::utf8_length(oop java_string) {\n@@ -625,0 +628,19 @@\n+int java_lang_String::utf8_length_as_int(oop java_string) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  return utf8_length_as_int(java_string, value);\n+}\n+\n+int java_lang_String::utf8_length_as_int(oop java_string, typeArrayOop value) {\n+  assert(value_equals(value, java_lang_String::value(java_string)),\n+         \"value must be same as java_lang_String::value(java_string)\");\n+  int length = java_lang_String::length(java_string, value);\n+  if (length == 0) {\n+    return 0;\n+  }\n+  if (!java_lang_String::is_latin1(java_string)) {\n+    return UNICODE::utf8_length_as_int(value->char_at_addr(0), length);\n+  } else {\n+    return UNICODE::utf8_length_as_int(value->byte_at_addr(0), length);\n+  }\n+}\n+\n@@ -626,1 +648,1 @@\n-  int length;\n+  size_t length;\n@@ -630,1 +652,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, int& length) {\n+char* java_lang_String::as_utf8_string(oop java_string, size_t& length) {\n@@ -632,0 +654,2 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n@@ -645,1 +669,1 @@\n-char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {\n+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& utf8_len) {\n@@ -666,1 +690,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen) {\n@@ -680,1 +704,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, char* buf, size_t buflen) {\n@@ -686,0 +710,3 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n+  size_t  length = static_cast<size_t>(len);\n@@ -691,1 +718,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -694,1 +721,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -698,1 +725,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -134,2 +134,5 @@\n-  static int utf8_length(oop java_string);\n-  static int utf8_length(oop java_string, typeArrayOop string_value);\n+  static size_t utf8_length(oop java_string);\n+  static size_t utf8_length(oop java_string, typeArrayOop string_value);\n+  \/\/ Legacy variants that truncate the length if needed\n+  static int    utf8_length_as_int(oop java_string);\n+  static int    utf8_length_as_int(oop java_string, typeArrayOop string_value);\n@@ -139,3 +142,4 @@\n-  static char*  as_utf8_string(oop java_string, int& length);\n-  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);\n-  static char*  as_utf8_string(oop java_string, char* buf, int buflen);\n+  \/\/ `length` is set to the length of the utf8 sequence.\n+  static char*  as_utf8_string(oop java_string, size_t& length);\n+  static char*  as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& length);\n+  static char*  as_utf8_string(oop java_string, char* buf, size_t buflen);\n@@ -143,2 +147,2 @@\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-  char* module_name = java_lang_String::as_utf8_string(name_oop, len);\n+  size_t utf8_len;\n+  char* module_name = java_lang_String::as_utf8_string(name_oop, utf8_len);\n+  len = checked_cast<int>(utf8_len); \/\/ module names are < 64K\n@@ -87,1 +89,1 @@\n-  int len;\n+  size_t len;\n@@ -89,1 +91,1 @@\n-  return SymbolTable::new_symbol(str, len);\n+  return SymbolTable::new_symbol(str, checked_cast<int>(len));\n@@ -145,2 +147,4 @@\n-static const char* as_internal_package(oop package_string, char* buf, int buflen, int& utf8_len) {\n-  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, utf8_len);\n+static const char* as_internal_package(oop package_string, char* buf, size_t buflen, int& utf8_len) {\n+  size_t full_utf8_len;\n+  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, full_utf8_len);\n+  utf8_len = checked_cast<int>(full_utf8_len); \/\/ package names are < 64K\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-    int utf8_length = length;\n+    size_t utf8_length = length;\n@@ -700,1 +700,1 @@\n-    st->print(\"%d: \", utf8_length);\n+    st->print(\"%zu: \", utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -466,1 +466,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -469,1 +469,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -474,1 +474,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -480,1 +480,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -482,1 +482,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -485,1 +485,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n@@ -490,1 +490,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-    const size_t length = static_cast<size_t>(java_lang_String::utf8_length(string, value)) + 1;\n+    const size_t length = java_lang_String::utf8_length(string, value) + 1;\n@@ -298,1 +298,1 @@\n-    java_lang_String::as_utf8_string(string, value, str, static_cast<int>(length));\n+    java_lang_String::as_utf8_string(string, value, str, length);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -505,1 +505,1 @@\n-static char* allocate_string(bool c_heap, int length, Thread* thread) {\n+static char* allocate_string(bool c_heap, size_t length, Thread* thread) {\n@@ -514,1 +514,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,4 @@\n-  return name != nullptr ? java_lang_String::as_utf8_string(name, length) : nullptr;\n+  size_t utf8_len;\n+  const char* ret = name != nullptr ? java_lang_String::as_utf8_string(name, utf8_len) : nullptr;\n+  length = checked_cast<int>(utf8_len); \/\/ Thread names should be short\n+  return ret;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  int quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n+  size_t quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2226,1 +2226,1 @@\n-  jsize ret = java_lang_String::utf8_length(java_string);\n+  jsize ret = java_lang_String::utf8_length_as_int(java_string);\n@@ -2239,1 +2239,2 @@\n-    \/* JNI Specification states return null on OOM *\/\n+    \/\/ JNI Specification states return null on OOM.\n+    \/\/ The resulting sequence doesn't have to be NUL-terminated but we do.\n@@ -2242,1 +2243,1 @@\n-      java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);\n+      java_lang_String::as_utf8_string(java_string, s_value, result, length + 1);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-      int utf8_length = 0;\n+      size_t utf8_length = 0;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-\/\/ Count bytes of the form 10xxxxxx and deduct this count\n+\/\/ The number of unicode characters in a utf8 sequence can be easily\n+\/\/ determined by noting that bytes of the form 10xxxxxx are part of\n+\/\/ a 2 or 3-byte multi-byte sequence, all others are either characters\n+\/\/ themselves or else the start of a multi-byte character.\n+\n+\/\/ Calculate the unicode length of a utf8 string of known size\n+\/\/ by counting bytes of the form 10xxxxxx and deducting this count\n@@ -104,2 +110,2 @@\n-int UTF8::unicode_length(const char* str, int len, bool& is_latin1, bool& has_multibyte) {\n-  int num_chars = len;\n+int UTF8::unicode_length(const char* str, size_t len, bool& is_latin1, bool& has_multibyte) {\n+  size_t num_chars = len;\n@@ -109,1 +115,1 @@\n-  for (int i = 0; i < len; i++) {\n+  for (size_t i = 0; i < len; i++) {\n@@ -121,1 +127,1 @@\n-  return num_chars;\n+  return checked_cast<int>(num_chars);\n@@ -124,3 +130,3 @@\n-\/\/ Count bytes of the utf8 string except those in form\n-\/\/ 10xxxxxx which only appear in multibyte characters.\n-\/\/ The utf8 string must be in legal form and has been\n+\/\/ Calculate the unicode length of a nul-terminated utf8 string\n+\/\/ by counting bytes of the utf8 string except those in the form\n+\/\/ 10xxxxxx. The utf8 string must be in legal form and has been\n@@ -198,1 +204,1 @@\n-int UTF8::quoted_ascii_length(const char* utf8_str, int utf8_length) {\n+size_t UTF8::quoted_ascii_length(const char* utf8_str, size_t utf8_length) {\n@@ -201,1 +207,1 @@\n-  int result = 0;\n+  size_t result = 0;\n@@ -215,1 +221,1 @@\n-void UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen) {\n+void UTF8::as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen) {\n@@ -251,1 +257,1 @@\n-  int length = ptr - quoted_ascii_str;\n+  size_t length = ptr - quoted_ascii_str;\n@@ -333,1 +339,1 @@\n-bool UTF8::is_legal_utf8(const unsigned char* buffer, int length,\n+bool UTF8::is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -335,3 +341,3 @@\n-  int i = 0;\n-  int count = length >> 2;\n-  for (int k=0; k<count; k++) {\n+  size_t i = 0;\n+  size_t count = length >> 2;\n+  for (size_t k = 0; k < count; k++) {\n@@ -408,1 +414,1 @@\n-void UTF8::truncate_to_legal_utf8(unsigned char* buffer, int length) {\n+void UTF8::truncate_to_legal_utf8(unsigned char* buffer, size_t length) {\n@@ -436,1 +442,1 @@\n-  for (int index = length - 2; index > 0; index--) {\n+  for (size_t index = length - 2; index > 0; index--) {\n@@ -444,1 +450,1 @@\n-        if ((index - 3) >= 0 &&\n+        if (index >= 3 &&\n@@ -473,1 +479,1 @@\n-int UNICODE::utf8_size(jchar c) {\n+size_t UNICODE::utf8_size(jchar c) {\n@@ -484,1 +490,1 @@\n-int UNICODE::utf8_size(jbyte c) {\n+size_t UNICODE::utf8_size(jbyte c) {\n@@ -497,1 +503,10 @@\n-int UNICODE::utf8_length(const T* base, int length) {\n+size_t UNICODE::utf8_length(const T* base, int length) {\n+  size_t result = 0;\n+  for (int index = 0; index < length; index++) {\n+    result += utf8_size(base[index]);\n+  }\n+  return result;\n+}\n+\n+template<typename T>\n+int UNICODE::utf8_length_as_int(const T* base, int length) {\n@@ -501,1 +516,4 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    \/\/ If the length is > INT_MAX-1 we truncate at a completed\n+    \/\/ modified-UTF8 encoding. This allows for +1 to be added\n+    \/\/ by the caller for NUL-termination, without overflow.\n@@ -511,2 +529,3 @@\n-char* UNICODE::as_utf8(const T* base, int& length) {\n-  int utf8_len = utf8_length(base, length);\n+char* UNICODE::as_utf8(const T* base, size_t& length) {\n+  \/\/ Incoming length must be <= INT_MAX\n+  size_t utf8_len = utf8_length(base, static_cast<int>(length));\n@@ -514,3 +533,3 @@\n-  char* result = as_utf8(base, length, (char*) buf, utf8_len + 1);\n-  assert((int) strlen(result) == utf8_len, \"length prediction must be correct\");\n-  \/\/ Set string length to uft8 length\n+  char* result = as_utf8(base, static_cast<int>(length), (char*) buf, utf8_len + 1);\n+  assert(strlen(result) == utf8_len, \"length prediction must be correct\");\n+  \/\/ Set outgoing string length to uft8 length\n@@ -521,1 +540,1 @@\n-char* UNICODE::as_utf8(const jchar* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jchar* base, int length, char* buf, size_t buflen) {\n@@ -526,2 +545,3 @@\n-    buflen -= utf8_size(c);\n-    if (buflen <= 0) break; \/\/ string is truncated\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n+    buflen -= sz;\n@@ -534,1 +554,1 @@\n-char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, size_t buflen) {\n@@ -539,1 +559,2 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n@@ -541,1 +562,0 @@\n-    if (buflen <= 0) break; \/\/ string is truncated\n@@ -546,0 +566,1 @@\n+      assert(sz == 2, \"must be!\");\n@@ -564,2 +585,2 @@\n-int UNICODE::quoted_ascii_length(const T* base, int length) {\n-  int result = 0;\n+size_t UNICODE::quoted_ascii_length(const T* base, int length) {\n+  size_t result = 0;\n@@ -579,1 +600,1 @@\n-void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, int buflen) {\n+void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, size_t buflen) {\n@@ -597,8 +618,10 @@\n-template int UNICODE::utf8_length(const jbyte* base, int length);\n-template int UNICODE::utf8_length(const jchar* base, int length);\n-template char* UNICODE::as_utf8(const jbyte* base, int& length);\n-template char* UNICODE::as_utf8(const jchar* base, int& length);\n-template int UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n-template int UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n-template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, int buflen);\n-template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, int buflen);\n+template size_t UNICODE::utf8_length(const jbyte* base, int length);\n+template size_t UNICODE::utf8_length(const jchar* base, int length);\n+template int UNICODE::utf8_length_as_int(const jbyte* base, int length);\n+template int UNICODE::utf8_length_as_int(const jchar* base, int length);\n+template char* UNICODE::as_utf8(const jbyte* base, size_t& length);\n+template char* UNICODE::as_utf8(const jchar* base, size_t& length);\n+template size_t UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n+template size_t UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n+template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, size_t buflen);\n+template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":68,"deletions":45,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,0 +32,39 @@\n+\/**\n+\n+String handling within Java and the VM requires a bit of explanation.\n+\n+Logically a java.lang.String is a sequence of 16-bit Unicode characters\n+encoded in UTF-16. In the past a String contained a Java char[] and so\n+could theoretically contain INT_MAX 16-bit characters. Then came JEP 254:\n+Compact Strings.\n+\n+With Compact Strings the Java char[] becomes a Java byte[], and that byte[]\n+contains either latin-1 characters all of which fit in 8-bits, or else each\n+pair of bytes represents a UTF-16 character. Consequently the maximum length\n+in characters of a latin-1 string is INT_MAX, whilst for non-latin-1 it is INT_MAX\/2.\n+\n+In the code below if we have latin-1 content then we treat the String's data\n+array as a jbyte[], else a jchar[]. The lengths of these arrays are specified\n+as an int value, with a nominal maximum of INT_MAX.\n+\n+The modified UTF-8 encoding specified for the VM, nominally encodes characters\n+in 1, 2, 3 or 6 bytes. The 6-byte representation is actually two 3-byte representations\n+for two UTF-16 characters forming a surrogate pair. If we are dealing with\n+a latin-1 string then each character will be encoded as either 1 or 2 bytes and so the\n+maximum UTF8 length is 2*INT_MAX. This can't be stored in an int so utf8 buffers must\n+use a size_t length. For non-latin-1 strings each UTF-16 character will encode as either\n+2 or 3 bytes, so the maximum UTF8 length in that case is 3 * INT_MAX\/2 i.e. 1.5*INT_MAX.\n+\n+The \"quoted ascii\" form of a unicode string is at worst 6 times longer than its\n+regular form, and so these lengths must always be size_t - though if we know we only\n+ever do this to symbols (or small symbol combinations) then we could use int.\n+\n+There is an additional assumption\/expectation that our UTF8 API's are never dealing with\n+invalid UTF8, and more generally that all UTF8 sequences could form valid Strings.\n+Consequently the Unicode length of a UTF8 sequence is assumed to always be representable\n+by an int. However, there are API's, such as JNI NewStringUTF, that do deal with such input\n+and could potentially have an unrepresentable string. The long standing position with JNI\n+is that the user must supply valid input so we do not try to account for these cases.\n+\n+*\/\n+\n@@ -44,1 +83,1 @@\n-  static int unicode_length(const char* utf8_str, int len) {\n+  static int unicode_length(const char* utf8_str, size_t len) {\n@@ -48,1 +87,1 @@\n-  static int unicode_length(const char* utf8_str, int len, bool& is_latin1, bool& has_multibyte);\n+  static int unicode_length(const char* utf8_str, size_t len, bool& is_latin1, bool& has_multibyte);\n@@ -54,1 +93,1 @@\n-  static int quoted_ascii_length(const char* utf8_str, int utf8_length);\n+  static size_t quoted_ascii_length(const char* utf8_str, size_t utf8_length);\n@@ -57,1 +96,1 @@\n-  static void as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen);\n+  static void as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen);\n@@ -85,1 +124,1 @@\n-  static bool   equal(const jbyte* base1, int length1, const jbyte* base2,int length2);\n+  static bool   equal(const jbyte* base1, int length1, const jbyte* base2, int length2);\n@@ -89,1 +128,1 @@\n-  static bool   is_legal_utf8(const unsigned char* buffer, int length,\n+  static bool   is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -91,1 +130,1 @@\n-  static void   truncate_to_legal_utf8(unsigned char* buffer, int length);\n+  static void   truncate_to_legal_utf8(unsigned char* buffer, size_t length);\n@@ -102,0 +141,6 @@\n+\n+  \/\/ returns the utf8 size of a unicode character\n+  \/\/ uses size_t for convenience in overflow checks\n+  static size_t utf8_size(jchar c);\n+  static size_t utf8_size(jbyte c);\n+\n@@ -109,4 +154,0 @@\n-  \/\/ returns the utf8 size of a unicode character\n-  static int utf8_size(jchar c);\n-  static int utf8_size(jbyte c);\n-\n@@ -114,1 +155,4 @@\n-  template<typename T> static int utf8_length(const T* base, int length);\n+  template<typename T> static size_t utf8_length(const T* base, int length);\n+\n+  \/\/ returns the utf8 length of a unicode string as an int - truncated if needed\n+  template<typename T> static int utf8_length_as_int(const T* base, int length);\n@@ -121,4 +165,4 @@\n-  \/\/ parameter is set to the length of the result utf8 string.\n-  template<typename T> static char* as_utf8(const T* base, int& length);\n-  static char* as_utf8(const jchar* base, int length, char* buf, int buflen);\n-  static char* as_utf8(const jbyte* base, int length, char* buf, int buflen);\n+  \/\/ parameter is set to the length of the resulting utf8 string.\n+  template<typename T> static char* as_utf8(const T* base, size_t& length);\n+  static char* as_utf8(const jchar* base, int length, char* buf, size_t buflen);\n+  static char* as_utf8(const jbyte* base, int length, char* buf, size_t buflen);\n@@ -127,1 +171,1 @@\n-  template<typename T> static int quoted_ascii_length(const T* base, int length);\n+  template<typename T> static size_t quoted_ascii_length(const T* base, int length);\n@@ -130,1 +174,1 @@\n-  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, int buflen);\n+  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"}]}