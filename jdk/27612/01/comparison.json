{"files":[{"patch":"@@ -231,1 +231,1 @@\n-    _available[partition_id] = FreeSetUnderConstruction;\n+    _available[partition_id] = 0;\n@@ -1628,0 +1628,2 @@\n+  assert(rebuild_lock() != nullptr, \"sanity\");\n+  rebuild_lock()->lock(false);\n@@ -1684,0 +1686,4 @@\n+\n+  \/\/ Release the rebuild lock now.  What remains in this function is read-only\n+  rebuild_lock()->unlock();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahLock.hpp\"\n@@ -33,0 +34,3 @@\n+typedef ShenandoahLock    ShenandoahRebuildLock;\n+typedef ShenandoahLocker  ShenandoahRebuildLocker;\n+\n@@ -112,2 +116,0 @@\n-  static const size_t FreeSetUnderConstruction = SIZE_MAX;\n-\n@@ -234,4 +236,6 @@\n-  \/\/ Return available_in assuming caller does not hold the heap lock.  In production builds, available is\n-  \/\/ returned without acquiring the lock.  In debug builds, the global heap lock is acquired in order to\n-  \/\/ enforce a consistency assert.\n-  inline size_t available_in_not_locked(ShenandoahFreeSetPartitionId which_partition) const {\n+  \/\/ Return available_in assuming caller does not hold the heap lock but does hold the rebuild_lock.\n+  \/\/ The returned value may be \"slightly stale\" because we do not assure that every fetch of this value\n+  \/\/ sees the most recent update of this value.  Requiring the caller to hold the rebuild_lock assures\n+  \/\/ that we don't see \"bogus\" values that are \"worse than stale\".  During rebuild of the freeset, the\n+  \/\/ value of _available is not reliable.\n+  inline size_t available_in_locked_for_rebuild(ShenandoahFreeSetPartitionId which_partition) const {\n@@ -239,9 +243,0 @@\n-    shenandoah_assert_not_heaplocked();\n-#ifdef ASSERT\n-    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n-    assert((_available[int(which_partition)] == FreeSetUnderConstruction) ||\n-           (_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)]),\n-           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n-           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n-           partition_membership_name(ssize_t(which_partition)));\n-#endif\n@@ -319,0 +314,9 @@\n+  \/\/ This locks the rebuild process (in combination with the global heap lock).  Whenever we rebuild the free set,\n+  \/\/ we first acquire the global heap lock and then we acquire this _rebuild_lock in a nested context.  Threads that\n+  \/\/ need to check available, acquire only the _rebuild_lock to make sure that they are not obtaining the value of\n+  \/\/ available for a partially reconstructed free-set.\n+  \/\/\n+  \/\/ Note that there is rank ordering of nested locks to prevent deadlock.  All threads that need to acquire both\n+  \/\/ locks will acquire them in the same order: first the global heap lock and then the rebuild lock.\n+  ShenandoahRebuildLock _rebuild_lock;\n+\n@@ -414,2 +418,0 @@\n-  static const size_t FreeSetUnderConstruction = ShenandoahRegionPartitions::FreeSetUnderConstruction;\n-\n@@ -418,0 +420,4 @@\n+  ShenandoahRebuildLock* rebuild_lock() {\n+    return &_rebuild_lock;\n+  }\n+\n@@ -483,1 +489,5 @@\n-  inline size_t available() const { return _partitions.available_in_not_locked(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t available() {\n+    shenandoah_assert_not_heaplocked();\n+    ShenandoahRebuildLocker locker(rebuild_lock());\n+    return _partitions.available_in_locked_for_rebuild(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1156,8 +1156,10 @@\n-    size_t young_cset_regions, old_cset_regions;\n-    size_t first_old, last_old, num_old;\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n-\n-    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n-    \/\/ no longer have objects separated by age into distinct regions.\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGenerationalFullGC::compute_balances();\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    ShenandoahFreeSet* free_set = heap->free_set();\n+    {\n+      free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+      \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+      \/\/ no longer have objects separated by age into distinct regions.\n+      if (heap->mode()->is_generational()) {\n+        ShenandoahGenerationalFullGC::compute_balances();\n+      }\n+      free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n@@ -1165,3 +1167,0 @@\n-\n-    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -748,0 +748,1 @@\n+    ShenandoahFreeSet* free_set = heap->free_set();\n@@ -749,1 +750,0 @@\n-    size_t young_cset_regions, old_cset_regions;\n@@ -752,2 +752,2 @@\n-    size_t first_old, last_old, num_old;\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n@@ -755,1 +755,1 @@\n-    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old, true);\n+    free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old, true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -423,2 +423,0 @@\n-    size_t young_cset_regions, old_cset_regions;\n-\n@@ -426,1 +424,1 @@\n-    size_t first_old, last_old, num_old;\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n@@ -2578,2 +2576,1 @@\n-  size_t young_cset_regions, old_cset_regions;\n-  size_t first_old_region, last_old_region, old_region_count;\n+  size_t young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count;\n@@ -2598,1 +2595,2 @@\n-    size_t allocation_runway = gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    size_t allocation_runway =\n+      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n@@ -2603,2 +2601,2 @@\n-    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.  Fragmentation\n-    \/\/ will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n+    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.\n+    \/\/ Fragmentation will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  assert(free_actual != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+    ShenandoahFreeSet* free_set = heap->free_set();\n@@ -513,6 +514,5 @@\n-    size_t cset_young_regions, cset_old_regions;\n-    size_t first_old, last_old, num_old;\n-    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions, first_old, last_old, num_old);\n-    \/\/ This is just old-gen completion.  No future budgeting required here.  The only reason to rebuild the freeset here\n-    \/\/ is in case there was any immediate old garbage identified.\n-    heap->free_set()->finish_rebuild(cset_young_regions, cset_old_regions, num_old);\n+    size_t cset_young_regions, cset_old_regions, first_old, last_old, num_old;\n+    free_set->prepare_to_rebuild(cset_young_regions, cset_old_regions, first_old, last_old, num_old);\n+    \/\/ This is completion of old-gen marking.  We rebuild in order to reclaim immediate garbage and to\n+    \/\/ prepare for subsequent mixed evacuations.\n+    free_set->finish_rebuild(cset_young_regions, cset_old_regions, num_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}