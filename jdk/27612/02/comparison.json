{"files":[{"patch":"@@ -342,1 +342,1 @@\n-    _available[partition_id] = FreeSetUnderConstruction;\n+    _available[partition_id] = 0;\n@@ -2628,0 +2628,4 @@\n+  assert(rebuild_lock() != nullptr, \"sanity\");\n+  rebuild_lock()->lock(false);\n+  \/\/ This resets all state information, removing all regions from all sets.\n+  clear();\n@@ -2657,0 +2661,3 @@\n+\n+  \/\/ Release the rebuild lock now.  What remains in this function is read-only\n+  rebuild_lock()->unlock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahLock.hpp\"\n@@ -33,0 +34,3 @@\n+typedef ShenandoahLock    ShenandoahRebuildLock;\n+typedef ShenandoahLocker  ShenandoahRebuildLocker;\n+\n@@ -144,2 +148,0 @@\n-  static const size_t FreeSetUnderConstruction = SIZE_MAX;\n-\n@@ -357,0 +359,10 @@\n+  \/\/ Return available_in assuming caller does not hold the heap lock but does hold the rebuild_lock.\n+  \/\/ The returned value may be \"slightly stale\" because we do not assure that every fetch of this value\n+  \/\/ sees the most recent update of this value.  Requiring the caller to hold the rebuild_lock assures\n+  \/\/ that we don't see \"bogus\" values that are \"worse than stale\".  During rebuild of the freeset, the\n+  \/\/ value of _available is not reliable.\n+  inline size_t available_in_locked_for_rebuild(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _available[int(which_partition)];\n+  }\n+\n@@ -364,17 +376,0 @@\n-  \/\/ Return available_in assuming caller does not hold the heap lock.  In production builds, available is\n-  \/\/ returned without acquiring the lock.  In debug builds, the global heap lock is acquired in order to\n-  \/\/ enforce a consistency assert.\n-  inline size_t available_in_not_locked(ShenandoahFreeSetPartitionId which_partition) const {\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    shenandoah_assert_not_heaplocked();\n-#ifdef ASSERT\n-    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n-    assert((_available[int(which_partition)] == FreeSetUnderConstruction) ||\n-           (_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)]),\n-           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n-           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n-           partition_membership_name(idx_t(which_partition)));\n-#endif\n-    return _available[int(which_partition)];\n-  }\n-\n@@ -445,0 +440,9 @@\n+  \/\/ This locks the rebuild process (in combination with the global heap lock).  Whenever we rebuild the free set,\n+  \/\/ we first acquire the global heap lock and then we acquire this _rebuild_lock in a nested context.  Threads that\n+  \/\/ need to check available, acquire only the _rebuild_lock to make sure that they are not obtaining the value of\n+  \/\/ available for a partially reconstructed free-set.\n+  \/\/\n+  \/\/ Note that there is rank ordering of nested locks to prevent deadlock.  All threads that need to acquire both\n+  \/\/ locks will acquire them in the same order: first the global heap lock and then the rebuild lock.\n+  ShenandoahRebuildLock _rebuild_lock;\n+\n@@ -639,2 +643,0 @@\n-  static const size_t FreeSetUnderConstruction = ShenandoahRegionPartitions::FreeSetUnderConstruction;\n-\n@@ -643,0 +645,4 @@\n+  ShenandoahRebuildLock* rebuild_lock() {\n+    return &_rebuild_lock;\n+  }\n+\n@@ -782,1 +788,5 @@\n-  inline size_t available() const { return _partitions.available_in_not_locked(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t available() {\n+    shenandoah_assert_not_heaplocked();\n+    ShenandoahRebuildLocker locker(rebuild_lock());\n+    return _partitions.available_in_locked_for_rebuild(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1116,8 +1116,10 @@\n-    size_t young_cset_regions, old_cset_regions;\n-    size_t first_old, last_old, num_old;\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n-\n-    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n-    \/\/ no longer have objects separated by age into distinct regions.\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGenerationalFullGC::compute_balances();\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    ShenandoahFreeSet* free_set = heap->free_set();\n+    {\n+      free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+      \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+      \/\/ no longer have objects separated by age into distinct regions.\n+      if (heap->mode()->is_generational()) {\n+        ShenandoahGenerationalFullGC::compute_balances();\n+      }\n+      free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n@@ -1125,3 +1127,0 @@\n-\n-    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -816,1 +816,0 @@\n-    size_t young_cset_regions, old_cset_regions;\n@@ -819,1 +818,1 @@\n-    size_t first_old, last_old, num_old;\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -429,2 +429,0 @@\n-\n-\n@@ -2523,2 +2521,1 @@\n-  size_t young_cset_regions, old_cset_regions;\n-  size_t first_old_region, last_old_region, old_region_count;\n+  size_t young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count;\n@@ -2543,1 +2540,2 @@\n-    size_t allocation_runway = gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    size_t allocation_runway =\n+      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n@@ -2548,2 +2546,2 @@\n-    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.  Fragmentation\n-    \/\/ will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n+    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.\n+    \/\/ Fragmentation will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-  assert(free_actual != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -412,0 +412,1 @@\n+    ShenandoahFreeSet* free_set = heap->free_set();\n@@ -413,2 +414,4 @@\n-    size_t young_trash_regions, old_trash_regions;\n-    size_t first_old, last_old, num_old;\n+\n+    \/\/ This is completion of old-gen marking.  We rebuild in order to reclaim immediate garbage and to\n+    \/\/ prepare for subsequent mixed evacuations.\n+    size_t young_trash_regions, old_trash_regions, first_old, last_old, num_old;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}