{"files":[{"patch":"@@ -231,1 +231,1 @@\n-    _available[partition_id] = FreeSetUnderConstruction;\n+    _available[partition_id] = 0;\n@@ -1628,0 +1628,2 @@\n+  assert(rebuild_lock() != nullptr, \"sanity\");\n+  rebuild_lock()->lock(false);\n@@ -1684,0 +1686,4 @@\n+\n+  \/\/ Release the rebuild lock now.  What remains in this function is read-only\n+  rebuild_lock()->unlock();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,2 +116,0 @@\n-  static const size_t FreeSetUnderConstruction = SIZE_MAX;\n-\n@@ -238,3 +236,5 @@\n-  \/\/ Return available_in assuming caller does not hold the heap lock.  In production builds, available is\n-  \/\/ returned without acquiring the lock.  In debug builds, the global heap lock is acquired in order to\n-  \/\/ enforce a consistency assert.\n+  \/\/ Return available_in assuming caller does not hold the heap lock but does hold the rebuild_lock.\n+  \/\/ The returned value may be \"slightly stale\" because we do not assure that every fetch of this value\n+  \/\/ sees the most recent update of this value.  Requiring the caller to hold the rebuild_lock assures\n+  \/\/ that we don't see \"bogus\" values that are \"worse than stale\".  During rebuild of the freeset, the\n+  \/\/ value of _available is not reliable.\n@@ -243,9 +243,0 @@\n-    shenandoah_assert_not_heaplocked();\n-#ifdef ASSERT\n-    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n-    assert((_available[int(which_partition)] == FreeSetUnderConstruction) ||\n-           (_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)]),\n-           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n-           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n-           partition_membership_name(ssize_t(which_partition)));\n-#endif\n@@ -323,2 +314,8 @@\n-  \/\/ This locks the rebuild process (in combination with the global heap lock)\n-  ShenandoahRebuildLock _lock;\n+  \/\/ This locks the rebuild process (in combination with the global heap lock).  Whenever we rebuild the free set,\n+  \/\/ we first acquire the global heap lock and then we acquire this _rebuild_lock in a nested context.  Threads that\n+  \/\/ need to check available, acquire only the _rebuild_lock to make sure that they are not obtaining the value of\n+  \/\/ available for a partially reconstructed free-set.\n+  \/\/\n+  \/\/ Note that there is rank ordering of nested locks to prevent deadlock.  All threads that need to acquire both\n+  \/\/ locks will acquire them in the same order: first the global heap lock and then the rebuild lock.\n+  ShenandoahRebuildLock _rebuild_lock;\n@@ -421,2 +418,0 @@\n-  static const size_t FreeSetUnderConstruction = ShenandoahRegionPartitions::FreeSetUnderConstruction;\n-\n@@ -425,3 +420,2 @@\n-\n-  ShenandoahRebuildLock* lock() {\n-    return &_lock;\n+  ShenandoahRebuildLock* rebuild_lock() {\n+    return &_rebuild_lock;\n@@ -496,1 +490,2 @@\n-    ShenandoahRebuildLocker locker(lock());\n+    shenandoah_assert_not_heaplocked();\n+    ShenandoahRebuildLocker locker(rebuild_lock());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1158,6 +1158,8 @@\n-    ShenandoahRebuildLocker rebuild_locker(free_set->lock());\n-    free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n-    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n-    \/\/ no longer have objects separated by age into distinct regions.\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGenerationalFullGC::compute_balances();\n+    {\n+      free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+      \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+      \/\/ no longer have objects separated by age into distinct regions.\n+      if (heap->mode()->is_generational()) {\n+        ShenandoahGenerationalFullGC::compute_balances();\n+      }\n+      free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n@@ -1165,3 +1167,0 @@\n-\n-    free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -750,2 +750,0 @@\n-    ShenandoahRebuildLocker rebuild_locker(free_set->lock());\n-    size_t young_cset_regions, old_cset_regions;\n@@ -754,1 +752,1 @@\n-    size_t first_old, last_old, num_old;\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -423,2 +423,0 @@\n-    size_t young_cset_regions, old_cset_regions;\n-\n@@ -426,2 +424,1 @@\n-    size_t first_old, last_old, num_old;\n-    ShenandoahRebuildLocker rebuild_locker(_free_set->lock());\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n@@ -2579,3 +2576,1 @@\n-  ShenandoahRebuildLocker rebuild_locker(_free_set->lock());\n-  size_t young_cset_regions, old_cset_regions;\n-  size_t first_old_region, last_old_region, old_region_count;\n+  size_t young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count;\n@@ -2600,1 +2595,2 @@\n-    size_t allocation_runway = gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    size_t allocation_runway =\n+      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  assert(free_actual != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -514,1 +514,0 @@\n-    ShenandoahRebuildLocker rebuild_locker(free_set->lock());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}