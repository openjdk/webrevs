{"files":[{"patch":"@@ -42,0 +42,6 @@\n+#if defined(__clang_major__)\n+#define CORRECT_COMPILER_ATOMIC_SUPPORT\n+#elif defined(__GNUC__) && (__riscv_xlen <= 32 || __GNUC__ > 13)\n+#define CORRECT_COMPILER_ATOMIC_SUPPORT\n+#endif\n+\n@@ -117,0 +123,38 @@\n+#ifndef CORRECT_COMPILER_ATOMIC_SUPPORT\n+\/\/ The implementation of `__atomic_compare_exchange` lacks sign extensions\n+\/\/ in GCC 13 and lower when using with 32-bit unsigned integers on RV64,\n+\/\/ so we should implement it manually.\n+\/\/ GCC bug: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=114130.\n+\/\/ See also JDK-8326936.\n+template<>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest __attribute__((unused)),\n+                                                T compare_value,\n+                                                T exchange_value,\n+                                                atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+\n+  int32_t old_value;\n+  uint64_t rc_temp;\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  __asm__ __volatile__ (\n+    \"1:  lr.w      %0, %2      \\n\\t\"\n+    \"    bne       %0, %3, 2f  \\n\\t\"\n+    \"    sc.w      %1, %4, %2  \\n\\t\"\n+    \"    bnez      %1, 1b      \\n\\t\"\n+    \"2:                        \\n\\t\"\n+    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*dest)\n+    : \/*%3*\/\"r\" ((int64_t)(int32_t)compare_value), \/*%4*\/\"r\" (exchange_value)\n+    : \"memory\" );\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return (T)old_value;\n+}\n+#endif\n+\n@@ -154,0 +198,4 @@\n+#ifndef CORRECT_COMPILER_ATOMIC_SUPPORT\n+  STATIC_ASSERT(byte_size != 4);\n+#endif\n+\n@@ -190,0 +238,1 @@\n+#undef CORRECT_COMPILER_ATOMIC_SUPPORT\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomic_linux_riscv.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"}]}