{"files":[{"patch":"@@ -129,0 +129,2 @@\n+\n+    private final Duration idleTimeoutDuration;\n@@ -134,0 +136,3 @@\n+    \/\/ true if this connection has been placed in the HTTP\/3 connection pool of the HttpClient.\n+    \/\/ false otherwise.\n+    private volatile boolean presentInConnPool;\n@@ -223,0 +228,11 @@\n+\n+        this.idleTimeoutDuration = client.client().idleConnectionTimeout(HTTP_3).orElse(null);\n+        if (idleTimeoutDuration == null) {\n+            \/\/ The absence of HTTP\/3 idle timeout duration is considered to mean\n+            \/\/ never idle terminating the connection\n+            quicConnection.connectionTerminator().appLayerMaxIdle(Duration.MAX,\n+                    this::isQUICTrafficGenerationRequired);\n+        } else {\n+            quicConnection.connectionTerminator().appLayerMaxIdle(idleTimeoutDuration,\n+                    this::isQUICTrafficGenerationRequired);\n+        }\n@@ -735,3 +751,2 @@\n-                    te = idleConnectionTimeoutEvent = client.client().idleConnectionTimeout(HTTP_3)\n-                            .map(IdleConnectionTimeoutEvent::new).orElse(null);\n-                    if (te != null) {\n+                    if (idleTimeoutDuration != null) {\n+                        te = idleConnectionTimeoutEvent = new IdleConnectionTimeoutEvent();\n@@ -876,0 +891,38 @@\n+    \/**\n+     * Mark this connection as being present or absent from the connection pool.\n+     *\/\n+    void setPooled(final boolean present) {\n+        this.presentInConnPool = present;\n+    }\n+\n+    \/**\n+     * This callback method is invoked by the QUIC layer when it notices that this\n+     * connection hasn't seen any traffic for certain period of time. QUIC\n+     * invokes this method to ask HTTP\/3 whether the QUIC layer\n+     * should generate traffic to keep this connection active.\n+     * This method returns true, indicating that the traffic must be generated,\n+     * if this HTTP\/3 connection is in pool and there's no current request\/response\n+     * in progress over this connection (i.e. the HTTP\/3 connection is idle in the\n+     * pool waiting for any new requests to be issued by the application).\n+     *\/\n+    private boolean isQUICTrafficGenerationRequired() {\n+        if (!isOpen()) {\n+            return false;\n+        }\n+        lock();\n+        try {\n+            \/\/ if there's no HTTP\/3 request\/responses in progress and the connection is\n+            \/\/ in the pool (thus idle), then we instruct QUIC to generate traffic on the\n+            \/\/ QUIC connection to prevent it from being idle terminated.\n+            final boolean generateTraffic = this.presentInConnPool\n+                    && this.exchanges.isEmpty()\n+                    && this.reservedStreamCount.get() == 0;\n+            if (debug.on()) {\n+                debug.log(\"QUIC traffic generation required = \" + generateTraffic);\n+            }\n+            return generateTraffic;\n+        } finally {\n+            unlock();\n+        }\n+    }\n+\n@@ -896,2 +949,3 @@\n-        IdleConnectionTimeoutEvent(Duration duration) {\n-            super(duration);\n+        IdleConnectionTimeoutEvent() {\n+            assert idleTimeoutDuration != null : \"idle timeout duration is null\";\n+            super(idleTimeoutDuration);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3Connection.java","additions":59,"deletions":5,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -158,1 +158,5 @@\n-            return advertised.putIfAbsent(key, c);\n+            final var prev = advertised.putIfAbsent(key, c);\n+            if (prev == null) {\n+                c.setPooled(true); \/\/ mark the newly pooled connection as pooled\n+            }\n+            return prev;\n@@ -161,1 +165,5 @@\n-        return unadvertised.putIfAbsent(key, c);\n+        final var prev = unadvertised.putIfAbsent(key, c);\n+        if (prev == null) {\n+            c.setPooled(true); \/\/ mark the newly pooled connection as pooled\n+        }\n+        return prev;\n@@ -164,1 +172,1 @@\n-    Http3Connection put(String key, Http3Connection c) {\n+    void put(String key, Http3Connection c) {\n@@ -171,1 +179,3 @@\n-            return advertised.put(key, c);\n+            advertised.put(key, c);\n+            c.setPooled(true);\n+            return;\n@@ -174,1 +184,2 @@\n-        return unadvertised.put(key, c);\n+        unadvertised.put(key, c);\n+        c.setPooled(true);\n@@ -192,1 +203,5 @@\n-        return unadvertised.remove(key, c);\n+        final boolean removed = unadvertised.remove(key, c);\n+        if (removed) {\n+            c.setPooled(false);\n+        }\n+        return removed;\n@@ -196,0 +211,1 @@\n+        advertised.values().forEach((c) -> c.setPooled(false));\n@@ -197,0 +213,1 @@\n+        unadvertised.values().forEach((c) -> c.setPooled(false));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3ConnectionPool.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,1 +27,6 @@\n-\/\/ responsible for managing the connection termination of a QUIC connection\n+import java.time.Duration;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Responsible for managing the connection termination of a QUIC connection\n+ *\/\n@@ -30,3 +35,9 @@\n-    \/\/ lets the terminator know that the connection is still alive and should not be\n-    \/\/ idle timed out\n-    void keepAlive();\n+    \/**\n+     * Instructs the connection terminator to consider the connection as active\n+     * at the present point in time. The connection terminator will then restart its\n+     * idle timeout timer from this point in time.\n+     * <p>\n+     * This method must be called when an incoming packet is processed successfully\n+     * or when an ack-eliciting packet is sent by the local endpoint on the connection.\n+     *\/\n+    void markActive();\n@@ -34,0 +45,11 @@\n+    \/**\n+     * Terminates the connection, if not already terminated, with the given cause.\n+     * <p>\n+     * A connection is terminated only once with a {@link TerminationCause}. However, this method\n+     * can be called any number of times. If the connection is not already terminated,\n+     * then this method does the necessary work to terminate the connection. Any subsequent\n+     * invocations of this method, after the connection has been terminated, will not\n+     * change the termination cause of the connection.\n+     *\n+     * @param cause the termination cause\n+     *\/\n@@ -36,0 +58,11 @@\n+    \/**\n+     * Returns {@code true} if the connection is allowed for use, {@code false} otherwise.\n+     * <p>\n+     * This method is typically called when a connection that has been idle, is about to be used\n+     * for handling some request. This method allows for co-ordination between the connection usage\n+     * and the connection terminator to prevent the connection from being idle timed out when it is\n+     * about to be used for some request. The connection must only be used if this method\n+     * returns {@code true}.\n+     *\n+     * @return true if the connection can be used, false otherwise\n+     *\/\n@@ -38,0 +71,29 @@\n+    \/**\n+     * Instructs the connection terminator that the application layer allows the\n+     * connection to stay idle for the given {@code maxIdle} duration. If the QUIC\n+     * layer has negotiated an idle timeout for the connection, that's lower than\n+     * the application's {@code maxIdle} duration, then the connection terminator\n+     * upon noticing absence of traffic over the connection for certain duration,\n+     * calls the {@code trafficGenerationCheck} to check if the QUIC layer should\n+     * explicitly generate some traffic to prevent the connection\n+     * from idle terminating.\n+     * <p>\n+     * When the {@code trafficGenerationCheck} is invoked, the application layer\n+     * must return {@code true} only if explicit traffic generation is necessary\n+     * to keep the connection alive.\n+     * <p>\n+     * If the application layer wishes to never idle terminate the connection, then\n+     * a {@code maxIdle} duration of {@linkplain Duration#MAX Duration.MAX} is recommended.\n+     *\n+     * @param maxIdle                the maximum idle duration of the connection,\n+     *                               at the application layer\n+     * @param trafficGenerationCheck the callback that will be invoked by the connection\n+     *                               terminator to decide if the QUIC layer should generate\n+     *                               any traffic to prevent the connection from idle terminating\n+     * @throws NullPointerException     if either {@code maxIdle} or {@code trafficGenerationCheck}\n+     *                                  is null\n+     * @throws IllegalArgumentException if {@code maxIdle} is\n+     *                                  {@linkplain Duration#isNegative() negative} or\n+     *                                  {@linkplain Duration#isZero() zero}\n+     *\/\n+    void appLayerMaxIdle(Duration maxIdle, Supplier<Boolean> trafficGenerationCheck);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/ConnectionTerminator.java","additions":66,"deletions":4,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.time.Duration;\n@@ -33,0 +34,1 @@\n+import java.util.function.Supplier;\n@@ -55,1 +57,0 @@\n-import static jdk.internal.net.quic.QuicTransportErrors.INTERNAL_ERROR;\n@@ -73,2 +74,2 @@\n-    public void keepAlive() {\n-        this.connection.idleTimeoutManager.keepAlive();\n+    public void markActive() {\n+        this.connection.idleTimeoutManager.markActive();\n@@ -82,0 +83,5 @@\n+    @Override\n+    public void appLayerMaxIdle(final Duration maxIdle, final Supplier<Boolean> trafficGenerationCheck) {\n+        this.connection.idleTimeoutManager.appLayerMaxIdle(maxIdle, trafficGenerationCheck);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/ConnectionTerminatorImpl.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.time.Duration;\n@@ -32,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -33,0 +35,1 @@\n+import java.util.function.Supplier;\n@@ -61,1 +64,1 @@\n-    \/\/ the time at which the last outgoing packet was sent or an\n+    \/\/ the time (in nanos) at which the last outgoing packet was sent or an\n@@ -63,1 +66,1 @@\n-    private volatile long lastPacketActivityAt;\n+    private volatile long lastPacketActivityNanos;\n@@ -69,1 +72,1 @@\n-    \/\/ the time at which the connection was last reserved for use.\n+    \/\/ the time (in nanos) at which the connection was last reserved for use.\n@@ -71,1 +74,5 @@\n-    private long lastUsageReservationAt;\n+    private long lastUsageReservationNanos;\n+\n+    private final AtomicReference<Supplier<Boolean>> trafficGenerationCheck = new AtomicReference<>();\n+    \/\/ must be accessed only when holding stateLock\n+    private PingEvent pingEvent;\n@@ -82,2 +89,2 @@\n-     * @throw IllegalStateException if handshake hasn't yet completed or if the handshake\n-     * has failed for the connection\n+     * @throws IllegalStateException if handshake hasn't yet completed or if the handshake\n+     *                               has failed for the connection\n@@ -86,2 +93,0 @@\n-        final CompletableFuture<QuicTLSEngine.HandshakeState> handshakeCF =\n-                this.connection.handshakeFlow().handshakeCF();\n@@ -89,15 +94,1 @@\n-        if (!handshakeCF.isDone()) {\n-            throw new IllegalStateException(\"handshake isn't yet complete,\"\n-                    + \" cannot start idle connection management\");\n-        }\n-        if (handshakeCF.isCompletedExceptionally()) {\n-            throw new IllegalStateException(\"cannot start idle connection management for a failed\"\n-                    + \" connection\");\n-        }\n-        startTimers();\n-    }\n-\n-    \/**\n-     * Starts the idle timeout timer of the QUIC connection, if not already started.\n-     *\/\n-    private void startTimers() {\n+        requireSuccessfulHandshake();\n@@ -119,0 +110,13 @@\n+    private void requireSuccessfulHandshake() {\n+        final CompletableFuture<QuicTLSEngine.HandshakeState> handshakeCF =\n+                this.connection.handshakeFlow().handshakeCF();\n+        if (!handshakeCF.isDone()) {\n+            throw new IllegalStateException(\"handshake isn't yet complete,\" +\n+                    \" cannot use idle connection management\");\n+        }\n+        if (handshakeCF.isCompletedExceptionally()) {\n+            throw new IllegalStateException(\"cannot use idle connection management for a failed\"\n+                    + \" connection\");\n+        }\n+    }\n+\n@@ -157,6 +161,2 @@\n-        \/\/ disable the event (refreshDeadline() of IdleTimeoutEvent will return Deadline.MAX)\n-        final Deadline nextDeadline = this.idleTimeoutEvent.nextDeadline;\n-        if (!nextDeadline.equals(Deadline.MAX)) {\n-            this.idleTimeoutEvent.nextDeadline = Deadline.MAX;\n-            endpoint.timer().reschedule(this.idleTimeoutEvent, Deadline.MIN);\n-        }\n+        \/\/ disable the idle timeout timer event\n+        disableTimedEvent(endpoint.timer(), this.idleTimeoutEvent);\n@@ -168,1 +168,1 @@\n-        \/\/ 75% of idle timeout or if idle timeout is not configured, then 30 seconds\n+        \/\/ 75% of QUIC idle timeout or if QUIC idle timeout is not configured, then 30 seconds\n@@ -197,6 +197,2 @@\n-        \/\/ disable the event (refreshDeadline() of StreamDataBlockedEvent will return Deadline.MAX)\n-        final Deadline nextDeadline = this.streamDataBlockedEvent.nextDeadline;\n-        if (!nextDeadline.equals(Deadline.MAX)) {\n-            this.streamDataBlockedEvent.nextDeadline = Deadline.MAX;\n-            endpoint.timer().reschedule(this.streamDataBlockedEvent, Deadline.MIN);\n-        }\n+        \/\/ disable the stream data blocked timer event\n+        disableTimedEvent(endpoint.timer(), this.streamDataBlockedEvent);\n@@ -206,0 +202,77 @@\n+    \/\/ set up a PING timer if the application layer's max idle duration for the connection\n+    \/\/ is larger than that of the negotiated QUIC idle timeout for that connection\n+    void appLayerMaxIdle(final Duration maxIdle, final Supplier<Boolean> trafficGenerationCheck) {\n+        Objects.requireNonNull(maxIdle, \"maxIdle\");\n+        Objects.requireNonNull(trafficGenerationCheck, \"trafficGenerationCheck\");\n+        if (maxIdle.isZero() || maxIdle.isNegative()) {\n+            throw new IllegalArgumentException(\"invalid maxIdle duration: \" + maxIdle);\n+        }\n+        \/\/ the application layer must not configure its max idle duration\n+        \/\/ until the QUIC connection's handshake has successfully completed\n+        requireSuccessfulHandshake();\n+\n+        if (!this.trafficGenerationCheck.compareAndSet(null, trafficGenerationCheck)) {\n+            throw new IllegalStateException(\"app layer max inactivity already set\");\n+        }\n+        final Optional<Long> quicIdleTimeout = getIdleTimeout();\n+        if (quicIdleTimeout.isEmpty()) {\n+            \/\/ the QUIC connection will never idle timeout, nothing more to do\n+            return;\n+        }\n+        \/\/ we start the PING sending timer event only if the QUIC layer idle timeout\n+        \/\/ is lesser than the app layer's desired idle time\n+        if (Duration.ofMillis(quicIdleTimeout.get()).compareTo(maxIdle) < 0) {\n+            this.stateLock.lock();\n+            try {\n+                if (shutdown.get()) {\n+                    return;\n+                }\n+                \/\/ QUIC connection has a lower idle timeout than the app layer. start a timer\n+                \/\/ which checks with the app layer at regular intervals to decide whether to\n+                \/\/ send a PING to keep the QUIC connection active.\n+                startPingTimer();\n+            } finally {\n+                this.stateLock.unlock();\n+            }\n+        }\n+    }\n+\n+    private void startPingTimer() {\n+        assert stateLock.isHeldByCurrentThread() : \"not holding state lock\";\n+        \/\/ we don't expect the timer to be started more than once\n+        assert this.pingEvent == null : \"PING timer already started\";\n+        final Optional<Long> quicIdleTimeout = getIdleTimeout();\n+        assert quicIdleTimeout.isPresent() : \"QUIC idle timeout is disabled, no need to start PING timer\";\n+        \/\/ potential PING generation every 75% of QUIC idle timeout\n+        final long pingFrequencyMillis = (long) (0.75 * quicIdleTimeout.get());\n+        assert pingFrequencyMillis > 0 : \"unexpected ping frequency: \" + pingFrequencyMillis;\n+        final QuicTimerQueue timerQueue = connection.endpoint().timer();\n+        final Deadline deadline = timeLine().instant().plusMillis(pingFrequencyMillis);\n+        \/\/ create the timeout event and register with the QuicTimerQueue.\n+        this.pingEvent = new PingEvent(deadline, pingFrequencyMillis);\n+        timerQueue.offer(this.pingEvent);\n+        if (debug.on()) {\n+            debug.log(\"started periodic PING for connection,\"\n+                    + \" ping event: \" + this.pingEvent\n+                    + \" deadline: \" + deadline);\n+        } else {\n+            Log.logQuic(\"{0} started periodic PING for connection,\"\n+                            + \" ping event: {1} deadline: {2}\",\n+                    connection.logTag(), this.pingEvent, deadline);\n+        }\n+    }\n+\n+    private void stopPingTimer() {\n+        assert stateLock.isHeldByCurrentThread() : \"not holding state lock\";\n+        if (this.pingEvent == null) {\n+            return;\n+        }\n+        final QuicEndpoint endpoint = this.connection.endpoint();\n+        assert endpoint != null : \"QUIC endpoint is null\";\n+        \/\/ disable the ping timer event\n+        disableTimedEvent(endpoint.timer(), this.pingEvent);\n+        this.pingEvent = null;\n+        this.trafficGenerationCheck.set(null);\n+    }\n+\n+\n@@ -212,1 +285,1 @@\n-     * @return true if the connection has been successfully reserved and is {@link #isOpen()}. false\n+     * @return true if the connection has been successfully reserved. false\n@@ -224,1 +297,1 @@\n-            final long lastPktActivity = lastPacketActivityAt;\n+            final long lastPktActivity = lastPacketActivityNanos;\n@@ -235,1 +308,1 @@\n-            this.lastUsageReservationAt = System.nanoTime();\n+            this.lastUsageReservationNanos = System.nanoTime();\n@@ -259,2 +332,3 @@\n-    void keepAlive() {\n-        lastPacketActivityAt = System.nanoTime(); \/\/ TODO: timeline().instant()?\n+    \/\/ consider the connection as active as of this moment\n+    void markActive() {\n+        lastPacketActivityNanos = System.nanoTime(); \/\/ TODO: timeline().instant()?\n@@ -273,0 +347,1 @@\n+            stopPingTimer();\n@@ -321,0 +396,9 @@\n+    private static void disableTimedEvent(final QuicTimerQueue timer, final TimedEvent te) {\n+        \/\/ disable the event (refreshDeadline() of TimedEvent will return Deadline.MAX)\n+        final Deadline nextDeadline = te.nextDeadline;\n+        if (!nextDeadline.equals(Deadline.MAX)) {\n+            te.nextDeadline = Deadline.MAX;\n+            timer.reschedule(te, Deadline.MIN);\n+        }\n+    }\n+\n@@ -357,0 +441,1 @@\n+        assert idleTerminationLock.isHeldByCurrentThread() : \"not holding idle termination lock\";\n@@ -358,1 +443,1 @@\n-        final long lastActiveNanos = Math.max(lastPacketActivityAt, lastUsageReservationAt);\n+        final long lastActiveNanos = Math.max(lastPacketActivityNanos, lastUsageReservationNanos);\n@@ -362,4 +447,4 @@\n-    final class IdleTimeoutEvent implements QuicTimedEvent {\n-        private final long eventId;\n-        private volatile Deadline deadline;\n-        private volatile Deadline nextDeadline;\n+    sealed abstract class TimedEvent implements QuicTimedEvent {\n+        protected final long eventId;\n+        protected volatile Deadline deadline;\n+        protected volatile Deadline nextDeadline;\n@@ -367,1 +452,1 @@\n-        private IdleTimeoutEvent(final Deadline deadline) {\n+        private TimedEvent(final Deadline deadline) {\n@@ -374,1 +459,1 @@\n-        public Deadline deadline() {\n+        public final Deadline deadline() {\n@@ -379,1 +464,1 @@\n-        public Deadline refreshDeadline() {\n+        public final Deadline refreshDeadline() {\n@@ -386,0 +471,15 @@\n+        @Override\n+        public final long eventId() {\n+            return this.eventId;\n+        }\n+\n+        @Override\n+        public abstract Deadline handle();\n+    }\n+\n+    final class IdleTimeoutEvent extends TimedEvent {\n+\n+        private IdleTimeoutEvent(final Deadline deadline) {\n+            super(deadline);\n+        }\n+\n@@ -445,5 +545,0 @@\n-        @Override\n-        public long eventId() {\n-            return this.eventId;\n-        }\n-\n@@ -456,2 +551,1 @@\n-    final class StreamDataBlockedEvent implements QuicTimedEvent {\n-        private final long eventId;\n+    final class StreamDataBlockedEvent extends TimedEvent {\n@@ -459,2 +553,0 @@\n-        private volatile Deadline deadline;\n-        private volatile Deadline nextDeadline;\n@@ -463,2 +555,1 @@\n-            assert deadline != null : \"timeout deadline is null\";\n-            this.deadline = this.nextDeadline = deadline;\n+            super(deadline);\n@@ -466,14 +557,0 @@\n-            this.eventId = QuicTimerQueue.newEventId();\n-        }\n-\n-        @Override\n-        public Deadline deadline() {\n-            return this.deadline;\n-        }\n-\n-        @Override\n-        public Deadline refreshDeadline() {\n-            if (shutdown.get()) {\n-                return this.deadline = this.nextDeadline = Deadline.MAX;\n-            }\n-            return this.deadline = this.nextDeadline;\n@@ -521,2 +598,60 @@\n-        public long eventId() {\n-            return this.eventId;\n+        public String toString() {\n+            return \"StreamDataBlockedEvent-\" + this.eventId;\n+        }\n+    }\n+\n+\n+    final class PingEvent extends TimedEvent {\n+        private final long pingFrequencyNanos;\n+        private final long idleTimeoutNanos;\n+\n+        private PingEvent(final Deadline deadline, final long pingFrequencyMillis) {\n+            super(deadline);\n+            this.pingFrequencyNanos = MILLISECONDS.toNanos(pingFrequencyMillis);\n+            if (this.pingFrequencyNanos <= 0) {\n+                throw new IllegalArgumentException(\"ping frequency is too small: \"\n+                        + pingFrequencyMillis + \" milliseconds\");\n+            }\n+            this.idleTimeoutNanos = MILLISECONDS.toNanos(getIdleTimeout().get());\n+        }\n+\n+        @Override\n+        public Deadline handle() {\n+            if (shutdown.get()) {\n+                \/\/ timeout manager is shutdown, nothing more to do\n+                return this.nextDeadline = Deadline.MAX;\n+            }\n+            if (!shouldInitiateAppLayerCheck()) {\n+                \/\/ reschedule for next round\n+                this.nextDeadline = timeLine().instant().plusNanos(this.pingFrequencyNanos);\n+                return this.nextDeadline;\n+            }\n+            \/\/ check with the app layer if traffic generation is required\n+            final Supplier<Boolean> check = trafficGenerationCheck.get();\n+            if (check == null) {\n+                \/\/ generateTrafficCheck can be null if the timeout manager was shutdown\n+                \/\/ when this event handling was in progress. don't send a PING frame\n+                \/\/ in that case.\n+                assert shutdown.get() : \"trafficGenerationCheck is absent\";\n+                return this.nextDeadline = Deadline.MAX;\n+            }\n+            if (check.get()) {\n+                \/\/ app layer OKed sending a PING\n+                connection.requestSendPing();\n+                if (debug.on()) {\n+                    debug.log(\"enqueued a PING frame\");\n+                } else {\n+                    Log.logQuic(\"{0} enqueued a PING frame\", connection.logTag());\n+                }\n+            } else {\n+                \/\/ app layer told us not to send a PING.\n+                \/\/ we skip the PING generation only for the current round, no need\n+                \/\/ to disable future PING checks\n+                if (debug.on()) {\n+                    debug.log(\"skipping PING generation\");\n+                } else {\n+                    Log.logQuic(\"{0} skipping PING generation\", connection.logTag());\n+                }\n+            }\n+            this.nextDeadline = timeLine().instant().plusNanos(this.pingFrequencyNanos);\n+            return this.nextDeadline;\n@@ -527,1 +662,29 @@\n-            return \"StreamDataBlockedEvent-\" + this.eventId;\n+            return \"PingEvent-\" + this.eventId;\n+        }\n+\n+        \/\/ returns true if the app layer traffic generation check needs to be invoked,\n+        \/\/ false otherwise.\n+        private boolean shouldInitiateAppLayerCheck() {\n+            final long lastPktAt = lastPacketActivityNanos;\n+            final long now = System.nanoTime();\n+            if ((now - lastPktAt) >= this.pingFrequencyNanos) {\n+                \/\/ no traffic during the ping interval, initiate a app layer check\n+                \/\/ to see if explicit traffic needs to be generated\n+                return true;\n+            }\n+            \/\/ check if the connection will potentially idle terminate before the next\n+            \/\/ ping check is scheduled, if yes, then initiate a app layer traffic\n+            \/\/ generation check now\n+            try {\n+                final long idleTerminationAt = Math.addExact(lastPktAt, this.idleTimeoutNanos);\n+                final long nextPingCheck = Math.addExact(now, this.pingFrequencyNanos);\n+                if (idleTerminationAt <= nextPingCheck) {\n+                    return true;\n+                }\n+            } catch (ArithmeticException ae) {\n+                \/\/ it's OK to trigger a potentially unnecessary app layer check in this case\n+                return true;\n+            }\n+            \/\/ connection appears to be receiving traffic, no need to initiate app layer\n+            \/\/ traffic generation check\n+            return false;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/IdleTimeoutManager.java","additions":240,"deletions":77,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -1990,1 +1990,1 @@\n-        this.terminator.keepAlive();\n+        this.terminator.markActive();\n@@ -2822,1 +2822,1 @@\n-            this.terminator.keepAlive();\n+            this.terminator.markActive();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicConnectionImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-                IdleTimeoutManager.IdleTimeoutEvent,\n-                IdleTimeoutManager.StreamDataBlockedEvent,\n+                IdleTimeoutManager.TimedEvent,\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicTimedEvent.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @bug 8371802\n+ * @summary verify that if a higher idle timeout is configured for a HTTP\/3 connection\n+ *          then a lower negotiated QUIC idle timeout doesn't cause QUIC to\n+ *          idle terminate the connection\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *\n+ * @comment this test has some explicit delays to simulate a idle connection, the timeout=180\n+ *          is merely to provide some leeway to the test and prevent timing out the test on busy\n+ *          systems\n+ * @run junit\/othervm\/timeout=180 -Djdk.httpclient.quic.idleTimeout=30\n+ *                    -Djdk.httpclient.keepalive.timeout.h3=120\n+ *                    ${test.main.class}\n+ *\/\n+class H3IdleExceedsQuicIdleTimeout {\n+\n+    private static final String REQ_PATH = \"\/8371802\";\n+\n+    private static HttpTestServer h3Server;\n+    private static SSLContext sslCtx;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslCtx = new SimpleSSLContext().get();\n+        assert sslCtx != null : \"SSLContext is null\";\n+        h3Server = HttpTestServer.create(HTTP_3_URI_ONLY, sslCtx);\n+        h3Server.addHandler(new Handler(), REQ_PATH);\n+        h3Server.start();\n+        System.err.println(\"HTTP\/3 server started at \" + h3Server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() throws Exception {\n+        if (h3Server != null) {\n+            System.err.println(\"stopping server at \" + h3Server.getAddress());\n+            h3Server.stop();\n+        }\n+    }\n+\n+    \/*\n+     * With QUIC idle connection timeout configured to be lower than the HTTP\/3 idle timeout,\n+     * this test issues a HTTP\/3 request and expects that request to establish a QUIC connection\n+     * and receive a successful response. The test then stays idle for a duration larger\n+     * than the QUIC idle timeout and issues a HTTP\/3 request again after that idle period.\n+     * The test then expects that the second request too is responded by the previously opened\n+     * connection, thus proving that the QUIC layer did the necessary work to prevent the (idle)\n+     * connection from terminating.\n+     *\/\n+    @Test\n+    void testQUICKeepsConnAlive() throws Exception {\n+        final long quicIdleTimeoutSecs = 30;\n+        assertEquals(quicIdleTimeoutSecs,\n+                Integer.parseInt(System.getProperty(\"jdk.httpclient.quic.idleTimeout\")),\n+                \"unexpected QUIC idle timeout\");\n+        assertEquals(120,\n+                Integer.parseInt(System.getProperty(\"jdk.httpclient.keepalive.timeout.h3\")),\n+                \"unexpected HTTP\/3 idle timeout\");\n+        try (final HttpClient client = HttpClient.newBuilder()\n+                .sslContext(sslCtx)\n+                .proxy(NO_PROXY)\n+                .version(HTTP_3)\n+                .build()) {\n+\n+            final URI req1URI = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .host(h3Server.getAddress().getAddress())\n+                    .port(h3Server.getAddress().getPort())\n+                    .path(REQ_PATH)\n+                    .query(\"i=1\")\n+                    .build();\n+            System.err.println(\"issuing request \" + req1URI);\n+            final HttpRequest req1 = HttpRequest.newBuilder()\n+                    .uri(req1URI)\n+                    .setOption(HttpOption.H3_DISCOVERY, HTTP_3_URI_ONLY)\n+                    .build();\n+            final HttpResponse<Void> resp1 = client.send(req1, BodyHandlers.discarding());\n+            assertEquals(200, resp1.statusCode(), \"unexpected status code\");\n+            final String resp1ConnLabel = resp1.connectionLabel().orElse(null);\n+            System.err.println(\"first request handled by connection: \" + resp1ConnLabel);\n+            assertNotNull(resp1ConnLabel, \"missing connection label on response\");\n+            assertEquals(HTTP_3, resp1.version(), \"unexpected response version\");\n+            \/\/ don't generate any more traffic from the HTTP\/3 side for longer than the QUIC\n+            \/\/ idle timeout\n+            stayIdle(quicIdleTimeoutSecs + 13, TimeUnit.SECONDS);\n+            \/\/ now send the HTTP\/3 request and expect the same previous connection to handle\n+            \/\/ respond to this request\n+            final URI req2URI = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .host(h3Server.getAddress().getAddress())\n+                    .port(h3Server.getAddress().getPort())\n+                    .path(REQ_PATH)\n+                    .query(\"i=2\")\n+                    .build();\n+            System.err.println(\"issuing request \" + req2URI);\n+            final HttpRequest req2 = HttpRequest.newBuilder()\n+                    .uri(req2URI)\n+                    .setOption(HttpOption.H3_DISCOVERY, HTTP_3_URI_ONLY)\n+                    .build();\n+            final HttpResponse<Void> resp2 = client.send(req2, BodyHandlers.discarding());\n+            assertEquals(200, resp2.statusCode(), \"unexpected status code\");\n+            final String resp2ConnLabel = resp2.connectionLabel().orElse(null);\n+            System.err.println(\"second request handled by connection: \" + resp2ConnLabel);\n+            assertEquals(resp1ConnLabel, resp2ConnLabel, \"second request handled by a different connection\");\n+            assertEquals(HTTP_3, resp2.version(), \"unexpected response version\");\n+        }\n+    }\n+\n+    private static void stayIdle(final long time, final TimeUnit unit) throws InterruptedException {\n+        \/\/ await on a CountDownLatch which no one counts down. this is merely\n+        \/\/ to avoid using Thread.sleep(...) and other similar constructs and then\n+        \/\/ having to deal with spurious wakeups.\n+        final boolean countedDown = new CountDownLatch(1).await(time, unit);\n+        assertFalse(countedDown, \"wasn't expected to be counted down\");\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+        private static final int NO_RESP_BODY = 0;\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            System.err.println(\"handling request \" + exchange.getRequestURI());\n+            exchange.sendResponseHeaders(200, NO_RESP_BODY);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3IdleExceedsQuicIdleTimeout.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}