{"files":[{"patch":"@@ -1080,12 +1080,5 @@\n-  if (can_reshape && cg != nullptr) {\n-    assert(IncrementalInlineMH, \"required\");\n-    assert(cg->call_node() == this, \"mismatch\");\n-    assert(cg->is_mh_late_inline(), \"not virtual\");\n-\n-    \/\/ Check whether this MH handle call becomes a candidate for inlining.\n-    ciMethod* callee = cg->method();\n-    vmIntrinsics::ID iid = callee->intrinsic_id();\n-    if (iid == vmIntrinsics::_invokeBasic) {\n-      if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(nullptr);\n+  if (cg != nullptr) {\n+    if (late_inline_failed()) {\n+      phase->C->prepend_late_inline(cg);\n+      if (cg->is_mh_late_inline()) {\n+        phase->C->inc_number_of_mh_late_inlines();\n@@ -1093,7 +1086,22 @@\n-    } else if (iid == vmIntrinsics::_linkToNative) {\n-      \/\/ never retry\n-    } else {\n-      assert(callee->has_member_arg(), \"wrong type of call?\");\n-      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(nullptr);\n+      set_generator(nullptr);\n+    } else if (can_reshape) {\n+      assert(IncrementalInlineMH, \"required\");\n+      assert(cg->call_node() == this, \"mismatch\");\n+      assert(cg->is_mh_late_inline(), \"not virtual\");\n+\n+      \/\/ Check whether this MH handle call becomes a candidate for inlining.\n+      ciMethod* callee = cg->method();\n+      vmIntrinsics::ID iid = callee->intrinsic_id();\n+      if (iid == vmIntrinsics::_invokeBasic) {\n+        if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n+          phase->C->prepend_late_inline(cg);\n+          set_generator(nullptr);\n+        }\n+      } else if (iid == vmIntrinsics::_linkToNative) {\n+        \/\/ never retry\n+      } else {\n+        assert(callee->has_member_arg(), \"wrong type of call?\");\n+        if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n+          phase->C->prepend_late_inline(cg);\n+          set_generator(nullptr);\n+        }\n@@ -1168,19 +1176,23 @@\n-  if (can_reshape && cg != nullptr) {\n-    assert(IncrementalInlineVirtual, \"required\");\n-    assert(cg->call_node() == this, \"mismatch\");\n-    assert(cg->is_virtual_late_inline(), \"not virtual\");\n-\n-    \/\/ Recover symbolic info for method resolution.\n-    ciMethod* caller = jvms()->method();\n-    ciBytecodeStream iter(caller);\n-    iter.force_bci(jvms()->bci());\n-\n-    bool             not_used1;\n-    ciSignature*     not_used2;\n-    ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-    ciKlass*         holder       = iter.get_declared_method_holder();\n-    if (orig_callee->is_method_handle_intrinsic()) {\n-      assert(_override_symbolic_info, \"required\");\n-      orig_callee = method();\n-      holder = method()->holder();\n-    }\n+  if (cg != nullptr) {\n+    if (late_inline_failed()) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(nullptr);\n+    } else if (can_reshape) {\n+      assert(IncrementalInlineVirtual, \"required\");\n+      assert(cg->call_node() == this, \"mismatch\");\n+      assert(cg->is_virtual_late_inline(), \"not virtual\");\n+\n+      \/\/ Recover symbolic info for method resolution.\n+      ciMethod* caller = jvms()->method();\n+      ciBytecodeStream iter(caller);\n+      iter.force_bci(jvms()->bci());\n+\n+      bool             not_used1;\n+      ciSignature*     not_used2;\n+      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+      ciKlass*         holder       = iter.get_declared_method_holder();\n+      if (orig_callee->is_method_handle_intrinsic()) {\n+        assert(_override_symbolic_info, \"required\");\n+        orig_callee = method();\n+        holder = method()->holder();\n+      }\n@@ -1188,1 +1200,1 @@\n-    ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1190,2 +1202,2 @@\n-    Node* receiver_node = in(TypeFunc::Parms);\n-    const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+      Node* receiver_node = in(TypeFunc::Parms);\n+      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1193,9 +1205,10 @@\n-    int  not_used3;\n-    bool call_does_dispatch;\n-    ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                       call_does_dispatch, not_used3);  \/\/ out-parameters\n-    if (!call_does_dispatch) {\n-      \/\/ Register for late inlining.\n-      cg->set_callee_method(callee);\n-      phase->C->prepend_late_inline(cg); \/\/ MH late inlining prepends to the list, so do the same\n-      set_generator(nullptr);\n+      int  not_used3;\n+      bool call_does_dispatch;\n+      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                        call_does_dispatch, not_used3);  \/\/ out-parameters\n+      if (!call_does_dispatch) {\n+        \/\/ Register for late inlining.\n+        cg->set_callee_method(callee);\n+        phase->C->prepend_late_inline(cg); \/\/ MH late inlining prepends to the list, so do the same\n+        set_generator(nullptr);\n+      }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":63,"deletions":50,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+  bool            _late_inline_failed;\n@@ -693,1 +694,2 @@\n-      _name(nullptr)\n+      _name(nullptr),\n+      _late_inline_failed(false)\n@@ -702,0 +704,1 @@\n+  bool late_inline_failed()    const { return _late_inline_failed; }\n@@ -707,0 +710,1 @@\n+  void set_late_inline_failed(bool failed) { _late_inline_failed = failed; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -668,0 +668,1 @@\n+                  _failed_late_inlines(comp_arena(), 2, 0, nullptr),\n@@ -2052,0 +2053,4 @@\n+      } else {\n+        cg->call_node()->set_generator(cg);\n+        cg->call_node()->set_late_inline_failed(true);\n+        add_failed_late_inline(cg);\n@@ -2083,0 +2088,8 @@\n+    \/\/ Reset failed generator in call node\n+    for (int i = 0; i < _failed_late_inlines.length(); i++) {\n+      CallGenerator* cg = _failed_late_inlines.at(i);\n+      CallNode* cn = cg->call_node();\n+      cn->set_generator(nullptr);\n+      cn->set_late_inline_failed(false);\n+    }\n+    _failed_late_inlines.clear();\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -464,0 +464,1 @@\n+  GrowableArray<CallGenerator*> _failed_late_inlines; \/\/ List of CallGenerators that have failed inlining\n@@ -1085,0 +1086,4 @@\n+  void              add_failed_late_inline(CallGenerator* cg) {\n+    _failed_late_inlines.push(cg);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-compiler\/vectorapi\/VectorLogicalOpIdentityTest.java 8302459 linux-x64,windows-x64\n-compiler\/vectorapi\/VectorRebracket128Test.java 8330538 generic-all\n+compiler\/vectorapi\/VectorRebracket128Test.java#Z 8330538 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @bug 8325520\n+ * @bug 8325520 8302459\n@@ -1401,1 +1401,1 @@\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+IncrementalInlineForceCleanup\")\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n@@ -1403,0 +1403,5 @@\n+        testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\")\n+                     .start();\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherMaskFoldingTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @bug 8288294\n+ * @bug 8288294 8302459\n@@ -764,0 +764,1 @@\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}