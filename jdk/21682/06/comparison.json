{"files":[{"patch":"@@ -473,1 +473,1 @@\n-    assert(_callee == nullptr, \"repeated inlining attempt\");\n+    assert(_callee == nullptr || _callee == m, \"repeated inline attempt with different callee\");\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1072,0 +1072,9 @@\n+void CallJavaNode::register_for_late_inline() {\n+  if (generator() != nullptr) {\n+    Compile::current()->prepend_late_inline(generator());\n+    set_generator(nullptr);\n+  } else {\n+    assert(false, \"repeated inline attempt\");\n+  }\n+}\n+\n@@ -1082,11 +1091,20 @@\n-    assert(IncrementalInlineMH, \"required\");\n-    assert(cg->call_node() == this, \"mismatch\");\n-    assert(cg->is_mh_late_inline(), \"not virtual\");\n-\n-    \/\/ Check whether this MH handle call becomes a candidate for inlining.\n-    ciMethod* callee = cg->method();\n-    vmIntrinsics::ID iid = callee->intrinsic_id();\n-    if (iid == vmIntrinsics::_invokeBasic) {\n-      if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(nullptr);\n+    if (cg->is_mh_late_inline()) {\n+      assert(IncrementalInlineMH, \"required\");\n+      assert(cg->call_node() == this, \"mismatch\");\n+      assert(cg->method()->is_method_handle_intrinsic(), \"required\");\n+\n+      \/\/ Check whether this MH handle call becomes a candidate for inlining.\n+      ciMethod* callee = cg->method();\n+      vmIntrinsics::ID iid = callee->intrinsic_id();\n+      if (iid == vmIntrinsics::_invokeBasic) {\n+        if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n+          register_for_late_inline();\n+        }\n+      } else if (iid == vmIntrinsics::_linkToNative) {\n+        \/\/ never retry\n+      } else {\n+        assert(callee->has_member_arg(), \"wrong type of call?\");\n+        if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n+          register_for_late_inline();\n+          phase->C->inc_number_of_mh_late_inlines();\n+        }\n@@ -1094,2 +1112,0 @@\n-    } else if (iid == vmIntrinsics::_linkToNative) {\n-      \/\/ never retry\n@@ -1097,4 +1113,5 @@\n-      assert(callee->has_member_arg(), \"wrong type of call?\");\n-      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n-        phase->C->prepend_late_inline(cg);\n-        set_generator(nullptr);\n+      assert(IncrementalInline, \"required\");\n+      assert(!cg->method()->is_method_handle_intrinsic(), \"required\");\n+      if (phase->C->print_inlining()) {\n+        phase->C->inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE,\n+          \"static call node changed: trying again\");\n@@ -1102,0 +1119,1 @@\n+      register_for_late_inline();\n@@ -1170,18 +1188,18 @@\n-    assert(IncrementalInlineVirtual, \"required\");\n-    assert(cg->call_node() == this, \"mismatch\");\n-    assert(cg->is_virtual_late_inline(), \"not virtual\");\n-\n-    \/\/ Recover symbolic info for method resolution.\n-    ciMethod* caller = jvms()->method();\n-    ciBytecodeStream iter(caller);\n-    iter.force_bci(jvms()->bci());\n-\n-    bool             not_used1;\n-    ciSignature*     not_used2;\n-    ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-    ciKlass*         holder       = iter.get_declared_method_holder();\n-    if (orig_callee->is_method_handle_intrinsic()) {\n-      assert(_override_symbolic_info, \"required\");\n-      orig_callee = method();\n-      holder = method()->holder();\n-    }\n+    if (cg->is_virtual_late_inline()) {\n+      assert(IncrementalInlineVirtual, \"required\");\n+      assert(cg->call_node() == this, \"mismatch\");\n+\n+      \/\/ Recover symbolic info for method resolution.\n+      ciMethod* caller = jvms()->method();\n+      ciBytecodeStream iter(caller);\n+      iter.force_bci(jvms()->bci());\n+\n+      bool             not_used1;\n+      ciSignature*     not_used2;\n+      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+      ciKlass*         holder       = iter.get_declared_method_holder();\n+      if (orig_callee->is_method_handle_intrinsic()) {\n+        assert(_override_symbolic_info, \"required\");\n+        orig_callee = method();\n+        holder = method()->holder();\n+      }\n@@ -1189,1 +1207,1 @@\n-    ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1191,2 +1209,2 @@\n-    Node* receiver_node = in(TypeFunc::Parms);\n-    const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+      Node* receiver_node = in(TypeFunc::Parms);\n+      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1194,9 +1212,16 @@\n-    int  not_used3;\n-    bool call_does_dispatch;\n-    ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                       call_does_dispatch, not_used3);  \/\/ out-parameters\n-    if (!call_does_dispatch) {\n-      \/\/ Register for late inlining.\n-      cg->set_callee_method(callee);\n-      phase->C->prepend_late_inline(cg); \/\/ MH late inlining prepends to the list, so do the same\n-      set_generator(nullptr);\n+      int  not_used3;\n+      bool call_does_dispatch;\n+      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n+      if (!call_does_dispatch) {\n+        \/\/ Register for late inlining.\n+        cg->set_callee_method(callee);\n+        register_for_late_inline(); \/\/ MH late inlining prepends to the list, so do the same\n+      }\n+    } else {\n+      assert(IncrementalInline, \"required\");\n+      if (phase->C->print_inlining()) {\n+        phase->C->inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE,\n+          \"dynamic call node changed: trying again\");\n+      }\n+      register_for_late_inline();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":72,"deletions":47,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -797,0 +797,1 @@\n+  void register_for_late_inline();\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2032,0 +2032,1 @@\n+    bool is_scheduled_for_igvn_before = C->igvn_worklist()->member(cg->call_node());\n@@ -2042,0 +2043,8 @@\n+      } else {\n+        bool is_scheduled_for_igvn_after = C->igvn_worklist()->member(cg->call_node());\n+        if (!is_scheduled_for_igvn_before && is_scheduled_for_igvn_after) { \/\/ avoid potential infinite loop\n+          assert(false, \"scheduled for IGVN during inlining attempt\");\n+        } else {\n+          assert(is_scheduled_for_igvn_before == is_scheduled_for_igvn_after, \"call node removed from IGVN list during inlining pass\");\n+          cg->call_node()->set_generator(cg);\n+        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-compiler\/vectorapi\/VectorLogicalOpIdentityTest.java 8302459 linux-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @bug 8325520\n+ * @bug 8325520 8302459\n@@ -1401,1 +1401,1 @@\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+IncrementalInlineForceCleanup\")\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n@@ -1403,0 +1403,5 @@\n+        testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\")\n+                     .start();\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherMaskFoldingTest.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @bug 8288294\n+ * @bug 8288294 8302459\n@@ -764,0 +764,1 @@\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}