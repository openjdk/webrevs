{"files":[{"patch":"@@ -161,0 +161,7 @@\n+#ifdef LINUX\n+class Whitebox_Linux : public os::Linux {\n+ public:\n+  static int host_cpus() { return os::Linux::active_processor_count(); }\n+};\n+#endif\n+\n@@ -2500,0 +2507,6 @@\n+\/\/ Physical cpus of the host machine (including containers), Linux only.\n+WB_ENTRY(jint, WB_HostCPUs(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return Whitebox_Linux::host_cpus();)\n+  return -1; \/\/ Not used\/implemented on other platforms\n+WB_END\n+\n@@ -2941,0 +2954,1 @@\n+  {CC\"hostCPUs\",                  CC\"()I\",            (void*)&WB_HostCPUs },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+containers\/systemd\/SystemdMemoryAwarenessTest.java 8322420 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    systemd.support \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class HelloSystemd {\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello Systemd\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/HelloSystemd.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @summary Memory\/CPU awareness test for JDK-under-test inside a systemd slice.\n+ * @requires systemd.support\n+ * @library \/test\/lib\n+ * @build HelloSystemd jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:whitebox.jar -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SystemdMemoryAwarenessTest\n+ *\/\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import jdk.test.lib.Platform;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.lib.containers.systemd.SystemdRunOptions;\n+import jdk.test.lib.containers.systemd.SystemdTestUtils;\n+import jdk.test.lib.containers.systemd.SystemdTestUtils.ResultFiles;\n+\n+import jtreg.SkippedException;\n+\n+public class SystemdMemoryAwarenessTest {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+       if (!Platform.isRoot()) {\n+           throw new SkippedException(\"Test requires to be run as root\");\n+       }\n+       testHelloSystemd();\n+    }\n+\n+    private static void testHelloSystemd() throws Exception {\n+        SystemdRunOptions opts = SystemdTestUtils.newOpts(\"HelloSystemd\");\n+        \/\/ 1 GB memory\n+        opts.memoryLimit(\"1000M\");\n+        int physicalCpus = wb.hostCPUs();\n+        if (physicalCpus < 3) {\n+           System.err.println(\"WARNING: host system only has \" + physicalCpus + \" expected >= 3\");\n+        }\n+        \/\/ 1 or 2 cores limit depending on physical CPUs\n+        int coreLimit = Math.min(physicalCpus, 2);\n+        System.out.println(\"DEBUG: Running test with a CPU limit of \" + coreLimit);\n+        opts.cpuLimit(String.format(\"%d%%\", coreLimit * 100));\n+        opts.sliceName(SystemdMemoryAwarenessTest.class.getSimpleName());\n+\n+        ResultFiles files = SystemdTestUtils.buildSystemdSlices(opts);\n+\n+        try {\n+            SystemdTestUtils.systemdRunJava(opts)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"Hello Systemd\")\n+                .shouldContain(\"OSContainer::active_processor_count: \" + coreLimit)\n+                .shouldContain(\"Memory Limit is: 1048576000\"); \/\/ 1 GB\n+        } finally {\n+            try {\n+                Files.delete(files.memory());\n+                Files.delete(files.cpu());\n+            } catch (NoSuchFileException e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/SystemdMemoryAwarenessTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -104,0 +104,1 @@\n+    systemd.support \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+        map.put(\"systemd.support\", this::systemdSupport);\n@@ -613,1 +614,1 @@\n-              isSupported = checkDockerSupport();\n+              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n@@ -623,0 +624,21 @@\n+    \/**\n+     * A simple check for systemd support\n+     *\n+     * @return true if systemd is supported in a given environment\n+     *\/\n+    protected String systemdSupport() {\n+        log(\"Entering systemdSupport()\");\n+\n+        boolean isSupported = Platform.isLinux();\n+        if (isSupported) {\n+           try {\n+              isSupported = checkProgramSupport(\"checkSystemdSupport()\", \"systemd-run\");\n+           } catch (Exception e) {\n+              isSupported = false;\n+           }\n+         }\n+\n+        log(\"systemdSupport(): returning isSupported = \" + isSupported);\n+        return \"\" + isSupported;\n+    }\n+\n@@ -657,3 +679,3 @@\n-    private boolean checkDockerSupport() throws IOException, InterruptedException {\n-        log(\"checkDockerSupport(): entering\");\n-        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+    private boolean checkProgramSupport(String logString, String cmd) throws IOException, InterruptedException {\n+        log(logString + \": entering\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", cmd);\n@@ -661,2 +683,2 @@\n-            redirectOutputToLogFile(\"checkDockerSupport(): which \" + Container.ENGINE_COMMAND,\n-                                                      pb, \"which-container\");\n+            redirectOutputToLogFile(logString + \": which \" + cmd,\n+                                                      pb, \"which-cmd\");\n@@ -667,1 +689,1 @@\n-        log(String.format(\"checkDockerSupport(): exitValue = %s, pid = %s\", exitValue, p.pid()));\n+        log(String.format(\"%s: exitValue = %s, pid = %s\", logString, exitValue, p.pid()));\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.systemd;\n+\n+import static jdk.test.lib.Asserts.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+\n+\/\/ This class represents options for running java inside systemd slices\n+\/\/ in test environment.\n+public class SystemdRunOptions {\n+    public ArrayList<String> javaOpts = new ArrayList<>();\n+    public String classToRun;  \/\/ class or \"-version\"\n+    public ArrayList<String> classParams = new ArrayList<>();\n+    public String memoryLimit; \/\/ used in slice for MemoryLimit property\n+    public String cpuLimit;    \/\/ used in slice for CPUQuota property\n+    public String sliceName;   \/\/ name of the slice (nests CPU in memory)\n+\n+    \/**\n+     * Convenience constructor for most common use cases in testing.\n+     * @param classToRun  a class to run, or \"-version\"\n+     * @param javaOpts  java options to use\n+     *\n+     * @return Default docker run options\n+     *\/\n+    public SystemdRunOptions(String classToRun, String... javaOpts) {\n+        this.classToRun = classToRun;\n+        Collections.addAll(this.javaOpts, javaOpts);\n+        this.sliceName = defaultSliceName();\n+    }\n+\n+    private static String defaultSliceName() {\n+        \/\/ Create a unique name for a systemd slice\n+        \/\/ jtreg guarantees that test.name is unique among all concurrently executing\n+        \/\/ tests. For example, if you have two test roots:\n+        \/\/\n+        \/\/     $ find test -type f\n+        \/\/     test\/foo\/TEST.ROOT\n+        \/\/     test\/foo\/my\/TestCase.java\n+        \/\/     test\/bar\/TEST.ROOT\n+        \/\/     test\/bar\/my\/TestCase.java\n+        \/\/     $ jtreg -concur:2 test\/foo test\/bar\n+        \/\/\n+        \/\/ jtreg will first run all the tests under test\/foo. When they are all finished, then\n+        \/\/ jtreg will run all the tests under test\/bar. So you will never have two concurrent\n+        \/\/ test cases whose test.name is \"my\/TestCase.java\"\n+        String testname = System.getProperty(\"test.name\");\n+        assertNotNull(testname, \"must be set by jtreg\");\n+        testname = testname.replace(\".java\", \"\");\n+        testname = testname.replace(\"\/\", \"_\");\n+        testname = testname.replace(\"\\\\\", \"_\");\n+        testname = testname.replace(\"-\", \"_\");\n+\n+        \/\/ Example:\n+        \/\/  Memory: \"test_containers_systemd_TestMemoryAwareness\"\n+        \/\/  CPU:    \"test_containers_systemd_TestMemoryAwareness-cpu\" => derived\n+        return testname;\n+    }\n+\n+    public SystemdRunOptions memoryLimit(String memLimit) {\n+        this.memoryLimit = memLimit;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions cpuLimit(String cpuLimit) {\n+        this.cpuLimit = cpuLimit;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions sliceName(String name) {\n+        this.sliceName = name;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions addJavaOpts(String... opts) {\n+        Collections.addAll(javaOpts, opts);\n+        return this;\n+    }\n+\n+    public SystemdRunOptions addClassOptions(String... opts) {\n+        Collections.addAll(classParams,opts);\n+        return this;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdRunOptions.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.systemd;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class SystemdTestUtils {\n+\n+    private static final Path SYSTEMD_CONFIG_HOME = Path.of(\"\/\", \"etc\", \"systemd\", \"system\");\n+\n+    \/\/ Specifies how many lines to copy from child STDOUT to main test output.\n+    \/\/ Having too many lines in the main test output will result\n+    \/\/ in JT harness trimming the output, and can lead to loss of useful\n+    \/\/ diagnostic information.\n+    private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;\n+\n+    public record ResultFiles(Path memory, Path cpu) {}\n+\n+    \/**\n+     * Run Java inside a systemd slice with specified parameters and options.\n+     *\n+     * @param opts The systemd slice options when running java\n+     * @return\n+     * @throws Exception\n+     *\/\n+    public static OutputAnalyzer systemdRunJava(SystemdRunOptions opts) throws Exception {\n+        return execute(buildJavaCommand(opts));\n+    }\n+\n+    \/**\n+     * Create commonly used options with the class to be launched inside the\n+     * systemd slice\n+     *\n+     * @param testClass The test class or {@code -version}\n+     * @return The basic options.\n+     *\/\n+    public static SystemdRunOptions newOpts(String testClass) {\n+        return new SystemdRunOptions(testClass,\n+                                     \"-Xlog:os+container=trace\",\n+                                     \"-cp\",\n+                                     Utils.TEST_CLASSES);\n+    }\n+\n+    \/**\n+     * Create systemd slice files under \/etc\/systemd\/system.\n+     *\n+     * The JDK will then run within that slice as provided by the SystemdRunOptions.\n+     *\n+     * @param runOpts The systemd slice options to use when running the test.\n+     * @return The systemd slice files (for cleanup-purposes later).\n+     * @throws Exception\n+     *\/\n+    public static ResultFiles buildSystemdSlices(SystemdRunOptions runOpts) throws Exception {\n+        String sliceName = sliceName(runOpts);\n+        String sliceNameCpu = sliceNameCpu(runOpts);\n+\n+        \/\/ Generate systemd slices for cpu\/memory\n+        String memorySliceContent = getMemorySlice(runOpts, sliceName);\n+        String cpuSliceContent = getCpuSlice(runOpts, sliceName);\n+\n+        Path memory, cpu;\n+        try {\n+            \/\/ memory slice\n+            memory = SYSTEMD_CONFIG_HOME.resolve(Path.of(sliceFileName(sliceName)));\n+            cpu = SYSTEMD_CONFIG_HOME.resolve(Path.of(sliceFileName(sliceNameCpu)));\n+            Files.writeString(memory, memorySliceContent);\n+            Files.writeString(cpu, cpuSliceContent);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"Failed to write systemd slice files\");\n+        }\n+\n+        systemdDaemonReload(cpu);\n+\n+        return new ResultFiles(memory, cpu);\n+    }\n+\n+    private static String sliceName(SystemdRunOptions runOpts) {\n+        \/\/ Slice name may include '-' which is a hierarchical slice indicator.\n+        \/\/ Replace '-' with '_' to avoid side-effects.\n+        return \"jdk_internal_\" + runOpts.sliceName.replace(\"-\", \"_\");\n+    }\n+\n+    private static String sliceNameCpu(SystemdRunOptions runOpts) {\n+        String slice = sliceName(runOpts);\n+        return String.format(\"%s-cpu\", slice);\n+    }\n+\n+    private static void systemdDaemonReload(Path cpu) throws Exception {\n+        List<String> daemonReload = List.of(\"systemctl\", \"daemon-reload\");\n+        List<String> restartSlice = List.of(\"systemctl\", \"restart\", cpu.getFileName().toString());\n+\n+        if (execute(daemonReload).getExitValue() != 0) {\n+            throw new AssertionError(\"Failed to reload systemd daemon\");\n+        }\n+        if (execute(restartSlice).getExitValue() != 0) {\n+            throw new AssertionError(\"Failed to restart the systemd slice\");\n+        }\n+    }\n+\n+    private static String getCpuSlice(SystemdRunOptions runOpts, String sliceName) {\n+        String basicSliceFormat = getBasicSliceFormat();\n+        return String.format(basicSliceFormat, sliceName, getMemoryCPUSliceContent(runOpts));\n+    }\n+\n+    private static Object getMemoryCPUSliceContent(SystemdRunOptions runOpts) {\n+        String format =\n+                \"\"\"\n+                CPUAccounting=true\n+                CPUQuota=%s\n+                \"\"\";\n+         return String.format(format, runOpts.cpuLimit);\n+    }\n+\n+    private static String getMemorySlice(SystemdRunOptions runOpts, String sliceName) {\n+        String basicSliceFormat = getBasicSliceFormat();\n+        return String.format(basicSliceFormat, sliceName, getMemorySliceContent(runOpts));\n+    }\n+\n+    private static Object getMemorySliceContent(SystemdRunOptions runOpts) {\n+        String format =\n+               \"\"\"\n+               MemoryAccounting=true\n+               MemoryLimit=%s\n+               \"\"\";\n+        return String.format(format, runOpts.memoryLimit);\n+    }\n+\n+    private static String getBasicSliceFormat() {\n+        return \"\"\"\n+               [Unit]\n+               Description=OpenJDK Tests Slice for %s\n+               Before=slices.target\n+\n+               [Slice]\n+               %s\n+               \"\"\";\n+    }\n+\n+    private static String sliceFileName(String sliceName) {\n+        return String.format(\"%s.slice\", sliceName);\n+    }\n+\n+    \/**\n+     * Build the java command to run inside a systemd slice\n+     *\n+     * @param SystemdRunOptions options for running the systemd slice test\n+     *\n+     * @return command\n+     * @throws Exception\n+     *\/\n+    private static List<String> buildJavaCommand(SystemdRunOptions opts) throws Exception {\n+        List<String> javaCmd = new ArrayList<>();\n+        \/\/ systemd-run --slice <slice-name>.slice --scope <java>\n+        javaCmd.add(\"systemd-run\");\n+        javaCmd.add(\"--slice\");\n+        javaCmd.add(sliceFileName(sliceNameCpu(opts)));\n+        javaCmd.add(\"--scope\");\n+        javaCmd.add(Path.of(Utils.TEST_JDK, \"bin\", \"java\").toString());\n+        javaCmd.addAll(opts.javaOpts);\n+        javaCmd.add(opts.classToRun);\n+        javaCmd.addAll(opts.classParams);\n+        return javaCmd;\n+    }\n+\n+    \/**\n+     * Execute a specified command in a process, report diagnostic info.\n+     *\n+     * @param command to be executed\n+     * @return The output from the process\n+     * @throws Exception\n+     *\/\n+    private static OutputAnalyzer execute(List<String> command) throws Exception {\n+        return execute(command.toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Execute a specified command in a process, report diagnostic info.\n+     *\n+     * @param command to be executed\n+     * @return The output from the process\n+     * @throws Exception\n+     *\/\n+    private static OutputAnalyzer execute(String... command) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder(command);\n+        System.out.println(\"[COMMAND]\\n\" + Utils.getCommandLine(pb));\n+\n+        Process p = pb.start();\n+        long pid = p.pid();\n+        OutputAnalyzer output = new OutputAnalyzer(p);\n+\n+        int max = MAX_LINES_TO_COPY_FOR_CHILD_STDOUT;\n+        String stdout = output.getStdout();\n+        String stdoutLimited = limitLines(stdout, max);\n+        System.out.println(\"[STDERR]\\n\" + output.getStderr());\n+        System.out.println(\"[STDOUT]\\n\" + stdoutLimited);\n+        if (stdout != stdoutLimited) {\n+            System.out.printf(\"Child process STDOUT is limited to %d lines\\n\",\n+                              max);\n+        }\n+\n+        String stdoutLogFile = String.format(\"systemd-stdout-%d.log\", pid);\n+        writeOutputToFile(stdout, stdoutLogFile);\n+        System.out.println(\"Full child process STDOUT was saved to \" + stdoutLogFile);\n+\n+        return output;\n+    }\n+\n+    private static void writeOutputToFile(String output, String fileName) throws Exception {\n+        try (FileWriter fw = new FileWriter(fileName)) {\n+            fw.write(output, 0, output.length());\n+        }\n+    }\n+\n+    private static String limitLines(String buffer, int nrOfLines) {\n+        List<String> l = Arrays.asList(buffer.split(\"\\\\R\"));\n+        if (l.size() < nrOfLines) {\n+            return buffer;\n+        }\n+\n+        return String.join(\"\\n\", l.subList(0, nrOfLines));\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdTestUtils.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -772,0 +772,1 @@\n+  public native int hostCPUs();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}