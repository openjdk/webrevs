{"files":[{"patch":"@@ -202,1 +202,21 @@\n-        if (tree.pattern instanceof JCPattern pattern) {\n+        \/\/ Translates regular instanceof type operation to instanceof pattern operator when\n+        \/\/ the expression was originally T but was subsequently erased to Object.\n+        \/\/\n+        \/\/ $expr instanceof $primitiveType\n+        \/\/ =>\n+        \/\/ $expr instanceof T $temp && $temp instanceof $primitiveType\n+        if (tree.erasedExprOriginalType!=null && !types.isSameType(tree.expr.type, tree.erasedExprOriginalType)) {\n+            BindingSymbol temp = new BindingSymbol(Flags.FINAL | Flags.SYNTHETIC,\n+                    names.fromString(\"temp\" + variableIndex++ + target.syntheticNameChar()),\n+                    tree.erasedExprOriginalType,\n+                    currentMethodSym);\n+\n+            JCVariableDecl tempDecl = make.at(tree.pos()).VarDef(temp, null);\n+\n+            JCTree resultExpr =\n+                    makeBinary(Tag.AND,\n+                            make.TypeTest(tree.expr, make.BindingPattern(tempDecl).setType(tree.erasedExprOriginalType)).setType(syms.booleanType),\n+                            make.TypeTest(make.Ident(tempDecl), tree.pattern).setType(syms.booleanType));\n+\n+            result = translate(resultExpr);\n+        } else if (tree.pattern instanceof JCPattern pattern) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -816,2 +816,1 @@\n-        Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;\n-        tree.selector = translate(tree.selector, target);\n+        tree.selector = translate(tree.selector, erasure(tree.selector.type));\n@@ -855,2 +854,1 @@\n-        Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;\n-        tree.selector = translate(tree.selector, target);\n+        tree.selector = translate(tree.selector, erasure(tree.selector.type));\n@@ -1070,1 +1068,0 @@\n-        tree.expr = translate(tree.expr, null);\n@@ -1072,0 +1069,7 @@\n+        if (tree.pattern.type.isPrimitive()) {\n+            tree.erasedExprOriginalType = erasure(tree.expr.type);\n+            tree.expr = translate(tree.expr, null);\n+        }\n+        else {\n+            tree.expr = translate(tree.expr, null);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2275,0 +2275,2 @@\n+        public Type erasedExprOriginalType;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+import java.util.List;\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8341408\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Second Preview)\n+ * @enablePreview\n+ * @compile PrimitiveTypesInTestingContextErasure.java\n+ * @run main\/othervm PrimitiveTypesInTestingContextErasure\n+ *\/\n+public class PrimitiveTypesInTestingContextErasure {\n+    public static void main(String[] args) {\n+        erasureSwitch();\n+        erasureInstanceofTypeComparisonOperator();\n+        erasureInstanceofPatternMatchingOperator();\n+\n+        pollutedInstanceofPatternMatchingOperatorReference();\n+        pollutedInstanceofPatternMatchingOperator();\n+        pollutedInstanceofTypeComparisonOperator();\n+        pollutedSwitch();\n+    }\n+\n+    public static void erasureSwitch() {\n+        List<Short> ls = List.of((short) 42);\n+        Short s = 42;\n+\n+        assertTrue(switch(ls.get(0)) {\n+            case int _ -> true;                  \/\/ Short to int\n+            default -> false;\n+        });\n+    }\n+\n+    public static void erasureInstanceofTypeComparisonOperator() {\n+        List<Short> ls = List.of((short) 42);\n+\n+        assertTrue(ls.get(0) instanceof int);   \/\/ Short to int\n+    }\n+\n+    public static void erasureInstanceofPatternMatchingOperator() {\n+        List<Short> ls = List.of((short) 42);\n+\n+        assertTrue(ls.get(0) instanceof int i); \/\/ Short to int\n+    }\n+\n+    public static void pollutedInstanceofPatternMatchingOperator() {\n+        List<Short> ls = (List) List.of(\"42\");\n+\n+        assertTrue(!(ls.get(0) instanceof int i));\n+    }\n+\n+    public static void pollutedInstanceofTypeComparisonOperator() {\n+        List<Short> ls = (List) List.of(\"42\");\n+\n+        assertTrue(!(ls.get(0) instanceof int i));\n+    }\n+\n+    public static void pollutedInstanceofPatternMatchingOperatorReference() {\n+        List<Short> ls = (List) List.of(\"42\");\n+\n+        assertTrue(!(ls.get(0) instanceof Short));\n+    }\n+\n+    public static void pollutedSwitch() {\n+        List<Short> ls = (List) List.of(\"42\");\n+\n+        try {\n+            var res = switch(ls.get(0)) {\n+                case int _ -> true;\n+                default -> false;\n+            };\n+            throw new AssertionError(\"Expected: ClassCastException\");\n+        } catch (ClassCastException e) {\n+            ;\n+        }\n+    }\n+\n+    static void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveTypesInTestingContextErasure.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}