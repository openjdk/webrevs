{"files":[{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -28,1 +27,0 @@\n-import java.io.IOException;\n@@ -32,0 +30,1 @@\n+import java.util.Arrays;\n@@ -33,1 +32,1 @@\n-import java.util.stream.Stream;\n+import java.util.stream.IntStream;\n@@ -45,1 +44,3 @@\n-        var supportedTypes = \"^.*; [CTS]; .*$\";\n+\n+        \/\/ java.lang\n+        var supportedTypes = \"^.*; [CF]; .*$\";  \/\/ full\/1:M case folding\n@@ -47,13 +48,37 @@\n-            .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n-            .map(line -> {\n-                String[] cols = line.split(\"; \");\n-                return new String[] {cols[0], cols[1], cols[2]};\n-            })\n-            .filter(cols -> {\n-                \/\/  the folding case doesn't map back to the original char.\n-                var cp1 = Integer.parseInt(cols[0], 16);\n-                var cp2 = Integer.parseInt(cols[2], 16);\n-                return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n-            })\n-            .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n-            .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var foldingChars = Arrays.stream(folding)\n+                            .mapToObj(Character::toChars)\n+                            .flatMapToInt(chars -> IntStream.range(0, chars.length).map(i -> (int) chars[i]))\n+                            .toArray();\n+                    return String.format(\"\\t\\tnew CaseFoldingEntry(0x%04x, %s)\",\n+                            cp,\n+                            Arrays.stream(foldingChars)\n+                                    .mapToObj(c -> String.format(\"0x%04x\", c))\n+                                    .collect(Collectors.joining(\", \", \"new char[] {\", \"}\"))\n+                    );\n+                })\n+                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n+        \/\/ util.regex\n+        var expandedSupportedTypes = \"^.*; [CTS]; .*$\";\n+        var expanded_caseFoldingEntries = Files.lines(caseFoldingTxt)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(expandedSupportedTypes))\n+                .map(line -> {\n+                    String[] cols = line.split(\"; \");\n+                    return new String[]{cols[0], cols[1], cols[2]};\n+                })\n+                .filter(cols -> {\n+                    \/\/ the folding case doesn't map back to the original char.\n+                    var cp1 = Integer.parseInt(cols[0], 16);\n+                    var cp2 = Integer.parseInt(cols[2], 16);\n+                    return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n+                })\n+                .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n+                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n@@ -65,1 +90,0 @@\n-        \/\/ Generate .java file\n@@ -67,5 +91,6 @@\n-            genSrcFile,\n-            Files.lines(templateFile)\n-                .map(line -> line.contains(\"%%%Entries\") ? T_0x0131_0x49 + caseFoldingEntries : line)\n-                .collect(Collectors.toList()),\n-            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+                genSrcFile,\n+                Files.lines(templateFile)\n+                        .map(line -> line.contains(\"%%%Entries\") ? caseFoldingEntries : line)\n+                        .map(line -> line.contains(\"%%%Expanded_Case_Map_Entries\") ? T_0x0131_0x49 + expanded_caseFoldingEntries : line)\n+                        .collect(Collectors.toList()),\n+                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CaseFolding.java","additions":48,"deletions":23,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -75,0 +75,17 @@\n+\n+GENSRC_STRINGCASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/java\/lang\/CaseFolding.java\n+\n+STRINGCASEFOLDING_TEMPLATE := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template\n+CASEFOLDINGTXT := $(MODULE_SRC)\/share\/data\/unicodedata\/CaseFolding.txt\n+\n+$(GENSRC_STRINGCASEFOLDING): $(BUILD_TOOLS_JDK) $(STRINGCASEFOLDING_TEMPLATE) $(CASEFOLDINGTXT)\n+\t$(call LogInfo, Generating $@)\n+\t$(call MakeTargetDir)\n+\t$(TOOL_GENERATECASEFOLDING) \\\n+\t    $(STRINGCASEFOLDING_TEMPLATE) \\\n+\t    $(CASEFOLDINGTXT) \\\n+\t    $(GENSRC_STRINGCASEFOLDING)\n+\n+TARGETS += $(GENSRC_STRINGCASEFOLDING)\n+\n+\n","filename":"make\/modules\/java.base\/gensrc\/GensrcCharacterData.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -53,17 +53,0 @@\n-GENSRC_CASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/util\/regex\/CaseFolding.java\n-\n-CASEFOLDINGTEMP := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template\n-CASEFOLDINGTXT := $(MODULE_SRC)\/share\/data\/unicodedata\/CaseFolding.txt\n-\n-$(GENSRC_CASEFOLDING): $(BUILD_TOOLS_JDK) $(CASEFOLDINGTEMP) $(CASEFOLDINGTXT)\n-\t$(call LogInfo, Generating $@)\n-\t$(call MakeTargetDir)\n-\t$(TOOL_GENERATECASEFOLDING) \\\n-\t    $(CASEFOLDINGTEMP) \\\n-\t    $(CASEFOLDINGTXT) \\\n-\t    $(GENSRC_CASEFOLDING)\n-\n-TARGETS += $(GENSRC_CASEFOLDING)\n-\n-################################################################################\n-\n","filename":"make\/modules\/java.base\/gensrc\/GensrcRegex.gmk","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2183,0 +2183,1 @@\n+     * @see  #equalsFoldCase(String)\n@@ -2192,0 +2193,50 @@\n+    \/**\n+     * Compares this {@code String} to another {@code String} for equality,\n+     * using <em>{@index \"Unicode case folding\"}<\/em>. Two strings are considered equal\n+     * by this method if their case-folded forms are identical.\n+     * <p>\n+     * Case folding is defined by the Unicode Standard in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">CaseFolding.txt<\/a>,\n+     * including 1:M mappings. For example, {@code \"Fu√ü\".equalsFoldCase(\"FUSS\")}\n+     * returns {@code true}, since the character {@code U+00DF} (sharp s) folds\n+     * to {@code \"ss\"}.\n+     * <p>\n+     * Case folding is locale-independent and language-neutral, unlike\n+     * locale-sensitive transformations such as {@link #toLowerCase()} or\n+     * {@link #toUpperCase()}. It is intended for caseless matching,\n+     * searching, and indexing.\n+     *\n+     * @apiNote\n+     * This method is the Unicode-compliant alternative to\n+     * {@link #equalsIgnoreCase(String)}. It implements full case folding as\n+     * defined by the Unicode Standard, which may differ from the simpler\n+     * per-character mapping performed by {@code equalsIgnoreCase}.\n+     * For example:\n+     * <pre>{@snippet lang=java :\n+     * String a = \"Fu√ü\";\n+     * String b = \"FUSS\";\n+     * boolean equalsFoldCase = a.equalsFoldCase(b);       \/\/ returns true\n+     * boolean equalsIgnoreCase = a.equalsIgnoreCase(b);   \/\/ returns false\n+     * }<\/pre>\n+     *\n+     * @param  anotherString\n+     *         The {@code String} to compare this {@code String} against\n+     *\n+     * @return  {@code true} if the given object is not {@code null} and represents\n+     *          the same sequence of characters as this string under Unicode case\n+     *          folding; {@code false} otherwise.\n+     *\n+     * @see     #compareToFoldCase(String)\n+     * @see     #equalsIgnoreCase(String)\n+     * @since   26\n+     *\/\n+    public boolean equalsFoldCase(String anotherString) {\n+        if (this == anotherString) {\n+            return true;\n+        }\n+        if (anotherString == null) {\n+            return false;\n+        }\n+        return UNICODE_CASEFOLD_ORDER.compare(this, anotherString) == 0;\n+    }\n+\n@@ -2307,0 +2358,1 @@\n+     * @see     #compareToFoldCase(String)\n@@ -2313,0 +2365,71 @@\n+    \/**\n+     * A Comparator that orders {@code String} objects as by\n+     * {@link #compareToFoldCase(String) compareToFoldCase()}.\n+     *\n+     * @see     #compareToFoldCase(String)\n+     * @since   26\n+     *\/\n+    public static final Comparator<String> UNICODE_CASEFOLD_ORDER\n+            = new FoldCaseComparator();\n+\n+    private static class FoldCaseComparator implements Comparator<String> {\n+\n+        @Override\n+        public int compare(String s1, String s2) {\n+            byte[] v1 = s1.value;\n+            byte[] v2 = s2.value;\n+            if (s1.coder == s2.coder()) {\n+                return s1.coder == LATIN1 ? StringLatin1.compareToFC(v1, v2)\n+                                          : StringUTF16.compareToFC(v1, v2);\n+            }\n+            return s1.coder == LATIN1 ? StringLatin1.compareToFC_UTF16(v1, v2)\n+                                      : StringUTF16.compareToFC_Latin1(v1, v2);\n+        }\n+    }\n+\n+    \/**\n+     * Compares two strings lexicographically using <em>{@index \"Unicode case folding\"}<\/em>.\n+     * This method returns an integer whose sign is that of calling {@code compareTo}\n+     * on the Unicode case folded version of the strings. Unicode Case folding\n+     * eliminates differences in case according to the Unicode Standard, using the\n+     * mappings defined in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">CaseFolding.txt<\/a>,\n+     * including 1:M mappings, such as {@code\"√ü\"} ‚Üí {@code }\"ss\"}.\n+     * <p>\n+     * Case folding is a locale-independent, language-neutral form of case mapping,\n+     * primarily intended for caseless matching. Unlike {@link #compareToIgnoreCase(String)},\n+     * which applies a simpler locale-insensitive uppercase mapping. This method\n+     * follows the Unicode <em>{@index \"full\"}<\/em> case folding, providing stable and\n+     * consistent results across all environments.\n+     * <p>\n+     * Note that this method does <em>not<\/em> take locale into account, and may\n+     * produce results that differ from locale-sensitive ordering. Use\n+     * {@link java.text.Collator} for locale-sensitive comparison.\n+     *\n+     * @apiNote\n+     * This method is the Unicode-compliant alternative to\n+     * {@link #compareToIgnoreCase(String)}. It implements the\n+     * <em>{@index \"full case folding\"}<\/em> as defined by the Unicode Standard, which\n+     * may differ from the simpler per-character mapping performed by\n+     * {@code compareToIgnoreCase}.\n+     * For example:\n+     * <pre>{@snippet lang=java :\n+     * String a = \"Fu√ü\";\n+     * String b = \"FUSS\";\n+     * int cmpFoldCase = a.compareToFoldCase(b);     \/\/ returns 0\n+     * int cmpIgnoreCase = a.compareToIgnoreCase(b); \/\/ returns > 0\n+     * }<\/pre>\n+     *\n+     * @param   str   the {@code String} to be compared.\n+     * @return  a negative integer, zero, or a positive integer as the specified\n+     *          String is greater than, equal to, or less than this String,\n+     *          ignoring case considerations by case folding.\n+     * @see     java.text.Collator\n+     * @see     #compareToIgnoreCase(String)\n+     * @see     #equalsFoldCase(String)\n+     * @since   26\n+     *\/\n+    public int compareToFoldCase(String str) {\n+        return UNICODE_CASEFOLD_ORDER.compare(this, str);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.java.lang.CaseFolding;\n@@ -65,0 +67,4 @@\n+    static int codePointAt(byte[] value, int index, int end) {\n+        return value[index] & 0xff;\n+    }\n+\n@@ -182,0 +188,94 @@\n+    public static int compareToFC(byte[] value, byte[] other) {\n+        int len1 = value.length;\n+        int len2 = other.length;\n+        char[] folded1 = null;\n+        char[] folded2 = null;\n+        int k1 = 0, k2 = 0, fk1 = 0, fk2 = 0;\n+        while ((k1 < len1 || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < len2 || folded2 != null && fk2 < folded2.length)) {\n+            char c1, c2;\n+            if (folded1 != null && fk1 < folded1.length) {\n+                c1 = folded1[fk1++];\n+            } else {\n+                int cp = codePointAt(value, k1++, len1);  \/\/ no surrogate\n+                folded1 = CaseFolding.foldIfDefined(cp);\n+                fk1 = 0;\n+                if (folded1 == null) {\n+                    c1 = (char)cp;\n+                } else {\n+                    c1 = folded1[fk1++];\n+                }\n+            }\n+            if (folded2 != null && fk2 < folded2.length) {\n+                c2 = folded2[fk2++];\n+            } else {\n+                int cp = codePointAt(other, k2++, len2);\n+                folded2 = CaseFolding.foldIfDefined(cp);\n+                fk2 = 0;\n+                if (folded2 == null) {\n+                    c2 = (char)cp;\n+                } else {\n+                    c2 = folded2[fk2++];\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < len1 || folded1 != null && fk1 < folded1.length) {\n+            return 1;\n+        }\n+        if (k2 < len2 || folded2 != null && fk2 < folded2.length) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    public static int compareToFC_UTF16(byte[] value, byte[] other) {\n+        int len1 = value.length;\n+        int len2 = StringUTF16.length(other);\n+        char[] folded1 = null;\n+        char[] folded2 = null;\n+        int k1 = 0, k2 = 0, fk1 = 0, fk2 = 0;\n+\n+        while ((k1 < len1 || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < len2 || folded2 != null && fk2 < folded2.length)) {\n+            char c1, c2;\n+            if (folded1 != null && fk1 < folded1.length) {\n+                c1 = folded1[fk1++];\n+            } else {\n+                int cp = codePointAt(value, k1++, len1);\n+                folded1 = CaseFolding.foldIfDefined(cp);\n+                fk1 = 0;\n+                if (folded1 == null) {\n+                    c1 = (char)cp;\n+                } else {\n+                    c1 = folded1[fk1++];\n+                }\n+            }\n+            if (folded2 != null && fk2 < folded2.length) {\n+                c2 = folded2[fk2++];\n+            } else {\n+                int cp = StringUTF16.codePointAt(other, k2, len2);\n+                k2 += Character.charCount(cp);\n+                folded2 = CaseFolding.foldIfDefined(cp);\n+                fk2 = 0;\n+                if (folded2 == null) {\n+                    c2 = (char)cp;\n+                } else {\n+                    c2 = folded2[fk2++];\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < len1 || folded1 != null && fk1 < folded1.length) {\n+            return 1;\n+        }\n+        if (k2 < len2 || folded2 != null && fk2 < folded2.length) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.java.lang.CaseFolding;\n@@ -595,0 +596,56 @@\n+    public static int compareToFC_Latin1(byte[] value, byte[] other) {\n+        return -StringLatin1.compareToFC_UTF16(other, value);\n+    }\n+\n+    public static int compareToFC(byte[] value, byte[] other) {\n+        int len1 = length(value);\n+        int len2 = length(other);\n+        char[] folded1 = null;\n+        char[] folded2 = null;\n+        int k1 = 0, k2 = 0, fk1 = 0, fk2 = 0;\n+        while ((k1 < len1 || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < len2 || folded2 != null && fk2 < folded2.length)) {\n+            int c1, c2;\n+            if (folded1 != null && fk1 < folded1.length) {\n+                c1 = Character.codePointAt(folded1, fk1);\n+                fk1 += Character.charCount(c1);\n+            } else {\n+                int cp = codePointAt(value, k1, len1, true);\n+                k1 += Character.charCount(cp);\n+                folded1 = CaseFolding.foldIfDefined(cp);\n+                fk1 = 0;\n+                if (folded1 == null) {\n+                    c1 = cp;\n+                } else {\n+                   c1 = Character.codePointAt(folded1, 0);\n+                   fk1 += Character.charCount(c1);\n+                }\n+            }\n+            if (folded2 != null && fk2 < folded2.length) {\n+                c2 = Character.codePointAt(folded2, fk2);\n+                fk2 += Character.charCount(c2);\n+            } else {\n+                int cp = codePointAt(other, k2, len2, true);\n+                k2 += Character.charCount(cp);\n+                folded2 = CaseFolding.foldIfDefined(cp);\n+                fk2 = 0;\n+                if (folded2 == null) {\n+                    c2 = cp;\n+                } else {\n+                   c2 = Character.codePointAt(folded2, 0);\n+                   fk2 += Character.charCount(c2);\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < len1 || folded1 != null && fk1 < folded1.length) {\n+            return 1;\n+        }\n+        if (k2 < len2 || folded2 != null && fk2 < folded2.length) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.java.lang.CaseFolding;\n@@ -47,1 +48,0 @@\n-import jdk.internal.util.regex.CaseFolding;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.java.lang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Map.entry;\n+\n+\/**\n+ * Utility class for {@code String.toCaseFold()} that handles Unicode case folding\n+ * properties defined in CasingFolding.txt, including 1:M full case folding.\n+ *\/\n+ public final class CaseFolding {\n+\n+    private CaseFolding()  {}\n+\n+    \/**\n+     * Tests whether the specified code point is already in its case-folded form.\n+     * <p>\n+     * A code point is considered folded if it does not have an explicit case\n+     * folding mapping in the Unicode CaseFolding data.\n+     *\n+     * @param  cp\n+     *         the Unicode code point to test\n+     * @return {@code true} if the given code point has no case\n+     *         folding mapping (that is, it is already folded);\n+     *         {@code false} otherwise\n+     *\n+     * @see #fold(int)\n+     *\/\n+ \tpublic static boolean isFolded(int cp) {\n+\t\treturn caseFoldingMap.get(cp) == null;\n+\t}\n+\n+    \/**\n+     * Returns the case-folded form of the specified code point, according\n+     * to the Unicode case folding mappings.\n+     * <p>\n+     * If the code point has no case folding mapping, this method returns\n+     * the original code point as a single-element array. Otherwise, it\n+     * returns the mapped form, which may consist of one or more {@code char}\n+     * values (to support 1:M mappings).\n+     *\n+     * @param  cp\n+     *         the Unicode code point to fold\n+     * @return an array of {@code char} values representing the\n+     *         case-folded form of the input code point\n+     *\n+     * @see #isFolded(int)\n+     *\/\n+    public static char[] fold(int cp) {\n+        var entry = caseFoldingMap.get(cp);\n+        if (entry != null)\n+          return entry.folding;\n+        return Character.toChars(cp);\n+    }\n+\n+   \/**\n+     * Returns the case-folded form of the specified code point defined\n+\t * by the Unicode case folding mappings.\n+     * <p>\n+     * If the code point has no case folding mapping defined, this method\n+\t * returns null. Otherwise, it returns the mapped form, which may consist\n+\t * of one or more {@code char} values (to support 1:M mappings).\n+     *\n+     * @param  cp\n+     *         the Unicode code point to fold\n+     * @return an array of {@code char} values representing the\n+     *         case-folded form of the input code point, null if\n+\t *         there is no mapping defined.\n+     *\/\n+    public static char[] foldIfDefined(int cp) {\n+        var entry = caseFoldingMap.get(cp);\n+        return entry != null ? entry.folding : null;\n+    }\n+\n+    \/**\n+     * Returns a case-folded copy of the given {@code String} object, using the\n+     * Unicode case folding mappings defined in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">\n+     * Unicode Case Folding Properties<\/a>.\n+     * <p>\n+     * This is a convenience method intended primarily for testing\n+     * {@link #isFolded(int)} and {@link #fold(int)}. Its implementation is\n+     * not optimized for performance and should not be used in performance-\n+     * sensitive contexts. It exists only until a dedicated\n+     * {@code String.toCaseFold()} method is introduced.\n+     *\n+     * @param s\n+     *        the input string\n+     * @return a {@code String} containing the case-folded form of the input string\n+     *\/\n+    public static String fold(String s) {\n+        int first;\n+        int len = s.length();\n+        int cpCnt = 1;\n+        for (first = 0; first < len; first += cpCnt) {\n+            int cp = s.codePointAt(first);\n+            if (!CaseFolding.isFolded(cp)) {\n+                break;\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        if (first == len) {\n+            return s;\n+        }\n+        StringBuilder sb = new StringBuilder(len);\n+        sb.append(s, 0, first);\n+        for (int i = first; i < len; i += cpCnt) {\n+            int cp = s.codePointAt(i);\n+            if (CaseFolding.isFolded(cp)) {\n+                sb.appendCodePoint(cp);\n+            } else {\n+                char[] folded = CaseFolding.fold(cp);\n+                sb.append(folded);\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n+     * matching, according to the\n+     * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n+     * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n+     * <p>\n+     * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n+     * be applied to literals and (optionally) to character classes. When applied to character classes, each\n+     * character class is expected to be closed under simple case folding. See the standard for the\n+     * detailed explanation and example of \"closed\".\n+     * <p>\n+     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n+     * <ol>\n+     * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n+     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n+     * <\/ol>\n+     * <p>\n+     * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n+     * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n+     * family may appears independently or within a class.\n+     * <p>\n+     * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n+     * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n+     * matching.\n+     * <p>\n+     * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n+     * if their behavior is clearly specified.\n+     * <p>\n+     * This method addresses that requirement for the \"range\" construct within in character class by computing\n+     * the additional characters that should be included to close the range under simple case folding:\n+     * <p>\n+     * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n+     * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n+     * character is not already in the range, then that mapped character (typically lowercase) is added to\n+     * the expansion set.\n+     * <p>\n+     * This allows regex character class \"range\" implementation to use the returned expansion set to support\n+     * additional case-insensitive matching, without duplicating characters already covered by the existing\n+     * regex range implementation. The expectation is the matching is done using both the uppercase and\n+     * lowercase forms of the input character, for example\n+     *\n+     * <pre>{@code\n+     *\n+     *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n+     *           inRange(lower, Character.toLower(ch), upper) ||\n+     *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n+     *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n+     * }<\/pre>\n+     *\n+     * <p>\n+     * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n+     * @param start the starting code point of the character range\n+     * @param end the ending code point of the character range\n+     * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n+     *         those already in the range\n+     *\/\n+    public static int[] getClassRangeClosingCharacters(int start, int end) {\n+        int[] expanded = new int[expanded_case_cps.length];\n+        int off = 0;\n+        for (int cp : expanded_case_cps) {\n+            if (cp >= start && cp <= end) {\n+                int folding = expanded_case_map.get(cp);\n+                if (folding < start || folding > end) {\n+                    expanded[off++] = folding;\n+                }\n+            }\n+        }\n+        return Arrays.copyOf(expanded, off);\n+    }\n+\n+    private static final Map<Integer, Integer> expanded_case_map = Map.ofEntries(\n+%%%Expanded_Case_Map_Entries\n+    );\n+\n+    private static final int[] expanded_case_cps = expanded_case_map.keySet()\n+      .stream()\n+      .mapToInt(Integer::intValue)\n+      .toArray();\n+\n+\n+     private static class CaseFoldingEntry {\n+        final int cp;\n+        final char[] folding;\n+        CaseFoldingEntry next = null;\n+\n+        CaseFoldingEntry(int cp, char[] folding) {\n+            this.cp = cp;\n+             this.folding = folding;\n+        };\n+\n+        public String toString() {\n+            return String.format(\"[%x %s]\",\n+                    cp,\n+                    IntStream.range(0, folding.length)\n+\t\t\t\t\t         .mapToObj(i -> String.format(\"%x\", (int)folding[i]))\n+                             .collect(Collectors.joining(\" \", \"\", \"\")));\n+        }\n+    }\n+\n+    private static class CaseFoldingMap {\n+\n+        private final CaseFoldingEntry[] entries;\n+\n+        CaseFoldingMap(CaseFoldingEntry[] entries) {\n+            this.entries = new CaseFoldingEntry[entries.length << 1];\n+            for (var entry : entries) {\n+                add(entry);\n+            }\n+        }\n+\n+        public CaseFoldingEntry get(int cp) {\n+            var entries = this.entries;\n+            var index = cp % entries.length;\n+            for (var e = entries[index]; e != null; e = e.next) {\n+                if (e.cp == cp)\n+                    return e;\n+            }\n+            return null;\n+        }\n+\n+        public int getDepth(int cp) {\n+            var entries = this.entries;\n+            var index = cp % entries.length;\n+            int depth = 0;\n+            for (var e = entries[index]; e != null; e = e.next) {\n+                if (e.cp == cp)\n+                    break;\n+                depth++;\n+            }\n+            return depth;\n+        }\n+\n+        private void add(CaseFoldingEntry entry) {\n+            int cp = entry.cp;\n+            var entries = this.entries;\n+            var index = cp % entries.length;\n+            for (var e = entries[index]; e != null; e = e.next) {\n+                if (e.cp == cp) {\n+                    throw new IllegalArgumentException(\"Duplicated mapping entry : \" +\n+                            String.format(\"U+%04x\", cp));\n+                }\n+            }\n+            entry.next = entries[index];\n+            entries[index] = entry;\n+        }\n+    }\n+\n+    private final static CaseFoldingEntry[] caseFoldingEntries = {\n+%%%Entries\n+    };\n+\n+    private final static CaseFoldingMap caseFoldingMap = new CaseFoldingMap(caseFoldingEntries);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util.regex;\n-\n-import java.util.Arrays;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Map.entry;\n-\n-public final class CaseFolding {\n-\n-    private static final Map<Integer, Integer> expanded_case_map = Map.ofEntries(\n-%%%Entries\n-    );\n-\n-    private static final int[] expanded_case_cps = expanded_case_map.keySet()\n-      .stream()\n-      .mapToInt(Integer::intValue)\n-      .toArray();\n-\n-    private CaseFolding()  {}\n-\n-    \/**\n-     * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n-     * matching, according to the\n-     * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n-     * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n-     * <p>\n-     * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n-     * be applied to literals and (optionally) to character classes. When applied to character classes, each\n-     * character class is expected to be closed under simple case folding. See the standard for the\n-     * detailed explanation and example of \"closed\".\n-     * <p>\n-     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n-     * <ol>\n-     * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n-     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n-     * <\/ol>\n-     * <p>\n-     * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n-     * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n-     * family may appears independently or within a class.\n-     * <p>\n-     * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n-     * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n-     * matching.\n-     * <p>\n-     * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n-     * if their behavior is clearly specified.\n-     * <p>\n-     * This method addresses that requirement for the \"range\" construct within in character class by computing\n-     * the additional characters that should be included to close the range under simple case folding:\n-     * <p>\n-     * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n-     * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n-     * character is not already in the range, then that mapped character (typically lowercase) is added to\n-     * the expansion set.\n-     * <p>\n-     * This allows regex character class \"range\" implementation to use the returned expansion set to support\n-     * additional case-insensitive matching, without duplicating characters already covered by the existing\n-     * regex range implementation. The expectation is the matching is done using both the uppercase and\n-     * lowercase forms of the input character, for example\n-     *\n-     * <pre>{@code\n-     *\n-     *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n-     *           inRange(lower, Character.toLower(ch), upper) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n-     * }<\/pre>\n-     *\n-     * <p>\n-     * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n-     * @param start the starting code point of the character range\n-     * @param end the ending code point of the character range\n-     * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n-     *         those already in the range\n-     *\/\n-    public static int[] getClassRangeClosingCharacters(int start, int end) {\n-        int[] expanded = new int[expanded_case_cps.length];\n-        int off = 0;\n-        for (int cp : expanded_case_cps) {\n-            if (cp >= start && cp <= end) {\n-                int folding = expanded_case_map.get(cp);\n-                if (folding < start || folding > end) {\n-                    expanded[off++] = folding;\n-                }\n-            }\n-        }\n-        return Arrays.copyOf(expanded, off);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary tests unicode case-folding based String comparison and equality\n+ * @bug 4397357\n+ * @library \/lib\/testlibrary\/java\/lang\n+ * @compile --add-exports java.base\/jdk.internal.java.lang=ALL-UNNAMED\n+ * UnicodeCaseFoldingTest.java\n+ * @run junit\/othervm --add-exports java.base\/jdk.internal.java.lang=ALL-UNNAMED\n+ * UnicodeCaseFoldingTest\n+ *\/\n+import java.nio.file.Files;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import jdk.internal.java.lang.CaseFolding;\n+\n+public class UnicodeCaseFoldingTest {\n+\n+    @Test\n+    void testAllCommnFullCodePointsListedInCaseFoldinigTxt() throws Throwable {\n+        var filter = \"^.*; [CF]; .*$\";  \/\/ C=common, F=full, for full case folding\n+        var results = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(filter))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var source = new String(Character.toChars(cp));\n+                    var expected = new String(folding, 0, folding.length);\n+                    \/\/ (1) Verify the folding result matches expected\n+                    assertEquals(expected, CaseFolding.fold(source), \"CaseFolding.fold()\");\n+\n+                    \/\/ (2) Verify compareToFoldCase() result\n+                    assertEquals(0, source.compareToFoldCase(expected), line); \/\/\"source.compareToFoldCase(expected)\");\n+                    assertEquals(0, expected.compareToFoldCase(source), \"expected.compareToFoldCase(source)\");\n+\n+                    \/\/ (3) Verify equalsFoldCase() result\n+                    assertEquals(true, source.equalsFoldCase(expected), \"source.equalsFoldCase(expected)\");\n+                    assertEquals(true, expected.equalsFoldCase(source), \"expected.equalsFoldCase(source)\");\n+                    return null;\n+                })\n+                .filter(error -> error != null)\n+                .toArray();\n+        assertEquals(0, results.length);\n+    }\n+\n+    @Test\n+    void testAllSimpleCodePointsListedInCaseFoldinigTxt() throws Throwable {\n+        \/\/ S=simple, for simple case folding. The simple case folding should still matches\n+        var filter = \"^.*; [S]; .*$\";\n+        var results = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(filter))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var source = new String(Character.toChars(cp));\n+                    var expected = new String(folding, 0, folding.length);\n+\n+                    \/\/ (1) Verify compareToFoldCase() result\n+                    assertEquals(0, source.compareToFoldCase(expected), \"source.compareToFoldCase(expected)\");\n+                    assertEquals(0, expected.compareToFoldCase(source), \"expected.compareToFoldCase(source)\");\n+\n+                    \/\/ (2) Verify equalsFoldCase() result\n+                    assertEquals(true, source.equalsFoldCase(expected), \"source.equalsFoldCase(expected)\");\n+                    assertEquals(true, expected.equalsFoldCase(source), \"expected.equalsFoldCase(source)\");\n+                    return null;\n+                })\n+                .filter(error -> error != null)\n+                .toArray();\n+        assertEquals(0, results.length);\n+    }\n+\n+    @Test\n+    public void testAllCodePointsFoldToThemselvesIfNotListed() throws Exception {\n+        \/\/ Collect all code points that appear in CaseFolding.txt\n+        var listed = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(\"^.*; [CF]; .*$\"))\n+                .map(line -> Integer.parseInt(line.split(\"; \")[0], 16))\n+                .collect(Collectors.toSet());\n+\n+        var failures = new ArrayList<String>();\n+\n+        \/\/ Scan BMP + Supplementary Plane 1 (U+0000..U+1FFFF)\n+        for (int cp = Character.MIN_CODE_POINT; cp <= 0x1FFFF; cp++) {\n+            if (!Character.isDefined(cp)) {\n+                continue;     \/\/ skip undefined\n+            }\n+            if (Character.isSurrogate((char) cp)) {\n+                continue; \/\/ skip surrogate code units\n+\n+            }\n+            if (listed.contains(cp)) {\n+                continue;          \/\/ already tested separately\n+            }\n+            String s = new String(Character.toChars(cp));\n+            String folded = CaseFolding.fold(s);\n+            if (!s.equals(folded)) {\n+                failures.add(String.format(\"Unexpected folding: U+%04X '%s' ‚Üí '%s'\", cp, s, folded));\n+            }\n+        }\n+\n+        assertEquals(0, failures.size(),\n+                () -> \"Some unlisted code points folded unexpectedly:\\n\"\n+                + String.join(\"\\n\", failures));\n+    }\n+\n+    @ParameterizedTest(name = \"CaseFold \\\"{0}\\\" ‚Üí \\\"{1}\\\"\")\n+    @MethodSource(\"caseFoldTestCases\")\n+    void testIndividualCaseFolding(String input, String expected) {\n+        assertEquals(expected, CaseFolding.fold(input));\n+    }\n+\n+    static Stream<Arguments> caseFoldTestCases() {\n+        return Stream.of(\n+                \/\/ ASCII simple cases\n+                Arguments.of(\"ABC\", \"abc\"),\n+                Arguments.of(\"already\", \"already\"),\n+                Arguments.of(\"MiXeD123\", \"mixed123\"),\n+                \/\/ --- Latin-1 to non-Latin-1 fold ---\n+                Arguments.of(\"aBc\\u00B5Efg\", \"abc\\u03BCefg\"), \/\/ \"¬µ\" ‚Üí \"Œº\"\n+                Arguments.of(\"test\\u00B5\\ud801\\udc00X\", \"test\\u03bc\\ud801\\udc28x\"),\n+                \/\/ German Eszett\n+                Arguments.of(\"Stra\\u00DFe\", \"strasse\"), \/\/ \"Stra√üe\"\n+                Arguments.of(\"\\u1E9E\", \"ss\"), \/\/ \"·∫û\"  capital sharp S\n+                \/\/ Turkish dotted I \/ dotless i\n+                Arguments.of(\"I\", \"i\"),\n+                Arguments.of(\"\\u0130\", \"i\\u0307\"), \/\/ capital dotted I ‚Üí \"i + dot above\"\n+                Arguments.of(\"\\u0069\\u0307\", \"i\\u0307\"), \/\/ small i + dot above remains\n+                Arguments.of(\"\\u0131\", \"\\u0131\"), \/\/ \"ƒ±\" (dotless i stays dotless)\n+\n+                \/\/ Greek special cases ---\n+                Arguments.of(\"\\u039F\\u03A3\", \"\\u03BF\\u03C3\"), \/\/ \"ŒüŒ£\" ‚Üí \"ŒøœÉ\"  final sigma always folds to normal sigma\n+                Arguments.of(\"\\u1F88\", \"\\u1F00\\u03B9\"), \/\/ \"·æà\" ‚Üí \"·ºÄŒπ\"    Alpha with psili + ypogegrammeni\n+                Arguments.of(\"\\u039C\\u03AC\\u03CA\\u03BF\\u03C2\", \"\\u03BC\\u03AC\\u03CA\\u03BF\\u03C3\"), \/\/ \"ŒúŒ¨œäŒøœÇ\" ‚Üí \"ŒºŒ¨œäŒøœÉ\"\n+                Arguments.of(\"\\u1F08\", \"\\u1F00\"), \/\/  ·ºà (Capital Alpha with psili) ‚Üí ·ºÄ\n+\n+                \/\/ Supplementary Plane characters\n+                Arguments.of(\"\\uD801\\uDC00\", \"\\uD801\\uDC28\"), \/\/ Deseret Capital Letter Long I ‚Üí Small\n+                Arguments.of(\"\\uD801\\uDC01\", \"\\uD801\\uDC29\"), \/\/ Deseret Capital Letter Long E ‚Üí Small\n+\n+                \/\/ Supplementary inside ASCII\n+                Arguments.of(\"abc\\uD801\\uDC00def\", \"abc\\uD801\\uDC28def\"),\n+                \/\/ Ligatures and compatibility folds\n+                Arguments.of(\"\\uFB00\", \"ff\"), \/\/ Ô¨Ä ‚Üí ff\n+                Arguments.of(\"\\uFB03\", \"ffi\"), \/\/ Ô¨É ‚Üí ffi\n+                Arguments.of(\"\\u212A\", \"k\"), \/\/ Kelvin sign ‚Üí k\n+\n+                Arguments.of(\"abc\\uFB00def\", \"abcffdef\"), \/\/ Ô¨Ä ‚Üí ff\n+                Arguments.of(\"abc\\uFB03def\", \"abcffidef\"), \/\/ Ô¨É ‚Üí ffi\n+                Arguments.of(\"abc\\u212Adef\", \"abckdef\"), \/\/ Kelvin sign ‚Üí k\n+\n+                \/\/ --- Fullwidth ---\n+                Arguments.of(\"\\uFF21\\uFF22\\uFF23\", \"\\uFF41\\uFF42\\uFF43\"), \/\/ \"Ôº°Ôº¢Ôº£\" ‚Üí \"ÔΩÅÔΩÇÔΩÉ\"\n+\n+                \/\/ --- Armenian ---\n+                Arguments.of(\"\\u0531\", \"\\u0561\"), \/\/ \"‘±\" ‚Üí \"’°\"\n+\n+                \/\/ --- Cherokee ---\n+                Arguments.of(\"\\u13A0\", \"\\u13A0\"), \/\/ Capital Cherokee A folds to itself\n+                Arguments.of(\"\\uAB70\", \"\\u13A0\") \/\/ Small Cherokee A folds Capital Cherokee A\n+        );\n+    }\n+\n+    static Stream<Arguments> caseFoldEqualProvider() {\n+        return Stream.of(\n+                Arguments.of(\"abc\", \"ABC\"),\n+                Arguments.of(\"aBcDe\", \"AbCdE\"),\n+                Arguments.of(\"\\u00C0\\u00E7\", \"\\u00E0\\u00C7\"), \/\/ √Ä√ß vs √†√á\n+                Arguments.of(\"stra√üe\", \"STRASSE\"), \/\/ √ü ‚Üí ss\n+                Arguments.of(\"\\uD83C\\uDDE6\", \"\\uD83C\\uDDE6\"), \/\/ üá¶ vs üá¶\n+                Arguments.of(\"\\u1E9E\", \"ss\"), \/\/ ·∫û (capital sharp S)\n+                Arguments.of(\"\\u03A3\", \"\\u03C3\"), \/\/ Œ£ vs œÉ (Greek Sigma)\n+                Arguments.of(\"\\u03C3\", \"\\u03C2\"), \/\/ œÉ vs œÇ (Greek sigma\/final sigma)\n+                Arguments.of(\"\\u212B\", \"\\u00E5\"), \/\/ ‚Ñ´ (Angstrom sign) vs √•\n+                Arguments.of(\"\\uFB00\", \"ff\"), \/\/ Ô¨Ä (ligature)\n+                Arguments.of(\"\\u01C5\", \"\\u01C5\"), \/\/ «Ö (Latin capital D with small z with caron)\n+                Arguments.of(\"Caf\\u00E9\", \"CAF\\u00C9\"), \/\/ Caf√© vs CAF√â\n+                Arguments.of(\"\\u03BA\\u03B1\\u03BB\\u03B7\\u03BC\\u03AD\\u03C1\\u03B1\", \"\\u039A\\u0391\\u039B\\u0397\\u039C\\u0388\\u03A1\\u0391\"), \/\/ Œ∫Œ±ŒªŒ∑ŒºŒ≠œÅŒ± vs ŒöŒëŒõŒóŒúŒïŒ°Œë\n+                Arguments.of(\"\\u4E2D\\u56FD\", \"\\u4E2D\\u56FD\"), \/\/ ‰∏≠ÂõΩ\n+                Arguments.of(\"\\u03B1\", \"\\u0391\"), \/\/ Œ± vs Œë (Greek alpha)\n+                Arguments.of(\"\\u212B\", \"\\u00C5\"), \/\/ ‚Ñ´ vs √Ö\n+                \/\/ from StringCompareToIgnoreCase\n+                Arguments.of(\"\\u0100\\u0102\\u0104\\u0106\\u0108\", \"\\u0100\\u0102\\u0104\\u0106\\u0109\"), \/\/ ƒÄƒÇƒÑƒÜƒà vs ƒÄƒÇƒÑƒÜƒâ\n+                Arguments.of(\"\\u0101\\u0103\\u0105\\u0107\\u0109\", \"\\u0100\\u0102\\u0104\\u0106\\u0109\"), \/\/ ƒÅƒÉƒÖƒáƒâ vs ƒÄƒÇƒÑƒÜƒâ\n+                Arguments.of(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\",\n+                        \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\"), \/\/ êêÄêêÅêêÇêêÉêêÑ vs êêÄêêÅêêÇêêÉêê¨\n+                Arguments.of(\"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\",\n+                        \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\") \/\/ êê®êê©êê™êê´êê¨ vs êêÄêêÅêêÇêêÉêê¨\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"caseFoldEqualProvider\")\n+    void testcompareToFoldCaseEquals(String s1, String s2) {\n+        assertEquals(0, s1.compareToFoldCase(s2));\n+        assertEquals(0, s2.compareToFoldCase(s1));\n+        assertEquals(true, s1.equalsFoldCase(s2));\n+        assertEquals(true, s2.equalsFoldCase(s1));\n+        assertEquals(CaseFolding.fold(s1), CaseFolding.fold(s2));\n+    }\n+\n+    static Stream<Arguments> caseFoldOrderingProvider() {\n+        return Stream.of(\n+                Arguments.of(\"asa\", \"a√ü\", -1), \/\/ √ü ‚Üí ss ‚Üí \"asa\" < \"ass\"\n+                Arguments.of(\"a√ü\", \"asa\", +1),\n+                Arguments.of(\"a\\u00DF\", \"ass\", 0), \/\/ a√ü vs ass\n+                Arguments.of(\"\\uFB03\", \"ffi\", 0), \/\/ Ô¨É (ligature)\n+                Arguments.of(\"\\u00C5\", \"Z\", 1), \/\/ √Ö vs Z\n+                Arguments.of(\"A\", \"\\u00C0\", -1), \/\/ A vs √Ä\n+                Arguments.of(\"\\u03A9\", \"\\u03C9\", 0), \/\/ Œ© vs œâ\n+                Arguments.of(\"\\u03C2\", \"\\u03C3\", 0), \/\/ œÇ vs œÉ\n+                Arguments.of(\"\\uD835\\uDD23\", \"R\", 1), \/\/ ùîØ (fraktur r) vs R\n+                Arguments.of(\"\\uFF26\", \"E\", 1), \/\/ Ôº¶ (full-width F) vs E\n+                Arguments.of(\"\\u00C9clair\", \"Eclair\", 1) \/\/ √âclair vs Eclair\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"caseFoldOrderingProvider\")\n+    void testcompareToFoldCaseOrdering(String s1, String s2, int expectedSign) {\n+        int cmp = s1.compareToFoldCase(s2);\n+        assertEquals(expectedSign, Integer.signum(cmp));\n+    }\n+\n+    static Stream<Arguments> roundTripProvider() {\n+        return Stream.of(\n+                Arguments.of(\"abc\"),\n+                Arguments.of(\"ABC\"),\n+                Arguments.of(\"stra√üe\"),\n+                Arguments.of(\"√Ä√ß\"),\n+                Arguments.of(\"a√ü\"),\n+                Arguments.of(\"\\uFB02uff\"), \/\/ Ô¨Çuff (ligature in \"fluff\")\n+                Arguments.of(\"\\u00C9COLE\") \/\/ √âCOLE\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"roundTripProvider\")\n+    void testCaseFoldRoundTrip(String s) {\n+        String folded = CaseFolding.fold(s);\n+        assertEquals(0, s.compareToFoldCase(folded));\n+        assertEquals(0, folded.compareToFoldCase(s));\n+        assertEquals(true, s.equalsFoldCase(folded));\n+        assertEquals(true, folded.equalsFoldCase(s));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/UnicodeCaseFoldingTest.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -39,6 +39,23 @@\n-    public String upper = new String(\"\\u0100\\u0102\\u0104\\u0106\\u0108\");\n-    public String upperLower = new String(\"\\u0100\\u0102\\u0104\\u0106\\u0109\");\n-    public String lower = new String(\"\\u0101\\u0103\\u0105\\u0107\\u0109\");\n-    public String supUpper = new String(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\");\n-    public String supUpperLower = new String(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\");\n-    public String supLower = new String(\"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\");\n+    public String upper = \"\\u0100\\u0102\\u0104\\u0106\\u0108\";\n+    public String upperLower = \"\\u0100\\u0102\\u0104\\u0106\\u0109\";\n+    public String lower = \"\\u0101\\u0103\\u0105\\u0107\\u0109\";\n+    public String supUpper = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\";\n+    public String supUpperLower = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\";\n+    public String supLower = \"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\";\n+\n+    public String asciiUpper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+    public String asciiUpperLower = \"ABCDEFGHIJKLMNOpqrstuvwxyz\";\n+    public String asciiLower = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+    public String greekUpper = \"\\u0391\\u0392\\u0393\\u0394\\u0395\"; \/\/ ŒëŒíŒìŒîŒï\n+    public String greekUpperLower = \"\\u0391\\u0392\\u0393\\u0394\\u03B5\"; \/\/ ŒëŒíŒìŒîŒµ\n+    public String greekLower = \"\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\"; \/\/ Œ±Œ≤Œ≥Œ¥Œµ\n+\n+    public String asciiGreekUpper = \"ABC\\u0391\\u0392\\u0393\"; \/\/ ABCŒëŒíŒì\n+    public String asciiGreekUpperLower = \"ABC\\u0391\\u0392\\u03B3\"; \/\/ ABCŒëŒíŒ≥\n+    public String asciiGreekLower = \"abc\\u03B1\\u03B2\\u03B3\"; \/\/ abcŒ±Œ≤Œ≥\n+\n+    public String utf16SupUpper = \"\\uD835\\uDC00\\uD835\\uDC01\\uD835\\uDC02\\uD835\\uDC03\\uD835\\uDC04\"; \/\/ 1D400..1D404\n+    public String utf16SupUpperLower = \"\\uD835\\uDC00\\uD835\\uDC01\\uD835\\uDC02\\uD835\\uDC03\\uD835\\uDC1C\"; \/\/ 1D400..1D41C\n+    public String utf16SubLower = \"\\uD835\\uDC1C\\uD835\\uDC1D\\uD835\\uDC1E\\uD835\\uDC1F\\uD835\\uDC20\"; \/\/ 1D41C..1D420\n+\n@@ -65,0 +82,102 @@\n+\n+    @Benchmark\n+    public int upperLowerCF() {\n+        return upper.compareToFoldCase(upperLower);\n+    }\n+\n+    @Benchmark\n+    public int lowerrCF() {\n+        return upper.compareToFoldCase(lower);\n+    }\n+\n+    @Benchmark\n+    public int supUpperLowerCF() {\n+        return supUpper.compareToFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLowerCF() {\n+        return supUpper.compareToFoldCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiUpperLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiGreekUpperLower() {\n+        return asciiGreekUpper.compareToIgnoreCase(asciiGreekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiGreekLower() {\n+        return asciiGreekUpper.compareToIgnoreCase(asciiGreekLower);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLower() {\n+        return greekUpper.compareToIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLower() {\n+        return greekUpper.compareToIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int utf16SupUpperLower() {\n+        return utf16SupUpper.compareToIgnoreCase(utf16SupUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int utf16SubLower() {\n+        return utf16SupUpper.compareToIgnoreCase(utf16SubLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiUpperLowerCF() {\n+        return asciiUpper.compareToFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLowerCF() {\n+        return asciiUpper.compareToFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLowerCF() {\n+        return greekUpper.compareToFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLowerCF() {\n+        return greekUpper.compareToFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiGreekUpperLowerCF() {\n+        return asciiGreekUpper.compareToFoldCase(asciiGreekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiGreekLowerCF() {\n+        return asciiGreekUpper.compareToFoldCase(asciiGreekLower);\n+    }\n+\n+\n+    @Benchmark\n+    public int utf16SupUpperLowerCF() {\n+        return utf16SupUpper.compareToFoldCase(utf16SupUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int utf16SubLowerCF() {\n+        return utf16SupUpper.compareToFoldCase(utf16SubLower);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToIgnoreCase.java","additions":125,"deletions":6,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  * @test\n+  * @benchmark\n+  * @summary Compare String.toUpperCase().toLowerCase() vs String.toCaseFold()\n+  * @library \/test\/lib\n+  * @run main org.openjdk.jmh.Main StringCaseFoldBenchmark\n+  *\/\n+\n+ package org.openjdk.bench.java.lang;\n+\n+ import org.openjdk.jmh.annotations.*;\n+ import java.util.concurrent.TimeUnit;\n+\n+ @BenchmarkMode(Mode.Throughput)\n+ @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+ @State(Scope.Thread)\n+ public class StringToCaseFold {\n+\n+     @Param({\"LATIN\", \"BMP\", \"SUPPLEMENTARY\", \"MIXED\"})\n+     private String dataset;\n+\n+     private String input;\n+\n+     @Setup(Level.Trial)\n+     public void setup() {\n+         switch (dataset) {\n+             case \"LATIN\":\n+                 \/\/ \"The Quick Brown Fox Jumps Over The Lazy Dog √ü √º √∂ ¬µ\"\n+                 input = \"The Quick Brown Fox Jumps Over The Lazy Dog \\u00DF \\u00FC \\u00F6 \\u00B5\";\n+                 break;\n+             case \"BMP\":\n+                 \/\/ \"ŒëŒªœÜŒ¨Œ≤Œ∑œÑŒø –∫–∏—Ä–∏–ª–ª–∏—Ü–∞ ◊¢◊ë◊®◊ô◊™ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©\"\n+                 input = \"\\u0391\\u03BB\\u03C6\\u03AC\\u03B2\\u03B7\\u03C4\\u03BF \" + \/\/ ŒëŒªœÜŒ¨Œ≤Œ∑œÑŒø\n+                         \"\\u043A\\u0438\\u0440\\u0438\\u043B\\u043B\\u0438\\u0446\\u0430 \" + \/\/ –∫–∏—Ä–∏–ª–ª–∏—Ü–∞\n+                         \"\\u05E2\\u05D1\\u05E8\\u05D9\\u05EA \" + \/\/ ◊¢◊ë◊®◊ô◊™\n+                         \"\\u0627\\u0644\\u0639\\u0631\\u0628\\u064A\\u0629\"; \/\/ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©\n+                 break;\n+             case \"SUPPLEMENTARY\":\n+                 \/\/ \"êê∑êê≤êëå Deseret êçà Gothic ùíúùí∑ùí∏ùíüùí∫ùíª MathBold\"\n+                 input = \"\\uD801\\uDC37\\uD801\\uDC32\\uD801\\uDC4C Deseret \" + \/\/ êê∑êê≤êëå\n+                         \"\\uD800\\uDF48 Gothic \" + \/\/ êçà\n+                         \"\\uD835\\uDC9C\\uD835\\uDCB7\\uD835\\uDCB8\\uD835\\uDC9F\\uD835\\uDCA0\\uD835\\uDCA1 MathBold\"; \/\/ ùíúùí∑ùí∏ùíüùí∫ùíª\n+                 break;\n+             case \"MIXED\":\n+                 \/\/ \"Hello êê∑ World √ü Œê Œ∞ ùíúùí∑ êçà üòä\"\n+                 input = \"Hello \\uD801\\uDC37 World \\u00DF \\u0390 \\u03B0 \" + \/\/ êê∑, √ü, Œê, Œ∞\n+                         \"\\uD835\\uDC9C\\uD835\\uDCB7 \" + \/\/ ùíúùí∑\n+                         \"\\uD800\\uDF48 \" + \/\/ êçà\n+                         \"\\uD83D\\uDE0A\"; \/\/ üòä\n+                 break;\n+             default:\n+                 throw new IllegalArgumentException(\"Unknown dataset: \" + dataset);\n+         }\n+     }\n+\n+     @Benchmark\n+     public String upperLower() {\n+         \/\/ Current common workaround for caseless comparison\n+         return input.toUpperCase().toLowerCase();\n+     }\n+\n+     @Benchmark\n+     public String caseFold() {\n+         \/\/ Proposed API\n+         return input;\n+         \/\/ return input.toCaseFold();\n+     }\n+ }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringToCaseFold.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}