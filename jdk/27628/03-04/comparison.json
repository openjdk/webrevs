{"files":[{"patch":"@@ -82,1 +82,1 @@\n-    build.tools.generatecharacter.CaseFolding\n+    build.tools.generatecharacter.GenerateCaseFolding\n","filename":"make\/ToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package build.tools.generatecharacter;\n-\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-import java.util.Arrays;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-public class CaseFolding {\n-\n-    public static void main(String[] args) throws Throwable {\n-        if (args.length != 3) {\n-            System.err.println(\"Usage: java CaseFolding TemplateFile CaseFolding.txt CaseFolding.java\");\n-            System.exit(1);\n-        }\n-        var templateFile = Paths.get(args[0]);\n-        var caseFoldingTxt = Paths.get(args[1]);\n-        var genSrcFile = Paths.get(args[2]);\n-\n-        \/\/ java.lang\n-        var supportedTypes = \"^.*; [CF]; .*$\";  \/\/ full\/1:M case folding\n-        var caseFoldingEntries = Files.lines(caseFoldingTxt)\n-                .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n-                .map(line -> {\n-                    var fields = line.split(\"; \");\n-                    var cp = Integer.parseInt(fields[0], 16);\n-                    fields = fields[2].trim().split(\" \");\n-                    var folding = new int[fields.length];\n-                    for (int i = 0; i < folding.length; i++) {\n-                        folding[i] = Integer.parseInt(fields[i], 16);\n-                    }\n-                    return String.format(\"\\t\\tnew CaseFoldingEntry(0x%04x, %s)\",\n-                            cp,\n-                            Arrays.stream(folding)\n-                                    .mapToObj(f -> String.format(\"0x%04x\", f))\n-                                    .collect(Collectors.joining(\", \", \"new int[] {\", \"}\"))\n-                    );\n-                })\n-                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n-        \/\/ util.regex\n-        var expandedSupportedTypes = \"^.*; [CTS]; .*$\";\n-        var expanded_caseFoldingEntries = Files.lines(caseFoldingTxt)\n-                .filter(line -> !line.startsWith(\"#\") && line.matches(expandedSupportedTypes))\n-                .map(line -> {\n-                    String[] cols = line.split(\"; \");\n-                    return new String[]{cols[0], cols[1], cols[2]};\n-                })\n-                .filter(cols -> {\n-                    \/\/ the folding case doesn't map back to the original char.\n-                    var cp1 = Integer.parseInt(cols[0], 16);\n-                    var cp2 = Integer.parseInt(cols[2], 16);\n-                    return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n-                })\n-                .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n-                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n-\n-        \/\/ hack, hack, hack! the logic does not pick 0131. just add manually to support 'I's.\n-        \/\/ 0049; T; 0131; # LATIN CAPITAL LETTER I\n-        final String T_0x0131_0x49 = String.format(\"        entry(0x%04x, 0x%04x),\\n\", 0x0131, 0x49);\n-\n-        Files.write(\n-                genSrcFile,\n-                Files.lines(templateFile)\n-                        .map(line -> line.contains(\"%%%Entries\") ? caseFoldingEntries : line)\n-                        .map(line -> line.contains(\"%%%Expanded_Case_Map_Entries\") ? T_0x0131_0x49 + expanded_caseFoldingEntries : line)\n-                        .collect(Collectors.toList()),\n-                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CaseFolding.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package build.tools.generatecharacter;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class GenerateCaseFolding {\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length != 3) {\n+            System.err.println(\"Usage: java GenerateCaseFolding TemplateFile CaseFolding.txt CaseFolding.java\");\n+            System.exit(1);\n+        }\n+        var templateFile = Paths.get(args[0]);\n+        var caseFoldingTxt = Paths.get(args[1]);\n+        var genSrcFile = Paths.get(args[2]);\n+\n+        \/\/ java.lang\n+        var supportedTypes = \"^.*; [CF]; .*$\";  \/\/ full\/1:M case folding\n+        String[][] caseFoldings = Files.lines(caseFoldingTxt)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = fields[0];\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new String[fields.length + 1];\n+                    folding[0] = cp;\n+                    System.arraycopy(fields, 0, folding, 1, fields.length);\n+                    return folding;\n+                })\n+                .toArray(size -> new String[size][]);\n+\n+        \/\/ util.regex\n+        var expandedSupportedTypes = \"^.*; [CTS]; .*$\";\n+        var expanded_caseFoldingEntries = Files.lines(caseFoldingTxt)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(expandedSupportedTypes))\n+                .map(line -> {\n+                    String[] cols = line.split(\"; \");\n+                    return new String[]{cols[0], cols[1], cols[2]};\n+                })\n+                .filter(cols -> {\n+                    \/\/ the folding case doesn't map back to the original char.\n+                    var cp1 = Integer.parseInt(cols[0], 16);\n+                    var cp2 = Integer.parseInt(cols[2], 16);\n+                    return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n+                })\n+                .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n+                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n+\n+        \/\/ hack, hack, hack! the logic does not pick 0131. just add manually to support 'I's.\n+        \/\/ 0049; T; 0131; # LATIN CAPITAL LETTER I\n+        final String T_0x0131_0x49 = String.format(\"        entry(0x%04x, 0x%04x),\\n\", 0x0131, 0x49);\n+\n+        Files.write(\n+                genSrcFile,\n+                Files.lines(templateFile)\n+                        .map(line -> line.contains(\"%%%Entries\") ? genFoldingEntries(caseFoldings) : line)\n+                        .map(line -> line.contains(\"%%%Expanded_Case_Map_Entries\") ? T_0x0131_0x49 + expanded_caseFoldingEntries : line)\n+                        .collect(Collectors.toList()),\n+                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+    }\n+\n+    private static String genFoldingEntries(String[][] foldings) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"    private static final int[] CASE_FOLDING_CPS = {\\n\");\n+        int width = 10;\n+        for (int i = 0; i < foldings.length; i++) {\n+            if (i % width == 0)\n+                sb.append(\"        \");\n+            sb.append(String.format(\"0X%s\", foldings[i][0]));\n+            if (i < foldings.length - 1)\n+                sb.append(\", \");\n+            if (i % width == width - 1 || i == foldings.length - 1)\n+                sb.append(\"\\n\");\n+        }\n+        sb.append(\"    };\\n\\n\");\n+\n+        sb.append(\"    private static final int[][] CASE_FOLDING_VALUES = {\\n\");\n+        width = 6;\n+        for (int i = 0; i < foldings.length; i++) {\n+            if (i % width == 0)\n+                sb.append(\"        \"); \/\/ indent\n+            var folding = foldings[i];\n+            sb.append(Arrays.stream(folding)\n+                            .skip(1)\n+                            .map(f -> String.format(\"0X%s\", f))\n+                            .collect(Collectors.joining(\", \", \"{\", \"}\"))\n+            );\n+            if (i < foldings.length - 1)\n+                sb.append(\", \");\n+            if (i % width == width - 1 || i == foldings.length - 1) {\n+                sb.append(\"\\n\");\n+            }\n+        }\n+        sb.append(\"    };\\n\");\n+        return sb.toString();\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/GenerateCaseFolding.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -76,1 +76,1 @@\n-GENSRC_STRINGCASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/java\/lang\/CaseFolding.java\n+GENSRC_STRINGCASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/lang\/CaseFolding.java\n","filename":"make\/modules\/java.base\/gensrc\/GensrcCharacterData.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.internal.java.lang.CaseFolding;\n+import jdk.internal.lang.CaseFolding;\n@@ -67,4 +67,0 @@\n-    static int codePointAt(byte[] value, int index, int end) {\n-        return value[index] & 0xff;\n-    }\n-\n@@ -244,1 +240,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.internal.java.lang.CaseFolding;\n+import jdk.internal.lang.CaseFolding;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.internal.java.lang.CaseFolding;\n+import jdk.internal.lang.CaseFolding;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.java.lang;\n+package jdk.internal.lang;\n@@ -39,1 +39,1 @@\n- public final class CaseFolding {\n+public final class CaseFolding {\n@@ -43,26 +43,8 @@\n-    \/**\n-     * Tests whether the specified code point is already in its case-folded form.\n-     * <p>\n-     * A code point is considered folded if it does not have an explicit case\n-     * folding mapping in the Unicode CaseFolding data.\n-     *\n-     * @param  cp\n-     *         the Unicode code point to test\n-     * @return {@code true} if the given code point has no case\n-     *         folding mapping (that is, it is already folded);\n-     *         {@code false} otherwise\n-     *\n-     * @see #fold(int)\n-     *\/\n- \tpublic static boolean isFolded(int cp) {\n-\t\treturn caseFoldingMap.get(cp) == null;\n-\t}\n-\n-    \/**\n-     * Tests whether the specified code point has a folding mapping entry defined.\n-     *\n-     * @param  cp\n-     *         the Unicode code point to test\n-     * @return {@code true} if the given code point has a case folding mapping entry\n-     *         defined in (@code caseFoldingMap}, {@code false} otherwise\n-     *\/\n+   \/**\n+    * Tests whether the specified code point has a folding mapping entry defined.\n+    *\n+    * @param  cp\n+    *         the Unicode code point to test\n+    * @return {@code true} if the given code point has a case folding mapping entry\n+    *         defined in (@code caseFoldingMap}, {@code false} otherwise\n+    *\/\n@@ -70,25 +52,2 @@\n-        return caseFoldingMap.get(cp) != null;\n-    }\n-\n-    \/**\n-     * Returns the case-folded form of the specified code point, according\n-     * to the Unicode case folding mappings.\n-     * <p>\n-     * If the code point has no case folding mapping, this method returns\n-     * the original code point as a single-element array. Otherwise, it\n-     * returns the mapped form, which may consist of one or more {@code char}\n-     * values (to support 1:M mappings).\n-     *\n-     * @param  cp\n-     *         the Unicode code point to fold\n-     * @return an array of {@code char} values representing the\n-     *         case-folded form of the input code point\n-     *\n-     * @see #isFolded(int)\n-     *\/\n-    public static int[] fold(int cp) {\n-        var entry = caseFoldingMap.get(cp);\n-        if (entry != null)\n-          return entry.folding;\n-        return new int[] { cp };\n-    }\n+         return getDefined(cp) != null;\n+     }\n@@ -97,13 +56,13 @@\n-     * Returns the case-folded form of the specified code point defined\n-\t * by the Unicode case folding mappings.\n-     * <p>\n-     * If the code point has no case folding mapping defined, this method\n-\t * returns null. Otherwise, it returns the mapped form, which may consist\n-\t * of one or more {@code char} values (to support 1:M mappings).\n-     *\n-     * @param  cp\n-     *         the Unicode code point to fold\n-     * @return an array of {@code char} values representing the\n-     *         case-folded form of the input code point, null if\n-\t *         there is no mapping defined.\n-     *\/\n+    * Returns the case-folded form of the specified code point defined\n+\t* by the Unicode case folding mappings.\n+    * <p>\n+    * If the code point has no case folding mapping defined, this method\n+\t* returns null. Otherwise, it returns the mapped form, which may consist\n+\t* of one or more {@code char} values (to support 1:M mappings).\n+    *\n+    * @param  cp\n+    *         the Unicode code point to fold\n+    * @return an array of {@code char} values representing the\n+    *         case-folded form of the input code point, null if\n+\t*         there is no mapping defined.\n+    *\/\n@@ -111,2 +70,1 @@\n-        var entry = caseFoldingMap.get(cp);\n-        return entry != null ? entry.folding : null;\n+        return getDefined(cp);\n@@ -115,47 +73,16 @@\n-    \/**\n-     * Returns a case-folded copy of the given {@code String} object, using the\n-     * Unicode case folding mappings defined in\n-     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">\n-     * Unicode Case Folding Properties<\/a>.\n-     * <p>\n-     * This is a convenience method intended primarily for testing\n-     * {@link #isFolded(int)} and {@link #fold(int)}. Its implementation is\n-     * not optimized for performance and should not be used in performance-\n-     * sensitive contexts. It exists only until a dedicated\n-     * {@code String.toCaseFold()} method is introduced.\n-     *\n-     * @param s\n-     *        the input string\n-     * @return a {@code String} containing the case-folded form of the input string\n-     *\/\n-    public static String fold(String s) {\n-        int first;\n-        int len = s.length();\n-        int cpCnt = 1;\n-        for (first = 0; first < len; first += cpCnt) {\n-            int cp = s.codePointAt(first);\n-            if (!CaseFolding.isFolded(cp)) {\n-                break;\n-            }\n-            cpCnt = Character.charCount(cp);\n-        }\n-        if (first == len) {\n-            return s;\n-        }\n-        StringBuilder sb = new StringBuilder(len);\n-        sb.append(s, 0, first);\n-        for (int i = first; i < len; i += cpCnt) {\n-            int cp = s.codePointAt(i);\n-            if (CaseFolding.isFolded(cp)) {\n-                sb.appendCodePoint(cp);\n-            } else {\n-                int[] folded = CaseFolding.fold(cp);\n-                 if (folded != null) {\n-                     for (int f : folded) {\n-                         sb.appendCodePoint(f);\n-                     }\n-                 }\n-            }\n-            cpCnt = Character.charCount(cp);\n-        }\n-        return sb.toString();\n+   \/**\n+    * Returns the case-folded form of the specified code point, if there\n+    * is a 1:1 mapping defined by the Unicode case folding mappings.\n+    * <p>\n+    * If the code point has no case folding mapping defined, or if it has\n+    * a 1:M (one-to-many) mapping, this method returns {@code -1}.\n+    * Otherwise, it returns the single mapped code point.\n+    *\n+    * @param  cp\n+    *         the Unicode code point to fold\n+    * @return the case-folded code point, or {@code -1} if no 1:1 mapping\n+    *         is defined\n+    *\/\n+    public static int foldIfDefined11(int cp) {\n+        var folding = getDefined(cp);\n+        return folding != null && folding.length == 1 ? folding[0] : -1;\n@@ -164,56 +91,56 @@\n-    \/**\n-     * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n-     * matching, according to the\n-     * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n-     * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n-     * <p>\n-     * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n-     * be applied to literals and (optionally) to character classes. When applied to character classes, each\n-     * character class is expected to be closed under simple case folding. See the standard for the\n-     * detailed explanation and example of \"closed\".\n-     * <p>\n-     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n-     * <ol>\n-     * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n-     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n-     * <\/ol>\n-     * <p>\n-     * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n-     * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n-     * family may appears independently or within a class.\n-     * <p>\n-     * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n-     * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n-     * matching.\n-     * <p>\n-     * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n-     * if their behavior is clearly specified.\n-     * <p>\n-     * This method addresses that requirement for the \"range\" construct within in character class by computing\n-     * the additional characters that should be included to close the range under simple case folding:\n-     * <p>\n-     * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n-     * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n-     * character is not already in the range, then that mapped character (typically lowercase) is added to\n-     * the expansion set.\n-     * <p>\n-     * This allows regex character class \"range\" implementation to use the returned expansion set to support\n-     * additional case-insensitive matching, without duplicating characters already covered by the existing\n-     * regex range implementation. The expectation is the matching is done using both the uppercase and\n-     * lowercase forms of the input character, for example\n-     *\n-     * <pre>{@code\n-     *\n-     *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n-     *           inRange(lower, Character.toLower(ch), upper) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n-     * }<\/pre>\n-     *\n-     * <p>\n-     * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n-     * @param start the starting code point of the character range\n-     * @param end the ending code point of the character range\n-     * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n-     *         those already in the range\n-     *\/\n+   \/**\n+    * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n+    * matching, according to the\n+    * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n+    * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n+    * <p>\n+    * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n+    * be applied to literals and (optionally) to character classes. When applied to character classes, each\n+    * character class is expected to be closed under simple case folding. See the standard for the\n+    * detailed explanation and example of \"closed\".\n+    * <p>\n+    * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n+    * <ol>\n+    * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n+    * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n+    * <\/ol>\n+    * <p>\n+    * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n+    * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n+    * family may appears independently or within a class.\n+    * <p>\n+    * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n+    * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n+    * matching.\n+    * <p>\n+    * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n+    * if their behavior is clearly specified.\n+    * <p>\n+    * This method addresses that requirement for the \"range\" construct within in character class by computing\n+    * the additional characters that should be included to close the range under simple case folding:\n+    * <p>\n+    * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n+    * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n+    * character is not already in the range, then that mapped character (typically lowercase) is added to\n+    * the expansion set.\n+    * <p>\n+    * This allows regex character class \"range\" implementation to use the returned expansion set to support\n+    * additional case-insensitive matching, without duplicating characters already covered by the existing\n+    * regex range implementation. The expectation is the matching is done using both the uppercase and\n+    * lowercase forms of the input character, for example\n+    *\n+    * <pre>{@code\n+    *\n+    *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n+    *           inRange(lower, Character.toLower(ch), upper) ||\n+    *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n+    *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n+    * }<\/pre>\n+    *\n+    * <p>\n+    * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n+    * @param start the starting code point of the character range\n+    * @param end the ending code point of the character range\n+    * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n+    *         those already in the range\n+    *\/\n@@ -243,39 +170,15 @@\n-\n-     private static class CaseFoldingEntry {\n-        final int cp;\n-        final int[] folding;\n-        CaseFoldingEntry next = null;\n-\n-        CaseFoldingEntry(int cp, int[] folding) {\n-            this.cp = cp;\n-            this.folding = folding;\n-        };\n-    }\n-\n-    private static class CaseFoldingMap {\n-\n-        private final CaseFoldingEntry[] entries;\n-\n-        CaseFoldingMap(CaseFoldingEntry[] entries) {\n-            this.entries = new CaseFoldingEntry[entries.length << 1];\n-            for (var entry : entries) {\n-                add(entry);\n-            }\n-        }\n-\n-        public CaseFoldingEntry get(int cp) {\n-            var entries = this.entries;\n-            var index = cp % entries.length;\n-            for (var e = entries[index]; e != null; e = e.next) {\n-                if (e.cp == cp)\n-                    return e;\n-            }\n-            return null;\n-        }\n-\n-        public int getDepth(int cp) {\n-            var entries = this.entries;\n-            var index = cp % entries.length;\n-            int depth = 0;\n-            for (var e = entries[index]; e != null; e = e.next) {\n-                if (e.cp == cp)\n+    private static final int HASH_CP = 0;\n+    private static final int HASH_INDEX = 1;\n+    private static final int HASH_NEXT = 2;\n+\n+    private static int[][] hashKeys(int[] keys) {\n+        var hashes = new int[keys.length << 1][3];  \/\/ cp + hash + next\n+        var off = keys.length;\n+        for (int i = 0; i < keys.length; i++) {\n+            var cp = keys[i];\n+            var hash = cp % keys.length;\n+            while (hashes[hash][HASH_CP] != 0) {\n+                var next = hashes[hash][HASH_NEXT];\n+                if (next == 0) {\n+                    hashes[hash][HASH_NEXT] = off;\n+                    hash = off++;\n@@ -283,1 +186,3 @@\n-                depth++;\n+                } else {\n+                    hash = next;\n+                }\n@@ -285,1 +190,2 @@\n-            return depth;\n+            hashes[hash][HASH_CP] = cp;\n+            hashes[hash][HASH_INDEX] = i;\n@@ -287,0 +193,2 @@\n+        return Arrays.copyOf(hashes, off);\n+    }\n@@ -288,9 +196,8 @@\n-        private void add(CaseFoldingEntry entry) {\n-            int cp = entry.cp;\n-            var entries = this.entries;\n-            var index = cp % entries.length;\n-            for (var e = entries[index]; e != null; e = e.next) {\n-                if (e.cp == cp) {\n-                    throw new IllegalArgumentException(\"Duplicated mapping entry : \" +\n-                            String.format(\"U+%04x\", cp));\n-                }\n+    private static int[] getDefined(int cp) {\n+        var hashes = CASE_FOLDING_HASHES;\n+        var length = CASE_FOLDING_CPS.length;  \/\/ hashed based on total defined.\n+        var hash = cp % length;\n+        while (hashes[hash][HASH_CP] != cp) {\n+            var next = hashes[hash][HASH_NEXT];\n+            if (next == 0) {\n+                return null;   \/\/ hash miss\n@@ -298,2 +205,1 @@\n-            entry.next = entries[index];\n-            entries[index] = entry;\n+            hash = next;\n@@ -301,0 +207,2 @@\n+        var index = hashes[hash][HASH_INDEX];\n+        return CASE_FOLDING_VALUES[index];\n@@ -303,1 +211,0 @@\n-    private final static CaseFoldingEntry[] caseFoldingEntries = {\n@@ -305,1 +212,0 @@\n-    };\n@@ -307,1 +213,1 @@\n-    private final static CaseFoldingMap caseFoldingMap = new CaseFoldingMap(caseFoldingEntries);\n+    private static final int[][] CASE_FOLDING_HASHES = hashKeys(CASE_FOLDING_CPS);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template","additions":132,"deletions":226,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @compile --add-exports java.base\/jdk.internal.java.lang=ALL-UNNAMED\n+ * @compile --add-exports java.base\/jdk.internal.lang=ALL-UNNAMED\n@@ -31,1 +31,1 @@\n- * @run junit\/othervm --add-exports java.base\/jdk.internal.java.lang=ALL-UNNAMED\n+ * @run junit\/othervm --add-exports java.base\/jdk.internal.lang=ALL-UNNAMED\n@@ -34,0 +34,1 @@\n+\n@@ -46,1 +47,1 @@\n-import jdk.internal.java.lang.CaseFolding;\n+import jdk.internal.lang.CaseFolding;\n@@ -66,1 +67,1 @@\n-                    assertEquals(expected, CaseFolding.fold(source), \"CaseFolding.fold()\");\n+                    assertEquals(expected, foldCase(source), \"CaseFolding.fold()\");\n@@ -130,1 +131,0 @@\n-\n@@ -136,1 +136,1 @@\n-            String folded = CaseFolding.fold(s);\n+            String folded = foldCase(s);\n@@ -144,1 +144,1 @@\n-                + String.join(\"\\n\", failures));\n+                        + String.join(\"\\n\", failures));\n@@ -150,1 +150,1 @@\n-        assertEquals(expected, CaseFolding.fold(input));\n+        assertEquals(expected, foldCase(input));\n@@ -239,1 +239,1 @@\n-        assertEquals(CaseFolding.fold(s1), CaseFolding.fold(s2));\n+        assertEquals(foldCase(s1), foldCase(s2));\n@@ -280,1 +280,1 @@\n-        String folded = CaseFolding.fold(s);\n+        String folded = foldCase(s);\n@@ -286,0 +286,32 @@\n+\n+    \/\/ helper to test the integrity of folding mapping\n+    private static String foldCase(String s) {\n+        int first;\n+        int len = s.length();\n+        int cpCnt = 1;\n+        for (first = 0; first < len; first += cpCnt) {\n+            int cp = s.codePointAt(first);\n+            if (CaseFolding.isDefined(cp)) {\n+                break;\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        if (first == len) {\n+            return s;\n+        }\n+        StringBuilder sb = new StringBuilder(len);\n+        sb.append(s, 0, first);\n+        for (int i = first; i < len; i += cpCnt) {\n+            int cp = s.codePointAt(i);\n+            int[] folded = CaseFolding.foldIfDefined(cp);\n+            if (folded == null) {\n+                sb.appendCodePoint(cp);\n+            } else {\n+                for (int f : folded) {\n+                    sb.appendCodePoint(f);\n+                }\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        return sb.toString();\n+    }\n","filename":"test\/jdk\/java\/lang\/String\/UnicodeCaseFoldingTest.java","additions":42,"deletions":10,"binary":false,"changes":52,"status":"modified"}]}