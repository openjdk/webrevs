{"files":[{"patch":"@@ -90,0 +90,14 @@\n+    private static long foldingToLong(String[] folding) {\n+        int cp = Integer.parseInt(folding[0], 16);\n+        long value = (long)Integer.parseInt(folding[1], 16);\n+        if (!Character.isSupplementaryCodePoint(cp) && folding.length != 2) {\n+            var shift = 16;\n+            for (int j = 2; j < folding.length; j++) {\n+                value |= (long)Integer.parseInt(folding[j], 16) << shift;\n+                shift <<= 1;\n+            }\n+            value = value | (long) (folding.length - 1) << 48;\n+        }\n+        return value;\n+    }\n+\n@@ -105,1 +119,1 @@\n-        sb.append(\"    private static final int[][] CASE_FOLDING_VALUES = {\\n\");\n+        sb.append(\"    private static final long[] CASE_FOLDING_VALUES = {\\n\");\n@@ -110,6 +124,1 @@\n-            var folding = foldings[i];\n-            sb.append(Arrays.stream(folding)\n-                            .skip(1)\n-                            .map(f -> String.format(\"0X%s\", f))\n-                            .collect(Collectors.joining(\", \", \"{\", \"}\"))\n-            );\n+            sb.append(String.format(\"0x%013xL\", foldingToLong(foldings[i])));\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/GenerateCaseFolding.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -185,5 +185,3 @@\n-        int[] folded1 = null;\n-        int[] folded2 = null;\n-        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n-        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n-               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+        int k1 = off, k2 = ooff;\n+        boolean lo1 = false, lo2 = false;  \/\/ true if we have a leftover 's' from u+00df -> ss\n+        while ((k1 < last || lo1) && (k2 < olast || lo2)) {\n@@ -191,2 +189,3 @@\n-            if (folded1 != null && fk1 < folded1.length) {\n-                c1 = folded1[fk1++];\n+            if (lo1) {\n+                c1 = 0x73; \/\/ leftover 's'\n+                lo1 = false;\n@@ -195,4 +194,3 @@\n-                folded1 = CaseFolding.foldIfDefined(c1);\n-                fk1 = 0;\n-                if (folded1 != null) {\n-                   c1 = folded1[fk1++];\n+                if (c1 == 0xdf) {\n+                    c1 = 0x73;\n+                    lo1 = true;\n@@ -201,2 +199,3 @@\n-            if (folded2 != null && fk2 < folded2.length) {\n-                c2 = folded2[fk2++];\n+            if (lo2) {\n+                c2 = 0x73; \/\/ 's'\n+                lo2 = false;\n@@ -205,4 +204,3 @@\n-                folded2 = CaseFolding.foldIfDefined(c2);\n-                fk2 = 0;\n-                if (folded2 != null) {\n-                    c2 = folded2[fk2++];\n+                if (c2 == 0xdf) {\n+                    c2 = 0x73;\n+                    lo2 = true;\n@@ -211,2 +209,2 @@\n-            if (c1 != c2) {\n-                return c1 - c2;\n+            if (!CharacterDataLatin1.equalsIgnoreCase((byte)c1, (byte)c2)) {\n+                return Character.toLowerCase(c1) - Character.toLowerCase(c2);\n@@ -215,1 +213,1 @@\n-        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n+        if (k1 < last || lo1) {\n@@ -218,1 +216,1 @@\n-        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n+        if (k2 < olast || lo2) {\n@@ -244,5 +242,3 @@\n-        int[] folded1 = null;\n-        int[] folded2 = null;\n-        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n-        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n-               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+        int f1 = 0, f2 = 0;\n+        int k1 = off, k2 = ooff;\n+        while ((k1 < last || f1 != 0) && (k2 < olast || f2 != 0)) {\n@@ -250,2 +246,2 @@\n-            if (folded1 != null && fk1 < folded1.length) {\n-                c1 = folded1[fk1++];\n+            if (f1 != 0) {\n+                c1 = (f1 & 0xffff); f1 >>>= 16;\n@@ -254,4 +250,6 @@\n-                folded1 = CaseFolding.foldIfDefined(c1);\n-                fk1 = 0;\n-                if (folded1 != null) {\n-                    c1 = folded1[fk1++];\n+                var f = CaseFolding.fold(c1);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c1 = (int)(f & 0xfffff);\n+                } else {\n+                    c1 = (int)f & 0xffff;\n+                    f1 = (int)(f >>> 16);\n@@ -260,2 +258,2 @@\n-            if (folded2 != null && fk2 < folded2.length) {\n-                c2 = folded2[fk2++];\n+            if (f2 != 0) {\n+                c2 = f2 & 0xffff; f2 >>>= 16;\n@@ -265,4 +263,6 @@\n-                folded2 = CaseFolding.foldIfDefined(c2);\n-                fk2 = 0;\n-                if (folded2 != null) {\n-                    c2 = folded2[fk2++];\n+                var f = CaseFolding.fold(c2);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c2 = (int)(f & 0xfffff);\n+                } else {\n+                    c2 = (int)(f & 0xffff);\n+                    f2 = (int)(f >>> 16);\n@@ -275,1 +275,1 @@\n-        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n+        if (k1 < last || f1 != 0) {\n@@ -278,1 +278,1 @@\n-        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n+        if (k2 < olast || f1 != 0) {\n@@ -293,3 +293,4 @@\n-                int[] folded = CaseFolding.foldIfDefined(cp1);\n-                if (folded != null) {\n-                    if (folded.length > 1) {\n+                long cf1 = CaseFolding.fold(cp1);\n+                long cf2 = CaseFolding.fold(cp2);\n+                if (cf1 != cf2) {\n+                    if (!CaseFolding.isSingleCodePoint(cf1) || !CaseFolding.isSingleCodePoint(cf2)) {\n@@ -298,11 +299,1 @@\n-                    cp1 = folded[0];\n-                }\n-                folded = CaseFolding.foldIfDefined(cp2);\n-                if (folded != null) {\n-                    if (folded.length > 1) {\n-                        return compareToFC0_UTF16(value, k, last, other, k, olast);\n-                    }\n-                    cp2 = folded[0];\n-                }\n-                if (cp1 != cp2) {\n-                    return cp1 - cp2;\n+                    return (int)(cf1 - cf2);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":45,"deletions":54,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -601,5 +601,3 @@\n-        int[] folded1 = null;\n-        int[] folded2 = null;\n-        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n-        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n-               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+        int f1 = 0, f2 = 0;\n+        int k1 = off, k2 = ooff;\n+        while ((k1 < last || f1 != 0) && (k2 < olast || f2 != 0)) {\n@@ -607,2 +605,2 @@\n-            if (folded1 != null && fk1 < folded1.length) {\n-                c1 = folded1[fk1++];\n+            if (f1 != 0) {\n+                c1 = f1 & 0xffff; f1 >>>= 16;\n@@ -610,1 +608,1 @@\n-                c1 = codePointAt(value, k1, last, true);\n+                c1 = StringUTF16.codePointAt(value, k1, last, true);\n@@ -612,4 +610,6 @@\n-                folded1 = CaseFolding.foldIfDefined(c1);\n-                fk1 = 0;\n-                if (folded1 != null) {\n-                    c1 = folded1[fk1++];\n+                var f = CaseFolding.fold(c1);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c1 = (int)(f & 0xfffff);\n+                } else {\n+                    c1 = (int)(f & 0xffff);\n+                    f1 = (int)(f >> 16);\n@@ -618,2 +618,2 @@\n-            if (folded2 != null && fk2 < folded2.length) {\n-                c2 = folded2[fk2++];\n+            if (f2 != 0) {\n+                c2 = f2 & 0xffff; f2 >>>= 16;\n@@ -621,1 +621,1 @@\n-                c2 = codePointAt(other, k2, olast, true);\n+                c2 = StringUTF16.codePointAt(other, k2, olast, true);\n@@ -623,4 +623,6 @@\n-                folded2 = CaseFolding.foldIfDefined(c2);\n-                fk2 = 0;\n-                if (folded2 != null) {\n-                    c2 = folded2[fk2++];\n+                var f = CaseFolding.fold(c2);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c2 = (int)(f & 0xfffff);\n+                } else {\n+                    c2 = (int)(f & 0xffff);\n+                    f2 = (int)(f >>> 16);\n@@ -633,1 +635,1 @@\n-        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n+        if (k1 < last || f1 != 0) {\n@@ -636,1 +638,1 @@\n-        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n+        if (k2 < olast || f2 != 0) {\n@@ -650,6 +652,9 @@\n-            if (cp1 == cp2) {\n-                k += Character.charCount(cp1);\n-                continue;\n-            }\n-            if (CaseFolding.isDefined(cp1) || CaseFolding.isDefined(cp2)) {\n-                return compareToFC0(value, k, tlast, other, k, olast);\n+            if (cp1 != cp2) {\n+                long cf1 = CaseFolding.fold(cp1);\n+                long cf2 = CaseFolding.fold(cp2);\n+                if (cf1 != cf2) {\n+                    if (!CaseFolding.isSingleCodePoint(cf1) || !CaseFolding.isSingleCodePoint(cf2)) {\n+                        return compareToFC0(value, k, tlast, other, k, olast);\n+                    }\n+                    return (int) cf1 - (int) cf2;\n+                }\n@@ -657,1 +662,1 @@\n-            return cp1 - cp2;\n+            k += Character.charCount(cp1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":33,"deletions":28,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-         return getDefined(cp) != null;\n+         return getDefined(cp) != -1;\n@@ -56,2 +56,2 @@\n-    * Returns the case-folded form of the specified code point defined\n-\t* by the Unicode case folding mappings.\n+    * Returns the case-folded form of the specified code point according\n+    * to the Unicode case folding mappings.\n@@ -59,3 +59,12 @@\n-    * If the code point has no case folding mapping defined, this method\n-\t* returns null. Otherwise, it returns the mapped form, which may consist\n-\t* of one or more {@code char} values (to support 1:M mappings).\n+    * If the code point has no case folding mapping defined, this method returns\n+    * the original code point.\n+    *\n+    * Possible combinations of the returning case-folding form as a long value\n+    *\n+    *  +---+---------+--------+---------+--------+--------+\n+    *  | 1:1 mapping |  0000  |   0000  |  000x  |  xxxx  |  0041 => 0061 or 1E921 => 1E943\n+    *  +---+---------+--------+---------+--------+--------+\n+    *  | 1:2 mapping |  0002  |   0000  |  xxxx  |  xxxx  |  FB02 => 0066 006C\n+    *  +---+---------+--------+---------+--------+--------+\n+    *  | 1:3 mapping |  0003  |   xxxx  |  xxxx  |  xxxx  |  FB03 => 0066 0066 0069\n+    *  +---+---------+--------+---------+--------+--------+\n@@ -65,3 +74,2 @@\n-    * @return an array of {@code char} values representing the\n-    *         case-folded form of the input code point, null if\n-\t*         there is no mapping defined.\n+    * @return a long value representing the case-folded form of the input\n+    *         code point, encoded as TBD\n@@ -69,2 +77,7 @@\n-    public static int[] foldIfDefined(int cp) {\n-        return getDefined(cp);\n+    public static long fold(int cp) {\n+        var fold = getDefined(cp);\n+        return fold == -1 ? cp : fold;\n+    }\n+\n+    public static boolean isSingleCodePoint(long fold) {\n+        return (fold >> 48) == 0;\n@@ -178,1 +191,1 @@\n-    private static int[] getDefined(int cp) {\n+    private static long getDefined(int cp) {\n@@ -185,1 +198,1 @@\n-                return null;   \/\/ hash miss\n+                return -1;   \/\/ hash miss\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                    assertEquals(expected, foldCase(source), \"CaseFolding.fold()\");\n+                    assertEquals(expected, foldCase(source), \"CaseFolding.fold(): \");\n@@ -288,0 +288,14 @@\n+    private static int[] longToFolding(long value) {\n+        int len = (int) (value >>> 48);\n+        if (len == 0) {\n+            return new int[]{(int) (value & 0xFFFFF)};\n+        } else {\n+            var folding = new int[len];\n+            for (int i = 0; i < len; i++) {\n+                folding[i] = (int) (value & 0xFFFF);\n+                value >>= 16;\n+            }\n+            return folding;\n+        }\n+    }\n+\n@@ -306,7 +320,3 @@\n-            int[] folded = CaseFolding.foldIfDefined(cp);\n-            if (folded == null) {\n-                sb.appendCodePoint(cp);\n-            } else {\n-                for (int f : folded) {\n-                    sb.appendCodePoint(f);\n-                }\n+            int[] folded = longToFolding(CaseFolding.fold(cp));\n+            for (int f : folded) {\n+                sb.appendCodePoint(f);\n","filename":"test\/jdk\/java\/lang\/String\/UnicodeCaseFoldingTest.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"}]}