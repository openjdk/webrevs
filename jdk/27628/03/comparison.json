{"files":[{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -28,1 +27,0 @@\n-import java.io.IOException;\n@@ -32,0 +30,1 @@\n+import java.util.Arrays;\n@@ -33,1 +32,1 @@\n-import java.util.stream.Stream;\n+import java.util.stream.IntStream;\n@@ -45,1 +44,3 @@\n-        var supportedTypes = \"^.*; [CTS]; .*$\";\n+\n+        \/\/ java.lang\n+        var supportedTypes = \"^.*; [CF]; .*$\";  \/\/ full\/1:M case folding\n@@ -47,13 +48,33 @@\n-            .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n-            .map(line -> {\n-                String[] cols = line.split(\"; \");\n-                return new String[] {cols[0], cols[1], cols[2]};\n-            })\n-            .filter(cols -> {\n-                \/\/  the folding case doesn't map back to the original char.\n-                var cp1 = Integer.parseInt(cols[0], 16);\n-                var cp2 = Integer.parseInt(cols[2], 16);\n-                return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n-            })\n-            .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n-            .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    return String.format(\"\\t\\tnew CaseFoldingEntry(0x%04x, %s)\",\n+                            cp,\n+                            Arrays.stream(folding)\n+                                    .mapToObj(f -> String.format(\"0x%04x\", f))\n+                                    .collect(Collectors.joining(\", \", \"new int[] {\", \"}\"))\n+                    );\n+                })\n+                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n+        \/\/ util.regex\n+        var expandedSupportedTypes = \"^.*; [CTS]; .*$\";\n+        var expanded_caseFoldingEntries = Files.lines(caseFoldingTxt)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(expandedSupportedTypes))\n+                .map(line -> {\n+                    String[] cols = line.split(\"; \");\n+                    return new String[]{cols[0], cols[1], cols[2]};\n+                })\n+                .filter(cols -> {\n+                    \/\/ the folding case doesn't map back to the original char.\n+                    var cp1 = Integer.parseInt(cols[0], 16);\n+                    var cp2 = Integer.parseInt(cols[2], 16);\n+                    return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n+                })\n+                .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n+                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n@@ -65,1 +86,0 @@\n-        \/\/ Generate .java file\n@@ -67,5 +87,6 @@\n-            genSrcFile,\n-            Files.lines(templateFile)\n-                .map(line -> line.contains(\"%%%Entries\") ? T_0x0131_0x49 + caseFoldingEntries : line)\n-                .collect(Collectors.toList()),\n-            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+                genSrcFile,\n+                Files.lines(templateFile)\n+                        .map(line -> line.contains(\"%%%Entries\") ? caseFoldingEntries : line)\n+                        .map(line -> line.contains(\"%%%Expanded_Case_Map_Entries\") ? T_0x0131_0x49 + expanded_caseFoldingEntries : line)\n+                        .collect(Collectors.toList()),\n+                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CaseFolding.java","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -75,0 +75,17 @@\n+\n+GENSRC_STRINGCASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/java\/lang\/CaseFolding.java\n+\n+STRINGCASEFOLDING_TEMPLATE := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template\n+CASEFOLDINGTXT := $(MODULE_SRC)\/share\/data\/unicodedata\/CaseFolding.txt\n+\n+$(GENSRC_STRINGCASEFOLDING): $(BUILD_TOOLS_JDK) $(STRINGCASEFOLDING_TEMPLATE) $(CASEFOLDINGTXT)\n+\t$(call LogInfo, Generating $@)\n+\t$(call MakeTargetDir)\n+\t$(TOOL_GENERATECASEFOLDING) \\\n+\t    $(STRINGCASEFOLDING_TEMPLATE) \\\n+\t    $(CASEFOLDINGTXT) \\\n+\t    $(GENSRC_STRINGCASEFOLDING)\n+\n+TARGETS += $(GENSRC_STRINGCASEFOLDING)\n+\n+\n","filename":"make\/modules\/java.base\/gensrc\/GensrcCharacterData.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -53,17 +53,0 @@\n-GENSRC_CASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/util\/regex\/CaseFolding.java\n-\n-CASEFOLDINGTEMP := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template\n-CASEFOLDINGTXT := $(MODULE_SRC)\/share\/data\/unicodedata\/CaseFolding.txt\n-\n-$(GENSRC_CASEFOLDING): $(BUILD_TOOLS_JDK) $(CASEFOLDINGTEMP) $(CASEFOLDINGTXT)\n-\t$(call LogInfo, Generating $@)\n-\t$(call MakeTargetDir)\n-\t$(TOOL_GENERATECASEFOLDING) \\\n-\t    $(CASEFOLDINGTEMP) \\\n-\t    $(CASEFOLDINGTXT) \\\n-\t    $(GENSRC_CASEFOLDING)\n-\n-TARGETS += $(GENSRC_CASEFOLDING)\n-\n-################################################################################\n-\n","filename":"make\/modules\/java.base\/gensrc\/GensrcRegex.gmk","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2183,0 +2183,1 @@\n+     * @see  #equalsFoldCase(String)\n@@ -2192,0 +2193,50 @@\n+    \/**\n+     * Compares this {@code String} to another {@code String} for equality,\n+     * using <em>{@index \"Unicode case folding\"}<\/em>. Two strings are considered equal\n+     * by this method if their case-folded forms are identical.\n+     * <p>\n+     * Case folding is defined by the Unicode Standard in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">CaseFolding.txt<\/a>,\n+     * including 1:M mappings. For example, {@code \"Fuß\".equalsFoldCase(\"FUSS\")}\n+     * returns {@code true}, since the character {@code U+00DF} (sharp s) folds\n+     * to {@code \"ss\"}.\n+     * <p>\n+     * Case folding is locale-independent and language-neutral, unlike\n+     * locale-sensitive transformations such as {@link #toLowerCase()} or\n+     * {@link #toUpperCase()}. It is intended for caseless matching,\n+     * searching, and indexing.\n+     *\n+     * @apiNote\n+     * This method is the Unicode-compliant alternative to\n+     * {@link #equalsIgnoreCase(String)}. It implements full case folding as\n+     * defined by the Unicode Standard, which may differ from the simpler\n+     * per-character mapping performed by {@code equalsIgnoreCase}.\n+     * For example:\n+     * <pre>{@snippet lang=java :\n+     * String a = \"Fuß\";\n+     * String b = \"FUSS\";\n+     * boolean equalsFoldCase = a.equalsFoldCase(b);       \/\/ returns true\n+     * boolean equalsIgnoreCase = a.equalsIgnoreCase(b);   \/\/ returns false\n+     * }<\/pre>\n+     *\n+     * @param  anotherString\n+     *         The {@code String} to compare this {@code String} against\n+     *\n+     * @return  {@code true} if the given object is not {@code null} and represents\n+     *          the same sequence of characters as this string under Unicode case\n+     *          folding; {@code false} otherwise.\n+     *\n+     * @see     #compareToFoldCase(String)\n+     * @see     #equalsIgnoreCase(String)\n+     * @since   26\n+     *\/\n+    public boolean equalsFoldCase(String anotherString) {\n+        if (this == anotherString) {\n+            return true;\n+        }\n+        if (anotherString == null) {\n+            return false;\n+        }\n+        return UNICODE_CASEFOLD_ORDER.compare(this, anotherString) == 0;\n+    }\n+\n@@ -2307,0 +2358,1 @@\n+     * @see     #compareToFoldCase(String)\n@@ -2313,0 +2365,71 @@\n+    \/**\n+     * A Comparator that orders {@code String} objects as by\n+     * {@link #compareToFoldCase(String) compareToFoldCase()}.\n+     *\n+     * @see     #compareToFoldCase(String)\n+     * @since   26\n+     *\/\n+    public static final Comparator<String> UNICODE_CASEFOLD_ORDER\n+            = new FoldCaseComparator();\n+\n+    private static class FoldCaseComparator implements Comparator<String> {\n+\n+        @Override\n+        public int compare(String s1, String s2) {\n+            byte[] v1 = s1.value;\n+            byte[] v2 = s2.value;\n+            if (s1.coder == s2.coder()) {\n+                return s1.coder == LATIN1 ? StringLatin1.compareToFC(v1, v2)\n+                                          : StringUTF16.compareToFC(v1, v2);\n+            }\n+            return s1.coder == LATIN1 ? StringLatin1.compareToFC_UTF16(v1, v2)\n+                                      : StringUTF16.compareToFC_Latin1(v1, v2);\n+        }\n+    }\n+\n+    \/**\n+     * Compares two strings lexicographically using <em>{@index \"Unicode case folding\"}<\/em>.\n+     * This method returns an integer whose sign is that of calling {@code compareTo}\n+     * on the Unicode case folded version of the strings. Unicode Case folding\n+     * eliminates differences in case according to the Unicode Standard, using the\n+     * mappings defined in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">CaseFolding.txt<\/a>,\n+     * including 1:M mappings, such as {@code\"ß\"} → {@code }\"ss\"}.\n+     * <p>\n+     * Case folding is a locale-independent, language-neutral form of case mapping,\n+     * primarily intended for caseless matching. Unlike {@link #compareToIgnoreCase(String)},\n+     * which applies a simpler locale-insensitive uppercase mapping. This method\n+     * follows the Unicode <em>{@index \"full\"}<\/em> case folding, providing stable and\n+     * consistent results across all environments.\n+     * <p>\n+     * Note that this method does <em>not<\/em> take locale into account, and may\n+     * produce results that differ from locale-sensitive ordering. Use\n+     * {@link java.text.Collator} for locale-sensitive comparison.\n+     *\n+     * @apiNote\n+     * This method is the Unicode-compliant alternative to\n+     * {@link #compareToIgnoreCase(String)}. It implements the\n+     * <em>{@index \"full case folding\"}<\/em> as defined by the Unicode Standard, which\n+     * may differ from the simpler per-character mapping performed by\n+     * {@code compareToIgnoreCase}.\n+     * For example:\n+     * <pre>{@snippet lang=java :\n+     * String a = \"Fuß\";\n+     * String b = \"FUSS\";\n+     * int cmpFoldCase = a.compareToFoldCase(b);     \/\/ returns 0\n+     * int cmpIgnoreCase = a.compareToIgnoreCase(b); \/\/ returns > 0\n+     * }<\/pre>\n+     *\n+     * @param   str   the {@code String} to be compared.\n+     * @return  a negative integer, zero, or a positive integer as the specified\n+     *          String is greater than, equal to, or less than this String,\n+     *          ignoring case considerations by case folding.\n+     * @see     java.text.Collator\n+     * @see     #compareToIgnoreCase(String)\n+     * @see     #equalsFoldCase(String)\n+     * @since   26\n+     *\/\n+    public int compareToFoldCase(String str) {\n+        return UNICODE_CASEFOLD_ORDER.compare(this, str);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.java.lang.CaseFolding;\n@@ -65,0 +67,4 @@\n+    static int codePointAt(byte[] value, int index, int end) {\n+        return value[index] & 0xff;\n+    }\n+\n@@ -182,0 +188,134 @@\n+    private static int compareToFC0(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int[] folded1 = null;\n+        int[] folded2 = null;\n+        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n+        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+            int c1, c2;\n+            if (folded1 != null && fk1 < folded1.length) {\n+                c1 = folded1[fk1++];\n+            } else {\n+                c1 = getChar(value, k1++);\n+                folded1 = CaseFolding.foldIfDefined(c1);\n+                fk1 = 0;\n+                if (folded1 != null) {\n+                   c1 = folded1[fk1++];\n+                }\n+            }\n+            if (folded2 != null && fk2 < folded2.length) {\n+                c2 = folded2[fk2++];\n+            } else {\n+                c2 = getChar(other, k2++);\n+                folded2 = CaseFolding.foldIfDefined(c2);\n+                fk2 = 0;\n+                if (folded2 != null) {\n+                    c2 = folded2[fk2++];\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n+            return 1;\n+        }\n+        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    static int compareToFC(byte[] value, byte[] other) {\n+        int len = value.length;\n+        int olen = other.length;\n+        int lim = Math.min(len, olen);\n+        for (int k = 0; k < lim; k++) {\n+            byte b1 = value[k];\n+            byte b2 = other[k];\n+            if (CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n+                continue;\n+            }\n+            int c1 = b1 & 0xff;\n+            int c2 = b2 & 0xff;\n+            if (c1 == 0xdf || c2 == 0xdf) {\n+                return compareToFC0(value, k, len, other, k, olen);\n+            }\n+            return Character.toLowerCase(c1) - Character.toLowerCase(c2);\n+\n+        }\n+        return len - olen;\n+    }\n+\n+    private static int compareToFC0_UTF16(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int[] folded1 = null;\n+        int[] folded2 = null;\n+        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n+        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+            int c1, c2;\n+            if (folded1 != null && fk1 < folded1.length) {\n+                c1 = folded1[fk1++];\n+            } else {\n+                c1 = getChar(value, k1++);\n+                folded1 = CaseFolding.foldIfDefined(c1);\n+                fk1 = 0;\n+                if (folded1 != null) {\n+                    c1 = folded1[fk1++];\n+                }\n+            }\n+            if (folded2 != null && fk2 < folded2.length) {\n+                c2 = folded2[fk2++];\n+            } else {\n+                c2 = StringUTF16.codePointAt(other, k2, olast, true);\n+                k2 += Character.charCount(c2);\n+                folded2 = CaseFolding.foldIfDefined(c2);\n+                fk2 = 0;\n+                if (folded2 != null) {\n+                    c2 = folded2[fk2++];\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n+            return 1;\n+        }\n+        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ latin1 vs utf16\n+    static int compareToFC_UTF16(byte[] value, byte[] other) {\n+        int last = length(value);\n+        int olast = StringUTF16.length(other);\n+        int lim = Math.min(last, olast);\n+        for (int k = 0; k < lim; k++) {\n+            int cp1 = getChar(value, k);\n+            int cp2 = StringUTF16.codePointAt(other, k, olast, true);\n+            if (cp1 == cp2) {\n+                continue;\n+            }\n+            int[] folded = CaseFolding.foldIfDefined(cp1);\n+            if (folded != null) {\n+                if (folded.length > 1) {\n+                    return compareToFC0_UTF16(value, k, last, other, k, olast);\n+                }\n+                cp1 = folded[0];\n+            }\n+            folded = CaseFolding.foldIfDefined(cp2);\n+            if (folded != null) {\n+                if (folded.length > 1) {\n+                    return compareToFC0_UTF16(value, k, last, other, k, olast);\n+                }\n+                cp2 = folded[0];\n+            }\n+            if (cp1 != cp2) {\n+                return cp1 - cp2;\n+            }\n+        }\n+        return last - olast;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.java.lang.CaseFolding;\n@@ -96,1 +97,1 @@\n-    private static int codePointAt(byte[] value, int index, int end, boolean checked) {\n+    static int codePointAt(byte[] value, int index, int end, boolean checked) {\n@@ -595,0 +596,65 @@\n+    public static int compareToFC_Latin1(byte[] value, byte[] other) {\n+        return -StringLatin1.compareToFC_UTF16(other, value);\n+    }\n+\n+    private static int compareToFC0(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int[] folded1 = null;\n+        int[] folded2 = null;\n+        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n+        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+            int c1, c2;\n+            if (folded1 != null && fk1 < folded1.length) {\n+                c1 = folded1[fk1++];\n+            } else {\n+                c1 = codePointAt(value, k1, last, true);\n+                k1 += Character.charCount(c1);\n+                folded1 = CaseFolding.foldIfDefined(c1);\n+                fk1 = 0;\n+                if (folded1 != null) {\n+                    c1 = folded1[fk1++];\n+                }\n+            }\n+            if (folded2 != null && fk2 < folded2.length) {\n+                c2 = folded2[fk2++];\n+            } else {\n+                c2 = codePointAt(other, k2, olast, true);\n+                k2 += Character.charCount(c2);\n+                folded2 = CaseFolding.foldIfDefined(c2);\n+                fk2 = 0;\n+                if (folded2 != null) {\n+                    c2 = folded2[fk2++];\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n+            return 1;\n+        }\n+        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    public static int compareToFC(byte[] value, byte[] other) {\n+        int tlast = length(value);\n+        int olast = length(other);\n+        int k = 0;\n+        while (k < tlast && k < olast) {\n+            int cp1 = codePointAt(value, k, tlast, true);\n+            int cp2 = codePointAt(other, k, olast, true);\n+            if (cp1 == cp2) {\n+                k += Character.charCount(cp1);\n+                continue;\n+            }\n+            if (CaseFolding.isDefined(cp1) || CaseFolding.isDefined(cp2)) {\n+                return compareToFC0(value, k, tlast, other, k, olast);\n+            }\n+            return cp1 - cp2;\n+        }\n+        return tlast - olast;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.java.lang.CaseFolding;\n@@ -47,1 +48,0 @@\n-import jdk.internal.util.regex.CaseFolding;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.java.lang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Map.entry;\n+\n+\/**\n+ * Utility class that handles Unicode case folding properties defined in\n+ * CasingFolding.txt, including 1:M full case folding.\n+ *\/\n+ public final class CaseFolding {\n+\n+    private CaseFolding()  {}\n+\n+    \/**\n+     * Tests whether the specified code point is already in its case-folded form.\n+     * <p>\n+     * A code point is considered folded if it does not have an explicit case\n+     * folding mapping in the Unicode CaseFolding data.\n+     *\n+     * @param  cp\n+     *         the Unicode code point to test\n+     * @return {@code true} if the given code point has no case\n+     *         folding mapping (that is, it is already folded);\n+     *         {@code false} otherwise\n+     *\n+     * @see #fold(int)\n+     *\/\n+ \tpublic static boolean isFolded(int cp) {\n+\t\treturn caseFoldingMap.get(cp) == null;\n+\t}\n+\n+    \/**\n+     * Tests whether the specified code point has a folding mapping entry defined.\n+     *\n+     * @param  cp\n+     *         the Unicode code point to test\n+     * @return {@code true} if the given code point has a case folding mapping entry\n+     *         defined in (@code caseFoldingMap}, {@code false} otherwise\n+     *\/\n+    public static boolean isDefined(int cp) {\n+        return caseFoldingMap.get(cp) != null;\n+    }\n+\n+    \/**\n+     * Returns the case-folded form of the specified code point, according\n+     * to the Unicode case folding mappings.\n+     * <p>\n+     * If the code point has no case folding mapping, this method returns\n+     * the original code point as a single-element array. Otherwise, it\n+     * returns the mapped form, which may consist of one or more {@code char}\n+     * values (to support 1:M mappings).\n+     *\n+     * @param  cp\n+     *         the Unicode code point to fold\n+     * @return an array of {@code char} values representing the\n+     *         case-folded form of the input code point\n+     *\n+     * @see #isFolded(int)\n+     *\/\n+    public static int[] fold(int cp) {\n+        var entry = caseFoldingMap.get(cp);\n+        if (entry != null)\n+          return entry.folding;\n+        return new int[] { cp };\n+    }\n+\n+   \/**\n+     * Returns the case-folded form of the specified code point defined\n+\t * by the Unicode case folding mappings.\n+     * <p>\n+     * If the code point has no case folding mapping defined, this method\n+\t * returns null. Otherwise, it returns the mapped form, which may consist\n+\t * of one or more {@code char} values (to support 1:M mappings).\n+     *\n+     * @param  cp\n+     *         the Unicode code point to fold\n+     * @return an array of {@code char} values representing the\n+     *         case-folded form of the input code point, null if\n+\t *         there is no mapping defined.\n+     *\/\n+    public static int[] foldIfDefined(int cp) {\n+        var entry = caseFoldingMap.get(cp);\n+        return entry != null ? entry.folding : null;\n+    }\n+\n+    \/**\n+     * Returns a case-folded copy of the given {@code String} object, using the\n+     * Unicode case folding mappings defined in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">\n+     * Unicode Case Folding Properties<\/a>.\n+     * <p>\n+     * This is a convenience method intended primarily for testing\n+     * {@link #isFolded(int)} and {@link #fold(int)}. Its implementation is\n+     * not optimized for performance and should not be used in performance-\n+     * sensitive contexts. It exists only until a dedicated\n+     * {@code String.toCaseFold()} method is introduced.\n+     *\n+     * @param s\n+     *        the input string\n+     * @return a {@code String} containing the case-folded form of the input string\n+     *\/\n+    public static String fold(String s) {\n+        int first;\n+        int len = s.length();\n+        int cpCnt = 1;\n+        for (first = 0; first < len; first += cpCnt) {\n+            int cp = s.codePointAt(first);\n+            if (!CaseFolding.isFolded(cp)) {\n+                break;\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        if (first == len) {\n+            return s;\n+        }\n+        StringBuilder sb = new StringBuilder(len);\n+        sb.append(s, 0, first);\n+        for (int i = first; i < len; i += cpCnt) {\n+            int cp = s.codePointAt(i);\n+            if (CaseFolding.isFolded(cp)) {\n+                sb.appendCodePoint(cp);\n+            } else {\n+                int[] folded = CaseFolding.fold(cp);\n+                 if (folded != null) {\n+                     for (int f : folded) {\n+                         sb.appendCodePoint(f);\n+                     }\n+                 }\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n+     * matching, according to the\n+     * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n+     * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n+     * <p>\n+     * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n+     * be applied to literals and (optionally) to character classes. When applied to character classes, each\n+     * character class is expected to be closed under simple case folding. See the standard for the\n+     * detailed explanation and example of \"closed\".\n+     * <p>\n+     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n+     * <ol>\n+     * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n+     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n+     * <\/ol>\n+     * <p>\n+     * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n+     * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n+     * family may appears independently or within a class.\n+     * <p>\n+     * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n+     * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n+     * matching.\n+     * <p>\n+     * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n+     * if their behavior is clearly specified.\n+     * <p>\n+     * This method addresses that requirement for the \"range\" construct within in character class by computing\n+     * the additional characters that should be included to close the range under simple case folding:\n+     * <p>\n+     * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n+     * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n+     * character is not already in the range, then that mapped character (typically lowercase) is added to\n+     * the expansion set.\n+     * <p>\n+     * This allows regex character class \"range\" implementation to use the returned expansion set to support\n+     * additional case-insensitive matching, without duplicating characters already covered by the existing\n+     * regex range implementation. The expectation is the matching is done using both the uppercase and\n+     * lowercase forms of the input character, for example\n+     *\n+     * <pre>{@code\n+     *\n+     *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n+     *           inRange(lower, Character.toLower(ch), upper) ||\n+     *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n+     *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n+     * }<\/pre>\n+     *\n+     * <p>\n+     * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n+     * @param start the starting code point of the character range\n+     * @param end the ending code point of the character range\n+     * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n+     *         those already in the range\n+     *\/\n+    public static int[] getClassRangeClosingCharacters(int start, int end) {\n+        int[] expanded = new int[expanded_case_cps.length];\n+        int off = 0;\n+        for (int cp : expanded_case_cps) {\n+            if (cp >= start && cp <= end) {\n+                int folding = expanded_case_map.get(cp);\n+                if (folding < start || folding > end) {\n+                    expanded[off++] = folding;\n+                }\n+            }\n+        }\n+        return Arrays.copyOf(expanded, off);\n+    }\n+\n+    private static final Map<Integer, Integer> expanded_case_map = Map.ofEntries(\n+%%%Expanded_Case_Map_Entries\n+    );\n+\n+    private static final int[] expanded_case_cps = expanded_case_map.keySet()\n+      .stream()\n+      .mapToInt(Integer::intValue)\n+      .toArray();\n+\n+\n+     private static class CaseFoldingEntry {\n+        final int cp;\n+        final int[] folding;\n+        CaseFoldingEntry next = null;\n+\n+        CaseFoldingEntry(int cp, int[] folding) {\n+            this.cp = cp;\n+            this.folding = folding;\n+        };\n+    }\n+\n+    private static class CaseFoldingMap {\n+\n+        private final CaseFoldingEntry[] entries;\n+\n+        CaseFoldingMap(CaseFoldingEntry[] entries) {\n+            this.entries = new CaseFoldingEntry[entries.length << 1];\n+            for (var entry : entries) {\n+                add(entry);\n+            }\n+        }\n+\n+        public CaseFoldingEntry get(int cp) {\n+            var entries = this.entries;\n+            var index = cp % entries.length;\n+            for (var e = entries[index]; e != null; e = e.next) {\n+                if (e.cp == cp)\n+                    return e;\n+            }\n+            return null;\n+        }\n+\n+        public int getDepth(int cp) {\n+            var entries = this.entries;\n+            var index = cp % entries.length;\n+            int depth = 0;\n+            for (var e = entries[index]; e != null; e = e.next) {\n+                if (e.cp == cp)\n+                    break;\n+                depth++;\n+            }\n+            return depth;\n+        }\n+\n+        private void add(CaseFoldingEntry entry) {\n+            int cp = entry.cp;\n+            var entries = this.entries;\n+            var index = cp % entries.length;\n+            for (var e = entries[index]; e != null; e = e.next) {\n+                if (e.cp == cp) {\n+                    throw new IllegalArgumentException(\"Duplicated mapping entry : \" +\n+                            String.format(\"U+%04x\", cp));\n+                }\n+            }\n+            entry.next = entries[index];\n+            entries[index] = entry;\n+        }\n+    }\n+\n+    private final static CaseFoldingEntry[] caseFoldingEntries = {\n+%%%Entries\n+    };\n+\n+    private final static CaseFoldingMap caseFoldingMap = new CaseFoldingMap(caseFoldingEntries);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util.regex;\n-\n-import java.util.Arrays;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Map.entry;\n-\n-public final class CaseFolding {\n-\n-    private static final Map<Integer, Integer> expanded_case_map = Map.ofEntries(\n-%%%Entries\n-    );\n-\n-    private static final int[] expanded_case_cps = expanded_case_map.keySet()\n-      .stream()\n-      .mapToInt(Integer::intValue)\n-      .toArray();\n-\n-    private CaseFolding()  {}\n-\n-    \/**\n-     * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n-     * matching, according to the\n-     * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n-     * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n-     * <p>\n-     * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n-     * be applied to literals and (optionally) to character classes. When applied to character classes, each\n-     * character class is expected to be closed under simple case folding. See the standard for the\n-     * detailed explanation and example of \"closed\".\n-     * <p>\n-     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n-     * <ol>\n-     * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n-     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n-     * <\/ol>\n-     * <p>\n-     * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n-     * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n-     * family may appears independently or within a class.\n-     * <p>\n-     * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n-     * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n-     * matching.\n-     * <p>\n-     * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n-     * if their behavior is clearly specified.\n-     * <p>\n-     * This method addresses that requirement for the \"range\" construct within in character class by computing\n-     * the additional characters that should be included to close the range under simple case folding:\n-     * <p>\n-     * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n-     * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n-     * character is not already in the range, then that mapped character (typically lowercase) is added to\n-     * the expansion set.\n-     * <p>\n-     * This allows regex character class \"range\" implementation to use the returned expansion set to support\n-     * additional case-insensitive matching, without duplicating characters already covered by the existing\n-     * regex range implementation. The expectation is the matching is done using both the uppercase and\n-     * lowercase forms of the input character, for example\n-     *\n-     * <pre>{@code\n-     *\n-     *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n-     *           inRange(lower, Character.toLower(ch), upper) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n-     * }<\/pre>\n-     *\n-     * <p>\n-     * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n-     * @param start the starting code point of the character range\n-     * @param end the ending code point of the character range\n-     * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n-     *         those already in the range\n-     *\/\n-    public static int[] getClassRangeClosingCharacters(int start, int end) {\n-        int[] expanded = new int[expanded_case_cps.length];\n-        int off = 0;\n-        for (int cp : expanded_case_cps) {\n-            if (cp >= start && cp <= end) {\n-                int folding = expanded_case_map.get(cp);\n-                if (folding < start || folding > end) {\n-                    expanded[off++] = folding;\n-                }\n-            }\n-        }\n-        return Arrays.copyOf(expanded, off);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary tests unicode case-folding based String comparison and equality\n+ * @bug 4397357\n+ * @library \/lib\/testlibrary\/java\/lang\n+ * @compile --add-exports java.base\/jdk.internal.java.lang=ALL-UNNAMED\n+ * UnicodeCaseFoldingTest.java\n+ * @run junit\/othervm --add-exports java.base\/jdk.internal.java.lang=ALL-UNNAMED\n+ * UnicodeCaseFoldingTest\n+ *\/\n+import java.nio.file.Files;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import jdk.internal.java.lang.CaseFolding;\n+\n+public class UnicodeCaseFoldingTest {\n+\n+    @Test\n+    void testAllCommnFullCodePointsListedInCaseFoldinigTxt() throws Throwable {\n+        var filter = \"^.*; [CF]; .*$\";  \/\/ C=common, F=full, for full case folding\n+        var results = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(filter))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var source = new String(Character.toChars(cp));\n+                    var expected = new String(folding, 0, folding.length);\n+                    \/\/ (1) Verify the folding result matches expected\n+                    assertEquals(expected, CaseFolding.fold(source), \"CaseFolding.fold()\");\n+\n+                    \/\/ (2) Verify compareToFoldCase() result\n+                    assertEquals(0, source.compareToFoldCase(expected), \"source.compareToFoldCase(expected)\");\n+                    assertEquals(0, expected.compareToFoldCase(source), \"expected.compareToFoldCase(source)\");\n+\n+                    \/\/ (3) Verify equalsFoldCase() result\n+                    assertEquals(true, source.equalsFoldCase(expected), \"source.equalsFoldCase(expected)\");\n+                    assertEquals(true, expected.equalsFoldCase(source), \"expected.equalsFoldCase(source)\");\n+                    return null;\n+                })\n+                .filter(error -> error != null)\n+                .toArray();\n+        assertEquals(0, results.length);\n+    }\n+\n+    @Test\n+    void testAllSimpleCodePointsListedInCaseFoldinigTxt() throws Throwable {\n+        \/\/ S=simple, for simple case folding. The simple case folding should still matches\n+        var filter = \"^.*; [S]; .*$\";\n+        var results = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(filter))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var source = new String(Character.toChars(cp));\n+                    var expected = new String(folding, 0, folding.length);\n+\n+                    \/\/ (1) Verify compareToFoldCase() result\n+                    assertEquals(0, source.compareToFoldCase(expected), \"source.compareToFoldCase(expected)\");\n+                    assertEquals(0, expected.compareToFoldCase(source), \"expected.compareToFoldCase(source)\");\n+\n+                    \/\/ (2) Verify equalsFoldCase() result\n+                    assertEquals(true, source.equalsFoldCase(expected), \"source.equalsFoldCase(expected)\");\n+                    assertEquals(true, expected.equalsFoldCase(source), \"expected.equalsFoldCase(source)\");\n+                    return null;\n+                })\n+                .filter(error -> error != null)\n+                .toArray();\n+        assertEquals(0, results.length);\n+    }\n+\n+    @Test\n+    public void testAllCodePointsFoldToThemselvesIfNotListed() throws Exception {\n+        \/\/ Collect all code points that appear in CaseFolding.txt\n+        var listed = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(\"^.*; [CF]; .*$\"))\n+                .map(line -> Integer.parseInt(line.split(\"; \")[0], 16))\n+                .collect(Collectors.toSet());\n+\n+        var failures = new ArrayList<String>();\n+\n+        \/\/ Scan BMP + Supplementary Plane 1 (U+0000..U+1FFFF)\n+        for (int cp = Character.MIN_CODE_POINT; cp <= 0x1FFFF; cp++) {\n+            if (!Character.isDefined(cp)) {\n+                continue;     \/\/ skip undefined\n+            }\n+            if (Character.isSurrogate((char) cp)) {\n+                continue; \/\/ skip surrogate code units\n+\n+            }\n+            if (listed.contains(cp)) {\n+                continue;          \/\/ already tested separately\n+            }\n+            String s = new String(Character.toChars(cp));\n+            String folded = CaseFolding.fold(s);\n+            if (!s.equals(folded)) {\n+                failures.add(String.format(\"Unexpected folding: U+%04X '%s' → '%s'\", cp, s, folded));\n+            }\n+        }\n+\n+        assertEquals(0, failures.size(),\n+                () -> \"Some unlisted code points folded unexpectedly:\\n\"\n+                + String.join(\"\\n\", failures));\n+    }\n+\n+    @ParameterizedTest(name = \"CaseFold \\\"{0}\\\" → \\\"{1}\\\"\")\n+    @MethodSource(\"caseFoldTestCases\")\n+    void testIndividualCaseFolding(String input, String expected) {\n+        assertEquals(expected, CaseFolding.fold(input));\n+    }\n+\n+    static Stream<Arguments> caseFoldTestCases() {\n+        return Stream.of(\n+                \/\/ ASCII simple cases\n+                Arguments.of(\"ABC\", \"abc\"),\n+                Arguments.of(\"already\", \"already\"),\n+                Arguments.of(\"MiXeD123\", \"mixed123\"),\n+                \/\/ --- Latin-1 to non-Latin-1 fold ---\n+                Arguments.of(\"aBc\\u00B5Efg\", \"abc\\u03BCefg\"), \/\/ \"µ\" → \"μ\"\n+                Arguments.of(\"test\\u00B5\\ud801\\udc00X\", \"test\\u03bc\\ud801\\udc28x\"),\n+                \/\/ German Eszett\n+                Arguments.of(\"Stra\\u00DFe\", \"strasse\"), \/\/ \"Straße\"\n+                Arguments.of(\"\\u1E9E\", \"ss\"), \/\/ \"ẞ\"  capital sharp S\n+                \/\/ Turkish dotted I \/ dotless i\n+                Arguments.of(\"I\", \"i\"),\n+                Arguments.of(\"\\u0130\", \"i\\u0307\"), \/\/ capital dotted I → \"i + dot above\"\n+                Arguments.of(\"\\u0069\\u0307\", \"i\\u0307\"), \/\/ small i + dot above remains\n+                Arguments.of(\"\\u0131\", \"\\u0131\"), \/\/ \"ı\" (dotless i stays dotless)\n+\n+                \/\/ Greek special cases ---\n+                Arguments.of(\"\\u039F\\u03A3\", \"\\u03BF\\u03C3\"), \/\/ \"ΟΣ\" → \"οσ\"  final sigma always folds to normal sigma\n+                Arguments.of(\"\\u1F88\", \"\\u1F00\\u03B9\"), \/\/ \"ᾈ\" → \"ἀι\"    Alpha with psili + ypogegrammeni\n+                Arguments.of(\"\\u039C\\u03AC\\u03CA\\u03BF\\u03C2\", \"\\u03BC\\u03AC\\u03CA\\u03BF\\u03C3\"), \/\/ \"Μάϊος\" → \"μάϊοσ\"\n+                Arguments.of(\"\\u1F08\", \"\\u1F00\"), \/\/  Ἀ (Capital Alpha with psili) → ἀ\n+\n+                \/\/ Supplementary Plane characters\n+                Arguments.of(\"\\uD801\\uDC00\", \"\\uD801\\uDC28\"), \/\/ Deseret Capital Letter Long I → Small\n+                Arguments.of(\"\\uD801\\uDC01\", \"\\uD801\\uDC29\"), \/\/ Deseret Capital Letter Long E → Small\n+\n+                \/\/ Supplementary inside ASCII\n+                Arguments.of(\"abc\\uD801\\uDC00def\", \"abc\\uD801\\uDC28def\"),\n+                \/\/ Ligatures and compatibility folds\n+                Arguments.of(\"\\uFB00\", \"ff\"), \/\/ ﬀ → ff\n+                Arguments.of(\"\\uFB03\", \"ffi\"), \/\/ ﬃ → ffi\n+                Arguments.of(\"\\u212A\", \"k\"), \/\/ Kelvin sign → k\n+\n+                Arguments.of(\"abc\\uFB00def\", \"abcffdef\"), \/\/ ﬀ → ff\n+                Arguments.of(\"abc\\uFB03def\", \"abcffidef\"), \/\/ ﬃ → ffi\n+                Arguments.of(\"abc\\u212Adef\", \"abckdef\"), \/\/ Kelvin sign → k\n+\n+                \/\/ --- Fullwidth ---\n+                Arguments.of(\"\\uFF21\\uFF22\\uFF23\", \"\\uFF41\\uFF42\\uFF43\"), \/\/ \"ＡＢＣ\" → \"ａｂｃ\"\n+\n+                \/\/ --- Armenian ---\n+                Arguments.of(\"\\u0531\", \"\\u0561\"), \/\/ \"Ա\" → \"ա\"\n+\n+                \/\/ --- Cherokee ---\n+                Arguments.of(\"\\u13A0\", \"\\u13A0\"), \/\/ Capital Cherokee A folds to itself\n+                Arguments.of(\"\\uAB70\", \"\\u13A0\") \/\/ Small Cherokee A folds Capital Cherokee A\n+        );\n+    }\n+\n+    static Stream<Arguments> caseFoldEqualProvider() {\n+        return Stream.of(\n+                Arguments.of(\"abc\", \"ABC\"),\n+                Arguments.of(\"aBcDe\", \"AbCdE\"),\n+                Arguments.of(\"\\u00C0\\u00E7\", \"\\u00E0\\u00C7\"), \/\/ Àç vs àÇ\n+                Arguments.of(\"straße\", \"STRASSE\"), \/\/ ß → ss\n+                Arguments.of(\"\\uD83C\\uDDE6\", \"\\uD83C\\uDDE6\"), \/\/ 🇦 vs 🇦\n+                Arguments.of(\"\\u1E9E\", \"ss\"), \/\/ ẞ (capital sharp S)\n+                Arguments.of(\"\\u03A3\", \"\\u03C3\"), \/\/ Σ vs σ (Greek Sigma)\n+                Arguments.of(\"\\u03C3\", \"\\u03C2\"), \/\/ σ vs ς (Greek sigma\/final sigma)\n+                Arguments.of(\"\\u212B\", \"\\u00E5\"), \/\/ Å (Angstrom sign) vs å\n+                Arguments.of(\"\\uFB00\", \"ff\"), \/\/ ﬀ (ligature)\n+                Arguments.of(\"\\u01C5\", \"\\u01C5\"), \/\/ ǅ (Latin capital D with small z with caron)\n+                Arguments.of(\"Caf\\u00E9\", \"CAF\\u00C9\"), \/\/ Café vs CAFÉ\n+                Arguments.of(\"\\u03BA\\u03B1\\u03BB\\u03B7\\u03BC\\u03AD\\u03C1\\u03B1\", \"\\u039A\\u0391\\u039B\\u0397\\u039C\\u0388\\u03A1\\u0391\"), \/\/ καλημέρα vs ΚΑΛΗΜΕΡΑ\n+                Arguments.of(\"\\u4E2D\\u56FD\", \"\\u4E2D\\u56FD\"), \/\/ 中国\n+                Arguments.of(\"\\u03B1\", \"\\u0391\"), \/\/ α vs Α (Greek alpha)\n+                Arguments.of(\"\\u212B\", \"\\u00C5\"), \/\/ Å vs Å\n+                \/\/ from StringCompareToIgnoreCase\n+                Arguments.of(\"\\u0100\\u0102\\u0104\\u0106\\u0108\", \"\\u0100\\u0102\\u0104\\u0106\\u0109\"), \/\/ ĀĂĄĆĈ vs ĀĂĄĆĉ\n+                Arguments.of(\"\\u0101\\u0103\\u0105\\u0107\\u0109\", \"\\u0100\\u0102\\u0104\\u0106\\u0109\"), \/\/ āăąćĉ vs ĀĂĄĆĉ\n+                Arguments.of(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\",\n+                        \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\"), \/\/ 𐐀𐐁𐐂𐐃𐐄 vs 𐐀𐐁𐐂𐐃𐐬\n+                Arguments.of(\"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\",\n+                        \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\") \/\/ 𐐨𐐩𐐪𐐫𐐬 vs 𐐀𐐁𐐂𐐃𐐬\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"caseFoldEqualProvider\")\n+    void testcompareToFoldCaseEquals(String s1, String s2) {\n+        assertEquals(0, s1.compareToFoldCase(s2));\n+        assertEquals(0, s2.compareToFoldCase(s1));\n+        assertEquals(true, s1.equalsFoldCase(s2));\n+        assertEquals(true, s2.equalsFoldCase(s1));\n+        assertEquals(CaseFolding.fold(s1), CaseFolding.fold(s2));\n+    }\n+\n+    static Stream<Arguments> caseFoldOrderingProvider() {\n+        return Stream.of(\n+                Arguments.of(\"asa\", \"aß\", -1), \/\/ ß → ss → \"asa\" < \"ass\"\n+                Arguments.of(\"aß\", \"asa\", +1),\n+                Arguments.of(\"a\\u00DF\", \"ass\", 0), \/\/ aß vs ass\n+                Arguments.of(\"\\uFB03\", \"ffi\", 0), \/\/ ﬃ (ligature)\n+                Arguments.of(\"\\u00C5\", \"Z\", 1), \/\/ Å vs Z\n+                Arguments.of(\"A\", \"\\u00C0\", -1), \/\/ A vs À\n+                Arguments.of(\"\\u03A9\", \"\\u03C9\", 0), \/\/ Ω vs ω\n+                Arguments.of(\"\\u03C2\", \"\\u03C3\", 0), \/\/ ς vs σ\n+                Arguments.of(\"\\uD835\\uDD23\", \"R\", 1), \/\/ 𝔯 (fraktur r) vs R\n+                Arguments.of(\"\\uFF26\", \"E\", 1), \/\/ Ｆ (full-width F) vs E\n+                Arguments.of(\"\\u00C9clair\", \"Eclair\", 1) \/\/ Éclair vs Eclair\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"caseFoldOrderingProvider\")\n+    void testcompareToFoldCaseOrdering(String s1, String s2, int expectedSign) {\n+        int cmp = s1.compareToFoldCase(s2);\n+        assertEquals(expectedSign, Integer.signum(cmp));\n+    }\n+\n+    static Stream<Arguments> roundTripProvider() {\n+        return Stream.of(\n+                Arguments.of(\"abc\"),\n+                Arguments.of(\"ABC\"),\n+                Arguments.of(\"straße\"),\n+                Arguments.of(\"Àç\"),\n+                Arguments.of(\"aß\"),\n+                Arguments.of(\"\\uFB02uff\"), \/\/ ﬂuff (ligature in \"fluff\")\n+                Arguments.of(\"\\u00C9COLE\") \/\/ ÉCOLE\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"roundTripProvider\")\n+    void testCaseFoldRoundTrip(String s) {\n+        String folded = CaseFolding.fold(s);\n+        assertEquals(0, s.compareToFoldCase(folded));\n+        assertEquals(0, folded.compareToFoldCase(s));\n+        assertEquals(true, s.equalsFoldCase(folded));\n+        assertEquals(true, folded.equalsFoldCase(s));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/UnicodeCaseFoldingTest.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::compareToFoldCase performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class StringCompareToFoldCase {\n+\n+    private String asciiUpper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+    private String asciiUpperLower = \"ABCDEFGHIJKLMNOpqrstuvwxyz\";\n+    private String asciiLower = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+    private String asciiWithDF = \"abcdßßßßßßßßßßßßßßßßWXYZ\";\n+    private String asciiWithDFSS = \"abcdssssssssssssssssßßßßßßßßWXYZ\";\n+\n+    private String asciiLatine1 = \"ABCDEFGHIJKLMNOpqrstuvwxyz0\";\n+    private String asciiLatin1UTF16 = \"abcdefghijklmnopqrstuvwxyz\\u0391\";\n+\n+    private String greekUpper = \"\\u0391\\u0392\\u0393\\u0394\\u0395\\u0391\\u0392\\u0393\\u0394\\u0395\"; \/\/ ΑΒΓΔΕ\n+    private String greekUpperLower = \"\\u0391\\u0392\\u0393\\u0394\\u0395\\u0391\\u0392\\u0393\\u0394\\u03B5\"; \/\/ ΑΒΓΔε\n+    private String greekLower = \"\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\"; \/\/ αβγδε\n+\n+    public String supUpper = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\";\n+    public String supUpperLower = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\";\n+    public String supLower = \"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\";\n+\n+    @Benchmark\n+    public int asciiUpperLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLower() {\n+        return greekUpper.compareToIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLower() {\n+        return greekUpper.compareToIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int latin1UTF16() {\n+        return asciiLatine1.compareToIgnoreCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public int supUpperLower() {\n+        return supUpper.compareToIgnoreCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLower() {\n+        return supUpper.compareToIgnoreCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiUpperLowerFC() {\n+        return asciiUpper.compareToFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLowerFC() {\n+        return asciiUpper.compareToFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiWithDFFC() {\n+        return asciiWithDF.compareToFoldCase(asciiWithDFSS);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLowerFC() {\n+        return greekUpper.compareToFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLowerFC() {\n+        return greekUpper.compareToFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int latin1UTF16FC() {\n+        return asciiLatine1.compareToFoldCase(asciiLatin1UTF16); }\n+\n+    @Benchmark\n+    public int supUpperLowerFC() {\n+        return supUpper.compareToFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLowerFC() {\n+        return supUpper.compareToFoldCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiUpperLowerEQ() {\n+        return asciiUpper.equalsIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiLowerEQ() {\n+        return asciiUpper.equalsIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekUpperLowerEQ() {\n+        return greekUpper.equalsIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekLowerEQ() {\n+        return greekUpper.equalsIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public boolean latin1UTF16EQ() {\n+        return asciiLatine1.equalsIgnoreCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public boolean supUpperLowerEQ() {\n+        return supUpper.equalsIgnoreCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean supLowerEQ() {\n+        return supUpper.equalsIgnoreCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiUpperLowerEQFC() {\n+        return asciiUpper.equalsFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiLowerEQFC() {\n+        return asciiUpper.equalsFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekUpperLowerEQFC() {\n+        return greekUpper.equalsFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekLowerEQFC() {\n+        return greekUpper.equalsFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public boolean latin1UTF16EQFC() {\n+        return asciiLatine1.equalsFoldCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public boolean supUpperLowerEQFC() {\n+        return supUpper.equalsFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean supLowerEQFC() {\n+        return supUpper.equalsFoldCase(supLower);\n+    }\n+ }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToFoldCase.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"}]}