{"files":[{"patch":"@@ -57,4 +57,0 @@\n-                    var foldingChars = Arrays.stream(folding)\n-                            .mapToObj(Character::toChars)\n-                            .flatMapToInt(chars -> IntStream.range(0, chars.length).map(i -> (int) chars[i]))\n-                            .toArray();\n@@ -63,3 +59,3 @@\n-                            Arrays.stream(foldingChars)\n-                                    .mapToObj(c -> String.format(\"0x%04x\", c))\n-                                    .collect(Collectors.joining(\", \", \"new char[] {\", \"}\"))\n+                            Arrays.stream(folding)\n+                                    .mapToObj(f -> String.format(\"0x%04x\", f))\n+                                    .collect(Collectors.joining(\", \", \"new int[] {\", \"}\"))\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CaseFolding.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -188,9 +188,7 @@\n-    public static int compareToFC(byte[] value, byte[] other) {\n-        int len1 = value.length;\n-        int len2 = other.length;\n-        char[] folded1 = null;\n-        char[] folded2 = null;\n-        int k1 = 0, k2 = 0, fk1 = 0, fk2 = 0;\n-        while ((k1 < len1 || folded1 != null && fk1 < folded1.length) &&\n-               (k2 < len2 || folded2 != null && fk2 < folded2.length)) {\n-            char c1, c2;\n+    private static int compareToFC0(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int[] folded1 = null;\n+        int[] folded2 = null;\n+        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n+        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+            int c1, c2;\n@@ -200,2 +198,2 @@\n-                int cp = codePointAt(value, k1++, len1);  \/\/ no surrogate\n-                folded1 = CaseFolding.foldIfDefined(cp);\n+                c1 = getChar(value, k1++);\n+                folded1 = CaseFolding.foldIfDefined(c1);\n@@ -203,4 +201,2 @@\n-                if (folded1 == null) {\n-                    c1 = (char)cp;\n-                } else {\n-                    c1 = folded1[fk1++];\n+                if (folded1 != null) {\n+                   c1 = folded1[fk1++];\n@@ -212,2 +208,2 @@\n-                int cp = codePointAt(other, k2++, len2);\n-                folded2 = CaseFolding.foldIfDefined(cp);\n+                c2 = getChar(other, k2++);\n+                folded2 = CaseFolding.foldIfDefined(c2);\n@@ -215,3 +211,1 @@\n-                if (folded2 == null) {\n-                    c2 = (char)cp;\n-                } else {\n+                if (folded2 != null) {\n@@ -225,1 +219,1 @@\n-        if (k1 < len1 || folded1 != null && fk1 < folded1.length) {\n+        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n@@ -228,1 +222,1 @@\n-        if (k2 < len2 || folded2 != null && fk2 < folded2.length) {\n+        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n@@ -234,6 +228,20 @@\n-    public static int compareToFC_UTF16(byte[] value, byte[] other) {\n-        int len1 = value.length;\n-        int len2 = StringUTF16.length(other);\n-        char[] folded1 = null;\n-        char[] folded2 = null;\n-        int k1 = 0, k2 = 0, fk1 = 0, fk2 = 0;\n+    static int compareToFC(byte[] value, byte[] other) {\n+        int len = value.length;\n+        int olen = other.length;\n+        int lim = Math.min(len, olen);\n+        for (int k = 0; k < lim; k++) {\n+            byte b1 = value[k];\n+            byte b2 = other[k];\n+            if (CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n+                continue;\n+            }\n+            int c1 = b1 & 0xff;\n+            int c2 = b2 & 0xff;\n+            if (c1 == 0xdf || c2 == 0xdf) {\n+                return compareToFC0(value, k, len, other, k, olen);\n+            }\n+            return Character.toLowerCase(c1) - Character.toLowerCase(c2);\n+\n+        }\n+        return len - olen;\n+    }\n@@ -241,3 +249,7 @@\n-        while ((k1 < len1 || folded1 != null && fk1 < folded1.length) &&\n-               (k2 < len2 || folded2 != null && fk2 < folded2.length)) {\n-            char c1, c2;\n+    private static int compareToFC0_UTF16(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int[] folded1 = null;\n+        int[] folded2 = null;\n+        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n+        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n+            int c1, c2;\n@@ -247,2 +259,2 @@\n-                int cp = codePointAt(value, k1++, len1);\n-                folded1 = CaseFolding.foldIfDefined(cp);\n+                c1 = getChar(value, k1++);\n+                folded1 = CaseFolding.foldIfDefined(c1);\n@@ -250,3 +262,1 @@\n-                if (folded1 == null) {\n-                    c1 = (char)cp;\n-                } else {\n+                if (folded1 != null) {\n@@ -259,3 +269,3 @@\n-                int cp = StringUTF16.codePointAt(other, k2, len2);\n-                k2 += Character.charCount(cp);\n-                folded2 = CaseFolding.foldIfDefined(cp);\n+                c2 = StringUTF16.codePointAt(other, k2, olast, true);\n+                k2 += Character.charCount(c2);\n+                folded2 = CaseFolding.foldIfDefined(c2);\n@@ -263,3 +273,1 @@\n-                if (folded2 == null) {\n-                    c2 = (char)cp;\n-                } else {\n+                if (folded2 != null) {\n@@ -273,1 +281,1 @@\n-        if (k1 < len1 || folded1 != null && fk1 < folded1.length) {\n+        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n@@ -276,1 +284,1 @@\n-        if (k2 < len2 || folded2 != null && fk2 < folded2.length) {\n+        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n@@ -282,0 +290,32 @@\n+    \/\/ latin1 vs utf16\n+    static int compareToFC_UTF16(byte[] value, byte[] other) {\n+        int last = length(value);\n+        int olast = StringUTF16.length(other);\n+        int lim = Math.min(last, olast);\n+        for (int k = 0; k < lim; k++) {\n+            int cp1 = getChar(value, k);\n+            int cp2 = StringUTF16.codePointAt(other, k, olast, true);\n+            if (cp1 == cp2) {\n+                continue;\n+            }\n+            int[] folded = CaseFolding.foldIfDefined(cp1);\n+            if (folded != null) {\n+                if (folded.length > 1) {\n+                    return compareToFC0_UTF16(value, k, last, other, k, olast);\n+                }\n+                cp1 = folded[0];\n+            }\n+            folded = CaseFolding.foldIfDefined(cp2);\n+            if (folded != null) {\n+                if (folded.length > 1) {\n+                    return compareToFC0_UTF16(value, k, last, other, k, olast);\n+                }\n+                cp2 = folded[0];\n+            }\n+            if (cp1 != cp2) {\n+                return cp1 - cp2;\n+            }\n+        }\n+        return last - olast;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":84,"deletions":44,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    private static int codePointAt(byte[] value, int index, int end, boolean checked) {\n+    static int codePointAt(byte[] value, int index, int end, boolean checked) {\n@@ -600,8 +600,6 @@\n-    public static int compareToFC(byte[] value, byte[] other) {\n-        int len1 = length(value);\n-        int len2 = length(other);\n-        char[] folded1 = null;\n-        char[] folded2 = null;\n-        int k1 = 0, k2 = 0, fk1 = 0, fk2 = 0;\n-        while ((k1 < len1 || folded1 != null && fk1 < folded1.length) &&\n-               (k2 < len2 || folded2 != null && fk2 < folded2.length)) {\n+    private static int compareToFC0(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int[] folded1 = null;\n+        int[] folded2 = null;\n+        int k1 = off, k2 = ooff, fk1 = 0, fk2 = 0;\n+        while ((k1 < last || folded1 != null && fk1 < folded1.length) &&\n+               (k2 < olast || folded2 != null && fk2 < folded2.length)) {\n@@ -610,2 +608,1 @@\n-                c1 = Character.codePointAt(folded1, fk1);\n-                fk1 += Character.charCount(c1);\n+                c1 = folded1[fk1++];\n@@ -613,3 +610,3 @@\n-                int cp = codePointAt(value, k1, len1, true);\n-                k1 += Character.charCount(cp);\n-                folded1 = CaseFolding.foldIfDefined(cp);\n+                c1 = codePointAt(value, k1, last, true);\n+                k1 += Character.charCount(c1);\n+                folded1 = CaseFolding.foldIfDefined(c1);\n@@ -617,5 +614,2 @@\n-                if (folded1 == null) {\n-                    c1 = cp;\n-                } else {\n-                   c1 = Character.codePointAt(folded1, 0);\n-                   fk1 += Character.charCount(c1);\n+                if (folded1 != null) {\n+                    c1 = folded1[fk1++];\n@@ -625,2 +619,1 @@\n-                c2 = Character.codePointAt(folded2, fk2);\n-                fk2 += Character.charCount(c2);\n+                c2 = folded2[fk2++];\n@@ -628,3 +621,3 @@\n-                int cp = codePointAt(other, k2, len2, true);\n-                k2 += Character.charCount(cp);\n-                folded2 = CaseFolding.foldIfDefined(cp);\n+                c2 = codePointAt(other, k2, olast, true);\n+                k2 += Character.charCount(c2);\n+                folded2 = CaseFolding.foldIfDefined(c2);\n@@ -632,5 +625,2 @@\n-                if (folded2 == null) {\n-                    c2 = cp;\n-                } else {\n-                   c2 = Character.codePointAt(folded2, 0);\n-                   fk2 += Character.charCount(c2);\n+                if (folded2 != null) {\n+                    c2 = folded2[fk2++];\n@@ -643,1 +633,1 @@\n-        if (k1 < len1 || folded1 != null && fk1 < folded1.length) {\n+        if (k1 < last || folded1 != null && fk1 < folded1.length) {\n@@ -646,1 +636,1 @@\n-        if (k2 < len2 || folded2 != null && fk2 < folded2.length) {\n+        if (k2 < olast || folded2 != null && fk2 < folded2.length) {\n@@ -652,0 +642,19 @@\n+    public static int compareToFC(byte[] value, byte[] other) {\n+        int tlast = length(value);\n+        int olast = length(other);\n+        int k = 0;\n+        while (k < tlast && k < olast) {\n+            int cp1 = codePointAt(value, k, tlast, true);\n+            int cp2 = codePointAt(other, k, olast, true);\n+            if (cp1 == cp2) {\n+                k += Character.charCount(cp1);\n+                continue;\n+            }\n+            if (CaseFolding.isDefined(cp1) || CaseFolding.isDefined(cp2)) {\n+                return compareToFC0(value, k, tlast, other, k, olast);\n+            }\n+            return cp1 - cp2;\n+        }\n+        return tlast - olast;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":40,"deletions":31,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n- * Utility class for {@code String.toCaseFold()} that handles Unicode case folding\n- * properties defined in CasingFolding.txt, including 1:M full case folding.\n+ * Utility class that handles Unicode case folding properties defined in\n+ * CasingFolding.txt, including 1:M full case folding.\n@@ -61,0 +61,12 @@\n+    \/**\n+     * Tests whether the specified code point has a folding mapping entry defined.\n+     *\n+     * @param  cp\n+     *         the Unicode code point to test\n+     * @return {@code true} if the given code point has a case folding mapping entry\n+     *         defined in (@code caseFoldingMap}, {@code false} otherwise\n+     *\/\n+    public static boolean isDefined(int cp) {\n+        return caseFoldingMap.get(cp) != null;\n+    }\n+\n@@ -77,1 +89,1 @@\n-    public static char[] fold(int cp) {\n+    public static int[] fold(int cp) {\n@@ -81,1 +93,1 @@\n-        return Character.toChars(cp);\n+        return new int[] { cp };\n@@ -98,1 +110,1 @@\n-    public static char[] foldIfDefined(int cp) {\n+    public static int[] foldIfDefined(int cp) {\n@@ -140,2 +152,6 @@\n-                char[] folded = CaseFolding.fold(cp);\n-                sb.append(folded);\n+                int[] folded = CaseFolding.fold(cp);\n+                 if (folded != null) {\n+                     for (int f : folded) {\n+                         sb.appendCodePoint(f);\n+                     }\n+                 }\n@@ -230,1 +246,1 @@\n-        final char[] folding;\n+        final int[] folding;\n@@ -233,1 +249,1 @@\n-        CaseFoldingEntry(int cp, char[] folding) {\n+        CaseFoldingEntry(int cp, int[] folding) {\n@@ -235,1 +251,1 @@\n-             this.folding = folding;\n+            this.folding = folding;\n@@ -237,8 +253,0 @@\n-\n-        public String toString() {\n-            return String.format(\"[%x %s]\",\n-                    cp,\n-                    IntStream.range(0, folding.length)\n-\t\t\t\t\t         .mapToObj(i -> String.format(\"%x\", (int)folding[i]))\n-                             .collect(Collectors.joining(\" \", \"\", \"\")));\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::compareToFoldCase performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class StringCompareToFoldCase {\n+\n+    private String asciiUpper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+    private String asciiUpperLower = \"ABCDEFGHIJKLMNOpqrstuvwxyz\";\n+    private String asciiLower = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+    private String asciiWithDF = \"abcdßßßßßßßßßßßßßßßßWXYZ\";\n+    private String asciiWithDFSS = \"abcdssssssssssssssssßßßßßßßßWXYZ\";\n+\n+    private String asciiLatine1 = \"ABCDEFGHIJKLMNOpqrstuvwxyz0\";\n+    private String asciiLatin1UTF16 = \"abcdefghijklmnopqrstuvwxyz\\u0391\";\n+\n+    private String greekUpper = \"\\u0391\\u0392\\u0393\\u0394\\u0395\\u0391\\u0392\\u0393\\u0394\\u0395\"; \/\/ ΑΒΓΔΕ\n+    private String greekUpperLower = \"\\u0391\\u0392\\u0393\\u0394\\u0395\\u0391\\u0392\\u0393\\u0394\\u03B5\"; \/\/ ΑΒΓΔε\n+    private String greekLower = \"\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\"; \/\/ αβγδε\n+\n+    public String supUpper = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\";\n+    public String supUpperLower = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\";\n+    public String supLower = \"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\";\n+\n+    @Benchmark\n+    public int asciiUpperLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLower() {\n+        return greekUpper.compareToIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLower() {\n+        return greekUpper.compareToIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int latin1UTF16() {\n+        return asciiLatine1.compareToIgnoreCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public int supUpperLower() {\n+        return supUpper.compareToIgnoreCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLower() {\n+        return supUpper.compareToIgnoreCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiUpperLowerFC() {\n+        return asciiUpper.compareToFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLowerFC() {\n+        return asciiUpper.compareToFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiWithDFFC() {\n+        return asciiWithDF.compareToFoldCase(asciiWithDFSS);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLowerFC() {\n+        return greekUpper.compareToFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLowerFC() {\n+        return greekUpper.compareToFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int latin1UTF16FC() {\n+        return asciiLatine1.compareToFoldCase(asciiLatin1UTF16); }\n+\n+    @Benchmark\n+    public int supUpperLowerFC() {\n+        return supUpper.compareToFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLowerFC() {\n+        return supUpper.compareToFoldCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiUpperLowerEQ() {\n+        return asciiUpper.equalsIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiLowerEQ() {\n+        return asciiUpper.equalsIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekUpperLowerEQ() {\n+        return greekUpper.equalsIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekLowerEQ() {\n+        return greekUpper.equalsIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public boolean latin1UTF16EQ() {\n+        return asciiLatine1.equalsIgnoreCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public boolean supUpperLowerEQ() {\n+        return supUpper.equalsIgnoreCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean supLowerEQ() {\n+        return supUpper.equalsIgnoreCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiUpperLowerEQFC() {\n+        return asciiUpper.equalsFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiLowerEQFC() {\n+        return asciiUpper.equalsFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekUpperLowerEQFC() {\n+        return greekUpper.equalsFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekLowerEQFC() {\n+        return greekUpper.equalsFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public boolean latin1UTF16EQFC() {\n+        return asciiLatine1.equalsFoldCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public boolean supUpperLowerEQFC() {\n+        return supUpper.equalsFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean supLowerEQFC() {\n+        return supUpper.equalsFoldCase(supLower);\n+    }\n+ }\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToFoldCase.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -39,23 +39,6 @@\n-    public String upper = \"\\u0100\\u0102\\u0104\\u0106\\u0108\";\n-    public String upperLower = \"\\u0100\\u0102\\u0104\\u0106\\u0109\";\n-    public String lower = \"\\u0101\\u0103\\u0105\\u0107\\u0109\";\n-    public String supUpper = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\";\n-    public String supUpperLower = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\";\n-    public String supLower = \"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\";\n-\n-    public String asciiUpper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-    public String asciiUpperLower = \"ABCDEFGHIJKLMNOpqrstuvwxyz\";\n-    public String asciiLower = \"abcdefghijklmnopqrstuvwxyz\";\n-\n-    public String greekUpper = \"\\u0391\\u0392\\u0393\\u0394\\u0395\"; \/\/ ΑΒΓΔΕ\n-    public String greekUpperLower = \"\\u0391\\u0392\\u0393\\u0394\\u03B5\"; \/\/ ΑΒΓΔε\n-    public String greekLower = \"\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\"; \/\/ αβγδε\n-\n-    public String asciiGreekUpper = \"ABC\\u0391\\u0392\\u0393\"; \/\/ ABCΑΒΓ\n-    public String asciiGreekUpperLower = \"ABC\\u0391\\u0392\\u03B3\"; \/\/ ABCΑΒγ\n-    public String asciiGreekLower = \"abc\\u03B1\\u03B2\\u03B3\"; \/\/ abcαβγ\n-\n-    public String utf16SupUpper = \"\\uD835\\uDC00\\uD835\\uDC01\\uD835\\uDC02\\uD835\\uDC03\\uD835\\uDC04\"; \/\/ 1D400..1D404\n-    public String utf16SupUpperLower = \"\\uD835\\uDC00\\uD835\\uDC01\\uD835\\uDC02\\uD835\\uDC03\\uD835\\uDC1C\"; \/\/ 1D400..1D41C\n-    public String utf16SubLower = \"\\uD835\\uDC1C\\uD835\\uDC1D\\uD835\\uDC1E\\uD835\\uDC1F\\uD835\\uDC20\"; \/\/ 1D41C..1D420\n-\n+    public String upper = new String(\"\\u0100\\u0102\\u0104\\u0106\\u0108\");\n+    public String upperLower = new String(\"\\u0100\\u0102\\u0104\\u0106\\u0109\");\n+    public String lower = new String(\"\\u0101\\u0103\\u0105\\u0107\\u0109\");\n+    public String supUpper = new String(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\");\n+    public String supUpperLower = new String(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\");\n+    public String supLower = new String(\"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\");\n@@ -82,102 +65,0 @@\n-\n-    @Benchmark\n-    public int upperLowerCF() {\n-        return upper.compareToFoldCase(upperLower);\n-    }\n-\n-    @Benchmark\n-    public int lowerrCF() {\n-        return upper.compareToFoldCase(lower);\n-    }\n-\n-    @Benchmark\n-    public int supUpperLowerCF() {\n-        return supUpper.compareToFoldCase(supUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int supLowerCF() {\n-        return supUpper.compareToFoldCase(supLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiUpperLower() {\n-        return asciiUpper.compareToIgnoreCase(asciiUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiLower() {\n-        return asciiUpper.compareToIgnoreCase(asciiLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiGreekUpperLower() {\n-        return asciiGreekUpper.compareToIgnoreCase(asciiGreekUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiGreekLower() {\n-        return asciiGreekUpper.compareToIgnoreCase(asciiGreekLower);\n-    }\n-\n-    @Benchmark\n-    public int greekUpperLower() {\n-        return greekUpper.compareToIgnoreCase(greekUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int greekLower() {\n-        return greekUpper.compareToIgnoreCase(greekLower);\n-    }\n-\n-    @Benchmark\n-    public int utf16SupUpperLower() {\n-        return utf16SupUpper.compareToIgnoreCase(utf16SupUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int utf16SubLower() {\n-        return utf16SupUpper.compareToIgnoreCase(utf16SubLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiUpperLowerCF() {\n-        return asciiUpper.compareToFoldCase(asciiUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiLowerCF() {\n-        return asciiUpper.compareToFoldCase(asciiLower);\n-    }\n-\n-    @Benchmark\n-    public int greekUpperLowerCF() {\n-        return greekUpper.compareToFoldCase(greekUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int greekLowerCF() {\n-        return greekUpper.compareToFoldCase(greekLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiGreekUpperLowerCF() {\n-        return asciiGreekUpper.compareToFoldCase(asciiGreekUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int asciiGreekLowerCF() {\n-        return asciiGreekUpper.compareToFoldCase(asciiGreekLower);\n-    }\n-\n-\n-    @Benchmark\n-    public int utf16SupUpperLowerCF() {\n-        return utf16SupUpper.compareToFoldCase(utf16SupUpperLower);\n-    }\n-\n-    @Benchmark\n-    public int utf16SubLowerCF() {\n-        return utf16SupUpper.compareToFoldCase(utf16SubLower);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToIgnoreCase.java","additions":6,"deletions":125,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  * @test\n-  * @benchmark\n-  * @summary Compare String.toUpperCase().toLowerCase() vs String.toCaseFold()\n-  * @library \/test\/lib\n-  * @run main org.openjdk.jmh.Main StringCaseFoldBenchmark\n-  *\/\n-\n- package org.openjdk.bench.java.lang;\n-\n- import org.openjdk.jmh.annotations.*;\n- import java.util.concurrent.TimeUnit;\n-\n- @BenchmarkMode(Mode.Throughput)\n- @OutputTimeUnit(TimeUnit.MILLISECONDS)\n- @State(Scope.Thread)\n- public class StringToCaseFold {\n-\n-     @Param({\"LATIN\", \"BMP\", \"SUPPLEMENTARY\", \"MIXED\"})\n-     private String dataset;\n-\n-     private String input;\n-\n-     @Setup(Level.Trial)\n-     public void setup() {\n-         switch (dataset) {\n-             case \"LATIN\":\n-                 \/\/ \"The Quick Brown Fox Jumps Over The Lazy Dog ß ü ö µ\"\n-                 input = \"The Quick Brown Fox Jumps Over The Lazy Dog \\u00DF \\u00FC \\u00F6 \\u00B5\";\n-                 break;\n-             case \"BMP\":\n-                 \/\/ \"Αλφάβητο кириллица עברית العربية\"\n-                 input = \"\\u0391\\u03BB\\u03C6\\u03AC\\u03B2\\u03B7\\u03C4\\u03BF \" + \/\/ Αλφάβητο\n-                         \"\\u043A\\u0438\\u0440\\u0438\\u043B\\u043B\\u0438\\u0446\\u0430 \" + \/\/ кириллица\n-                         \"\\u05E2\\u05D1\\u05E8\\u05D9\\u05EA \" + \/\/ עברית\n-                         \"\\u0627\\u0644\\u0639\\u0631\\u0628\\u064A\\u0629\"; \/\/ العربية\n-                 break;\n-             case \"SUPPLEMENTARY\":\n-                 \/\/ \"𐐷𐐲𐑌 Deseret 𐍈 Gothic 𝒜𝒷𝒸𝒟𝒺𝒻 MathBold\"\n-                 input = \"\\uD801\\uDC37\\uD801\\uDC32\\uD801\\uDC4C Deseret \" + \/\/ 𐐷𐐲𐑌\n-                         \"\\uD800\\uDF48 Gothic \" + \/\/ 𐍈\n-                         \"\\uD835\\uDC9C\\uD835\\uDCB7\\uD835\\uDCB8\\uD835\\uDC9F\\uD835\\uDCA0\\uD835\\uDCA1 MathBold\"; \/\/ 𝒜𝒷𝒸𝒟𝒺𝒻\n-                 break;\n-             case \"MIXED\":\n-                 \/\/ \"Hello 𐐷 World ß ΐ ΰ 𝒜𝒷 𐍈 😊\"\n-                 input = \"Hello \\uD801\\uDC37 World \\u00DF \\u0390 \\u03B0 \" + \/\/ 𐐷, ß, ΐ, ΰ\n-                         \"\\uD835\\uDC9C\\uD835\\uDCB7 \" + \/\/ 𝒜𝒷\n-                         \"\\uD800\\uDF48 \" + \/\/ 𐍈\n-                         \"\\uD83D\\uDE0A\"; \/\/ 😊\n-                 break;\n-             default:\n-                 throw new IllegalArgumentException(\"Unknown dataset: \" + dataset);\n-         }\n-     }\n-\n-     @Benchmark\n-     public String upperLower() {\n-         \/\/ Current common workaround for caseless comparison\n-         return input.toUpperCase().toLowerCase();\n-     }\n-\n-     @Benchmark\n-     public String caseFold() {\n-         \/\/ Proposed API\n-         return input;\n-         \/\/ return input.toCaseFold();\n-     }\n- }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringToCaseFold.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"}]}