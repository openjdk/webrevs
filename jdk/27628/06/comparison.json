{"files":[{"patch":"@@ -82,1 +82,1 @@\n-    build.tools.generatecharacter.CaseFolding\n+    build.tools.generatecharacter.GenerateCaseFolding\n","filename":"make\/ToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.generatecharacter;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardOpenOption;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class CaseFolding {\n-\n-    public static void main(String[] args) throws Throwable {\n-        if (args.length != 3) {\n-            System.err.println(\"Usage: java CaseFolding TemplateFile CaseFolding.txt CaseFolding.java\");\n-            System.exit(1);\n-        }\n-        var templateFile = Paths.get(args[0]);\n-        var caseFoldingTxt = Paths.get(args[1]);\n-        var genSrcFile = Paths.get(args[2]);\n-        var supportedTypes = \"^.*; [CTS]; .*$\";\n-        var caseFoldingEntries = Files.lines(caseFoldingTxt)\n-            .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n-            .map(line -> {\n-                String[] cols = line.split(\"; \");\n-                return new String[] {cols[0], cols[1], cols[2]};\n-            })\n-            .filter(cols -> {\n-                \/\/  the folding case doesn't map back to the original char.\n-                var cp1 = Integer.parseInt(cols[0], 16);\n-                var cp2 = Integer.parseInt(cols[2], 16);\n-                return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n-            })\n-            .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n-            .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n-\n-        \/\/ hack, hack, hack! the logic does not pick 0131. just add manually to support 'I's.\n-        \/\/ 0049; T; 0131; # LATIN CAPITAL LETTER I\n-        final String T_0x0131_0x49 = String.format(\"        entry(0x%04x, 0x%04x),\\n\", 0x0131, 0x49);\n-\n-        \/\/ Generate .java file\n-        Files.write(\n-            genSrcFile,\n-            Files.lines(templateFile)\n-                .map(line -> line.contains(\"%%%Entries\") ? T_0x0131_0x49 + caseFoldingEntries : line)\n-                .collect(Collectors.toList()),\n-            StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n-    }\n-}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CaseFolding.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package build.tools.generatecharacter;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class GenerateCaseFolding {\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length != 3) {\n+            System.err.println(\"Usage: java GenerateCaseFolding TemplateFile CaseFolding.txt CaseFolding.java\");\n+            System.exit(1);\n+        }\n+        var templateFile = Paths.get(args[0]);\n+        var caseFoldingTxt = Paths.get(args[1]);\n+        var genSrcFile = Paths.get(args[2]);\n+\n+        \/\/ java.lang\n+        var supportedTypes = \"^.*; [CF]; .*$\";  \/\/ full\/1:M case folding\n+        String[][] caseFoldings = Files.lines(caseFoldingTxt)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(supportedTypes))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = fields[0];\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new String[fields.length + 1];\n+                    folding[0] = cp;\n+                    System.arraycopy(fields, 0, folding, 1, fields.length);\n+                    return folding;\n+                })\n+                .toArray(size -> new String[size][]);\n+\n+        \/\/ util.regex\n+        var expandedSupportedTypes = \"^.*; [CTS]; .*$\";\n+        var expanded_caseFoldingEntries = Files.lines(caseFoldingTxt)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(expandedSupportedTypes))\n+                .map(line -> {\n+                    String[] cols = line.split(\"; \");\n+                    return new String[]{cols[0], cols[1], cols[2]};\n+                })\n+                .filter(cols -> {\n+                    \/\/ the folding case doesn't map back to the original char.\n+                    var cp1 = Integer.parseInt(cols[0], 16);\n+                    var cp2 = Integer.parseInt(cols[2], 16);\n+                    return Character.toUpperCase(cp2) != cp1 && Character.toLowerCase(cp2) != cp1;\n+                })\n+                .map(cols -> String.format(\"        entry(0x%s, 0x%s)\", cols[0], cols[2]))\n+                .collect(Collectors.joining(\",\\n\", \"\", \"\"));\n+\n+        \/\/ hack, hack, hack! the logic does not pick 0131. just add manually to support 'I's.\n+        \/\/ 0049; T; 0131; # LATIN CAPITAL LETTER I\n+        final String T_0x0131_0x49 = String.format(\"        entry(0x%04x, 0x%04x),\\n\", 0x0131, 0x49);\n+\n+        Files.write(\n+                genSrcFile,\n+                Files.lines(templateFile)\n+                        .map(line -> line.contains(\"%%%Entries\") ? genFoldingEntries(caseFoldings) : line)\n+                        .map(line -> line.contains(\"%%%Expanded_Case_Map_Entries\") ? T_0x0131_0x49 + expanded_caseFoldingEntries : line)\n+                        .collect(Collectors.toList()),\n+                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+    }\n+\n+    private static long foldingToLong(String[] folding) {\n+        int cp = Integer.parseInt(folding[0], 16);\n+        long value = (long)Integer.parseInt(folding[1], 16);\n+        if (!Character.isSupplementaryCodePoint(cp) && folding.length != 2) {\n+            var shift = 16;\n+            for (int j = 2; j < folding.length; j++) {\n+                value |= (long)Integer.parseInt(folding[j], 16) << shift;\n+                shift <<= 1;\n+            }\n+            value = value | (long) (folding.length - 1) << 48;\n+        }\n+        return value;\n+    }\n+\n+    private static String genFoldingEntries(String[][] foldings) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"    private static final int[] CASE_FOLDING_CPS = {\\n\");\n+        int width = 10;\n+        for (int i = 0; i < foldings.length; i++) {\n+            if (i % width == 0)\n+                sb.append(\"        \");\n+            sb.append(String.format(\"0X%s\", foldings[i][0]));\n+            if (i < foldings.length - 1)\n+                sb.append(\", \");\n+            if (i % width == width - 1 || i == foldings.length - 1)\n+                sb.append(\"\\n\");\n+        }\n+        sb.append(\"    };\\n\\n\");\n+\n+        sb.append(\"    private static final long[] CASE_FOLDING_VALUES = {\\n\");\n+        width = 6;\n+        for (int i = 0; i < foldings.length; i++) {\n+            if (i % width == 0)\n+                sb.append(\"        \"); \/\/ indent\n+            sb.append(String.format(\"0x%013xL\", foldingToLong(foldings[i])));\n+            if (i < foldings.length - 1)\n+                sb.append(\", \");\n+            if (i % width == width - 1 || i == foldings.length - 1) {\n+                sb.append(\"\\n\");\n+            }\n+        }\n+        sb.append(\"    };\\n\");\n+        return sb.toString();\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/GenerateCaseFolding.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -75,0 +75,17 @@\n+\n+GENSRC_STRINGCASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/lang\/CaseFolding.java\n+\n+STRINGCASEFOLDING_TEMPLATE := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template\n+CASEFOLDINGTXT := $(MODULE_SRC)\/share\/data\/unicodedata\/CaseFolding.txt\n+\n+$(GENSRC_STRINGCASEFOLDING): $(BUILD_TOOLS_JDK) $(STRINGCASEFOLDING_TEMPLATE) $(CASEFOLDINGTXT)\n+\t$(call LogInfo, Generating $@)\n+\t$(call MakeTargetDir)\n+\t$(TOOL_GENERATECASEFOLDING) \\\n+\t    $(STRINGCASEFOLDING_TEMPLATE) \\\n+\t    $(CASEFOLDINGTXT) \\\n+\t    $(GENSRC_STRINGCASEFOLDING)\n+\n+TARGETS += $(GENSRC_STRINGCASEFOLDING)\n+\n+\n","filename":"make\/modules\/java.base\/gensrc\/GensrcCharacterData.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -53,17 +53,0 @@\n-GENSRC_CASEFOLDING := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/util\/regex\/CaseFolding.java\n-\n-CASEFOLDINGTEMP := $(MODULE_SRC)\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template\n-CASEFOLDINGTXT := $(MODULE_SRC)\/share\/data\/unicodedata\/CaseFolding.txt\n-\n-$(GENSRC_CASEFOLDING): $(BUILD_TOOLS_JDK) $(CASEFOLDINGTEMP) $(CASEFOLDINGTXT)\n-\t$(call LogInfo, Generating $@)\n-\t$(call MakeTargetDir)\n-\t$(TOOL_GENERATECASEFOLDING) \\\n-\t    $(CASEFOLDINGTEMP) \\\n-\t    $(CASEFOLDINGTXT) \\\n-\t    $(GENSRC_CASEFOLDING)\n-\n-TARGETS += $(GENSRC_CASEFOLDING)\n-\n-################################################################################\n-\n","filename":"make\/modules\/java.base\/gensrc\/GensrcRegex.gmk","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2183,0 +2183,1 @@\n+     * @see  #equalsFoldCase(String)\n@@ -2192,0 +2193,50 @@\n+    \/**\n+     * Compares this {@code String} to another {@code String} for equality,\n+     * using <em>{@index \"Unicode case folding\"}<\/em>. Two strings are considered equal\n+     * by this method if their case-folded forms are identical.\n+     * <p>\n+     * Case folding is defined by the Unicode Standard in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">CaseFolding.txt<\/a>,\n+     * including 1:M mappings. For example, {@code \"Fuß\".equalsFoldCase(\"FUSS\")}\n+     * returns {@code true}, since the character {@code U+00DF} (sharp s) folds\n+     * to {@code \"ss\"}.\n+     * <p>\n+     * Case folding is locale-independent and language-neutral, unlike\n+     * locale-sensitive transformations such as {@link #toLowerCase()} or\n+     * {@link #toUpperCase()}. It is intended for caseless matching,\n+     * searching, and indexing.\n+     *\n+     * @apiNote\n+     * This method is the Unicode-compliant alternative to\n+     * {@link #equalsIgnoreCase(String)}. It implements full case folding as\n+     * defined by the Unicode Standard, which may differ from the simpler\n+     * per-character mapping performed by {@code equalsIgnoreCase}.\n+     * For example:\n+     * <pre>{@snippet lang=java :\n+     * String a = \"Fuß\";\n+     * String b = \"FUSS\";\n+     * boolean equalsFoldCase = a.equalsFoldCase(b);       \/\/ returns true\n+     * boolean equalsIgnoreCase = a.equalsIgnoreCase(b);   \/\/ returns false\n+     * }<\/pre>\n+     *\n+     * @param  anotherString\n+     *         The {@code String} to compare this {@code String} against\n+     *\n+     * @return  {@code true} if the given object is not {@code null} and represents\n+     *          the same sequence of characters as this string under Unicode case\n+     *          folding; {@code false} otherwise.\n+     *\n+     * @see     #compareToFoldCase(String)\n+     * @see     #equalsIgnoreCase(String)\n+     * @since   26\n+     *\/\n+    public boolean equalsFoldCase(String anotherString) {\n+        if (this == anotherString) {\n+            return true;\n+        }\n+        if (anotherString == null) {\n+            return false;\n+        }\n+        return UNICODE_CASEFOLD_ORDER.compare(this, anotherString) == 0;\n+    }\n+\n@@ -2307,0 +2358,1 @@\n+     * @see     #compareToFoldCase(String)\n@@ -2313,0 +2365,71 @@\n+    \/**\n+     * A Comparator that orders {@code String} objects as by\n+     * {@link #compareToFoldCase(String) compareToFoldCase()}.\n+     *\n+     * @see     #compareToFoldCase(String)\n+     * @since   26\n+     *\/\n+    public static final Comparator<String> UNICODE_CASEFOLD_ORDER\n+            = new FoldCaseComparator();\n+\n+    private static class FoldCaseComparator implements Comparator<String> {\n+\n+        @Override\n+        public int compare(String s1, String s2) {\n+            byte[] v1 = s1.value;\n+            byte[] v2 = s2.value;\n+            if (s1.coder == s2.coder()) {\n+                return s1.coder == LATIN1 ? StringLatin1.compareToFC(v1, v2)\n+                                          : StringUTF16.compareToFC(v1, v2);\n+            }\n+            return s1.coder == LATIN1 ? StringLatin1.compareToFC_UTF16(v1, v2)\n+                                      : StringUTF16.compareToFC_Latin1(v1, v2);\n+        }\n+    }\n+\n+    \/**\n+     * Compares two strings lexicographically using <em>{@index \"Unicode case folding\"}<\/em>.\n+     * This method returns an integer whose sign is that of calling {@code compareTo}\n+     * on the Unicode case folded version of the strings. Unicode Case folding\n+     * eliminates differences in case according to the Unicode Standard, using the\n+     * mappings defined in\n+     * <a href=\"https:\/\/www.unicode.org\/Public\/UCD\/latest\/ucd\/CaseFolding.txt\">CaseFolding.txt<\/a>,\n+     * including 1:M mappings, such as {@code\"ß\"} → {@code }\"ss\"}.\n+     * <p>\n+     * Case folding is a locale-independent, language-neutral form of case mapping,\n+     * primarily intended for caseless matching. Unlike {@link #compareToIgnoreCase(String)},\n+     * which applies a simpler locale-insensitive uppercase mapping. This method\n+     * follows the Unicode <em>{@index \"full\"}<\/em> case folding, providing stable and\n+     * consistent results across all environments.\n+     * <p>\n+     * Note that this method does <em>not<\/em> take locale into account, and may\n+     * produce results that differ from locale-sensitive ordering. Use\n+     * {@link java.text.Collator} for locale-sensitive comparison.\n+     *\n+     * @apiNote\n+     * This method is the Unicode-compliant alternative to\n+     * {@link #compareToIgnoreCase(String)}. It implements the\n+     * <em>{@index \"full case folding\"}<\/em> as defined by the Unicode Standard, which\n+     * may differ from the simpler per-character mapping performed by\n+     * {@code compareToIgnoreCase}.\n+     * For example:\n+     * <pre>{@snippet lang=java :\n+     * String a = \"Fuß\";\n+     * String b = \"FUSS\";\n+     * int cmpFoldCase = a.compareToFoldCase(b);     \/\/ returns 0\n+     * int cmpIgnoreCase = a.compareToIgnoreCase(b); \/\/ returns > 0\n+     * }<\/pre>\n+     *\n+     * @param   str   the {@code String} to be compared.\n+     * @return  a negative integer, zero, or a positive integer as the specified\n+     *          String is greater than, equal to, or less than this String,\n+     *          ignoring case considerations by case folding.\n+     * @see     java.text.Collator\n+     * @see     #compareToIgnoreCase(String)\n+     * @see     #equalsFoldCase(String)\n+     * @since   26\n+     *\/\n+    public int compareToFoldCase(String str) {\n+        return UNICODE_CASEFOLD_ORDER.compare(this, str);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.internal.lang.CaseFolding;\n@@ -182,0 +184,122 @@\n+    private static int compareToFC0(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int k1 = off, k2 = ooff;\n+        boolean lo1 = false, lo2 = false;  \/\/ true if we have a leftover 's' from u+00df -> ss\n+        while ((k1 < last || lo1) && (k2 < olast || lo2)) {\n+            int c1, c2;\n+            if (lo1) {\n+                c1 = 0x73; \/\/ leftover 's'\n+                lo1 = false;\n+            } else {\n+                c1 = getChar(value, k1++);\n+                if (c1 == 0xdf) {\n+                    c1 = 0x73;\n+                    lo1 = true;\n+                }\n+            }\n+            if (lo2) {\n+                c2 = 0x73; \/\/ 's'\n+                lo2 = false;\n+            } else {\n+                c2 = getChar(other, k2++);\n+                if (c2 == 0xdf) {\n+                    c2 = 0x73;\n+                    lo2 = true;\n+                }\n+            }\n+            if (!CharacterDataLatin1.equalsIgnoreCase((byte)c1, (byte)c2)) {\n+                return Character.toLowerCase(c1) - Character.toLowerCase(c2);\n+            }\n+        }\n+        if (k1 < last || lo1) {\n+            return 1;\n+        }\n+        if (k2 < olast || lo2) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    static int compareToFC(byte[] value, byte[] other) {\n+        int len = value.length;\n+        int olen = other.length;\n+        int lim = Math.min(len, olen);\n+        for (int k = 0; k < lim; k++) {\n+            byte b1 = value[k];\n+            byte b2 = other[k];\n+            if (!CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n+                int c1 = b1 & 0xff;\n+                int c2 = b2 & 0xff;\n+                if (c1 == 0xdf || c2 == 0xdf) {  \/\/ 0xdf is the only 1:M in latin1 range\n+                    return compareToFC0(value, k, len, other, k, olen);\n+                }\n+                return Character.toLowerCase(c1) - Character.toLowerCase(c2);\n+            }\n+        }\n+        return len - olen;\n+    }\n+\n+    private static int compareToFC0_UTF16(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int f1 = 0, f2 = 0;\n+        int k1 = off, k2 = ooff;\n+        while ((k1 < last || f1 != 0) && (k2 < olast || f2 != 0)) {\n+            int c1, c2;\n+            if (f1 != 0) {\n+                c1 = (f1 & 0xffff); f1 >>>= 16;\n+            } else {\n+                c1 = getChar(value, k1++);\n+                var f = CaseFolding.fold(c1);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c1 = (int)(f & 0xfffff);\n+                } else {\n+                    c1 = (int)f & 0xffff;\n+                    f1 = (int)(f >>> 16);\n+                }\n+            }\n+            if (f2 != 0) {\n+                c2 = f2 & 0xffff; f2 >>>= 16;\n+            } else {\n+                c2 = StringUTF16.codePointAt(other, k2, olast, true);\n+                k2 += Character.charCount(c2);\n+                var f = CaseFolding.fold(c2);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c2 = (int)(f & 0xfffff);\n+                } else {\n+                    c2 = (int)(f & 0xffff);\n+                    f2 = (int)(f >>> 16);\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < last || f1 != 0) {\n+            return 1;\n+        }\n+        if (k2 < olast || f1 != 0) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ latin1 vs utf16\n+    static int compareToFC_UTF16(byte[] value, byte[] other) {\n+        int last = length(value);\n+        int olast = StringUTF16.length(other);\n+        int lim = Math.min(last, olast);\n+        for (int k = 0; k < lim; k++) {\n+            int cp1 = getChar(value, k);\n+            int cp2 = StringUTF16.codePointAt(other, k, olast, true);\n+            if (cp1 != cp2) {\n+                long cf1 = CaseFolding.fold(cp1);\n+                long cf2 = CaseFolding.fold(cp2);\n+                if (cf1 != cf2) {\n+                    if (!CaseFolding.isSingleCodePoint(cf1) || !CaseFolding.isSingleCodePoint(cf2)) {\n+                        return compareToFC0_UTF16(value, k, last, other, k, olast);\n+                    }\n+                    return (int)(cf1 - cf2);\n+                }\n+            }\n+        }\n+        return last - olast;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.lang.CaseFolding;\n@@ -96,1 +97,1 @@\n-    private static int codePointAt(byte[] value, int index, int end, boolean checked) {\n+    static int codePointAt(byte[] value, int index, int end, boolean checked) {\n@@ -595,0 +596,71 @@\n+    public static int compareToFC_Latin1(byte[] value, byte[] other) {\n+        return -StringLatin1.compareToFC_UTF16(other, value);\n+    }\n+\n+    private static int compareToFC0(byte[] value, int off, int last, byte[] other, int ooff, int olast) {\n+        int f1 = 0, f2 = 0;\n+        int k1 = off, k2 = ooff;\n+        while ((k1 < last || f1 != 0) && (k2 < olast || f2 != 0)) {\n+            int c1, c2;\n+            if (f1 != 0) {\n+                c1 = f1 & 0xffff; f1 >>>= 16;\n+            } else {\n+                c1 = StringUTF16.codePointAt(value, k1, last, true);\n+                k1 += Character.charCount(c1);\n+                var f = CaseFolding.fold(c1);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c1 = (int)(f & 0xfffff);\n+                } else {\n+                    c1 = (int)(f & 0xffff);\n+                    f1 = (int)(f >> 16);\n+                }\n+            }\n+            if (f2 != 0) {\n+                c2 = f2 & 0xffff; f2 >>>= 16;\n+            } else {\n+                c2 = StringUTF16.codePointAt(other, k2, olast, true);\n+                k2 += Character.charCount(c2);\n+                var f = CaseFolding.fold(c2);\n+                if (CaseFolding.isSingleCodePoint(f)) {\n+                    c2 = (int)(f & 0xfffff);\n+                } else {\n+                    c2 = (int)(f & 0xffff);\n+                    f2 = (int)(f >>> 16);\n+                }\n+            }\n+            if (c1 != c2) {\n+                return c1 - c2;\n+            }\n+        }\n+        if (k1 < last || f1 != 0) {\n+            return 1;\n+        }\n+        if (k2 < olast || f2 != 0) {\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    public static int compareToFC(byte[] value, byte[] other) {\n+        int tlast = length(value);\n+        int olast = length(other);\n+        int lim = Math.min(tlast, olast);\n+        int k = 0;\n+        while (k < lim) {\n+            int cp1 = codePointAt(value, k, tlast, true);\n+            int cp2 = codePointAt(other, k, olast, true);\n+            if (cp1 != cp2) {\n+                long cf1 = CaseFolding.fold(cp1);\n+                long cf2 = CaseFolding.fold(cp2);\n+                if (cf1 != cf2) {\n+                    if (!CaseFolding.isSingleCodePoint(cf1) || !CaseFolding.isSingleCodePoint(cf2)) {\n+                        return compareToFC0(value, k, tlast, other, k, olast);\n+                    }\n+                    return (int) cf1 - (int) cf2;\n+                }\n+            }\n+            k += Character.charCount(cp1);\n+        }\n+        return tlast - olast;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.lang.CaseFolding;\n@@ -47,1 +48,0 @@\n-import jdk.internal.util.regex.CaseFolding;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Map.entry;\n+\n+\/**\n+ * Utility class that handles Unicode case folding properties defined in\n+ * CasingFolding.txt, including 1:M full case folding.\n+ *\/\n+public final class CaseFolding {\n+\n+    private CaseFolding()  {}\n+\n+   \/**\n+    * Tests whether the specified code point has a folding mapping entry defined.\n+    *\n+    * @param  cp\n+    *         the Unicode code point to test\n+    * @return {@code true} if the given code point has a case folding mapping entry\n+    *         defined in (@code caseFoldingMap}, {@code false} otherwise\n+    *\/\n+    public static boolean isDefined(int cp) {\n+         return getDefined(cp) != -1;\n+     }\n+\n+   \/**\n+    * Returns the case-folded form of the specified code point according\n+    * to the Unicode case folding mappings.\n+    * <p>\n+    * If the code point has no case folding mapping defined, this method returns\n+    * the original code point.\n+    *\n+    * Possible combinations of the returning case-folding form as a long value\n+    *\n+    *  +---+---------+--------+---------+--------+--------+\n+    *  | 1:1 mapping |  0000  |   0000  |  000x  |  xxxx  |  0041 => 0061 or 1E921 => 1E943\n+    *  +---+---------+--------+---------+--------+--------+\n+    *  | 1:2 mapping |  0002  |   0000  |  xxxx  |  xxxx  |  FB02 => 0066 006C\n+    *  +---+---------+--------+---------+--------+--------+\n+    *  | 1:3 mapping |  0003  |   xxxx  |  xxxx  |  xxxx  |  FB03 => 0066 0066 0069\n+    *  +---+---------+--------+---------+--------+--------+\n+    *\n+    * @param  cp\n+    *         the Unicode code point to fold\n+    * @return a long value representing the case-folded form of the input\n+    *         code point, encoded as TBD\n+    *\/\n+    public static long fold(int cp) {\n+        var fold = getDefined(cp);\n+        return fold == -1 ? cp : fold;\n+    }\n+\n+    public static boolean isSingleCodePoint(long fold) {\n+        return (fold >> 48) == 0;\n+    }\n+\n+   \/**\n+    * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n+    * matching, according to the\n+    * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n+    * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n+    * <p>\n+    * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n+    * be applied to literals and (optionally) to character classes. When applied to character classes, each\n+    * character class is expected to be closed under simple case folding. See the standard for the\n+    * detailed explanation and example of \"closed\".\n+    * <p>\n+    * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n+    * <ol>\n+    * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n+    * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n+    * <\/ol>\n+    * <p>\n+    * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n+    * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n+    * family may appears independently or within a class.\n+    * <p>\n+    * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n+    * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n+    * matching.\n+    * <p>\n+    * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n+    * if their behavior is clearly specified.\n+    * <p>\n+    * This method addresses that requirement for the \"range\" construct within in character class by computing\n+    * the additional characters that should be included to close the range under simple case folding:\n+    * <p>\n+    * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n+    * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n+    * character is not already in the range, then that mapped character (typically lowercase) is added to\n+    * the expansion set.\n+    * <p>\n+    * This allows regex character class \"range\" implementation to use the returned expansion set to support\n+    * additional case-insensitive matching, without duplicating characters already covered by the existing\n+    * regex range implementation. The expectation is the matching is done using both the uppercase and\n+    * lowercase forms of the input character, for example\n+    *\n+    * <pre>{@code\n+    *\n+    *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n+    *           inRange(lower, Character.toLower(ch), upper) ||\n+    *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n+    *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n+    * }<\/pre>\n+    *\n+    * <p>\n+    * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n+    * @param start the starting code point of the character range\n+    * @param end the ending code point of the character range\n+    * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n+    *         those already in the range\n+    *\/\n+    public static int[] getClassRangeClosingCharacters(int start, int end) {\n+        int[] expanded = new int[expanded_case_cps.length];\n+        int off = 0;\n+        for (int cp : expanded_case_cps) {\n+            if (cp >= start && cp <= end) {\n+                int folding = expanded_case_map.get(cp);\n+                if (folding < start || folding > end) {\n+                    expanded[off++] = folding;\n+                }\n+            }\n+        }\n+        return Arrays.copyOf(expanded, off);\n+    }\n+\n+    private static final Map<Integer, Integer> expanded_case_map = Map.ofEntries(\n+%%%Expanded_Case_Map_Entries\n+    );\n+\n+    private static final int[] expanded_case_cps = expanded_case_map.keySet()\n+      .stream()\n+      .mapToInt(Integer::intValue)\n+      .toArray();\n+\n+    private static final int HASH_CP = 0;\n+    private static final int HASH_INDEX = 1;\n+    private static final int HASH_NEXT = 2;\n+\n+    private static int[][] hashKeys(int[] keys) {\n+        var hashes = new int[keys.length << 1][3];  \/\/ cp + hash + next\n+        var off = keys.length;\n+        for (int i = 0; i < keys.length; i++) {\n+            var cp = keys[i];\n+            var hash = cp % keys.length;\n+            while (hashes[hash][HASH_CP] != 0) {\n+                var next = hashes[hash][HASH_NEXT];\n+                if (next == 0) {\n+                    hashes[hash][HASH_NEXT] = off;\n+                    hash = off++;\n+                    break;\n+                } else {\n+                    hash = next;\n+                }\n+            }\n+            hashes[hash][HASH_CP] = cp;\n+            hashes[hash][HASH_INDEX] = i;\n+        }\n+        return Arrays.copyOf(hashes, off);\n+    }\n+\n+    private static long getDefined(int cp) {\n+        var hashes = CASE_FOLDING_HASHES;\n+        var length = CASE_FOLDING_CPS.length;  \/\/ hashed based on total defined.\n+        var hash = cp % length;\n+        while (hashes[hash][HASH_CP] != cp) {\n+            var next = hashes[hash][HASH_NEXT];\n+            if (next == 0) {\n+                return -1;   \/\/ hash miss\n+            }\n+            hash = next;\n+        }\n+        var index = hashes[hash][HASH_INDEX];\n+        return CASE_FOLDING_VALUES[index];\n+    }\n+\n+%%%Entries\n+\n+    private static final int[][] CASE_FOLDING_HASHES = hashKeys(CASE_FOLDING_CPS);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/CaseFolding.java.template","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.util.regex;\n-\n-import java.util.Arrays;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.util.Map.entry;\n-\n-public final class CaseFolding {\n-\n-    private static final Map<Integer, Integer> expanded_case_map = Map.ofEntries(\n-%%%Entries\n-    );\n-\n-    private static final int[] expanded_case_cps = expanded_case_map.keySet()\n-      .stream()\n-      .mapToInt(Integer::intValue)\n-      .toArray();\n-\n-    private CaseFolding()  {}\n-\n-    \/**\n-     * Returns an expansion set to \"close\" a given regex Unicode character class range for case-sensitive\n-     * matching, according to the\n-     * <a href=\"https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\">Simple Loose Matches<\/a>\n-     * rule defined in Unicode Technical Standard #18: Unicode Regular Expressions.\n-     * <p>\n-     * To conform with Level 1 of UTS #18, specifically RL1.5: Simple Loose Matches, simple case folding must\n-     * be applied to literals and (optionally) to character classes. When applied to character classes, each\n-     * character class is expected to be closed under simple case folding. See the standard for the\n-     * detailed explanation and example of \"closed\".\n-     * <p>\n-     * RL1.5 states: To meet this requirement, an implementation that supports case-sensitive matching should\n-     * <ol>\n-     * <li>Provide at least the simple, default Unicode case-insensitive matching, and<\/li>\n-     * <li>Specify which character properties or constructs are closed under the matching.<\/li>\n-     * <\/ol>\n-     * <p>\n-     * In the {@code  Pattern} implementation, 5 types of constructs maybe case-sensitive when matching:\n-     * back-refs, string slice (sequences), single, family(char-property) and class range. Single and\n-     * family may appears independently or within a class.\n-     * <p>\n-     * For loose\/case-insensitive matching, the back-refs, slices and singles apply {code toUpperCase} and\n-     * {@code toLowerCase} to both the pattern and the input string. This effectively 'close' the class for\n-     * matching.\n-     * <p>\n-     * The family\/char-properties are not \"closed\" and should remain unchanged. This is acceptable per RL1.5,\n-     * if their behavior is clearly specified.\n-     * <p>\n-     * This method addresses that requirement for the \"range\" construct within in character class by computing\n-     * the additional characters that should be included to close the range under simple case folding:\n-     * <p>\n-     * For each character in the input range {@code [start, end]} (inclusive), if the character has a simple\n-     * case folding mapping in Unicode's CaseFolding.txt, the mapping is not a round-trip map, and the mapped\n-     * character is not already in the range, then that mapped character (typically lowercase) is added to\n-     * the expansion set.\n-     * <p>\n-     * This allows regex character class \"range\" implementation to use the returned expansion set to support\n-     * additional case-insensitive matching, without duplicating characters already covered by the existing\n-     * regex range implementation. The expectation is the matching is done using both the uppercase and\n-     * lowercase forms of the input character, for example\n-     *\n-     * <pre>{@code\n-     *\n-     *     ch -> inRange(lower, Character.toUpperCase(ch), upper) ||\n-     *           inRange(lower, Character.toLower(ch), upper) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch)) ||\n-     *           additionalClosingCharacters.contains(Character.toUpperCase(ch))\n-     * }<\/pre>\n-     *\n-     * <p>\n-     * @spec https:\/\/www.unicode.org\/reports\/tr18\/#Simple_Loose_Matches\n-     * @param start the starting code point of the character range\n-     * @param end the ending code point of the character range\n-     * @return a {@code int[]} containing the all simple case equivalents of characters in the range, excluding\n-     *         those already in the range\n-     *\/\n-    public static int[] getClassRangeClosingCharacters(int start, int end) {\n-        int[] expanded = new int[expanded_case_cps.length];\n-        int off = 0;\n-        for (int cp : expanded_case_cps) {\n-            if (cp >= start && cp <= end) {\n-                int folding = expanded_case_map.get(cp);\n-                if (folding < start || folding > end) {\n-                    expanded[off++] = folding;\n-                }\n-            }\n-        }\n-        return Arrays.copyOf(expanded, off);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/CaseFolding.java.template","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary tests unicode case-folding based String comparison and equality\n+ * @bug 4397357\n+ * @library \/lib\/testlibrary\/java\/lang\n+ * @compile --add-exports java.base\/jdk.internal.lang=ALL-UNNAMED\n+ * UnicodeCaseFoldingTest.java\n+ * @run junit\/othervm --add-exports java.base\/jdk.internal.lang=ALL-UNNAMED\n+ * UnicodeCaseFoldingTest\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import jdk.internal.lang.CaseFolding;\n+\n+public class UnicodeCaseFoldingTest {\n+\n+    @Test\n+    void testAllCommnFullCodePointsListedInCaseFoldinigTxt() throws Throwable {\n+        var filter = \"^.*; [CF]; .*$\";  \/\/ C=common, F=full, for full case folding\n+        var results = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(filter))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var source = new String(Character.toChars(cp));\n+                    var expected = new String(folding, 0, folding.length);\n+                    \/\/ (1) Verify the folding result matches expected\n+                    assertEquals(expected, foldCase(source), \"CaseFolding.fold(): \");\n+\n+                    \/\/ (2) Verify compareToFoldCase() result\n+                    assertEquals(0, source.compareToFoldCase(expected), \"source.compareToFoldCase(expected)\");\n+                    assertEquals(0, expected.compareToFoldCase(source), \"expected.compareToFoldCase(source)\");\n+\n+                    \/\/ (3) Verify equalsFoldCase() result\n+                    assertEquals(true, source.equalsFoldCase(expected), \"source.equalsFoldCase(expected)\");\n+                    assertEquals(true, expected.equalsFoldCase(source), \"expected.equalsFoldCase(source)\");\n+                    return null;\n+                })\n+                .filter(error -> error != null)\n+                .toArray();\n+        assertEquals(0, results.length);\n+    }\n+\n+    @Test\n+    void testAllSimpleCodePointsListedInCaseFoldinigTxt() throws Throwable {\n+        \/\/ S=simple, for simple case folding. The simple case folding should still matches\n+        var filter = \"^.*; [S]; .*$\";\n+        var results = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(filter))\n+                .map(line -> {\n+                    var fields = line.split(\"; \");\n+                    var cp = Integer.parseInt(fields[0], 16);\n+                    fields = fields[2].trim().split(\" \");\n+                    var folding = new int[fields.length];\n+                    for (int i = 0; i < folding.length; i++) {\n+                        folding[i] = Integer.parseInt(fields[i], 16);\n+                    }\n+                    var source = new String(Character.toChars(cp));\n+                    var expected = new String(folding, 0, folding.length);\n+\n+                    \/\/ (1) Verify compareToFoldCase() result\n+                    assertEquals(0, source.compareToFoldCase(expected), \"source.compareToFoldCase(expected)\");\n+                    assertEquals(0, expected.compareToFoldCase(source), \"expected.compareToFoldCase(source)\");\n+\n+                    \/\/ (2) Verify equalsFoldCase() result\n+                    assertEquals(true, source.equalsFoldCase(expected), \"source.equalsFoldCase(expected)\");\n+                    assertEquals(true, expected.equalsFoldCase(source), \"expected.equalsFoldCase(source)\");\n+                    return null;\n+                })\n+                .filter(error -> error != null)\n+                .toArray();\n+        assertEquals(0, results.length);\n+    }\n+\n+    @Test\n+    public void testAllCodePointsFoldToThemselvesIfNotListed() throws Exception {\n+        \/\/ Collect all code points that appear in CaseFolding.txt\n+        var listed = Files.lines(UCDFiles.CASEFOLDING)\n+                .filter(line -> !line.startsWith(\"#\") && line.matches(\"^.*; [CF]; .*$\"))\n+                .map(line -> Integer.parseInt(line.split(\"; \")[0], 16))\n+                .collect(Collectors.toSet());\n+\n+        var failures = new ArrayList<String>();\n+\n+        \/\/ Scan BMP + Supplementary Plane 1 (U+0000..U+1FFFF)\n+        for (int cp = Character.MIN_CODE_POINT; cp <= 0x1FFFF; cp++) {\n+            if (!Character.isDefined(cp)) {\n+                continue;     \/\/ skip undefined\n+            }\n+            if (Character.isSurrogate((char) cp)) {\n+                continue; \/\/ skip surrogate code units\n+            }\n+            if (listed.contains(cp)) {\n+                continue;          \/\/ already tested separately\n+            }\n+            String s = new String(Character.toChars(cp));\n+            String folded = foldCase(s);\n+            if (!s.equals(folded)) {\n+                failures.add(String.format(\"Unexpected folding: U+%04X '%s' → '%s'\", cp, s, folded));\n+            }\n+        }\n+\n+        assertEquals(0, failures.size(),\n+                () -> \"Some unlisted code points folded unexpectedly:\\n\"\n+                        + String.join(\"\\n\", failures));\n+    }\n+\n+    @ParameterizedTest(name = \"CaseFold \\\"{0}\\\" → \\\"{1}\\\"\")\n+    @MethodSource(\"caseFoldTestCases\")\n+    void testIndividualCaseFolding(String input, String expected) {\n+        assertEquals(expected, foldCase(input));\n+    }\n+\n+    static Stream<Arguments> caseFoldTestCases() {\n+        return Stream.of(\n+                \/\/ ASCII simple cases\n+                Arguments.of(\"ABC\", \"abc\"),\n+                Arguments.of(\"already\", \"already\"),\n+                Arguments.of(\"MiXeD123\", \"mixed123\"),\n+                \/\/ --- Latin-1 to non-Latin-1 fold ---\n+                Arguments.of(\"aBc\\u00B5Efg\", \"abc\\u03BCefg\"), \/\/ \"µ\" → \"μ\"\n+                Arguments.of(\"test\\u00B5\\ud801\\udc00X\", \"test\\u03bc\\ud801\\udc28x\"),\n+                \/\/ German Eszett\n+                Arguments.of(\"Stra\\u00DFe\", \"strasse\"), \/\/ \"Straße\"\n+                Arguments.of(\"\\u1E9E\", \"ss\"), \/\/ \"ẞ\"  capital sharp S\n+                \/\/ Turkish dotted I \/ dotless i\n+                Arguments.of(\"I\", \"i\"),\n+                Arguments.of(\"\\u0130\", \"i\\u0307\"), \/\/ capital dotted I → \"i + dot above\"\n+                Arguments.of(\"\\u0069\\u0307\", \"i\\u0307\"), \/\/ small i + dot above remains\n+                Arguments.of(\"\\u0131\", \"\\u0131\"), \/\/ \"ı\" (dotless i stays dotless)\n+\n+                \/\/ Greek special cases ---\n+                Arguments.of(\"\\u039F\\u03A3\", \"\\u03BF\\u03C3\"), \/\/ \"ΟΣ\" → \"οσ\"  final sigma always folds to normal sigma\n+                Arguments.of(\"\\u1F88\", \"\\u1F00\\u03B9\"), \/\/ \"ᾈ\" → \"ἀι\"    Alpha with psili + ypogegrammeni\n+                Arguments.of(\"\\u039C\\u03AC\\u03CA\\u03BF\\u03C2\", \"\\u03BC\\u03AC\\u03CA\\u03BF\\u03C3\"), \/\/ \"Μάϊος\" → \"μάϊοσ\"\n+                Arguments.of(\"\\u1F08\", \"\\u1F00\"), \/\/  Ἀ (Capital Alpha with psili) → ἀ\n+\n+                \/\/ Supplementary Plane characters\n+                Arguments.of(\"\\uD801\\uDC00\", \"\\uD801\\uDC28\"), \/\/ Deseret Capital Letter Long I → Small\n+                Arguments.of(\"\\uD801\\uDC01\", \"\\uD801\\uDC29\"), \/\/ Deseret Capital Letter Long E → Small\n+\n+                \/\/ Supplementary inside ASCII\n+                Arguments.of(\"abc\\uD801\\uDC00def\", \"abc\\uD801\\uDC28def\"),\n+                \/\/ Ligatures and compatibility folds\n+                Arguments.of(\"\\uFB00\", \"ff\"), \/\/ ﬀ → ff\n+                Arguments.of(\"\\uFB03\", \"ffi\"), \/\/ ﬃ → ffi\n+                Arguments.of(\"\\u212A\", \"k\"), \/\/ Kelvin sign → k\n+\n+                Arguments.of(\"abc\\uFB00def\", \"abcffdef\"), \/\/ ﬀ → ff\n+                Arguments.of(\"abc\\uFB03def\", \"abcffidef\"), \/\/ ﬃ → ffi\n+                Arguments.of(\"abc\\u212Adef\", \"abckdef\"), \/\/ Kelvin sign → k\n+\n+                \/\/ --- Fullwidth ---\n+                Arguments.of(\"\\uFF21\\uFF22\\uFF23\", \"\\uFF41\\uFF42\\uFF43\"), \/\/ \"ＡＢＣ\" → \"ａｂｃ\"\n+\n+                \/\/ --- Armenian ---\n+                Arguments.of(\"\\u0531\", \"\\u0561\"), \/\/ \"Ա\" → \"ա\"\n+\n+                \/\/ --- Cherokee ---\n+                Arguments.of(\"\\u13A0\", \"\\u13A0\"), \/\/ Capital Cherokee A folds to itself\n+                Arguments.of(\"\\uAB70\", \"\\u13A0\") \/\/ Small Cherokee A folds Capital Cherokee A\n+        );\n+    }\n+\n+    static Stream<Arguments> caseFoldEqualProvider() {\n+        return Stream.of(\n+                Arguments.of(\"abc\", \"ABC\"),\n+                Arguments.of(\"aBcDe\", \"AbCdE\"),\n+                Arguments.of(\"\\u00C0\\u00E7\", \"\\u00E0\\u00C7\"), \/\/ Àç vs àÇ\n+                Arguments.of(\"straße\", \"STRASSE\"), \/\/ ß → ss\n+                Arguments.of(\"\\uD83C\\uDDE6\", \"\\uD83C\\uDDE6\"), \/\/ 🇦 vs 🇦\n+                Arguments.of(\"\\u1E9E\", \"ss\"), \/\/ ẞ (capital sharp S)\n+                Arguments.of(\"\\u03A3\", \"\\u03C3\"), \/\/ Σ vs σ (Greek Sigma)\n+                Arguments.of(\"\\u03C3\", \"\\u03C2\"), \/\/ σ vs ς (Greek sigma\/final sigma)\n+                Arguments.of(\"\\u212B\", \"\\u00E5\"), \/\/ Å (Angstrom sign) vs å\n+                Arguments.of(\"\\uFB00\", \"ff\"), \/\/ ﬀ (ligature)\n+                Arguments.of(\"\\u01C5\", \"\\u01C5\"), \/\/ ǅ (Latin capital D with small z with caron)\n+                Arguments.of(\"Caf\\u00E9\", \"CAF\\u00C9\"), \/\/ Café vs CAFÉ\n+                Arguments.of(\"\\u03BA\\u03B1\\u03BB\\u03B7\\u03BC\\u03AD\\u03C1\\u03B1\", \"\\u039A\\u0391\\u039B\\u0397\\u039C\\u0388\\u03A1\\u0391\"), \/\/ καλημέρα vs ΚΑΛΗΜΕΡΑ\n+                Arguments.of(\"\\u4E2D\\u56FD\", \"\\u4E2D\\u56FD\"), \/\/ 中国\n+                Arguments.of(\"\\u03B1\", \"\\u0391\"), \/\/ α vs Α (Greek alpha)\n+                Arguments.of(\"\\u212B\", \"\\u00C5\"), \/\/ Å vs Å\n+                \/\/ from StringCompareToIgnoreCase\n+                Arguments.of(\"\\u0100\\u0102\\u0104\\u0106\\u0108\", \"\\u0100\\u0102\\u0104\\u0106\\u0109\"), \/\/ ĀĂĄĆĈ vs ĀĂĄĆĉ\n+                Arguments.of(\"\\u0101\\u0103\\u0105\\u0107\\u0109\", \"\\u0100\\u0102\\u0104\\u0106\\u0109\"), \/\/ āăąćĉ vs ĀĂĄĆĉ\n+                Arguments.of(\"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\",\n+                        \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\"), \/\/ 𐐀𐐁𐐂𐐃𐐄 vs 𐐀𐐁𐐂𐐃𐐬\n+                Arguments.of(\"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\",\n+                        \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\") \/\/ 𐐨𐐩𐐪𐐫𐐬 vs 𐐀𐐁𐐂𐐃𐐬\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"caseFoldEqualProvider\")\n+    void testcompareToFoldCaseEquals(String s1, String s2) {\n+        assertEquals(0, s1.compareToFoldCase(s2));\n+        assertEquals(0, s2.compareToFoldCase(s1));\n+        assertEquals(true, s1.equalsFoldCase(s2));\n+        assertEquals(true, s2.equalsFoldCase(s1));\n+        assertEquals(foldCase(s1), foldCase(s2));\n+    }\n+\n+    static Stream<Arguments> caseFoldOrderingProvider() {\n+        return Stream.of(\n+                Arguments.of(\"asa\", \"aß\", -1), \/\/ ß → ss → \"asa\" < \"ass\"\n+                Arguments.of(\"aß\", \"asa\", +1),\n+                Arguments.of(\"a\\u00DF\", \"ass\", 0), \/\/ aß vs ass\n+                Arguments.of(\"\\uFB03\", \"ffi\", 0), \/\/ ﬃ (ligature)\n+                Arguments.of(\"\\u00C5\", \"Z\", 1), \/\/ Å vs Z\n+                Arguments.of(\"A\", \"\\u00C0\", -1), \/\/ A vs À\n+                Arguments.of(\"\\u03A9\", \"\\u03C9\", 0), \/\/ Ω vs ω\n+                Arguments.of(\"\\u03C2\", \"\\u03C3\", 0), \/\/ ς vs σ\n+                Arguments.of(\"\\uD835\\uDD23\", \"R\", 1), \/\/ 𝔯 (fraktur r) vs R\n+                Arguments.of(\"\\uFF26\", \"E\", 1), \/\/ Ｆ (full-width F) vs E\n+                Arguments.of(\"\\u00C9clair\", \"Eclair\", 1) \/\/ Éclair vs Eclair\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"caseFoldOrderingProvider\")\n+    void testcompareToFoldCaseOrdering(String s1, String s2, int expectedSign) {\n+        int cmp = s1.compareToFoldCase(s2);\n+        assertEquals(expectedSign, Integer.signum(cmp));\n+    }\n+\n+    static Stream<Arguments> roundTripProvider() {\n+        return Stream.of(\n+                Arguments.of(\"abc\"),\n+                Arguments.of(\"ABC\"),\n+                Arguments.of(\"straße\"),\n+                Arguments.of(\"Àç\"),\n+                Arguments.of(\"aß\"),\n+                Arguments.of(\"\\uFB02uff\"), \/\/ ﬂuff (ligature in \"fluff\")\n+                Arguments.of(\"\\u00C9COLE\") \/\/ ÉCOLE\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"roundTripProvider\")\n+    void testCaseFoldRoundTrip(String s) {\n+        String folded = foldCase(s);\n+        assertEquals(0, s.compareToFoldCase(folded));\n+        assertEquals(0, folded.compareToFoldCase(s));\n+        assertEquals(true, s.equalsFoldCase(folded));\n+        assertEquals(true, folded.equalsFoldCase(s));\n+    }\n+\n+    \/\/ helper to test the integrity of folding mapping\n+    private static int[] longToFolding(long value) {\n+        int len = (int) (value >>> 48);\n+        if (len == 0) {\n+            return new int[]{(int) (value & 0xFFFFF)};\n+        } else {\n+            var folding = new int[len];\n+            for (int i = 0; i < len; i++) {\n+                folding[i] = (int) (value & 0xFFFF);\n+                value >>= 16;\n+            }\n+            return folding;\n+        }\n+    }\n+\n+    private static String foldCase(String s) {\n+        int first;\n+        int len = s.length();\n+        int cpCnt = 1;\n+        for (first = 0; first < len; first += cpCnt) {\n+            int cp = s.codePointAt(first);\n+            if (CaseFolding.isDefined(cp)) {\n+                break;\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        if (first == len) {\n+            return s;\n+        }\n+        StringBuilder sb = new StringBuilder(len);\n+        sb.append(s, 0, first);\n+        for (int i = first; i < len; i += cpCnt) {\n+            int cp = s.codePointAt(i);\n+            int[] folded = longToFolding(CaseFolding.fold(cp));\n+            for (int f : folded) {\n+                sb.appendCodePoint(f);\n+            }\n+            cpCnt = Character.charCount(cp);\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/UnicodeCaseFoldingTest.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::compareToFoldCase performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+public class StringCompareToFoldCase {\n+\n+    private String asciiUpper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+    private String asciiUpperLower = \"ABCDEFGHIJKLMNOpqrstuvwxyz\";\n+    private String asciiLower = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+    private String asciiWithDF = \"abcdßßßßßßßßßßßßßßßßWXYZ\";\n+    private String asciiWithDFSS = \"abcdssssssssssssssssßßßßßßßßWXYZ\";\n+\n+    private String asciiLatine1 = \"ABCDEFGHIJKLMNOpqrstuvwxyz0\";\n+    private String asciiLatin1UTF16 = \"abcdefghijklmnopqrstuvwxyz\\u0391\";\n+\n+    private String greekUpper = \"\\u0391\\u0392\\u0393\\u0394\\u0395\\u0391\\u0392\\u0393\\u0394\\u0395\"; \/\/ ΑΒΓΔΕ\n+    private String greekUpperLower = \"\\u0391\\u0392\\u0393\\u0394\\u0395\\u0391\\u0392\\u0393\\u0394\\u03B5\"; \/\/ ΑΒΓΔε\n+    private String greekLower = \"\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\"; \/\/ αβγδε\n+\n+    public String supUpper = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc04\";\n+    public String supUpperLower = \"\\ud801\\udc00\\ud801\\udc01\\ud801\\udc02\\ud801\\udc03\\ud801\\udc2c\";\n+    public String supLower = \"\\ud801\\udc28\\ud801\\udc29\\ud801\\udc2a\\ud801\\udc2b\\ud801\\udc2c\";\n+\n+    @Benchmark\n+    public int asciiUpperLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLower() {\n+        return asciiUpper.compareToIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLower() {\n+        return greekUpper.compareToIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLower() {\n+        return greekUpper.compareToIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int latin1UTF16() {\n+        return asciiLatine1.compareToIgnoreCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public int supUpperLower() {\n+        return supUpper.compareToIgnoreCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLower() {\n+        return supUpper.compareToIgnoreCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiUpperLowerFC() {\n+        return asciiUpper.compareToFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiLowerFC() {\n+        return asciiUpper.compareToFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public int asciiWithDFFC() {\n+        return asciiWithDF.compareToFoldCase(asciiWithDFSS);\n+    }\n+\n+    @Benchmark\n+    public int greekUpperLowerFC() {\n+        return greekUpper.compareToFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int greekLowerFC() {\n+        return greekUpper.compareToFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public int latin1UTF16FC() {\n+        return asciiLatine1.compareToFoldCase(asciiLatin1UTF16); }\n+\n+    @Benchmark\n+    public int supUpperLowerFC() {\n+        return supUpper.compareToFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public int supLowerFC() {\n+        return supUpper.compareToFoldCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiUpperLowerEQ() {\n+        return asciiUpper.equalsIgnoreCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiLowerEQ() {\n+        return asciiUpper.equalsIgnoreCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekUpperLowerEQ() {\n+        return greekUpper.equalsIgnoreCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekLowerEQ() {\n+        return greekUpper.equalsIgnoreCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public boolean latin1UTF16EQ() {\n+        return asciiLatine1.equalsIgnoreCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public boolean supUpperLowerEQ() {\n+        return supUpper.equalsIgnoreCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean supLowerEQ() {\n+        return supUpper.equalsIgnoreCase(supLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiUpperLowerEQFC() {\n+        return asciiUpper.equalsFoldCase(asciiUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean asciiLowerEQFC() {\n+        return asciiUpper.equalsFoldCase(asciiLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekUpperLowerEQFC() {\n+        return greekUpper.equalsFoldCase(greekUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean greekLowerEQFC() {\n+        return greekUpper.equalsFoldCase(greekLower);\n+    }\n+\n+    @Benchmark\n+    public boolean latin1UTF16EQFC() {\n+        return asciiLatine1.equalsFoldCase(asciiLatin1UTF16);\n+    }\n+\n+    @Benchmark\n+    public boolean supUpperLowerEQFC() {\n+        return supUpper.equalsFoldCase(supUpperLower);\n+    }\n+\n+    @Benchmark\n+    public boolean supLowerEQFC() {\n+        return supUpper.equalsFoldCase(supLower);\n+    }\n+ }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToFoldCase.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"}]}