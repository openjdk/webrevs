{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -303,1 +304,2 @@\n-  _ideal_phase_name_set(PHASE_NUM_TYPES, mtCompiler)\n+  _ideal_phase_name_set(PHASE_NUM_TYPES, mtCompiler),\n+  _trace_auto_vectorization_tags(TRACE_AUTO_VECTORIZATION_TAG_NUM, mtCompiler)\n@@ -436,0 +438,10 @@\n+    if (!_modified[TraceAutoVectorizationIndex]) {\n+      \/\/ Parse ccstr and create mask\n+      ccstrlist option;\n+      if (CompilerOracle::has_option_value(method, CompileCommand::TraceAutoVectorization, option)) {\n+        TraceAutoVectorizationTagValidator validator(option, false);\n+        if (validator.is_valid()) {\n+          set.cloned()->set_trace_auto_vectorization_tags(validator.tags());\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,0 @@\n-    cflags(VectorizeDebug,          uintx, 0, VectorizeDebug) \\\n@@ -94,0 +93,1 @@\n+NOT_PRODUCT(cflags(TraceAutoVectorization, ccstrlist, \"\", TraceAutoVectorization)) \\\n@@ -134,0 +134,1 @@\n+  CHeapBitMap _trace_auto_vectorization_tags;\n@@ -208,0 +209,6 @@\n+  void set_trace_auto_vectorization_tags(const CHeapBitMap& tags) {\n+    _trace_auto_vectorization_tags.set_from(tags);\n+  };\n+  const CHeapBitMap& trace_auto_vectorization_tags() {\n+    return _trace_auto_vectorization_tags;\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -778,2 +779,8 @@\n-#ifndef PRODUCT\n-      else if (option == CompileCommand::PrintIdealPhase) {\n+#if !defined(PRODUCT) && defined(COMPILER2)\n+      else if (option == CompileCommand::TraceAutoVectorization) {\n+        TraceAutoVectorizationTagValidator validator(value, true);\n+\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized tag name in %s: %s\", option2name(option), validator.what());\n+        }\n+      } else if (option == CompileCommand::PrintIdealPhase) {\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+NOT_PRODUCT(option(TraceAutoVectorization, \"TraceAutoVectorization\", Ccstrlist)) \\\n@@ -90,1 +91,0 @@\n-  option(VectorizeDebug, \"VectorizeDebug\", Uintx) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -338,0 +339,11 @@\n+        }\n+#if !defined(PRODUCT) && defined(COMPILER2)\n+        else if (strncmp(option_key->name, \"TraceAutoVectorization\", 22) == 0) {\n+          TraceAutoVectorizationTagValidator validator(s, false);\n+\n+          valid = validator.is_valid();\n+          if (valid) {\n+            set->set_trace_auto_vectorization_tags(validator.tags());\n+          } else {\n+            error(VALUE_ERROR, \"Unrecognized tag name detected in TraceAutoVectorization: %s\", validator.what());\n+          }\n@@ -348,0 +360,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -142,41 +143,0 @@\n-class PhaseNameIter {\n- private:\n-  char* _token;\n-  char* _saved_ptr;\n-  char* _list;\n-\n- public:\n-  PhaseNameIter(ccstrlist option) {\n-    _list = (char*) canonicalize(option);\n-    _saved_ptr = _list;\n-    _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n-  }\n-\n-  ~PhaseNameIter() {\n-    FREE_C_HEAP_ARRAY(char, _list);\n-  }\n-\n-  const char* operator*() const { return _token; }\n-\n-  PhaseNameIter& operator++() {\n-    _token = strtok_r(nullptr, \",\", &_saved_ptr);\n-    return *this;\n-  }\n-\n-  ccstrlist canonicalize(ccstrlist option_value) {\n-    char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n-    int i = 0;\n-    char current;\n-    while ((current = option_value[i]) != '\\0') {\n-      if (current == '\\n' || current == ' ') {\n-        canonicalized_list[i] = ',';\n-      } else {\n-        canonicalized_list[i] = current;\n-      }\n-      i++;\n-    }\n-    canonicalized_list[i] = '\\0';\n-    return canonicalized_list;\n-  }\n-};\n-\n@@ -195,1 +155,1 @@\n-    for (PhaseNameIter iter(option); *iter != nullptr && _valid; ++iter) {\n+    for (StringUtils::CommaSeparatedStringIterator iter(option); *iter != nullptr && _valid; ++iter) {\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -72,7 +72,0 @@\n-#ifndef PRODUCT\n-  _vector_loop_debug = 0;\n-  if (_phase->C->method() != nullptr) {\n-    _vector_loop_debug = phase->C->directive()->VectorizeDebugOption;\n-  }\n-\n-#endif\n@@ -118,1 +111,1 @@\n-      if (TraceSuperWord) {\n+      if (is_trace_superword_precondition()) {\n@@ -300,0 +293,1 @@\n+#ifndef PRODUCT\n@@ -303,0 +297,1 @@\n+#endif\n@@ -349,0 +344,5 @@\n+#ifndef PRODUCT\n+      if (TraceSuperWordLoopUnrollAnalysis) {\n+        tty->print_cr(\"slp analysis: set max unroll to %d\", local_loop_unroll_factor);\n+      }\n+#endif\n@@ -522,13 +522,0 @@\n-\n-#ifndef PRODUCT\n-  if (_do_vector_loop && TraceSuperWord) {\n-    tty->print(\"SuperWord::SLP_extract\\n\");\n-    tty->print(\"input loop\\n\");\n-    _lpt->dump_head();\n-    _lpt->dump();\n-    for (uint i = 0; i < _lpt->_body.size(); i++) {\n-      _lpt->_body.at(i)->dump();\n-    }\n-  }\n-#endif\n-\n@@ -557,1 +544,1 @@\n-    if (TraceSuperWord) {\n+    if (is_trace_superword_any()) {\n@@ -600,1 +587,2 @@\n-  if (TraceSuperWord) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_adjacent_memops()) {\n@@ -603,0 +591,1 @@\n+#endif\n@@ -670,2 +659,2 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter find_adjacent_refs\");\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::find_adjacent_refs\");\n@@ -753,2 +742,2 @@\n-#ifdef ASSERT\n-  if (TraceSuperWord && Verbose) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_verbose()) {\n@@ -765,3 +754,3 @@\n-#ifdef ASSERT\n-    if (TraceSuperWord) {\n-      tty->print(\"\\nVector align to node: \");\n+#ifndef PRODUCT\n+    if (is_trace_superword_adjacent_memops()) {\n+      tty->print(\"SuperWord::find_align_to_ref: \");\n@@ -828,1 +817,1 @@\n-  if (TraceSuperWord) {\n+  if (is_trace_superword_alignment()) {\n@@ -861,8 +850,0 @@\n-#ifndef PRODUCT\n-    if(TraceSuperWord && Verbose) {\n-      tty->print_cr(\"SuperWord::dependence_graph: built a new mem slice\");\n-      for (int j = _nlist.length() - 1; j >= 0 ; j--) {\n-        _nlist.at(j)->dump();\n-      }\n-    }\n-#endif\n@@ -905,1 +886,2 @@\n-    if (TraceSuperWord) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_dependence_graph()) {\n@@ -912,0 +894,1 @@\n+#endif\n@@ -924,1 +907,0 @@\n-    NOT_PRODUCT( if(is_trace_mem_slice()) tty->print_cr(\"SuperWord::mem_slice_preds: n %d\", n->_idx);)\n@@ -931,3 +913,0 @@\n-          if (TraceSuperWord && Verbose) {\n-            tty->print_cr(\"SuperWord::mem_slice_preds: added pred(%d)\", out->_idx);\n-          }\n@@ -952,3 +931,0 @@\n-    if (TraceSuperWord && Verbose) {\n-      tty->print_cr(\"SuperWord::mem_slice_preds: added pred(%d)\", n->_idx);\n-    }\n@@ -959,0 +935,10 @@\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_memory_slices()) {\n+    tty->print_cr(\"\\nSuperWord::mem_slice_preds:\");\n+    stop->dump();\n+    for (int j = preds.length() - 1; j >= 0 ; j--) {\n+      preds.at(j)->dump();\n+    }\n+  }\n+#endif\n@@ -1209,2 +1195,3 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter extend_packlist\");\n+#ifndef PRODUCT\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::extend_packlist\");\n@@ -1213,0 +1200,1 @@\n+#endif\n@@ -1242,1 +1230,6 @@\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, alignment(s1));)\n+#ifndef PRODUCT\n+  if (is_trace_superword_alignment()) {\n+    tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\",\n+                  s1->_idx, alignment(s1));\n+  }\n+#endif\n@@ -1261,1 +1254,6 @@\n-        NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: set_alignment(%d, %d, %d)\", t1->_idx, t2->_idx, align);)\n+#ifndef PRODUCT\n+        if (is_trace_superword_alignment()) {\n+          tty->print_cr(\"SuperWord::follow_use_defs: set_alignment(%d, %d, %d)\",\n+                        t1->_idx, t2->_idx, align);\n+        }\n+#endif\n@@ -1283,1 +1281,6 @@\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_def_uses: s1 %d, align %d\", s1->_idx, align);)\n+#ifndef PRODUCT\n+  if (is_trace_superword_alignment()) {\n+    tty->print_cr(\"SuperWord::follow_def_uses: s1 %d, align %d\",\n+                  s1->_idx, align);\n+  }\n+#endif\n@@ -1325,1 +1328,6 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_def_uses: set_alignment(%d, %d, %d)\", u1->_idx, u2->_idx, align);)\n+#ifndef PRODUCT\n+    if (is_trace_superword_alignment()) {\n+      tty->print_cr(\"SuperWord::follow_def_uses: set_alignment(%d, %d, %d)\",\n+                    u1->_idx, u2->_idx, align);\n+    }\n+#endif\n@@ -1516,1 +1524,1 @@\n-        if (TraceSuperWord) {\n+        if (is_trace_superword_rejections()) {\n@@ -1567,1 +1575,1 @@\n-        if (TraceSuperWord) {\n+        if (is_trace_superword_rejections()) {\n@@ -1583,2 +1591,2 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter combine_packs\");\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::combine_packs\");\n@@ -1624,2 +1632,2 @@\n-  if (TraceSuperWord || is_trace_align_vector()) {\n-    tty->print_cr(\"\\nfilter_packs_for_alignment:\");\n+  if (is_trace_superword_info() || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nSuperWord::filter_packs_for_alignment:\");\n@@ -1655,0 +1663,6 @@\n+#ifndef PRODUCT\n+          if (is_trace_superword_rejections() || is_trace_align_vector()) {\n+            tty->print_cr(\"Rejected by AlignVector:\");\n+            p->at(0)->dump();\n+          }\n+#endif\n@@ -1666,1 +1680,1 @@\n-  if (TraceSuperWord || is_trace_align_vector()) {\n+  if (is_trace_superword_info() || is_trace_align_vector()) {\n@@ -1683,0 +1697,7 @@\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_packset() || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nAfter Superword::filter_packs_for_alignment\");\n+    print_packset();\n+  }\n+#endif\n@@ -1728,1 +1749,1 @@\n-      if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n+      if (is_trace_superword_rejections()) {\n@@ -1752,1 +1773,1 @@\n-        if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n+        if (is_trace_superword_rejections()) {\n@@ -1764,2 +1785,2 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter filter_packs\");\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::filter_packs\");\n@@ -2239,1 +2260,2 @@\n-    if (TraceSuperWord) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_rejections()) {\n@@ -2244,0 +2266,1 @@\n+#endif\n@@ -2249,1 +2272,1 @@\n-  if (TraceSuperWord) {\n+  if (is_trace_superword_info()) {\n@@ -2385,1 +2408,0 @@\n-      NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"VPointer::output: %d executed first, %d executed last in pack\", first->_idx, n->_idx); print_pack(p);})\n@@ -2678,0 +2700,1 @@\n+#ifndef PRODUCT\n@@ -2681,0 +2704,1 @@\n+#endif\n@@ -3054,1 +3078,1 @@\n-  if (TraceSuperWord) {\n+  if (is_trace_superword_info()) {\n@@ -3061,0 +3085,2 @@\n+  }\n+  if (is_trace_superword_memory_slices()) {\n@@ -3127,1 +3153,2 @@\n-  if (TraceSuperWord && Verbose) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_dependence_graph()) {\n@@ -3130,0 +3157,1 @@\n+#endif\n@@ -3189,1 +3217,2 @@\n-  if (TraceSuperWord && Verbose) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_vector_element_type()) {\n@@ -3192,0 +3221,1 @@\n+#endif\n@@ -3267,1 +3297,1 @@\n-  if (TraceSuperWord && Verbose) {\n+  if (is_trace_superword_vector_element_type()) {\n@@ -3282,1 +3312,1 @@\n-  if ((TraceSuperWord && Verbose) || is_trace_alignment()) {\n+  if (is_trace_superword_alignment()) {\n@@ -3288,1 +3318,1 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"VPointer::memory_alignment: VPointer p invalid, return bottom_align\");)\n+    NOT_PRODUCT(if(is_trace_superword_alignment()) tty->print_cr(\"SuperWord::memory_alignment: VPointer p invalid, return bottom_align\");)\n@@ -3293,1 +3323,1 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"VPointer::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n+    NOT_PRODUCT(if(is_trace_superword_alignment()) tty->print_cr(\"SuperWord::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n@@ -3301,2 +3331,2 @@\n-  if ((TraceSuperWord && Verbose) || is_trace_alignment()) {\n-    tty->print_cr(\"VPointer::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n+  if (is_trace_superword_alignment()) {\n+    tty->print_cr(\"SuperWord::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":106,"deletions":76,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -244,7 +244,70 @@\n-  bool     is_debug()              { return _vector_loop_debug > 0; }\n-  bool     is_trace_alignment()    { return (_vector_loop_debug & 2) > 0; }\n-  bool     is_trace_mem_slice()    { return (_vector_loop_debug & 4) > 0; }\n-  bool     is_trace_loop()         { return (_vector_loop_debug & 8) > 0; }\n-  bool     is_trace_adjacent()     { return (_vector_loop_debug & 16) > 0; }\n-  bool     is_trace_cmov()         { return (_vector_loop_debug & 32) > 0; }\n-  bool     is_trace_align_vector() { return (_vector_loop_debug & 128) > 0; }\n+  \/\/ TraceAutoVectorization and TraceSuperWord\n+  bool is_trace_superword_precondition() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION);\n+  }\n+\n+  bool is_trace_superword_vector_element_type() const {\n+    \/\/ Too verbose for TraceSuperWord\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES);\n+  }\n+\n+  bool is_trace_superword_alignment() const {\n+    \/\/ Too verbose for TraceSuperWord\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n+  }\n+\n+  bool is_trace_superword_memory_slices() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n+  }\n+\n+  bool is_trace_superword_dependence_graph() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n+  }\n+\n+  bool is_trace_superword_adjacent_memops() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS);\n+  }\n+\n+  bool is_trace_superword_rejections() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS);\n+  }\n+\n+  bool is_trace_superword_packset() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET);\n+  }\n+\n+  bool is_trace_superword_info() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO);\n+  }\n+\n+  bool is_trace_superword_verbose() const {\n+    \/\/ Too verbose for TraceSuperWord\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+  }\n+\n+  bool is_trace_superword_any() const {\n+    return TraceSuperWord ||\n+           is_trace_align_vector() ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+  }\n+\n+  bool is_trace_align_vector() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::ALIGN_VECTOR) ||\n+           is_trace_superword_verbose();\n+  }\n@@ -252,0 +315,1 @@\n+\n@@ -268,3 +332,1 @@\n-#ifndef PRODUCT\n-  uintx          _vector_loop_debug; \/\/ provide more printing in debug mode\n-#endif\n+  NOT_PRODUCT(VTrace _vtrace);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":72,"deletions":10,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_TRACEAUTOVECTORIZATIONTAG_HPP\n+#define SHARE_OPTO_TRACEAUTOVECTORIZATIONTAG_HPP\n+\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/stringUtils.hpp\"\n+\n+#define COMPILER_TRACE_AUTO_VECTORIZATION_TAG(flags) \\\n+  flags(POINTER_ANALYSIS,     \"Trace VPointer\") \\\n+  flags(SW_PRECONDITION,      \"Trace SuperWord precondition\") \\\n+  flags(SW_TYPES,             \"Trace SuperWord::compute_vector_element_type\") \\\n+  flags(SW_ALIGNMENT,         \"Trace SuperWord alignment analysis\") \\\n+  flags(SW_MEMORY_SLICES,     \"Trace SuperWord memory slices\") \\\n+  flags(SW_DEPENDENCE_GRAPH,  \"Trace SuperWord::dependence_graph\") \\\n+  flags(SW_ADJACENT_MEMOPS,   \"Trace SuperWord::find_adjacent_refs\") \\\n+  flags(SW_REJECTIONS,        \"Trace SuperWord rejections (non vectorizations)\") \\\n+  flags(SW_PACKSET,           \"Trace SuperWord packset at different stages\") \\\n+  flags(SW_INFO,              \"Trace SuperWord info (equivalent to TraceSuperWord)\") \\\n+  flags(SW_VERBOSE,           \"Trace SuperWord verbose (all SW tags enabled)\") \\\n+  flags(ALIGN_VECTOR,         \"Trace AlignVector\") \\\n+  flags(ALL,                  \"Trace everything (very verbose)\")\n+\n+#define table_entry(name, description) name,\n+enum TraceAutoVectorizationTag {\n+  COMPILER_TRACE_AUTO_VECTORIZATION_TAG(table_entry)\n+  TRACE_AUTO_VECTORIZATION_TAG_NUM,\n+  TRACE_AUTO_VECTORIZATION_TAG_NONE\n+};\n+#undef table_entry\n+\n+static const char* tag_descriptions[] = {\n+#define array_of_labels(name, description) description,\n+       COMPILER_TRACE_AUTO_VECTORIZATION_TAG(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+static const char* tag_names[] = {\n+#define array_of_labels(name, description) #name,\n+       COMPILER_TRACE_AUTO_VECTORIZATION_TAG(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+static TraceAutoVectorizationTag find_tag(const char* str) {\n+  for (int i = 0; i < TRACE_AUTO_VECTORIZATION_TAG_NUM; i++) {\n+    if (strcmp(tag_names[i], str) == 0) {\n+      return (TraceAutoVectorizationTag)i;\n+    }\n+  }\n+  return TRACE_AUTO_VECTORIZATION_TAG_NONE;\n+}\n+\n+class TraceAutoVectorizationTagValidator {\n+ private:\n+  CHeapBitMap _tags;\n+  bool _valid;\n+  char* _bad;\n+  bool _is_print_usage;\n+\n+ public:\n+  TraceAutoVectorizationTagValidator(ccstrlist option, bool is_print_usage) :\n+    _tags(TRACE_AUTO_VECTORIZATION_TAG_NUM, mtCompiler),\n+    _valid(true),\n+    _bad(nullptr),\n+    _is_print_usage(is_print_usage)\n+  {\n+    for (StringUtils::CommaSeparatedStringIterator iter(option); *iter != nullptr && _valid; ++iter) {\n+      char const* tag_name = *iter;\n+      if (strcmp(\"help\", tag_name) == 0) {\n+        if (_is_print_usage) {\n+          print_help();\n+        }\n+        continue;\n+      }\n+      bool set_bit = true;\n+      \/\/ Check for \"TAG\" or \"-TAG\"\n+      if (strncmp(\"-\", tag_name, strlen(\"-\")) == 0) {\n+        tag_name++;\n+        set_bit = false;\n+      }\n+      TraceAutoVectorizationTag tag = find_tag(tag_name);\n+      if (TRACE_AUTO_VECTORIZATION_TAG_NONE == tag) {\n+        \/\/ cap len to a value we know is enough for all tags\n+        const size_t len = MIN2<size_t>(strlen(*iter), 63) + 1;\n+        _bad = NEW_C_HEAP_ARRAY(char, len, mtCompiler);\n+        \/\/ strncpy always writes len characters. If the source string is\n+        \/\/ shorter, the function fills the remaining bytes with nulls.\n+        strncpy(_bad, *iter, len);\n+        _valid = false;\n+      } else if (ALL == tag) {\n+        _tags.set_range(0, TRACE_AUTO_VECTORIZATION_TAG_NUM);\n+      } else if (SW_VERBOSE == tag) {\n+        _tags.at_put(SW_PRECONDITION, set_bit);\n+        _tags.at_put(SW_TYPES, set_bit);\n+        _tags.at_put(SW_ALIGNMENT, set_bit);\n+        _tags.at_put(SW_MEMORY_SLICES, set_bit);\n+        _tags.at_put(SW_DEPENDENCE_GRAPH, set_bit);\n+        _tags.at_put(SW_ADJACENT_MEMOPS, set_bit);\n+        _tags.at_put(SW_REJECTIONS, set_bit);\n+        _tags.at_put(SW_PACKSET, set_bit);\n+        _tags.at_put(SW_INFO, set_bit);\n+        _tags.at_put(SW_VERBOSE, set_bit);\n+      } else if (SW_INFO == tag) {\n+        _tags.at_put(SW_PRECONDITION, set_bit);\n+        _tags.at_put(SW_MEMORY_SLICES, set_bit);\n+        _tags.at_put(SW_DEPENDENCE_GRAPH, set_bit);\n+        _tags.at_put(SW_ADJACENT_MEMOPS, set_bit);\n+        _tags.at_put(SW_REJECTIONS, set_bit);\n+        _tags.at_put(SW_PACKSET, set_bit);\n+        _tags.at_put(SW_INFO, set_bit);\n+      } else {\n+        assert(tag < TRACE_AUTO_VECTORIZATION_TAG_NUM, \"out of bounds\");\n+        _tags.at_put(tag, set_bit);\n+      }\n+    }\n+  }\n+\n+  ~TraceAutoVectorizationTagValidator() {\n+    if (_bad != nullptr) {\n+      FREE_C_HEAP_ARRAY(char, _bad);\n+    }\n+  }\n+\n+  bool is_valid() const { return _valid; }\n+  const char* what() const { return _bad; }\n+  const CHeapBitMap& tags() const {\n+    assert(is_valid(), \"only read tags when valid\");\n+    return _tags;\n+  }\n+\n+  static void print_help() {\n+    tty->cr();\n+    tty->print_cr(\"Usage for CompileCommand TraceAutoVectorization:\");\n+    tty->print_cr(\"  -XX:CompileCommand=TraceAutoVectorization,<package.class::method>,<tags>\");\n+    tty->print_cr(\"  %-22s %s\", \"tags\", \"descriptions\");\n+    for (int i = 0; i < TRACE_AUTO_VECTORIZATION_TAG_NUM; i++) {\n+      tty->print_cr(\"  %-22s %s\", tag_names[i], tag_descriptions[i]);\n+    }\n+    tty->cr();\n+  }\n+};\n+\n+#endif \/\/ SHARE_OPTO_TRACEAUTOVECTORIZATIONTAG_HPP\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-  , _tracer((phase->C->directive()->VectorizeDebugOption & 2) > 0)\n+  , _tracer(phase->C->directive()->trace_auto_vectorization_tags().at(TraceAutoVectorizationTag::POINTER_ANALYSIS))\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -34,0 +35,16 @@\n+#ifndef PRODUCT\n+\/\/ Access to TraceAutoVectorization tags\n+class VTrace : public StackObj {\n+private:\n+  const CHeapBitMap &_trace_tags;\n+\n+public:\n+  VTrace() : _trace_tags(Compile::current()->directive()->trace_auto_vectorization_tags()) {}\n+  NONCOPYABLE(VTrace);\n+\n+  bool is_trace(TraceAutoVectorizationTag tag) const {\n+    return _trace_tags.at(tag);\n+  }\n+};\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -125,0 +126,20 @@\n+\n+StringUtils::CommaSeparatedStringIterator::~CommaSeparatedStringIterator() {\n+  FREE_C_HEAP_ARRAY(char, _list);\n+}\n+\n+ccstrlist StringUtils::CommaSeparatedStringIterator::canonicalize(ccstrlist option_value) {\n+  char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n+  int i = 0;\n+  char current;\n+  while ((current = option_value[i]) != '\\0') {\n+    if (current == '\\n' || current == ' ') {\n+      canonicalized_list[i] = ',';\n+    } else {\n+      canonicalized_list[i] = current;\n+    }\n+    i++;\n+  }\n+  canonicalized_list[i] = '\\0';\n+  return canonicalized_list;\n+}\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,27 @@\n+\n+  class CommaSeparatedStringIterator {\n+  private:\n+    char* _token;\n+    char* _saved_ptr;\n+    char* _list;\n+\n+  public:\n+    CommaSeparatedStringIterator(ccstrlist option) {\n+      \/\/ Immediately make a private copy of option, and\n+      \/\/ replace spaces and newlines with comma.\n+      _list = (char*) canonicalize(option);\n+      _saved_ptr = _list;\n+      _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n+    }\n+\n+    ~CommaSeparatedStringIterator();\n+\n+    const char* operator*() const { return _token; }\n+\n+    CommaSeparatedStringIterator& operator++() {\n+      _token = strtok_r(nullptr, \",\", &_saved_ptr);\n+      return *this;\n+    }\n+\n+    ccstrlist canonicalize(ccstrlist option_value);\n+  };\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            \"-XX:CompileCommand=option,Test::test,VectorizeDebug,3\",\n+            \"-XX:CompileCommand=option,Test::test,MemStat,3\",\n@@ -75,1 +75,1 @@\n-            \"Missing type 'uintx' before option 'VectorizeDebug'\"\n+            \"Missing type 'uintx' before option 'MemStat'\"\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/TestInvalidCompileCommand.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}