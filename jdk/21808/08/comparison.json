{"files":[{"patch":"@@ -65,1 +65,2 @@\n-  jlong lowest_limit = phys_mem;\n+  jlong lowest_limit = limit < 0 ? phys_mem : limit;\n+  julong orig_limit = ((julong)lowest_limit) != phys_mem ? lowest_limit : phys_mem;\n@@ -86,1 +87,1 @@\n-  if ((julong)lowest_limit != phys_mem) {\n+  if ((julong)lowest_limit != orig_limit) {\n@@ -96,0 +97,1 @@\n+    log_trace(os, container)(\"Lowest limit was: \" JLONG_FORMAT, lowest_limit);\n@@ -119,1 +121,2 @@\n-  int lowest_limit = host_cpus;\n+  int lowest_limit = cpus < host_cpus ? cpus: host_cpus;\n+  int orig_limit = lowest_limit != host_cpus ? lowest_limit : host_cpus;\n@@ -141,1 +144,1 @@\n-  if (lowest_limit != host_cpus) {\n+  if (lowest_limit != orig_limit) {\n@@ -151,0 +154,1 @@\n+    log_trace(os, container)(\"Lowest limit was: %d\", lowest_limit);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    ss.print_raw(_mount_point);\n@@ -53,1 +54,1 @@\n-      ss.print_raw(_mount_point);\n+      \/\/ host processes and containers with cgroupns=private\n@@ -55,1 +56,5 @@\n-        ss.print_raw(cgroup_path);\n+        if (strstr(cgroup_path, \"..\/\") == nullptr) {\n+          ss.print_raw(cgroup_path);\n+        } else {\n+          log_warning(os, container)(\"Cgroup cpu\/memory controller path includes '..\/', detected limits won't be accurate\");\n+        }\n@@ -57,1 +62,0 @@\n-      _path = os::strdup(ss.base());\n@@ -59,11 +63,17 @@\n-      if (strcmp(_root, cgroup_path) == 0) {\n-        ss.print_raw(_mount_point);\n-        _path = os::strdup(ss.base());\n-      } else {\n-        char *p = strstr((char*)cgroup_path, _root);\n-        if (p != nullptr && p == _root) {\n-          if (strlen(cgroup_path) > strlen(_root)) {\n-            ss.print_raw(_mount_point);\n-            const char* cg_path_sub = cgroup_path + strlen(_root);\n-            ss.print_raw(cg_path_sub);\n-            _path = os::strdup(ss.base());\n+      \/\/ containers with cgroupns=host, default setting is _root==cgroup_path\n+      if (strcmp(_root, cgroup_path) != 0) {\n+        if (*cgroup_path != '\\0' && strcmp(cgroup_path, \"\/\") != 0) {\n+          \/\/ When moved to a subgroup, between subgroups, the path suffix will change.\n+          const char *suffix = cgroup_path;\n+          while (suffix != nullptr) {\n+            stringStream pp;\n+            pp.print_raw(_mount_point);\n+            pp.print_raw(suffix);\n+            if (os::file_exists(pp.base())) {\n+              ss.print_raw(suffix);\n+              if (suffix != cgroup_path) {\n+                log_trace(os, container)(\"set_subsystem_path: cgroup v1 path reduced to: %s.\", suffix);\n+              }\n+              break;\n+            }\n+            suffix = strchr(suffix+1, '\/');\n@@ -74,0 +84,1 @@\n+    _path = os::strdup(ss.base());\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2024, Red Hat Inc.\n@@ -318,1 +318,5 @@\n-    ss.print_raw(cgroup_path);\n+    if (strstr(cgroup_path, \"..\/\") == nullptr) {\n+      ss.print_raw(cgroup_path);\n+    } else {\n+      log_warning(os, container)(\"Cgroup cpu\/memory controller path includes '..\/', detected limits won't be accurate\");\n+    }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.lang.System.Logger.Level;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n@@ -47,0 +50,1 @@\n+            String path = mountPoint;\n@@ -48,0 +52,1 @@\n+                \/\/ host processes and containers with cgroupns=private\n@@ -49,9 +54,6 @@\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n+                    if (cgroupPath.indexOf(\"..\/\") == -1) {\n+                        path += cgroupPath;\n+                    } else {\n+                        System.getLogger(\"jdk.internal.platform\").log(Level.WARNING,\n+                                \"Cgroup cpu\/memory controller path includes '..\/', detected limits won't be accurate\");\n+                    }\n@@ -59,5 +61,18 @@\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n+            } else {\n+                \/\/ containers with cgroupns=host, default setting is _root==cgroup_path\n+                if (!cgroupPath.equals(root)) {\n+                    if (!cgroupPath.equals(\"\") && !cgroupPath.equals(\"\/\")) {\n+                        \/\/ When moved to a subgroup, between subgroups, the path suffix will change.\n+                        Path cgp = Path.of(cgroupPath);\n+                        int nameCount = cgp.getNameCount();\n+                        for (int i=0; i<nameCount; ++i) {\n+                            Path dir = Path.of(mountPoint, cgp.toString());\n+                            if (Files.isDirectory(dir)) {\n+                                path = dir.toString();\n+                                if (i > 0) {\n+                                    System.getLogger(\"jdk.internal.platform\").log(Level.DEBUG, String.format(\n+                                            \"Cgroup v1 path reduced to: %s.\", cgp));\n+                                }\n+                                break;\n+                            }\n+                            cgp = (cgp.getNameCount() > 1) ? cgp.subpath(1, cgp.getNameCount()) : Path.of(\"\");\n@@ -68,0 +83,1 @@\n+            this.path = path;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2024, Red Hat Inc.\n@@ -28,0 +28,1 @@\n+import java.lang.System.Logger.Level;\n@@ -38,1 +39,7 @@\n-        this.path = Paths.get(mountPath, cgroupPath).toString();\n+        if (cgroupPath.indexOf(\"..\/\") == -1) {\n+            this.path = Paths.get(mountPath, cgroupPath).toString();\n+        } else {\n+            this.path = mountPath;\n+            System.getLogger(\"jdk.internal.platform\").log(Level.WARNING,\n+                    \"Cgroup cpu\/memory controller path includes '..\/', detected limits won't be accurate\");\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -437,1 +437,7 @@\n-  int length = 2;\n+  TestCase container_moving_cgroup = {\n+    \"\/sys\/fs\/cgroup\/cpu,cpuacct\",                                            \/\/ mount_path\n+    \"\/system.slice\/garden.service\/garden\/good\/2f57368b-0eda-4e52-64d8-af5c\", \/\/ root_path\n+    \"\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\",  \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/cpu,cpuacct\"                                             \/\/ expected_path\n+  };\n+  int length = 3;\n@@ -439,1 +445,2 @@\n-                            &container_engine };\n+                            &container_engine,\n+                            &container_moving_cgroup };\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (C) 2024, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.internal.platform.Metrics;\n+\n+import java.util.ArrayList;\n+\n+\/*\n+ * @test\n+ * @bug 8343191\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run main TestMemoryWithSubgroups\n+ *\/\n+public class TestMemoryWithSubgroups {\n+\n+    private static final String imageName = Common.imageName(\"subgroup\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Metrics metrics = Metrics.systemMetrics();\n+        if (metrics == null) {\n+            System.out.println(\"Cgroup not configured.\");\n+            return;\n+        }\n+        if (!DockerTestUtils.canTestDocker()) {\n+            System.out.println(\"Unable to run docker tests.\");\n+            return;\n+        }\n+        if (\"cgroupv1\".equals(metrics.getProvider())) {\n+\n+            Common.prepareWhiteBox();\n+            DockerTestUtils.buildJdkContainerImage(imageName);\n+\n+            try {\n+                testMemoryLimitSubgroupV1(\"100m\", \"104857600\", false);\n+                testMemoryLimitSubgroupV1(\"500m\", \"524288000\", false);\n+                testMemoryLimitSubgroupV1(\"100m\", \"104857600\", true);\n+                testMemoryLimitSubgroupV1(\"500m\", \"524288000\", true);\n+            } finally {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        } else if (\"cgroupv2\".equals(metrics.getProvider())) {\n+\n+            Common.prepareWhiteBox();\n+            DockerTestUtils.buildJdkContainerImage(imageName);\n+\n+            try {\n+                testMemoryLimitSubgroupV2(\"100m\", \"104857600\", false);\n+                testMemoryLimitSubgroupV2(\"500m\", \"524288000\", false);\n+                testMemoryLimitSubgroupV2(\"100m\", \"104857600\", true);\n+                testMemoryLimitSubgroupV2(\"500m\", \"524288000\", true);\n+            } finally {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        } else {\n+            System.out.println(\"Metrics are from neither cgroup v1 nor v2, skipped for now.\");\n+        }\n+    }\n+\n+    private static void testMemoryLimitSubgroupV1(String valueToSet, String expectedValue, boolean privateNamespace)\n+            throws Exception {\n+\n+        Common.logNewTestCase(\"Cgroup V1 subgroup memory limit: \" + valueToSet);\n+\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", \"1g\");\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo \" + valueToSet + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.limit_in_bytes ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"\/jdk\/bin\/java -Xlog:os+container=trace -version\");\n+\n+        Common.run(opts)\n+            .shouldMatch(\"Lowest limit was:.*\" + expectedValue);\n+    }\n+\n+    private static void testMemoryLimitSubgroupV2(String valueToSet, String expectedValue, boolean privateNamespace)\n+            throws Exception {\n+\n+        Common.logNewTestCase(\"Cgroup V2 subgroup memory limit: \" + valueToSet);\n+\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", \"1g\");\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/cgroup.subtree_control ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/memory\/cgroup.subtree_control ; \" +\n+            \"echo \" + valueToSet + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.max ; \" +\n+            \"\/jdk\/bin\/java -Xlog:os+container=trace -version\");\n+\n+        Common.run(opts)\n+            .shouldMatch(\"Lowest limit was:.*\" + expectedValue);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithSubgroups.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Red Hat, Inc.\n+ * Copyright (c) 2022, 2024, Red Hat, Inc.\n@@ -67,0 +67,3 @@\n+    \/*\n+     * Less common cases: Containers\n+     *\/\n@@ -74,1 +77,1 @@\n-        String expectedPath = mountPoint + \"\/some\";\n+        String expectedPath = mountPoint;\n@@ -78,0 +81,10 @@\n+    @Test\n+    public void testCgPathToMovedPath() {\n+        String root = \"\/system.slice\/garden.service\/garden\/good\/2f57368b-0eda-4e52-64d8-af5c\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/cpu,cpuacct\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint;\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupV1SubsystemControllerTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2024, Red Hat Inc.\n@@ -47,0 +47,1 @@\n+import jdk.internal.platform.cgroupv1.CgroupV1SubsystemController;\n@@ -78,0 +79,1 @@\n+    private Path cgroupv1MntInfoNonTrivialRoot;\n@@ -80,0 +82,1 @@\n+    private Path cgroupv1SelfNonTrivialRoot;\n@@ -178,0 +181,1 @@\n+    private String mntInfoNonTrivialRoot = \"2207 2196 0:43 \/system.slice\/garden.service\/garden\/good\/2f57368b-0eda-4e52-64d8-af5c \/sys\/fs\/cgroup\/cpu,cpuacct ro,nosuid,nodev,noexec,relatime master:25 - cgroup cgroup rw,cpu,cpuacct\\n\";\n@@ -233,0 +237,1 @@\n+    private String cgroupv1SelfNTRoot = \"11:cpu,cpuacct:\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\\n\";\n@@ -297,0 +302,3 @@\n+            cgroupv1MntInfoNonTrivialRoot = Paths.get(existingDirectory.toString(), \"mountinfo_nt_root\");\n+            Files.writeString(cgroupv1MntInfoNonTrivialRoot, mntInfoNonTrivialRoot);\n+\n@@ -303,0 +311,3 @@\n+            cgroupv1SelfNonTrivialRoot = Paths.get(existingDirectory.toString(), \"self_nt_root_cgv1\");\n+            Files.writeString(cgroupv1SelfNonTrivialRoot, cgroupv1SelfNTRoot);\n+\n@@ -452,0 +463,21 @@\n+    @Test\n+    public void testMountPrefixCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonTrivialRoot.toString();\n+        String selfCgroup = cgroupv1SelfNonTrivialRoot.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(cpuInfo.getCgroupPath(), \"\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\");\n+        String expectedMountPoint = \"\/sys\/fs\/cgroup\/cpu,cpuacct\";\n+        assertEquals(expectedMountPoint, cpuInfo.getMountPoint());\n+        CgroupV1SubsystemController cgroupv1MemoryController = new CgroupV1SubsystemController(cpuInfo.getMountRoot(), cpuInfo.getMountPoint());\n+        cgroupv1MemoryController.setPath(cpuInfo.getCgroupPath());\n+        String actualPath = cgroupv1MemoryController.path();\n+        assertNotNull(actualPath);\n+        String expectedPath = expectedMountPoint;\n+        assertEquals(\"Should be equal to the mount point path\", expectedPath, actualPath);\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerfileConfig;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+\n+import java.util.ArrayList;\n+\n+\/*\n+ * @test\n+ * @bug 8343191\n+ * @key cgroups\n+ * @summary Cgroup v1 subsystem fails to set subsystem path\n+ * @requires container.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build MetricsMemoryTester\n+ * @run main TestDockerMemoryMetricsSubgroup\n+ *\/\n+\n+public class TestDockerMemoryMetricsSubgroup {\n+    private static final String imageName =\n+            DockerfileConfig.getBaseImageName() + \":\" +\n+            DockerfileConfig.getBaseImageVersion();\n+\n+    public static void main(String[] args) throws Exception {\n+        Metrics metrics = Metrics.systemMetrics();\n+        if (metrics == null) {\n+            System.out.println(\"Cgroup not configured.\");\n+            return;\n+        }\n+        if (!DockerTestUtils.canTestDocker()) {\n+            System.out.println(\"Unable to run docker tests.\");\n+            return;\n+        }\n+        if (\"cgroupv1\".equals(metrics.getProvider())) {\n+            testMemoryLimitSubgroupV1(\"200m\", \"400m\", false);\n+            testMemoryLimitSubgroupV1(\"500m\", \"1G\", false);\n+            testMemoryLimitSubgroupV1(\"200m\", \"400m\", true);\n+            testMemoryLimitSubgroupV1(\"500m\", \"1G\", true);\n+        } else if (\"cgroupv2\".equals(metrics.getProvider())) {\n+            testMemoryLimitSubgroupV2(\"200m\", \"400m\", false);\n+            testMemoryLimitSubgroupV2(\"500m\", \"1G\", false);\n+            testMemoryLimitSubgroupV2(\"200m\", \"400m\", true);\n+            testMemoryLimitSubgroupV2(\"500m\", \"1G\", true);\n+        } else {\n+            System.out.println(\"Metrics are from neither cgroup v1 nor v2, skipped for now.\");\n+        }\n+    }\n+\n+    private static void testMemoryLimitSubgroupV1(String innerSize, String outerGroupMemorySize, boolean privateNamespace) throws Exception {\n+        Common.logNewTestCase(\"testMemoryLimitSubgroup, innerSize = \" + innerSize);\n+        DockerRunOptions opts =\n+            new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\")\n+            .addDockerOpts(\"--volume\", Utils.TEST_JDK + \":\/jdk\")\n+            .addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", outerGroupMemorySize);\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo \" + innerSize + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.limit_in_bytes ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"\/jdk\/bin\/java -cp \/test-classes\/ \" +\n+            \"--add-exports java.base\/jdk.internal.platform=ALL-UNNAMED \" +\n+            \"MetricsMemoryTester memory \" + innerSize);\n+\n+        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+    }\n+\n+    private static void testMemoryLimitSubgroupV2(String innerSize, String outerGroupMemorySize, boolean privateNamespace) throws Exception {\n+        Common.logNewTestCase(\"testMemoryLimitSubgroup, innerSize = \" + innerSize);\n+        DockerRunOptions opts =\n+            new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\")\n+            .addDockerOpts(\"--volume\", Utils.TEST_JDK + \":\/jdk\")\n+            .addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", outerGroupMemorySize);\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/cgroup.subtree_control ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/memory\/cgroup.subtree_control ; \" +\n+            \"echo \" + innerSize + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.max ; \" +\n+            \"\/jdk\/bin\/java -cp \/test-classes\/ \" +\n+            \"--add-exports java.base\/jdk.internal.platform=ALL-UNNAMED \" +\n+            \"MetricsMemoryTester memory \" + innerSize);\n+\n+        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetricsSubgroup.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}