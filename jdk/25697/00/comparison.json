{"files":[{"patch":"@@ -177,131 +177,0 @@\n-\n-    \/**\n-     * <p>Descriptor constructor taking an XML String.<\/p>\n-     *\n-     * <p>The format of the XML string is not defined, but an\n-     * implementation must ensure that the string returned by\n-     * {@link #toXMLString() toXMLString()} on an existing\n-     * descriptor can be used to instantiate an equivalent\n-     * descriptor using this constructor.<\/p>\n-     *\n-     * <p>In this implementation, all field values will be created\n-     * as Strings.  If the field values are not Strings, the\n-     * programmer will have to reset or convert these fields\n-     * correctly.<\/p>\n-     *\n-     * @param inStr An XML-formatted string used to populate this\n-     * Descriptor.  The format is not defined, but any\n-     * implementation must ensure that the string returned by\n-     * method {@link #toXMLString toXMLString} on an existing\n-     * descriptor can be used to instantiate an equivalent\n-     * descriptor when instantiated using this constructor.\n-     *\n-     * @exception RuntimeOperationsException If the String inStr\n-     * passed in parameter is null\n-     * @exception XMLParseException XML parsing problem while parsing\n-     * the input String\n-     * @exception MBeanException Wraps a distributed communication Exception.\n-     * @deprecated This constructor exists for historical reasons.  If\n-     * reading from XML is required, it should be implemented externally.\n-     *\/\n-    \/* At some stage we should rewrite this code to be cleverer.  Using\n-       a StringTokenizer as we do means, first, that we accept a lot of\n-       bogus strings without noticing they are bogus, and second, that we\n-       split the string being parsed at characters like > even if they\n-       occur in the middle of a field value. *\/\n-    @Deprecated(since=\"25\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    public DescriptorSupport(String inStr)\n-            throws MBeanException, RuntimeOperationsException,\n-                   XMLParseException {\n-        \/* parse an XML-formatted string and populate internal\n-         * structure with it *\/\n-        if (MODELMBEAN_LOGGER.isLoggable(Level.TRACE)) {\n-            MODELMBEAN_LOGGER.log(Level.TRACE,\n-                    \"Descriptor(String = '\" + inStr + \"') Constructor\");\n-        }\n-        if (inStr == null) {\n-            if (MODELMBEAN_LOGGER.isLoggable(Level.TRACE)) {\n-                MODELMBEAN_LOGGER.log(Level.TRACE,\n-                        \"Descriptor(String = null) Illegal arguments\");\n-            }\n-            final String msg = \"String in parameter is null\";\n-            final RuntimeException iae = new IllegalArgumentException(msg);\n-            throw new RuntimeOperationsException(iae, msg);\n-        }\n-\n-        final String lowerInStr = inStr.toLowerCase(Locale.ENGLISH);\n-        if (!lowerInStr.startsWith(\"<descriptor>\")\n-            || !lowerInStr.endsWith(\"<\/descriptor>\")) {\n-            throw new XMLParseException(\"No <descriptor>, <\/descriptor> pair\");\n-            \/\/ XMLParseException is deprecated for removal.\n-        }\n-\n-        \/\/ parse xmlstring into structures\n-        init(null);\n-        \/\/ create dummy descriptor: should have same size\n-        \/\/ as number of fields in xmlstring\n-        \/\/ loop through structures and put them in descriptor\n-\n-        StringTokenizer st = new StringTokenizer(inStr, \"<> \\t\\n\\r\\f\");\n-\n-        boolean inFld = false;\n-        boolean inDesc = false;\n-        String fieldName = null;\n-        String fieldValue = null;\n-\n-\n-        while (st.hasMoreTokens()) {  \/\/ loop through tokens\n-            String tok = st.nextToken();\n-\n-            if (tok.equalsIgnoreCase(\"FIELD\")) {\n-                inFld = true;\n-            } else if (tok.equalsIgnoreCase(\"\/FIELD\")) {\n-                if ((fieldName != null) && (fieldValue != null)) {\n-                    fieldName =\n-                        fieldName.substring(fieldName.indexOf('\"') + 1,\n-                                            fieldName.lastIndexOf('\"'));\n-                    final Object fieldValueObject =\n-                        parseQuotedFieldValue(fieldValue);\n-                    setField(fieldName, fieldValueObject);\n-                }\n-                fieldName = null;\n-                fieldValue = null;\n-                inFld = false;\n-            } else if (tok.equalsIgnoreCase(\"DESCRIPTOR\")) {\n-                inDesc = true;\n-            } else if (tok.equalsIgnoreCase(\"\/DESCRIPTOR\")) {\n-                inDesc = false;\n-                fieldName = null;\n-                fieldValue = null;\n-                inFld = false;\n-            } else if (inFld && inDesc) {\n-                \/\/ want kw=value, eg, name=\"myname\" value=\"myvalue\"\n-                int eq_separator = tok.indexOf('=');\n-                if (eq_separator > 0) {\n-                    String kwPart = tok.substring(0,eq_separator);\n-                    String valPart = tok.substring(eq_separator+1);\n-                    if (kwPart.equalsIgnoreCase(\"NAME\"))\n-                        fieldName = valPart;\n-                    else if (kwPart.equalsIgnoreCase(\"VALUE\"))\n-                        fieldValue = valPart;\n-                    else {  \/\/ xml parse exception\n-                        final String msg =\n-                            \"Expected `name' or `value', got `\" + tok + \"'\";\n-                        throw new XMLParseException(msg);\n-                        \/\/ XMLParseException is deprecated for removal.\n-                    }\n-                } else { \/\/ xml parse exception\n-                    final String msg =\n-                        \"Expected `keyword=value', got `\" + tok + \"'\";\n-                    throw new XMLParseException(msg);\n-                    \/\/ XMLParseException is deprecated for removal.\n-                }\n-            }\n-        }  \/\/ while tokens\n-        if (MODELMBEAN_LOGGER.isLoggable(Level.TRACE)) {\n-            MODELMBEAN_LOGGER.log(Level.TRACE,\n-                    \"Descriptor(XMLString) Exit\");\n-        }\n-    }\n-\n@@ -949,225 +818,0 @@\n-\n-\n-    \/**\n-     * <p>Returns an XML String representing the descriptor.<\/p>\n-     *\n-     * <p>The format is not defined, but an implementation must\n-     * ensure that the string returned by this method can be\n-     * used to build an equivalent descriptor when instantiated\n-     * using the constructor {@link #DescriptorSupport(String)\n-     * DescriptorSupport(String inStr)}.<\/p>\n-     *\n-     * <p>Fields which are not String objects will have toString()\n-     * called on them to create the value. The value will be\n-     * enclosed in parentheses.  It is not guaranteed that you can\n-     * reconstruct these objects unless they have been\n-     * specifically set up to support toString() in a meaningful\n-     * format and have a matching constructor that accepts a\n-     * String in the same format.<\/p>\n-     *\n-     * <p>If the descriptor is empty the following String is\n-     * returned: &lt;Descriptor&gt;&lt;\/Descriptor&gt;<\/p>\n-     *\n-     * @return the XML string.\n-     *\n-     * @exception RuntimeOperationsException for illegal value for\n-     * field Names or field Values.  If the XML formatted string\n-     * construction fails for any reason, this exception will be\n-     * thrown.\n-     * @deprecated This method exists for historical reasons.  If\n-     * writing to XML is required, it should be implemented externally.\n-     *\/\n-    @Deprecated(since=\"25\", forRemoval=true)\n-    public synchronized String toXMLString() {\n-        final StringBuilder buf = new StringBuilder(\"<Descriptor>\");\n-        Set<Map.Entry<String, Object>> returnedSet = descriptorMap.entrySet();\n-        for (Map.Entry<String, Object> currElement : returnedSet) {\n-            final String name = currElement.getKey();\n-            Object value = currElement.getValue();\n-            String valueString = null;\n-            \/* Set valueString to non-null if and only if this is a string that\n-               cannot be confused with the encoding of an object.  If it\n-               could be so confused (surrounded by parentheses) then we\n-               call makeFieldValue as for any non-String object and end\n-               up with an encoding like \"(java.lang.String\/(thing))\".  *\/\n-            if (value instanceof String) {\n-                final String svalue = (String) value;\n-                if (!svalue.startsWith(\"(\") || !svalue.endsWith(\")\"))\n-                    valueString = quote(svalue);\n-            }\n-            if (valueString == null)\n-                valueString = makeFieldValue(value);\n-            buf.append(\"<field name=\\\"\").append(name).append(\"\\\" value=\\\"\")\n-                .append(valueString).append(\"\\\"><\/field>\");\n-        }\n-        buf.append(\"<\/Descriptor>\");\n-        return buf.toString();\n-    }\n-\n-    private static final String[] entities = {\n-        \" &#32;\",\n-        \"\\\"&quot;\",\n-        \"<&lt;\",\n-        \">&gt;\",\n-        \"&&amp;\",\n-        \"\\r&#13;\",\n-        \"\\t&#9;\",\n-        \"\\n&#10;\",\n-        \"\\f&#12;\",\n-    };\n-    private static final Map<String,Character> entityToCharMap =\n-        new HashMap<>();\n-    private static final String[] charToEntityMap;\n-\n-    static {\n-        char maxChar = 0;\n-        for (int i = 0; i < entities.length; i++) {\n-            final char c = entities[i].charAt(0);\n-            if (c > maxChar)\n-                maxChar = c;\n-        }\n-        charToEntityMap = new String[maxChar + 1];\n-        for (int i = 0; i < entities.length; i++) {\n-            final char c = entities[i].charAt(0);\n-            final String entity = entities[i].substring(1);\n-            charToEntityMap[c] = entity;\n-            entityToCharMap.put(entity, c);\n-        }\n-    }\n-\n-    private static boolean isMagic(char c) {\n-        return (c < charToEntityMap.length && charToEntityMap[c] != null);\n-    }\n-\n-    \/*\n-     * Quote the string so that it will be acceptable to the (String)\n-     * constructor.  Since the parsing code in that constructor is fairly\n-     * stupid, we're obliged to quote apparently innocuous characters like\n-     * space, <, and >.  In a future version, we should rewrite the parser\n-     * and only quote \" plus either \\ or & (depending on the quote syntax).\n-     *\/\n-    private static String quote(String s) {\n-        boolean found = false;\n-        for (int i = 0; i < s.length(); i++) {\n-            if (isMagic(s.charAt(i))) {\n-                found = true;\n-                break;\n-            }\n-        }\n-        if (!found)\n-            return s;\n-        final StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < s.length(); i++) {\n-            char c = s.charAt(i);\n-            if (isMagic(c))\n-                buf.append(charToEntityMap[c]);\n-            else\n-                buf.append(c);\n-        }\n-        return buf.toString();\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static String unquote(String s) throws XMLParseException {\n-        if (!s.startsWith(\"\\\"\") || !s.endsWith(\"\\\"\")) {\n-            throw new XMLParseException(\"Value must be quoted: <\" + s + \">\");\n-            \/\/ XMLParseException is deprecated for removal.\n-        }\n-        final StringBuilder buf = new StringBuilder();\n-        final int len = s.length() - 1;\n-        for (int i = 1; i < len; i++) {\n-            final char c = s.charAt(i);\n-            final int semi;\n-            final Character quoted;\n-            if (c == '&'\n-                && (semi = s.indexOf(';', i + 1)) >= 0\n-                && ((quoted = entityToCharMap.get(s.substring(i, semi+1)))\n-                    != null)) {\n-                buf.append(quoted);\n-                i = semi;\n-            } else\n-                buf.append(c);\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Make the string that will go inside \"...\" for a value that is not\n-     * a plain String.\n-     * @throws RuntimeOperationsException if the value cannot be encoded.\n-     *\/\n-    private static String makeFieldValue(Object value) {\n-        if (value == null)\n-            return \"(null)\";\n-\n-        Class<?> valueClass = value.getClass();\n-        try {\n-            valueClass.getConstructor(String.class);\n-        } catch (NoSuchMethodException e) {\n-            final String msg =\n-                \"Class \" + valueClass + \" does not have a public \" +\n-                \"constructor with a single string arg\";\n-            final RuntimeException iae = new IllegalArgumentException(msg);\n-            throw new RuntimeOperationsException(iae,\n-                                                 \"Cannot make XML descriptor\");\n-        } catch (SecurityException e) {\n-            \/\/ OK: we'll pretend the constructor is there\n-            \/\/ too bad if it's not: we'll find out when we try to\n-            \/\/ reconstruct the DescriptorSupport\n-        }\n-\n-        final String quotedValueString = quote(value.toString());\n-\n-        return \"(\" + valueClass.getName() + \"\/\" + quotedValueString + \")\";\n-    }\n-\n-    \/*\n-     * Parse a field value from the XML produced by toXMLString().\n-     * Given a descriptor XML containing <field name=\"nnn\" value=\"vvv\">,\n-     * the argument to this method will be \"vvv\" (a string including the\n-     * containing quote characters).  If vvv begins and ends with parentheses,\n-     * then it may contain:\n-     * - the characters \"null\", in which case the result is null;\n-     * - a value of the form \"some.class.name\/xxx\", in which case the\n-     * result is equivalent to `new some.class.name(\"xxx\")';\n-     * - some other string, in which case the result is that string,\n-     * without the parentheses.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static Object parseQuotedFieldValue(String s)\n-            throws XMLParseException {\n-        s = unquote(s);\n-        if (s.equalsIgnoreCase(\"(null)\"))\n-            return null;\n-        if (!s.startsWith(\"(\") || !s.endsWith(\")\"))\n-            return s;\n-        final int slash = s.indexOf('\/');\n-        if (slash < 0) {\n-            \/\/ compatibility: old code didn't include class name\n-            return s.substring(1, s.length() - 1);\n-        }\n-        final String className = s.substring(1, slash);\n-\n-        final Constructor<?> constr;\n-        try {\n-            final ClassLoader contextClassLoader =\n-                Thread.currentThread().getContextClassLoader();\n-            final Class<?> c =\n-                Class.forName(className, false, contextClassLoader);\n-            constr = c.getConstructor(new Class<?>[] {String.class});\n-        } catch (Exception e) {\n-            throw new XMLParseException(e, \"Cannot parse value: <\" + s + \">\");\n-            \/\/ XMLParseException is deprecated for removal.\n-        }\n-        final String arg = s.substring(slash + 1, s.length() - 1);\n-        try {\n-            return constr.newInstance(new Object[] {arg});\n-        } catch (Exception e) {\n-            final String msg =\n-                \"Cannot construct instance of \" + className +\n-                \" with arg: <\" + s + \">\";\n-            throw new XMLParseException(e, msg);\n-            \/\/ XMLParseException is deprecated for removal.\n-        }\n-    }\n-\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":0,"deletions":356,"binary":false,"changes":356,"status":"modified"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @author    IBM Corp.\n- *\n- * Copyright IBM Corp. 1999-2000.  All rights reserved.\n- *\/\n-\n-\n-package javax.management.modelmbean;\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamField;\n-\n-\/**\n-* This exception is thrown when an XML formatted string is being parsed into ModelMBean objects\n-* or when XML formatted strings are being created from ModelMBean objects.\n-*\n-* It is also used to wrapper exceptions from XML parsers that may be used.\n-*\n-* <p>The <b>serialVersionUID<\/b> of this class is <code>3176664577895105181L<\/code>.\n-*\n-* @deprecated This class exists only to support XML parsing implemented privately in this module,\n-* in DescriptorSupport.  That feature is deprecated for removal.\n-*\n-* @since 1.5\n-*\/\n-@Deprecated(since=\"25\", forRemoval=true)\n-public class XMLParseException\n-extends Exception\n-{\n-    private static final long serialVersionUID = 3176664577895105181L;\n-\n-    \/**\n-     * Default constructor .\n-     *\/\n-    public  XMLParseException ()\n-    {\n-      super(\"XML Parse Exception.\");\n-    }\n-\n-    \/**\n-     * Constructor taking a string.\n-     *\n-     * @param s the detail message.\n-     *\/\n-    public  XMLParseException (String s)\n-    {\n-      super(\"XML Parse Exception: \" + s);\n-    }\n-    \/**\n-     * Constructor taking a string and an exception.\n-     *\n-     * @param e the nested exception.\n-     * @param s the detail message.\n-     *\/\n-    public  XMLParseException (Exception e, String s)\n-    {\n-      super(\"XML Parse Exception: \" + s + \":\" + e.toString());\n-    }\n-\n-    \/**\n-     * Deserializes an {@link XMLParseException} from an {@link ObjectInputStream}.\n-     *\/\n-    private void readObject(ObjectInputStream in)\n-            throws IOException, ClassNotFoundException {\n-      \/\/ New serial form ignores extra field \"msgStr\"\n-      in.defaultReadObject();\n-    }\n-\n-\n-    \/**\n-     * Serializes an {@link XMLParseException} to an {@link ObjectOutputStream}.\n-     *\/\n-    private void writeObject(ObjectOutputStream out)\n-            throws IOException {\n-      out.defaultWriteObject();\n-    }\n-}\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/XMLParseException.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -49,1 +49,0 @@\n-import javax.management.modelmbean.XMLParseException;\n@@ -103,1 +102,0 @@\n-        exceptions.add(new XMLParseException());\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/ExceptionFactory.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,3 +186,0 @@\n-        ok &= caseTest(new DescriptorSupport(d1.toXMLString()),\n-                       \"DescriptorSupport(String)\");\n-        d1 = new DescriptorSupport(new String[] {\"NAME=blah\"});\n","filename":"test\/jdk\/javax\/management\/modelmbean\/DescriptorSupportTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4957393\n- * @summary Test that DescriptorSupport.toXMLString() can be used to\n- * reconstruct an equivalent DescriptorSupport\n- * @author Eamonn McManus\n- *\n- * @run clean DescriptorSupportXMLTest\n- * @run build DescriptorSupportXMLTest\n- * @run main DescriptorSupportXMLTest\n- *\/\n-\n-import java.util.Arrays;\n-\n-import javax.management.RuntimeOperationsException;\n-import javax.management.modelmbean.DescriptorSupport;\n-\n-public class DescriptorSupportXMLTest {\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\"Testing that DescriptorSupport.toXMLString() \" +\n-                           \"can be used to reconstruct an equivalent \" +\n-                           \"DescriptorSupport\");\n-        int failed = 0;\n-\n-        final Object[] testValues = {\n-            \/\/ Values that should be encodable.\n-            \"\",\n-            \"ok\",\n-            \"null\",\n-            \"(open\",\n-            \"close)\",\n-            \"(parens)\",\n-            \"quote\\\"quote\",\n-            \"a description with several words\",\n-            \"magic&\\\"\\\\<> \\r\\t\\n\\f;&;magic\",\n-            \"&lt;descriptor&gt;&&&&lt;\/descriptor&gt;\",\n-            \"&lt;descriptor&gt;&&&&lt;\/blahblahblah&gt;\",\n-            null,\n-            new Integer(10),\n-            Boolean.TRUE,\n-            new Float(1.0f),\n-\n-            \/\/ Values that are not encodable: it is important that we throw\n-            \/\/ an exception during encoding rather than waiting until decode\n-            \/\/ time to discover the problem.  These classes are not encodable\n-            \/\/ because they don't have a (String) constructor.\n-            new Character('!'),\n-            new java.util.HashMap(),\n-        };\n-\n-        for (int i = 0; i < testValues.length; i++) {\n-            final Object v = testValues[i];\n-            final String what =\n-                (v == null) ? \"null\" :\n-                (v.getClass().getName() + \"{\" + v + \"}\");\n-\n-            final DescriptorSupport in =\n-                new DescriptorSupport(new String[] {\"bloo\"}, new Object[] {v});\n-\n-            final String xml;\n-            try {\n-                xml = in.toXMLString();\n-            } catch (RuntimeOperationsException e) {\n-                final Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    System.out.println(\"OK: \" + what + \": got a \" +\n-                                       \"RuntimeOperationsException wrapping \" +\n-                                       \"an IllegalArgumentException: \" +\n-                                       cause.getMessage());\n-                } else {\n-                    final String causeString =\n-                        (cause == null) ? \"null\" : cause.getClass().getName();\n-                    System.out.println(\"FAILED: \" + what + \": got a \" +\n-                                       \"RuntimeOperationException wrapping \" +\n-                                       causeString);\n-                    failed++;\n-                }\n-                continue;\n-            }\n-\n-            System.out.println(\"Encoded \" + what + \" as \" + xml);\n-\n-            final DescriptorSupport out;\n-            try {\n-                out = new DescriptorSupport(xml);\n-            } catch (Exception e) {\n-                System.out.println(\"FAILED: \" + what + \": got an exception:\");\n-                e.printStackTrace(System.out);\n-                failed++;\n-                continue;\n-            }\n-\n-            final String[] names = out.getFieldNames();\n-            if (names.length != 1 || !\"bloo\".equals(names[0])) {\n-                System.out.println(\"FAILED: decoded names wrong: \" +\n-                                   Arrays.asList(names));\n-                failed++;\n-                continue;\n-            }\n-\n-            final Object[] values = out.getFieldValues(names);\n-            if (values.length != 1) {\n-                System.out.println(\"FAILED: wrong number of values: \" +\n-                                   Arrays.asList(values));\n-                failed++;\n-                continue;\n-            }\n-\n-            final Object outValue = values[0];\n-\n-            if (v == null) {\n-                if (outValue == null)\n-                    System.out.println(\"OK: decoded null value\");\n-                else {\n-                    System.out.println(\"FAILED: decoded null value as \" +\n-                                       outValue.getClass().getName() + \"{\" +\n-                                       outValue + \"}\");\n-                    failed++;\n-                }\n-                continue;\n-            }\n-\n-            if (outValue == null) {\n-                System.out.println(\"FAILED: decoded non-null value as null\");\n-                failed++;\n-                continue;\n-            }\n-\n-            if (v.getClass() != outValue.getClass()) {\n-                System.out.println(\"FAILED: decoded value has class \" +\n-                                   outValue.getClass().getName() + \"{\" +\n-                                   outValue + \"}\");\n-                failed++;\n-                continue;\n-            }\n-\n-            if (v.equals(outValue))\n-                System.out.println(\"OK: decoded value is equal to original\");\n-            else {\n-                System.out.println(\"FAILED: decoded value is different: {\" +\n-                                   outValue + \"}\");\n-                failed++;\n-            }\n-        }\n-\n-        if (failed == 0)\n-            System.out.println(\"OK: all tests passed\");\n-        else {\n-            System.out.println(\"TEST FAILED: fail count: \" + failed);\n-            System.exit(1);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/modelmbean\/DescriptorSupportXMLTest.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-        \"DescriptorSupport(String)\",\n@@ -75,3 +74,0 @@\n-                        ds = new DescriptorSupport(new DescriptorSupport().toXMLString());\n-                        break;\n-                    case 3:\n@@ -80,1 +76,1 @@\n-                    case 4:\n+                    case 3:\n@@ -83,1 +79,1 @@\n-                    case 5:\n+                    case 4:\n@@ -86,1 +82,1 @@\n-                    case 6:\n+                    case 5:\n","filename":"test\/jdk\/javax\/management\/modelmbean\/LoggingExceptionTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}