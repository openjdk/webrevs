{"files":[{"patch":"@@ -5992,8 +5992,1 @@\n-  tty->cr();\n-  tty->print_cr(\"idoms of early %d:\", early->_idx);\n-  dump_idom(early);\n-  tty->cr();\n-  tty->print_cr(\"idoms of (wrong) LCA %d:\", LCA->_idx);\n-  dump_idom(LCA);\n-  tty->cr();\n-  dump_real_LCA(early, LCA);\n+  dump_idoms(early, LCA);\n@@ -6003,5 +5996,24 @@\n-\/\/ Find the real LCA of early and the wrongly assumed LCA.\n-void PhaseIdealLoop::dump_real_LCA(Node* early, Node* wrong_lca) {\n-  assert(!is_dominator(early, wrong_lca) && !is_dominator(early, wrong_lca),\n-         \"sanity check that one node does not dominate the other\");\n-  assert(!has_ctrl(early) && !has_ctrl(wrong_lca), \"sanity check, no data nodes\");\n+\/\/ Class to compute the real LCA given an early node and a wrong LCA in a bad graph.\n+class RealLCA {\n+  const PhaseIdealLoop* _phase;\n+  Node* _early;\n+  Node* _wrong_lca;\n+  uint _early_index;\n+  int _wrong_lca_index;\n+\n+  \/\/ Given idom chains of early and wrong LCA: Walk through idoms starting at StartNode and find the first node which\n+  \/\/ is different: Return the previously visited node which must be the real LCA.\n+  \/\/ The node lists also contain _early and _wrong_lca, respectively.\n+  Node* find_real_lca(Unique_Node_List& early_with_idoms, Unique_Node_List& wrong_lca_with_idoms) {\n+    int early_index = early_with_idoms.size() - 1;\n+    int wrong_lca_index = wrong_lca_with_idoms.size() - 1;\n+    bool found_difference = false;\n+    do {\n+      if (early_with_idoms[early_index] != wrong_lca_with_idoms[wrong_lca_index]) {\n+        \/\/ First time early and wrong LCA idoms differ. Real LCA must be at the previous index.\n+        found_difference = true;\n+        break;\n+      }\n+      early_index--;\n+      wrong_lca_index--;\n+    } while (wrong_lca_index >= 0);\n@@ -6009,32 +6021,6 @@\n-  ResourceMark rm;\n-  Node_List nodes_seen;\n-  Node* real_LCA = NULL;\n-  Node* n1 = wrong_lca;\n-  Node* n2 = early;\n-  uint count_1 = 0;\n-  uint count_2 = 0;\n-  \/\/ Add early and wrong_lca to simplify calculation of idom indices\n-  nodes_seen.push(n1);\n-  nodes_seen.push(n2);\n-\n-  \/\/ Walk the idom chain up from early and wrong_lca and stop when they intersect.\n-  while (!n1->is_Start() && !n2->is_Start()) {\n-    n1 = idom(n1);\n-    n2 = idom(n2);\n-    if (n1 == n2) {\n-      \/\/ Both idom chains intersect at the same index\n-      real_LCA = n1;\n-      count_1 = nodes_seen.size() \/ 2;\n-      count_2 = count_1;\n-      break;\n-    }\n-    if (check_idom_chains_intersection(n1, count_1, count_2, &nodes_seen)) {\n-      real_LCA = n1;\n-      break;\n-    }\n-    if (check_idom_chains_intersection(n2, count_2, count_1, &nodes_seen)) {\n-      real_LCA = n2;\n-      break;\n-    }\n-    nodes_seen.push(n1);\n-    nodes_seen.push(n2);\n+    assert(early_index >= 0, \"must always find an LCA - cannot be early\");\n+    _early_index = early_index;\n+    _wrong_lca_index = wrong_lca_index;\n+    Node* real_lca = early_with_idoms[_early_index + 1]; \/\/ Plus one to skip _early.\n+    assert(found_difference || real_lca == _wrong_lca, \"wrong LCA dominates early and is therefore the real LCA\");\n+    return real_lca;\n@@ -6043,4 +6029,4 @@\n-  assert(real_LCA != NULL, \"must always find an LCA\");\n-  tty->print_cr(\"Real LCA of early %d (idom[%d]) and (wrong) LCA %d (idom[%d]):\", early->_idx, count_2, wrong_lca->_idx, count_1);\n-  real_LCA->dump();\n-}\n+  void dump(Node* real_lca) {\n+    tty->cr();\n+    tty->print_cr(\"idoms of early \\\"%d %s\\\":\", _early->_idx, _early->Name());\n+    _phase->dump_idom(_early, _early_index + 1);\n@@ -6048,14 +6034,9 @@\n-\/\/ Check if n is already on nodes_seen (i.e. idom chains of early and wrong_lca intersect at n). Determine the idom index of n\n-\/\/ on both idom chains and return them in idom_idx_new and idom_idx_other, respectively.\n-bool PhaseIdealLoop::check_idom_chains_intersection(const Node* n, uint& idom_idx_new, uint& idom_idx_other, const Node_List* nodes_seen) const {\n-  if (nodes_seen->contains(n)) {\n-    \/\/ The idom chain has just discovered n.\n-    \/\/ Divide by 2 because nodes_seen contains the same amount of nodes from both chains.\n-    idom_idx_new = nodes_seen->size() \/ 2;\n-\n-    \/\/ The other chain already contained n. Search the index.\n-    for (uint i = 0; i < nodes_seen->size(); i++) {\n-      if (nodes_seen->at(i) == n) {\n-        \/\/ Divide by 2 because nodes_seen contains the same amount of nodes from both chains.\n-        idom_idx_other = i \/ 2;\n-      }\n+    tty->cr();\n+    tty->print_cr(\"idoms of (wrong) LCA \\\"%d %s\\\":\", _wrong_lca->_idx, _wrong_lca->Name());\n+    _phase->dump_idom(_wrong_lca, _wrong_lca_index + 1);\n+\n+    tty->cr();\n+    tty->print(\"Real LCA of early \\\"%d %s\\\" (idom[%d]) and wrong LCA \\\"%d %s\\\"\",\n+               _early->_idx, _early->Name(), _early_index, _wrong_lca->_idx, _wrong_lca->Name());\n+    if (_wrong_lca_index >= 0) {\n+      tty->print(\" (idom[%d])\", _wrong_lca_index);\n@@ -6063,1 +6044,2 @@\n-    return true;\n+    tty->print_cr(\":\");\n+    real_lca->dump();\n@@ -6065,1 +6047,27 @@\n-  return false;\n+\n+ public:\n+  RealLCA(const PhaseIdealLoop* phase, Node* early, Node* wrong_lca)\n+      : _phase(phase), _early(early), _wrong_lca(wrong_lca), _early_index(0), _wrong_lca_index(0) {\n+    assert(!wrong_lca->is_Start(), \"StartNode is always a common dominator\");\n+  }\n+\n+  void compute_and_dump() {\n+    ResourceMark rm;\n+    Unique_Node_List early_with_idoms;\n+    Unique_Node_List wrong_lca_with_idoms;\n+    early_with_idoms.push(_early);\n+    wrong_lca_with_idoms.push(_wrong_lca);\n+    _phase->get_idoms(_early, 10000, early_with_idoms);\n+    _phase->get_idoms(_wrong_lca, 10000, wrong_lca_with_idoms);\n+    Node* real_lca = find_real_lca(early_with_idoms, wrong_lca_with_idoms);\n+    dump(real_lca);\n+  }\n+};\n+\n+\/\/ Dump the idom chain of early, of the wrong LCA and dump the real LCA of early and wrong LCA.\n+void PhaseIdealLoop::dump_idoms(Node* early, Node* wrong_lca) {\n+  assert(!is_dominator(early, wrong_lca), \"sanity check that early does not dominate wrong lca\");\n+  assert(!has_ctrl(early) && !has_ctrl(wrong_lca), \"sanity check, no data nodes\");\n+\n+  RealLCA real_lca(this, early, wrong_lca);\n+  real_lca.compute_and_dump();\n@@ -6138,1 +6146,1 @@\n-void PhaseIdealLoop::dump_idom(Node* n) const {\n+void PhaseIdealLoop::dump_idom(Node* n, const uint count) const {\n@@ -6142,4 +6150,23 @@\n-    for (int i = 0; i < 100 && !n->is_Start(); i++) {\n-      tty->print(\"idom[%d] \", i);\n-      n->dump();\n-      n = idom(n);\n+    ResourceMark rm;\n+    Unique_Node_List idoms;\n+    get_idoms(n, count, idoms);\n+    dump_idoms_in_reverse(n, idoms);\n+  }\n+}\n+\n+void PhaseIdealLoop::get_idoms(Node* n, const uint count, Unique_Node_List& idoms) const {\n+  Node* next = n;\n+  for (uint i = 0; !next->is_Start() && i < count; i++) {\n+    next = idom(next);\n+    assert(!idoms.member(next), \"duplicated idom is not possible\");\n+    idoms.push(next);\n+  }\n+}\n+\n+void PhaseIdealLoop::dump_idoms_in_reverse(const Node* n, const Node_List& idom_list) const {\n+  Node* next;\n+  uint padding = 3;\n+  uint node_index_padding_width = static_cast<int>(log10(C->unique())) + 1;\n+  for (int i = idom_list.size() - 1; i >= 0; i--) {\n+    if (i == 9 || i == 99) {\n+      padding++;\n@@ -6147,0 +6174,2 @@\n+    next = idom_list[i];\n+    tty->print_cr(\"idom[%d]:%*c%*d  %s\", i, padding, ' ', node_index_padding_width, next->_idx, next->Name());\n@@ -6148,0 +6177,1 @@\n+  tty->print_cr(\"n:      %*c%*d  %s\", padding, ' ', node_index_padding_width, n->_idx, n->Name());\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":100,"deletions":70,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -1659,4 +1659,2 @@\n-#ifdef ASSERT\n-  void dump_real_LCA(Node* early, Node* wrong_lca);\n-  bool check_idom_chains_intersection(const Node* n, uint& idom_idx_new, uint& idom_idx_other, const Node_List* nodes_seen) const;\n-#endif\n+  DEBUG_ONLY(void dump_idoms(Node* early, Node* wrong_lca);)\n+  NOT_PRODUCT(void dump_idoms_in_reverse(const Node* n, const Node_List& idom_list) const;)\n@@ -1675,1 +1673,3 @@\n-  void dump_idom(Node* n) const;\n+  void dump_idom(Node* n) const { dump_idom(n, 1000); } \/\/ For debugging\n+  void dump_idom(Node* n, uint count) const;\n+  void get_idoms(Node* n, uint count, Unique_Node_List& idoms) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}