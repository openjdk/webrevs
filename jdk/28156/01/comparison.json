{"files":[{"patch":"@@ -100,0 +100,1 @@\n+    private volatile boolean blockedByPacer;\n@@ -389,0 +390,1 @@\n+            congestionController.updatePacer(now);\n@@ -407,0 +409,1 @@\n+                long startTime = System.nanoTime();\n@@ -445,0 +448,1 @@\n+                        congestionController.appLimited();\n@@ -454,1 +458,7 @@\n-                blockedByCC = !cwndAvailable;\n+                if (packetsSent != 0 && Log.quicCC()) {\n+                    Log.logQuic(\"%s OUT: sent: %s packets in %s ns, cwnd limited: %s, pacer limited: %s\".formatted(\n+                            packetEmitter.logTag(), packetsSent, System.nanoTime() - startTime,\n+                            congestionController.isCwndLimited(), congestionController.isPacerLimited()));\n+                }\n+                blockedByCC = !cwndAvailable && congestionController.isCwndLimited();\n+                blockedByPacer = !cwndAvailable && congestionController.isPacerLimited();\n@@ -460,0 +470,1 @@\n+                        blockedByCC = blockedByPacer = false;\n@@ -1392,0 +1403,9 @@\n+        if (blockedByPacer) {\n+            Deadline pacerDeadline = congestionController.pacerDeadline();\n+            if (verbose && Log.quicTimer()) {\n+                Log.logQuic(String.format(\"%s: [%s] pacer deadline: %s, ackDeadline: %s, deadline in %s\",\n+                        packetEmitter.logTag(), packetNumberSpace, pacerDeadline, ackDeadline,\n+                        Utils.debugDeadline(now(), min(ackDeadline, pacerDeadline))));\n+            }\n+            return min(ackDeadline, pacerDeadline);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/PacketSpaceManager.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,45 @@\n+    \/**\n+     * {@return the current size of the congestion window in bytes}\n+     *\/\n+    long congestionWindow();\n+\n+    \/**\n+     * {@return the initial window size in bytes}\n+     *\/\n+    long initialWindow();\n+\n+    \/**\n+     * {@return maximum datagram size}\n+     *\/\n+    long maxDatagramSize();\n+\n+    \/**\n+     * {@return true if the connection is in slow start phase}\n+     *\/\n+    boolean isSlowStart();\n+\n+    \/**\n+     * Update the pacer with the current time\n+     * @param now the current time\n+     *\/\n+    void updatePacer(Deadline now);\n+\n+    \/**\n+     * {@return true if sending is blocked by pacer}\n+     *\/\n+    boolean isPacerLimited();\n+\n+    \/**\n+     * {@return true if sending is blocked by congestion window}\n+     *\/\n+    boolean isCwndLimited();\n+\n+    \/**\n+     * {@return deadline when pacer will unblock sending}\n+     *\/\n+    Deadline pacerDeadline();\n+\n+    \/**\n+     * Notify the congestion controller that sending is app-limited\n+     *\/\n+    void appLimited();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicCongestionController.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-        this.congestionController = new QuicRenoCongestionController(dbgTag);\n+        this.congestionController = new QuicRenoCongestionController(dbgTag, rttEstimator);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicConnectionImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.quic;\n+\n+import jdk.internal.net.http.common.Deadline;\n+import jdk.internal.net.http.common.Log;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.internal.util.OperatingSystem;\n+\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\/**\n+ * Implementation of pacing.\n+ *\n+ * When the connection is sending at a rate lower than permitted\n+ * by the congestion controller, pacer is responsible for spreading out\n+ * the outgoing packets across the entire RTT.\n+ *\n+ * Technically the pacer provides two functions:\n+ * - computes the number of packets that can be sent now\n+ * - computes the time when another packet can be sent\n+ *\n+ * When a new flow starts, or when the flow is not pacer-limited,\n+ * the pacer limits the window to:\n+ * max(INITIAL_WINDOW, pacingRate \/ timerFreq)\n+ * timerFreq is the best timer resolution we can get from the selector.\n+ * pacingRate is N * congestionWindow \/ smoothedRTT\n+ * where N = 2 when in slow start, N = 1.25 otherwise.\n+ *\n+ * After that, the window refills at pacingRate, up to two timer periods or 4 packets,\n+ * whichever is higher.\n+ *\n+ * The time when another packet can be sent is computed\n+ * as the time when the window will allow at least 2 packets.\n+ *\n+ * All methods are externally synchronized in congestion controller.\n+ *\n+ * Ideas taken from:\n+ * https:\/\/www.rfc-editor.org\/rfc\/rfc9002.html#name-pacing\n+ * https:\/\/www.ietf.org\/archive\/id\/draft-welzl-iccrg-pacing-03.html\n+ *\/\n+public class QuicPacer {\n+\n+    \/\/ usually 64 Hz on Windows, 1000 on Linux\n+    private static final long DEFAULT_TIMER_FREQ_HZ = OperatingSystem.isWindows() ? 64 : 1000;\n+    private static final long TIMER_FREQ_HZ = Math.clamp(\n+            Utils.getLongProperty(\"jdk.httpclient.quic.timerFrequency\", DEFAULT_TIMER_FREQ_HZ),\n+            1, 1000);\n+\n+    private final QuicRttEstimator rttEstimator;\n+    private final QuicCongestionController congestionController;\n+\n+    private boolean appLimited;\n+    private long quota;\n+    private Deadline lastUpdate;\n+\n+    \/**\n+     * Create a QUIC pacer for the given RTT estimator and congestion controller\n+     *\n+     * @param rttEstimator         the RTT estimator\n+     * @param congestionController the congestion controller\n+     *\/\n+    public QuicPacer(QuicRttEstimator rttEstimator,\n+                     QuicCongestionController congestionController) {\n+        this.rttEstimator = rttEstimator;\n+        this.congestionController = congestionController;\n+        this.appLimited = true;\n+    }\n+\n+    \/**\n+     * called to indicate that the flow is app-limited.\n+     * Alters the behavior of the following updateQuota call.\n+     *\/\n+    public void appLimited() {\n+        appLimited = true;\n+    }\n+\n+    \/**\n+     * {@return true if pacer quota not hit yet, false otherwise}\n+     *\/\n+    public boolean canSend() {\n+        return quota >= congestionController.maxDatagramSize();\n+    }\n+\n+    \/**\n+     * Update quota based on time since the last call to this method\n+     * and whether appLimited() was called or not.\n+     *\n+     * @param now current time\n+     *\/\n+    public void updateQuota(Deadline now) {\n+        if (lastUpdate != null && !now.isAfter(lastUpdate)) {\n+            \/\/ might happen when transmission tasks from different packet spaces\n+            \/\/ race to update quota. Keep the most recent update only.\n+            return;\n+        }\n+        long rttMicros = rttEstimator.state().smoothedRttMicros();\n+        long cwnd = congestionController.congestionWindow();\n+        if (rttMicros * TIMER_FREQ_HZ < TimeUnit.SECONDS.toMicros(2)) {\n+            \/\/ RTT less than two timer periods; don't pace\n+            quota = 2 * cwnd;\n+            lastUpdate = now;\n+            return;\n+        }\n+        long pacingRate = cwnd * (congestionController.isSlowStart() ? 2_000_000 : 1_250_000) \/ rttMicros; \/\/ bytes per second\n+        long initialWindow = congestionController.initialWindow();\n+        long onePeriodWindow = pacingRate \/ TIMER_FREQ_HZ;\n+        long maxQuota;\n+        if (appLimited) {\n+            maxQuota = Math.max(initialWindow, onePeriodWindow);\n+        } else {\n+            maxQuota = Math.max(2 * onePeriodWindow, 4 * congestionController.maxDatagramSize());\n+        }\n+        if (lastUpdate == null) {\n+            quota = Math.max(initialWindow, maxQuota);\n+        } else {\n+            long nanosSinceUpdate = Deadline.between(lastUpdate, now).toNanos();\n+            if (nanosSinceUpdate >= TimeUnit.MICROSECONDS.toNanos(rttMicros)) {\n+                \/\/ don't bother computing the increment, it might overflow and will be capped to maxQuota anyway\n+                quota = maxQuota;\n+                if (Log.quicCC()) {\n+                    Log.logQuic(\"pacer cwnd: %s, rtt %s us, duration %s ns, quota: %s\".formatted(\n+                            cwnd, rttMicros, nanosSinceUpdate, quota));\n+                }\n+            } else {\n+                long quotaIncrement = pacingRate * nanosSinceUpdate \/ 1_000_000_000;\n+                quota += quotaIncrement;\n+                quota = Math.min(quota, maxQuota);\n+                if (Log.quicCC()) {\n+                    Log.logQuic(\"pacer cwnd: %s, rtt %s us, duration %s ns, increment %s, quota %s\".formatted(\n+                            cwnd, rttMicros, nanosSinceUpdate, quotaIncrement, quota));\n+                }\n+            }\n+        }\n+        lastUpdate = now;\n+        appLimited = false;\n+    }\n+\n+    \/**\n+     * {@return the deadline when quota will increase to two packets}\n+     *\/\n+    public Deadline twoPacketDeadline() {\n+        long datagramSize = congestionController.maxDatagramSize();\n+        long quotaNeeded = datagramSize * 2 - quota;\n+        if (quotaNeeded <= 0) {\n+            assert canSend();\n+            return lastUpdate;\n+        }\n+        \/\/ Window increases at a rate of rtt \/ cwnd \/ N\n+        long rttMicros = rttEstimator.state().smoothedRttMicros();\n+        long cwnd = congestionController.congestionWindow();\n+        return lastUpdate.plus(rttMicros\n+                * (congestionController.isSlowStart() ? 500 : 800) \/* 1000\/N *\/\n+                * quotaNeeded \/ cwnd, ChronoUnit.NANOS);\n+    }\n+\n+    \/**\n+     * called to indicate that a packet was sent\n+     *\n+     * @param packetBytes packet size in bytes\n+     *\/\n+    public void packetSent(int packetBytes) {\n+        quota -= packetBytes;\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicPacer.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,3 @@\n-    public QuicRenoCongestionController(String dbgTag) {\n+    private final QuicPacer pacer;\n+\n+    public QuicRenoCongestionController(String dbgTag, QuicRttEstimator rttEstimator) {\n@@ -70,0 +72,1 @@\n+        this.pacer = new QuicPacer(rttEstimator, this);\n@@ -86,1 +89,1 @@\n-            Log.logQuic(dbgTag+ \" Congestion: ssThresh: \" + ssThresh +\n+            Log.logQuic(dbgTag + \" Congestion: ssThresh: \" + ssThresh +\n@@ -106,2 +109,4 @@\n-            var canSend = congestionWindow - bytesInFlight >= maxDatagramSize;\n-            return canSend;\n+            if (isCwndLimited() || isPacerLimited()) {\n+                return false;\n+            }\n+            return true;\n@@ -135,0 +140,1 @@\n+            pacer.packetSent(packetBytes);\n@@ -150,2 +156,2 @@\n-                if (Log.quicCC()) {\n-                    Log.logQuic(dbgTag+ \" Acked, in recovery: bytes: \" + packetBytes +\n+                if (Log.quicCC() && Log.trace()) {\n+                    Log.logQuic(dbgTag + \" Acked, in recovery: bytes: \" + packetBytes +\n@@ -168,1 +174,1 @@\n-            if (Log.quicCC()) {\n+            if (Log.quicCC() && Log.trace()) {\n@@ -170,1 +176,1 @@\n-                    Log.logQuic(dbgTag+ \" Acked, not blocked: bytes: \" + packetBytes +\n+                    Log.logQuic(dbgTag + \" Acked, not blocked: bytes: \" + packetBytes +\n@@ -197,1 +203,1 @@\n-                    Log.logQuic(dbgTag+ \" Persistent congestion: ssThresh: \" + ssThresh +\n+                    Log.logQuic(dbgTag + \" Persistent congestion: ssThresh: \" + ssThresh +\n@@ -220,0 +226,90 @@\n+\n+    @Override\n+    public long congestionWindow() {\n+        lock.lock();\n+        try {\n+            return congestionWindow;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long initialWindow() {\n+        lock.lock();\n+        try {\n+            return Math.max(14720, 2 * maxDatagramSize);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long maxDatagramSize() {\n+        lock.lock();\n+        try {\n+            return maxDatagramSize;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isSlowStart() {\n+        lock.lock();\n+        try {\n+            return congestionWindow < ssThresh;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void updatePacer(Deadline now) {\n+        lock.lock();\n+        try {\n+            pacer.updateQuota(now);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPacerLimited() {\n+        lock.lock();\n+        try {\n+            return !pacer.canSend();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isCwndLimited() {\n+        lock.lock();\n+        try {\n+            return congestionWindow - bytesInFlight < maxDatagramSize;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public Deadline pacerDeadline() {\n+        lock.lock();\n+        try {\n+            return pacer.twoPacketDeadline();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void appLimited() {\n+        lock.lock();\n+        try {\n+            pacer.appLimited();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicRenoCongestionController.java","additions":106,"deletions":10,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Deadline;\n+import jdk.internal.net.http.quic.QuicCongestionController;\n+import jdk.internal.net.http.quic.QuicPacer;\n+import jdk.internal.net.http.quic.QuicRttEstimator;\n+import jdk.internal.net.http.quic.packets.QuicPacket;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Djdk.httpclient.quic.timerFrequency=1000 PacerTest\n+ *\/\n+public class PacerTest {\n+\n+    private static class TestCongestionController implements QuicCongestionController {\n+        private long cwnd;\n+        private long iw;\n+        private long maxDatagramSize;\n+        private boolean isSlowStart;\n+\n+        private TestCongestionController(long cwnd, long iw, long maxDatagramSize, boolean isSlowStart) {\n+            this.cwnd = cwnd;\n+            this.iw = iw;\n+            this.maxDatagramSize = maxDatagramSize;\n+            this.isSlowStart = isSlowStart;\n+        }\n+\n+        @Override\n+        public boolean canSendPacket() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public void updateMaxDatagramSize(int newSize) {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public void packetSent(int packetBytes) {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public void packetAcked(int packetBytes, Deadline sentTime) {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public void packetLost(Collection<QuicPacket> lostPackets, Deadline sentTime, boolean persistent) {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public void packetDiscarded(Collection<QuicPacket> discardedPackets) {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public long congestionWindow() {\n+            return cwnd;\n+        }\n+\n+        @Override\n+        public long initialWindow() {\n+            return iw;\n+        }\n+\n+        @Override\n+        public long maxDatagramSize() {\n+            return maxDatagramSize;\n+        }\n+\n+        @Override\n+        public boolean isSlowStart() {\n+            return isSlowStart;\n+        }\n+\n+        @Override\n+        public void updatePacer(Deadline now) {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public boolean isPacerLimited() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public boolean isCwndLimited() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public Deadline pacerDeadline() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public void appLimited() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+    }\n+\n+    public record TestCase(int maxDatagramSize, int packetsInIW, int packetsInCwnd, int millisInRtt,\n+                           int initialPermit, int periodicPermit, boolean slowStart) {\n+    }\n+\n+    @DataProvider\n+    public Object[][] pacerFirstFlight() {\n+        return List.of(\n+                        \/\/ Should permit initial window before blocking\n+                        new TestCase(1200, 10, 32, 16, 10, 4, true),\n+                        \/\/ Should permit 2*cwnd\/rtt packets before blocking\n+                        new TestCase(1200, 10, 128, 16, 16, 16, true),\n+                        \/\/ Should permit 1.25*cwnd\/rtt packets before blocking\n+                        new TestCase(1200, 10, 256, 16, 20, 20, false)\n+                ).stream().map(Stream::of)\n+                .map(Stream::toArray)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"pacerFirstFlight\")\n+    public void testBasicPacing(TestCase test) {\n+        int maxDatagramSize = test.maxDatagramSize;\n+        int packetsInIW = test.packetsInIW;\n+        int packetsInCwnd = test.packetsInCwnd;\n+        int millisInRtt = test.millisInRtt;\n+        int permit = test.initialPermit;\n+        QuicCongestionController cc = new TestCongestionController(packetsInCwnd * maxDatagramSize,\n+                maxDatagramSize * packetsInIW, maxDatagramSize, test.slowStart);\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1000 * millisInRtt, 0, Deadline.MIN);\n+        QuicPacer pacer = new QuicPacer(rtt, cc);\n+        pacer.updateQuota(Deadline.MIN);\n+        for (int i = 0; i < permit; i++) {\n+            assertTrue(pacer.canSend(), \"Pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Pacer didn't block\");\n+        Deadline next = pacer.twoPacketDeadline();\n+        pacer.updateQuota(next);\n+        for (int i = 0; i < 2; i++) {\n+            assertTrue(pacer.canSend(), \"Two packet deadline: pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Two packet deadline: pacer didn't block\");\n+        next = next.plus(1, ChronoUnit.MILLIS);\n+        pacer.updateQuota(next);\n+        for (int i = 0; i < test.periodicPermit; i++) {\n+            assertTrue(pacer.canSend(), \"One millisecond: pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"One millisecond: pacer didn't block\");\n+        next = next.plus(3, ChronoUnit.MILLIS);\n+        pacer.updateQuota(next);\n+        \/\/ Quota capped at two millisecond equivalent\n+        for (int i = 0; i < 2 * test.periodicPermit; i++) {\n+            assertTrue(pacer.canSend(), \"Three milliseconds: pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Three milliseconds: pacer didn't block\");\n+        next = next.plus(3, ChronoUnit.MILLIS);\n+        pacer.appLimited();\n+        pacer.updateQuota(next);\n+        \/\/ App-limited: quota capped at initialPermit\n+        for (int i = 0; i < test.initialPermit; i++) {\n+            assertTrue(pacer.canSend(), \"App limited: pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"App limited: pacer didn't block\");\n+    }\n+\n+    @Test\n+    public void testPacingShortRtt() {\n+        int maxDatagramSize = 1200;\n+        int packetsInIW = 10;\n+        int packetsInCwnd = 32;\n+        QuicCongestionController cc = new TestCongestionController(packetsInCwnd * maxDatagramSize,\n+                maxDatagramSize * packetsInIW, maxDatagramSize, true);\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1000, 0, Deadline.MIN);\n+        QuicPacer pacer = new QuicPacer(rtt, cc);\n+        pacer.updateQuota(Deadline.MIN);\n+        for (int i = 0; i < 2 * packetsInCwnd; i++) {\n+            assertTrue(pacer.canSend(), \"Pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Pacer didn't block\");\n+        \/\/ when RTT is short, permit cwnd on every update\n+        Deadline next = pacer.twoPacketDeadline();\n+        pacer.updateQuota(next);\n+        for (int i = 0; i < 2 * packetsInCwnd; i++) {\n+            assertTrue(pacer.canSend(), \"Two packet deadline: pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Two packet deadline: pacer didn't block\");\n+    }\n+\n+    @Test\n+    public void testPacingSmallCwnd() {\n+        int maxDatagramSize = 1200;\n+        int packetsInIW = 10;\n+        int packetsInCwnd = 2;\n+        int millisInRtt = 16;\n+        QuicCongestionController cc = new TestCongestionController(packetsInCwnd * maxDatagramSize,\n+                maxDatagramSize * packetsInIW, maxDatagramSize, true);\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1000 * millisInRtt, 0, Deadline.MIN);\n+        QuicPacer pacer = new QuicPacer(rtt, cc);\n+        \/\/ first quota update is capped to IW\n+        pacer.updateQuota(Deadline.MIN);\n+        \/\/ update quota again. This time it's capped to 4 packets\n+        pacer.updateQuota(Deadline.MIN.plusNanos(1));\n+        for (int i = 0; i < 4; i++) {\n+            assertTrue(pacer.canSend(), \"Pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Pacer didn't block\");\n+        Deadline next = pacer.twoPacketDeadline();\n+        pacer.updateQuota(next);\n+        for (int i = 0; i < 2; i++) {\n+            assertTrue(pacer.canSend(), \"Two packet deadline: pacer blocked after \" + i + \" packets\");\n+            pacer.packetSent(maxDatagramSize);\n+        }\n+        assertFalse(pacer.canSend(), \"Two packet deadline: pacer didn't block\");\n+        \/\/ pacing rate is 1 packet per 4 milliseconds\n+        next = next.plus(4, ChronoUnit.MILLIS);\n+        pacer.updateQuota(next);\n+        assertTrue(pacer.canSend(), \"Pacer blocked after 4 millis\");\n+        pacer.packetSent(maxDatagramSize);\n+        assertFalse(pacer.canSend(), \"Pacer permitted 2 packets after 4 millis\");\n+\n+        next = next.plus(2, ChronoUnit.MILLIS);\n+        pacer.updateQuota(next);\n+        assertFalse(pacer.canSend(), \"Pacer permitted a packet after 2 millis\");\n+        next = next.plus(2, ChronoUnit.MILLIS);\n+        pacer.updateQuota(next);\n+        assertTrue(pacer.canSend(), \"Pacer blocked after 2x2 millis\");\n+        pacer.packetSent(maxDatagramSize);\n+        assertFalse(pacer.canSend(), \"Pacer permitted 2 packets after 2x2 millis\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/quic\/PacerTest.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import jdk.internal.net.http.quic.CodingContext;\n@@ -52,0 +53,1 @@\n+import jdk.internal.net.http.quic.QuicConnectionId;\n@@ -64,2 +66,0 @@\n-import jdk.internal.net.http.quic.CodingContext;\n-import jdk.internal.net.http.quic.QuicConnectionId;\n@@ -611,0 +611,32 @@\n+                @Override\n+                public long congestionWindow() {\n+                    return Integer.MAX_VALUE;\n+                }\n+                @Override\n+                public long initialWindow() {\n+                    return Integer.MAX_VALUE;\n+                }\n+                @Override\n+                public long maxDatagramSize() {\n+                    return 1200;\n+                }\n+                @Override\n+                public boolean isSlowStart() {\n+                    return false;\n+                }\n+                @Override\n+                public void updatePacer(Deadline now) { }\n+                @Override\n+                public boolean isPacerLimited() {\n+                    return false;\n+                }\n+                @Override\n+                public boolean isCwndLimited() {\n+                    return false;\n+                }\n+                @Override\n+                public Deadline pacerDeadline() {\n+                    return Deadline.MIN;\n+                }\n+                @Override\n+                public void appLimited() { }\n","filename":"test\/jdk\/java\/net\/httpclient\/quic\/PacketSpaceManagerTest.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"}]}