{"files":[{"patch":"@@ -34,9 +34,1 @@\n-\n-\/\/ These are inline variants of Thread::SpinAcquire with optional blocking in VM.\n-\n-class ShenandoahNoBlockOp : public StackObj {\n-public:\n-  ShenandoahNoBlockOp(JavaThread* java_thread) {\n-    assert(java_thread == nullptr, \"Should not pass anything\");\n-  }\n-};\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -46,2 +38,8 @@\n-  if (allow_block_for_safepoint && thread->is_Java_thread()) {\n-    contended_lock_internal<ThreadBlockInVM>(JavaThread::cast(thread));\n+  if (thread->is_Java_thread()) {\n+    \/\/Java threads spin a little before yielding and potentially blocking.\n+    constexpr uint32_t SPINS = 0x1F;\n+    if (allow_block_for_safepoint) {\n+      contended_lock_internal<true, SPINS>(thread);\n+    } else {\n+      contended_lock_internal<false, SPINS>(thread);\n+    }\n@@ -49,1 +47,6 @@\n-    contended_lock_internal<ShenandoahNoBlockOp>(nullptr);\n+    \/\/ Non-Java threads are not allowed to block, and they spin hard\n+    \/\/ to progress quickly. The normal number of GC threads is low enough\n+    \/\/ for this not to have detrimental effect. This favors GC threads\n+    \/\/ a little over Java threads, which is good for GC progress under\n+    \/\/ extreme contention.\n+    contended_lock_internal<false, UINT32_MAX>(thread);\n@@ -53,10 +56,17 @@\n-template<typename BlockOp>\n-void ShenandoahLock::contended_lock_internal(JavaThread* java_thread) {\n-  int ctr = 0;\n-  int yields = 0;\n-  while (Atomic::load(&_state) == locked ||\n-         Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n-    if ((++ctr & 0xFFF) == 0) {\n-      BlockOp block(java_thread);\n-      if (yields > 5) {\n-        os::naked_short_sleep(1);\n+\n+template<bool ALLOW_BLOCK, uint32_t MAX_SPINS>\n+void ShenandoahLock::contended_lock_internal(Thread* thread) {\n+  assert(!ALLOW_BLOCK || thread->is_Java_thread(), \"Must be a Java thread when allow block.\");\n+  uint32_t ctr = os::is_MP() ? MAX_SPINS : 0; \/\/Do not spin on single processor.\n+  do {\n+    if (ctr > 0 && !SafepointSynchronize::is_synchronizing()) {\n+      \/\/ Lightly contended, spin a little if SP it NOT synchronizing.\n+      SpinPause();\n+      ctr--;\n+    } else {\n+      if (ALLOW_BLOCK && SafepointSynchronize::is_synchronizing())) {\n+        \/\/ We know SP is synchronizing and block is allowed, block the thread in VM for faster SP synchronization.\n+        \/\/ Need to wait on STS_lock ( suspendible thread set)\n+        ThreadBlockInVM block(JavaThread::cast(thread), true);\n+        MonitorLocker ml(STS_lock, Mutex::_safepoint_check_flag);\n+        ml.wait();\n@@ -65,1 +75,0 @@\n-        yields++;\n@@ -67,2 +76,0 @@\n-    } else {\n-      SpinPause();\n@@ -70,1 +77,1 @@\n-  }\n+  } while (!try_lock(ALLOW_BLOCK));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  volatile Thread* _owner;\n+  Thread* volatile _owner;\n@@ -43,2 +43,8 @@\n-  template<typename BlockOp>\n-  void contended_lock_internal(JavaThread* java_thread);\n+  template<bool ALLOW_BLOC, uint32_t MAX_SPINS>\n+  void contended_lock_internal(Thread* thread);\n+\n+  inline bool try_lock(bool allow_lock) {\n+    if (Atomic::load(&_state) == locked) return false;\n+    if (SafepointSynchronize::is_synchronizing() && allow_lock) return false;\n+    return Atomic::cmpxchg(&_state, unlocked, locked) == unlocked; \n+  }\n@@ -52,3 +58,7 @@\n-    \/\/ Try to lock fast, or dive into contended lock handling.\n-    if (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n-      contended_lock(allow_block_for_safepoint);\n+    if(allow_block_for_safepoint && SafepointSynchronize::is_synchronizing()) {\n+        contended_lock(allow_block_for_safepoint);\n+    } else {\n+      \/\/ Try to lock fast, or dive into contended lock handling.\n+      if (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+        contended_lock(allow_block_for_safepoint);\n+      }\n@@ -59,1 +69,1 @@\n-    DEBUG_ONLY(Atomic::store(&_owner, Thread::current());)\n+    Atomic::store(&_owner, Thread::current());\n@@ -64,1 +74,1 @@\n-    DEBUG_ONLY(Atomic::store(&_owner, (Thread*)nullptr);)\n+    Atomic::store(&_owner, (Thread*)nullptr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"}]}