{"files":[{"patch":"@@ -33,2 +33,0 @@\n-#include \"runtime\/os.inline.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -38,8 +36,2 @@\n-  if (thread->is_Java_thread()) {\n-    \/\/Java threads spin a little before yielding and potentially blocking.\n-    constexpr uint32_t SPINS = 0x1F;\n-    if (allow_block_for_safepoint) {\n-      contended_lock_internal<true, SPINS>(thread);\n-    } else {\n-      contended_lock_internal<false, SPINS>(thread);\n-    }\n+  if (thread->is_Java_thread() && allow_block_for_safepoint) {\n+    contended_lock_internal<true>(JavaThread::cast(thread));\n@@ -47,6 +39,1 @@\n-    \/\/ Non-Java threads are not allowed to block, and they spin hard\n-    \/\/ to progress quickly. The normal number of GC threads is low enough\n-    \/\/ for this not to have detrimental effect. This favors GC threads\n-    \/\/ a little over Java threads, which is good for GC progress under\n-    \/\/ extreme contention.\n-    contended_lock_internal<false, UINT32_MAX>(thread);\n+    contended_lock_internal<false>(nullptr);\n@@ -56,6 +43,8 @@\n-\n-template<bool ALLOW_BLOCK, uint32_t MAX_SPINS>\n-void ShenandoahLock::contended_lock_internal(Thread* thread) {\n-  assert(!ALLOW_BLOCK || thread->is_Java_thread(), \"Must be a Java thread when allow block.\");\n-  uint32_t ctr = os::is_MP() ? MAX_SPINS : 0; \/\/Do not spin on single processor.\n-  do {\n+template<bool ALLOW_BLOCK>\n+void ShenandoahLock::contended_lock_internal(JavaThread* java_thread) {\n+  assert(!ALLOW_BLOCK || java_thread != nullptr, \"Must have a Java thread when allowing block.\");\n+  \/\/ Spin this much on multi-processor, do not spin on multi-processor.\n+  int ctr = os::is_MP() ? 0x1F : 0;\n+  \/\/ Apply TTAS to avoid more expenseive CAS calls if the lock is still held by other thread.\n+  while (Atomic::load(&_state) == locked ||\n+    Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n@@ -63,1 +52,1 @@\n-      \/\/ Lightly contended, spin a little if SP it NOT synchronizing.\n+      \/\/ Lightly contended, spin a little if no safepoint is pending.\n@@ -67,6 +56,20 @@\n-      if (ALLOW_BLOCK && SafepointSynchronize::is_synchronizing())) {\n-        \/\/ We know SP is synchronizing and block is allowed, block the thread in VM for faster SP synchronization.\n-        \/\/ Need to wait on STS_lock ( suspendible thread set)\n-        ThreadBlockInVM block(JavaThread::cast(thread), true);\n-        MonitorLocker ml(STS_lock, Mutex::_safepoint_check_flag);\n-        ml.wait();\n+      if (ALLOW_BLOCK) {\n+        ThreadBlockInVM block(java_thread);\n+        if (SafepointSynchronize::is_synchronizing()) {\n+          \/\/ If safepoint is pending, we want to block and allow safepoint to proceed.\n+          \/\/ Normally, TBIVM above would block us in its destructor.\n+          \/\/\n+          \/\/ But that blocking only happens when TBIVM knows the thread poll is armed.\n+          \/\/ There is a window between announcing a safepoint and arming the thread poll\n+          \/\/ during which trying to continuously enter TBIVM is counter-productive.\n+          \/\/ Under high contention, we may end up going in circles thousands of times.\n+          \/\/ To avoid it, we wait here until local poll is armed and then proceed\n+          \/\/ to TBVIM exit for blocking. We do not SpinPause, but yield to let\n+          \/\/ VM thread to arm the poll sooner.\n+          while (SafepointSynchronize::is_synchronizing() &&\n+            !SafepointMechanism::local_poll_armed(java_thread)) {\n+            os::naked_yield();\n+          }\n+        } else {\n+          os::naked_yield();\n+        }\n@@ -77,1 +80,1 @@\n-  } while (!try_lock(ALLOW_BLOCK));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -43,9 +43,2 @@\n-  template<bool ALLOW_BLOC, uint32_t MAX_SPINS>\n-  void contended_lock_internal(Thread* thread);\n-\n-  inline bool try_lock(bool allow_lock) {\n-    if (Atomic::load(&_state) == locked) return false;\n-    if (SafepointSynchronize::is_synchronizing() && allow_lock) return false;\n-    return Atomic::cmpxchg(&_state, unlocked, locked) == unlocked; \n-  }\n-\n+  template<bool ALLOW_BLOCK>\n+  void contended_lock_internal(JavaThread* java_thread);\n@@ -58,2 +51,4 @@\n-    if(allow_block_for_safepoint && SafepointSynchronize::is_synchronizing()) {\n-        contended_lock(allow_block_for_safepoint);\n+    if (allow_block_for_safepoint && SafepointSynchronize::is_synchronizing()) {\n+      \/\/ Java thread, and there is a pending safepoint. Dive into contended locking\n+      \/\/ immediately without trying anything else, and block.\n+      contended_lock(allow_block_for_safepoint);\n@@ -69,1 +64,1 @@\n-    Atomic::store(&_owner, Thread::current());\n+    DEBUG_ONLY(Atomic::store(&_owner, Thread::current());)\n@@ -74,1 +69,1 @@\n-    Atomic::store(&_owner, (Thread*)nullptr);\n+    DEBUG_ONLY(Atomic::store(&_owner, (Thread*)nullptr);)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"}]}