{"files":[{"patch":"@@ -35,9 +35,0 @@\n-\/\/ These are inline variants of Thread::SpinAcquire with optional blocking in VM.\n-\n-class ShenandoahNoBlockOp : public StackObj {\n-public:\n-  ShenandoahNoBlockOp(JavaThread* java_thread) {\n-    assert(java_thread == nullptr, \"Should not pass anything\");\n-  }\n-};\n-\n@@ -46,2 +37,8 @@\n-  if (allow_block_for_safepoint && thread->is_Java_thread()) {\n-    contended_lock_internal<ThreadBlockInVM>(JavaThread::cast(thread));\n+  if (thread->is_Java_thread()) {\n+    \/\/Java threads spin a little before yielding and potentially blocking.\n+    constexpr uint32_t SPINS = 0x1F;\n+    if (allow_block_for_safepoint) {\n+      contended_lock_internal<true, SPINS>(thread);\n+    } else {\n+      contended_lock_internal<false, SPINS>(thread);\n+    }\n@@ -49,1 +46,6 @@\n-    contended_lock_internal<ShenandoahNoBlockOp>(nullptr);\n+    \/\/ Non-Java threads are not allowed to block, and they spin hard\n+    \/\/ to progress quickly. The normal number of GC threads is low enough\n+    \/\/ for this not to have detrimental effect. This favors GC threads\n+    \/\/ a little over Java threads, which is good for GC progress under\n+    \/\/ extreme contention.\n+    contended_lock_internal<false, UINT32_MAX>(thread);\n@@ -53,4 +55,5 @@\n-template<typename BlockOp>\n-void ShenandoahLock::contended_lock_internal(JavaThread* java_thread) {\n-  int ctr = 0;\n-  int yields = 0;\n+\n+template<bool ALLOW_BLOCK, uint32_t MAX_SPINS>\n+void ShenandoahLock::contended_lock_internal(Thread* thread) {\n+  assert(!ALLOW_BLOCK || thread->is_Java_thread(), \"Must be a Java thread when allow block.\");\n+  uint32_t ctr = os::is_MP() ? MAX_SPINS : 0; \/\/Do not spin on single processor.\n@@ -58,10 +61,3 @@\n-         Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n-    if ((++ctr & 0xFFF) == 0) {\n-      BlockOp block(java_thread);\n-      if (yields > 5) {\n-        os::naked_short_sleep(1);\n-      } else {\n-        os::naked_yield();\n-        yields++;\n-      }\n-    } else {\n+      Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+    if (ctr > 0 && !SafepointSynchronize::is_synchronizing()) {\n+      \/\/ Lightly contended, spin a little if SP it NOT synchronizing.\n@@ -69,0 +65,8 @@\n+      ctr--;\n+    } else if (ALLOW_BLOCK) {\n+      \/\/We know SP is synchronizing and block is allosed,\n+      \/\/yield to safepoint call to so VM will reach safepoint faster.\n+      ThreadBlockInVM block(JavaThread::cast(thread), true);\n+      os::naked_yield();\n+    } else {\n+      os::naked_yield();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":30,"deletions":26,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -43,3 +43,2 @@\n-  template<typename BlockOp>\n-  void contended_lock_internal(JavaThread* java_thread);\n-\n+  template<bool ALLOW_BLOC, uint32_t MAX_SPINS>\n+  void contended_lock_internal(Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}