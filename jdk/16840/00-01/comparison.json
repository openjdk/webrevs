{"files":[{"patch":"@@ -526,0 +526,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -550,0 +554,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -592,0 +593,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -550,0 +550,2 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n@@ -551,0 +553,2 @@\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1892,0 +1892,2 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n@@ -1893,0 +1895,2 @@\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,0 +1369,2 @@\n+  check_extra_data_locked();\n+\n@@ -1398,0 +1400,2 @@\n+  check_extra_data_locked();\n+\n@@ -1441,0 +1445,2 @@\n+  check_extra_data_locked();\n+\n@@ -1463,4 +1469,5 @@\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries. Do it re-entrant in case\n-    \/\/ we already have the lock further up.\n-    ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self());\n+    \/\/ TODO lock is not useless, since we require lock at the beginning of the method.\n+    \/\/ \/\/ Check again now that we have the lock. Another thread may\n+    \/\/ \/\/ have added extra data entries. Do it re-entrant in case\n+    \/\/ \/\/ we already have the lock further up.\n+    \/\/ ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self());\n@@ -1698,0 +1705,2 @@\n+  check_extra_data_locked();\n+\n@@ -1739,0 +1748,2 @@\n+  check_extra_data_locked();\n+\n@@ -1783,0 +1794,2 @@\n+  check_extra_data_locked();\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2315,1 +2315,2 @@\n-    assert(extra_data_lock()->owned_by_self(), \"must have lock\");\n+    check_extra_data_locked();\n+\n@@ -2338,1 +2339,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2455,0 +2459,10 @@\n+  void check_extra_data_locked() const {\n+#ifdef ASSERT\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(JavaThread::current()->is_in_no_safepoint_scope(), \"must have NoSafepointVerifier inside lock scope\");\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1800,0 +1800,1 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n@@ -1801,0 +1802,2 @@\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -2141,2 +2144,10 @@\n-        ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n-        int dos = (pdata == nullptr)? 0: pdata->trap_state();\n+\n+        int dos = 0;\n+        {\n+          \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+          MutexLocker ml(trap_mdo->extra_data_lock());\n+          NoSafepointVerifier no_safepoint;\n+\n+          ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n+          dos = (pdata == nullptr)? 0: pdata->trap_state();\n+        }\n@@ -2316,1 +2327,0 @@\n-    ProfileData* pdata = nullptr;\n@@ -2322,1 +2332,6 @@\n-      pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      MutexLocker ml(trap_mdo->extra_data_lock());\n+      NoSafepointVerifier no_safepoint;\n+\n+      ProfileData* pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n@@ -2388,0 +2403,9 @@\n+\n+      if (make_not_entrant && pdata != nullptr) {\n+        \/\/ Record the recompilation event, if any.\n+        int tstate0 = pdata->trap_state();\n+        int tstate1 = trap_state_set_recompiled(tstate0, true);\n+        if (tstate1 != tstate0) {\n+          pdata->set_trap_state(tstate1);\n+        }\n+      }\n@@ -2398,8 +2422,0 @@\n-      if (pdata != nullptr) {\n-        \/\/ Record the recompilation event, if any.\n-        int tstate0 = pdata->trap_state();\n-        int tstate1 = trap_state_set_recompiled(tstate0, true);\n-        if (tstate1 != tstate0)\n-          pdata->set_trap_state(tstate1);\n-      }\n-\n@@ -2466,0 +2482,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n@@ -2498,4 +2516,1 @@\n-    {\n-      MutexLocker ml(trap_mdo->extra_data_lock());\n-      pdata = trap_mdo->allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : nullptr);\n-    }\n+    pdata = trap_mdo->allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : nullptr);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -615,0 +615,2 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n@@ -616,0 +618,2 @@\n+        NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}