{"files":[{"patch":"@@ -526,0 +526,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -550,0 +554,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -592,0 +593,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -549,1 +549,7 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1892,0 +1892,2 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n@@ -1893,0 +1895,2 @@\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,0 +1369,2 @@\n+  check_extra_data_locked();\n+\n@@ -1398,0 +1400,2 @@\n+  check_extra_data_locked();\n+\n@@ -1441,0 +1445,2 @@\n+  check_extra_data_locked();\n+\n@@ -1463,3 +1469,5 @@\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n+    \/\/ TODO lock is not useless, since we require lock at the beginning of the method.\n+    \/\/ \/\/ Check again now that we have the lock. Another thread may\n+    \/\/ \/\/ have added extra data entries. Do it re-entrant in case\n+    \/\/ \/\/ we already have the lock further up.\n+    \/\/ ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self());\n@@ -1697,0 +1705,2 @@\n+  check_extra_data_locked();\n+\n@@ -1738,0 +1748,2 @@\n+  check_extra_data_locked();\n+\n@@ -1782,0 +1794,2 @@\n+  check_extra_data_locked();\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2315,0 +2315,2 @@\n+    check_extra_data_locked();\n+\n@@ -2337,1 +2339,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2454,0 +2459,10 @@\n+  void check_extra_data_locked() const {\n+#ifdef ASSERT\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(JavaThread::current()->is_in_no_safepoint_scope(), \"must have NoSafepointVerifier inside lock scope\");\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1800,0 +1800,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -2140,2 +2144,10 @@\n-        ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n-        int dos = (pdata == nullptr)? 0: pdata->trap_state();\n+\n+        int dos = 0;\n+        {\n+          \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+          MutexLocker ml(trap_mdo->extra_data_lock());\n+          NoSafepointVerifier no_safepoint;\n+\n+          ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n+          dos = (pdata == nullptr)? 0: pdata->trap_state();\n+        }\n@@ -2315,1 +2327,0 @@\n-    ProfileData* pdata = nullptr;\n@@ -2321,1 +2332,6 @@\n-      pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      MutexLocker ml(trap_mdo->extra_data_lock());\n+      NoSafepointVerifier no_safepoint;\n+\n+      ProfileData* pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n@@ -2387,0 +2403,9 @@\n+\n+      if (make_not_entrant && pdata != nullptr) {\n+        \/\/ Record the recompilation event, if any.\n+        int tstate0 = pdata->trap_state();\n+        int tstate1 = trap_state_set_recompiled(tstate0, true);\n+        if (tstate1 != tstate0) {\n+          pdata->set_trap_state(tstate1);\n+        }\n+      }\n@@ -2397,8 +2422,0 @@\n-      if (pdata != nullptr) {\n-        \/\/ Record the recompilation event, if any.\n-        int tstate0 = pdata->trap_state();\n-        int tstate1 = trap_state_set_recompiled(tstate0, true);\n-        if (tstate1 != tstate0)\n-          pdata->set_trap_state(tstate1);\n-      }\n-\n@@ -2465,0 +2482,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -615,0 +615,5 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock());\n+        NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}