{"files":[{"patch":"@@ -85,1 +85,1 @@\n-  bool finish() {\n+  bool finish(NoSafepointVerifier* no_safepoint) {\n@@ -90,2 +90,9 @@\n-    \/\/ Holding locks through safepoints is bad practice.\n-    MutexUnlocker mu(_mdo->extra_data_lock());\n+    \/\/ We are currently holding the extra_data_lock and ensuring\n+    \/\/ no safepoint breaks the lock.\n+    _mdo->check_extra_data_locked();\n+    \/\/ We now want to cache some method data. This could cause\n+    \/\/ a safepoint. We temporarily release the lock and allow\n+    \/\/ safepoints, and revert that at the end of the scope:\n+    MutexUnlocker mu(_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    PauseNoSafepointVerifier pause_no_safepoints(no_safepoint);\n+\n@@ -107,1 +114,1 @@\n-void ciMethodData::prepare_metadata() {\n+void ciMethodData::prepare_metadata(NoSafepointVerifier* no_safepoint) {\n@@ -114,1 +121,1 @@\n-    if (cl.finish()) {\n+    if (cl.finish(no_safepoint)) {\n@@ -126,1 +133,5 @@\n-  MutexLocker ml(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not unintentionally broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n@@ -128,1 +139,1 @@\n-  prepare_metadata();\n+  prepare_metadata(&no_safepoint);\n@@ -131,1 +142,0 @@\n-  NoSafepointVerifier no_safepoint;\n@@ -564,0 +574,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -588,0 +602,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  void prepare_metadata();\n+  void prepare_metadata(NoSafepointVerifier* no_safepoint);\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-void CodeBlob::print_code() {\n+void CodeBlob::print_code_on(outputStream* st) {\n@@ -241,1 +241,1 @@\n-  Disassembler::decode(this, tty);\n+  Disassembler::decode(this, st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-  void print_code();\n+  void print_code_on(outputStream* st);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -690,6 +690,9 @@\n-    ttyLocker ttyl;\n-    tty->print_cr(\"implicit exception happened at \" INTPTR_FORMAT, p2i(pc));\n-    print();\n-    method()->print_codes();\n-    print_code();\n-    print_pcs();\n+\n+    \/\/ Keep tty output consistent. To avoid ttyLocker, we buffer in stream, and print all at once.\n+    stringStream ss;\n+    ss.print_cr(\"implicit exception happened at \" INTPTR_FORMAT, p2i(pc));\n+    print_on(&ss);\n+    method()->print_codes_on(&ss);\n+    print_code_on(&ss);\n+    print_pcs_on(&ss);\n+    tty->print(\"%s\", ss.as_string()); \/\/ print all at once\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-  virtual void print_pcs() = 0;\n+  virtual void print_pcs_on(outputStream* st) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1023,1 +1023,1 @@\n-      print_pcs();\n+      print_pcs_on(tty);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,2 +624,1 @@\n-  void print_pcs() { print_pcs_on(tty); }\n-  void print_pcs_on(outputStream* st);\n+  virtual void print_pcs_on(outputStream* st) override final;\n@@ -638,2 +637,1 @@\n-  \/\/ void print_pcs()                             PRODUCT_RETURN;\n-  void print_pcs()                                { return; }\n+  virtual void print_pcs_on(outputStream* st) override final { return; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -195,1 +196,3 @@\n-  ttyLocker ttyl;  \/\/ keep the following output coherent\n+  \/\/ Keep output to st coherent: collect all lines and print at once.\n+  ResourceMark rm;\n+  stringStream ss;\n@@ -197,1 +200,1 @@\n-    method_printer.trace(method, s.bcp(), st);\n+    method_printer.trace(method, s.bcp(), &ss);\n@@ -199,0 +202,1 @@\n+  st->print(\"%s\", ss.as_string());\n@@ -592,0 +596,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -550,1 +550,7 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1892,1 +1892,5 @@\n-  MutexLocker mu(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker mu(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2534,1 +2534,0 @@\n-      ConditionalMutexLocker ml(mdo->extra_data_lock(), !SafepointSynchronize::is_at_safepoint());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -543,1 +543,1 @@\n-void Method::print_invocation_count() {\n+void Method::print_invocation_count(outputStream* st) {\n@@ -545,7 +545,7 @@\n-  if (is_static()) tty->print(\"static \");\n-  if (is_final()) tty->print(\"final \");\n-  if (is_synchronized()) tty->print(\"synchronized \");\n-  if (is_native()) tty->print(\"native \");\n-  tty->print(\"%s::\", method_holder()->external_name());\n-  name()->print_symbol_on(tty);\n-  signature()->print_symbol_on(tty);\n+  if (is_static())       { st->print(\"static \"); }\n+  if (is_final())        { st->print(\"final \"); }\n+  if (is_synchronized()) { st->print(\"synchronized \"); }\n+  if (is_native())       { st->print(\"native \"); }\n+  st->print(\"%s::\", method_holder()->external_name());\n+  name()->print_symbol_on(st);\n+  signature()->print_symbol_on(st);\n@@ -555,1 +555,1 @@\n-    tty->print(\" {%d}\", code_size());\n+    st->print(\" {%d}\", code_size());\n@@ -557,1 +557,1 @@\n-  tty->cr();\n+  st->cr();\n@@ -564,3 +564,3 @@\n-  tty->print_cr (\"  interpreter_invocation_count: \" INT32_FORMAT_W(11), interpreter_invocation_count());\n-  tty->print_cr (\"  invocation_counter:           \" INT32_FORMAT_W(11), invocation_count());\n-  tty->print_cr (\"  backedge_counter:             \" INT32_FORMAT_W(11), backedge_count());\n+  st->print_cr (\"  interpreter_invocation_count: \" INT32_FORMAT_W(11), interpreter_invocation_count());\n+  st->print_cr (\"  invocation_counter:           \" INT32_FORMAT_W(11), invocation_count());\n+  st->print_cr (\"  backedge_counter:             \" INT32_FORMAT_W(11), backedge_count());\n@@ -569,1 +569,1 @@\n-    tty->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11), method_data()->decompile_count());\n+    st->print_cr (\"  decompile_count:              \" UINT32_FORMAT_W(11), method_data()->decompile_count());\n@@ -574,1 +574,1 @@\n-    tty->print_cr (\"  compiled_invocation_count:    \" INT64_FORMAT_W(11), compiled_invocation_count());\n+    st->print_cr (\"  compiled_invocation_count:    \" INT64_FORMAT_W(11), compiled_invocation_count());\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-  void print_invocation_count();\n+  void print_invocation_count(outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1227,1 +1227,1 @@\n-    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n+    _extra_data_lock(Mutex::nosafepoint, \"MDOExtraData_lock\"),\n@@ -1388,0 +1388,2 @@\n+  check_extra_data_locked();\n+\n@@ -1439,0 +1441,2 @@\n+  check_extra_data_locked();\n+\n@@ -1482,0 +1486,2 @@\n+  check_extra_data_locked();\n+\n@@ -1504,3 +1510,6 @@\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n+    \/\/ TODO lock is not useless, since we require lock at the beginning of the method.\n+    \/\/ \/\/ Check again now that we have the lock. Another thread may\n+    \/\/ \/\/ have added extra data entries. Do it re-entrant in case\n+    \/\/ \/\/ we already have the lock further up.\n+    \/\/ ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self());\n+    \/\/ Mutex::_no_safepoint_check_flag\n@@ -1738,0 +1747,2 @@\n+  check_extra_data_locked();\n+\n@@ -1779,0 +1790,2 @@\n+  check_extra_data_locked();\n+\n@@ -1823,0 +1836,2 @@\n+  check_extra_data_locked();\n+\n@@ -1860,0 +1875,5 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n@@ -1869,0 +1889,5 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -2284,1 +2286,4 @@\n-  uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();\n+  uint arg_modified(int a)                       { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+                                                   NoSafepointVerifier no_safepoint;\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2293,1 +2298,4 @@\n-  void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();\n+  void set_arg_modified(int a, uint v)           { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+                                                   NoSafepointVerifier no_safepoint;\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2345,0 +2353,2 @@\n+    check_extra_data_locked();\n+\n@@ -2371,1 +2381,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2386,1 +2399,1 @@\n-  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)limit_data_position()); }\n@@ -2503,0 +2516,12 @@\n+  void check_extra_data_locked() const {\n+#ifdef ASSERT\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(!Thread::current()->is_Java_thread() ||\n+           JavaThread::current()->is_in_no_safepoint_scope(),\n+           \"JavaThread must have NoSafepointVerifier inside lock scope\");\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1229,1 +1229,0 @@\n-    MutexLocker mu(THREAD, mdo->extra_data_lock());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1800,0 +1800,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -2105,0 +2109,7 @@\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      \/\/ We must do this already now, since we cannot acquire this lock while\n+      \/\/ holding the tty lock (lock ordering by rank).\n+      MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+      NoSafepointVerifier no_safepoint;\n+\n@@ -2106,0 +2117,1 @@\n+\n@@ -2140,0 +2152,3 @@\n+\n+        \/\/ We need to lock to read the ProfileData. But to keep the locks ordered, we need to\n+        \/\/ lock extra_data_lock before the tty lock.\n@@ -2315,1 +2330,0 @@\n-    ProfileData* pdata = nullptr;\n@@ -2321,1 +2335,6 @@\n-      pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+      NoSafepointVerifier no_safepoint;\n+\n+      ProfileData* pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n@@ -2387,0 +2406,9 @@\n+\n+      if (make_not_entrant && pdata != nullptr) {\n+        \/\/ Record the recompilation event, if any.\n+        int tstate0 = pdata->trap_state();\n+        int tstate1 = trap_state_set_recompiled(tstate0, true);\n+        if (tstate1 != tstate0) {\n+          pdata->set_trap_state(tstate1);\n+        }\n+      }\n@@ -2397,8 +2425,0 @@\n-      if (pdata != nullptr) {\n-        \/\/ Record the recompilation event, if any.\n-        int tstate0 = pdata->trap_state();\n-        int tstate1 = trap_state_set_recompiled(tstate0, true);\n-        if (tstate1 != tstate0)\n-          pdata->set_trap_state(tstate1);\n-      }\n-\n@@ -2476,0 +2496,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n@@ -2558,0 +2580,5 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -133,5 +133,10 @@\n-        ttyLocker ttyl;\n-        tty->print_cr(\"------------------------------------------------------------------------\");\n-        m->print_invocation_count();\n-        tty->print_cr(\"  mdo size: %d bytes\", m->method_data()->size_in_bytes());\n-        tty->cr();\n+\n+        \/\/ Instead of taking tty lock, we collect all lines into a string stream\n+        \/\/ and then print them all at once.\n+        ResourceMark rm2;\n+        stringStream ss;\n+\n+        ss.print_cr(\"------------------------------------------------------------------------\");\n+        m->print_invocation_count(&ss);\n+        ss.print_cr(\"  mdo size: %d bytes\", m->method_data()->size_in_bytes());\n+        ss.cr();\n@@ -140,2 +145,2 @@\n-          tty->fill_to(2);\n-          m->method_data()->parameters_type_data()->print_data_on(tty);\n+          ss.fill_to(2);\n+          m->method_data()->parameters_type_data()->print_data_on(&ss);\n@@ -143,1 +148,2 @@\n-        m->print_codes();\n+        m->print_codes_on(&ss);\n+        tty->print(\"%s\", ss.as_string()); \/\/ print all at once\n@@ -195,1 +201,1 @@\n-    if ((iic + cic) >= (uint64_t)MethodHistogramCutoff) m->print_invocation_count();\n+    if ((iic + cic) >= (uint64_t)MethodHistogramCutoff) m->print_invocation_count(tty);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -615,0 +615,5 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+        NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -162,8 +162,10 @@\n-      ttyLocker ttyl;\n-      tty->print_cr(\"Error in fill_from_frame: pc_desc for \"\n-                    INTPTR_FORMAT \" not found or invalid at %d\",\n-                    p2i(_frame.pc()), decode_offset);\n-      nm()->print();\n-      nm()->method()->print_codes();\n-      nm()->print_code();\n-      nm()->print_pcs();\n+      \/\/ Keep tty output consistent. To avoid ttyLocker, we buffer in stream, and print all at once.\n+      stringStream ss;\n+      ss.print_cr(\"Error in fill_from_frame: pc_desc for \"\n+                  INTPTR_FORMAT \" not found or invalid at %d\",\n+                  p2i(_frame.pc()), decode_offset);\n+      nm()->print_on(&ss);\n+      nm()->method()->print_codes_on(&ss);\n+      nm()->print_code_on(&ss);\n+      nm()->print_pcs_on(&ss);\n+      tty->print(\"%s\", ss.as_string()); \/\/ print all at once\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}