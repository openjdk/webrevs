{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,12 @@\n-    \/\/ Holding locks through safepoints is bad practice.\n-    MutexUnlocker mu(_mdo->extra_data_lock());\n+    \/\/ We are currently holding the extra_data_lock and ensuring\n+    \/\/ no safepoint breaks the lock.\n+    _mdo->check_extra_data_locked();\n+\n+    \/\/ We now want to cache some method data. This could cause a safepoint.\n+    \/\/ We temporarily release the lock and allow safepoints, and revert that\n+    \/\/ at the end of the scope. This is safe, since we currently do not hold\n+    \/\/ any extra_method_data: finish is called only after clean_extra_data,\n+    \/\/ and the outer scope that first aquired the lock should not hold any\n+    \/\/ extra_method_data while cleaning is performed, as the offsets can change.\n+    MutexUnlocker mu(_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -126,1 +136,4 @@\n-  MutexLocker ml(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not unintentionally broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -565,0 +578,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -589,0 +605,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -595,0 +596,4 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -550,1 +550,6 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+\n+  \/\/ Lock to access ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrMethodData.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1892,1 +1892,4 @@\n-  MutexLocker mu(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker mu(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2534,1 +2534,0 @@\n-      ConditionalMutexLocker ml(mdo->extra_data_lock(), !SafepointSynchronize::is_at_safepoint());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1221,1 +1221,1 @@\n-    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n+    _extra_data_lock(Mutex::nosafepoint, \"MDOExtraData_lock\"),\n@@ -1382,0 +1382,2 @@\n+  check_extra_data_locked();\n+\n@@ -1432,1 +1434,3 @@\n-ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*& dp, bool concurrent) {\n+ProfileData* MethodData::bci_to_extra_data_find(int bci, Method* m, DataLayout*& dp) {\n+  check_extra_data_locked();\n+\n@@ -1453,3 +1457,0 @@\n-        \/\/ data->method() may be null in case of a concurrent\n-        \/\/ allocation. Maybe it's for the same method. Try to use that\n-        \/\/ entry in that case.\n@@ -1457,4 +1458,2 @@\n-          if (data->method() == nullptr) {\n-            assert(concurrent, \"impossible because no concurrent allocation\");\n-            return nullptr;\n-          } else if (data->method() == m) {\n+          assert(data->method() != nullptr, \"method must be set\");\n+          if (data->method() == m) {\n@@ -1476,0 +1475,2 @@\n+  check_extra_data_locked();\n+\n@@ -1489,5 +1490,3 @@\n-  \/\/ Allocation in the extra data space has to be atomic because not\n-  \/\/ all entries have the same size and non atomic concurrent\n-  \/\/ allocation would result in a corrupted extra data space.\n-  ProfileData* result = bci_to_extra_data_helper(bci, m, dp, true);\n-  if (result != nullptr) {\n+  \/\/ Find if already exists\n+  ProfileData* result = bci_to_extra_data_find(bci, m, dp);\n+  if (result != nullptr || dp >= end) {\n@@ -1497,9 +1496,2 @@\n-  if (create_if_missing && dp < end) {\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n-    ProfileData* result = bci_to_extra_data_helper(bci, m, dp, false);\n-    if (result != nullptr || dp >= end) {\n-      return result;\n-    }\n-\n+  if (create_if_missing) {\n+    \/\/ Not found -> Allocate\n@@ -1732,0 +1724,2 @@\n+  check_extra_data_locked();\n+\n@@ -1773,0 +1767,2 @@\n+  check_extra_data_locked();\n+\n@@ -1817,0 +1813,2 @@\n+  check_extra_data_locked();\n+\n@@ -1854,0 +1852,4 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -1863,0 +1865,4 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":30,"deletions":24,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -2171,1 +2173,1 @@\n-  ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*& dp, bool concurrent);\n+  ProfileData* bci_to_extra_data_find(int bci, Method* m, DataLayout*& dp);\n@@ -2313,1 +2315,3 @@\n-  uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();\n+  uint arg_modified(int a)                       { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2322,1 +2326,3 @@\n-  void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();\n+  void set_arg_modified(int a, uint v)           { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2374,0 +2380,2 @@\n+    check_extra_data_locked();\n+\n@@ -2400,1 +2408,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2415,1 +2426,1 @@\n-  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)limit_data_position()); }\n@@ -2532,0 +2543,12 @@\n+  void check_extra_data_locked() const {\n+#ifdef ASSERT\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(!Thread::current()->is_Java_thread() ||\n+           JavaThread::current()->is_in_no_safepoint_scope(),\n+           \"JavaThread must have NoSafepointVerifier inside lock scope\");\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1229,1 +1229,0 @@\n-    MutexLocker mu(THREAD, mdo->extra_data_lock());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1800,0 +1800,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2105,0 +2108,6 @@\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      \/\/ We must do this already now, since we cannot acquire this lock while\n+      \/\/ holding the tty lock (lock ordering by rank).\n+      MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2106,0 +2115,1 @@\n+\n@@ -2140,0 +2150,3 @@\n+\n+        \/\/ We need to lock to read the ProfileData. But to keep the locks ordered, we need to\n+        \/\/ lock extra_data_lock before the tty lock.\n@@ -2315,0 +2328,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    ConditionalMutexLocker ml((trap_mdo != nullptr) ? trap_mdo->extra_data_lock() : nullptr,\n+                              (trap_mdo != nullptr),\n+                              Mutex::_no_safepoint_check_flag);\n@@ -2321,0 +2339,1 @@\n+\n@@ -2476,0 +2495,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n@@ -2558,0 +2579,4 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -618,0 +618,4 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}