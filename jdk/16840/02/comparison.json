{"files":[{"patch":"@@ -112,1 +112,6 @@\n-    mdo->clean_extra_data(&cl);\n+    {\n+      \/\/ We hold the extra data lock, so now don't safepoint so we don't\n+      \/\/ give up the lock during cleaning.\n+      NoSafepointVerifier no_safepoint;\n+      mdo->clean_extra_data(&cl);\n+    }\n@@ -526,0 +531,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -550,0 +559,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -592,0 +593,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -549,1 +549,7 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1892,0 +1892,2 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n@@ -1893,0 +1895,2 @@\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1369,0 +1369,2 @@\n+  check_extra_data_locked();\n+\n@@ -1398,0 +1400,2 @@\n+  check_extra_data_locked();\n+\n@@ -1441,0 +1445,2 @@\n+  check_extra_data_locked();\n+\n@@ -1463,3 +1469,5 @@\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n+    \/\/ TODO lock is not useless, since we require lock at the beginning of the method.\n+    \/\/ \/\/ Check again now that we have the lock. Another thread may\n+    \/\/ \/\/ have added extra data entries. Do it re-entrant in case\n+    \/\/ \/\/ we already have the lock further up.\n+    \/\/ ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self());\n@@ -1697,0 +1705,2 @@\n+  check_extra_data_locked();\n+\n@@ -1738,0 +1748,2 @@\n+  check_extra_data_locked();\n+\n@@ -1782,0 +1794,2 @@\n+  check_extra_data_locked();\n+\n@@ -1819,0 +1833,1 @@\n+  \/\/ TODO safe?\n@@ -1828,0 +1843,1 @@\n+  \/\/ TODO safe?\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -2257,1 +2259,4 @@\n-  uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();\n+  uint arg_modified(int a)                       { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock());\n+                                                   NoSafepointVerifier no_safepoint;\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2266,1 +2271,4 @@\n-  void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();\n+  void set_arg_modified(int a, uint v)           { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock());\n+                                                   NoSafepointVerifier no_safepoint;\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2315,0 +2323,2 @@\n+    check_extra_data_locked();\n+\n@@ -2337,1 +2347,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2341,1 +2354,1 @@\n-  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)limit_data_position()); }\n@@ -2454,0 +2467,10 @@\n+  void check_extra_data_locked() const {\n+#ifdef ASSERT\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(JavaThread::current()->is_in_no_safepoint_scope(), \"must have NoSafepointVerifier inside lock scope\");\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1800,0 +1800,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock());\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -2140,2 +2144,10 @@\n-        ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n-        int dos = (pdata == nullptr)? 0: pdata->trap_state();\n+\n+        int dos = 0;\n+        {\n+          \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+          MutexLocker ml(trap_mdo->extra_data_lock());\n+          NoSafepointVerifier no_safepoint;\n+\n+          ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n+          dos = (pdata == nullptr)? 0: pdata->trap_state();\n+        }\n@@ -2315,1 +2327,0 @@\n-    ProfileData* pdata = nullptr;\n@@ -2321,1 +2332,6 @@\n-      pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      MutexLocker ml(trap_mdo->extra_data_lock());\n+      NoSafepointVerifier no_safepoint;\n+\n+      ProfileData* pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n@@ -2387,0 +2403,9 @@\n+\n+      if (make_not_entrant && pdata != nullptr) {\n+        \/\/ Record the recompilation event, if any.\n+        int tstate0 = pdata->trap_state();\n+        int tstate1 = trap_state_set_recompiled(tstate0, true);\n+        if (tstate1 != tstate0) {\n+          pdata->set_trap_state(tstate1);\n+        }\n+      }\n@@ -2397,8 +2422,0 @@\n-      if (pdata != nullptr) {\n-        \/\/ Record the recompilation event, if any.\n-        int tstate0 = pdata->trap_state();\n-        int tstate1 = trap_state_set_recompiled(tstate0, true);\n-        if (tstate1 != tstate0)\n-          pdata->set_trap_state(tstate1);\n-      }\n-\n@@ -2465,0 +2482,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -615,0 +615,5 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock());\n+        NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}