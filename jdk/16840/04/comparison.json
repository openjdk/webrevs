{"files":[{"patch":"@@ -85,1 +85,1 @@\n-  bool finish() {\n+  bool finish(NoSafepointVerifier* no_safepoint) {\n@@ -90,2 +90,9 @@\n-    \/\/ Holding locks through safepoints is bad practice.\n-    MutexUnlocker mu(_mdo->extra_data_lock());\n+    \/\/ We are currently holding the extra_data_lock and ensuring\n+    \/\/ no safepoint breaks the lock.\n+    _mdo->check_extra_data_locked();\n+    \/\/ We now want to cache some method data. This could cause\n+    \/\/ a safepoint. We temporarily release the lock and allow\n+    \/\/ safepoints, and revert that at the end of the scope:\n+    MutexUnlocker mu(_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    PauseNoSafepointVerifier pause_no_safepoints(no_safepoint);\n+\n@@ -107,1 +114,1 @@\n-void ciMethodData::prepare_metadata() {\n+void ciMethodData::prepare_metadata(NoSafepointVerifier* no_safepoint) {\n@@ -114,1 +121,1 @@\n-    if (cl.finish()) {\n+    if (cl.finish(no_safepoint)) {\n@@ -126,1 +133,5 @@\n-  MutexLocker ml(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not unintentionally broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n@@ -128,1 +139,1 @@\n-  prepare_metadata();\n+  prepare_metadata(&no_safepoint);\n@@ -131,1 +142,0 @@\n-  NoSafepointVerifier no_safepoint;\n@@ -564,0 +574,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -588,0 +602,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  void prepare_metadata();\n+  void prepare_metadata(NoSafepointVerifier* no_safepoint);\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -592,0 +593,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -550,1 +550,7 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1892,1 +1892,5 @@\n-  MutexLocker mu(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker mu(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2534,1 +2534,0 @@\n-      ConditionalMutexLocker ml(mdo->extra_data_lock(), !SafepointSynchronize::is_at_safepoint());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1227,1 +1227,1 @@\n-    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n+    _extra_data_lock(Mutex::nosafepoint, \"MDOExtraData_lock\"),\n@@ -1388,0 +1388,2 @@\n+  check_extra_data_locked();\n+\n@@ -1439,0 +1441,2 @@\n+  check_extra_data_locked();\n+\n@@ -1482,0 +1486,2 @@\n+  check_extra_data_locked();\n+\n@@ -1504,3 +1510,6 @@\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n+    \/\/ TODO lock is not useless, since we require lock at the beginning of the method.\n+    \/\/ \/\/ Check again now that we have the lock. Another thread may\n+    \/\/ \/\/ have added extra data entries. Do it re-entrant in case\n+    \/\/ \/\/ we already have the lock further up.\n+    \/\/ ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self());\n+    \/\/ Mutex::_no_safepoint_check_flag\n@@ -1738,0 +1747,2 @@\n+  check_extra_data_locked();\n+\n@@ -1779,0 +1790,2 @@\n+  check_extra_data_locked();\n+\n@@ -1823,0 +1836,2 @@\n+  check_extra_data_locked();\n+\n@@ -1860,0 +1875,5 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n@@ -1869,0 +1889,5 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -2284,1 +2286,4 @@\n-  uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();\n+  uint arg_modified(int a)                       { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+                                                   NoSafepointVerifier no_safepoint;\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2293,1 +2298,4 @@\n-  void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();\n+  void set_arg_modified(int a, uint v)           { \/\/ Lock and avoid breaking lock with Safepoint\n+                                                   MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+                                                   NoSafepointVerifier no_safepoint;\n+                                                   ArgInfoData *aid = arg_info();\n@@ -2345,0 +2353,2 @@\n+    check_extra_data_locked();\n+\n@@ -2371,1 +2381,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2386,1 +2399,1 @@\n-  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)limit_data_position()); }\n@@ -2503,0 +2516,12 @@\n+  void check_extra_data_locked() const {\n+#ifdef ASSERT\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(!Thread::current()->is_Java_thread() ||\n+           JavaThread::current()->is_in_no_safepoint_scope(),\n+           \"JavaThread must have NoSafepointVerifier inside lock scope\");\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1229,1 +1229,0 @@\n-    MutexLocker mu(THREAD, mdo->extra_data_lock());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1800,0 +1800,4 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+    NoSafepointVerifier no_safepoint;\n+\n@@ -2140,2 +2144,10 @@\n-        ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n-        int dos = (pdata == nullptr)? 0: pdata->trap_state();\n+\n+        int dos = 0;\n+        {\n+          \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+          MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+          NoSafepointVerifier no_safepoint;\n+\n+          ProfileData* pdata = trap_mdo->bci_to_data(trap_bci);\n+          dos = (pdata == nullptr)? 0: pdata->trap_state();\n+        }\n@@ -2315,1 +2327,0 @@\n-    ProfileData* pdata = nullptr;\n@@ -2321,1 +2332,6 @@\n-      pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+      NoSafepointVerifier no_safepoint;\n+\n+      ProfileData* pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,\n@@ -2387,0 +2403,9 @@\n+\n+      if (make_not_entrant && pdata != nullptr) {\n+        \/\/ Record the recompilation event, if any.\n+        int tstate0 = pdata->trap_state();\n+        int tstate1 = trap_state_set_recompiled(tstate0, true);\n+        if (tstate1 != tstate0) {\n+          pdata->set_trap_state(tstate1);\n+        }\n+      }\n@@ -2397,8 +2422,0 @@\n-      if (pdata != nullptr) {\n-        \/\/ Record the recompilation event, if any.\n-        int tstate0 = pdata->trap_state();\n-        int tstate1 = trap_state_set_recompiled(tstate0, true);\n-        if (tstate1 != tstate0)\n-          pdata->set_trap_state(tstate1);\n-      }\n-\n@@ -2476,0 +2493,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -615,0 +615,5 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+        NoSafepointVerifier no_safepoint;\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}