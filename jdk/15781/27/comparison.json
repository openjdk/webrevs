{"files":[{"patch":"@@ -1889,0 +1889,4 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n@@ -3030,1 +3034,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1626,0 +1626,4 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,3 @@\n-\n+  product(bool, UseMadvPopulateWrite, false, DIAGNOSTIC,                \\\n+          \"Use MADV_POPULATE_WRITE in os::pd_pretouch_memory.\")         \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2885,0 +2885,9 @@\n+\/\/ Define MADV_POPULATE_WRITE here so we can build HotSpot on old systems.\n+#define MADV_POPULATE_WRITE_value 23\n+#ifndef MADV_POPULATE_WRITE\n+  #define MADV_POPULATE_WRITE MADV_POPULATE_WRITE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+#endif\n+\n@@ -2944,0 +2953,26 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  const size_t len = pointer_delta(last, first, sizeof(char)) + page_size;\n+  \/\/ Use madvise to pretouch on Linux when THP is used, and fallback to the\n+  \/\/ common method if unsupported. THP can form right after madvise rather than\n+  \/\/ being assembled later.\n+  if (HugePages::thp_mode() == THPMode::always || UseTransparentHugePages) {\n+    int err = 0;\n+    if (UseMadvPopulateWrite &&\n+        ::madvise(first, len, MADV_POPULATE_WRITE) == -1) {\n+      err = errno;\n+    }\n+    if (!UseMadvPopulateWrite || err == EINVAL) { \/\/ Not to use or not supported\n+      \/\/ When using THP we need to always pre-touch using small pages as the\n+      \/\/ OS will initially always use small pages.\n+      return os::vm_page_size();\n+    } else if (err != 0) {\n+      log_warning(gc, os)(\"::madvise(\" PTR_FORMAT \", \" SIZE_FORMAT\n+                          \", %d) failed; error='%s' (errno=%d)\",\n+                          p2i(first), len, MADV_POPULATE_WRITE,\n+                          os::strerror(err), err);\n+    }\n+    return 0;\n+  }\n+  return page_size;\n+}\n+\n@@ -4366,0 +4401,3 @@\n+  \/\/ Check the availability of MADV_POPULATE_WRITE.\n+  UseMadvPopulateWrite = (::madvise(0, 0, MADV_POPULATE_WRITE) == 0);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3799,0 +3799,5 @@\n+\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2117,1 +2117,1 @@\n-    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* first = align_down(start, page_size);\n@@ -2119,6 +2119,10 @@\n-    assert(cur <= last, \"invariant\");\n-    \/\/ Iterate from first page through last (inclusive), being careful to\n-    \/\/ avoid overflow if the last page abuts the end of the address range.\n-    for ( ; true; cur += page_size) {\n-      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n-      if (cur >= last) break;\n+    assert(first <= last, \"invariant\");\n+    const size_t pd_page_size = pd_pretouch_memory(first, last, page_size);\n+    if (pd_page_size > 0) {\n+      \/\/ Iterate from first page through last (inclusive), being careful to\n+      \/\/ avoid overflow if the last page abuts the end of the address range.\n+      last = align_down(static_cast<char*>(end) - 1, pd_page_size);\n+      for (char* cur = static_cast<char*>(first); \/* break *\/; cur += pd_page_size) {\n+        Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+        if (cur >= last) break;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -227,0 +227,4 @@\n+  \/\/ Returns 0 if pretouch is done via platform dependent method, or otherwise\n+  \/\/ returns page_size that should be used for the common method.\n+  static size_t pd_pretouch_memory(void* first, void* last, size_t page_size);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -353,0 +353,64 @@\n+class PretouchMemoryRunnable : public TestRunnable {\n+  char* addr;\n+  size_t byte;\n+public:\n+  PretouchMemoryRunnable(char* addr, size_t byte): addr(addr), byte(byte) {}\n+\n+  void runUnitTest() const {\n+    os::pretouch_memory(addr, addr + byte, os::vm_page_size());\n+  }\n+};\n+\n+class UseMemoryRunnable : public TestRunnable {\n+  char* addr;\n+  size_t byte;\n+public:\n+  UseMemoryRunnable(char* addr, size_t byte): addr(addr), byte(byte) {}\n+\n+  void runUnitTest() const {\n+    int* iptr = reinterpret_cast<int*>(addr);\n+    for (int i = 0; i < 1000 && (size_t)i < (byte \/ (sizeof(int))); i++)\n+      *iptr++ = i;\n+  }\n+};\n+\n+static void *pthread_test_runnable(void *runnable) {\n+  TestRunnable* r = reinterpret_cast<TestRunnable*>(runnable);\n+  r->runUnitTest();\n+  return nullptr;\n+}\n+\n+TEST_VM(os_linux, pretouch_thp_and_use_concurrent) {\n+  \/\/ Explicitly enable thp to test cocurrent system calls.\n+  bool useThp = UseTransparentHugePages;\n+  UseTransparentHugePages = true;\n+  char* heap = os::reserve_memory(1 * G, false, mtInternal);\n+  EXPECT_NE(heap, (char*)NULL);\n+  EXPECT_TRUE(os::commit_memory(heap, 1 * G, false));\n+\n+  {\n+    UseMemoryRunnable use(heap, 1 * G);\n+    PretouchMemoryRunnable pretouch(heap, 1 * G);\n+    pthread_t threads[8];\n+    pthread_attr_t attributes[8];\n+    for (int i = 0; i < 8; i++) {\n+      pthread_attr_init(attributes + i);\n+      TestRunnable *runnable = &pretouch;\n+      if (i == 0) runnable = &use;\n+      pthread_create(threads + i, attributes + i, pthread_test_runnable, runnable);\n+      pthread_attr_destroy(attributes + i);\n+    }\n+    for (int i = 0; i < 8; i++) {\n+      pthread_join(threads[i], 0);\n+    }\n+  }\n+\n+  int* iptr = reinterpret_cast<int*>(heap);\n+  for (int i = 0; i < 1000; i++)\n+    EXPECT_EQ(*iptr++, i);\n+\n+  EXPECT_TRUE(os::uncommit_memory(heap, 1 * G, false));\n+  EXPECT_TRUE(os::release_memory(heap, 1 * G));\n+  UseTransparentHugePages = useThp;\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) Ampere Computing and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestTransparentHugePageUsage\n+ * @bug 8315923\n+ * @library \/test\/lib\n+ * @requires vm.gc.Serial & os.family == \"linux\" & os.maxMemory > 2G\n+ * @summary Check that a pretouched java heap appears to use THPs by checking\n+ *          AnonHugePages in smaps\n+ * @comment Use SerialGC to increase the time window for pretouching\n+ * @run driver runtime.os.TestTransparentHugePageUsage\n+ *\/\n+\n+package runtime.os;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.InputStreamReader;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTransparentHugePageUsage {\n+  private static final String[] fixedCmdLine = {\n+    \"-XX:+UseTransparentHugePages\", \"-XX:+AlwaysPreTouch\",\n+    \"-Xlog:startuptime,pagesize,gc+heap=debug\",\n+    \"-XX:+UseSerialGC\", \"-Xms1G\", \"-Xmx1G\",\n+  };\n+\n+  public static void main(String[] args) throws Exception {\n+    ArrayList<String> cmdLine = new ArrayList<>(Arrays.asList(fixedCmdLine));\n+    cmdLine.add(\"runtime.os.TestTransparentHugePageUsage$CatSmaps\");\n+    ProcessBuilder builder = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+    checkUsage(new BufferedReader(new InputStreamReader(builder.start().getInputStream())));\n+  }\n+\n+  private static void checkUsage(BufferedReader reader) throws Exception {\n+    final Pattern useThp = Pattern.compile(\".*\\\\[info\\\\]\\\\[pagesize\\\\].+UseTransparentHugePages=1.*\");\n+    \/\/ Ensure THP is not disabled by OS.\n+    if (reader.lines().filter(line -> useThp.matcher(line).matches()).findFirst().isPresent()) {\n+      final Pattern heapAddr = Pattern.compile(\".*\\\\sHeap:\\\\s.+base=0x0*(\\\\p{XDigit}+).*\");\n+      final Optional<Long> addr = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, heapAddr.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1)), 16));\n+      if (!addr.isPresent()) throw new RuntimeException(\"Heap base was not found in smaps.\");\n+      \/\/ Match the start of a mapping, for example:\n+      \/\/ 200000000-800000000 rw-p 00000000 00:00 0\n+      final Pattern mapping = Pattern.compile(\"^(\\\\p{XDigit}+)-\\\\p{XDigit}+.*\");\n+      reader.lines()\n+            .filter(line -> {\n+                  Matcher matcher = mapping.matcher(line);\n+                  if (matcher.matches()) {\n+                    Long mappingAddr = Long.valueOf(line.substring(matcher.start(1), matcher.end(1)), 16);\n+                    if (mappingAddr.equals(addr.get())) return true;\n+                  }\n+                  return false;\n+                })\n+            .findFirst();\n+      final Pattern thpUsage = Pattern.compile(\"^AnonHugePages:\\\\s+(\\\\d+)\\\\skB\");\n+      final Optional<Long> usage = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, thpUsage.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1))));\n+      if (!usage.isPresent()) throw new RuntimeException(\"The usage of THP was not found.\");\n+      \/\/ Even with MADV_POPULATE_WRITE, the usage of THP is still one page less than the whole heap.\n+      if (usage.get() < 524288) throw new RuntimeException(\"The usage of THP is not enough.\");\n+    }\n+  }\n+\n+  public static class CatSmaps {\n+    public static void main(String[] args) throws Exception {\n+      new BufferedReader(new FileReader(\"\/proc\/self\/smaps\"))\n+          .lines()\n+          .forEach(line -> System.out.println(line));\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTransparentHugePageUsage.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}