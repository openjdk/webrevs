{"files":[{"patch":"@@ -1887,0 +1887,4 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1648,0 +1648,4 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2880,0 +2880,9 @@\n+\/\/ Define MADV_POPULATE_WRITE here so we can build HotSpot on old systems.\n+#define MADV_POPULATE_WRITE_value 23\n+#ifndef MADV_POPULATE_WRITE\n+  #define MADV_POPULATE_WRITE MADV_POPULATE_WRITE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+#endif\n+\n@@ -2939,0 +2948,24 @@\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  const size_t len = pointer_delta(last, first, sizeof(char)) + page_size;\n+  \/\/ Use madvise to pretouch on Linux when THP is used, and fallback to the\n+  \/\/ common method if unsupported. THP can form right after madvise rather than\n+  \/\/ being assembled later.\n+  if (HugePages::thp_mode() == THPMode::always || UseTransparentHugePages) {\n+    if (::madvise(first, len, MADV_POPULATE_WRITE) == -1) {\n+      int err = errno;\n+      if (err == EINVAL) { \/\/ Not supported\n+        \/\/ When using THP we need to always pre-touch using small pages as the\n+        \/\/ OS will initially always use small pages.\n+        pretouch_memory_common(first, last, os::vm_page_size());\n+      } else {\n+        log_warning(gc, os)(\"::madvise(\" PTR_FORMAT \", \" SIZE_FORMAT\n+                            \", %d) failed; error='%s' (errno=%d)\",\n+                            p2i(first), len, MADV_POPULATE_WRITE,\n+                            os::strerror(err), err);\n+      }\n+    }\n+  } else {\n+    pretouch_memory_common(first, last, page_size);\n+  }\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3803,0 +3803,5 @@\n+\n+void os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  pretouch_memory_common(first, last, page_size);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2110,1 +2110,1 @@\n-    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* first = align_down(start, page_size);\n@@ -2112,1 +2112,1 @@\n-    assert(cur <= last, \"invariant\");\n+    assert(first <= last, \"invariant\");\n@@ -2115,4 +2115,11 @@\n-    for ( ; true; cur += page_size) {\n-      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n-      if (cur >= last) break;\n-    }\n+    pd_pretouch_memory(first, last, page_size);\n+  }\n+}\n+\n+void os::pretouch_memory_common(void* first, void* last, size_t page_size) {\n+  assert(is_aligned(first, page_size), \"pointer \" PTR_FORMAT \" is not page-aligned by %zu\", p2i(first), page_size);\n+  assert(is_aligned(last, page_size), \"pointer \" PTR_FORMAT \" is not page-aligned by %zu\", p2i(last), page_size);\n+  assert(first <= last, \"invalid range: \" PTR_FORMAT \" -> \" PTR_FORMAT, p2i(first), p2i(last));\n+  for (char* cur = static_cast<char*>(first); \/* break *\/; cur += page_size) {\n+    Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+    if (cur >= last) break;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -226,0 +226,6 @@\n+  static void   pd_pretouch_memory(void* first, void* last, size_t page_size);\n+\n+  \/\/ Some platforms may have special treatment for pretouch, while most\n+  \/\/ platforms do the same thing. So the common part of the code was extracted\n+  \/\/ here to avoid copying it around.\n+  static void   pretouch_memory_common(void* first, void* last, size_t page_size);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -353,0 +353,26 @@\n+class PretouchMemoryRunnable : public TestRunnable {\n+  char* addr;\n+  size_t byte;\n+public:\n+  PretouchMemoryRunnable(char* addr, size_t byte): addr(addr), byte(byte) {}\n+\n+  void runUnitTest() const {\n+    os::pretouch_memory(addr, addr + byte, os::vm_page_size());\n+  }\n+};\n+\n+TEST_VM(os_linux, pretouch_thp_concurrent) {\n+  \/\/ Explicitly enable thp to test cocurrent system calls.\n+  bool useThp = UseTransparentHugePages;\n+  UseTransparentHugePages = true;\n+  char* heap = os::reserve_memory(1 * G, false, mtInternal);\n+  EXPECT_NE(heap, (char*)NULL);\n+  EXPECT_TRUE(os::commit_memory(heap, 1 * G, false));\n+  PretouchMemoryRunnable runnable(heap, 1 * G);\n+  ConcurrentTestRunner testRunner(&runnable, os::active_processor_count(), 1000);\n+  testRunner.run();\n+  EXPECT_TRUE(os::uncommit_memory(heap, 1 * G, false));\n+  EXPECT_TRUE(os::release_memory(heap, 1 * G));\n+  UseTransparentHugePages = useThp;\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) Ampere Computing and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestTransparentHugePageUsage\n+ * @bug 8315923\n+ * @library \/test\/lib\n+ * @requires vm.gc.Parallel & os.family == \"linux\" & os.maxMemory > 2G\n+ * @summary Check if the usage of THP is zero when enabled.\n+ * @comment The test is not ParallelGC-specific, but a multi-threaded GC is\n+ *          required. So ParallelGC is used here.\n+ * @run driver runtime.os.TestTransparentHugePageUsage ${os.processors}\n+ *\/\n+\n+package runtime.os;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.InputStreamReader;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTransparentHugePageUsage {\n+  private static final String[] fixedCmdLine = {\n+    \"-XX:+UseTransparentHugePages\", \"-XX:+AlwaysPreTouch\",\n+    \"-Xlog:startuptime,pagesize,gc+heap=debug\",\n+    \"-XX:+UseParallelGC\", \"-Xms1G\", \"-Xmx1G\",\n+  };\n+\n+  public static void main(String[] args) throws Exception {\n+    ArrayList<String> cmdLine = new ArrayList<>(Arrays.asList(fixedCmdLine));\n+    if (args.length > 0) {\n+      cmdLine.add(\"-XX:ParallelGCThreads=\" + args[0]);\n+    }\n+    cmdLine.add(\"runtime.os.TestTransparentHugePageUsage$CatSmaps\");\n+    ProcessBuilder builder = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+    checkUsage(new BufferedReader(new InputStreamReader(builder.start().getInputStream())));\n+  }\n+\n+  private static void checkUsage(BufferedReader reader) throws Exception {\n+    final Pattern useThp = Pattern.compile(\".*\\\\[info\\\\]\\\\[pagesize\\\\].+UseTransparentHugePages=1.*\");\n+    \/\/ Ensure THP is not disabled by OS.\n+    if (reader.lines().filter(line -> useThp.matcher(line).matches()).findFirst().isPresent()) {\n+      final Pattern heapAddr = Pattern.compile(\".*\\\\sHeap:\\\\s.+base=0x0*(\\\\p{XDigit}+).*\");\n+      final Optional<Long> addr = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, heapAddr.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1)), 16));\n+      if (!addr.isPresent()) throw new RuntimeException(\"Heap base was not found in smaps.\");\n+      \/\/ Match the start of a mapping, for example:\n+      \/\/ 200000000-800000000 rw-p 00000000 00:00 0\n+      final Pattern mapping = Pattern.compile(\"^(\\\\p{XDigit}+)-\\\\p{XDigit}+.*\");\n+      reader.lines()\n+            .filter(line -> {\n+                  Matcher matcher = mapping.matcher(line);\n+                  if (matcher.matches()) {\n+                    Long mappingAddr = Long.valueOf(line.substring(matcher.start(1), matcher.end(1)), 16);\n+                    if (mappingAddr.equals(addr.get())) return true;\n+                  }\n+                  return false;\n+                })\n+            .findFirst();\n+      final Pattern thpUsage = Pattern.compile(\"^AnonHugePages:\\\\s+(\\\\d+)\\\\skB\");\n+      final Optional<Long> usage = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, thpUsage.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1))));\n+      if (!usage.isPresent()) throw new RuntimeException(\"The usage of THP was not found.\");\n+      if (usage.get() == 0) throw new RuntimeException(\"The usage of THP should not be zero.\");\n+    }\n+  }\n+\n+  public static class CatSmaps {\n+    public static void main(String[] args) throws Exception {\n+      new BufferedReader(new FileReader(\"\/proc\/self\/smaps\"))\n+          .lines()\n+          .forEach(line -> System.out.println(line));\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTransparentHugePageUsage.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}