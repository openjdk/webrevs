{"files":[{"patch":"@@ -16284,1 +16284,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16293,1 +16293,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16299,1 +16299,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16308,1 +16308,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  lightweight_lock(basic_lock, obj, hdr, temp, rscratch2, slow_case);\n+  fast_lock(basic_lock, obj, hdr, temp, rscratch2, slow_case);\n@@ -86,1 +86,1 @@\n-  lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n+  fast_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n+void C2_MacroAssembler::fast_lock(Register obj, Register box, Register t1,\n@@ -176,1 +176,1 @@\n-  { \/\/ Lightweight locking\n+  { \/\/ Fast locking\n@@ -306,1 +306,1 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register t1,\n+void C2_MacroAssembler::fast_unlock(Register obj, Register box, Register t1,\n@@ -321,1 +321,1 @@\n-  { \/\/ Lightweight unlock\n+  { \/\/ Fast unlock\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,3 +54,3 @@\n-  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in .ad file.\n-  void fast_lock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n-  void fast_unlock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  void fast_lock(Register object, Register box, Register t1, Register t2, Register t3);\n+  void fast_unlock(Register object, Register box, Register t1, Register t2, Register t3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-  lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n+  fast_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -736,1 +736,1 @@\n-  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n+  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by fast_unlock\n@@ -747,1 +747,1 @@\n-  lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n+  fast_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7067,1 +7067,1 @@\n-\/\/ Implements lightweight-locking.\n+\/\/ Implements fast-locking.\n@@ -7072,1 +7072,1 @@\n-void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow) {\n+void MacroAssembler::fast_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -7126,1 +7126,1 @@\n-\/\/ Implements lightweight-unlocking.\n+\/\/ Implements fast-unlocking.\n@@ -7131,1 +7131,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n+void MacroAssembler::fast_unlock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -7177,1 +7177,1 @@\n-  stop(\"lightweight_unlock already unlocked\");\n+  stop(\"fast_unlock already unlocked\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1741,2 +1741,2 @@\n-  void lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow);\n-  void lightweight_unlock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void fast_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void fast_unlock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1710,1 +1710,1 @@\n-  const Register lock_tmp = r14;  \/\/ Temporary used by lightweight_lock\/unlock\n+  const Register lock_tmp = r14;  \/\/ Temporary used by fast_lock\/unlock\n@@ -1727,1 +1727,1 @@\n-    __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+    __ fast_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1836,1 +1836,1 @@\n-    __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n+    __ fast_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+  constexpr static bool supports_recursive_fast_locking() { return true; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  lightweight_lock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+  fast_lock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n@@ -221,1 +221,1 @@\n-  lightweight_unlock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+  fast_unlock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n-  lightweight_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                   1 \/* savemask (save t1) *\/, done);\n+  MacroAssembler::fast_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                            1 \/* savemask (save t1) *\/, done);\n@@ -110,2 +110,2 @@\n-  lightweight_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                     1 \/* savemask (save t1) *\/, done);\n+  MacroAssembler::fast_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                              1 \/* savemask (save t1) *\/, done);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -907,1 +907,1 @@\n-  lightweight_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n+  fast_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n@@ -948,1 +948,1 @@\n-  lightweight_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n+  fast_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1753,1 +1753,1 @@\n-\/\/ Attempt to lightweight-lock an object\n+\/\/ Attempt to fast-lock an object\n@@ -1760,1 +1760,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n+void MacroAssembler::fast_lock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n@@ -1810,1 +1810,1 @@\n-\/\/ Attempt to lightweight-unlock an object\n+\/\/ Attempt to fast-unlock an object\n@@ -1817,1 +1817,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n+void MacroAssembler::fast_unlock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1013,1 +1013,1 @@\n-  \/\/ Attempt to lightweight-lock an object\n+  \/\/ Attempt to fast-lock an object\n@@ -1020,1 +1020,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n+  void fast_lock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n@@ -1022,1 +1022,1 @@\n-  \/\/ Attempt to lightweight-unlock an object\n+  \/\/ Attempt to fast-unlock an object\n@@ -1029,1 +1029,1 @@\n-  void lightweight_unlock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n+  void fast_unlock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1142,1 +1142,1 @@\n-    __ lightweight_lock(sync_obj \/* object *\/, basic_lock \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+    __ fast_lock(sync_obj \/* object *\/, basic_lock \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n@@ -1198,1 +1198,1 @@\n-    __ lightweight_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+    __ fast_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n+  fast_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n@@ -107,1 +107,1 @@\n-  lightweight_unlock(Roop, Rmark, slow_int);\n+  fast_unlock(Roop, Rmark, slow_int);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(ConditionRegister flag, Register obj, Register box,\n+void C2_MacroAssembler::fast_lock(ConditionRegister flag, Register obj, Register box,\n@@ -41,1 +41,1 @@\n-  compiler_fast_lock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n+  compiler_fast_lock_object(flag, obj, box, tmp1, tmp2, tmp3);\n@@ -44,1 +44,1 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(ConditionRegister flag, Register obj, Register box,\n+void C2_MacroAssembler::fast_unlock(ConditionRegister flag, Register obj, Register box,\n@@ -46,1 +46,1 @@\n-  compiler_fast_unlock_lightweight_object(flag, obj, box, tmp1, tmp2, tmp3);\n+  compiler_fast_unlock_object(flag, obj, box, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in .ad file.\n-  void fast_lock_lightweight(ConditionRegister flag, Register obj, Register box,\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  void fast_lock(ConditionRegister flag, Register obj, Register box,\n@@ -34,1 +34,1 @@\n-  void fast_unlock_lightweight(ConditionRegister flag, Register obj, Register box,\n+  void fast_unlock(ConditionRegister flag, Register obj, Register box,\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -956,1 +956,1 @@\n-  lightweight_lock(monitor, object, header, tmp, slow_case);\n+  fast_lock(monitor, object, header, tmp, slow_case);\n@@ -985,1 +985,1 @@\n-  lightweight_unlock(object, header, slow_case);\n+  fast_unlock(object, header, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2674,1 +2674,1 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+void MacroAssembler::compiler_fast_lock_object(ConditionRegister flag, Register obj, Register box,\n@@ -2702,1 +2702,1 @@\n-  { \/\/ Lightweight locking\n+  { \/\/ Fast locking\n@@ -2850,1 +2850,1 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register obj, Register box,\n+void MacroAssembler::compiler_fast_unlock_object(ConditionRegister flag, Register obj, Register box,\n@@ -2866,1 +2866,1 @@\n-  { \/\/ Lightweight unlock\n+  { \/\/ Fast unlock\n@@ -2907,1 +2907,1 @@\n-    stop(\"lightweight_unlock already unlocked\");\n+    stop(\"fast_unlock already unlocked\");\n@@ -4576,1 +4576,1 @@\n-\/\/ Implements lightweight-locking.\n+\/\/ Implements fast-locking.\n@@ -4580,1 +4580,1 @@\n-void MacroAssembler::lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::fast_lock(Register box, Register obj, Register t1, Register t2, Label& slow) {\n@@ -4632,1 +4632,1 @@\n-\/\/ Implements lightweight-unlocking.\n+\/\/ Implements fast-unlocking.\n@@ -4636,1 +4636,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register t1, Label& slow) {\n+void MacroAssembler::fast_unlock(Register obj, Register t1, Label& slow) {\n@@ -4694,1 +4694,1 @@\n-  stop(\"lightweight_unlock already unlocked\");\n+  stop(\"fast_unlock already unlocked\");\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -701,2 +701,2 @@\n-  void lightweight_lock(Register box, Register obj, Register t1, Register t2, Label& slow);\n-  void lightweight_unlock(Register obj, Register t1, Label& slow);\n+  void fast_lock(Register box, Register obj, Register t1, Register t2, Label& slow);\n+  void fast_unlock(Register obj, Register t1, Label& slow);\n@@ -716,1 +716,1 @@\n-  void compiler_fast_lock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+  void compiler_fast_lock_object(ConditionRegister flag, Register oop, Register box,\n@@ -719,1 +719,1 @@\n-  void compiler_fast_unlock_lightweight_object(ConditionRegister flag, Register oop, Register box,\n+  void compiler_fast_unlock_object(ConditionRegister flag, Register oop, Register box,\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -11567,1 +11567,1 @@\n-instruct cmpFastLockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n+instruct cmpFastLock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n@@ -11574,1 +11574,1 @@\n-    __ fast_lock_lightweight($crx$$CondRegister, $oop$$Register, $box$$Register,\n+    __ fast_lock($crx$$CondRegister, $oop$$Register, $box$$Register,\n@@ -11590,1 +11590,1 @@\n-    __ fast_lock_lightweight($crx$$CondRegister, $oop$$Register, $box$$Register,\n+    __ fast_lock($crx$$CondRegister, $oop$$Register, $box$$Register,\n@@ -11599,1 +11599,1 @@\n-instruct cmpFastUnlockLightweight(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n+instruct cmpFastUnlock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n@@ -11605,1 +11605,1 @@\n-    __ fast_unlock_lightweight($crx$$CondRegister, $oop$$Register, $box$$Register,\n+    __ fast_unlock($crx$$CondRegister, $oop$$Register, $box$$Register,\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2390,1 +2390,1 @@\n-    __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n+    __ compiler_fast_lock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n@@ -2609,1 +2609,1 @@\n-    __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n+    __ compiler_fast_unlock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+  constexpr static bool supports_recursive_fast_locking() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  lightweight_lock(basic_lock, obj, hdr, temp, t1, slow_case);\n+  fast_lock(basic_lock, obj, hdr, temp, t1, slow_case);\n@@ -74,1 +74,1 @@\n-  lightweight_unlock(obj, hdr, temp, t1, slow_case);\n+  fast_unlock(obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+void C2_MacroAssembler::fast_lock(Register obj, Register box,\n@@ -77,1 +77,1 @@\n-  { \/\/ Lightweight locking\n+  { \/\/ Fast locking\n@@ -208,1 +208,1 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box,\n+void C2_MacroAssembler::fast_unlock(Register obj, Register box,\n@@ -228,1 +228,1 @@\n-  { \/\/ Lightweight unlock\n+  { \/\/ Fast unlock\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in .ad file.\n-  void fast_lock_lightweight(Register object, Register box,\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  void fast_lock(Register object, Register box,\n@@ -55,1 +55,1 @@\n-  void fast_unlock_lightweight(Register object, Register box,\n+  void fast_unlock(Register object, Register box,\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-  lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n+  fast_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -777,1 +777,1 @@\n-  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n+  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by fast_unlock\n@@ -788,1 +788,1 @@\n-  lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n+  fast_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6443,1 +6443,1 @@\n-\/\/ Implements lightweight-locking.\n+\/\/ Implements fast-locking.\n@@ -6448,1 +6448,1 @@\n-void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::fast_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -6507,1 +6507,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::fast_unlock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -6554,1 +6554,1 @@\n-  stop(\"lightweight_unlock already unlocked\");\n+  stop(\"fast_unlock already unlocked\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1641,2 +1641,2 @@\n-  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n-  void lightweight_unlock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void fast_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void fast_unlock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11047,1 +11047,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box,\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box,\n@@ -11054,1 +11054,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3,$tmp4 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3,$tmp4 #@cmpFastLock\" %}\n@@ -11057,1 +11057,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register,\n+    __ fast_lock($object$$Register, $box$$Register,\n@@ -11065,1 +11065,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box,\n+instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box,\n@@ -11072,1 +11072,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlockLightweight\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlock\" %}\n@@ -11075,1 +11075,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register,\n+    __ fast_unlock($object$$Register, $box$$Register,\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1645,1 +1645,1 @@\n-  const Register lock_tmp = x31;  \/\/ Temporary used by lightweight_lock\/unlock\n+  const Register lock_tmp = x31;  \/\/ Temporary used by fast_lock\/unlock\n@@ -1662,1 +1662,1 @@\n-    __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+    __ fast_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1757,1 +1757,1 @@\n-    __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n+    __ fast_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,1 +478,1 @@\n-  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+  constexpr static bool supports_recursive_fast_locking() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n+  fast_lock(Rbox, Roop, Rmark, tmp, slow_case);\n@@ -80,1 +80,1 @@\n-  lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n+  fast_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n-  compiler_fast_lock_lightweight_object(obj, box, temp1, temp2);\n+void C2_MacroAssembler::fast_lock(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_lock_object(obj, box, temp1, temp2);\n@@ -40,2 +40,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2) {\n-  compiler_fast_unlock_lightweight_object(obj, box, temp1, temp2);\n+void C2_MacroAssembler::fast_unlock(Register obj, Register box, Register temp1, Register temp2) {\n+  compiler_fast_unlock_object(obj, box, temp1, temp2);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,3 @@\n-  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in s390.ad file.\n-  void fast_lock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n-  void fast_unlock_lightweight(Register obj, Register box, Register temp1, Register temp2);\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in s390.ad file.\n+  void fast_lock(Register obj, Register box, Register temp1, Register temp2);\n+  void fast_unlock(Register obj, Register box, Register temp1, Register temp2);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1016,1 +1016,1 @@\n-  lightweight_lock(monitor, object, header, tmp, slow_case);\n+  fast_lock(monitor, object, header, tmp, slow_case);\n@@ -1051,1 +1051,1 @@\n-  lightweight_unlock(object, header, current_header, slow_case);\n+  fast_unlock(object, header, current_header, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6141,1 +6141,1 @@\n-\/\/ Implements lightweight-locking.\n+\/\/ Implements fast-locking.\n@@ -6145,1 +6145,1 @@\n-void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register temp1, Register temp2, Label& slow) {\n+void MacroAssembler::fast_lock(Register basic_lock, Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -6206,1 +6206,1 @@\n-\/\/ Implements lightweight-unlocking.\n+\/\/ Implements fast-unlocking.\n@@ -6210,1 +6210,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register temp1, Register temp2, Label& slow) {\n+void MacroAssembler::fast_unlock(Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -6267,1 +6267,1 @@\n-  stop(\"lightweight_unlock already unlocked\");\n+  stop(\"fast_unlock already unlocked\");\n@@ -6292,1 +6292,1 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2) {\n+void MacroAssembler::compiler_fast_lock_object(Register obj, Register box, Register tmp1, Register tmp2) {\n@@ -6317,2 +6317,2 @@\n-  BLOCK_COMMENT(\"compiler_fast_lightweight_locking {\");\n-  { \/\/ lightweight locking\n+  BLOCK_COMMENT(\"compiler_fast_locking {\");\n+  { \/\/ Fast locking\n@@ -6365,1 +6365,1 @@\n-  BLOCK_COMMENT(\"} compiler_fast_lightweight_locking\");\n+  BLOCK_COMMENT(\"} compiler_fast_locking\");\n@@ -6367,1 +6367,1 @@\n-  BLOCK_COMMENT(\"handle_inflated_monitor_lightweight_locking {\");\n+  BLOCK_COMMENT(\"handle_inflated_monitor_locking {\");\n@@ -6444,1 +6444,1 @@\n-  BLOCK_COMMENT(\"} handle_inflated_monitor_lightweight_locking\");\n+  BLOCK_COMMENT(\"} handle_inflated_monitor_locking\");\n@@ -6467,1 +6467,1 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2) {\n+void MacroAssembler::compiler_fast_unlock_object(Register obj, Register box, Register tmp1, Register tmp2) {\n@@ -6482,2 +6482,2 @@\n-  BLOCK_COMMENT(\"compiler_fast_lightweight_unlock {\");\n-  { \/\/ Lightweight Unlock\n+  BLOCK_COMMENT(\"compiler_fast_unlock {\");\n+  { \/\/ Fast Unlock\n@@ -6528,1 +6528,1 @@\n-    stop(\"lightweight_unlock already unlocked\");\n+    stop(\"fast_unlock already unlocked\");\n@@ -6549,1 +6549,1 @@\n-  BLOCK_COMMENT(\"} compiler_fast_lightweight_unlock\");\n+  BLOCK_COMMENT(\"} compiler_fast_unlock\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -793,4 +793,4 @@\n-  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Label& slow);\n-  void lightweight_unlock(Register obj, Register tmp1, Register tmp2, Label& slow);\n-  void compiler_fast_lock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2);\n-  void compiler_fast_unlock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2);\n+  void fast_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void fast_unlock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void compiler_fast_lock_object(Register obj, Register box, Register tmp1, Register tmp2);\n+  void compiler_fast_unlock_object(Register obj, Register box, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -10160,1 +10160,1 @@\n-instruct cmpFastLockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n@@ -10167,1 +10167,1 @@\n-    __ fast_lock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n@@ -10175,1 +10175,1 @@\n-instruct cmpFastUnlockLightweight(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n+instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n@@ -10182,1 +10182,1 @@\n-    __ fast_unlock_lightweight($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_unlock($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1768,1 +1768,1 @@\n-    __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1964,1 +1964,1 @@\n-    __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n+    __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,1 +428,1 @@\n-  constexpr static bool supports_recursive_lightweight_locking() { return true; }\n+  constexpr static bool supports_recursive_fast_locking() { return true; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  lightweight_lock(basic_lock, obj, hdr, tmp, slow_case);\n+  fast_lock(basic_lock, obj, hdr, tmp, slow_case);\n@@ -69,1 +69,1 @@\n-  lightweight_unlock(obj, rax, hdr, slow_case);\n+  fast_unlock(obj, rax, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-int C2FastUnlockLightweightStub::max_size() const {\n+int C2FastUnlockStub::max_size() const {\n@@ -65,1 +65,1 @@\n-void C2FastUnlockLightweightStub::emit(C2_MacroAssembler& masm) {\n+void C2FastUnlockStub::emit(C2_MacroAssembler& masm) {\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register rax_reg,\n+void C2_MacroAssembler::fast_lock(Register obj, Register box, Register rax_reg,\n@@ -250,1 +250,1 @@\n-  { \/\/ Lightweight Lock\n+  { \/\/ Fast Lock\n@@ -418,1 +418,1 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register reg_rax, Register t, Register thread) {\n+void C2_MacroAssembler::fast_unlock(Register obj, Register reg_rax, Register t, Register thread) {\n@@ -433,1 +433,1 @@\n-  C2FastUnlockLightweightStub* stub = nullptr;\n+  C2FastUnlockStub* stub = nullptr;\n@@ -436,1 +436,1 @@\n-    stub = new (Compile::current()->comp_arena()) C2FastUnlockLightweightStub(obj, mark, reg_rax, thread);\n+    stub = new (Compile::current()->comp_arena()) C2FastUnlockStub(obj, mark, reg_rax, thread);\n@@ -442,1 +442,1 @@\n-  { \/\/ Lightweight Unlock\n+  { \/\/ Fast Unlock\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  void fast_lock_lightweight(Register obj, Register box, Register rax_reg,\n+  void fast_lock(Register obj, Register box, Register rax_reg,\n@@ -40,1 +40,1 @@\n-  void fast_unlock_lightweight(Register obj, Register reg_rax, Register t, Register thread);\n+  void fast_unlock(Register obj, Register reg_rax, Register t, Register thread);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1036,1 +1036,1 @@\n-  lightweight_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n+  fast_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n@@ -1078,1 +1078,1 @@\n-  lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n+  fast_unlock(obj_reg, swap_reg, header_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9656,1 +9656,1 @@\n-\/\/ Implements lightweight-locking.\n+\/\/ Implements fast-locking.\n@@ -9662,1 +9662,1 @@\n-void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register tmp, Label& slow) {\n+void MacroAssembler::fast_lock(Register basic_lock, Register obj, Register reg_rax, Register tmp, Label& slow) {\n@@ -9718,1 +9718,1 @@\n-\/\/ Implements lightweight-unlocking.\n+\/\/ Implements fast-unlocking.\n@@ -9724,1 +9724,1 @@\n-void MacroAssembler::lightweight_unlock(Register obj, Register reg_rax, Register tmp, Label& slow) {\n+void MacroAssembler::fast_unlock(Register obj, Register reg_rax, Register tmp, Label& slow) {\n@@ -9756,1 +9756,1 @@\n-  stop(\"lightweight_unlock already unlocked\");\n+  stop(\"fast_unlock already unlocked\");\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2057,2 +2057,2 @@\n-  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register tmp, Label& slow);\n-  void lightweight_unlock(Register obj, Register reg_rax, Register tmp, Label& slow);\n+  void fast_lock(Register basic_lock, Register obj, Register reg_rax, Register tmp, Label& slow);\n+  void fast_unlock(Register obj, Register reg_rax, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2144,1 +2144,1 @@\n-    __ lightweight_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n+    __ fast_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n@@ -2269,1 +2269,1 @@\n-    __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+    __ fast_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -998,1 +998,1 @@\n-  constexpr static bool supports_recursive_lightweight_locking() {\n+  constexpr static bool supports_recursive_fast_locking() {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -14160,1 +14160,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI rax_reg, rRegP tmp) %{\n+instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI rax_reg, rRegP tmp) %{\n@@ -14166,1 +14166,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n+    __ fast_lock($object$$Register, $box$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n@@ -14171,1 +14171,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, rRegP object, rax_RegP rax_reg, rRegP tmp) %{\n+instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP rax_reg, rRegP tmp) %{\n@@ -14177,1 +14177,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n+    __ fast_unlock($object$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n+    assert(!UseObjectMonitorTable, \"Fast locking with OM table does not use markWord for monitors\");\n@@ -241,1 +241,1 @@\n-    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n+    assert(!UseObjectMonitorTable, \"Fast locking with OM table does not use markWord for monitors\");\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-class C2FastUnlockLightweightStub : public C2CodeStub {\n+class C2FastUnlockStub : public C2CodeStub {\n@@ -110,1 +110,1 @@\n-  C2FastUnlockLightweightStub(Register obj, Register mark, Register t, Register thread) : C2CodeStub(),\n+  C2FastUnlockStub(Register obj, Register mark, Register t, Register thread) : C2CodeStub(),\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -1969,2 +1968,2 @@\n-WB_ENTRY(jboolean, WB_supportsRecursiveLightweightLocking(JNIEnv* env))\n-  return (jboolean) VM_Version::supports_recursive_lightweight_locking();\n+WB_ENTRY(jboolean, WB_supportsRecursiveFastLocking(JNIEnv* env))\n+  return (jboolean) VM_Version::supports_recursive_fast_locking();\n@@ -2990,1 +2989,1 @@\n-  {CC\"supportsRecursiveLightweightLocking\", CC\"()Z\",  (void*)&WB_supportsRecursiveLightweightLocking },\n+  {CC\"supportsRecursiveFastLocking\", CC\"()Z\",  (void*)&WB_supportsRecursiveFastLocking },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-  \/\/ Is recursive lightweight locking implemented for this platform?\n-  constexpr static bool supports_recursive_lightweight_locking() { return false; }\n+  \/\/ Is recursive fast locking implemented for this platform?\n+  constexpr static bool supports_recursive_fast_locking() { return false; }\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -1674,1 +1673,1 @@\n-            LightweightSynchronizer::inflate_fast_locked_object(obj(), ObjectSynchronizer::InflateCause::inflate_cause_vm_internal,\n+            ObjectSynchronizer::inflate_fast_locked_object(obj(), ObjectSynchronizer::InflateCause::inflate_cause_vm_internal,\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1957,8 +1957,8 @@\n-          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n-          \"monitors rather than the first word of the object.\")             \\\n-                                                                            \\\n-  product(int, LightweightFastLockingSpins, 13, DIAGNOSTIC,                 \\\n-          \"Specifies the number of times lightweight fast locking will \"    \\\n-          \"attempt to CAS the markWord before inflating. Between each \"     \\\n-          \"CAS it will spin for exponentially more time, resulting in \"     \\\n-          \"a total number of spins on the order of O(2^value)\")             \\\n+          \"Use a table to record inflated monitors rather than the first \"  \\\n+          \"word of the object.\")                                            \\\n+                                                                            \\\n+  product(int, FastLockingSpins, 13, DIAGNOSTIC,                            \\\n+          \"Specifies the number of times fast locking will attempt to \"     \\\n+          \"CAS the markWord before inflating. Between each CAS it will \"    \\\n+          \"spin for exponentially more time, resulting in a total number \"  \\\n+          \"of spins on the order of O(2^value)\")                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1411,1 +1411,1 @@\n-  \/\/ Due to lightweight locking\n+  \/\/ Due to fast locking\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1231 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"jfrfiles\/jfrEventClasses.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"nmt\/memTag.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomicAccess.hpp\"\n-#include \"runtime\/basicLock.inline.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/javaThread.inline.hpp\"\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n-#include \"runtime\/lockStack.inline.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/objectMonitor.inline.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/safepointMechanism.inline.hpp\"\n-#include \"runtime\/safepointVerifiers.hpp\"\n-#include \"runtime\/synchronizer.inline.hpp\"\n-#include \"runtime\/timerTrace.hpp\"\n-#include \"runtime\/trimNativeHeap.hpp\"\n-#include \"utilities\/concurrentHashTable.inline.hpp\"\n-#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n-class ObjectMonitorTable : AllStatic {\n-  struct Config {\n-    using Value = ObjectMonitor*;\n-    static uintx get_hash(Value const& value, bool* is_dead) {\n-      return (uintx)value->hash();\n-    }\n-    static void* allocate_node(void* context, size_t size, Value const& value) {\n-      ObjectMonitorTable::inc_items_count();\n-      return AllocateHeap(size, mtObjectMonitor);\n-    };\n-    static void free_node(void* context, void* memory, Value const& value) {\n-      ObjectMonitorTable::dec_items_count();\n-      FreeHeap(memory);\n-    }\n-  };\n-  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n-\n-  static ConcurrentTable* _table;\n-  static volatile size_t _items_count;\n-  static size_t _table_size;\n-  static volatile bool _resize;\n-\n-  class Lookup : public StackObj {\n-    oop _obj;\n-\n-   public:\n-    explicit Lookup(oop obj) : _obj(obj) {}\n-\n-    uintx get_hash() const {\n-      uintx hash = _obj->mark().hash();\n-      assert(hash != 0, \"should have a hash\");\n-      return hash;\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_refers_to(_obj);\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return false;\n-    }\n-  };\n-\n-  class LookupMonitor : public StackObj {\n-    ObjectMonitor* _monitor;\n-\n-   public:\n-    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n-\n-    uintx get_hash() const {\n-      return _monitor->hash();\n-    }\n-\n-    bool equals(ObjectMonitor** value) {\n-      return (*value) == _monitor;\n-    }\n-\n-    bool is_dead(ObjectMonitor** value) {\n-      assert(*value != nullptr, \"must be\");\n-      return (*value)->object_is_dead();\n-    }\n-  };\n-\n-  static void inc_items_count() {\n-    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static void dec_items_count() {\n-    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n-  }\n-\n-  static double get_load_factor() {\n-    size_t count = AtomicAccess::load(&_items_count);\n-    return (double)count \/ (double)_table_size;\n-  }\n-\n-  static size_t table_size(Thread* current = Thread::current()) {\n-    return ((size_t)1) << _table->get_size_log2(current);\n-  }\n-\n-  static size_t max_log_size() {\n-    \/\/ TODO[OMTable]: Evaluate the max size.\n-    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n-    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n-    \/\/                are definitely rounding errors (alignment).\n-    const size_t max_capacity = MaxHeapSize;\n-    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n-    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n-    const size_t log_max_objects = log2i_graceful(max_objects);\n-\n-    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n-  }\n-\n-  static size_t min_log_size() {\n-    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n-    return 10;\n-  }\n-\n-  template<typename V>\n-  static size_t clamp_log_size(V log_size) {\n-    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n-  }\n-\n-  static size_t initial_log_size() {\n-    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n-    return clamp_log_size(estimate);\n-  }\n-\n-  static size_t grow_hint () {\n-    return ConcurrentTable::DEFAULT_GROW_HINT;\n-  }\n-\n- public:\n-  static void create() {\n-    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n-    _items_count = 0;\n-    _table_size = table_size();\n-    _resize = false;\n-  }\n-\n-  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n-#ifdef ASSERT\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      bool has_monitor = obj->mark().has_monitor();\n-      assert(has_monitor == (monitor != nullptr),\n-          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n-          BOOL_TO_STR(has_monitor), p2i(monitor));\n-    }\n-#endif\n-  }\n-\n-  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n-    ObjectMonitor* result = nullptr;\n-    Lookup lookup_f(obj);\n-    auto found_f = [&](ObjectMonitor** found) {\n-      assert((*found)->object_peek() == obj, \"must be\");\n-      result = *found;\n-    };\n-    _table->get(current, lookup_f, found_f);\n-    verify_monitor_get_result(obj, result);\n-    return result;\n-  }\n-\n-  static void try_notify_grow() {\n-    if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n-      AtomicAccess::store(&_resize, true);\n-      if (Service_lock->try_lock()) {\n-        Service_lock->notify();\n-        Service_lock->unlock();\n-      }\n-    }\n-  }\n-\n-  static bool should_shrink() {\n-    \/\/ Not implemented;\n-    return false;\n-  }\n-\n-  static constexpr double GROW_LOAD_FACTOR = 0.75;\n-\n-  static bool should_grow() {\n-    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n-  }\n-\n-  static bool should_resize() {\n-    return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n-  }\n-\n-  template<typename Task, typename... Args>\n-  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n-    if (task.prepare(current)) {\n-      log_trace(monitortable)(\"Started to %s\", task_name);\n-      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n-      while (task.do_task(current, args...)) {\n-        task.pause(current);\n-        {\n-          ThreadBlockInVM tbivm(current);\n-        }\n-        task.cont(current);\n-      }\n-      task.done(current);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool grow(JavaThread* current) {\n-    ConcurrentTable::GrowTask grow_task(_table);\n-    if (run_task(current, grow_task, \"Grow\")) {\n-      _table_size = table_size(current);\n-      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool clean(JavaThread* current) {\n-    ConcurrentTable::BulkDeleteTask clean_task(_table);\n-    auto is_dead = [&](ObjectMonitor** monitor) {\n-      return (*monitor)->object_is_dead();\n-    };\n-    auto do_nothing = [&](ObjectMonitor** monitor) {};\n-    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n-    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n-  }\n-\n-  static bool resize(JavaThread* current) {\n-    LogTarget(Info, monitortable) lt;\n-    bool success = false;\n-\n-    if (should_grow()) {\n-      lt.print(\"Start growing with load factor %f\", get_load_factor());\n-      success = grow(current);\n-    } else {\n-      if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n-        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n-      }\n-      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n-      success = clean(current);\n-    }\n-\n-    AtomicAccess::store(&_resize, false);\n-\n-    return success;\n-  }\n-\n-  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n-    \/\/ Enter the monitor into the concurrent hashtable.\n-    ObjectMonitor* result = monitor;\n-    Lookup lookup_f(obj);\n-    auto found_f = [&](ObjectMonitor** found) {\n-      assert((*found)->object_peek() == obj, \"must be\");\n-      result = *found;\n-    };\n-    bool grow;\n-    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n-    verify_monitor_get_result(obj, result);\n-    if (grow) {\n-      try_notify_grow();\n-    }\n-    return result;\n-  }\n-\n-  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n-    LookupMonitor lookup_f(monitor);\n-    return _table->remove(current, lookup_f);\n-  }\n-\n-  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n-    LookupMonitor lookup_f(monitor);\n-    bool result = false;\n-    auto found_f = [&](ObjectMonitor** found) {\n-      result = true;\n-    };\n-    _table->get(current, lookup_f, found_f);\n-    return result;\n-  }\n-\n-  static void print_on(outputStream* st) {\n-    auto printer = [&] (ObjectMonitor** entry) {\n-       ObjectMonitor* om = *entry;\n-       oop obj = om->object_peek();\n-       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n-       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n-       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n-       st->cr();\n-       return true;\n-    };\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      _table->do_safepoint_scan(printer);\n-    } else {\n-      _table->do_scan(Thread::current(), printer);\n-    }\n-  }\n-};\n-\n-ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n-volatile size_t ObjectMonitorTable::_items_count = 0;\n-size_t ObjectMonitorTable::_table_size = 0;\n-volatile bool ObjectMonitorTable::_resize = false;\n-\n-ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted) {\n-  ObjectMonitor* monitor = get_monitor_from_table(current, object);\n-  if (monitor != nullptr) {\n-    *inserted = false;\n-    return monitor;\n-  }\n-\n-  ObjectMonitor* alloced_monitor = new ObjectMonitor(object);\n-  alloced_monitor->set_anonymous_owner();\n-\n-  \/\/ Try insert monitor\n-  monitor = add_monitor(current, alloced_monitor, object);\n-\n-  *inserted = alloced_monitor == monitor;\n-  if (!*inserted) {\n-    delete alloced_monitor;\n-  }\n-\n-  return monitor;\n-}\n-\n-static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n-  if (log_is_enabled(Trace, monitorinflation)) {\n-    ResourceMark rm(current);\n-    log_trace(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n-                                INTPTR_FORMAT \", type='%s' cause=%s\", p2i(object),\n-                                object->mark().value(), object->klass()->external_name(),\n-                                ObjectSynchronizer::inflate_cause_name(cause));\n-  }\n-}\n-\n-static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n-                                       const oop obj,\n-                                       ObjectSynchronizer::InflateCause cause) {\n-  assert(event != nullptr, \"invariant\");\n-  const Klass* monitor_klass = obj->klass();\n-  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n-    return;\n-  }\n-  event->set_monitorClass(monitor_klass);\n-  event->set_address((uintptr_t)(void*)obj);\n-  event->set_cause((u1)cause);\n-  event->commit();\n-}\n-\n-ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-\n-  EventJavaMonitorInflate event;\n-\n-  bool inserted;\n-  ObjectMonitor* monitor = get_or_insert_monitor_from_table(object, current, &inserted);\n-\n-  if (inserted) {\n-    log_inflate(current, object, cause);\n-    if (event.should_commit()) {\n-      post_monitor_inflate_event(&event, object, cause);\n-    }\n-\n-    \/\/ The monitor has an anonymous owner so it is safe from async deflation.\n-    ObjectSynchronizer::_in_use_list.add(monitor);\n-  }\n-\n-  return monitor;\n-}\n-\n-\/\/ Add the hashcode to the monitor to match the object and put it in the hashtable.\n-ObjectMonitor* LightweightSynchronizer::add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-  assert(obj == monitor->object(), \"must be\");\n-\n-  intptr_t hash = obj->mark().hash();\n-  assert(hash != 0, \"must be set when claiming the object monitor\");\n-  monitor->set_hash(hash);\n-\n-  return ObjectMonitorTable::monitor_put_get(current, monitor, obj);\n-}\n-\n-bool LightweightSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-  assert(monitor->object_peek() == obj, \"must be, cleared objects are removed by is_dead\");\n-\n-  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n-}\n-\n-void LightweightSynchronizer::deflate_mark_word(oop obj) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-\n-  markWord mark = obj->mark_acquire();\n-  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n-\n-  while (mark.has_monitor()) {\n-    const markWord new_mark = mark.clear_lock_bits().set_unlocked();\n-    mark = obj->cas_set_mark(new_mark, mark);\n-  }\n-}\n-\n-void LightweightSynchronizer::initialize() {\n-  if (!UseObjectMonitorTable) {\n-    return;\n-  }\n-  ObjectMonitorTable::create();\n-}\n-\n-bool LightweightSynchronizer::needs_resize() {\n-  if (!UseObjectMonitorTable) {\n-    return false;\n-  }\n-  return ObjectMonitorTable::should_resize();\n-}\n-\n-bool LightweightSynchronizer::resize_table(JavaThread* current) {\n-  if (!UseObjectMonitorTable) {\n-    return true;\n-  }\n-  return ObjectMonitorTable::resize(current);\n-}\n-\n-class LightweightSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n- private:\n-  oop _contended_oops[LockStack::CAPACITY];\n-  int _length;\n-\n-  void do_oop(oop* o) final {\n-    oop obj = *o;\n-    if (obj->mark_acquire().has_monitor()) {\n-      if (_length > 0 && _contended_oops[_length - 1] == obj) {\n-        \/\/ Recursive\n-        return;\n-      }\n-      _contended_oops[_length++] = obj;\n-    }\n-  }\n-\n-  void do_oop(narrowOop* o) final {\n-    ShouldNotReachHere();\n-  }\n-\n- public:\n-  LockStackInflateContendedLocks() :\n-    _contended_oops(),\n-    _length(0) {};\n-\n-  void inflate(JavaThread* current) {\n-    assert(current == JavaThread::current(), \"must be\");\n-    current->lock_stack().oops_do(this);\n-    for (int i = 0; i < _length; i++) {\n-      LightweightSynchronizer::\n-        inflate_fast_locked_object(_contended_oops[i], ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n-    }\n-  }\n-};\n-\n-void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  LockStack& lock_stack = current->lock_stack();\n-\n-  \/\/ Make room on lock_stack\n-  if (lock_stack.is_full()) {\n-    \/\/ Inflate contended objects\n-    LockStackInflateContendedLocks().inflate(current);\n-    if (lock_stack.is_full()) {\n-      \/\/ Inflate the oldest object\n-      inflate_fast_locked_object(lock_stack.bottom(), ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n-    }\n-  }\n-}\n-\n-class LightweightSynchronizer::CacheSetter : StackObj {\n-  JavaThread* const _thread;\n-  BasicLock* const _lock;\n-  ObjectMonitor* _monitor;\n-\n-  NONCOPYABLE(CacheSetter);\n-\n- public:\n-  CacheSetter(JavaThread* thread, BasicLock* lock) :\n-    _thread(thread),\n-    _lock(lock),\n-    _monitor(nullptr) {}\n-\n-  ~CacheSetter() {\n-    \/\/ Only use the cache if using the table.\n-    if (UseObjectMonitorTable) {\n-      if (_monitor != nullptr) {\n-        \/\/ If the monitor is already in the BasicLock cache then it is most\n-        \/\/ likely in the thread cache, do not set it again to avoid reordering.\n-        if (_monitor != _lock->object_monitor_cache()) {\n-          _thread->om_set_monitor_cache(_monitor);\n-          _lock->set_object_monitor_cache(_monitor);\n-        }\n-      } else {\n-        _lock->clear_object_monitor_cache();\n-      }\n-    }\n-  }\n-\n-  void set_monitor(ObjectMonitor* monitor) {\n-    assert(_monitor == nullptr, \"only set once\");\n-    _monitor = monitor;\n-  }\n-\n-};\n-\n-\/\/ Reads first from the BasicLock cache then from the OMCache in the current thread.\n-\/\/ C2 fast-path may have put the monitor in the cache in the BasicLock.\n-inline static ObjectMonitor* read_caches(JavaThread* current, BasicLock* lock, oop object) {\n-  ObjectMonitor* monitor = lock->object_monitor_cache();\n-  if (monitor == nullptr) {\n-    monitor = current->om_get_from_monitor_cache(object);\n-  }\n-  return monitor;\n-}\n-\n-class LightweightSynchronizer::VerifyThreadState {\n-  bool _no_safepoint;\n-\n- public:\n-  VerifyThreadState(JavaThread* locking_thread, JavaThread* current) : _no_safepoint(locking_thread != current) {\n-    assert(current == Thread::current(), \"must be\");\n-    assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"locking_thread may not run concurrently\");\n-    if (_no_safepoint) {\n-      DEBUG_ONLY(JavaThread::current()->inc_no_safepoint_count();)\n-    }\n-  }\n-  ~VerifyThreadState() {\n-    if (_no_safepoint){\n-      DEBUG_ONLY(JavaThread::current()->dec_no_safepoint_count();)\n-    }\n-  }\n-};\n-\n-inline bool LightweightSynchronizer::fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current) {\n-  markWord mark = obj->mark();\n-  while (mark.is_unlocked()) {\n-    ensure_lock_stack_space(current);\n-    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n-    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n-    \/\/ Try to swing into 'fast-locked' state.\n-    markWord locked_mark = mark.set_fast_locked();\n-    markWord old_mark = mark;\n-    mark = obj->cas_set_mark(locked_mark, old_mark);\n-    if (old_mark == mark) {\n-      \/\/ Successfully fast-locked, push object to lock-stack and return.\n-      lock_stack.push(obj);\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n-  const int log_spin_limit = os::is_MP() ? LightweightFastLockingSpins : 1;\n-  const int log_min_safepoint_check_interval = 10;\n-\n-  markWord mark = obj->mark();\n-  const auto should_spin = [&]() {\n-    if (!mark.has_monitor()) {\n-      \/\/ Spin while not inflated.\n-      return true;\n-    } else if (observed_deflation) {\n-      \/\/ Spin while monitor is being deflated.\n-      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n-      return monitor == nullptr || monitor->is_being_async_deflated();\n-    }\n-    \/\/ Else stop spinning.\n-    return false;\n-  };\n-  \/\/ Always attempt to lock once even when safepoint synchronizing.\n-  bool should_process = false;\n-  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n-    \/\/ Spin with exponential backoff.\n-    const int total_spin_count = 1 << i;\n-    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n-    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n-    for (int outer = 0; outer < outer_spin_count; outer++) {\n-      should_process = SafepointMechanism::should_process(current);\n-      if (should_process) {\n-        \/\/ Stop spinning for safepoint.\n-        break;\n-      }\n-      for (int inner = 1; inner < inner_spin_count; inner++) {\n-        SpinPause();\n-      }\n-    }\n-\n-    if (fast_lock_try_enter(obj, lock_stack, current)) return true;\n-  }\n-  return false;\n-}\n-\n-void LightweightSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n-  assert(!UseObjectMonitorTable || lock->object_monitor_cache() == nullptr, \"must be cleared\");\n-  JavaThread* current = JavaThread::current();\n-  VerifyThreadState vts(locking_thread, current);\n-\n-  if (obj->klass()->is_value_based()) {\n-    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n-  }\n-\n-  LockStack& lock_stack = locking_thread->lock_stack();\n-\n-  ObjectMonitor* monitor = nullptr;\n-  if (lock_stack.contains(obj())) {\n-    monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n-    bool entered = monitor->enter_for(locking_thread);\n-    assert(entered, \"recursive ObjectMonitor::enter_for must succeed\");\n-  } else {\n-    do {\n-      \/\/ It is assumed that enter_for must enter on an object without contention.\n-      monitor = inflate_and_enter(obj(), lock, ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n-      \/\/ But there may still be a race with deflation.\n-    } while (monitor == nullptr);\n-  }\n-\n-  assert(monitor != nullptr, \"LightweightSynchronizer::enter_for must succeed\");\n-  assert(!UseObjectMonitorTable || lock->object_monitor_cache() == nullptr, \"unused. already cleared\");\n-}\n-\n-void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-\n-  if (obj->klass()->is_value_based()) {\n-    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n-  }\n-\n-  CacheSetter cache_setter(current, lock);\n-\n-  \/\/ Used when deflation is observed. Progress here requires progress\n-  \/\/ from the deflator. After observing that the deflator is not\n-  \/\/ making progress (after two yields), switch to sleeping.\n-  SpinYield spin_yield(0, 2);\n-  bool observed_deflation = false;\n-\n-  LockStack& lock_stack = current->lock_stack();\n-\n-  if (!lock_stack.is_full() && lock_stack.try_recursive_enter(obj())) {\n-    \/\/ Recursively fast locked\n-    return;\n-  }\n-\n-  if (lock_stack.contains(obj())) {\n-    ObjectMonitor* monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n-    bool entered = monitor->enter(current);\n-    assert(entered, \"recursive ObjectMonitor::enter must succeed\");\n-    cache_setter.set_monitor(monitor);\n-    return;\n-  }\n-\n-  while (true) {\n-    \/\/ Fast-locking does not use the 'lock' argument.\n-    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n-    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n-    \/\/ is worth it.\n-    \/\/ If deflation has been observed we also spin while deflation is ongoing.\n-    if (fast_lock_try_enter(obj(), lock_stack, current)) {\n-      return;\n-    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n-      return;\n-    }\n-\n-    if (observed_deflation) {\n-      spin_yield.wait();\n-    }\n-\n-    ObjectMonitor* monitor = inflate_and_enter(obj(), lock, ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n-    if (monitor != nullptr) {\n-      cache_setter.set_monitor(monitor);\n-      return;\n-    }\n-\n-    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n-    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n-    \/\/ for clearing out the monitor and transitioning the markWord back to\n-    \/\/ fast locking.\n-    observed_deflation = true;\n-  }\n-}\n-\n-void LightweightSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n-\n-  markWord mark = object->mark();\n-  assert(!mark.is_unlocked(), \"must be\");\n-\n-  LockStack& lock_stack = current->lock_stack();\n-  if (mark.is_fast_locked()) {\n-    if (lock_stack.try_recursive_exit(object)) {\n-      \/\/ This is a recursive exit which succeeded\n-      return;\n-    }\n-    if (lock_stack.is_recursive(object)) {\n-      \/\/ Must inflate recursive locks if try_recursive_exit fails\n-      \/\/ This happens for un-structured unlocks, could potentially\n-      \/\/ fix try_recursive_exit to handle these.\n-      inflate_fast_locked_object(object, ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n-    }\n-  }\n-\n-  while (mark.is_fast_locked()) {\n-    markWord unlocked_mark = mark.set_unlocked();\n-    markWord old_mark = mark;\n-    mark = object->cas_set_mark(unlocked_mark, old_mark);\n-    if (old_mark == mark) {\n-      \/\/ CAS successful, remove from lock_stack\n-      size_t recursion = lock_stack.remove(object) - 1;\n-      assert(recursion == 0, \"Should not have unlocked here\");\n-      return;\n-    }\n-  }\n-\n-  assert(mark.has_monitor(), \"must be\");\n-  \/\/ The monitor exists\n-  ObjectMonitor* monitor;\n-  if (UseObjectMonitorTable) {\n-    monitor = read_caches(current, lock, object);\n-    if (monitor == nullptr) {\n-      monitor = get_monitor_from_table(current, object);\n-    }\n-  } else {\n-    monitor = ObjectSynchronizer::read_monitor(mark);\n-  }\n-  if (monitor->has_anonymous_owner()) {\n-    assert(current->lock_stack().contains(object), \"current must have object on its lock stack\");\n-    monitor->set_owner_from_anonymous(current);\n-    monitor->set_recursions(current->lock_stack().remove(object) - 1);\n-  }\n-\n-  monitor->exit(current);\n-}\n-\n-\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to get an\n-\/\/ inflated ObjectMonitor* from contexts which require that, such as\n-\/\/ notify\/wait and jni_exit. Lightweight locking keeps the invariant that it\n-\/\/ only inflates if it is already locked by the current thread or the current\n-\/\/ thread is in the process of entering. To maintain this invariant we need to\n-\/\/ throw a java.lang.IllegalMonitorStateException before inflating if the\n-\/\/ current thread is not the owner.\n-ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n-  JavaThread* current = THREAD;\n-\n-  for (;;) {\n-    markWord mark = obj->mark_acquire();\n-    if (mark.is_unlocked()) {\n-      \/\/ No lock, IMSE.\n-      THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n-                 \"current thread is not owner\", nullptr);\n-    }\n-\n-    if (mark.is_fast_locked()) {\n-      if (!current->lock_stack().contains(obj)) {\n-        \/\/ Fast locked by other thread, IMSE.\n-        THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n-                   \"current thread is not owner\", nullptr);\n-      } else {\n-        \/\/ Current thread owns the lock, must inflate\n-        return inflate_fast_locked_object(obj, cause, current, current);\n-      }\n-    }\n-\n-    assert(mark.has_monitor(), \"must be\");\n-    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n-    if (monitor != nullptr) {\n-      if (monitor->has_anonymous_owner()) {\n-        LockStack& lock_stack = current->lock_stack();\n-        if (lock_stack.contains(obj)) {\n-          \/\/ Current thread owns the lock but someone else inflated it.\n-          \/\/ Fix owner and pop lock stack.\n-          monitor->set_owner_from_anonymous(current);\n-          monitor->set_recursions(lock_stack.remove(obj) - 1);\n-        } else {\n-          \/\/ Fast locked (and inflated) by other thread, or deflation in progress, IMSE.\n-          THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n-                     \"current thread is not owner\", nullptr);\n-        }\n-      }\n-      return monitor;\n-    }\n-  }\n-}\n-\n-ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, Thread* current) {\n-\n-  \/\/ The JavaThread* locking parameter requires that the locking_thread == JavaThread::current,\n-  \/\/ or is suspended throughout the call by some other mechanism.\n-  \/\/ Even with lightweight locking the thread might be nullptr when called from a non\n-  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n-  \/\/ important for the correctness of the lightweight locking algorithm that the thread\n-  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n-  EventJavaMonitorInflate event;\n-\n-  for (;;) {\n-    const markWord mark = object->mark_acquire();\n-\n-    \/\/ The mark can be in one of the following states:\n-    \/\/ *  inflated     - Just return if using stack-locking.\n-    \/\/                   If using fast-locking and the ObjectMonitor owner\n-    \/\/                   is anonymous and the locking_thread owns the\n-    \/\/                   object lock, then we make the locking_thread\n-    \/\/                   the ObjectMonitor owner and remove the lock from\n-    \/\/                   the locking_thread's lock stack.\n-    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n-    \/\/ *  unlocked     - Aggressively inflate the object.\n-\n-    \/\/ CASE: inflated\n-    if (mark.has_monitor()) {\n-      ObjectMonitor* inf = mark.monitor();\n-      markWord dmw = inf->header();\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-      if (inf->has_anonymous_owner() &&\n-          locking_thread != nullptr && locking_thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(locking_thread);\n-        size_t removed = locking_thread->lock_stack().remove(object);\n-        inf->set_recursions(removed - 1);\n-      }\n-      return inf;\n-    }\n-\n-    \/\/ CASE: fast-locked\n-    \/\/ Could be fast-locked either by the locking_thread or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n-    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n-    \/\/ the locking_thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to the locking_thread. Otherwise, we set the ObjectMonitor's owner\n-    \/\/ to anonymous. If we lose the race to set the object's mark to the\n-    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n-    \/\/\n-    if (mark.is_fast_locked()) {\n-      ObjectMonitor* monitor = new ObjectMonitor(object);\n-      monitor->set_header(mark.set_unlocked());\n-      bool own = locking_thread != nullptr && locking_thread->lock_stack().contains(object);\n-      if (own) {\n-        \/\/ Owned by locking_thread.\n-        monitor->set_owner(locking_thread);\n-      } else {\n-        \/\/ Owned by somebody else.\n-        monitor->set_anonymous_owner();\n-      }\n-      markWord monitor_mark = markWord::encode(monitor);\n-      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n-      if (old_mark == mark) {\n-        \/\/ Success! Return inflated monitor.\n-        if (own) {\n-          size_t removed = locking_thread->lock_stack().remove(object);\n-          monitor->set_recursions(removed - 1);\n-        }\n-        \/\/ Once the ObjectMonitor is configured and object is associated\n-        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-        ObjectSynchronizer::_in_use_list.add(monitor);\n-\n-        log_inflate(current, object, cause);\n-        if (event.should_commit()) {\n-          post_monitor_inflate_event(&event, object, cause);\n-        }\n-        return monitor;\n-      } else {\n-        delete monitor;\n-        continue;  \/\/ Interference -- just retry\n-      }\n-    }\n-\n-    \/\/ CASE: unlocked\n-    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n-    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n-    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n-    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n-    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n-    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n-    \/\/ An inflateTry() method that we could call from enter() would be useful.\n-\n-    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    ObjectMonitor* m = new ObjectMonitor(object);\n-    \/\/ prepare m for installation - set monitor to initial state\n-    m->set_header(mark);\n-\n-    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n-      delete m;\n-      m = nullptr;\n-      continue;\n-      \/\/ interference - the markword changed - just retry.\n-      \/\/ The state-transitions are one-way, so there's no chance of\n-      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n-    }\n-\n-    \/\/ Once the ObjectMonitor is configured and object is associated\n-    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-    ObjectSynchronizer::_in_use_list.add(m);\n-\n-    log_inflate(current, object, cause);\n-    if (event.should_commit()) {\n-      post_monitor_inflate_event(&event, object, cause);\n-    }\n-    return m;\n-  }\n-}\n-\n-ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n-  VerifyThreadState vts(locking_thread, current);\n-  assert(locking_thread->lock_stack().contains(object), \"locking_thread must have object on its lock stack\");\n-\n-  ObjectMonitor* monitor;\n-\n-  if (!UseObjectMonitorTable) {\n-    return inflate_into_object_header(object, cause, locking_thread, current);\n-  }\n-\n-  \/\/ Inflating requires a hash code\n-  ObjectSynchronizer::FastHashCode(current, object);\n-\n-  markWord mark = object->mark_acquire();\n-  assert(!mark.is_unlocked(), \"Cannot be unlocked\");\n-\n-  for (;;) {\n-    \/\/ Fetch the monitor from the table\n-    monitor = get_or_insert_monitor(object, current, cause);\n-\n-    \/\/ ObjectMonitors are always inserted as anonymously owned, this thread is\n-    \/\/ the current holder of the monitor. So unless the entry is stale and\n-    \/\/ contains a deflating monitor it must be anonymously owned.\n-    if (monitor->has_anonymous_owner()) {\n-      \/\/ The monitor must be anonymously owned if it was added\n-      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n-      \/\/ New fresh monitor\n-      break;\n-    }\n-\n-    \/\/ If the monitor was not anonymously owned then we got a deflating monitor\n-    \/\/ from the table. We need to let the deflator make progress and remove this\n-    \/\/ entry before we are allowed to add a new one.\n-    os::naked_yield();\n-    assert(monitor->is_being_async_deflated(), \"Should be the reason\");\n-  }\n-\n-  \/\/ Set the mark word; loop to handle concurrent updates to other parts of the mark word\n-  while (mark.is_fast_locked()) {\n-    mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n-  }\n-\n-  \/\/ Indicate that the monitor now has a known owner\n-  monitor->set_owner_from_anonymous(locking_thread);\n-\n-  \/\/ Remove the entry from the thread's lock stack\n-  monitor->set_recursions(locking_thread->lock_stack().remove(object) - 1);\n-\n-  if (locking_thread == current) {\n-    \/\/ Only change the thread local state of the current thread.\n-    locking_thread->om_set_monitor_cache(monitor);\n-  }\n-\n-  return monitor;\n-}\n-\n-ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, BasicLock* lock, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n-  VerifyThreadState vts(locking_thread, current);\n-\n-  \/\/ Note: In some paths (deoptimization) the 'current' thread inflates and\n-  \/\/ enters the lock on behalf of the 'locking_thread' thread.\n-\n-  ObjectMonitor* monitor = nullptr;\n-\n-  if (!UseObjectMonitorTable) {\n-    \/\/ Do the old inflate and enter.\n-    monitor = inflate_into_object_header(object, cause, locking_thread, current);\n-\n-    bool entered;\n-    if (locking_thread == current) {\n-      entered = monitor->enter(locking_thread);\n-    } else {\n-      entered = monitor->enter_for(locking_thread);\n-    }\n-\n-    \/\/ enter returns false for deflation found.\n-    return entered ? monitor : nullptr;\n-  }\n-\n-  NoSafepointVerifier nsv;\n-\n-  \/\/ Try to get the monitor from the thread-local cache.\n-  \/\/ There's no need to use the cache if we are locking\n-  \/\/ on behalf of another thread.\n-  if (current == locking_thread) {\n-    monitor = read_caches(current, lock, object);\n-  }\n-\n-  \/\/ Get or create the monitor\n-  if (monitor == nullptr) {\n-    \/\/ Lightweight monitors require that hash codes are installed first\n-    ObjectSynchronizer::FastHashCode(locking_thread, object);\n-    monitor = get_or_insert_monitor(object, current, cause);\n-  }\n-\n-  if (monitor->try_enter(locking_thread)) {\n-    return monitor;\n-  }\n-\n-  \/\/ Holds is_being_async_deflated() stable throughout this function.\n-  ObjectMonitorContentionMark contention_mark(monitor);\n-\n-  \/\/\/ First handle the case where the monitor from the table is deflated\n-  if (monitor->is_being_async_deflated()) {\n-    \/\/ The MonitorDeflation thread is deflating the monitor. The locking thread\n-    \/\/ must spin until further progress has been made.\n-\n-    \/\/ Clear the BasicLock cache as it may contain this monitor.\n-    lock->clear_object_monitor_cache();\n-\n-    const markWord mark = object->mark_acquire();\n-\n-    if (mark.has_monitor()) {\n-      \/\/ Waiting on the deflation thread to remove the deflated monitor from the table.\n-      os::naked_yield();\n-\n-    } else if (mark.is_fast_locked()) {\n-      \/\/ Some other thread managed to fast-lock the lock, or this is a\n-      \/\/ recursive lock from the same thread; yield for the deflation\n-      \/\/ thread to remove the deflated monitor from the table.\n-      os::naked_yield();\n-\n-    } else {\n-      assert(mark.is_unlocked(), \"Implied\");\n-      \/\/ Retry immediately\n-    }\n-\n-    \/\/ Retry\n-    return nullptr;\n-  }\n-\n-  for (;;) {\n-    const markWord mark = object->mark_acquire();\n-    \/\/ The mark can be in one of the following states:\n-    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous\n-    \/\/                   and the locking_thread owns the object\n-    \/\/                   lock, then we make the locking_thread\n-    \/\/                   the ObjectMonitor owner and remove the\n-    \/\/                   lock from the locking_thread's lock stack.\n-    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n-    \/\/ *  neutral      - Inflate the object. Successful CAS is locked\n-\n-    \/\/ CASE: inflated\n-    if (mark.has_monitor()) {\n-      LockStack& lock_stack = locking_thread->lock_stack();\n-      if (monitor->has_anonymous_owner() && lock_stack.contains(object)) {\n-        \/\/ The lock is fast-locked by the locking thread,\n-        \/\/ convert it to a held monitor with a known owner.\n-        monitor->set_owner_from_anonymous(locking_thread);\n-        monitor->set_recursions(lock_stack.remove(object) - 1);\n-      }\n-\n-      break; \/\/ Success\n-    }\n-\n-    \/\/ CASE: fast-locked\n-    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n-    \/\/\n-    if (mark.is_fast_locked()) {\n-      markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n-      if (old_mark != mark) {\n-        \/\/ CAS failed\n-        continue;\n-      }\n-\n-      \/\/ Success! Return inflated monitor.\n-      LockStack& lock_stack = locking_thread->lock_stack();\n-      if (lock_stack.contains(object)) {\n-        \/\/ The lock is fast-locked by the locking thread,\n-        \/\/ convert it to a held monitor with a known owner.\n-        monitor->set_owner_from_anonymous(locking_thread);\n-        monitor->set_recursions(lock_stack.remove(object) - 1);\n-      }\n-\n-      break; \/\/ Success\n-    }\n-\n-    \/\/ CASE: neutral (unlocked)\n-\n-    \/\/ Catch if the object's header is not neutral (not locked and\n-    \/\/ not marked is what we care about here).\n-    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n-    if (old_mark != mark) {\n-      \/\/ CAS failed\n-      continue;\n-    }\n-\n-    \/\/ Transitioned from unlocked to monitor means locking_thread owns the lock.\n-    monitor->set_owner_from_anonymous(locking_thread);\n-\n-    return monitor;\n-  }\n-\n-  if (current == locking_thread) {\n-    \/\/ One round of spinning\n-    if (monitor->spin_enter(locking_thread)) {\n-      return monitor;\n-    }\n-\n-    \/\/ Monitor is contended, take the time before entering to fix the lock stack.\n-    LockStackInflateContendedLocks().inflate(current);\n-  }\n-\n-  \/\/ enter can block for safepoints; clear the unhandled object oop\n-  PauseNoSafepointVerifier pnsv(&nsv);\n-  object = nullptr;\n-\n-  if (current == locking_thread) {\n-    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n-  } else {\n-    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n-  }\n-\n-  return monitor;\n-}\n-\n-void LightweightSynchronizer::deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n-  if (obj != nullptr) {\n-    deflate_mark_word(obj);\n-  }\n-  bool removed = remove_monitor(current, monitor, obj);\n-  if (obj != nullptr) {\n-    assert(removed, \"Should have removed the entry if obj was alive\");\n-  }\n-}\n-\n-ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-  return ObjectMonitorTable::monitor_get(current, obj);\n-}\n-\n-bool LightweightSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-  return ObjectMonitorTable::contains_monitor(current, monitor);\n-}\n-\n-bool LightweightSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n-  assert(current->thread_state() == _thread_in_Java, \"must be\");\n-  assert(obj != nullptr, \"must be\");\n-  NoSafepointVerifier nsv;\n-\n-  LockStack& lock_stack = current->lock_stack();\n-  if (lock_stack.is_full()) {\n-    \/\/ Always go into runtime if the lock stack is full.\n-    return false;\n-  }\n-\n-  const markWord mark = obj->mark();\n-\n-#ifndef _LP64\n-  \/\/ Only for 32bit which has limited support for fast locking outside the runtime.\n-  if (lock_stack.try_recursive_enter(obj)) {\n-    \/\/ Recursive lock successful.\n-    return true;\n-  }\n-\n-  if (mark.is_unlocked()) {\n-    markWord locked_mark = mark.set_fast_locked();\n-    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n-      \/\/ Successfully fast-locked, push object to lock-stack and return.\n-      lock_stack.push(obj);\n-      return true;\n-    }\n-  }\n-#endif\n-\n-  if (mark.has_monitor()) {\n-    ObjectMonitor* monitor;\n-    if (UseObjectMonitorTable) {\n-      monitor = read_caches(current, lock, obj);\n-    } else {\n-      monitor = ObjectSynchronizer::read_monitor(mark);\n-    }\n-\n-    if (monitor == nullptr) {\n-      \/\/ Take the slow-path on a cache miss.\n-      return false;\n-    }\n-\n-    if (UseObjectMonitorTable) {\n-      \/\/ Set the monitor regardless of success.\n-      \/\/ Either we successfully lock on the monitor, or we retry with the\n-      \/\/ monitor in the slow path. If the monitor gets deflated, it will be\n-      \/\/ cleared, either by the CacheSetter if we fast lock in enter or in\n-      \/\/ inflate_and_enter when we see that the monitor is deflated.\n-      lock->set_object_monitor_cache(monitor);\n-    }\n-\n-    if (monitor->spin_enter(current)) {\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Slow-path.\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":0,"deletions":1231,"binary":false,"changes":1231,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n-#define SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/objectMonitor.hpp\"\n-#include \"runtime\/synchronizer.hpp\"\n-\n-class ObjectMonitorTable;\n-\n-class LightweightSynchronizer : AllStatic {\n- private:\n-  static ObjectMonitor* get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted);\n-  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n-\n-  static ObjectMonitor* add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj);\n-  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n-\n-  static void deflate_mark_word(oop object);\n-\n-  static void ensure_lock_stack_space(JavaThread* current);\n-\n-  class CacheSetter;\n-  class LockStackInflateContendedLocks;\n-  class VerifyThreadState;\n-\n- public:\n-  static void initialize();\n-\n-  static bool needs_resize();\n-  static bool resize_table(JavaThread* current);\n-\n- private:\n-  static inline bool fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current);\n-  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n-\n- public:\n-  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static void exit(oop object, BasicLock* lock, JavaThread* current);\n-\n-  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, Thread* current);\n-  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n-  static ObjectMonitor* inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n-  static ObjectMonitor* inflate_and_enter(oop object, BasicLock* lock, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n-\n-  static void deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n-\n-  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n-\n-  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n-\n-  static bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -86,1 +86,1 @@\n-      if (VM_Version::supports_recursive_lightweight_locking()) {\n+      if (VM_Version::supports_recursive_fast_locking()) {\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -90,1 +90,1 @@\n-  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_fast_locking()) {\n@@ -122,1 +122,1 @@\n-  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_fast_locking()) {\n@@ -148,1 +148,1 @@\n-  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_fast_locking()) {\n@@ -257,1 +257,1 @@\n-  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must exist in table\");\n+  assert(monitor == ObjectSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must exist in table\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -403,1 +402,1 @@\n-  \/\/ Used by LightweightSynchronizer::inflate_and_enter in deoptimization path to enter for another thread.\n+  \/\/ Used by ObjectSynchronizer::inflate_and_enter in deoptimization path to enter for another thread.\n@@ -844,1 +843,1 @@\n-    LightweightSynchronizer::deflate_monitor(current, obj, this);\n+    ObjectSynchronizer::deflate_monitor(current, obj, this);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-  \/\/ * Lightweight locking with UseObjectMonitorTable:\n+  \/\/ * Fast locking with UseObjectMonitorTable:\n@@ -166,1 +166,1 @@\n-  \/\/ * * Lightweight locking without UseObjectMonitorTable:\n+  \/\/ * * Fast locking without UseObjectMonitorTable:\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  assert(!UseObjectMonitorTable, \"Fast locking with OM table does not use header\");\n@@ -82,1 +82,1 @@\n-  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  assert(!UseObjectMonitorTable, \"Fast locking with OM table does not use header\");\n@@ -87,1 +87,1 @@\n-  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  assert(UseObjectMonitorTable, \"Only used by fast locking with OM table\");\n@@ -92,1 +92,1 @@\n-  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  assert(UseObjectMonitorTable, \"Only used by fast locking with OM table\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -116,1 +115,1 @@\n-              (object_monitor_table_work = LightweightSynchronizer::needs_resize())\n+              (object_monitor_table_work = ObjectSynchronizer::needs_resize())\n@@ -176,1 +175,1 @@\n-      LightweightSynchronizer::resize_table(jt);\n+      ObjectSynchronizer::resize_table(jt);\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2014,1 +2014,1 @@\n-  \/\/ C2_MacroAssembler::fast_unlock_lightweight() unlocked an inflated\n+  \/\/ C2_MacroAssembler::fast_unlock() unlocked an inflated\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -57,0 +56,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -61,0 +61,2 @@\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n@@ -284,1 +286,1 @@\n-  LightweightSynchronizer::initialize();\n+  ObjectSynchronizer::create_om_table();\n@@ -424,11 +426,0 @@\n-\/\/ -----------------------------------------------------------------------------\n-\/\/ Monitor Enter\/Exit\n-\n-void ObjectSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n-  \/\/ When called with locking_thread != Thread::current() some mechanism must synchronize\n-  \/\/ the locking_thread with respect to the current thread. Currently only used when\n-  \/\/ deoptimizing and re-locking locks. See Deoptimization::relock_objects\n-  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n-  return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n-}\n-\n@@ -454,1 +445,1 @@\n-    if (LightweightSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr) {\n+    if (ObjectSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr) {\n@@ -466,1 +457,1 @@\n-  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n+  monitor = ObjectSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n@@ -506,1 +497,1 @@\n-  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n+  monitor = ObjectSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n@@ -525,1 +516,1 @@\n-  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n+  monitor = ObjectSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n@@ -538,1 +529,1 @@\n-  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  ObjectMonitor* monitor = ObjectSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -552,1 +543,1 @@\n-  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  ObjectMonitor* monitor = ObjectSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -629,21 +620,0 @@\n-static intptr_t install_hash_code(Thread* current, oop obj) {\n-  assert(UseObjectMonitorTable, \"must be\");\n-\n-  markWord mark = obj->mark_acquire();\n-  for (;;) {\n-    intptr_t hash = mark.hash();\n-    if (hash != 0) {\n-      return hash;\n-    }\n-\n-    hash = get_next_hash(current, obj);\n-    const markWord old_mark = mark;\n-    const markWord new_mark = old_mark.copy_set_hash(hash);\n-\n-    mark = obj->cas_set_mark(new_mark, old_mark);\n-    if (old_mark == mark) {\n-      return hash;\n-    }\n-  }\n-}\n-\n@@ -651,6 +621,0 @@\n-  if (UseObjectMonitorTable) {\n-    \/\/ Since the monitor isn't in the object header, the hash can simply be\n-    \/\/ installed in the object header.\n-    return install_hash_code(current, obj);\n-  }\n-\n@@ -662,1 +626,3 @@\n-    if (mark.is_unlocked() || mark.is_fast_locked()) {\n+    \/\/ If UseObjectMonitorTable is set the hash can simply be installed in the\n+    \/\/ object header, since the monitor isn't in the object header.\n+    if (UseObjectMonitorTable || !mark.has_monitor()) {\n@@ -681,1 +647,2 @@\n-    } else if (mark.has_monitor()) {\n+    } else {\n+      assert(!mark.is_unlocked() && !mark.is_fast_locked(), \"invariant\");\n@@ -1212,1 +1179,1 @@\n-        assert(!LightweightSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n+        assert(!ObjectSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n@@ -1484,0 +1451,1188 @@\n+\n+\/\/ -----------------------------------------------------------------------------\n+\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n+class ObjectMonitorTable : AllStatic {\n+  struct Config {\n+    using Value = ObjectMonitor*;\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      return (uintx)value->hash();\n+    }\n+    static void* allocate_node(void* context, size_t size, Value const& value) {\n+      ObjectMonitorTable::inc_items_count();\n+      return AllocateHeap(size, mtObjectMonitor);\n+    };\n+    static void free_node(void* context, void* memory, Value const& value) {\n+      ObjectMonitorTable::dec_items_count();\n+      FreeHeap(memory);\n+    }\n+  };\n+  using ConcurrentTable = ConcurrentHashTable<Config, mtObjectMonitor>;\n+\n+  static ConcurrentTable* _table;\n+  static volatile size_t _items_count;\n+  static size_t _table_size;\n+  static volatile bool _resize;\n+\n+  class Lookup : public StackObj {\n+    oop _obj;\n+\n+   public:\n+    explicit Lookup(oop obj) : _obj(obj) {}\n+\n+    uintx get_hash() const {\n+      uintx hash = _obj->mark().hash();\n+      assert(hash != 0, \"should have a hash\");\n+      return hash;\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_refers_to(_obj);\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return false;\n+    }\n+  };\n+\n+  class LookupMonitor : public StackObj {\n+    ObjectMonitor* _monitor;\n+\n+   public:\n+    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+    uintx get_hash() const {\n+      return _monitor->hash();\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      return (*value) == _monitor;\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_is_dead();\n+    }\n+  };\n+\n+  static void inc_items_count() {\n+    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n+  }\n+\n+  static void dec_items_count() {\n+    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n+  }\n+\n+  static double get_load_factor() {\n+    size_t count = AtomicAccess::load(&_items_count);\n+    return (double)count \/ (double)_table_size;\n+  }\n+\n+  static size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n+  static size_t max_log_size() {\n+    \/\/ TODO[OMTable]: Evaluate the max size.\n+    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n+    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n+    \/\/                are definitely rounding errors (alignment).\n+    const size_t max_capacity = MaxHeapSize;\n+    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n+    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n+    const size_t log_max_objects = log2i_graceful(max_objects);\n+\n+    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n+  }\n+\n+  static size_t min_log_size() {\n+    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+    return 10;\n+  }\n+\n+  template<typename V>\n+  static size_t clamp_log_size(V log_size) {\n+    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+  }\n+\n+  static size_t initial_log_size() {\n+    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+    return clamp_log_size(estimate);\n+  }\n+\n+  static size_t grow_hint () {\n+    return ConcurrentTable::DEFAULT_GROW_HINT;\n+  }\n+\n+ public:\n+  static void create() {\n+    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n+    _items_count = 0;\n+    _table_size = table_size();\n+    _resize = false;\n+  }\n+\n+  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n+#ifdef ASSERT\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      bool has_monitor = obj->mark().has_monitor();\n+      assert(has_monitor == (monitor != nullptr),\n+          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n+          BOOL_TO_STR(has_monitor), p2i(monitor));\n+    }\n+#endif\n+  }\n+\n+  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n+    ObjectMonitor* result = nullptr;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    verify_monitor_get_result(obj, result);\n+    return result;\n+  }\n+\n+  static void try_notify_grow() {\n+    if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n+      AtomicAccess::store(&_resize, true);\n+      if (Service_lock->try_lock()) {\n+        Service_lock->notify();\n+        Service_lock->unlock();\n+      }\n+    }\n+  }\n+\n+  static bool should_shrink() {\n+    \/\/ Not implemented;\n+    return false;\n+  }\n+\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n+\n+  static bool should_grow() {\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+  }\n+\n+  static bool should_resize() {\n+    return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n+  }\n+\n+  template<typename Task, typename... Args>\n+  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+    if (task.prepare(current)) {\n+      log_trace(monitortable)(\"Started to %s\", task_name);\n+      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n+      while (task.do_task(current, args...)) {\n+        task.pause(current);\n+        {\n+          ThreadBlockInVM tbivm(current);\n+        }\n+        task.cont(current);\n+      }\n+      task.done(current);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool grow(JavaThread* current) {\n+    ConcurrentTable::GrowTask grow_task(_table);\n+    if (run_task(current, grow_task, \"Grow\")) {\n+      _table_size = table_size(current);\n+      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool clean(JavaThread* current) {\n+    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    auto is_dead = [&](ObjectMonitor** monitor) {\n+      return (*monitor)->object_is_dead();\n+    };\n+    auto do_nothing = [&](ObjectMonitor** monitor) {};\n+    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n+    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+  }\n+\n+  static bool resize(JavaThread* current) {\n+    LogTarget(Info, monitortable) lt;\n+    bool success = false;\n+\n+    if (should_grow()) {\n+      lt.print(\"Start growing with load factor %f\", get_load_factor());\n+      success = grow(current);\n+    } else {\n+      if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n+        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+      }\n+      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+      success = clean(current);\n+    }\n+\n+    AtomicAccess::store(&_resize, false);\n+\n+    return success;\n+  }\n+\n+  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+    \/\/ Enter the monitor into the concurrent hashtable.\n+    ObjectMonitor* result = monitor;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    bool grow;\n+    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+    verify_monitor_get_result(obj, result);\n+    if (grow) {\n+      try_notify_grow();\n+    }\n+    return result;\n+  }\n+\n+  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    return _table->remove(current, lookup_f);\n+  }\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    bool result = false;\n+    auto found_f = [&](ObjectMonitor** found) {\n+      result = true;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    return result;\n+  }\n+\n+  static void print_on(outputStream* st) {\n+    auto printer = [&] (ObjectMonitor** entry) {\n+       ObjectMonitor* om = *entry;\n+       oop obj = om->object_peek();\n+       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n+       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n+       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n+       st->cr();\n+       return true;\n+    };\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      _table->do_safepoint_scan(printer);\n+    } else {\n+      _table->do_scan(Thread::current(), printer);\n+    }\n+  }\n+};\n+\n+ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n+volatile size_t ObjectMonitorTable::_items_count = 0;\n+size_t ObjectMonitorTable::_table_size = 0;\n+volatile bool ObjectMonitorTable::_resize = false;\n+\n+ObjectMonitor* ObjectSynchronizer::get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted) {\n+  ObjectMonitor* monitor = get_monitor_from_table(current, object);\n+  if (monitor != nullptr) {\n+    *inserted = false;\n+    return monitor;\n+  }\n+\n+  ObjectMonitor* alloced_monitor = new ObjectMonitor(object);\n+  alloced_monitor->set_anonymous_owner();\n+\n+  \/\/ Try insert monitor\n+  monitor = add_monitor(current, alloced_monitor, object);\n+\n+  *inserted = alloced_monitor == monitor;\n+  if (!*inserted) {\n+    delete alloced_monitor;\n+  }\n+\n+  return monitor;\n+}\n+\n+static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n+  if (log_is_enabled(Trace, monitorinflation)) {\n+    ResourceMark rm(current);\n+    log_trace(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n+                                INTPTR_FORMAT \", type='%s' cause=%s\", p2i(object),\n+                                object->mark().value(), object->klass()->external_name(),\n+                                ObjectSynchronizer::inflate_cause_name(cause));\n+  }\n+}\n+\n+static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n+                                       const oop obj,\n+                                       ObjectSynchronizer::InflateCause cause) {\n+  assert(event != nullptr, \"invariant\");\n+  const Klass* monitor_klass = obj->klass();\n+  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n+  event->set_address((uintptr_t)(void*)obj);\n+  event->set_cause((u1)cause);\n+  event->commit();\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  EventJavaMonitorInflate event;\n+\n+  bool inserted;\n+  ObjectMonitor* monitor = get_or_insert_monitor_from_table(object, current, &inserted);\n+\n+  if (inserted) {\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+\n+    \/\/ The monitor has an anonymous owner so it is safe from async deflation.\n+    ObjectSynchronizer::_in_use_list.add(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+\/\/ Add the hashcode to the monitor to match the object and put it in the hashtable.\n+ObjectMonitor* ObjectSynchronizer::add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(obj == monitor->object(), \"must be\");\n+\n+  intptr_t hash = obj->mark().hash();\n+  assert(hash != 0, \"must be set when claiming the object monitor\");\n+  monitor->set_hash(hash);\n+\n+  return ObjectMonitorTable::monitor_put_get(current, monitor, obj);\n+}\n+\n+bool ObjectSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor->object_peek() == obj, \"must be, cleared objects are removed by is_dead\");\n+\n+  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n+}\n+\n+void ObjectSynchronizer::deflate_mark_word(oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n+\n+  while (mark.has_monitor()) {\n+    const markWord new_mark = mark.clear_lock_bits().set_unlocked();\n+    mark = obj->cas_set_mark(new_mark, mark);\n+  }\n+}\n+\n+void ObjectSynchronizer::create_om_table() {\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n+  ObjectMonitorTable::create();\n+}\n+\n+bool ObjectSynchronizer::needs_resize() {\n+  if (!UseObjectMonitorTable) {\n+    return false;\n+  }\n+  return ObjectMonitorTable::should_resize();\n+}\n+\n+bool ObjectSynchronizer::resize_table(JavaThread* current) {\n+  if (!UseObjectMonitorTable) {\n+    return true;\n+  }\n+  return ObjectMonitorTable::resize(current);\n+}\n+\n+class ObjectSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n+ private:\n+  oop _contended_oops[LockStack::CAPACITY];\n+  int _length;\n+\n+  void do_oop(oop* o) final {\n+    oop obj = *o;\n+    if (obj->mark_acquire().has_monitor()) {\n+      if (_length > 0 && _contended_oops[_length - 1] == obj) {\n+        \/\/ Recursive\n+        return;\n+      }\n+      _contended_oops[_length++] = obj;\n+    }\n+  }\n+\n+  void do_oop(narrowOop* o) final {\n+    ShouldNotReachHere();\n+  }\n+\n+ public:\n+  LockStackInflateContendedLocks() :\n+    _contended_oops(),\n+    _length(0) {};\n+\n+  void inflate(JavaThread* current) {\n+    assert(current == JavaThread::current(), \"must be\");\n+    current->lock_stack().oops_do(this);\n+    for (int i = 0; i < _length; i++) {\n+      ObjectSynchronizer::\n+        inflate_fast_locked_object(_contended_oops[i], ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+};\n+\n+void ObjectSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  \/\/ Make room on lock_stack\n+  if (lock_stack.is_full()) {\n+    \/\/ Inflate contended objects\n+    LockStackInflateContendedLocks().inflate(current);\n+    if (lock_stack.is_full()) {\n+      \/\/ Inflate the oldest object\n+      inflate_fast_locked_object(lock_stack.bottom(), ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+}\n+\n+class ObjectSynchronizer::CacheSetter : StackObj {\n+  JavaThread* const _thread;\n+  BasicLock* const _lock;\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(CacheSetter);\n+\n+ public:\n+  CacheSetter(JavaThread* thread, BasicLock* lock) :\n+    _thread(thread),\n+    _lock(lock),\n+    _monitor(nullptr) {}\n+\n+  ~CacheSetter() {\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        \/\/ If the monitor is already in the BasicLock cache then it is most\n+        \/\/ likely in the thread cache, do not set it again to avoid reordering.\n+        if (_monitor != _lock->object_monitor_cache()) {\n+          _thread->om_set_monitor_cache(_monitor);\n+          _lock->set_object_monitor_cache(_monitor);\n+        }\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n+    }\n+  }\n+\n+  void set_monitor(ObjectMonitor* monitor) {\n+    assert(_monitor == nullptr, \"only set once\");\n+    _monitor = monitor;\n+  }\n+\n+};\n+\n+\/\/ Reads first from the BasicLock cache then from the OMCache in the current thread.\n+\/\/ C2 fast-path may have put the monitor in the cache in the BasicLock.\n+inline static ObjectMonitor* read_caches(JavaThread* current, BasicLock* lock, oop object) {\n+  ObjectMonitor* monitor = lock->object_monitor_cache();\n+  if (monitor == nullptr) {\n+    monitor = current->om_get_from_monitor_cache(object);\n+  }\n+  return monitor;\n+}\n+\n+class ObjectSynchronizer::VerifyThreadState {\n+  bool _no_safepoint;\n+\n+ public:\n+  VerifyThreadState(JavaThread* locking_thread, JavaThread* current) : _no_safepoint(locking_thread != current) {\n+    assert(current == Thread::current(), \"must be\");\n+    assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"locking_thread may not run concurrently\");\n+    if (_no_safepoint) {\n+      DEBUG_ONLY(JavaThread::current()->inc_no_safepoint_count();)\n+    }\n+  }\n+  ~VerifyThreadState() {\n+    if (_no_safepoint){\n+      DEBUG_ONLY(JavaThread::current()->dec_no_safepoint_count();)\n+    }\n+  }\n+};\n+\n+inline bool ObjectSynchronizer::fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current) {\n+  markWord mark = obj->mark();\n+  while (mark.is_unlocked()) {\n+    ensure_lock_stack_space(current);\n+    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+    \/\/ Try to swing into 'fast-locked' state.\n+    markWord locked_mark = mark.set_fast_locked();\n+    markWord old_mark = mark;\n+    mark = obj->cas_set_mark(locked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool ObjectSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? FastLockingSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  markWord mark = obj->mark();\n+  const auto should_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    if (fast_lock_try_enter(obj, lock_stack, current)) return true;\n+  }\n+  return false;\n+}\n+\n+void ObjectSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  \/\/ When called with locking_thread != Thread::current() some mechanism must synchronize\n+  \/\/ the locking_thread with respect to the current thread. Currently only used when\n+  \/\/ deoptimizing and re-locking locks. See Deoptimization::relock_objects\n+  assert(locking_thread == Thread::current() || locking_thread->is_obj_deopt_suspend(), \"must be\");\n+\n+  assert(!UseObjectMonitorTable || lock->object_monitor_cache() == nullptr, \"must be cleared\");\n+  JavaThread* current = JavaThread::current();\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n+  }\n+\n+  LockStack& lock_stack = locking_thread->lock_stack();\n+\n+  ObjectMonitor* monitor = nullptr;\n+  if (lock_stack.contains(obj())) {\n+    monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    bool entered = monitor->enter_for(locking_thread);\n+    assert(entered, \"recursive ObjectMonitor::enter_for must succeed\");\n+  } else {\n+    do {\n+      \/\/ It is assumed that enter_for must enter on an object without contention.\n+      monitor = inflate_and_enter(obj(), lock, ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+      \/\/ But there may still be a race with deflation.\n+    } while (monitor == nullptr);\n+  }\n+\n+  assert(monitor != nullptr, \"ObjectSynchronizer::enter_for must succeed\");\n+  assert(!UseObjectMonitorTable || lock->object_monitor_cache() == nullptr, \"unused. already cleared\");\n+}\n+\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n+  }\n+\n+  CacheSetter cache_setter(current, lock);\n+\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n+  SpinYield spin_yield(0, 2);\n+  bool observed_deflation = false;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.is_full() && lock_stack.try_recursive_enter(obj())) {\n+    \/\/ Recursively fast locked\n+    return;\n+  }\n+\n+  if (lock_stack.contains(obj())) {\n+    ObjectMonitor* monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    bool entered = monitor->enter(current);\n+    assert(entered, \"recursive ObjectMonitor::enter must succeed\");\n+    cache_setter.set_monitor(monitor);\n+    return;\n+  }\n+\n+  while (true) {\n+    \/\/ Fast-locking does not use the 'lock' argument.\n+    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n+    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n+    \/\/ is worth it.\n+    \/\/ If deflation has been observed we also spin while deflation is ongoing.\n+    if (fast_lock_try_enter(obj(), lock_stack, current)) {\n+      return;\n+    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n+      return;\n+    }\n+\n+    if (observed_deflation) {\n+      spin_yield.wait();\n+    }\n+\n+    ObjectMonitor* monitor = inflate_and_enter(obj(), lock, ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    if (monitor != nullptr) {\n+      cache_setter.set_monitor(monitor);\n+      return;\n+    }\n+\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n+    observed_deflation = true;\n+  }\n+}\n+\n+void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+\n+  markWord mark = object->mark();\n+  assert(!mark.is_unlocked(), \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (mark.is_fast_locked()) {\n+    if (lock_stack.try_recursive_exit(object)) {\n+      \/\/ This is a recursive exit which succeeded\n+      return;\n+    }\n+    if (lock_stack.is_recursive(object)) {\n+      \/\/ Must inflate recursive locks if try_recursive_exit fails\n+      \/\/ This happens for un-structured unlocks, could potentially\n+      \/\/ fix try_recursive_exit to handle these.\n+      inflate_fast_locked_object(object, ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+\n+  while (mark.is_fast_locked()) {\n+    markWord unlocked_mark = mark.set_unlocked();\n+    markWord old_mark = mark;\n+    mark = object->cas_set_mark(unlocked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ CAS successful, remove from lock_stack\n+      size_t recursion = lock_stack.remove(object) - 1;\n+      assert(recursion == 0, \"Should not have unlocked here\");\n+      return;\n+    }\n+  }\n+\n+  assert(mark.has_monitor(), \"must be\");\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor;\n+  if (UseObjectMonitorTable) {\n+    monitor = read_caches(current, lock, object);\n+    if (monitor == nullptr) {\n+      monitor = get_monitor_from_table(current, object);\n+    }\n+  } else {\n+    monitor = ObjectSynchronizer::read_monitor(mark);\n+  }\n+  if (monitor->has_anonymous_owner()) {\n+    assert(current->lock_stack().contains(object), \"current must have object on its lock stack\");\n+    monitor->set_owner_from_anonymous(current);\n+    monitor->set_recursions(current->lock_stack().remove(object) - 1);\n+  }\n+\n+  monitor->exit(current);\n+}\n+\n+\/\/ ObjectSynchronizer::inflate_locked_or_imse is used to get an\n+\/\/ inflated ObjectMonitor* from contexts which require that, such as\n+\/\/ notify\/wait and jni_exit. Fast locking keeps the invariant that it\n+\/\/ only inflates if it is already locked by the current thread or the current\n+\/\/ thread is in the process of entering. To maintain this invariant we need to\n+\/\/ throw a java.lang.IllegalMonitorStateException before inflating if the\n+\/\/ current thread is not the owner.\n+ObjectMonitor* ObjectSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n+  JavaThread* current = THREAD;\n+\n+  for (;;) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked()) {\n+      \/\/ No lock, IMSE.\n+      THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                 \"current thread is not owner\", nullptr);\n+    }\n+\n+    if (mark.is_fast_locked()) {\n+      if (!current->lock_stack().contains(obj)) {\n+        \/\/ Fast locked by other thread, IMSE.\n+        THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                   \"current thread is not owner\", nullptr);\n+      } else {\n+        \/\/ Current thread owns the lock, must inflate\n+        return inflate_fast_locked_object(obj, cause, current, current);\n+      }\n+    }\n+\n+    assert(mark.has_monitor(), \"must be\");\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      if (monitor->has_anonymous_owner()) {\n+        LockStack& lock_stack = current->lock_stack();\n+        if (lock_stack.contains(obj)) {\n+          \/\/ Current thread owns the lock but someone else inflated it.\n+          \/\/ Fix owner and pop lock stack.\n+          monitor->set_owner_from_anonymous(current);\n+          monitor->set_recursions(lock_stack.remove(obj) - 1);\n+        } else {\n+          \/\/ Fast locked (and inflated) by other thread, or deflation in progress, IMSE.\n+          THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                     \"current thread is not owner\", nullptr);\n+        }\n+      }\n+      return monitor;\n+    }\n+  }\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, Thread* current) {\n+\n+  \/\/ The JavaThread* locking parameter requires that the locking_thread == JavaThread::current,\n+  \/\/ or is suspended throughout the call by some other mechanism.\n+  \/\/ Even with fast locking the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the fast locking algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the locking_thread owns the\n+    \/\/                   object lock, then we make the locking_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the locking_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->has_anonymous_owner() &&\n+          locking_thread != nullptr && locking_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(locking_thread);\n+        size_t removed = locking_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the locking_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the locking_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the locking_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = locking_thread != nullptr && locking_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by locking_thread.\n+        monitor->set_owner(locking_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_anonymous_owner();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = locking_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  VerifyThreadState vts(locking_thread, current);\n+  assert(locking_thread->lock_stack().contains(object), \"locking_thread must have object on its lock stack\");\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(object, cause, locking_thread, current);\n+  }\n+\n+  \/\/ Inflating requires a hash code\n+  ObjectSynchronizer::FastHashCode(current, object);\n+\n+  markWord mark = object->mark_acquire();\n+  assert(!mark.is_unlocked(), \"Cannot be unlocked\");\n+\n+  for (;;) {\n+    \/\/ Fetch the monitor from the table\n+    monitor = get_or_insert_monitor(object, current, cause);\n+\n+    \/\/ ObjectMonitors are always inserted as anonymously owned, this thread is\n+    \/\/ the current holder of the monitor. So unless the entry is stale and\n+    \/\/ contains a deflating monitor it must be anonymously owned.\n+    if (monitor->has_anonymous_owner()) {\n+      \/\/ The monitor must be anonymously owned if it was added\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n+      \/\/ New fresh monitor\n+      break;\n+    }\n+\n+    \/\/ If the monitor was not anonymously owned then we got a deflating monitor\n+    \/\/ from the table. We need to let the deflator make progress and remove this\n+    \/\/ entry before we are allowed to add a new one.\n+    os::naked_yield();\n+    assert(monitor->is_being_async_deflated(), \"Should be the reason\");\n+  }\n+\n+  \/\/ Set the mark word; loop to handle concurrent updates to other parts of the mark word\n+  while (mark.is_fast_locked()) {\n+    mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+  }\n+\n+  \/\/ Indicate that the monitor now has a known owner\n+  monitor->set_owner_from_anonymous(locking_thread);\n+\n+  \/\/ Remove the entry from the thread's lock stack\n+  monitor->set_recursions(locking_thread->lock_stack().remove(object) - 1);\n+\n+  if (locking_thread == current) {\n+    \/\/ Only change the thread local state of the current thread.\n+    locking_thread->om_set_monitor_cache(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_and_enter(oop object, BasicLock* lock, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  \/\/ Note: In some paths (deoptimization) the 'current' thread inflates and\n+  \/\/ enters the lock on behalf of the 'locking_thread' thread.\n+\n+  ObjectMonitor* monitor = nullptr;\n+\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(object, cause, locking_thread, current);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Try to get the monitor from the thread-local cache.\n+  \/\/ There's no need to use the cache if we are locking\n+  \/\/ on behalf of another thread.\n+  if (current == locking_thread) {\n+    monitor = read_caches(current, lock, object);\n+  }\n+\n+  \/\/ Get or create the monitor\n+  if (monitor == nullptr) {\n+    \/\/ Lightweight monitors require that hash codes are installed first\n+    ObjectSynchronizer::FastHashCode(locking_thread, object);\n+    monitor = get_or_insert_monitor(object, current, cause);\n+  }\n+\n+  if (monitor->try_enter(locking_thread)) {\n+    return monitor;\n+  }\n+\n+  \/\/ Holds is_being_async_deflated() stable throughout this function.\n+  ObjectMonitorContentionMark contention_mark(monitor);\n+\n+  \/\/\/ First handle the case where the monitor from the table is deflated\n+  if (monitor->is_being_async_deflated()) {\n+    \/\/ The MonitorDeflation thread is deflating the monitor. The locking thread\n+    \/\/ must spin until further progress has been made.\n+\n+    \/\/ Clear the BasicLock cache as it may contain this monitor.\n+    lock->clear_object_monitor_cache();\n+\n+    const markWord mark = object->mark_acquire();\n+\n+    if (mark.has_monitor()) {\n+      \/\/ Waiting on the deflation thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else if (mark.is_fast_locked()) {\n+      \/\/ Some other thread managed to fast-lock the lock, or this is a\n+      \/\/ recursive lock from the same thread; yield for the deflation\n+      \/\/ thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else {\n+      assert(mark.is_unlocked(), \"Implied\");\n+      \/\/ Retry immediately\n+    }\n+\n+    \/\/ Retry\n+    return nullptr;\n+  }\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous\n+    \/\/                   and the locking_thread owns the object\n+    \/\/                   lock, then we make the locking_thread\n+    \/\/                   the ObjectMonitor owner and remove the\n+    \/\/                   lock from the locking_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  neutral      - Inflate the object. Successful CAS is locked\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (monitor->has_anonymous_owner() && lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+      if (old_mark != mark) {\n+        \/\/ CAS failed\n+        continue;\n+      }\n+\n+      \/\/ Success! Return inflated monitor.\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: neutral (unlocked)\n+\n+    \/\/ Catch if the object's header is not neutral (not locked and\n+    \/\/ not marked is what we care about here).\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+    if (old_mark != mark) {\n+      \/\/ CAS failed\n+      continue;\n+    }\n+\n+    \/\/ Transitioned from unlocked to monitor means locking_thread owns the lock.\n+    monitor->set_owner_from_anonymous(locking_thread);\n+\n+    return monitor;\n+  }\n+\n+  if (current == locking_thread) {\n+    \/\/ One round of spinning\n+    if (monitor->spin_enter(locking_thread)) {\n+      return monitor;\n+    }\n+\n+    \/\/ Monitor is contended, take the time before entering to fix the lock stack.\n+    LockStackInflateContendedLocks().inflate(current);\n+  }\n+\n+  \/\/ enter can block for safepoints; clear the unhandled object oop\n+  PauseNoSafepointVerifier pnsv(&nsv);\n+  object = nullptr;\n+\n+  if (current == locking_thread) {\n+    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n+  } else {\n+    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n+  }\n+\n+  return monitor;\n+}\n+\n+void ObjectSynchronizer::deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n+  if (obj != nullptr) {\n+    deflate_mark_word(obj);\n+  }\n+  bool removed = remove_monitor(current, monitor, obj);\n+  if (obj != nullptr) {\n+    assert(removed, \"Should have removed the entry if obj was alive\");\n+  }\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::monitor_get(current, obj);\n+}\n+\n+bool ObjectSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::contains_monitor(current, monitor);\n+}\n+\n+bool ObjectSynchronizer::quick_enter_internal(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"must be\");\n+  assert(obj != nullptr, \"must be\");\n+  NoSafepointVerifier nsv;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (lock_stack.is_full()) {\n+    \/\/ Always go into runtime if the lock stack is full.\n+    return false;\n+  }\n+\n+  const markWord mark = obj->mark();\n+\n+#ifndef _LP64\n+  \/\/ Only for 32bit which has limited support for fast locking outside the runtime.\n+  if (lock_stack.try_recursive_enter(obj)) {\n+    \/\/ Recursive lock successful.\n+    return true;\n+  }\n+\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* monitor;\n+    if (UseObjectMonitorTable) {\n+      monitor = read_caches(current, lock, obj);\n+    } else {\n+      monitor = ObjectSynchronizer::read_monitor(mark);\n+    }\n+\n+    if (monitor == nullptr) {\n+      \/\/ Take the slow-path on a cache miss.\n+      return false;\n+    }\n+\n+    if (UseObjectMonitorTable) {\n+      \/\/ Set the monitor regardless of success.\n+      \/\/ Either we successfully lock on the monitor, or we retry with the\n+      \/\/ monitor in the slow path. If the monitor gets deflated, it will be\n+      \/\/ cleared, either by the CacheSetter if we fast lock in enter or in\n+      \/\/ inflate_and_enter when we see that the monitor is deflated.\n+      lock->set_object_monitor_cache(monitor);\n+    }\n+\n+    if (monitor->spin_enter(current)) {\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Slow-path.\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1204,"deletions":49,"binary":false,"changes":1253,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-  static inline void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static inline void exit(oop obj, BasicLock* lock, JavaThread* current);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n@@ -197,1 +197,0 @@\n-  friend class LightweightSynchronizer;\n@@ -211,0 +210,38 @@\n+\n+  static ObjectMonitor* get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted);\n+  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n+\n+  static ObjectMonitor* add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj);\n+  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n+\n+  static void deflate_mark_word(oop object);\n+\n+  static void ensure_lock_stack_space(JavaThread* current);\n+\n+  class CacheSetter;\n+  class LockStackInflateContendedLocks;\n+  class VerifyThreadState;\n+\n+  static void create_om_table();\n+\n+ public:\n+  static bool needs_resize();\n+  static bool resize_table(JavaThread* current);\n+\n+ private:\n+  static inline bool fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current);\n+  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n+\n+ public:\n+  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, Thread* current);\n+  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n+  static ObjectMonitor* inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+  static ObjectMonitor* inflate_and_enter(oop object, BasicLock* lock, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+\n+  static void deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n+\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n+\n+  static bool quick_enter_internal(oop obj, BasicLock* Lock, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -41,1 +40,1 @@\n-    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+    return ObjectSynchronizer::get_monitor_from_table(current, obj);\n@@ -45,6 +44,0 @@\n-inline void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n-\n-  LightweightSynchronizer::enter(obj, lock, current);\n-}\n-\n@@ -60,5 +53,1 @@\n-  return LightweightSynchronizer::quick_enter(obj, lock, current);\n-}\n-\n-inline void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  LightweightSynchronizer::exit(object, lock, current);\n+  return ObjectSynchronizer::quick_enter_internal(obj, lock, current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_fast_locking()) {\n@@ -133,1 +133,1 @@\n-  if (!VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_fast_locking()) {\n@@ -200,1 +200,1 @@\n-  const bool test_recursive = VM_Version::supports_recursive_lightweight_locking();\n+  const bool test_recursive = VM_Version::supports_recursive_fast_locking();\n@@ -262,1 +262,1 @@\n-  const bool test_recursive = VM_Version::supports_recursive_lightweight_locking();\n+  const bool test_recursive = VM_Version::supports_recursive_fast_locking();\n","filename":"test\/hotspot\/gtest\/runtime\/test_lockStack.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-                \/\/ looks like this [A, B]. Lightweight locking\n+                \/\/ looks like this [A, B]. Fast locking\n@@ -223,5 +223,4 @@\n-            \/\/ Legacy tolerates endless recursions. While testing\n-            \/\/ lightweight we don't go deeper than the size of the\n-            \/\/ lock stack, which in this test case will be filled\n-            \/\/ with a number of B-elements. See comment in runA()\n-            \/\/ above for more info.\n+            \/\/ Legacy tolerates endless recursions. While testing we\n+            \/\/ don't go deeper than the size of the lock stack, which\n+            \/\/ in this test case will be filled with a number of\n+            \/\/ B-elements. See comment in runA() above for more info.\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/TestRecursiveLocking.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Tests the interaction between recursive lightweight locking and\n+ * @summary Tests the interaction between recursive fast locking and\n@@ -96,2 +96,2 @@\n-        if (!WB.supportsRecursiveLightweightLocking()) {\n-            throw new SkippedException(\"Test only valid if lightweight locking supports recursion\");\n+        if (!WB.supportsRecursiveFastLocking()) {\n+            throw new SkippedException(\"Test only valid if fast locking supports recursion\");\n","filename":"test\/hotspot\/jtreg\/runtime\/lockStack\/TestLockStackCapacity.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n- * @comment Regression test for re-locking racing with deflation with lightweight locking.\n+ * @comment Regression test for re-locking racing with deflation with fast locking.\n@@ -240,1 +240,1 @@\n-        new EARelockingWithManyLightweightLocksTarget()                                     .run();\n+        new EARelockingWithManyFastLocksTarget()                                            .run();\n@@ -366,1 +366,1 @@\n-        new EARelockingWithManyLightweightLocks()                                     .run(this);\n+        new EARelockingWithManyFastLocks()                                            .run(this);\n@@ -1753,3 +1753,2 @@\n- * lightweight locked objects when the relocking is done. With\n- * lightweight the lock stack of the thread will be full because of\n- * this.\n+ * fast locked objects when the relocking is done, which means that the\n+ * lock stack of the thread will be full because of this.\n@@ -1758,1 +1757,1 @@\n-class EARelockingWithManyLightweightLocks extends EATestCaseBaseDebugger {\n+class EARelockingWithManyFastLocks extends EATestCaseBaseDebugger {\n@@ -1768,1 +1767,1 @@\n-class EARelockingWithManyLightweightLocksTarget extends EATestCaseBaseTarget {\n+class EARelockingWithManyFastLocksTarget extends EATestCaseBaseTarget {\n@@ -2263,1 +2262,1 @@\n- * not use recursive locking and exposed a bug in the lightweight-locking implementation.\n+ * not use recursive locking and exposed a bug in the fast-locking implementation.\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  public native boolean supportsRecursiveLightweightLocking();\n+  public native boolean supportsRecursiveFastLocking();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}