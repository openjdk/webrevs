{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -803,0 +803,1 @@\n+            case ERR -> null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8224922\n+ * @bug 8224922 8365689\n@@ -36,0 +36,2 @@\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.MemberSelectTree;\n@@ -52,0 +54,1 @@\n+import javax.lang.model.util.ElementFilter;\n@@ -595,0 +598,152 @@\n+    @Test \/\/JDK-8365689\n+    public void testUndefined(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {\n+                              requires undefined1; \/\/as module\n+                              exports undefined2; \/\/as package\n+                              exports test;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                              void t() {\n+                                  undefined3.call();\n+                                  this.undefined4();\n+                              }\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-XDshould-stop.at=FLOW\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UndefinedPrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                \"undefined1: \" + \"<null>\",\n+                \"undefined2: \" + \"<null>\",\n+                \"undefined3: \" + \"<null>\",\n+                \"undefined4: \" + \"<null>\"\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-XDshould-stop.at=FLOW\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UndefinedPrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                \"undefined1: \" + \"<null>\",\n+                \"undefined2: \" + \"<null>\",\n+                \"undefined3: \" + \"<null>\",\n+                \"undefined4: \" + \"<null>\"\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class UndefinedPrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                switch (currentElement.getKind()) {\n+                    case MODULE -> {\n+                        ElementFilter.exportsIn(((ModuleElement) currentElement).getDirectives())\n+                                     .stream()\n+                                     .map(ed -> ed.getPackage())\n+                                     .forEach(q::add);\n+                    }\n+                    case PACKAGE -> {\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                        continue;\n+                    }\n+                    default -> {}\n+                }\n+\n+                TreePath tp = trees.getPath(currentElement);\n+\n+                new TreePathScanner<>() {\n+                    @Override\n+                    public Object visitIdentifier(IdentifierTree node, Object p) {\n+                        if (node.getName().toString().startsWith(\"undefined\")) {\n+                            Element el = trees.getElement(getCurrentPath());\n+                            handleDeclaration(el);\n+                        }\n+                        return super.visitIdentifier(node, p);\n+                    }\n+\n+                    @Override\n+                    public Object visitMemberSelect(MemberSelectTree node, Object p) {\n+                        if (node.getIdentifier().toString().startsWith(\"undefined\")) {\n+                            Element el = trees.getElement(getCurrentPath());\n+                            handleDeclaration(el);\n+                        }\n+                        return super.visitMemberSelect(node, p);\n+                    }\n+                }.scan(tp, null);\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":157,"deletions":2,"binary":false,"changes":159,"status":"modified"}]}