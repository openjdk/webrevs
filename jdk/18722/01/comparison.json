{"files":[{"patch":"@@ -34,3 +34,3 @@\n-void CardTableRS::scan_old_to_young_refs(TenuredSpace* sp, HeapWord* saved_mark_word) {\n-  const MemRegion ur    = sp->used_region();\n-  const MemRegion urasm = MemRegion(sp->bottom(), saved_mark_word);\n+void CardTableRS::scan_old_to_young_refs(TenuredGeneration* tg, HeapWord* saved_mark_word) {\n+  const MemRegion ur    = tg->used_region();\n+  const MemRegion urasm = MemRegion(tg->space()->bottom(), saved_mark_word);\n@@ -46,1 +46,1 @@\n-    non_clean_card_iterate(sp, urasm, &cl);\n+    non_clean_card_iterate(tg, urasm, &cl);\n@@ -228,1 +228,1 @@\n-void CardTableRS::non_clean_card_iterate(TenuredSpace* sp,\n+void CardTableRS::non_clean_card_iterate(TenuredGeneration* tg,\n@@ -241,1 +241,1 @@\n-    HeapWord* result = sp->block_start_const(addr);\n+    HeapWord* result = tg->block_start(addr);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  void scan_old_to_young_refs(TenuredSpace* sp, HeapWord* saved_mark_word);\n+  void scan_old_to_young_refs(TenuredGeneration* tg, HeapWord* saved_mark_word);\n@@ -86,1 +86,1 @@\n-  void non_clean_card_iterate(TenuredSpace* sp,\n+  void non_clean_card_iterate(TenuredGeneration* tg,\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -591,0 +591,19 @@\n+\/\/ Very general, slow implementation.\n+HeapWord* DefNewGeneration::block_start_const(const ContiguousSpace* cs, const void* p) {\n+  assert(MemRegion(cs->bottom(), cs->end()).contains(p),\n+         \"p (\" PTR_FORMAT \") not in space [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+         p2i(p), p2i(cs->bottom()), p2i(cs->end()));\n+  if (p >= cs->top()) {\n+    return cs->top();\n+  } else {\n+    HeapWord* last = cs->bottom();\n+    HeapWord* cur = last;\n+    while (cur <= p) {\n+      last = cur;\n+      cur += cast_to_oop(cur)->size();\n+    }\n+    assert(oopDesc::is_oop(cast_to_oop(last)), PTR_FORMAT \" should be an object start\", p2i(last));\n+    return last;\n+  }\n+}\n+\n@@ -593,1 +612,1 @@\n-    return eden()->block_start_const(p);\n+    return block_start_const(eden(), p);\n@@ -596,1 +615,1 @@\n-    return from()->block_start_const(p);\n+    return block_start_const(from(), p);\n@@ -599,1 +618,1 @@\n-  return to()->block_start_const(p);\n+  return block_start_const(to(), p);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -158,0 +158,6 @@\n+  \/\/ If \"p\" is in the space, returns the address of the start of the\n+  \/\/ \"block\" that contains \"p\".  We say \"block\" instead of \"object\" since\n+  \/\/ some heaps may not pack objects densely; a chunk may either be an\n+  \/\/ object or a non-object.  If \"p\" is not in the space, return null.\n+  static HeapWord* block_start_const(const ContiguousSpace* cs, const void* p);\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -268,1 +268,17 @@\n-  return space()->block_start_const(p);\n+  return block_start_const(p);\n+}\n+\n+HeapWord* TenuredGeneration::block_start_const(const void* addr) const {\n+  HeapWord* cur_block = _bts->block_start_reaching_into_card(addr);\n+\n+  while (true) {\n+    HeapWord* next_block = cur_block + cast_to_oop(cur_block)->size();\n+    if (next_block > addr) {\n+      assert(cur_block <= addr, \"postcondition\");\n+      return cur_block;\n+    }\n+    cur_block = next_block;\n+    \/\/ Because the BOT is precise, we should never step into the next card\n+    \/\/ (i.e. crossing the card boundary).\n+    assert(!SerialBlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+  }\n@@ -272,1 +288,1 @@\n-  _rs->scan_old_to_young_refs(space(), saved_mark_word());\n+  _rs->scan_old_to_young_refs(this, saved_mark_word());\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+  HeapWord* block_start_const(const void* addr) const;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,19 +128,0 @@\n-\/\/ Very general, slow implementation.\n-HeapWord* ContiguousSpace::block_start_const(const void* p) const {\n-  assert(MemRegion(bottom(), end()).contains(p),\n-         \"p (\" PTR_FORMAT \") not in space [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(p), p2i(bottom()), p2i(end()));\n-  if (p >= top()) {\n-    return top();\n-  } else {\n-    HeapWord* last = bottom();\n-    HeapWord* cur = last;\n-    while (cur <= p) {\n-      last = cur;\n-      cur += cast_to_oop(cur)->size();\n-    }\n-    assert(oopDesc::is_oop(cast_to_oop(last)), PTR_FORMAT \" should be an object start\", p2i(last));\n-    return last;\n-  }\n-}\n-\n@@ -194,16 +175,0 @@\n-HeapWord* TenuredSpace::block_start_const(const void* addr) const {\n-  HeapWord* cur_block = _offsets->block_start_reaching_into_card(addr);\n-\n-  while (true) {\n-    HeapWord* next_block = cur_block + cast_to_oop(cur_block)->size();\n-    if (next_block > addr) {\n-      assert(cur_block <= addr, \"postcondition\");\n-      return cur_block;\n-    }\n-    cur_block = next_block;\n-    \/\/ Because the BOT is precise, we should never step into the next card\n-    \/\/ (i.e. crossing the card boundary).\n-    assert(!SerialBlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -172,6 +172,0 @@\n-  \/\/ If \"p\" is in the space, returns the address of the start of the\n-  \/\/ \"block\" that contains \"p\".  We say \"block\" instead of \"object\" since\n-  \/\/ some heaps may not pack objects densely; a chunk may either be an\n-  \/\/ object or a non-object.  If \"p\" is not in the space, return null.\n-  virtual HeapWord* block_start_const(const void* p) const;\n-\n@@ -200,2 +194,0 @@\n-  HeapWord* block_start_const(const void* addr) const override;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}