{"files":[{"patch":"@@ -35,0 +35,30 @@\n+\n+\/\/\/ This test runs on `internalProjection.json`-style files generated\n+\/\/\/ by NIST's ACVP Server. See [https:\/\/github.com\/usnistgov\/ACVP-Server].\n+\/\/\/\n+\/\/\/ The files are either put into the `data` directory or another\n+\/\/\/ directory specified by the `test.acvp.data` test property.\n+\/\/\/ The test walks through the directory recursively and looks for\n+\/\/\/ file names equals to or ending with `internalProjection.json` and\n+\/\/\/ runs test on them.\n+\/\/\/\n+\/\/\/ Set the `test.acvp.alg` test property to only test this algorithm.\n+\/\/\/\n+\/\/\/ Sample files can be downloaded from\n+\/\/\/ [https:\/\/github.com\/usnistgov\/ACVP-Server\/tree\/master\/gen-val\/json-files].\n+\/\/\/\n+\/\/\/ By default, the test uses system-preferred implementations.\n+\/\/\/ If you want to test on a specific provider, set the\n+\/\/\/ `test.acvp.provider` test property. The provider must be\n+\/\/\/ registered.\n+\/\/\/\n+\/\/\/ Tests for each algorithm must be compliant to its specification linked from\n+\/\/\/ [https:\/\/github.com\/usnistgov\/ACVP?tab=readme-ov-file#supported-algorithms].\n+\/\/\/\n+\/\/\/ Example:\n+\/\/\/ ```\n+\/\/\/ jtreg -Dtest.acvp.provider=SunJCE \\\n+\/\/\/       -Dtest.acvp.alg=ML-KEM \\\n+\/\/\/       -Dtest.acvp.data=\/path\/to\/json-files\/ \\\n+\/\/\/       -jdk:\/path\/to\/jdk Launcher.java\n+\/\/\/ ```\n@@ -44,3 +74,10 @@\n-        PROVIDER = provProp != null\n-                ? Security.getProvider(provProp)\n-                : null;\n+        if (provProp != null) {\n+            var p = Security.getProvider(provProp);\n+            if (p == null) {\n+                System.err.println(provProp + \" is not a registered provider name\");\n+                throw new RuntimeException(\"Cannot run test\");\n+            }\n+            PROVIDER = p;\n+        } else {\n+            PROVIDER = null;\n+        }\n@@ -51,29 +88,0 @@\n-        \/\/ This test runs on \"internalProjection.json\"-style files generated\n-        \/\/ by NIST's ACVP Server. See https:\/\/github.com\/usnistgov\/ACVP-Server.\n-        \/\/\n-        \/\/ The files are either put into the \"data\" directory or another\n-        \/\/ directory specified by the \"test.acvp.data\" test property.\n-        \/\/ The test walks through the directory recursively and looks for\n-        \/\/ file names equals to or ending with \"internalProjection.json\" and\n-        \/\/ runs test on them.\n-        \/\/\n-        \/\/ Set the \"test.acvp.alg\" test property to only test this algorithm.\n-        \/\/\n-        \/\/ Sample files can be downloaded from\n-        \/\/ https:\/\/github.com\/usnistgov\/ACVP-Server\/tree\/master\/gen-val\/json-files.\n-        \/\/\n-        \/\/ By default, the test uses system-preferred implementations.\n-        \/\/ If you want to test on a specific provider, set the\n-        \/\/ \"test.acvp.provider\" test property. The provider must be\n-        \/\/ registered.\n-        \/\/\n-        \/\/ Tests for each algorithm must be compliant to its specification linked from\n-        \/\/ https:\/\/github.com\/usnistgov\/ACVP?tab=readme-ov-file#supported-algorithms.\n-        \/\/\n-        \/\/ Example:\n-        \/\/\n-        \/\/ jtreg -Dtest.acvp.provider=SunJCE \\\n-        \/\/       -Dtest.acvp.alg=ML-KEM \\\n-        \/\/       -Dtest.acvp.data=\/path\/to\/json-files\/ \\\n-        \/\/       -jdk:\/path\/to\/jdk Launcher.java\n-\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":40,"deletions":32,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.security.FixedSecureRandom;\n@@ -26,1 +27,0 @@\n-import java.io.ByteArrayOutputStream;\n@@ -30,1 +30,2 @@\n-import java.util.HexFormat;\n+\n+import static jdk.test.lib.Utils.toByteArray;\n@@ -57,1 +58,1 @@\n-                g.initialize(np, new RandomSource(xeh(c.get(\"seed\").asString())));\n+                g.initialize(np, new FixedSecureRandom(toByteArray(c.get(\"seed\").asString())));\n@@ -61,2 +62,2 @@\n-                Asserts.assertEqualsByteArray(pk, xeh(c.get(\"pk\").asString()));\n-                Asserts.assertEqualsByteArray(sk, xeh(c.get(\"sk\").asString()));\n+                Asserts.assertEqualsByteArray(pk, toByteArray(c.get(\"pk\").asString()));\n+                Asserts.assertEqualsByteArray(sk, toByteArray(c.get(\"sk\").asString()));\n@@ -81,1 +82,1 @@\n-                    public byte[] getEncoded() { return xeh(c.get(\"sk\").asString()); }\n+                    public byte[] getEncoded() { return toByteArray(c.get(\"sk\").asString()); }\n@@ -83,1 +84,1 @@\n-                var sr = new RandomSource(det ? new byte[32] : xeh(c.get(\"rnd\").asString()));\n+                var sr = new FixedSecureRandom(det ? new byte[32] : toByteArray(c.get(\"rnd\").asString()));\n@@ -85,1 +86,1 @@\n-                s.update(xeh(c.get(\"message\").asString()));\n+                s.update(toByteArray(c.get(\"message\").asString()));\n@@ -87,1 +88,1 @@\n-                Asserts.assertEqualsByteArray(sig, xeh(c.get(\"signature\").asString()));\n+                Asserts.assertEqualsByteArray(sig, toByteArray(c.get(\"signature\").asString()));\n@@ -102,1 +103,1 @@\n-                public byte[] getEncoded() { return xeh(t.get(\"pk\").asString()); }\n+                public byte[] getEncoded() { return toByteArray(t.get(\"pk\").asString()); }\n@@ -108,2 +109,2 @@\n-                s.update(xeh(c.get(\"message\").asString()));\n-                var out = s.verify(xeh(c.get(\"signature\").asString()))\n+                s.update(toByteArray(c.get(\"message\").asString()));\n+                var out = s.verify(toByteArray(c.get(\"signature\").asString()))\n@@ -116,28 +117,0 @@\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    static byte[] xeh(String s) {\n-        return HexFormat.of().parseHex(s);\n-    }\n-\n-    static class RandomSource extends SecureRandom {\n-        private byte[] buffer;\n-        private int offset;\n-        public RandomSource(byte[]... data) {\n-            var os = new ByteArrayOutputStream();\n-            for (byte[] b : data) {\n-                os.writeBytes(b);\n-            }\n-            buffer = os.toByteArray();\n-            offset = 0;\n-        }\n-\n-        @Override\n-        public void nextBytes(byte[] bytes) {\n-            if (bytes.length > buffer.length - offset) {\n-                throw new IllegalStateException(\"Not enough bytes\");\n-            }\n-            System.arraycopy(buffer, offset, bytes, 0, bytes.length);\n-            offset += bytes.length;\n-        }\n-    }\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":13,"deletions":40,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.security.FixedSecureRandom;\n@@ -27,1 +28,0 @@\n-import java.io.ByteArrayOutputStream;\n@@ -31,1 +31,2 @@\n-import java.util.HexFormat;\n+\n+import static jdk.test.lib.Utils.toByteArray;\n@@ -57,2 +58,2 @@\n-                g.initialize(np, new RandomSource(\n-                        xeh(c.get(\"d\").asString()), xeh(c.get(\"z\").asString())));\n+                g.initialize(np, new FixedSecureRandom(\n+                        toByteArray(c.get(\"d\").asString()), toByteArray(c.get(\"z\").asString())));\n@@ -62,2 +63,2 @@\n-                Asserts.assertEqualsByteArray(pk, xeh(c.get(\"ek\").asString()));\n-                Asserts.assertEqualsByteArray(sk, xeh(c.get(\"dk\").asString()));\n+                Asserts.assertEqualsByteArray(pk, toByteArray(c.get(\"ek\").asString()));\n+                Asserts.assertEqualsByteArray(sk, toByteArray(c.get(\"dk\").asString()));\n@@ -83,1 +84,1 @@\n-                        public byte[] getEncoded() { return xeh(c.get(\"ek\").asString()); }\n+                        public byte[] getEncoded() { return toByteArray(c.get(\"ek\").asString()); }\n@@ -86,1 +87,1 @@\n-                            ek, new RandomSource(xeh(c.get(\"m\").asString())));\n+                            ek, new FixedSecureRandom(toByteArray(c.get(\"m\").asString())));\n@@ -88,1 +89,1 @@\n-                    Asserts.assertEqualsByteArray(enc.encapsulation(), xeh(c.get(\"c\").asString()));\n+                    Asserts.assertEqualsByteArray(enc.encapsulation(), toByteArray(c.get(\"c\").asString()));\n@@ -90,1 +91,1 @@\n-                            enc.key().getEncoded(), xeh(c.get(\"k\").asString()));\n+                            enc.key().getEncoded(), toByteArray(c.get(\"k\").asString()));\n@@ -97,1 +98,1 @@\n-                    public byte[] getEncoded() { return xeh(t.get(\"dk\").asString()); }\n+                    public byte[] getEncoded() { return toByteArray(t.get(\"dk\").asString()); }\n@@ -102,2 +103,2 @@\n-                    var k = d.decapsulate(xeh(c.get(\"c\").asString()));\n-                    Asserts.assertEqualsByteArray(k.getEncoded(), xeh(c.get(\"k\").asString()));\n+                    var k = d.decapsulate(toByteArray(c.get(\"c\").asString()));\n+                    Asserts.assertEqualsByteArray(k.getEncoded(), toByteArray(c.get(\"k\").asString()));\n@@ -109,28 +110,0 @@\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    static byte[] xeh(String s) {\n-        return HexFormat.of().parseHex(s);\n-    }\n-\n-    static class RandomSource extends SecureRandom {\n-        private byte[] buffer;\n-        private int offset;\n-        public RandomSource(byte[]... data) {\n-            var os = new ByteArrayOutputStream();\n-            for (byte[] b : data) {\n-                os.writeBytes(b);\n-            }\n-            buffer = os.toByteArray();\n-            offset = 0;\n-        }\n-\n-        @Override\n-        public void nextBytes(byte[] bytes) {\n-            if (bytes.length > buffer.length - offset) {\n-                throw new IllegalStateException(\"Not enough bytes\");\n-            }\n-            System.arraycopy(buffer, offset, bytes, 0, bytes.length);\n-            offset += bytes.length;\n-        }\n-    }\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":14,"deletions":41,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.util.HexFormat;\n+\n+import static jdk.test.lib.Utils.toByteArray;\n@@ -44,1 +45,1 @@\n-                        var msg = xeh(c.get(\"msg\").asString());\n+                        var msg = toByteArray(c.get(\"msg\").asString());\n@@ -48,1 +49,1 @@\n-                                    xeh(c.get(\"md\").asString()));\n+                                    toByteArray(c.get(\"md\").asString()));\n@@ -59,1 +60,1 @@\n-                        var SEED = xeh(c.get(\"msg\").asString());\n+                        var SEED = toByteArray(c.get(\"msg\").asString());\n@@ -72,1 +73,1 @@\n-                                            xeh(r.get(\"md\").asString()));\n+                                            toByteArray(r.get(\"md\").asString()));\n@@ -90,1 +91,1 @@\n-                                            xeh(r.get(\"md\").asString()));\n+                                            toByteArray(r.get(\"md\").asString()));\n@@ -103,1 +104,1 @@\n-                        var ct = xeh(lm.get(\"content\").asString());\n+                        var ct = toByteArray(lm.get(\"content\").asString());\n@@ -112,1 +113,1 @@\n-                                xeh(c.get(\"md\").asString()));\n+                                toByteArray(c.get(\"md\").asString()));\n@@ -136,4 +137,0 @@\n-\n-    static byte[] xeh(String s) {\n-        return HexFormat.of().parseHex(s);\n-    }\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/SHA_Test.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.FixedSecureRandom;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @summary ensure FixedSecureRandom works as expected\n+ *\/\n+public class FixedSecureRandomTest {\n+    public static void main(String[] args) throws Exception {\n+        var fsr = new FixedSecureRandom(new byte[] {1, 2, 3},\n+                new byte[] {4, 5, 6});\n+        var b1 = new byte[2];\n+        fsr.nextBytes(b1);\n+        Asserts.assertEqualsByteArray(b1, new byte[] {1, 2});\n+        Asserts.assertTrue(fsr.hasRemaining());\n+        fsr.nextBytes(b1);\n+        Asserts.assertEqualsByteArray(b1, new byte[] {3, 4});\n+        Asserts.assertTrue(fsr.hasRemaining());\n+        fsr.nextBytes(b1);\n+        Asserts.assertEqualsByteArray(b1, new byte[] {5, 6});\n+        Asserts.assertFalse(fsr.hasRemaining());\n+        Utils.runAndCheckException(() -> fsr.nextBytes(b1),\n+                IllegalStateException.class);\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/security\/FixedSecureRandomTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.SecureRandom;\n+\n+\/\/\/ A custom implementation of `SecureRandom` that outputs a\n+\/\/\/ predefined sequence of bytes.\n+\/\/\/\n+\/\/\/ The `FixedSecureRandom` class is designed for testing and\n+\/\/\/ controlled environments where predictable output is required.\n+\/\/\/ Upon creation, the class is initialized with a fixed byte array.\n+\/\/\/ Each call to `nextBytes()` will return these bytes in sequence,\n+\/\/\/ ensuring that the output matches the provided input exactly.\n+\/\/\/ An `IllegalStateException` will be thrown when the predefined\n+\/\/\/ bytes are exhausted.\n+public class FixedSecureRandom extends SecureRandom {\n+\n+    private byte[] buffer;\n+    private int offset;\n+\n+    \/\/ Multiple segments of ordered predefined bytes can be\n+    \/\/ provided for convenience. For example, ML-KEM.KeyGen\n+    \/\/ requires 2 blocks of 32-byte random data.\n+    public FixedSecureRandom(byte[]... data) {\n+        var os = new ByteArrayOutputStream();\n+        for (byte[] b : data) {\n+            os.writeBytes(b);\n+        }\n+        buffer = os.toByteArray();\n+        offset = 0;\n+    }\n+\n+    @Override\n+    public void nextBytes(byte[] bytes) {\n+        if (bytes.length > buffer.length - offset) {\n+            throw new IllegalStateException(\"Not enough bytes\");\n+        }\n+        System.arraycopy(buffer, offset, bytes, 0, bytes.length);\n+        offset += bytes.length;\n+    }\n+\n+    \/\/\/ {@return whether there are remaining used bytes}\n+    \/\/\/\n+    \/\/\/ This method is useful to detect whether an algorithm\n+    \/\/\/ implementation has indeed consumed the required number\n+    \/\/\/ of bytes correctly.\n+    public boolean hasRemaining() {\n+        return offset != buffer.length;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/FixedSecureRandom.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}