{"files":[{"patch":"@@ -24,0 +24,2 @@\n+#include \"gc\/z\/zAddress.inline.hpp\"\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -49,0 +52,90 @@\n+class ZColorStoreGoodOopClosure : public BasicOopIterateClosure {\n+public:\n+  virtual void do_oop(oop* p_) {\n+    volatile zpointer* const p = (volatile zpointer*)p_;\n+    const zpointer ptr = ZBarrier::load_atomic(p);\n+    const zaddress addr = ZPointer::uncolor(ptr);\n+    AtomicAccess::store(p, ZAddress::store_good(addr));\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+class ZLoadBarrierOopClosure : public BasicOopIterateClosure {\n+public:\n+  virtual void do_oop(oop* p) {\n+    ZBarrier::load_barrier_on_oop_field((zpointer*)p);\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+};\n+\n+void ZBarrierSet::load_barrier_all(oop src, size_t size) {\n+  check_is_valid_zaddress(src);\n+\n+  ZLoadBarrierOopClosure cl;\n+  ZIterator::oop_iterate(src, &cl);\n+}\n+\n+void ZBarrierSet::color_store_good_all(oop dst, size_t size) {\n+  check_is_valid_zaddress(dst);\n+  assert(dst->is_typeArray() || ZHeap::heap()->is_young(to_zaddress(dst)), \"ZColorStoreGoodOopClosure is only valid for young objects\");\n+\n+  ZColorStoreGoodOopClosure cl_sg;\n+  ZIterator::oop_iterate(dst, &cl_sg);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::load_barrier_on_weak_oop_field_preloaded(p, o);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o) {\n+  return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(p, o);\n+}\n+\n+void ZBarrierSet::store_barrier_on_heap_oop_field(volatile zpointer* p, bool heal) {\n+  ZBarrier::store_barrier_on_heap_oop_field(p, heal);\n+}\n+\n+void ZBarrierSet::no_keep_alive_store_barrier_on_heap_oop_field(volatile zpointer* p) {\n+  ZBarrier::no_keep_alive_store_barrier_on_heap_oop_field(p);\n+}\n+\n+void ZBarrierSet::store_barrier_on_native_oop_field(volatile zpointer* p, bool heal) {\n+  ZBarrier::store_barrier_on_native_oop_field(p, heal);\n+}\n+\n+zaddress ZBarrierSet::load_barrier_on_oop_field(volatile zpointer* p) {\n+  return ZBarrier::load_barrier_on_oop_field(p);\n+}\n+\n+void ZBarrierSet::clone_obj_array(objArrayOop src_obj, objArrayOop dst_obj) {\n+  volatile zpointer* src = (volatile zpointer*)src_obj->base();\n+  volatile zpointer* dst = (volatile zpointer*)dst_obj->base();\n+  const int length = src_obj->length();\n+\n+  for (const volatile zpointer* const end = src + length; src < end; src++, dst++) {\n+    zaddress elem = ZBarrier::load_barrier_on_oop_field(src);\n+    \/\/ We avoid healing here because the store below colors the pointer store good,\n+    \/\/ hence avoiding the cost of a CAS.\n+    ZBarrier::store_barrier_on_heap_oop_field(dst, false \/* heal *\/);\n+    AtomicAccess::store(dst, ZAddress::store_good(elem));\n+  }\n+}\n+\n@@ -156,14 +249,0 @@\n-void ZBarrierSet::clone_obj_array(objArrayOop src_obj, objArrayOop dst_obj) {\n-  volatile zpointer* src = (volatile zpointer*)src_obj->base();\n-  volatile zpointer* dst = (volatile zpointer*)dst_obj->base();\n-  const int length = src_obj->length();\n-\n-  for (const volatile zpointer* const end = src + length; src < end; src++, dst++) {\n-    zaddress elem = ZBarrier::load_barrier_on_oop_field(src);\n-    \/\/ We avoid healing here because the store below colors the pointer store good,\n-    \/\/ hence avoiding the cost of a CAS.\n-    ZBarrier::store_barrier_on_heap_oop_field(dst, false \/* heal *\/);\n-    AtomicAccess::store(dst, ZAddress::store_good(elem));\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":93,"deletions":14,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -36,0 +36,17 @@\n+  static void load_barrier_all(oop src, size_t size);\n+  static void color_store_good_all(oop dst, size_t size);\n+\n+  static zaddress load_barrier_on_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress no_keep_alive_load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress load_barrier_on_weak_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+  static zaddress load_barrier_on_phantom_oop_field_preloaded(volatile zpointer* p, zpointer o);\n+\n+  static void store_barrier_on_heap_oop_field(volatile zpointer* p, bool heal);\n+  static void no_keep_alive_store_barrier_on_heap_oop_field(volatile zpointer* p);\n+  static void store_barrier_on_native_oop_field(volatile zpointer* p, bool heal);\n+\n+  static zaddress load_barrier_on_oop_field(volatile zpointer* p);\n+\n+  static void clone_obj_array(objArrayOop src, objArrayOop dst);\n+\n@@ -42,2 +59,0 @@\n-  static void clone_obj_array(objArrayOop src, objArrayOop dst);\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n-#include \"gc\/z\/zIterator.inline.hpp\"\n+#include \"gc\/z\/zHeap.hpp\"\n@@ -34,1 +33,1 @@\n-#include \"memory\/iterator.inline.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n@@ -71,1 +70,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -73,1 +72,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -76,1 +75,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -80,1 +79,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -82,1 +81,1 @@\n-      return ZBarrier::load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -85,1 +84,1 @@\n-      return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -100,1 +99,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -102,1 +101,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -105,1 +104,1 @@\n-      return ZBarrier::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::no_keep_alive_load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -109,1 +108,1 @@\n-      return ZBarrier::load_barrier_on_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_oop_field_preloaded(p, o);\n@@ -111,1 +110,1 @@\n-      return ZBarrier::load_barrier_on_weak_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_weak_oop_field_preloaded(p, o);\n@@ -114,1 +113,1 @@\n-      return ZBarrier::load_barrier_on_phantom_oop_field_preloaded(p, o);\n+      return ZBarrierSet::load_barrier_on_phantom_oop_field_preloaded(p, o);\n@@ -129,1 +128,1 @@\n-    ZBarrier::store_barrier_on_heap_oop_field(p, true \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_heap_oop_field(p, true \/* heal *\/);\n@@ -138,1 +137,1 @@\n-    ZBarrier::store_barrier_on_heap_oop_field(p, false \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_heap_oop_field(p, false \/* heal *\/);\n@@ -145,1 +144,1 @@\n-    ZBarrier::no_keep_alive_store_barrier_on_heap_oop_field(p);\n+    ZBarrierSet::no_keep_alive_store_barrier_on_heap_oop_field(p);\n@@ -152,1 +151,1 @@\n-    ZBarrier::store_barrier_on_native_oop_field(p, true \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_native_oop_field(p, true \/* heal *\/);\n@@ -161,1 +160,1 @@\n-    ZBarrier::store_barrier_on_native_oop_field(p, false \/* heal *\/);\n+    ZBarrierSet::store_barrier_on_native_oop_field(p, false \/* heal *\/);\n@@ -328,1 +327,1 @@\n-  return ZBarrier::load_barrier_on_oop_field(src);\n+  return ZBarrierSet::load_barrier_on_oop_field(src);\n@@ -406,25 +405,0 @@\n-class ZColorStoreGoodOopClosure : public BasicOopIterateClosure {\n-public:\n-  virtual void do_oop(oop* p_) {\n-    volatile zpointer* const p = (volatile zpointer*)p_;\n-    const zpointer ptr = ZBarrier::load_atomic(p);\n-    const zaddress addr = ZPointer::uncolor(ptr);\n-    AtomicAccess::store(p, ZAddress::store_good(addr));\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-class ZLoadBarrierOopClosure : public BasicOopIterateClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    ZBarrier::load_barrier_on_oop_field((zpointer*)p);\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n@@ -447,2 +421,1 @@\n-  ZLoadBarrierOopClosure cl;\n-  ZIterator::oop_iterate(src, &cl);\n+  ZBarrierSet::load_barrier_all(src, size);\n@@ -453,2 +426,0 @@\n-  assert(dst->is_typeArray() || ZHeap::heap()->is_young(to_zaddress(dst)), \"ZColorStoreGoodOopClosure is only valid for young objects\");\n-\n@@ -456,2 +427,1 @@\n-  ZColorStoreGoodOopClosure cl_sg;\n-  ZIterator::oop_iterate(dst, &cl_sg);\n+  ZBarrierSet::color_store_good_all(dst, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":22,"deletions":52,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"gc\/z\/zGeneration.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zGranuleMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zRangeRegistry.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+#include \"gc\/z\/zHeap.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-#if INCLUDE_ZGC\n-#include \"gc\/z\/zBarrier.inline.hpp\"\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}