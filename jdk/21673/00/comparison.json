{"files":[{"patch":"@@ -334,0 +334,3 @@\n+        if (!canSeek())\n+            return super.readAllBytes();\n+\n@@ -385,0 +388,3 @@\n+        if (!canSeek())\n+            return super.readNBytes(len);\n+\n@@ -421,1 +427,1 @@\n-        if (out instanceof FileOutputStream fos) {\n+        if (out instanceof FileOutputStream fos && canSeek()) {\n@@ -474,1 +480,4 @@\n-        return skip0(n);\n+        if (canSeek())\n+            return skip0(n);\n+\n+        return super.skip(n);\n@@ -606,0 +615,9 @@\n+    \/**\n+     * Whether seeking is supported. Seeking is used in the implementations of\n+     * position0() and skip0().\n+     *\/\n+    private boolean canSeek() {\n+        return canSeek0(fd);\n+    }\n+    private native boolean canSeek0(FileDescriptor fd);\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,6 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileInputStream_canSeek0(JNIEnv *env, jobject this, jobject fdo) {\n+    FD fd = getFD(env, this, fis_fd);\n+    return IO_CanSeek(env, fd);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/FileInputStream.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -267,0 +267,13 @@\n+\n+jboolean\n+handleCanSeek(JNIEnv* env, FD fd)\n+{\n+    struct stat fbuf;\n+    if (fstat(fd, &fbuf) == -1)\n+        JNU_ThrowIOExceptionWithLastError(env, \"fstat failed\");\n+\n+    if (S_ISREG(fbuf.st_mode) || S_ISDIR(fbuf.st_mode) || S_ISLNK(fbuf.st_mode))\n+        return JNI_TRUE;\n+\n+    return JNI_FALSE;\n+}\n","filename":"src\/java.base\/unix\/native\/libjava\/io_util_md.c","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+jboolean handleCanSeek(JNIEnv* env, FD fd);\n@@ -69,0 +70,1 @@\n+#define IO_CanSeek handleCanSeek\n","filename":"src\/java.base\/unix\/native\/libjava\/io_util_md.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -598,0 +598,6 @@\n+\n+jboolean\n+handleCanSeek(JNIEnv* env, FD fd)\n+{\n+    return JNI_TRUE;\n+}\n","filename":"src\/java.base\/windows\/native\/libjava\/io_util_md.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+jboolean handleCanSeek(JNIEnv* env, FD fd);\n@@ -85,0 +86,1 @@\n+#define IO_CanSeek handleCanSeek\n","filename":"src\/java.base\/windows\/native\/libjava\/io_util_md.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8341666\n+ * @summary Test of FileInputStream reading from stdin and a named pipe\n+ * @requires os.family != \"windows\"\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED PseudoDevice\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import jdk.test.lib.Platform;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class PseudoDevice {\n+\n+    private static final String PIPE = \"pipe\";\n+    private static final File PIPE_FILE = new File(PIPE);\n+    private static final String SENTENCE =\n+        \"Rien n'est permis mais tout est possible\";\n+\n+    private static class mkfifo {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.ADDRESS,\n+            ValueLayout.JAVA_SHORT\n+        );\n+\n+        public static final MemorySegment ADDR;\n+        static {\n+            Linker linker = Linker.nativeLinker();\n+            SymbolLookup stdlib = linker.defaultLookup();\n+            ADDR = stdlib.find(\"mkfifo\").orElseThrow();\n+        }\n+\n+        public static final MethodHandle HANDLE =\n+            Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    public static int mkfifo(MemorySegment x0, short x1) {\n+        var mh$ = mkfifo.HANDLE;\n+        try {\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+\n+    private static Thread createWriteThread() {\n+        Thread t = new Thread(\n+            new Runnable() {\n+                public void run() {\n+                    try (FileOutputStream fos = new FileOutputStream(PIPE);) {\n+                        fos.write(SENTENCE.getBytes());\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        );\n+        t.start();\n+        return t;\n+    }\n+\n+    @BeforeAll\n+    static void before() throws InterruptedException, IOException {\n+        if (Platform.isWindows())\n+            return;\n+\n+        PIPE_FILE.delete();\n+        try (var newArena = Arena.ofConfined()) {\n+            var addr = newArena.allocateFrom(PIPE);\n+            short mode = 0666;\n+            assertEquals(0, mkfifo(addr, mode));\n+        }\n+        if (!PIPE_FILE.exists())\n+            throw new RuntimeException(\"Failed to create \" + PIPE);\n+    }\n+\n+    @AfterAll\n+    static void after() throws IOException {\n+        if (Platform.isWindows())\n+            return;\n+\n+        PIPE_FILE.delete();\n+    }\n+\n+    \/**\n+     * Tests that new FileInputStream(File).available() does not throw\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void availableStdin() throws IOException {\n+        File stdin = new File(\"\/dev\", \"stdin\");\n+        if (stdin.exists()) {\n+            try (InputStream s = new FileInputStream(stdin);) {\n+                s.available();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that new FileInputStream(File).skip(0) does not throw\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void skipStdin() throws IOException {\n+        File stdin = new File(\"\/dev\", \"stdin\");\n+        if (stdin.exists()) {\n+            try (InputStream s = new FileInputStream(stdin);) {\n+                s.skip(0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests new FileInputStream(File).readAllBytes().\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void readAllBytes() throws InterruptedException, IOException {\n+        Thread t = createWriteThread();\n+        try (InputStream in = new FileInputStream(PIPE)) {\n+            String s = new String(in.readAllBytes());\n+            System.out.println(s);\n+            assertEquals(SENTENCE, s);\n+        } finally {\n+            t.join();\n+        }\n+    }\n+\n+    \/**\n+     * Tests new FileInputStream(File).readNBytes(byte[],int,int).\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void readNBytesNoOverride() throws InterruptedException, IOException {\n+        Thread t = createWriteThread();\n+        try (InputStream in = new FileInputStream(PIPE)) {\n+            final int offset = 11;\n+            final int length = 17;\n+            assert length <= SENTENCE.length();\n+            byte[] b = new byte[offset + length];\n+            int n = in.readNBytes(b, offset, length);\n+            String s = new String(b, offset, length);\n+            System.out.println(s);\n+            assertEquals(SENTENCE.substring(0, length), s);\n+        } finally {\n+            t.join();\n+        }\n+    }\n+\n+    \/**\n+     * Tests new FileInputStream(File).readNBytes(int).\n+     *\/\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    void readNBytesOverride() throws InterruptedException, IOException {\n+        Thread t = createWriteThread();\n+        try (InputStream in = new FileInputStream(PIPE)) {\n+            final int length = 17;\n+            assert length <= SENTENCE.length();\n+            byte[] b = in.readNBytes(length);\n+            String s = new String(b);\n+            System.out.println(s);\n+            assertEquals(SENTENCE.substring(0, length), s);\n+        } finally {\n+            t.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/FileInputStream\/PseudoDevice.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}