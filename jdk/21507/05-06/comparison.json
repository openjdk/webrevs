{"files":[{"patch":"@@ -548,2 +548,1 @@\n-     *    activation. Emptiness must be conservatively approximated\n-     *    (by checking preceeding queue array slot, not inidices)\n+     *    activation. Emptiness must be conservatively approximated,\n@@ -557,7 +556,13 @@\n-     *    producer, each worker taking its first (since the last\n-     *    activation) task from a queue should propagate a signal if\n-     *    there are more tasks in that queue. This is equivalent to,\n-     *    but generally faster than, arranging the stealer take\n-     *    multiple tasks, re-pushing one or more on its own queue, and\n-     *    signalling (because its queue is empty), also resulting in\n-     *    logarithmic full activation time.\n+     *    producer, each worker taking a task from a queue should\n+     *    propagate a signal if there are more tasks in that\n+     *    queue. This is equivalent to, but generally faster than,\n+     *    arranging the stealer take multiple tasks, re-pushing one or\n+     *    more on its own queue, and signalling (because its queue is\n+     *    empty), also resulting in logarithmic full activation\n+     *    time. If tasks do not not engage in unbounded loops based on\n+     *    the actions of other workers with unknown dependencies loop,\n+     *    this form of proagation can be limited to one signal per\n+     *    activation (phase change). We distinguish the cases by\n+     *    further signalling only if the task is an InterruptibleTask\n+     *    (see below), which are the only supported forms of task that\n+     *    may do so.\n@@ -613,3 +618,6 @@\n-     * signal during deactivation.  Because idle workers are often not\n-     * yet blocked (parked), we use a WorkQueue field to advertise\n-     * that a waiter actually needs unparking upon signal.\n+     * (external) signal during deactivation. To reduce false-alarm\n+     * reactivations while doing so, we scan multiple times\n+     * (analogously to method quiescent()) before trying to\n+     * reactivate.  Because idle workers are often not yet blocked\n+     * (parked), we use a WorkQueue field to advertise that a waiter\n+     * actually needs unparking upon signal.\n@@ -1271,2 +1279,1 @@\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                task != null) {                             \/\/ else disabled\n+            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n@@ -1283,2 +1290,1 @@\n-                int d = 1;\n-                if (!internal) {\n+                if (!internal)\n@@ -1286,3 +1292,0 @@\n-                    if (task.getClass().getSuperclass() == interruptibleTaskClass)\n-                        d = 2;\n-                }\n@@ -1291,1 +1294,2 @@\n-                else if ((room == 0 || a[m & (s - d)] == null) && pool != null)\n+                else if ((room == 0 || s == base || a[m & (s - 1)] == null) &&\n+                         pool != null)\n@@ -1821,1 +1825,1 @@\n-            reactivate(true);\n+            releaseAll();\n@@ -1905,1 +1909,1 @@\n-     * Releases one or all waiting workers\n+     * Releases all waiting workers. Called only during shutdown.\n@@ -1909,1 +1913,1 @@\n-    private long reactivate(boolean all) {\n+    private long releaseAll() {\n@@ -1922,2 +1926,0 @@\n-                if (!all)\n-                    break;\n@@ -1991,4 +1993,4 @@\n-                        for (int m = cap - 1, pb = -1, b; ;) {\n-                            long k = slotOffset((b = q.base) & m);\n-                            ForkJoinTask<?> t = (ForkJoinTask<?>)\n-                                U.getReferenceAcquire(a, k);\n+                        for (int m = cap - 1, pb = -1;;) { \/\/ track progress\n+                            ForkJoinTask<?> t; int b; long k;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset(m & (b = q.base)));\n@@ -2000,1 +2002,1 @@\n-                                if (a[b & m] == null) {\n+                                if (U.getReference(a, k) == null) {\n@@ -2015,4 +2017,3 @@\n-                                if ((!propagated ||\n-                                     t.getClass().getSuperclass() ==\n-                                     interruptibleTaskClass) &&\n-                                    next != null) {\n+                                if (next != null &&\n+                                    (!propagated || t.getClass().getSuperclass() ==\n+                                     interruptibleTaskClass)) {\n@@ -2052,1 +2053,1 @@\n-        int ac =  (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n+        int ac = (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n@@ -2057,1 +2058,1 @@\n-        int checks = (ac <= 1) ? ac + 1 : 3;  \/\/ reactivation threshold\n+        int prechecks = Math.min(ac, 2);      \/\/ reactivation threshold\n@@ -2064,5 +2065,6 @@\n-            Thread.onSpinWait();              \/\/ interleave spins and rechecks\n-            if ((k & 1) == 0 && (q = qs[k & (n - 1)]) != null &&\n-                (a = q.array) != null && (cap = a.length) > 0 &&\n-                a[q.base & (cap - 1)] != null && --checks <= 0 &&\n-                ctl == qc && compareAndSetCtl(qc, pc))\n+            if ((k & 1) != 0)\n+                Thread.onSpinWait();          \/\/ interleave spins and rechecks\n+            else if ((q = qs[k & (n - 1)]) != null &&\n+                     (a = q.array) != null && (cap = a.length) > 0 &&\n+                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n+                     ctl == qc && compareAndSetCtl(qc, pc))\n@@ -2745,1 +2747,1 @@\n-            if ((e & STOP) != 0L && (reactivate(true) & RC_MASK) > 0L && now)\n+            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"}]}