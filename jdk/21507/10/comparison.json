{"files":[{"patch":"@@ -265,4 +265,1 @@\n-     * ordered writes of various kinds for updates, but usually use\n-     * explicit load fences for reads, to cover access of several\n-     * fields of possibly several objects without further constraining\n-     * read-by-read ordering.\n+     * ordered writes of various kinds for accesses when required.\n@@ -308,2 +305,1 @@\n-     *    CAS succeeds, but uses an explicit acquire fence to support\n-     *    the following rechecks even if the CAS is not attempted.\n+     *    CAS succeeds.\n@@ -552,6 +548,5 @@\n-     *    activation. Emptiness must be conservatively approximated\n-     *    (by checking if there is apparently at most one existing\n-     *    task) which may result in unnecessary signals.  Also, to\n-     *    reduce resource usages in some cases, at the expense of\n-     *    slower startup in others, activation of an idle thread is\n-     *    preferred over creating a new one, here and elsewhere.\n+     *    activation. Emptiness must be conservatively approximated,\n+     *    which may result in unnecessary signals.  Also, to reduce\n+     *    resource usages in some cases, at the expense of slower\n+     *    startup in others, activation of an idle thread is preferred\n+     *    over creating a new one, here and elsewhere.\n@@ -561,7 +556,13 @@\n-     *    producer, each worker taking its first (since the last\n-     *    activation) task from a queue should propagate a signal if\n-     *    there are more tasks in that queue. This is equivalent to,\n-     *    but generally faster than, arranging the stealer take\n-     *    multiple tasks, re-pushing one or more on its own queue, and\n-     *    signalling (because its queue is empty), also resulting in\n-     *    logarithmic full activation time.\n+     *    producer, each worker taking a task from a queue should\n+     *    propagate a signal if there are more tasks in that\n+     *    queue. This is equivalent to, but generally faster than,\n+     *    arranging the stealer take multiple tasks, re-pushing one or\n+     *    more on its own queue, and signalling (because its queue is\n+     *    empty), also resulting in logarithmic full activation\n+     *    time. If tasks do not not engage in unbounded loops based on\n+     *    the actions of other workers with unknown dependencies loop,\n+     *    this form of proagation can be limited to one signal per\n+     *    activation (phase change). We distinguish the cases by\n+     *    further signalling only if the task is an InterruptibleTask\n+     *    (see below), which are the only supported forms of task that\n+     *    may do so.\n@@ -617,3 +618,6 @@\n-     * signal during deactivation.  Because idle workers are often not\n-     * yet blocked (parked), we use a WorkQueue field to advertise\n-     * that a waiter actually needs unparking upon signal.\n+     * (external) signal during deactivation. To reduce false-alarm\n+     * reactivations while doing so, we scan multiple times\n+     * (analogously to method quiescent()) before trying to\n+     * reactivate.  Because idle workers are often not yet blocked\n+     * (parked), we use a WorkQueue field to advertise that a waiter\n+     * actually needs unparking upon signal.\n@@ -910,4 +914,2 @@\n-     * Currently, arrays for workers are initialized to be just large\n-     * enough to avoid resizing in most tree-structured tasks, but\n-     * larger for external queues where both false-sharing problems\n-     * and the need for resizing are more common.  (Maintenance note:\n+     * Currently, arrays are initialized to be just large enough to\n+     * avoid resizing in most tree-structured tasks. (Maintenance note:\n@@ -1002,6 +1004,0 @@\n-    \/**\n-     * Initial capacity of work-stealing queue array for external queues.\n-     * Must be a power of two, at least 2. See above.\n-     *\/\n-    static final int INITIAL_EXTERNAL_QUEUE_CAPACITY = 1 << 9;\n-\n@@ -1252,3 +1248,1 @@\n-            array = new ForkJoinTask<?>[owner == null ?\n-                                        INITIAL_EXTERNAL_QUEUE_CAPACITY :\n-                                        INITIAL_QUEUE_CAPACITY];\n+            array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -1300,4 +1294,6 @@\n-                else if ((room == 0 ||\n-                          a[m & (s - 2)] == null) && \/\/ at most one existing task\n-                         pool != null)\n-                    pool.signalWork();\n+                if ((room == 0 ||        \/\/ pad for InterruptibleTasks\n+                     a[m & (s - ((internal || task == null ||\n+                                  task.getClass().getSuperclass() !=\n+                                  interruptibleTaskClass) ? 1 : 2))] == null) &&\n+                    pool != null)\n+                    pool.signalWork();   \/\/ may have appeared empty\n@@ -1357,2 +1353,1 @@\n-                    while (b == (b = base)) {\n-                        U.loadFence();\n+                    while (b == (b = U.getIntAcquire(this, BASE)))\n@@ -1360,1 +1355,0 @@\n-                    }\n@@ -1384,1 +1378,1 @@\n-            int p = top, s = p - 1, cap, k;\n+            int p = top, s = p - 1, cap; long k;\n@@ -1386,1 +1380,1 @@\n-                a[k = (cap - 1) & s] == task &&\n+                U.getReference(a, k = slotOffset((cap - 1) & s)) == task &&\n@@ -1389,1 +1383,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), task, null)) {\n+                    U.compareAndSetReference(a, k, task, null)) {\n@@ -1423,2 +1417,2 @@\n-            for (int b = base;;) {\n-                int cap, k, nb; ForkJoinTask<?>[] a;\n+            for (int pb = -1, b; ; pb = b) {       \/\/ track progress\n+                ForkJoinTask<?> t; int cap, nb; long k; ForkJoinTask<?>[] a;\n@@ -1427,16 +1421,10 @@\n-                long kp = slotOffset(k = (cap - 1) & b);\n-                int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n-                ForkJoinTask<?> t = a[k];\n-                U.loadFence();\n-                if (b == (b = base)) {             \/\/ else inconsistent\n-                    if (t != null) {\n-                        if (U.compareAndSetReference(a, kp, t, null)) {\n-                            updateBase(nb);\n-                            return t;\n-                        }\n-                        b = base;\n-                    }\n-                    else if (a[sk] == null && a[nk] == null && a[k] == null) {\n-                        if (top - b <= 0)\n-                            break;                 \/\/ empty\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n+                Object u = U.getReference(         \/\/ next slot\n+                    a, slotOffset((cap - 1) & (nb = b + 1)));\n+                if (base != b)                     \/\/ inconsistent\n+                    ;\n+                else if (t == null) {\n+                    if (u == null && top - b <= 0)\n+                        break;                     \/\/ empty\n+                    if (pb == b)\n@@ -1444,1 +1432,4 @@\n-                    }\n+                }\n+                else if (U.compareAndSetReference(a, k, t, null)) {\n+                    updateBase(nb);\n+                    return t;\n@@ -1474,2 +1465,4 @@\n-                    ForkJoinTask<?> t; int k; boolean taken;\n-                    if ((t = a[k = i & m]) == null)\n+                    long k; boolean taken;\n+                    ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReference(\n+                        a, k = slotOffset(i & m));\n+                    if (t == null)\n@@ -1478,1 +1471,0 @@\n-                        long pos = slotOffset(k);\n@@ -1483,1 +1475,1 @@\n-                             U.compareAndSetReference(a, pos, task, null))) {\n+                             U.compareAndSetReference(a, k, task, null))) {\n@@ -1490,1 +1482,1 @@\n-                                    a, pos, (ForkJoinTask<?>)\n+                                    a, k, (ForkJoinTask<?>)\n@@ -1518,2 +1510,2 @@\n-                    ForkJoinTask<?>[] a; ForkJoinTask<?> t; boolean taken;\n-                    int stat, p, s, cap, k;\n+                    ForkJoinTask<?>[] a; boolean taken; Object o;\n+                    int stat, p, s, cap;\n@@ -1526,3 +1518,2 @@\n-                    if ((t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null)\n-                        break;\n-                    if (!(t instanceof CountedCompleter))\n+                    long k = slotOffset((cap - 1) & (s = (p = top) - 1));\n+                    if (!((o = U.getReference(a, k)) instanceof CountedCompleter))\n@@ -1530,1 +1521,1 @@\n-                    CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                    CountedCompleter<?> t = (CountedCompleter<?>)o, f = t;\n@@ -1541,1 +1532,1 @@\n-                         U.compareAndSetReference(a, slotOffset(k), t, null)))\n+                         U.compareAndSetReference(a, k, t, null)))\n@@ -1563,1 +1554,1 @@\n-                ForkJoinTask<?>[] a; int b, cap, k;\n+                ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap; long k;\n@@ -1566,2 +1557,2 @@\n-                ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n-                U.loadFence();\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n@@ -1578,1 +1569,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    U.compareAndSetReference(a, k, t, null)) {\n@@ -1636,0 +1627,6 @@\n+    \/**\n+     * Cached for faster type tests.\n+     *\/\n+    static final Class<?> interruptibleTaskClass;\n+\n+\n@@ -1841,7 +1838,5 @@\n-                    if (w.top - w.base > 0) {\n-                        ForkJoinTask<?> t; \/\/ cancel remaining tasks\n-                        while ((t = w.nextLocalTask()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n+                    ForkJoinTask<?> t;     \/\/ cancel remaining tasks\n+                    while ((t = w.nextLocalTask(0)) != null) {\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n@@ -1989,2 +1984,2 @@\n-            int cfg = w.config, src = -1, nsteals = 0;\n-            rescan: for (boolean scanned = false;;) {\n+            int cfg = w.config, nsteals = 0, src = -1;\n+            for (;;) {\n@@ -1994,1 +1989,1 @@\n-                    return;\n+                    break;\n@@ -1996,26 +1991,22 @@\n-                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    int j; WorkQueue q;\n-                    if ((q = qs[j = i & (n - 1)]) != null) {\n-                        boolean taken = false;\n-                        for (int pb = -1, b = q.base;;) {\n-                            int cap, k, nb; ForkJoinTask<?>[] a;\n-                            if ((a = q.array) == null || (cap = a.length) <= 0)\n-                                continue rescan;\n-                            long kp = slotOffset(k = (cap - 1) & b);\n-                            int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                            int sk = (b + 2) & (cap - 1); \/\/ 2nd slot ahead\n-                            ForkJoinTask<?> t = a[k];\n-                            U.loadFence();\n-                            if (b != (b = q.base))\n-                                ;                         \/\/ inconsistent\n-                            else if (t == null) {         \/\/ possibly empty\n-                                if (a[sk] == null && a[nk] == null &&\n-                                    a[k] == null) {       \/\/ screen\n-                                    if (q.top - b > 0) {  \/\/ stalled\n-                                        if (!taken)       \/\/ move unless taking\n-                                            continue rescan;\n-                                    }\n-                                    else if (taken)\n-                                        continue rescan;  \/\/ depleted; restart\n-                                    else\n-                                        break;            \/\/ empty\n+                boolean rescan = false;\n+                scan: for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                    if ((q = qs[j = i & (n - 1)]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0) {\n+                        for (int m = cap - 1, pb = -1;;) { \/\/ track progress\n+                            ForkJoinTask<?> t; int b; long k;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset(m & (b = q.base)));\n+                            if (q.base != b)              \/\/ inconsistent\n+                                ;\n+                            else if (t == null) {\n+                                if (a[b & m] == null &&\n+                                    a[(b + 1) & m] == null &&\n+                                    a[(b + 2) & m] == null) {\n+                                    if (rescan)           \/\/ end of run\n+                                        break scan;\n+                                    break;                \/\/ probably empty\n+                                }\n+                                if (pb == (pb = b)) {\n+                                    rescan = true;        \/\/ stalled; reorder scan\n+                                    break scan;\n@@ -2023,2 +2014,0 @@\n-                                if (pb == (pb = b))       \/\/ base unchanged\n-                                    Thread.onSpinWait();\n@@ -2026,4 +2015,2 @@\n-                            else if (!U.compareAndSetReference(a, kp, t, null))\n-                                b = q.base;               \/\/ contended\n-                            else {\n-                                q.base = nb;\n+                            else if (U.compareAndSetReference(a, k, t, null)) {\n+                                int nb = q.base = b + 1;\n@@ -2031,3 +2018,7 @@\n-                                w.source = j;             \/\/ volatile write\n-                                if (taken != (taken = true) && a[nk] != null)\n-                                    signalWork();         \/\/ propagate signal\n+                                w.source = j;             \/\/ volatile\n+                                rescan = true;\n+                                boolean propagate = (src != (src = j)) ||\n+                                    t.getClass().getSuperclass() ==\n+                                    interruptibleTaskClass;\n+                                if (propagate && a[nb & m] != null)\n+                                    signalWork();\n@@ -2035,2 +2026,2 @@\n-                                if ((b = q.base) != nb && src != (src = j))\n-                                    continue rescan;      \/\/ reduce interference\n+                                if (!propagate && q.base != nb)\n+                                    break scan;          \/\/ reduce interference\n@@ -2038,0 +2029,2 @@\n+                            else if (rescan)\n+                                break scan;              \/\/ collision during run\n@@ -2041,6 +2034,5 @@\n-                if (!scanned)\n-                    scanned = true;                   \/\/ rescan before deactivate\n-                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n-                    scanned = false;\n-                else\n-                    return;\n+                if (!rescan) {\n+                    if (((phase = deactivate(w, phase)) & IDLE) != 0)\n+                        break;\n+                    src = -1;\n+                }\n@@ -2055,1 +2047,0 @@\n-     * @param r random seed\n@@ -2059,1 +2050,3 @@\n-    private int deactivate(WorkQueue w, int r, int phase) {\n+    private int deactivate(WorkQueue w, int phase) {\n+        if (w == null)                        \/\/ currently impossible\n+            return IDLE;\n@@ -2061,42 +2054,24 @@\n-        if (w != null) {                         \/\/ always true\n-            w.phase = p;\n-            long pc = ctl, qc;\n-            for (;;) {                           \/\/ try to enqueue\n-                w.stackPred = (int)pc;           \/\/ set ctl stack link\n-                qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-                if (pc == (pc = compareAndExchangeCtl(pc, qc))) \/\/ success\n-                    break;\n-                if ((pc & RC_MASK) >= (qc & RC_MASK)) {\n-                    p = w.phase = phase;         \/\/ back out on possible signal\n-                    break;\n-                }\n-            }\n-            if (p != phase &&                    \/\/ check quiescent termination\n-                ((runState & SHUTDOWN) == 0L || quiescent() <= 0)) {\n-                WorkQueue[] qs;\n-                int spins = ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS + 1;\n-                while ((p = w.phase) != activePhase && --spins > 0)\n-                    Thread.onSpinWait();         \/\/ reduce flailing\n-                if (p != activePhase && (qs = queues) != null) {\n-                    int n = qs.length, step = (r >>> 16) | 1;\n-                    for (int i = r, l = n; l > 0; --l, i += step) {\n-                        WorkQueue q;             \/\/ check for missed signals\n-                        if ((q = qs[i & (n - 1)]) != null &&\n-                            q.top - q.base > 0) {\n-                            if (ctl == qc && compareAndSetCtl(qc, pc)) {\n-                                p = w.phase = activePhase;\n-                                break;           \/\/ self-signal\n-                            }\n-                            if ((p = w.phase) == activePhase)\n-                                break;\n-                        }\n-                    }\n-                    if (p != activePhase) {\n-                        long delay = (((qc & RC_MASK) > 0L) ? 0L :\n-                                      (w.source != INVALID_ID) ? keepAlive :\n-                                      TIMEOUT_SLOP); \/\/ minimal delay if cascade\n-                        if ((p = w.phase) != activePhase)\n-                            p = awaitWork(w, p, delay); \/\/ block, drop, or exit\n-                    }\n-                }\n-            }\n+        long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+        w.stackPred = (int)pc;                \/\/ set ctl stack link\n+        w.phase = p;\n+        if (!compareAndSetCtl(pc, qc))        \/\/ try to enqueue\n+            return w.phase = phase;           \/\/ back out on possible signal\n+        int ac = (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n+        if (((e = runState) & STOP) != 0L ||\n+            ((e & SHUTDOWN) != 0L && ac == 0 && quiescent() > 0) ||\n+            (qs = queues) == null || (n = qs.length) <= 0)\n+            return IDLE;                      \/\/ terminating\n+        int prechecks = Math.min(ac, 2);      \/\/ reactivation threshold\n+        for (int k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n+            WorkQueue q; int cap; ForkJoinTask<?>[] a;\n+            if (w.phase == activePhase)\n+                return activePhase;\n+            if (--k < 0)\n+                return awaitWork(w, p);       \/\/ block, drop, or exit\n+            if ((k & 1) != 0)\n+                Thread.onSpinWait();          \/\/ interleave spins and rechecks\n+            else if ((q = qs[k & (n - 1)]) != null &&\n+                     (a = q.array) != null && (cap = a.length) > 0 &&\n+                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n+                     ctl == qc && compareAndSetCtl(qc, pc))\n+                return w.phase = activePhase; \/\/ reactivate\n@@ -2104,1 +2079,0 @@\n-        return p;\n@@ -2112,1 +2086,0 @@\n-     * @param delay if nonzero keepAlive before trimming if quiescent\n@@ -2115,1 +2088,1 @@\n-    private int awaitWork(WorkQueue w, int p, long delay) {\n+    private int awaitWork(WorkQueue w, int p) {\n@@ -2117,0 +2090,7 @@\n+            long deadline;                     \/\/ for idle timeouts\n+            if ((ctl & RC_MASK) > 0L)\n+                deadline = 0L;\n+            else if ((deadline =\n+                      (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n+                      System.currentTimeMillis()) == 0L)\n+                deadline = 1L;                 \/\/ avoid zero\n@@ -2118,11 +2098,7 @@\n-            LockSupport.setCurrentBlocker(this);\n-            long deadline = (delay == 0L ? 0L :\n-                             delay + System.currentTimeMillis());\n-            w.parking = 1;                 \/\/ enable unpark\n-            while ((p = w.phase) != activePhase) {\n-                boolean trimmable = false; int trim;\n-                Thread.interrupted();      \/\/ clear status\n-                if ((runState & STOP) != 0L)\n-                    break;\n-                if (deadline != 0L) {\n-                    if ((trim = tryTrim(w, p, deadline)) > 0)\n+            if ((p = w.phase) != activePhase && (runState & STOP) == 0L) {\n+                LockSupport.setCurrentBlocker(this);\n+                w.parking = 1;                 \/\/ enable unpark\n+                while ((p = w.phase) != activePhase) {\n+                    boolean trimmable = false; int trim;\n+                    Thread.interrupted();      \/\/ clear status\n+                    if ((runState & STOP) != 0L)\n@@ -2130,4 +2106,9 @@\n-                    else if (trim < 0)\n-                        deadline = 0L;\n-                    else\n-                        trimmable = true;\n+                    if (deadline != 0L) {\n+                        if ((trim = tryTrim(w, p, deadline)) > 0)\n+                            break;\n+                        else if (trim < 0)\n+                            deadline = 0L;\n+                        else\n+                            trimmable = true;\n+                    }\n+                    U.park(trimmable, deadline);\n@@ -2135,1 +2116,2 @@\n-                U.park(trimmable, deadline);\n+                w.parking = 0;\n+                LockSupport.setCurrentBlocker(null);\n@@ -2137,2 +2119,0 @@\n-            w.parking = 0;\n-            LockSupport.setCurrentBlocker(null);\n@@ -2293,1 +2273,3 @@\n-                            int sq = q.source, b, cap, k; ForkJoinTask<?>[] a;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            boolean eligible = false;\n+                            int sq = q.source, b, cap; long k;\n@@ -2296,3 +2278,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2317,2 +2298,2 @@\n-                            if (q.source == sq && q.base == b && a[k] == t) {\n-                                int nb = b + 1, nk = nb & (cap - 1);\n+                            if (q.source == sq && q.base == b &&\n+                                U.getReference(a, k) == t) {\n@@ -2320,2 +2301,1 @@\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2325,4 +2305,3 @@\n-                                if (U.compareAndSetReference(\n-                                        a, slotOffset(k), t, null)) {\n-                                    q.updateBase(nb);\n-                                    w.source = j;\n+                                if (U.compareAndSetReference(a, k, t, null)) {\n+                                    q.base = b + 1;\n+                                    w.source = j;    \/\/ volatile write\n@@ -2375,1 +2354,3 @@\n-                            ForkJoinTask<?>[] a; int b, cap, k;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            int b, cap, nb; long k;\n+                            boolean eligible = false;\n@@ -2378,3 +2359,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2395,1 +2375,0 @@\n-                                int nb = b + 1, nk = nb & (cap - 1);\n@@ -2398,2 +2377,2 @@\n-                                            a, slotOffset(k), t, null)) {\n-                                        q.updateBase(nb);\n+                                            a, k, t, null)) {\n+                                        q.updateBase(b + 1);\n@@ -2405,3 +2384,2 @@\n-                                else if (a[k] == t) {\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                else if (U.getReference(a, k) == t) {\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2460,1 +2438,2 @@\n-                        ForkJoinTask<?>[] a; int b, cap, k;\n+                        ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                        int b, cap; long k;\n@@ -2463,1 +2442,2 @@\n-                        ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                        t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                            a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2466,2 +2446,1 @@\n-                        U.loadFence();\n-                        if (q.base == b && a[k] == t) {\n+                        if (q.base == b && U.getReference(a, k) == t) {\n@@ -2480,4 +2459,3 @@\n-                            if (U.compareAndSetReference(\n-                                    a, slotOffset(k), t, null)) {\n-                                q.updateBase(nb);\n-                                w.source = j;\n+                            if (U.compareAndSetReference(a, k, t, null)) {\n+                                q.base = nb;\n+                                w.source = j; \/\/ volatile write\n@@ -2779,13 +2757,10 @@\n-            if ((ctl & RC_MASK) > 0L) {          \/\/ unless all inactive\n-                int r = (int)Thread.currentThread().threadId();\n-                WorkQueue[] qs = queues;         \/\/ stagger traversals\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int l = n; l > 0; --l, ++r) {\n-                    WorkQueue q; ForkJoinTask<?> t;\n-                    if ((q = qs[r & (n - 1)]) != null &&\n-                        q.source != DROPPED) {\n-                        while ((t = q.poll()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n+            int r = (int)Thread.currentThread().threadId();\n+            WorkQueue[] qs = queues;             \/\/ stagger traversals\n+            int n = (qs == null) ? 0 : qs.length;\n+            for (int l = n; l > 0; --l, ++r) {\n+                WorkQueue q; ForkJoinTask<?> t;\n+                if ((q = qs[r & (n - 1)]) != null) {\n+                    while ((t = q.poll()) != null) {\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n@@ -4060,0 +4035,1 @@\n+        interruptibleTaskClass = ForkJoinTask.InterruptibleTask.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":217,"deletions":241,"binary":false,"changes":458,"status":"modified"}]}