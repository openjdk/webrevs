{"files":[{"patch":"@@ -413,19 +413,22 @@\n-     * includes monotonic event bits (SHUTDOWN, STOP, CLEANED (when\n-     * all queues are knowm to be empty after stopping) and\n-     * TERMINATED).  The version tags enable detection of state\n-     * changes (by comparing two reads) modulo bit wraparound. The bit\n-     * range in each case suffices for purposes of determining\n-     * quiescence, termination, avoiding ABA-like errors, and signal\n-     * control, most of which are ultimately based on at most 15bit\n-     * ranges (due to 32767 max total workers). RunState updates do\n-     * not need to be atomic with respect to ctl updates, but because\n-     * they are not, some care is required to avoid stalls. The\n-     * seqLock properties detect changes and conditionally upgrade to\n-     * coordinate with updates. It is typically held for less than a\n-     * dozen instructions unless the queue array is being resized,\n-     * during which contention is rare. To be conservative,\n-     * lockRunState is implemented as a spin\/sleep loop. Here and\n-     * elsewhere spin constants are short enough to apply even on\n-     * systems with few available processors.  In addition to checking\n-     * pool status, reads of runState sometimes serve as acquire\n-     * fences before reading other fields.\n+     * includes monotonic event bits:\n+     * * SHUTDOWN: no more external tasks accepted; STOP when quiescent\n+     * * STOP: no more tasks run, and deregister all workers\n+     * * CLEANED: all unexecuted tasks have been cancelled\n+     * * TERMINATED: all qorkers deregistered and all queues cleaned\n+     * The version tags enable detection of state changes (by\n+     * comparing two reads) modulo bit wraparound. The bit range in\n+     * each case suffices for purposes of determining quiescence,\n+     * termination, avoiding ABA-like errors, and signal control, most\n+     * of which are ultimately based on at most 15bit ranges (due to\n+     * 32767 max total workers). RunState updates do not need to be\n+     * atomic with respect to ctl updates, but because they are not,\n+     * some care is required to avoid stalls. The seqLock properties\n+     * detect changes and conditionally upgrade to coordinate with\n+     * updates. It is typically held for less than a dozen\n+     * instructions unless the queue array is being resized, during\n+     * which contention is rare. To be conservative, lockRunState is\n+     * implemented as a spin\/sleep loop. Here and elsewhere spin\n+     * constants are short enough to apply even on systems with few\n+     * available processors.  In addition to checking pool status,\n+     * reads of runState sometimes serve as acquire fences before\n+     * reading other fields.\n@@ -656,18 +659,30 @@\n-     * Termination. A call to shutdownNow invokes tryTerminate to\n-     * atomically set a runState mode bit.  However, the process of\n-     * termination is intrinsically non-atomic. The calling thread, as\n-     * well as other workers thereafter terminating help cancel queued\n-     * tasks until runState is marked as CLEANED (staggering queues\n-     * and backing off on interference to avoid contention while doing\n-     * so-- see method cleanQueues). These actions race with\n-     * unterminated workers.  By default, workers check for\n-     * termination only when accessing pool state.  This may take a\n-     * while but suffices for structured computational tasks.  But not\n-     * necessarily for others. Class InterruptibleTask (see below)\n-     * further arranges runState checks before executing task bodies,\n-     * and ensures interrupts while terminating. Even so, there are no\n-     * guarantees after an abrupt shutdown that remaining tasks\n-     * complete normally or exceptionally or are cancelled.\n-     * Termination may fail to complete if running tasks ignore both\n-     * task status and interrupts and\/or produce more tasks after\n-     * others that could cancel them have exited.\n+     * Termination. Termination is initiated by setting STOP in one of\n+     * three ways (via methods tryTerminate and quiescent):\n+     * * A call to shutdownNow, in which case all workers are\n+     *   interrupted.  ensuring that the queues array is stable,\n+     *   so will not miss any of them.\n+     * * A call to shutdown when quiescent, in which case method\n+     *   releaseWaiters is used to dequeue them, at which point they notice\n+     *   STOP state and return from runWorker to deregister();\n+     * * The pool becomes quiescent() sometime after shutdown has\n+     *   been called, in which case releaseWaiters is also used to\n+     *   propagate as they deregister.\n+     * Upon STOP, each worker, as well as external callers to\n+     * tryTerminate (via close() etc) race to set CLEANED, indicating\n+     * that all tasks have been cancelled. The implementation (method\n+     * cleanQueues) balances cases in which there may be many tasks to\n+     * cancel (benefitting from parallelism) versus contention and\n+     * interference when many threads try to poll remaining queues,\n+     * while also avoiding unnecessary rechedcks, by using\n+     * pseudorandom scans and giving up upon interference. This may be\n+     * retried by the same caller only when there are no more\n+     * registered workers, using the same criteria as method\n+     * quiescent.  When CLEANED and all workers have deregistered,\n+     * TERMINATED is set, also signalling any caller of\n+     * awaitTermination or close.  Because shutdownNow-based\n+     * termination relies on interrupts, there is no guarantee that\n+     * workers will stop if their tasks ignore interrupts.  Class\n+     * InterruptibleTask (see below) further arranges runState checks\n+     * before executing task bodies, and ensures interrupts while\n+     * terminating. Even so, there are no guarantees because tasks may\n+     * internally enter unbounded loops.\n@@ -1850,1 +1865,1 @@\n-            releaseAll();                  \/\/ ensure released\n+            releaseWaiters();              \/\/ ensure released\n@@ -1919,1 +1934,1 @@\n-    private void releaseAll() {\n+    private void releaseWaiters() {\n@@ -2752,1 +2767,1 @@\n-                    lockRunState(); \/\/ ensure queues array stable after stop\n+                    spinLockRunState(); \/\/ ensure queues array stable after stop\n@@ -2765,1 +2780,1 @@\n-            releaseAll();\n+            releaseWaiters();\n@@ -2774,1 +2789,1 @@\n-                if (ctl != 0L)\n+                if (ctl != 0L) \/\/ else loop if didn't finish cleaning\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":57,"deletions":42,"binary":false,"changes":99,"status":"modified"}]}