{"files":[{"patch":"@@ -659,1 +659,3 @@\n-     * tasks and interrupt other workers. These actions race with\n+     * tasks and interrupt other workers (staggering queues and\n+     * backing off on interference to avoid contention while doing\n+     * so-- see method helpTerminate). These actions race with\n@@ -1831,1 +1833,1 @@\n-            releaseAll();\n+            dropWaiters();\n@@ -1915,3 +1917,1 @@\n-     * Releases all waiting workers. Called only during shutdown.\n-     *\n-     * @return current ctl\n+     * Releases and drops all waiting workers. Called only during shutdown.\n@@ -1919,3 +1919,2 @@\n-    private long releaseAll() {\n-        long c = ctl;\n-        for (;;) {\n+    private void dropWaiters() {\n+        for (long c = ctl;;) {\n@@ -1927,2 +1926,2 @@\n-                          c, ((UMASK & (c + RC_UNIT)) | (c & TC_MASK) |\n-                              (v.stackPred & LMASK))))) {\n+                          c, (v.stackPred & LMASK) | (UMASK & (c - TC_UNIT))))) {\n+                v.source = DROPPED;\n@@ -1934,1 +1933,0 @@\n-        return c;\n@@ -1939,3 +1937,3 @@\n-     * @return positive if stopping, nonnegative if terminating or all\n-     * workers are inactive and submission queues are empty and\n-     * unlocked; if so, setting STOP if shutdown is enabled\n+     * @return nonnegative if terminating or all workers are inactive\n+     * and submission queues are empty and unlocked; if so, setting\n+     * STOP if shutdown is enabled and returning greater than 1, else 0.\n@@ -1971,1 +1969,1 @@\n-                    return 1;                             \/\/ enable termination\n+                    return 2;                             \/\/ enable termination\n@@ -2747,6 +2745,11 @@\n-        long e = runState, isShutdown;\n-        if ((e & STOP) == 0L) {\n-            if (now)\n-                runState = e = (lockRunState() + RS_LOCK) | STOP | SHUTDOWN;\n-            else if ((isShutdown = (e & SHUTDOWN)) != 0 || enable) {\n-                if (isShutdown == 0)\n+        long e;\n+        if (((e = runState) & STOP) == 0L) {\n+            long isShutdown, ps;\n+            boolean startTerminating = false;\n+            if (now) {\n+                runState = ((ps = lockRunState()) + RS_LOCK) | STOP | SHUTDOWN;\n+                if ((ps & STOP) == 0L)\n+                    startTerminating = true;\n+            }\n+            else if ((isShutdown = (e & SHUTDOWN)) != 0L || enable) {\n+                if (isShutdown == 0L)\n@@ -2754,2 +2757,2 @@\n-                if (quiescent() > 0)\n-                    e = runState;\n+                if (quiescent() > 1)\n+                    startTerminating = true;\n@@ -2757,2 +2760,2 @@\n-            if ((e & STOP) != 0L) {\n-                releaseAll();\n+            if (startTerminating) {\n+                dropWaiters();\n@@ -2761,1 +2764,0 @@\n-                e = runState;\n@@ -2764,8 +2766,40 @@\n-        if ((e & (STOP | TERMINATED)) == STOP) { \/\/ help cancel tasks\n-            int r = (int)Thread.currentThread().threadId();\n-            WorkQueue[] qs = queues;             \/\/ stagger traversals\n-            int n = (qs == null) ? 0 : qs.length;\n-            for (int l = n; l > 0; --l, ++r) {\n-                WorkQueue q; ForkJoinTask<?> t;\n-                if ((q = qs[r & (n - 1)]) != null) {\n-                    while (q.source != DROPPED && (t = q.poll()) != null) {\n+        if ((runState & STOP) != 0L)\n+            helpTerminate();\n+        if (((e = runState) & (STOP | TERMINATED)) == STOP && ctl == 0L) {\n+            e |= TERMINATED;\n+            if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n+                CountDownLatch done; SharedThreadContainer ctr;\n+                if ((done = termination) != null)\n+                    done.countDown();\n+                if ((ctr = container) != null)\n+                    ctr.close();\n+            }\n+        }\n+        return e;\n+    }\n+\n+    \/**\n+     * Scans queues (with start index based on thread id to stagger\n+     * traversals), cancelling tasks until empty or interference (in\n+     * which case one or more other threads will finish cancellation).\n+     *\/\n+    private void helpTerminate() {\n+        int r = (int)Thread.currentThread().threadId();\n+        r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n+        WorkQueue[] qs = queues;             \/\/ stagger traversals\n+        int n = (qs == null) ? 0 : qs.length;\n+        for (int l = n; l > 0; --l, ++r) {\n+            WorkQueue q;\n+            if ((q = qs[r & (n - 1)]) != null) {\n+                for (;;) {\n+                    ForkJoinTask<?> t; int cap, b; long k; ForkJoinTask<?>[] a;\n+                    if ((a = q.array) == null || (cap = a.length) <= 0)\n+                        break;\n+                    t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                        a, k = slotOffset((cap - 1) & (b = q.base)));\n+                    if (q.base != b)                   \/\/ inconsistent\n+                        ;\n+                    else if (t == null || !U.compareAndSetReference(a, k, t, null))\n+                        break;                         \/\/ empty or contended\n+                    else {\n+                        q.updateBase(b + 1);\n@@ -2779,10 +2813,0 @@\n-            if (((e = runState) & TERMINATED) == 0L && ctl == 0L) {\n-                e |= TERMINATED;\n-                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n-                    CountDownLatch done; SharedThreadContainer ctr;\n-                    if ((done = termination) != null)\n-                        done.countDown();\n-                    if ((ctr = container) != null)\n-                        ctr.close();\n-                }\n-            }\n@@ -2790,1 +2814,0 @@\n-        return e;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":68,"deletions":45,"binary":false,"changes":113,"status":"modified"}]}