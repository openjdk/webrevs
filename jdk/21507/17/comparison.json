{"files":[{"patch":"@@ -266,4 +266,1 @@\n-     * ordered writes of various kinds for updates, but usually use\n-     * explicit load fences for reads, to cover access of several\n-     * fields of possibly several objects without further constraining\n-     * read-by-read ordering.\n+     * ordered writes of various kinds for accesses when required.\n@@ -309,2 +306,1 @@\n-     *    CAS succeeds, but uses an explicit acquire fence to support\n-     *    the following rechecks even if the CAS is not attempted.\n+     *    CAS succeeds.\n@@ -479,2 +475,1 @@\n-     * another at the same index. During termination, worker queue\n-     * array updates are disabled.\n+     * another at the same index.\n@@ -553,6 +548,5 @@\n-     *    activation. Emptiness must be conservatively approximated\n-     *    (by checking if there is apparently at most one existing\n-     *    task) which may result in unnecessary signals.  Also, to\n-     *    reduce resource usages in some cases, at the expense of\n-     *    slower startup in others, activation of an idle thread is\n-     *    preferred over creating a new one, here and elsewhere.\n+     *    activation. Emptiness must be conservatively approximated,\n+     *    which may result in unnecessary signals.  Also, to reduce\n+     *    resource usages in some cases, at the expense of slower\n+     *    startup in others, activation of an idle thread is preferred\n+     *    over creating a new one, here and elsewhere.\n@@ -562,7 +556,13 @@\n-     *    producer, each worker taking its first (since the last\n-     *    activation) task from a queue should propagate a signal if\n-     *    there are more tasks in that queue. This is equivalent to,\n-     *    but generally faster than, arranging the stealer take\n-     *    multiple tasks, re-pushing one or more on its own queue, and\n-     *    signalling (because its queue is empty), also resulting in\n-     *    logarithmic full activation time.\n+     *    producer, each worker taking a task from a queue should\n+     *    propagate a signal if there are more tasks in that\n+     *    queue. This is equivalent to, but generally faster than,\n+     *    arranging the stealer take multiple tasks, re-pushing one or\n+     *    more on its own queue, and signalling (because its queue is\n+     *    empty), also resulting in logarithmic full activation\n+     *    time. If tasks do not not engage in unbounded loops based on\n+     *    the actions of other workers with unknown dependencies loop,\n+     *    this form of proagation can be limited to one signal per\n+     *    activation (phase change). We distinguish the cases by\n+     *    further signalling only if the task is an InterruptibleTask\n+     *    (see below), which are the only supported forms of task that\n+     *    may do so.\n@@ -618,3 +618,6 @@\n-     * signal during deactivation.  Because idle workers are often not\n-     * yet blocked (parked), we use a WorkQueue field to advertise\n-     * that a waiter actually needs unparking upon signal.\n+     * (external) signal during deactivation. To reduce false-alarm\n+     * reactivations while doing so, we scan multiple times\n+     * (analogously to method quiescent()) before trying to\n+     * reactivate.  Because idle workers are often not yet blocked\n+     * (parked), we use a WorkQueue field to advertise that a waiter\n+     * actually needs unparking upon signal.\n@@ -655,1 +658,3 @@\n-     * tasks and interrupt other workers. These actions race with\n+     * tasks and interrupt other workers (staggering queues and\n+     * backing off on interference to avoid contention while doing\n+     * so-- see method helpTerminate). These actions race with\n@@ -851,1 +856,3 @@\n-     * paths.\n+     * paths. The inability to rely on caller-runs may also require\n+     * extra signalling (and resulting scanning and contention) so is\n+     * done only conditionally in methods push and runworker.\n@@ -911,4 +918,2 @@\n-     * Currently, arrays for workers are initialized to be just large\n-     * enough to avoid resizing in most tree-structured tasks, but\n-     * larger for external queues where both false-sharing problems\n-     * and the need for resizing are more common.  (Maintenance note:\n+     * Currently, arrays are initialized to be just large enough to\n+     * avoid resizing in most tree-structured tasks. (Maintenance note:\n@@ -1003,6 +1008,0 @@\n-    \/**\n-     * Initial capacity of work-stealing queue array for external queues.\n-     * Must be a power of two, at least 2. See above.\n-     *\/\n-    static final int INITIAL_EXTERNAL_QUEUE_CAPACITY = 1 << 9;\n-\n@@ -1037,0 +1036,1 @@\n+    static final int DROPPING         = DROPPED | INVALID_ID;\n@@ -1253,3 +1253,1 @@\n-            array = new ForkJoinTask<?>[owner == null ?\n-                                        INITIAL_EXTERNAL_QUEUE_CAPACITY :\n-                                        INITIAL_QUEUE_CAPACITY];\n+            array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -1301,4 +1299,6 @@\n-                else if ((room == 0 ||\n-                          a[m & (s - 2)] == null) && \/\/ at most one existing task\n-                         pool != null)\n-                    pool.signalWork();\n+                if ((room == 0 ||        \/\/ pad for InterruptibleTasks\n+                     a[m & (s - ((internal || task == null ||\n+                                  task.getClass().getSuperclass() !=\n+                                  interruptibleTaskClass) ? 1 : 2))] == null) &&\n+                    pool != null)\n+                    pool.signalWork();   \/\/ may have appeared empty\n@@ -1358,2 +1358,1 @@\n-                    while (b == (b = base)) {\n-                        U.loadFence();\n+                    while (b == (b = U.getIntAcquire(this, BASE)))\n@@ -1361,1 +1360,0 @@\n-                    }\n@@ -1385,1 +1383,1 @@\n-            int p = top, s = p - 1, cap, k;\n+            int p = top, s = p - 1, cap; long k;\n@@ -1387,1 +1385,1 @@\n-                a[k = (cap - 1) & s] == task &&\n+                U.getReference(a, k = slotOffset((cap - 1) & s)) == task &&\n@@ -1390,1 +1388,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), task, null)) {\n+                    U.compareAndSetReference(a, k, task, null)) {\n@@ -1424,2 +1422,2 @@\n-            for (int b = base;;) {\n-                int cap, k, nb; ForkJoinTask<?>[] a;\n+            for (int pb = -1, b; ; pb = b) {       \/\/ track progress\n+                ForkJoinTask<?> t; int cap, nb; long k; ForkJoinTask<?>[] a;\n@@ -1428,16 +1426,10 @@\n-                long kp = slotOffset(k = (cap - 1) & b);\n-                int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n-                ForkJoinTask<?> t = a[k];\n-                U.loadFence();\n-                if (b == (b = base)) {             \/\/ else inconsistent\n-                    if (t != null) {\n-                        if (U.compareAndSetReference(a, kp, t, null)) {\n-                            updateBase(nb);\n-                            return t;\n-                        }\n-                        b = base;\n-                    }\n-                    else if (a[sk] == null && a[nk] == null && a[k] == null) {\n-                        if (top - b <= 0)\n-                            break;                 \/\/ empty\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n+                Object u = U.getReference(         \/\/ next slot\n+                    a, slotOffset((cap - 1) & (nb = b + 1)));\n+                if (base != b)                     \/\/ inconsistent\n+                    ;\n+                else if (t == null) {\n+                    if (u == null && top - b <= 0)\n+                        break;                     \/\/ empty\n+                    if (pb == b)\n@@ -1445,1 +1437,4 @@\n-                    }\n+                }\n+                else if (U.compareAndSetReference(a, k, t, null)) {\n+                    updateBase(nb);\n+                    return t;\n@@ -1475,2 +1470,4 @@\n-                    ForkJoinTask<?> t; int k; boolean taken;\n-                    if ((t = a[k = i & m]) == null)\n+                    long k; boolean taken;\n+                    ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReference(\n+                        a, k = slotOffset(i & m));\n+                    if (t == null)\n@@ -1479,1 +1476,0 @@\n-                        long pos = slotOffset(k);\n@@ -1484,1 +1480,1 @@\n-                             U.compareAndSetReference(a, pos, task, null))) {\n+                             U.compareAndSetReference(a, k, task, null))) {\n@@ -1491,1 +1487,1 @@\n-                                    a, pos, (ForkJoinTask<?>)\n+                                    a, k, (ForkJoinTask<?>)\n@@ -1519,2 +1515,2 @@\n-                    ForkJoinTask<?>[] a; ForkJoinTask<?> t; boolean taken;\n-                    int stat, p, s, cap, k;\n+                    ForkJoinTask<?>[] a; boolean taken; Object o;\n+                    int stat, p, s, cap;\n@@ -1527,3 +1523,2 @@\n-                    if ((t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null)\n-                        break;\n-                    if (!(t instanceof CountedCompleter))\n+                    long k = slotOffset((cap - 1) & (s = (p = top) - 1));\n+                    if (!((o = U.getReference(a, k)) instanceof CountedCompleter))\n@@ -1531,1 +1526,1 @@\n-                    CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                    CountedCompleter<?> t = (CountedCompleter<?>)o, f = t;\n@@ -1542,1 +1537,1 @@\n-                         U.compareAndSetReference(a, slotOffset(k), t, null)))\n+                         U.compareAndSetReference(a, k, t, null)))\n@@ -1564,1 +1559,1 @@\n-                ForkJoinTask<?>[] a; int b, cap, k;\n+                ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap; long k;\n@@ -1567,2 +1562,2 @@\n-                ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n-                U.loadFence();\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n@@ -1579,1 +1574,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    U.compareAndSetReference(a, k, t, null)) {\n@@ -1637,0 +1632,6 @@\n+    \/**\n+     * Cached for faster type tests.\n+     *\/\n+    static final Class<?> interruptibleTaskClass;\n+\n+\n@@ -1831,1 +1832,1 @@\n-        if ((runState & STOP) != 0L)       \/\/ ensure released\n+        if ((runState & STOP) != 0L)     \/\/ ensure released\n@@ -1836,14 +1837,10 @@\n-        if (wt != null && (w = wt.workQueue) != null) {\n-            phase = w.phase;\n-            if ((src = w.source) != DROPPED) {\n-                w.source = DROPPED;        \/\/ else already dropped\n-                if (phase != 0) {          \/\/ else failed to start\n-                    replaceable = true;\n-                    if (w.top - w.base > 0) {\n-                        ForkJoinTask<?> t; \/\/ cancel remaining tasks\n-                        while ((t = w.nextLocalTask()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n-                        }\n+        if (wt != null && (w = wt.workQueue) != null &&\n+            (phase = w.phase) != 0) {    \/\/ else failed to start\n+            if (((src = w.source) & DROPPED) == 0) {\n+                w.source = DROPPED;      \/\/ else already dropped\n+                replaceable = true;\n+                ForkJoinTask<?> t;       \/\/ cancel remaining tasks\n+                while ((t = w.nextLocalTask(0)) != null) {\n+                    try {\n+                        t.cancel(false);\n+                    } catch (Throwable ignore) {\n@@ -1853,0 +1850,16 @@\n+            boolean locked = false;      \/\/ OK to skip on contention if stopping\n+            long ns = w.nsteals & 0xffffffffL, s;\n+            if (((s = runState) & RS_LOCK) == 0L && casRunState(s, s + RS_LOCK))\n+                locked = true;\n+            else if ((s & STOP) == 0L) {\n+                spinLockRunState();\n+                locked = true;\n+            }\n+            if (locked) {\n+                WorkQueue[] qs; int n, i;\n+                stealCount += ns;         \/\/ accumulate steals\n+                if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                    qs[i = phase & SMASK & (n - 1)] == w)\n+                    qs[i] = null;         \/\/ remove index\n+                unlockRunState();\n+            }\n@@ -1854,1 +1867,1 @@\n-        if (src != DROPPED) {             \/\/ decrement counts\n+        if (src != DROPPED) {            \/\/ decrement counts\n@@ -1861,14 +1874,2 @@\n-        if ((tryTerminate(false, false) & STOP) == 0L && w != null) {\n-            WorkQueue[] qs; int n, i;     \/\/ remove index unless terminating\n-            long ns = w.nsteals & 0xffffffffL;\n-            if ((lockRunState() & STOP) != 0L)\n-                replaceable = false;\n-            else if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                     qs[i = phase & SMASK & (n - 1)] == w) {\n-                qs[i] = null;\n-                stealCount += ns;         \/\/ accumulate steals\n-            }\n-            unlockRunState();\n-            if (replaceable)\n-                signalWork();\n-        }\n+        if ((tryTerminate(false, false) & STOP) == 0L && replaceable)\n+            signalWork();\n@@ -1932,0 +1933,1 @@\n+                v.source = DROPPING; \/\/ avoid unnecessary shutdown overhead\n@@ -1942,3 +1944,3 @@\n-     * @return positive if stopping, nonnegative if terminating or all\n-     * workers are inactive and submission queues are empty and\n-     * unlocked; if so, setting STOP if shutdown is enabled\n+     * @return nonnegative if terminating or all workers are inactive\n+     * and submission queues are empty and unlocked; if so, setting\n+     * STOP if shutdown is enabled and returning greater than 1, else 0.\n@@ -1974,1 +1976,1 @@\n-                    return 1;                             \/\/ enable termination\n+                    return 2;                             \/\/ enable termination\n@@ -1990,2 +1992,2 @@\n-            int cfg = w.config, src = -1, nsteals = 0;\n-            rescan: for (boolean scanned = false;;) {\n+            int cfg = w.config, nsteals = 0, src = -1;\n+            for (;;) {\n@@ -1995,1 +1997,1 @@\n-                    return;\n+                    break;\n@@ -1997,21 +1999,21 @@\n-                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    int j; WorkQueue q;\n-                    if ((q = qs[j = i & (n - 1)]) != null) {\n-                        boolean taken = false;\n-                        for (int pb = -1, b = q.base;;) {\n-                            int cap, k, nb; ForkJoinTask<?>[] a;\n-                            if ((a = q.array) == null || (cap = a.length) <= 0)\n-                                continue rescan;\n-                            long kp = slotOffset(k = (cap - 1) & b);\n-                            int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                            int sk = (b + 2) & (cap - 1); \/\/ 2nd slot ahead\n-                            ForkJoinTask<?> t = a[k];\n-                            U.loadFence();\n-                            if (b != (b = q.base))\n-                                ;                         \/\/ inconsistent\n-                            else if (t == null) {         \/\/ possibly empty\n-                                if (a[sk] == null && a[nk] == null &&\n-                                    a[k] == null) {       \/\/ screen\n-                                    if (q.top - b > 0) {  \/\/ stalled\n-                                        if (!taken)       \/\/ move unless taking\n-                                            continue rescan;\n+                boolean rescan = false;\n+                scan: for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                    if ((q = qs[j = i & (n - 1)]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0) {\n+                        for (int m = cap - 1, pb = -1, b = q.base;;) {\n+                            ForkJoinTask<?> t; long k;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset(m & b));\n+                            if (b != (b = q.base) || t == null ||\n+                                !U.compareAndSetReference(a, k, t, null)) {\n+                                if (a[b & m] == null) {\n+                                    if (rescan)           \/\/ end of run\n+                                        break scan;\n+                                    if (a[(b + 1) & m] == null &&\n+                                        a[(b + 2) & m] == null) {\n+                                        break;            \/\/ probably empty\n+                                    }\n+                                    if (pb == (pb = b)) { \/\/ track progress\n+                                        rescan = true;    \/\/ stalled; reorder scan\n+                                        break scan;\n@@ -2019,4 +2021,0 @@\n-                                    else if (taken)\n-                                        continue rescan;  \/\/ depleted; restart\n-                                    else\n-                                        break;            \/\/ empty\n@@ -2024,2 +2022,0 @@\n-                                if (pb == (pb = b))       \/\/ base unchanged\n-                                    Thread.onSpinWait();\n@@ -2027,2 +2023,0 @@\n-                            else if (!U.compareAndSetReference(a, kp, t, null))\n-                                b = q.base;               \/\/ contended\n@@ -2030,1 +2024,2 @@\n-                                q.base = nb;\n+                                boolean propagate;\n+                                int nb = q.base = b + 1;\n@@ -2032,3 +2027,8 @@\n-                                w.source = j;             \/\/ volatile write\n-                                if (taken != (taken = true) && a[nk] != null)\n-                                    signalWork();         \/\/ propagate signal\n+                                w.source = j;             \/\/ volatile\n+                                rescan = true;\n+                                if (propagate =\n+                                    ((src != (src = j) ||\n+                                      t.getClass().getSuperclass() ==\n+                                      interruptibleTaskClass) &&\n+                                     a[nb & m] != null))\n+                                    signalWork();\n@@ -2036,2 +2036,2 @@\n-                                if ((b = q.base) != nb && src != (src = j))\n-                                    continue rescan;      \/\/ reduce interference\n+                                if ((b = q.base) != nb && !propagate)\n+                                    break scan;          \/\/ reduce interference\n@@ -2042,6 +2042,5 @@\n-                if (!scanned)\n-                    scanned = true;                   \/\/ rescan before deactivate\n-                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n-                    scanned = false;\n-                else\n-                    return;\n+                if (!rescan) {\n+                    if (((phase = deactivate(w, phase)) & IDLE) != 0)\n+                        break;\n+                    src = -1;\n+                }\n@@ -2056,1 +2055,0 @@\n-     * @param r random seed\n@@ -2060,1 +2058,3 @@\n-    private int deactivate(WorkQueue w, int r, int phase) {\n+    private int deactivate(WorkQueue w, int phase) {\n+        if (w == null)                        \/\/ currently impossible\n+            return IDLE;\n@@ -2062,42 +2062,24 @@\n-        if (w != null) {                         \/\/ always true\n-            w.phase = p;\n-            long pc = ctl, qc;\n-            for (;;) {                           \/\/ try to enqueue\n-                w.stackPred = (int)pc;           \/\/ set ctl stack link\n-                qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-                if (pc == (pc = compareAndExchangeCtl(pc, qc))) \/\/ success\n-                    break;\n-                if ((pc & RC_MASK) >= (qc & RC_MASK)) {\n-                    p = w.phase = phase;         \/\/ back out on possible signal\n-                    break;\n-                }\n-            }\n-            if (p != phase &&                    \/\/ check quiescent termination\n-                ((runState & SHUTDOWN) == 0L || quiescent() <= 0)) {\n-                WorkQueue[] qs;\n-                int spins = ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS + 1;\n-                while ((p = w.phase) != activePhase && --spins > 0)\n-                    Thread.onSpinWait();         \/\/ reduce flailing\n-                if (p != activePhase && (qs = queues) != null) {\n-                    int n = qs.length, step = (r >>> 16) | 1;\n-                    for (int i = r, l = n; l > 0; --l, i += step) {\n-                        WorkQueue q;             \/\/ check for missed signals\n-                        if ((q = qs[i & (n - 1)]) != null &&\n-                            q.top - q.base > 0) {\n-                            if (ctl == qc && compareAndSetCtl(qc, pc)) {\n-                                p = w.phase = activePhase;\n-                                break;           \/\/ self-signal\n-                            }\n-                            if ((p = w.phase) == activePhase)\n-                                break;\n-                        }\n-                    }\n-                    if (p != activePhase) {\n-                        long delay = (((qc & RC_MASK) > 0L) ? 0L :\n-                                      (w.source != INVALID_ID) ? keepAlive :\n-                                      TIMEOUT_SLOP); \/\/ minimal delay if cascade\n-                        if ((p = w.phase) != activePhase)\n-                            p = awaitWork(w, p, delay); \/\/ block, drop, or exit\n-                    }\n-                }\n-            }\n+        long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+        w.stackPred = (int)pc;                \/\/ set ctl stack link\n+        w.phase = p;\n+        if (!compareAndSetCtl(pc, qc))        \/\/ try to enqueue\n+            return w.phase = phase;           \/\/ back out on possible signal\n+        int ac = (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n+        if (((e = runState) & STOP) != 0L ||\n+            ((e & SHUTDOWN) != 0L && ac == 0 && quiescent() > 0) ||\n+            (qs = queues) == null || (n = qs.length) <= 0)\n+            return IDLE;                      \/\/ terminating\n+        int prechecks = Math.min(ac, 2);      \/\/ reactivation threshold\n+        for (int k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n+            WorkQueue q; int cap; ForkJoinTask<?>[] a;\n+            if (w.phase == activePhase)\n+                return activePhase;\n+            if (--k < 0)\n+                return awaitWork(w, p);       \/\/ block, drop, or exit\n+            if ((k & 1) != 0)\n+                Thread.onSpinWait();          \/\/ interleave spins and rechecks\n+            else if ((q = qs[k & (n - 1)]) != null &&\n+                     (a = q.array) != null && (cap = a.length) > 0 &&\n+                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n+                     ctl == qc && compareAndSetCtl(qc, pc))\n+                return w.phase = activePhase; \/\/ reactivate\n@@ -2105,1 +2087,0 @@\n-        return p;\n@@ -2113,1 +2094,0 @@\n-     * @param delay if nonzero keepAlive before trimming if quiescent\n@@ -2116,1 +2096,1 @@\n-    private int awaitWork(WorkQueue w, int p, long delay) {\n+    private int awaitWork(WorkQueue w, int p) {\n@@ -2118,0 +2098,7 @@\n+            long deadline;                     \/\/ for idle timeouts\n+            if ((ctl & RC_MASK) > 0L)\n+                deadline = 0L;\n+            else if ((deadline =\n+                      (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n+                      System.currentTimeMillis()) == 0L)\n+                deadline = 1L;                 \/\/ avoid zero\n@@ -2119,11 +2106,7 @@\n-            LockSupport.setCurrentBlocker(this);\n-            long deadline = (delay == 0L ? 0L :\n-                             delay + System.currentTimeMillis());\n-            w.parking = 1;                 \/\/ enable unpark\n-            while ((p = w.phase) != activePhase) {\n-                boolean trimmable = false; int trim;\n-                Thread.interrupted();      \/\/ clear status\n-                if ((runState & STOP) != 0L)\n-                    break;\n-                if (deadline != 0L) {\n-                    if ((trim = tryTrim(w, p, deadline)) > 0)\n+            if ((p = w.phase) != activePhase && (runState & STOP) == 0L) {\n+                LockSupport.setCurrentBlocker(this);\n+                w.parking = 1;                 \/\/ enable unpark\n+                while ((p = w.phase) != activePhase) {\n+                    boolean trimmable = false; int trim;\n+                    Thread.interrupted();      \/\/ clear status\n+                    if ((runState & STOP) != 0L)\n@@ -2131,4 +2114,9 @@\n-                    else if (trim < 0)\n-                        deadline = 0L;\n-                    else\n-                        trimmable = true;\n+                    if (deadline != 0L) {\n+                        if ((trim = tryTrim(w, p, deadline)) > 0)\n+                            break;\n+                        else if (trim < 0)\n+                            deadline = 0L;\n+                        else\n+                            trimmable = true;\n+                    }\n+                    U.park(trimmable, deadline);\n@@ -2136,1 +2124,2 @@\n-                U.park(trimmable, deadline);\n+                w.parking = 0;\n+                LockSupport.setCurrentBlocker(null);\n@@ -2138,2 +2127,0 @@\n-            w.parking = 0;\n-            LockSupport.setCurrentBlocker(null);\n@@ -2294,1 +2281,3 @@\n-                            int sq = q.source, b, cap, k; ForkJoinTask<?>[] a;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            boolean eligible = false;\n+                            int sq = q.source, b, cap; long k;\n@@ -2297,3 +2286,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2318,2 +2306,2 @@\n-                            if (q.source == sq && q.base == b && a[k] == t) {\n-                                int nb = b + 1, nk = nb & (cap - 1);\n+                            if (q.source == sq && q.base == b &&\n+                                U.getReference(a, k) == t) {\n@@ -2321,2 +2309,1 @@\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2326,4 +2313,3 @@\n-                                if (U.compareAndSetReference(\n-                                        a, slotOffset(k), t, null)) {\n-                                    q.updateBase(nb);\n-                                    w.source = j;\n+                                if (U.compareAndSetReference(a, k, t, null)) {\n+                                    q.base = b + 1;\n+                                    w.source = j;    \/\/ volatile write\n@@ -2376,1 +2362,3 @@\n-                            ForkJoinTask<?>[] a; int b, cap, k;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            int b, cap, nb; long k;\n+                            boolean eligible = false;\n@@ -2379,3 +2367,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2396,1 +2383,0 @@\n-                                int nb = b + 1, nk = nb & (cap - 1);\n@@ -2399,2 +2385,2 @@\n-                                            a, slotOffset(k), t, null)) {\n-                                        q.updateBase(nb);\n+                                            a, k, t, null)) {\n+                                        q.updateBase(b + 1);\n@@ -2406,3 +2392,2 @@\n-                                else if (a[k] == t) {\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                else if (U.getReference(a, k) == t) {\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2461,1 +2446,2 @@\n-                        ForkJoinTask<?>[] a; int b, cap, k;\n+                        ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                        int b, cap; long k;\n@@ -2464,1 +2450,2 @@\n-                        ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                        t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                            a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2467,2 +2454,1 @@\n-                        U.loadFence();\n-                        if (q.base == b && a[k] == t) {\n+                        if (q.base == b && U.getReference(a, k) == t) {\n@@ -2481,4 +2467,3 @@\n-                            if (U.compareAndSetReference(\n-                                    a, slotOffset(k), t, null)) {\n-                                q.updateBase(nb);\n-                                w.source = j;\n+                            if (U.compareAndSetReference(a, k, t, null)) {\n+                                q.base = nb;\n+                                w.source = j; \/\/ volatile write\n@@ -2630,1 +2615,0 @@\n-        tryTerminate(false, false);\n@@ -2767,6 +2751,11 @@\n-        long e = runState, isShutdown;\n-        if ((e & STOP) == 0L) {\n-            if (now)\n-                runState = e = (lockRunState() + RS_LOCK) | STOP | SHUTDOWN;\n-            else if ((isShutdown = (e & SHUTDOWN)) != 0 || enable) {\n-                if (isShutdown == 0)\n+        long e;\n+        if (((e = runState) & STOP) == 0L) {\n+            long isShutdown, ps;\n+            boolean startTerminating = false;\n+            if (now) {\n+                runState = ((ps = lockRunState()) + RS_LOCK) | STOP | SHUTDOWN;\n+                if ((ps & STOP) == 0L)\n+                    startTerminating = true;\n+            }\n+            else if ((isShutdown = (e & SHUTDOWN)) != 0L || enable) {\n+                if (isShutdown == 0L)\n@@ -2774,2 +2763,2 @@\n-                if (quiescent() > 0)\n-                    e = runState;\n+                if (quiescent() > 1)\n+                    startTerminating = true;\n@@ -2777,20 +2766,4 @@\n-            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n-                interruptAll();\n-        }\n-        if ((e & (STOP | TERMINATED)) == STOP) { \/\/ help cancel tasks\n-            if ((ctl & RC_MASK) > 0L) {          \/\/ unless all inactive\n-                int r = (int)Thread.currentThread().threadId();\n-                WorkQueue[] qs = queues;         \/\/ stagger traversals\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int l = n; l > 0; --l, ++r) {\n-                    WorkQueue q; ForkJoinTask<?> t;\n-                    if ((q = qs[r & (n - 1)]) != null &&\n-                        q.source != DROPPED) {\n-                        while ((t = q.poll()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n-                        }\n-                    }\n-                }\n+            if (startTerminating) {\n+                releaseAll();\n+                if (now)\n+                    interruptAll();\n@@ -2798,1 +2771,7 @@\n-            if (((e = runState) & TERMINATED) == 0L && ctl == 0L) {\n+            e = runState;\n+        }\n+        while ((e & (STOP | TERMINATED)) == STOP) {\n+            boolean clean = helpTerminate();\n+            if (((e = runState) & TERMINATED) != 0L || ctl != 0L)\n+                break;\n+            if (clean) {\n@@ -2807,0 +2786,1 @@\n+                break;\n@@ -2812,0 +2792,39 @@\n+    \/**\n+     * Scans queues in a psuedorandom order based on thread id,\n+     * cancelling tasks until empty, or returning early upon\n+     * interference (in which case others will finish cancellation).\n+     *\n+     * @return true if all queues are empty\n+     *\/\n+    private boolean helpTerminate() {\n+        int r = (int)Thread.currentThread().threadId();\n+        r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n+        int step = (r >>> 16) | 1;                \/\/ randomize traversals\n+        WorkQueue[] qs = queues;\n+        int n = (qs == null) ? 0 : qs.length;\n+        for (int l = n; l > 0; --l, r += step) {\n+            WorkQueue q;  ForkJoinTask<?>[] a; int cap;\n+            if ((q = qs[r & (n - 1)]) != null &&\n+                (a = q.array) != null && (cap = a.length) > 0) {\n+                for (;;) {\n+                    ForkJoinTask<?> t; int b; long k;\n+                    t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                        a, k = slotOffset((cap - 1) & (b = q.base)));\n+                    if (q.base == b && t != null &&\n+                        U.compareAndSetReference(a, k, t, null)) {\n+                        q.updateBase(b + 1);\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n+                        }\n+                    }\n+                    else if (q.top - q.base > 0)\n+                        return false;             \/\/ interference\n+                    else\n+                        break;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -2822,1 +2841,1 @@\n-                q.source != DROPPED) {\n+                (q.source & DROPPED) == 0) {\n@@ -4062,0 +4081,1 @@\n+        interruptibleTaskClass = ForkJoinTask.InterruptibleTask.class;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":308,"deletions":288,"binary":false,"changes":596,"status":"modified"}]}