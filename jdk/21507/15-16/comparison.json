{"files":[{"patch":"@@ -475,2 +475,1 @@\n-     * another at the same index. During termination, worker queue\n-     * array updates are disabled.\n+     * another at the same index.\n@@ -1833,1 +1832,1 @@\n-        if ((runState & STOP) != 0L)       \/\/ ensure released\n+        if ((runState & STOP) != 0L)     \/\/ ensure released\n@@ -1838,2 +1837,2 @@\n-        if (wt != null && (w = wt.workQueue) != null) {\n-            phase = w.phase;\n+        if (wt != null && (w = wt.workQueue) != null &&\n+            (phase = w.phase) != 0) {    \/\/ else failed to start\n@@ -1841,9 +1840,7 @@\n-                w.source = DROPPED;        \/\/ else already dropped\n-                if (phase != 0) {          \/\/ else failed to start\n-                    replaceable = true;\n-                    ForkJoinTask<?> t;     \/\/ cancel remaining tasks\n-                    while ((t = w.nextLocalTask(0)) != null) {\n-                        try {\n-                            t.cancel(false);\n-                        } catch (Throwable ignore) {\n-                        }\n+                w.source = DROPPED;      \/\/ else already dropped\n+                replaceable = true;\n+                ForkJoinTask<?> t;       \/\/ cancel remaining tasks\n+                while ((t = w.nextLocalTask(0)) != null) {\n+                    try {\n+                        t.cancel(false);\n+                    } catch (Throwable ignore) {\n@@ -1853,0 +1850,16 @@\n+            boolean locked = false;      \/\/ OK to skip on contention if stopping\n+            long ns = w.nsteals & 0xffffffffL, s;\n+            if (((s = runState) & RS_LOCK) == 0L && casRunState(s, s + RS_LOCK))\n+                locked = true;\n+            else if ((s & STOP) == 0L) {\n+                spinLockRunState();\n+                locked = true;\n+            }\n+            if (locked) {\n+                WorkQueue[] qs; int n, i;\n+                stealCount += ns;         \/\/ accumulate steals\n+                if ((qs = queues) != null && (n = qs.length) > 0 &&\n+                    qs[i = phase & SMASK & (n - 1)] == w)\n+                    qs[i] = null;         \/\/ remove index\n+                unlockRunState();\n+            }\n@@ -1854,1 +1867,1 @@\n-        if (src != DROPPED) {             \/\/ decrement counts\n+        if (src != DROPPED) {            \/\/ decrement counts\n@@ -1861,14 +1874,2 @@\n-        if ((tryTerminate(false, false) & STOP) == 0L && w != null) {\n-            WorkQueue[] qs; int n, i;     \/\/ remove index unless terminating\n-            long ns = w.nsteals & 0xffffffffL;\n-            if ((lockRunState() & STOP) != 0L)\n-                replaceable = false;\n-            else if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                     qs[i = phase & SMASK & (n - 1)] == w) {\n-                qs[i] = null;\n-                stealCount += ns;         \/\/ accumulate steals\n-            }\n-            unlockRunState();\n-            if (replaceable)\n-                signalWork();\n-        }\n+        if ((tryTerminate(false, false) & STOP) == 0L && replaceable)\n+            signalWork();\n@@ -2793,2 +2794,2 @@\n-     * cancelling tasks until empty or interference (in which case one\n-     * or more other threads will finish cancellation).\n+     * cancelling tasks until empty, or returning early upon\n+     * interference (in which case others will finish cancellation).\n@@ -2796,1 +2797,1 @@\n-     * @return true if all undropped queues are now known to be empty\n+     * @return true if all queues are empty\n@@ -2799,1 +2800,0 @@\n-        boolean clean = true;\n@@ -2806,2 +2806,3 @@\n-            WorkQueue q;\n-            if ((q = qs[r & (n - 1)]) != null && (q.source & DROPPED) == 0) {\n+            WorkQueue q;  ForkJoinTask<?>[] a; int cap;\n+            if ((q = qs[r & (n - 1)]) != null &&\n+                (a = q.array) != null && (cap = a.length) > 0) {\n@@ -2809,3 +2810,1 @@\n-                    ForkJoinTask<?> t; int cap, b; long k; ForkJoinTask<?>[] a;\n-                    if ((a = q.array) == null || (cap = a.length) <= 0)\n-                        break;\n+                    ForkJoinTask<?> t; int b; long k;\n@@ -2814,8 +2813,2 @@\n-                    if (q.base != b)               \/\/ inconsistent\n-                        ;\n-                    else if (t == null) {\n-                        if (clean && q.top - b > 0)\n-                            clean = false;\n-                        break;\n-                    }\n-                    else if (U.compareAndSetReference(a, k, t, null)) {\n+                    if (q.base == b && t != null &&\n+                        U.compareAndSetReference(a, k, t, null)) {\n@@ -2828,0 +2821,4 @@\n+                    else if (q.top - q.base > 0)\n+                        return false;             \/\/ interference\n+                    else\n+                        break;\n@@ -2831,1 +2828,1 @@\n-        return clean;\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":44,"deletions":47,"binary":false,"changes":91,"status":"modified"}]}