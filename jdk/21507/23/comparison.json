{"files":[{"patch":"@@ -266,4 +266,1 @@\n-     * ordered writes of various kinds for updates, but usually use\n-     * explicit load fences for reads, to cover access of several\n-     * fields of possibly several objects without further constraining\n-     * read-by-read ordering.\n+     * ordered writes of various kinds for accesses when required.\n@@ -309,2 +306,1 @@\n-     *    CAS succeeds, but uses an explicit acquire fence to support\n-     *    the following rechecks even if the CAS is not attempted.\n+     *    CAS succeeds.\n@@ -417,1 +413,5 @@\n-     * includes monotonic event bits (SHUTDOWN, STOP, and TERMINATED).\n+     * includes monotonic event bits:\n+     * * SHUTDOWN: no more external tasks accepted; STOP when quiescent\n+     * * STOP: no more tasks run, and deregister all workers\n+     * * CLEANED: all unexecuted tasks have been cancelled\n+     * * TERMINATED: all workers deregistered and all queues cleaned\n@@ -553,6 +553,5 @@\n-     *    activation. Emptiness must be conservatively approximated\n-     *    (by checking if there is apparently at most one existing\n-     *    task) which may result in unnecessary signals.  Also, to\n-     *    reduce resource usages in some cases, at the expense of\n-     *    slower startup in others, activation of an idle thread is\n-     *    preferred over creating a new one, here and elsewhere.\n+     *    activation. Emptiness must be conservatively approximated,\n+     *    which may result in unnecessary signals.  Also, to reduce\n+     *    resource usages in some cases, at the expense of slower\n+     *    startup in others, activation of an idle thread is preferred\n+     *    over creating a new one, here and elsewhere.\n@@ -562,7 +561,13 @@\n-     *    producer, each worker taking its first (since the last\n-     *    activation) task from a queue should propagate a signal if\n-     *    there are more tasks in that queue. This is equivalent to,\n-     *    but generally faster than, arranging the stealer take\n-     *    multiple tasks, re-pushing one or more on its own queue, and\n-     *    signalling (because its queue is empty), also resulting in\n-     *    logarithmic full activation time.\n+     *    producer, each worker taking a task from a queue should\n+     *    propagate a signal if there are more tasks in that\n+     *    queue. This is equivalent to, but generally faster than,\n+     *    arranging the stealer take multiple tasks, re-pushing one or\n+     *    more on its own queue, and signalling (because its queue is\n+     *    empty), also resulting in logarithmic full activation\n+     *    time. If tasks do not not engage in unbounded loops based on\n+     *    the actions of other workers with unknown dependencies loop,\n+     *    this form of proagation can be limited to one signal per\n+     *    activation (phase change). We distinguish the cases by\n+     *    further signalling only if the task is an InterruptibleTask\n+     *    (see below), which are the only supported forms of task that\n+     *    may do so.\n@@ -618,3 +623,6 @@\n-     * signal during deactivation.  Because idle workers are often not\n-     * yet blocked (parked), we use a WorkQueue field to advertise\n-     * that a waiter actually needs unparking upon signal.\n+     * (external) signal during deactivation. To reduce false-alarm\n+     * reactivations while doing so, we scan multiple times\n+     * (analogously to method quiescent()) before trying to\n+     * reactivate.  Because idle workers are often not yet blocked\n+     * (parked), we use a WorkQueue field to advertise that a waiter\n+     * actually needs unparking upon signal.\n@@ -651,16 +659,30 @@\n-     * Termination. A call to shutdownNow invokes tryTerminate to\n-     * atomically set a runState mode bit.  However, the process of\n-     * termination is intrinsically non-atomic. The calling thread, as\n-     * well as other workers thereafter terminating help cancel queued\n-     * tasks and interrupt other workers. These actions race with\n-     * unterminated workers.  By default, workers check for\n-     * termination only when accessing pool state.  This may take a\n-     * while but suffices for structured computational tasks.  But not\n-     * necessarily for others. Class InterruptibleTask (see below)\n-     * further arranges runState checks before executing task bodies,\n-     * and ensures interrupts while terminating. Even so, there are no\n-     * guarantees after an abrupt shutdown that remaining tasks\n-     * complete normally or exceptionally or are cancelled.\n-     * Termination may fail to complete if running tasks ignore both\n-     * task status and interrupts and\/or produce more tasks after\n-     * others that could cancel them have exited.\n+     * Termination. Termination is initiated by setting STOP in one of\n+     * three ways (via methods tryTerminate and quiescent):\n+     * * A call to shutdownNow, in which case all workers are\n+     *   interrupted, first ensuring that the queues array is stable,\n+     *   to avoid missing any workers.\n+     * * A call to shutdown when quiescent, in which case method\n+     *   releaseWaiters is used to dequeue them, at which point they notice\n+     *   STOP state and return from runWorker to deregister();\n+     * * The pool becomes quiescent() sometime after shutdown has\n+     *   been called, in which case releaseWaiters is also used to\n+     *   propagate as they deregister.\n+     * Upon STOP, each worker, as well as external callers to\n+     * tryTerminate (via close() etc) race to set CLEANED, indicating\n+     * that all tasks have been cancelled. The implementation (method\n+     * cleanQueues) balances cases in which there may be many tasks to\n+     * cancel (benefitting from parallelism) versus contention and\n+     * interference when many threads try to poll remaining queues,\n+     * while also avoiding unnecessary rechecks, by using\n+     * pseudorandom scans and giving up upon interference. This may be\n+     * retried by the same caller only when there are no more\n+     * registered workers, using the same criteria as method\n+     * quiescent.  When CLEANED and all workers have deregistered,\n+     * TERMINATED is set, also signalling any caller of\n+     * awaitTermination or close.  Because shutdownNow-based\n+     * termination relies on interrupts, there is no guarantee that\n+     * workers will stop if their tasks ignore interrupts.  Class\n+     * InterruptibleTask (see below) further arranges runState checks\n+     * before executing task bodies, and ensures interrupts while\n+     * terminating. Even so, there are no guarantees because tasks may\n+     * internally enter unbounded loops.\n@@ -851,1 +873,3 @@\n-     * paths.\n+     * paths. The inability to rely on caller-runs may also require\n+     * extra signalling (resulting in scanning and contention) so is\n+     * done only conditionally in methods push and runworker.\n@@ -911,4 +935,2 @@\n-     * Currently, arrays for workers are initialized to be just large\n-     * enough to avoid resizing in most tree-structured tasks, but\n-     * larger for external queues where both false-sharing problems\n-     * and the need for resizing are more common.  (Maintenance note:\n+     * Currently, arrays are initialized to be just large enough to\n+     * avoid resizing in most tree-structured tasks. (Maintenance note:\n@@ -1003,6 +1025,0 @@\n-    \/**\n-     * Initial capacity of work-stealing queue array for external queues.\n-     * Must be a power of two, at least 2. See above.\n-     *\/\n-    static final int INITIAL_EXTERNAL_QUEUE_CAPACITY = 1 << 9;\n-\n@@ -1022,2 +1038,3 @@\n-    static final long TERMINATED      = 1L <<  2;   \/\/ only set if STOP also set\n-    static final long RS_LOCK         = 1L <<  3;   \/\/ lowest seqlock bit\n+    static final long CLEANED         = 1L <<  2;   \/\/ stopped and queues cleared\n+    static final long TERMINATED      = 1L <<  3;   \/\/ only set if STOP also set\n+    static final long RS_LOCK         = 1L <<  4;   \/\/ lowest seqlock bit\n@@ -1253,3 +1270,1 @@\n-            array = new ForkJoinTask<?>[owner == null ?\n-                                        INITIAL_EXTERNAL_QUEUE_CAPACITY :\n-                                        INITIAL_QUEUE_CAPACITY];\n+            array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -1301,4 +1316,6 @@\n-                else if ((room == 0 ||\n-                          a[m & (s - 2)] == null) && \/\/ at most one existing task\n-                         pool != null)\n-                    pool.signalWork();\n+                if ((room == 0 ||        \/\/ pad for InterruptibleTasks\n+                     a[m & (s - ((internal || task == null ||\n+                                  task.getClass().getSuperclass() !=\n+                                  interruptibleTaskClass) ? 1 : 2))] == null) &&\n+                    pool != null)\n+                    pool.signalWork();   \/\/ may have appeared empty\n@@ -1358,2 +1375,1 @@\n-                    while (b == (b = base)) {\n-                        U.loadFence();\n+                    while (b == (b = U.getIntAcquire(this, BASE)))\n@@ -1361,1 +1377,0 @@\n-                    }\n@@ -1385,1 +1400,1 @@\n-            int p = top, s = p - 1, cap, k;\n+            int p = top, s = p - 1, cap; long k;\n@@ -1387,1 +1402,1 @@\n-                a[k = (cap - 1) & s] == task &&\n+                U.getReference(a, k = slotOffset((cap - 1) & s)) == task &&\n@@ -1390,1 +1405,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), task, null)) {\n+                    U.compareAndSetReference(a, k, task, null)) {\n@@ -1424,2 +1439,2 @@\n-            for (int b = base;;) {\n-                int cap, k, nb; ForkJoinTask<?>[] a;\n+            for (int pb = -1, b; ; pb = b) {       \/\/ track progress\n+                ForkJoinTask<?> t; int cap, nb; long k; ForkJoinTask<?>[] a;\n@@ -1428,16 +1443,10 @@\n-                long kp = slotOffset(k = (cap - 1) & b);\n-                int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n-                ForkJoinTask<?> t = a[k];\n-                U.loadFence();\n-                if (b == (b = base)) {             \/\/ else inconsistent\n-                    if (t != null) {\n-                        if (U.compareAndSetReference(a, kp, t, null)) {\n-                            updateBase(nb);\n-                            return t;\n-                        }\n-                        b = base;\n-                    }\n-                    else if (a[sk] == null && a[nk] == null && a[k] == null) {\n-                        if (top - b <= 0)\n-                            break;                 \/\/ empty\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n+                Object u = U.getReference(         \/\/ next slot\n+                    a, slotOffset((cap - 1) & (nb = b + 1)));\n+                if (base != b)                     \/\/ inconsistent\n+                    ;\n+                else if (t == null) {\n+                    if (u == null && top - b <= 0)\n+                        break;                     \/\/ empty\n+                    if (pb == b)\n@@ -1445,1 +1454,4 @@\n-                    }\n+                }\n+                else if (U.compareAndSetReference(a, k, t, null)) {\n+                    updateBase(nb);\n+                    return t;\n@@ -1475,2 +1487,4 @@\n-                    ForkJoinTask<?> t; int k; boolean taken;\n-                    if ((t = a[k = i & m]) == null)\n+                    long k; boolean taken;\n+                    ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReference(\n+                        a, k = slotOffset(i & m));\n+                    if (t == null)\n@@ -1479,1 +1493,0 @@\n-                        long pos = slotOffset(k);\n@@ -1484,1 +1497,1 @@\n-                             U.compareAndSetReference(a, pos, task, null))) {\n+                             U.compareAndSetReference(a, k, task, null))) {\n@@ -1491,1 +1504,1 @@\n-                                    a, pos, (ForkJoinTask<?>)\n+                                    a, k, (ForkJoinTask<?>)\n@@ -1519,2 +1532,2 @@\n-                    ForkJoinTask<?>[] a; ForkJoinTask<?> t; boolean taken;\n-                    int stat, p, s, cap, k;\n+                    ForkJoinTask<?>[] a; boolean taken; Object o;\n+                    int stat, p, s, cap;\n@@ -1527,1 +1540,2 @@\n-                    if ((t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null)\n+                    long k = slotOffset((cap - 1) & (s = (p = top) - 1));\n+                    if (!((o = U.getReference(a, k)) instanceof CountedCompleter))\n@@ -1529,3 +1543,1 @@\n-                    if (!(t instanceof CountedCompleter))\n-                        break;\n-                    CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                    CountedCompleter<?> t = (CountedCompleter<?>)o, f = t;\n@@ -1542,1 +1554,1 @@\n-                         U.compareAndSetReference(a, slotOffset(k), t, null)))\n+                         U.compareAndSetReference(a, k, t, null)))\n@@ -1564,1 +1576,1 @@\n-                ForkJoinTask<?>[] a; int b, cap, k;\n+                ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap; long k;\n@@ -1567,2 +1579,2 @@\n-                ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n-                U.loadFence();\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n@@ -1579,1 +1591,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    U.compareAndSetReference(a, k, t, null)) {\n@@ -1588,0 +1600,12 @@\n+        \/**\n+         * Cancels all local tasks. Called only by owner.\n+         *\/\n+        final void cancelTasks() {\n+            for (ForkJoinTask<?> t; (t = nextLocalTask(0)) != null; ) {\n+                try {\n+                    t.cancel(false);\n+                } catch (Throwable ignore) {\n+                }\n+            }\n+        }\n+\n@@ -1637,0 +1661,10 @@\n+    \/**\n+     * Cached for faster type tests.\n+     *\/\n+    static final Class<?> interruptibleTaskClass;\n+\n+    \/**\n+     * For VirtualThread intrinsics\n+     *\/\n+    private static final JavaLangAccess JLA;\n+\n@@ -1831,25 +1865,7 @@\n-        if ((runState & STOP) != 0L)       \/\/ ensure released\n-            releaseAll();\n-        WorkQueue w = null;\n-        int src = 0, phase = 0;\n-        boolean replaceable = false;\n-        if (wt != null && (w = wt.workQueue) != null) {\n-            phase = w.phase;\n-            if ((src = w.source) != DROPPED) {\n-                w.source = DROPPED;        \/\/ else already dropped\n-                if (phase != 0) {          \/\/ else failed to start\n-                    replaceable = true;\n-                    if (w.top - w.base > 0) {\n-                        ForkJoinTask<?> t; \/\/ cancel remaining tasks\n-                        while ((t = w.nextLocalTask()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if (src != DROPPED) {             \/\/ decrement counts\n-            long c = ctl;\n+        WorkQueue w; int phase;\n+        if ((w = ((wt == null) ? null : wt.workQueue)) == null)\n+            phase = 0;\n+        else if ((phase = w.phase) != 0 && (phase & IDLE) != 0)\n+            releaseWaiters();              \/\/ ensure released\n+        if (w == null || w.source != DROPPED) {\n+            long c = ctl;                  \/\/ decrement counts\n@@ -1861,2 +1877,2 @@\n-        if ((tryTerminate(false, false) & STOP) == 0L && w != null) {\n-            WorkQueue[] qs; int n, i;     \/\/ remove index unless terminating\n+        if (phase != 0 && w != null && (runState & STOP) == 0L) {\n+            WorkQueue[] qs; int n, i;      \/\/ remove index unless terminating\n@@ -1864,6 +1880,5 @@\n-            if ((lockRunState() & STOP) != 0L)\n-                replaceable = false;\n-            else if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                     qs[i = phase & SMASK & (n - 1)] == w) {\n-                qs[i] = null;\n-                stealCount += ns;         \/\/ accumulate steals\n+            if ((lockRunState() & STOP) == 0L &&\n+                (qs = queues) != null && (n = qs.length) > 0 &&\n+                qs[i = phase & SMASK & (n - 1)] == w) {\n+                    qs[i] = null;\n+                    stealCount += ns;      \/\/ accumulate steals\n@@ -1872,2 +1887,5 @@\n-            if (replaceable)\n-                signalWork();\n+        }\n+        if ((tryTerminate(false, false) & STOP) == 0L &&\n+            phase != 0 && w != null && w.source != DROPPED) {\n+            signalWork();                  \/\/ possibly replace\n+            w.cancelTasks();               \/\/ clean queue\n@@ -1919,2 +1937,0 @@\n-     *\n-     * @return current ctl\n@@ -1922,3 +1938,2 @@\n-    private long releaseAll() {\n-        long c = ctl;\n-        for (;;) {\n+    private void releaseWaiters() {\n+        for (long c = ctl;;) {\n@@ -1937,1 +1952,0 @@\n-        return c;\n@@ -1947,1 +1961,1 @@\n-        outer: for (;;) {\n+        for (;;) {\n@@ -1990,2 +2004,2 @@\n-            int cfg = w.config, src = -1, nsteals = 0;\n-            rescan: for (boolean scanned = false;;) {\n+            int cfg = w.config, nsteals = 0, src = -1;\n+            for (;;) {\n@@ -1995,1 +2009,1 @@\n-                    return;\n+                    break;\n@@ -1997,21 +2011,21 @@\n-                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    int j; WorkQueue q;\n-                    if ((q = qs[j = i & (n - 1)]) != null) {\n-                        boolean taken = false;\n-                        for (int pb = -1, b = q.base;;) {\n-                            int cap, k, nb; ForkJoinTask<?>[] a;\n-                            if ((a = q.array) == null || (cap = a.length) <= 0)\n-                                continue rescan;\n-                            long kp = slotOffset(k = (cap - 1) & b);\n-                            int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                            int sk = (b + 2) & (cap - 1); \/\/ 2nd slot ahead\n-                            ForkJoinTask<?> t = a[k];\n-                            U.loadFence();\n-                            if (b != (b = q.base))\n-                                ;                         \/\/ inconsistent\n-                            else if (t == null) {         \/\/ possibly empty\n-                                if (a[sk] == null && a[nk] == null &&\n-                                    a[k] == null) {       \/\/ screen\n-                                    if (q.top - b > 0) {  \/\/ stalled\n-                                        if (!taken)       \/\/ move unless taking\n-                                            continue rescan;\n+                boolean rescan = false;\n+                scan: for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                    if ((q = qs[j = i & (n - 1)]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0) {\n+                        for (int m = cap - 1, pb = -1, b = q.base;;) {\n+                            ForkJoinTask<?> t; long k;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset(m & b));\n+                            if (b != (b = q.base) || t == null ||\n+                                !U.compareAndSetReference(a, k, t, null)) {\n+                                if (a[b & m] == null) {\n+                                    if (rescan)           \/\/ end of run\n+                                        break scan;\n+                                    if (a[(b + 1) & m] == null &&\n+                                        a[(b + 2) & m] == null) {\n+                                        break;            \/\/ probably empty\n+                                    }\n+                                    if (pb == (pb = b)) { \/\/ track progress\n+                                        rescan = true;    \/\/ stalled; reorder scan\n+                                        break scan;\n@@ -2019,4 +2033,0 @@\n-                                    else if (taken)\n-                                        continue rescan;  \/\/ depleted; restart\n-                                    else\n-                                        break;            \/\/ empty\n@@ -2024,2 +2034,0 @@\n-                                if (pb == (pb = b))       \/\/ base unchanged\n-                                    Thread.onSpinWait();\n@@ -2027,2 +2035,0 @@\n-                            else if (!U.compareAndSetReference(a, kp, t, null))\n-                                b = q.base;               \/\/ contended\n@@ -2030,1 +2036,2 @@\n-                                q.base = nb;\n+                                boolean propagate;\n+                                int nb = q.base = b + 1;\n@@ -2032,3 +2039,8 @@\n-                                w.source = j;             \/\/ volatile write\n-                                if (taken != (taken = true) && a[nk] != null)\n-                                    signalWork();         \/\/ propagate signal\n+                                w.source = j;             \/\/ volatile\n+                                rescan = true;\n+                                if (propagate =\n+                                    ((src != (src = j) ||\n+                                      t.getClass().getSuperclass() ==\n+                                      interruptibleTaskClass) &&\n+                                     a[nb & m] != null))\n+                                    signalWork();\n@@ -2036,2 +2048,2 @@\n-                                if ((b = q.base) != nb && src != (src = j))\n-                                    continue rescan;      \/\/ reduce interference\n+                                if ((b = q.base) != nb && !propagate)\n+                                    break scan;          \/\/ reduce interference\n@@ -2042,6 +2054,5 @@\n-                if (!scanned)\n-                    scanned = true;                   \/\/ rescan before deactivate\n-                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n-                    scanned = false;\n-                else\n-                    return;\n+                if (!rescan) {\n+                    if (((phase = deactivate(w, phase)) & IDLE) != 0)\n+                        break;\n+                    src = -1;\n+                }\n@@ -2056,1 +2067,0 @@\n-     * @param r random seed\n@@ -2060,1 +2070,3 @@\n-    private int deactivate(WorkQueue w, int r, int phase) {\n+    private int deactivate(WorkQueue w, int phase) {\n+        if (w == null)                        \/\/ currently impossible\n+            return IDLE;\n@@ -2062,42 +2074,24 @@\n-        if (w != null) {                         \/\/ always true\n-            w.phase = p;\n-            long pc = ctl, qc;\n-            for (;;) {                           \/\/ try to enqueue\n-                w.stackPred = (int)pc;           \/\/ set ctl stack link\n-                qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-                if (pc == (pc = compareAndExchangeCtl(pc, qc))) \/\/ success\n-                    break;\n-                if ((pc & RC_MASK) >= (qc & RC_MASK)) {\n-                    p = w.phase = phase;         \/\/ back out on possible signal\n-                    break;\n-                }\n-            }\n-            if (p != phase &&                    \/\/ check quiescent termination\n-                ((runState & SHUTDOWN) == 0L || quiescent() <= 0)) {\n-                WorkQueue[] qs;\n-                int spins = ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS + 1;\n-                while ((p = w.phase) != activePhase && --spins > 0)\n-                    Thread.onSpinWait();         \/\/ reduce flailing\n-                if (p != activePhase && (qs = queues) != null) {\n-                    int n = qs.length, step = (r >>> 16) | 1;\n-                    for (int i = r, l = n; l > 0; --l, i += step) {\n-                        WorkQueue q;             \/\/ check for missed signals\n-                        if ((q = qs[i & (n - 1)]) != null &&\n-                            q.top - q.base > 0) {\n-                            if (ctl == qc && compareAndSetCtl(qc, pc)) {\n-                                p = w.phase = activePhase;\n-                                break;           \/\/ self-signal\n-                            }\n-                            if ((p = w.phase) == activePhase)\n-                                break;\n-                        }\n-                    }\n-                    if (p != activePhase) {\n-                        long delay = (((qc & RC_MASK) > 0L) ? 0L :\n-                                      (w.source != INVALID_ID) ? keepAlive :\n-                                      TIMEOUT_SLOP); \/\/ minimal delay if cascade\n-                        if ((p = w.phase) != activePhase)\n-                            p = awaitWork(w, p, delay); \/\/ block, drop, or exit\n-                    }\n-                }\n-            }\n+        long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+        w.stackPred = (int)pc;                \/\/ set ctl stack link\n+        w.phase = p;\n+        if (!compareAndSetCtl(pc, qc))        \/\/ try to enqueue\n+            return w.phase = phase;           \/\/ back out on possible signal\n+        int ac = (short)(qc >>> RC_SHIFT), n; long e; WorkQueue[] qs;\n+        if (((e = runState) & STOP) != 0L ||\n+            ((e & SHUTDOWN) != 0L && ac == 0 && quiescent() > 0) ||\n+            (qs = queues) == null || (n = qs.length) <= 0)\n+            return IDLE;                      \/\/ terminating\n+        int prechecks = Math.min(ac, 2);      \/\/ reactivation threshold\n+        for (int k = Math.max(n + (n << 1), SPIN_WAITS << 1);;) {\n+            WorkQueue q; int cap; ForkJoinTask<?>[] a;\n+            if (w.phase == activePhase)\n+                return activePhase;\n+            if (--k < 0)\n+                return awaitWork(w, p);       \/\/ block, drop, or exit\n+            if ((k & 1) != 0)\n+                Thread.onSpinWait();          \/\/ interleave spins and rechecks\n+            else if ((q = qs[k & (n - 1)]) != null &&\n+                     (a = q.array) != null && (cap = a.length) > 0 &&\n+                     a[q.base & (cap - 1)] != null && --prechecks < 0 &&\n+                     ctl == qc && compareAndSetCtl(qc, pc))\n+                return w.phase = activePhase; \/\/ reactivate\n@@ -2105,1 +2099,0 @@\n-        return p;\n@@ -2113,1 +2106,0 @@\n-     * @param delay if nonzero keepAlive before trimming if quiescent\n@@ -2116,1 +2108,1 @@\n-    private int awaitWork(WorkQueue w, int p, long delay) {\n+    private int awaitWork(WorkQueue w, int p) {\n@@ -2118,0 +2110,7 @@\n+            long deadline;                     \/\/ for idle timeouts\n+            if ((ctl & RC_MASK) > 0L)\n+                deadline = 0L;\n+            else if ((deadline =\n+                      (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n+                      System.currentTimeMillis()) == 0L)\n+                deadline = 1L;                 \/\/ avoid zero\n@@ -2119,11 +2118,7 @@\n-            LockSupport.setCurrentBlocker(this);\n-            long deadline = (delay == 0L ? 0L :\n-                             delay + System.currentTimeMillis());\n-            w.parking = 1;                 \/\/ enable unpark\n-            while ((p = w.phase) != activePhase) {\n-                boolean trimmable = false; int trim;\n-                Thread.interrupted();      \/\/ clear status\n-                if ((runState & STOP) != 0L)\n-                    break;\n-                if (deadline != 0L) {\n-                    if ((trim = tryTrim(w, p, deadline)) > 0)\n+            if ((p = w.phase) != activePhase && (runState & STOP) == 0L) {\n+                LockSupport.setCurrentBlocker(this);\n+                w.parking = 1;                 \/\/ enable unpark\n+                while ((p = w.phase) != activePhase) {\n+                    boolean trimmable = false; int trim;\n+                    Thread.interrupted();      \/\/ clear status\n+                    if ((runState & STOP) != 0L)\n@@ -2131,4 +2126,9 @@\n-                    else if (trim < 0)\n-                        deadline = 0L;\n-                    else\n-                        trimmable = true;\n+                    if (deadline != 0L) {\n+                        if ((trim = tryTrim(w, p, deadline)) > 0)\n+                            break;\n+                        else if (trim < 0)\n+                            deadline = 0L;\n+                        else\n+                            trimmable = true;\n+                    }\n+                    U.park(trimmable, deadline);\n@@ -2136,1 +2136,2 @@\n-                U.park(trimmable, deadline);\n+                w.parking = 0;\n+                LockSupport.setCurrentBlocker(null);\n@@ -2138,2 +2139,0 @@\n-            w.parking = 0;\n-            LockSupport.setCurrentBlocker(null);\n@@ -2294,1 +2293,3 @@\n-                            int sq = q.source, b, cap, k; ForkJoinTask<?>[] a;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            boolean eligible = false;\n+                            int sq = q.source, b, cap; long k;\n@@ -2297,3 +2298,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2318,2 +2318,2 @@\n-                            if (q.source == sq && q.base == b && a[k] == t) {\n-                                int nb = b + 1, nk = nb & (cap - 1);\n+                            if (q.source == sq && q.base == b &&\n+                                U.getReference(a, k) == t) {\n@@ -2321,2 +2321,1 @@\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2326,4 +2325,3 @@\n-                                if (U.compareAndSetReference(\n-                                        a, slotOffset(k), t, null)) {\n-                                    q.updateBase(nb);\n-                                    w.source = j;\n+                                if (U.compareAndSetReference(a, k, t, null)) {\n+                                    q.base = b + 1;\n+                                    w.source = j;    \/\/ volatile write\n@@ -2376,1 +2374,3 @@\n-                            ForkJoinTask<?>[] a; int b, cap, k;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            int b, cap, nb; long k;\n+                            boolean eligible = false;\n@@ -2379,3 +2379,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2396,1 +2395,0 @@\n-                                int nb = b + 1, nk = nb & (cap - 1);\n@@ -2399,2 +2397,2 @@\n-                                            a, slotOffset(k), t, null)) {\n-                                        q.updateBase(nb);\n+                                            a, k, t, null)) {\n+                                        q.updateBase(b + 1);\n@@ -2406,3 +2404,2 @@\n-                                else if (a[k] == t) {\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                else if (U.getReference(a, k) == t) {\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2461,1 +2458,2 @@\n-                        ForkJoinTask<?>[] a; int b, cap, k;\n+                        ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                        int b, cap; long k;\n@@ -2464,1 +2462,2 @@\n-                        ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                        t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                            a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2467,2 +2466,1 @@\n-                        U.loadFence();\n-                        if (q.base == b && a[k] == t) {\n+                        if (q.base == b && U.getReference(a, k) == t) {\n@@ -2481,4 +2479,3 @@\n-                            if (U.compareAndSetReference(\n-                                    a, slotOffset(k), t, null)) {\n-                                q.updateBase(nb);\n-                                w.source = j;\n+                            if (U.compareAndSetReference(a, k, t, null)) {\n+                                q.base = nb;\n+                                w.source = j; \/\/ volatile write\n@@ -2630,1 +2627,0 @@\n-        tryTerminate(false, false);\n@@ -2647,1 +2643,0 @@\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -2767,11 +2762,11 @@\n-        long e = runState, isShutdown;\n-        if ((e & STOP) == 0L) {\n-            if (now)\n-                runState = e = (lockRunState() + RS_LOCK) | STOP | SHUTDOWN;\n-            else if ((isShutdown = (e & SHUTDOWN)) != 0 || enable) {\n-                if (isShutdown == 0)\n-                    getAndBitwiseOrRunState(SHUTDOWN);\n-                if (quiescent() > 0)\n-                    e = runState;\n-            }\n-            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n+        long e, isShutdown, ps;\n+        if (((e = runState) & TERMINATED) != 0L)\n+            now = false;\n+        else if ((e & STOP) != 0L)\n+            now = true;\n+        else if (now) {\n+            if (((ps = getAndBitwiseOrRunState(SHUTDOWN|STOP) & STOP)) == 0L) {\n+                if ((ps & RS_LOCK) != 0L) {\n+                    spinLockRunState(); \/\/ ensure queues array stable after stop\n+                    unlockRunState();\n+                }\n@@ -2779,0 +2774,1 @@\n+            }\n@@ -2780,15 +2776,26 @@\n-        if ((e & (STOP | TERMINATED)) == STOP) { \/\/ help cancel tasks\n-            if ((ctl & RC_MASK) > 0L) {          \/\/ unless all inactive\n-                int r = (int)Thread.currentThread().threadId();\n-                WorkQueue[] qs = queues;         \/\/ stagger traversals\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int l = n; l > 0; --l, ++r) {\n-                    WorkQueue q; ForkJoinTask<?> t;\n-                    if ((q = qs[r & (n - 1)]) != null &&\n-                        q.source != DROPPED) {\n-                        while ((t = q.poll()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n-                        }\n+        else if ((isShutdown = (e & SHUTDOWN)) != 0L || enable) {\n+            if (isShutdown == 0L)\n+                getAndBitwiseOrRunState(SHUTDOWN);\n+            if (quiescent() > 0)\n+                now = true;\n+        }\n+        if (now) {\n+            releaseWaiters();\n+            for (;;) {\n+                if (((e = runState) & CLEANED) == 0L) {\n+                    boolean clean = cleanQueues();\n+                    if (((e = runState) & CLEANED) == 0L && clean)\n+                        e = getAndBitwiseOrRunState(CLEANED) | CLEANED;\n+                }\n+                if ((e & TERMINATED) != 0L)\n+                    break;\n+                if (ctl != 0L) \/\/ else loop if didn't finish cleaning\n+                    break;\n+                if ((e & CLEANED) != 0L) {\n+                    e |= TERMINATED;\n+                    if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n+                        CountDownLatch done; SharedThreadContainer ctr;\n+                        if ((done = termination) != null)\n+                            done.countDown();\n+                        if ((ctr = container) != null)\n+                            ctr.close();\n@@ -2796,0 +2803,1 @@\n+                    break;\n@@ -2798,8 +2806,39 @@\n-            if (((e = runState) & TERMINATED) == 0L && ctl == 0L) {\n-                e |= TERMINATED;\n-                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n-                    CountDownLatch done; SharedThreadContainer ctr;\n-                    if ((done = termination) != null)\n-                        done.countDown();\n-                    if ((ctr = container) != null)\n-                        ctr.close();\n+        }\n+        return e;\n+    }\n+\n+    \/**\n+     * Scans queues in a psuedorandom order based on thread id,\n+     * cancelling tasks until empty, or returning early upon\n+     * interference or still-active external queues, in which case\n+     * other calls will finish cancellation.\n+     *\n+     * @return true if all queues empty\n+     *\/\n+    private boolean cleanQueues() {\n+        int r = (int)Thread.currentThread().threadId();\n+        r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n+        int step = (r >>> 16) | 1;                \/\/ randomize traversals\n+        WorkQueue[] qs = queues;\n+        int n = (qs == null) ? 0 : qs.length;\n+        for (int l = n; l > 0; --l, r += step) {\n+            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+            if ((q = qs[r & (n - 1)]) != null &&\n+                (a = q.array) != null && (cap = a.length) > 0) {\n+                for (;;) {\n+                    ForkJoinTask<?> t; int b; long k;\n+                    t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                        a, k = slotOffset((cap - 1) & (b = q.base)));\n+                    if (q.base == b && t != null &&\n+                        U.compareAndSetReference(a, k, t, null)) {\n+                        q.updateBase(b + 1);\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n+                        }\n+                    }\n+                    else if ((q.phase & (IDLE|1)) == 0 ||\n+                             q.top - q.base > 0)\n+                        return false;             \/\/ incomplete\n+                    else\n+                        break;\n@@ -2809,1 +2848,1 @@\n-        return e;\n+        return true;\n@@ -2821,2 +2860,1 @@\n-            if ((q = qs[i]) != null && (o = q.owner) != null && o != current &&\n-                q.source != DROPPED) {\n+            if ((q = qs[i]) != null && (o = q.owner) != null && o != current) {\n@@ -4062,0 +4100,2 @@\n+        interruptibleTaskClass = ForkJoinTask.InterruptibleTask.class;\n+        JLA = SharedSecrets.getJavaLangAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":360,"deletions":320,"binary":false,"changes":680,"status":"modified"}]}