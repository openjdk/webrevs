{"files":[{"patch":"@@ -413,18 +413,19 @@\n-     * includes monotonic event bits (SHUTDOWN, STOP, and TERMINATED).\n-     * The version tags enable detection of state changes (by\n-     * comparing two reads) modulo bit wraparound. The bit range in\n-     * each case suffices for purposes of determining quiescence,\n-     * termination, avoiding ABA-like errors, and signal control, most\n-     * of which are ultimately based on at most 15bit ranges (due to\n-     * 32767 max total workers). RunState updates do not need to be\n-     * atomic with respect to ctl updates, but because they are not,\n-     * some care is required to avoid stalls. The seqLock properties\n-     * detect changes and conditionally upgrade to coordinate with\n-     * updates. It is typically held for less than a dozen\n-     * instructions unless the queue array is being resized, during\n-     * which contention is rare. To be conservative, lockRunState is\n-     * implemented as a spin\/sleep loop. Here and elsewhere spin\n-     * constants are short enough to apply even on systems with few\n-     * available processors.  In addition to checking pool status,\n-     * reads of runState sometimes serve as acquire fences before\n-     * reading other fields.\n+     * includes monotonic event bits (SHUTDOWN, STOP, CLEANED (when\n+     * all queues are knowm to be empty after stopping) and\n+     * TERMINATED).  The version tags enable detection of state\n+     * changes (by comparing two reads) modulo bit wraparound. The bit\n+     * range in each case suffices for purposes of determining\n+     * quiescence, termination, avoiding ABA-like errors, and signal\n+     * control, most of which are ultimately based on at most 15bit\n+     * ranges (due to 32767 max total workers). RunState updates do\n+     * not need to be atomic with respect to ctl updates, but because\n+     * they are not, some care is required to avoid stalls. The\n+     * seqLock properties detect changes and conditionally upgrade to\n+     * coordinate with updates. It is typically held for less than a\n+     * dozen instructions unless the queue array is being resized,\n+     * during which contention is rare. To be conservative,\n+     * lockRunState is implemented as a spin\/sleep loop. Here and\n+     * elsewhere spin constants are short enough to apply even on\n+     * systems with few available processors.  In addition to checking\n+     * pool status, reads of runState sometimes serve as acquire\n+     * fences before reading other fields.\n@@ -475,1 +476,2 @@\n-     * another at the same index.\n+     * another at the same index. During termination, worker queue\n+     * array updates are disabled.\n@@ -658,3 +660,3 @@\n-     * tasks and interrupt other workers (staggering queues and\n-     * backing off on interference to avoid contention while doing\n-     * so-- see method helpTerminate). These actions race with\n+     * tasks until runState is marked as CLEANED (staggering queues\n+     * and backing off on interference to avoid contention while doing\n+     * so-- see method cleanQueues). These actions race with\n@@ -1021,2 +1023,3 @@\n-    static final long TERMINATED      = 1L <<  2;   \/\/ only set if STOP also set\n-    static final long RS_LOCK         = 1L <<  3;   \/\/ lowest seqlock bit\n+    static final long CLEANED         = 1L <<  2;   \/\/ stopped and queues cleared\n+    static final long TERMINATED      = 1L <<  3;   \/\/ only set if STOP also set\n+    static final long RS_LOCK         = 1L <<  4;   \/\/ lowest seqlock bit\n@@ -1036,1 +1039,0 @@\n-    static final int DROPPING         = DROPPED | INVALID_ID;\n@@ -1583,0 +1585,12 @@\n+        \/**\n+         * Cancels all local tasks. Called only by owner.\n+         *\/\n+        final void cancelTasks() {\n+            for (ForkJoinTask<?> t; (t = nextLocalTask(0)) != null; ) {\n+                try {\n+                    t.cancel(false);\n+                } catch (Throwable ignore) {\n+                }\n+            }\n+        }\n+\n@@ -1832,37 +1846,7 @@\n-        if ((runState & STOP) != 0L)     \/\/ ensure released\n-            releaseAll();\n-        WorkQueue w = null;\n-        int src = 0, phase = 0;\n-        boolean replaceable = false;\n-        if (wt != null && (w = wt.workQueue) != null &&\n-            (phase = w.phase) != 0) {    \/\/ else failed to start\n-            if (((src = w.source) & DROPPED) == 0) {\n-                w.source = DROPPED;      \/\/ else already dropped\n-                replaceable = true;\n-                ForkJoinTask<?> t;       \/\/ cancel remaining tasks\n-                while ((t = w.nextLocalTask(0)) != null) {\n-                    try {\n-                        t.cancel(false);\n-                    } catch (Throwable ignore) {\n-                    }\n-                }\n-            }\n-            boolean locked = false;      \/\/ OK to skip on contention if stopping\n-            long ns = w.nsteals & 0xffffffffL, s;\n-            if (((s = runState) & RS_LOCK) == 0L && casRunState(s, s + RS_LOCK))\n-                locked = true;\n-            else if ((s & STOP) == 0L) {\n-                spinLockRunState();\n-                locked = true;\n-            }\n-            if (locked) {\n-                WorkQueue[] qs; int n, i;\n-                stealCount += ns;         \/\/ accumulate steals\n-                if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                    qs[i = phase & SMASK & (n - 1)] == w)\n-                    qs[i] = null;         \/\/ remove index\n-                unlockRunState();\n-            }\n-        }\n-        if (src != DROPPED) {            \/\/ decrement counts\n-            long c = ctl;\n+        WorkQueue w; int phase;\n+        if ((w = ((wt == null) ? null : wt.workQueue)) == null)\n+            phase = 0;\n+        else if ((phase = w.phase) != 0 && (phase & IDLE) != 0)\n+            releaseAll();                  \/\/ ensure released\n+        if (w == null || w.source != DROPPED) {\n+            long c = ctl;                  \/\/ decrement counts\n@@ -1874,2 +1858,15 @@\n-        if ((tryTerminate(false, false) & STOP) == 0L && replaceable)\n-            signalWork();\n+        if ((tryTerminate(false, false) & STOP) == 0L && phase != 0 &&\n+            w != null) {\n+            WorkQueue[] qs; int n, i;      \/\/ remove index unless terminating\n+            w.cancelTasks();               \/\/ clean queue\n+            long ns = w.nsteals & 0xffffffffL;\n+            if ((lockRunState() & STOP) == 0L &&\n+                (qs = queues) != null && (n = qs.length) > 0 &&\n+                qs[i = phase & SMASK & (n - 1)] == w) {\n+                qs[i] = null;\n+                stealCount += ns;          \/\/ accumulate steals\n+            }\n+            unlockRunState();\n+            if (w.source != DROPPED && (runState & STOP) == 0L)\n+                signalWork();              \/\/ possibly replace\n+        }\n@@ -1920,2 +1917,0 @@\n-     *\n-     * @return current ctl\n@@ -1923,3 +1918,2 @@\n-    private long releaseAll() {\n-        long c = ctl;\n-        for (;;) {\n+    private void releaseAll() {\n+        for (long c = ctl;;) {\n@@ -1933,1 +1927,0 @@\n-                v.source = DROPPING; \/\/ avoid unnecessary shutdown overhead\n@@ -1939,1 +1932,0 @@\n-        return c;\n@@ -1944,3 +1936,3 @@\n-     * @return nonnegative if terminating or all workers are inactive\n-     * and submission queues are empty and unlocked; if so, setting\n-     * STOP if shutdown is enabled and returning greater than 1, else 0.\n+     * @return positive if stopping, nonnegative if terminating or all\n+     * workers are inactive and submission queues are empty and\n+     * unlocked; if so, setting STOP if shutdown is enabled\n@@ -1949,1 +1941,1 @@\n-        outer: for (;;) {\n+        for (;;) {\n@@ -1976,1 +1968,1 @@\n-                    return 2;                             \/\/ enable termination\n+                    return 1;                             \/\/ enable termination\n@@ -2754,1 +2746,0 @@\n-            boolean startTerminating = false;\n@@ -2758,1 +2749,1 @@\n-                    startTerminating = true;\n+                    interruptAll();\n@@ -2763,7 +2754,2 @@\n-                if (quiescent() > 1)\n-                    startTerminating = true;\n-            }\n-            if (startTerminating) {\n-                releaseAll();\n-                if (now)\n-                    interruptAll();\n+                if (quiescent() > 0)\n+                    now = true;\n@@ -2771,1 +2757,2 @@\n-            e = runState;\n+            if (now)\n+                e = runState;\n@@ -2773,12 +2760,22 @@\n-        while ((e & (STOP | TERMINATED)) == STOP) {\n-            boolean clean = helpTerminate();\n-            if (((e = runState) & TERMINATED) != 0L || ctl != 0L)\n-                break;\n-            if (clean) {\n-                e |= TERMINATED;\n-                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n-                    CountDownLatch done; SharedThreadContainer ctr;\n-                    if ((done = termination) != null)\n-                        done.countDown();\n-                    if ((ctr = container) != null)\n-                        ctr.close();\n+        if ((e & (STOP | TERMINATED)) == STOP) {\n+            releaseAll();\n+            for (;;) {\n+                if (((e = runState) & CLEANED) == 0L) {\n+                    boolean clean = cleanQueues();\n+                    if (((e = runState) & CLEANED) == 0L && clean)\n+                        e = getAndBitwiseOrRunState(CLEANED) | CLEANED;\n+                }\n+                if ((e & TERMINATED) != 0L)\n+                    break;\n+                if (ctl != 0L)\n+                    break;\n+                if ((e & CLEANED) != 0L) {\n+                    e |= TERMINATED;\n+                    if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n+                        CountDownLatch done; SharedThreadContainer ctr;\n+                        if ((done = termination) != null)\n+                            done.countDown();\n+                        if ((ctr = container) != null)\n+                            ctr.close();\n+                    }\n+                    break;\n@@ -2786,1 +2783,0 @@\n-                break;\n@@ -2795,1 +2791,2 @@\n-     * interference (in which case others will finish cancellation).\n+     * interference or still-active external queues, in which case\n+     * other calls will finish cancellation.\n@@ -2797,1 +2794,1 @@\n-     * @return true if all queues are empty\n+     * @return true if all queues empty\n@@ -2799,1 +2796,1 @@\n-    private boolean helpTerminate() {\n+    private boolean cleanQueues() {\n@@ -2806,1 +2803,1 @@\n-            WorkQueue q;  ForkJoinTask<?>[] a; int cap;\n+            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n@@ -2821,2 +2818,3 @@\n-                    else if (q.top - q.base > 0)\n-                        return false;             \/\/ interference\n+                    else if ((q.phase & (IDLE|1)) == 0 ||\n+                             q.top - q.base > 0)\n+                        return false;             \/\/ incomplete\n@@ -2840,2 +2838,1 @@\n-            if ((q = qs[i]) != null && (o = q.owner) != null && o != current &&\n-                (q.source & DROPPED) == 0) {\n+            if ((q = qs[i]) != null && (o = q.owner) != null && o != current) {\n@@ -2848,0 +2845,1 @@\n+        \/\/        releaseAll();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":105,"deletions":107,"binary":false,"changes":212,"status":"modified"}]}