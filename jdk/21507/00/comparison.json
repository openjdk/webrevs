{"files":[{"patch":"@@ -265,4 +265,1 @@\n-     * ordered writes of various kinds for updates, but usually use\n-     * explicit load fences for reads, to cover access of several\n-     * fields of possibly several objects without further constraining\n-     * read-by-read ordering.\n+     * ordered writes of various kinds for accesses when required.\n@@ -308,2 +305,1 @@\n-     *    CAS succeeds, but uses an explicit acquire fence to support\n-     *    the following rechecks even if the CAS is not attempted.\n+     *    CAS succeeds\n@@ -553,5 +549,5 @@\n-     *    (by checking if there is apparently at most one existing\n-     *    task) which may result in unnecessary signals.  Also, to\n-     *    reduce resource usages in some cases, at the expense of\n-     *    slower startup in others, activation of an idle thread is\n-     *    preferred over creating a new one, here and elsewhere.\n+     *    (by checking preceeding queue array slot, not inidices)\n+     *    which may result in unnecessary signals.  Also, to reduce\n+     *    resource usages in some cases, at the expense of slower\n+     *    startup in others, activation of an idle thread is preferred\n+     *    over creating a new one, here and elsewhere.\n@@ -858,1 +854,1 @@\n-     * exceptions is preferred to throwing InterruptedExceptions,\n+     * exceptions is preferred to throwing InterruptedExeptions,\n@@ -910,4 +906,2 @@\n-     * Currently, arrays for workers are initialized to be just large\n-     * enough to avoid resizing in most tree-structured tasks, but\n-     * larger for external queues where both false-sharing problems\n-     * and the need for resizing are more common.  (Maintenance note:\n+     * Currently, arrays are initialized to be just large enough to\n+     * avoid resizing in most tree-structured tasks. (Maintenance note:\n@@ -1002,6 +996,0 @@\n-    \/**\n-     * Initial capacity of work-stealing queue array for external queues.\n-     * Must be a power of two, at least 2. See above.\n-     *\/\n-    static final int INITIAL_EXTERNAL_QUEUE_CAPACITY = 1 << 9;\n-\n@@ -1252,3 +1240,1 @@\n-            array = new ForkJoinTask<?>[owner == null ?\n-                                        INITIAL_EXTERNAL_QUEUE_CAPACITY :\n-                                        INITIAL_QUEUE_CAPACITY];\n+            array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n@@ -1284,12 +1270,4 @@\n-            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n-                if ((room = (m = cap - 1) - (s - b)) >= 0) {\n-                    top = s + 1;\n-                    long pos = slotOffset(m & s);\n-                    if (!internal)\n-                        U.putReference(a, pos, task);       \/\/ inside lock\n-                    else\n-                        U.getAndSetReference(a, pos, task); \/\/ fully fenced\n-                    if (room == 0)                          \/\/ resize\n-                        growArray(a, cap, s);\n-                }\n+            int s = top++, b = base, m, cap, room; ForkJoinTask<?>[] a;\n+            if ((a = array) == null || (cap = a.length) <= 0 ||\n+                (room = (m = cap - 1) - (s - b)) < 0) {\n+                top = s;                          \/\/ back out\n@@ -1298,6 +1276,1 @@\n-                if (room < 0)\n-                    throw new RejectedExecutionException(\"Queue capacity exceeded\");\n-                else if ((room == 0 ||\n-                          a[m & (s - 2)] == null) && \/\/ at most one existing task\n-                         pool != null)\n-                    pool.signalWork();\n+                throw new RejectedExecutionException(\"Queue capacity exceeded\");\n@@ -1305,0 +1278,11 @@\n+            long k = slotOffset(m & s), pk = slotOffset(m & (s - 1));\n+            if (!internal)\n+                U.putReference(a, k, task);       \/\/ inside lock\n+            else\n+                U.getAndSetReference(a, k, task); \/\/ fully fenced\n+            if (room == 0)                        \/\/ resize\n+                growArray(a, cap, s);\n+            if (!internal)\n+                unlockPhase();\n+            if ((room == 0 || U.getReference(a, pk) == null) && pool != null)\n+                pool.signalWork();                \/\/ may have appeared empty\n@@ -1357,2 +1341,1 @@\n-                    while (b == (b = base)) {\n-                        U.loadFence();\n+                    while (b == (b = U.getIntAcquire(this, BASE)))\n@@ -1360,1 +1343,0 @@\n-                    }\n@@ -1384,1 +1366,1 @@\n-            int p = top, s = p - 1, cap, k;\n+            int p = top, s = p - 1, cap; long k;\n@@ -1386,1 +1368,1 @@\n-                a[k = (cap - 1) & s] == task &&\n+                U.getReference(a, k = slotOffset((cap - 1) & s)) == task &&\n@@ -1389,1 +1371,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), task, null)) {\n+                    U.compareAndSetReference(a, k, task, null)) {\n@@ -1423,2 +1405,2 @@\n-            for (int b = base;;) {\n-                int cap, k, nb; ForkJoinTask<?>[] a;\n+            for (int pb = -1, b; ; pb = b) {       \/\/ track progress\n+                ForkJoinTask<?> t; int cap, nb; long k; ForkJoinTask<?>[] a;\n@@ -1427,16 +1409,10 @@\n-                long kp = slotOffset(k = (cap - 1) & b);\n-                int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                int sk = (b + 2) & (cap - 1);      \/\/ 2nd slot ahead\n-                ForkJoinTask<?> t = a[k];\n-                U.loadFence();\n-                if (b == (b = base)) {             \/\/ else inconsistent\n-                    if (t != null) {\n-                        if (U.compareAndSetReference(a, kp, t, null)) {\n-                            updateBase(nb);\n-                            return t;\n-                        }\n-                        b = base;\n-                    }\n-                    else if (a[sk] == null && a[nk] == null && a[k] == null) {\n-                        if (top - b <= 0)\n-                            break;                 \/\/ empty\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n+                Object u = U.getReference(         \/\/ next slot\n+                    a, slotOffset((cap - 1) & (nb = b + 1)));\n+                if (base != b)                     \/\/ inconsistent\n+                    ;\n+                else if (t == null) {\n+                    if (u == null && top - b <= 0)\n+                        break;                     \/\/ empty\n+                    if (pb == b)\n@@ -1444,1 +1420,4 @@\n-                    }\n+                }\n+                else if (U.compareAndSetReference(a, k, t, null)) {\n+                    updateBase(nb);\n+                    return t;\n@@ -1474,2 +1453,4 @@\n-                    ForkJoinTask<?> t; int k; boolean taken;\n-                    if ((t = a[k = i & m]) == null)\n+                    long k; boolean taken;\n+                    ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReference(\n+                        a, k = slotOffset(i & m));\n+                    if (t == null)\n@@ -1478,1 +1459,0 @@\n-                        long pos = slotOffset(k);\n@@ -1483,1 +1463,1 @@\n-                             U.compareAndSetReference(a, pos, task, null))) {\n+                             U.compareAndSetReference(a, k, task, null))) {\n@@ -1490,1 +1470,1 @@\n-                                    a, pos, (ForkJoinTask<?>)\n+                                    a, k, (ForkJoinTask<?>)\n@@ -1518,2 +1498,2 @@\n-                    ForkJoinTask<?>[] a; ForkJoinTask<?> t; boolean taken;\n-                    int stat, p, s, cap, k;\n+                    ForkJoinTask<?>[] a; boolean taken; Object o;\n+                    int stat, p, s, cap;\n@@ -1526,1 +1506,2 @@\n-                    if ((t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null)\n+                    long k = slotOffset((cap - 1) & (s = (p = top) - 1));\n+                    if (!((o = U.getReference(a, k)) instanceof CountedCompleter))\n@@ -1528,3 +1509,1 @@\n-                    if (!(t instanceof CountedCompleter))\n-                        break;\n-                    CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                    CountedCompleter<?> t = (CountedCompleter<?>)o, f = t;\n@@ -1541,1 +1520,1 @@\n-                         U.compareAndSetReference(a, slotOffset(k), t, null)))\n+                         U.compareAndSetReference(a, k, t, null)))\n@@ -1563,1 +1542,1 @@\n-                ForkJoinTask<?>[] a; int b, cap, k;\n+                ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap; long k;\n@@ -1566,2 +1545,2 @@\n-                ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n-                U.loadFence();\n+                t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, k = slotOffset((cap - 1) & (b = base)));\n@@ -1578,1 +1557,1 @@\n-                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    U.compareAndSetReference(a, k, t, null)) {\n@@ -1831,1 +1810,1 @@\n-            releaseAll();\n+            reactivate(true);\n@@ -1841,7 +1820,5 @@\n-                    if (w.top - w.base > 0) {\n-                        ForkJoinTask<?> t; \/\/ cancel remaining tasks\n-                        while ((t = w.nextLocalTask()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n+                    ForkJoinTask<?> t;     \/\/ cancel remaining tasks\n+                    while ((t = w.nextLocalTask(0)) != null) {\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n@@ -1917,1 +1894,1 @@\n-     * Releases all waiting workers. Called only during shutdown.\n+     * Releases one or all waiting workers\n@@ -1921,1 +1898,1 @@\n-    private long releaseAll() {\n+    private long reactivate(boolean all) {\n@@ -1934,0 +1911,2 @@\n+                if (!all)\n+                    break;\n@@ -1989,2 +1968,2 @@\n-            int cfg = w.config, src = -1, nsteals = 0;\n-            rescan: for (boolean scanned = false;;) {\n+            int cfg = w.config, nsteals = 0, src = -1;\n+            for (;;) {\n@@ -1994,1 +1973,1 @@\n-                    return;\n+                    break;\n@@ -1996,26 +1975,19 @@\n-                for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n-                    int j; WorkQueue q;\n-                    if ((q = qs[j = i & (n - 1)]) != null) {\n-                        boolean taken = false;\n-                        for (int pb = -1, b = q.base;;) {\n-                            int cap, k, nb; ForkJoinTask<?>[] a;\n-                            if ((a = q.array) == null || (cap = a.length) <= 0)\n-                                continue rescan;\n-                            long kp = slotOffset(k = (cap - 1) & b);\n-                            int nk = (nb = b + 1) & (cap - 1); \/\/ next slot\n-                            int sk = (b + 2) & (cap - 1); \/\/ 2nd slot ahead\n-                            ForkJoinTask<?> t = a[k];\n-                            U.loadFence();\n-                            if (b != (b = q.base))\n-                                ;                         \/\/ inconsistent\n-                            else if (t == null) {         \/\/ possibly empty\n-                                if (a[sk] == null && a[nk] == null &&\n-                                    a[k] == null) {       \/\/ screen\n-                                    if (q.top - b > 0) {  \/\/ stalled\n-                                        if (!taken)       \/\/ move unless taking\n-                                            continue rescan;\n-                                    }\n-                                    else if (taken)\n-                                        continue rescan;  \/\/ depleted; restart\n-                                    else\n-                                        break;            \/\/ empty\n+                boolean rescan = false;\n+                scan: for (int l = n; l > 0; --l, i += step) {  \/\/ scan queues\n+                    int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n+                    if ((q = qs[j = i & (n - 1)]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0) {\n+                        for (int pb = -1, b; ; pb = b) {  \/\/ track progress\n+                            ForkJoinTask<?> t; int nb; long k, nk;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n+                            Object u = U.getReference(    \/\/ next slot\n+                                a, nk = slotOffset((cap - 1) & (nb = b + 1)));\n+                            if (q.base != b)              \/\/ inconsistent\n+                                ;\n+                            else if (t == null) {\n+                                if (u == null && q.top - b <= 0)\n+                                    break;                \/\/ empty\n+                                if (pb == b) {\n+                                    rescan = true;        \/\/ stalled; revisit\n+                                    break scan;\n@@ -2023,2 +1995,0 @@\n-                                if (pb == (pb = b))       \/\/ base unchanged\n-                                    Thread.onSpinWait();\n@@ -2026,3 +1996,1 @@\n-                            else if (!U.compareAndSetReference(a, kp, t, null))\n-                                b = q.base;               \/\/ contended\n-                            else {\n+                            else if (U.compareAndSetReference(a, k, t, null)) {\n@@ -2031,3 +1999,5 @@\n-                                w.source = j;             \/\/ volatile write\n-                                if (taken != (taken = true) && a[nk] != null)\n-                                    signalWork();         \/\/ propagate signal\n+                                w.source = j;             \/\/ volatile\n+                                rescan = true;\n+                                if (src != (src = j) &&\n+                                    U.getReferenceVolatile(a, nk) != null)\n+                                    signalWork();         \/\/ propagate\n@@ -2035,2 +2005,0 @@\n-                                if ((b = q.base) != nb && src != (src = j))\n-                                    continue rescan;      \/\/ reduce interference\n@@ -2041,6 +2009,5 @@\n-                if (!scanned)\n-                    scanned = true;                   \/\/ rescan before deactivate\n-                else if (((phase = deactivate(w, r, phase)) & IDLE) == 0)\n-                    scanned = false;\n-                else\n-                    return;\n+                if (!rescan) {\n+                    src = -1;\n+                    if (((phase = deactivate(w, phase)) & IDLE) != 0)\n+                        break;\n+                }\n@@ -2055,1 +2022,0 @@\n-     * @param r random seed\n@@ -2059,1 +2025,3 @@\n-    private int deactivate(WorkQueue w, int r, int phase) {\n+    private int deactivate(WorkQueue w, int phase) {\n+        if (w == null)                        \/\/ currently impossible\n+            return IDLE;\n@@ -2061,42 +2029,21 @@\n-        if (w != null) {                         \/\/ always true\n-            w.phase = p;\n-            long pc = ctl, qc;\n-            for (;;) {                           \/\/ try to enqueue\n-                w.stackPred = (int)pc;           \/\/ set ctl stack link\n-                qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-                if (pc == (pc = compareAndExchangeCtl(pc, qc))) \/\/ success\n-                    break;\n-                if ((pc & RC_MASK) >= (qc & RC_MASK)) {\n-                    p = w.phase = phase;         \/\/ back out on possible signal\n-                    break;\n-                }\n-            }\n-            if (p != phase &&                    \/\/ check quiescent termination\n-                ((runState & SHUTDOWN) == 0L || quiescent() <= 0)) {\n-                WorkQueue[] qs;\n-                int spins = ((short)(qc >>> TC_SHIFT) << 1) + SPIN_WAITS + 1;\n-                while ((p = w.phase) != activePhase && --spins > 0)\n-                    Thread.onSpinWait();         \/\/ reduce flailing\n-                if (p != activePhase && (qs = queues) != null) {\n-                    int n = qs.length, step = (r >>> 16) | 1;\n-                    for (int i = r, l = n; l > 0; --l, i += step) {\n-                        WorkQueue q;             \/\/ check for missed signals\n-                        if ((q = qs[i & (n - 1)]) != null &&\n-                            q.top - q.base > 0) {\n-                            if (ctl == qc && compareAndSetCtl(qc, pc)) {\n-                                p = w.phase = activePhase;\n-                                break;           \/\/ self-signal\n-                            }\n-                            if ((p = w.phase) == activePhase)\n-                                break;\n-                        }\n-                    }\n-                    if (p != activePhase) {\n-                        long delay = (((qc & RC_MASK) > 0L) ? 0L :\n-                                      (w.source != INVALID_ID) ? keepAlive :\n-                                      TIMEOUT_SLOP); \/\/ minimal delay if cascade\n-                        if ((p = w.phase) != activePhase)\n-                            p = awaitWork(w, p, delay); \/\/ block, drop, or exit\n-                    }\n-                }\n-            }\n+        long pc = ctl, qc = (activePhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+        w.stackPred = (int)pc;                \/\/ set ctl stack link\n+        w.phase = p;\n+        if (!compareAndSetCtl(pc, qc))        \/\/ try to enqueue\n+            return w.phase = phase;           \/\/ back out on possible signal\n+        long e; WorkQueue[] qs; int n;\n+        if (((e = runState) & STOP) != 0L ||\n+            ((e & SHUTDOWN) != 0L && (qc & RC_MASK) == 0L && quiescent() > 0) ||\n+            (qs = queues) == null || (n = qs.length) <= 0)\n+            return IDLE;                      \/\/ terminating\n+        for (int steps = Math.max(n << 1, SPIN_WAITS), found = 0, i = 0; ; ++i) {\n+            WorkQueue q;                      \/\/ interleave spins and rechecks\n+            if (w.phase == activePhase)\n+                return activePhase;\n+            if (i >= steps)\n+                return awaitWork(w, p);       \/\/ block, drop, or exit\n+            Thread.onSpinWait();\n+            if (found != 2 && (i & n) != 0 && (i & 1) == 0 &&\n+                (q = qs[i & (n - 1)]) != null &&\n+                q.top - q.base > 0 && ++found == 2)\n+                reactivate(false);            \/\/ help signal\n@@ -2104,1 +2051,0 @@\n-        return p;\n@@ -2112,1 +2058,0 @@\n-     * @param delay if nonzero keepAlive before trimming if quiescent\n@@ -2115,1 +2060,1 @@\n-    private int awaitWork(WorkQueue w, int p, long delay) {\n+    private int awaitWork(WorkQueue w, int p) {\n@@ -2117,0 +2062,7 @@\n+            long deadline;                     \/\/ for idle timeouts\n+            if ((ctl & RC_MASK) > 0L)\n+                deadline = 0L;\n+            else if ((deadline =\n+                      (((w.source != INVALID_ID) ? keepAlive : TIMEOUT_SLOP)) +\n+                      System.currentTimeMillis()) == 0L)\n+                deadline = 1L;                 \/\/ avoid zero\n@@ -2118,11 +2070,7 @@\n-            LockSupport.setCurrentBlocker(this);\n-            long deadline = (delay == 0L ? 0L :\n-                             delay + System.currentTimeMillis());\n-            w.parking = 1;                 \/\/ enable unpark\n-            while ((p = w.phase) != activePhase) {\n-                boolean trimmable = false; int trim;\n-                Thread.interrupted();      \/\/ clear status\n-                if ((runState & STOP) != 0L)\n-                    break;\n-                if (deadline != 0L) {\n-                    if ((trim = tryTrim(w, p, deadline)) > 0)\n+            if ((p = w.phase) != activePhase && (runState & STOP) == 0L) {\n+                LockSupport.setCurrentBlocker(this);\n+                w.parking = 1;                 \/\/ enable unpark\n+                while ((p = w.phase) != activePhase) {\n+                    boolean trimmable = false; int trim;\n+                    Thread.interrupted();      \/\/ clear status\n+                    if ((runState & STOP) != 0L)\n@@ -2130,4 +2078,9 @@\n-                    else if (trim < 0)\n-                        deadline = 0L;\n-                    else\n-                        trimmable = true;\n+                    if (deadline != 0L) {\n+                        if ((trim = tryTrim(w, p, deadline)) > 0)\n+                            break;\n+                        else if (trim < 0)\n+                            deadline = 0L;\n+                        else\n+                            trimmable = true;\n+                    }\n+                    U.park(trimmable, deadline);\n@@ -2135,1 +2088,2 @@\n-                U.park(trimmable, deadline);\n+                w.parking = 0;\n+                LockSupport.setCurrentBlocker(null);\n@@ -2137,2 +2091,0 @@\n-            w.parking = 0;\n-            LockSupport.setCurrentBlocker(null);\n@@ -2293,1 +2245,3 @@\n-                            int sq = q.source, b, cap, k; ForkJoinTask<?>[] a;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            boolean eligible = false;\n+                            int sq = q.source, b, cap; long k;\n@@ -2296,3 +2250,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2317,2 +2270,2 @@\n-                            if (q.source == sq && q.base == b && a[k] == t) {\n-                                int nb = b + 1, nk = nb & (cap - 1);\n+                            if (q.source == sq && q.base == b &&\n+                                U.getReference(a, k) == t) {\n@@ -2320,2 +2273,1 @@\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2325,3 +2277,2 @@\n-                                if (U.compareAndSetReference(\n-                                        a, slotOffset(k), t, null)) {\n-                                    q.updateBase(nb);\n+                                if (U.compareAndSetReference(a, k, t, null)) {\n+                                    q.base = b + 1;\n@@ -2375,1 +2326,3 @@\n-                            ForkJoinTask<?>[] a; int b, cap, k;\n+                            ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                            int b, cap, nb; long k;\n+                            boolean eligible = false;\n@@ -2378,3 +2331,2 @@\n-                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n-                            U.loadFence();\n-                            boolean eligible = false;\n+                            t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                                a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2395,1 +2347,0 @@\n-                                int nb = b + 1, nk = nb & (cap - 1);\n@@ -2398,2 +2349,2 @@\n-                                            a, slotOffset(k), t, null)) {\n-                                        q.updateBase(nb);\n+                                            a, k, t, null)) {\n+                                        q.updateBase(b + 1);\n@@ -2405,3 +2356,2 @@\n-                                else if (a[k] == t) {\n-                                    if (!rescan && t == null &&\n-                                        (a[nk] != null || q.top - b > 0))\n+                                else if (U.getReference(a, k) == t) {\n+                                    if (!rescan && t == null && q.top - b > 0)\n@@ -2460,1 +2410,2 @@\n-                        ForkJoinTask<?>[] a; int b, cap, k;\n+                        ForkJoinTask<?> t; ForkJoinTask<?>[] a;\n+                        int b, cap; long k;\n@@ -2463,1 +2414,2 @@\n-                        ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                        t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                            a, k = slotOffset((cap - 1) & (b = q.base)));\n@@ -2466,2 +2418,1 @@\n-                        U.loadFence();\n-                        if (q.base == b && a[k] == t) {\n+                        if (q.base == b && U.getReference(a, k) == t) {\n@@ -2480,3 +2431,2 @@\n-                            if (U.compareAndSetReference(\n-                                    a, slotOffset(k), t, null)) {\n-                                q.updateBase(nb);\n+                            if (U.compareAndSetReference(a, k, t, null)) {\n+                                q.base = nb;\n@@ -2775,1 +2725,1 @@\n-            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n+            if ((e & STOP) != 0L && (reactivate(true) & RC_MASK) > 0L && now)\n@@ -2779,13 +2729,10 @@\n-            if ((ctl & RC_MASK) > 0L) {          \/\/ unless all inactive\n-                int r = (int)Thread.currentThread().threadId();\n-                WorkQueue[] qs = queues;         \/\/ stagger traversals\n-                int n = (qs == null) ? 0 : qs.length;\n-                for (int l = n; l > 0; --l, ++r) {\n-                    WorkQueue q; ForkJoinTask<?> t;\n-                    if ((q = qs[r & (n - 1)]) != null &&\n-                        q.source != DROPPED) {\n-                        while ((t = q.poll()) != null) {\n-                            try {\n-                                t.cancel(false);\n-                            } catch (Throwable ignore) {\n-                            }\n+            int r = (int)Thread.currentThread().threadId();\n+            WorkQueue[] qs = queues;             \/\/ stagger traversals\n+            int n = (qs == null) ? 0 : qs.length;\n+            for (int l = n; l > 0; --l, ++r) {\n+                WorkQueue q; ForkJoinTask<?> t;\n+                if ((q = qs[r & (n - 1)]) != null) {\n+                    while ((t = q.poll()) != null) {\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":193,"deletions":246,"binary":false,"changes":439,"status":"modified"}]}