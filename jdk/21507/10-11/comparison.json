{"files":[{"patch":"@@ -854,1 +854,3 @@\n-     * paths.\n+     * paths. The inability to rely on caller-runs may also require\n+     * extra signalling (and resulting scanning and contention) so is\n+     * done only conditionally in methods push and runworker.\n@@ -1828,1 +1830,1 @@\n-            releaseAll();\n+            dropWaiters();\n@@ -1912,1 +1914,1 @@\n-     * Releases all waiting workers. Called only during shutdown.\n+     * Releases and drops all waiting workers. Called only during shutdown.\n@@ -1916,3 +1918,2 @@\n-    private long releaseAll() {\n-        long c = ctl;\n-        for (;;) {\n+    private long dropWaiters() {\n+        for (long c = ctl;;) {\n@@ -1922,1 +1923,1 @@\n-                break;\n+                return c;\n@@ -1924,2 +1925,2 @@\n-                          c, ((UMASK & (c + RC_UNIT)) | (c & TC_MASK) |\n-                              (v.stackPred & LMASK))))) {\n+                          c, (v.stackPred & LMASK) | (UMASK & (c - TC_UNIT))))) {\n+                v.source = DROPPED;\n@@ -1931,1 +1932,0 @@\n-        return c;\n@@ -2753,1 +2753,1 @@\n-            if ((e & STOP) != 0L && (releaseAll() & RC_MASK) > 0L && now)\n+            if ((e & STOP) != 0L && (dropWaiters() & RC_MASK) != 0L && now)\n@@ -2757,10 +2757,12 @@\n-            int r = (int)Thread.currentThread().threadId();\n-            WorkQueue[] qs = queues;             \/\/ stagger traversals\n-            int n = (qs == null) ? 0 : qs.length;\n-            for (int l = n; l > 0; --l, ++r) {\n-                WorkQueue q; ForkJoinTask<?> t;\n-                if ((q = qs[r & (n - 1)]) != null) {\n-                    while ((t = q.poll()) != null) {\n-                        try {\n-                            t.cancel(false);\n-                        } catch (Throwable ignore) {\n+            if ((ctl & RC_MASK) != 0L) {         \/\/ unless all inactive\n+                int r = (int)Thread.currentThread().threadId();\n+                WorkQueue[] qs = queues;         \/\/ stagger traversals\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int l = n; l > 0; --l, ++r) {\n+                    WorkQueue q; ForkJoinTask<?> t;\n+                    if ((q = qs[r & (n - 1)]) != null) {\n+                        while (q.source != DROPPED && (t = q.poll()) != null) {\n+                            try {\n+                                t.cancel(false);\n+                            } catch (Throwable ignore) {\n+                            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"}]}