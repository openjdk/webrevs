{"files":[{"patch":"@@ -78,1 +78,0 @@\n-#include \"utilities\/exceptions.hpp\"\n@@ -547,3 +546,0 @@\n-\n-  \/\/ Whenever a GC happens, clear the exception logging cache to avoid stale oop pointers.\n-  Exceptions::clear_logging_cache();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -498,4 +498,0 @@\n-      bool is_throw_bytecode = false;\n-      if (!h_method->is_native()) {\n-        is_throw_bytecode = (Bytecodes::Code) *h_method->bcp_from(current_bci) == Bytecodes::_athrow;\n-      }\n@@ -505,1 +501,4 @@\n-      Exceptions::log_exception(h_exception, tempst.as_string(), is_throw_bytecode);\n+      Exceptions::log_exception(h_exception, tempst.as_string());\n+    }\n+    if (log_is_enabled(Info, exceptions, stacktrace)) {\n+      Exceptions::log_exception_stacktrace(h_exception, h_method, current_bci);\n@@ -507,0 +506,1 @@\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,10 +118,14 @@\n-    ResourceMark rm(thread);\n-    const char* exc_value = h_name != nullptr ? h_name->as_C_string() : \"null\";\n-    log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n-                        \"at [%s, line %d]\\nfor thread \" PTR_FORMAT \",\\n\"\n-                        \"throwing pre-allocated exception: %s\",\n-                        MAX_LEN, exc_value, message ? \": \" : \"\",\n-                        MAX_LEN, message ? message : \"\",\n-                        p2i(h_exception()), file, line, p2i(thread),\n-                        Universe::vm_exception()->print_value_string());\n-    maybe_log_call_stack(h_exception, false);\n+    if (log_is_enabled(Info, exceptions)) {\n+      ResourceMark rm(thread);\n+      const char* exc_value = h_name != nullptr ? h_name->as_C_string() : \"null\";\n+      log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n+                           \"at [%s, line %d]\\nfor thread \" PTR_FORMAT \",\\n\"\n+                           \"throwing pre-allocated exception: %s\",\n+                           MAX_LEN, exc_value, message ? \": \" : \"\",\n+                           MAX_LEN, message ? message : \"\",\n+                           p2i(h_exception()), file, line, p2i(thread),\n+                           Universe::vm_exception()->print_value_string());\n+    }\n+    if (log_is_enabled(Info, exceptions, stacktrace)) {\n+      log_exception_stacktrace(h_exception);\n+    }\n@@ -149,9 +153,13 @@\n-  \/\/ tracing (do this up front - so it works during boot strapping)\n-  \/\/ Note, the print_value_string() argument is not called unless logging is enabled!\n-  log_info(exceptions)(\"Exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n-                       \"thrown [%s, line %d]\\nfor thread \" PTR_FORMAT,\n-                       MAX_LEN, h_exception->print_value_string(),\n-                       message ? \": \" : \"\",\n-                       MAX_LEN, message ? message : \"\",\n-                       p2i(h_exception()), file, line, p2i(thread));\n-  maybe_log_call_stack(h_exception, false);\n+  if (log_is_enabled(Info, exceptions)) {\n+    \/\/ tracing (do this up front - so it works during boot strapping)\n+    \/\/ Note, the print_value_string() argument is not called unless logging is enabled!\n+    log_info(exceptions)(\"Exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n+                         \"thrown [%s, line %d]\\nfor thread \" PTR_FORMAT,\n+                         MAX_LEN, h_exception->print_value_string(),\n+                         message ? \": \" : \"\",\n+                         MAX_LEN, message ? message : \"\",\n+                         p2i(h_exception()), file, line, p2i(thread));\n+  }\n+  if (log_is_enabled(Info, exceptions, stacktrace)) {\n+    log_exception_stacktrace(h_exception);\n+  }\n@@ -601,1 +609,1 @@\n-void Exceptions::log_exception(Handle exception, const char* message, bool is_throw_bytecode) {\n+void Exceptions::log_exception(Handle exception, const char* message) {\n@@ -614,1 +622,0 @@\n-  maybe_log_call_stack(exception, !is_throw_bytecode);\n@@ -617,3 +624,49 @@\n-\/\/ We don't want to use an OopHandle, or else we may prevent this object from being collected.\n-\/\/ Whenever a GC happens, this will be cleared by Exceptions::clear_logging_cache().\n-static oop _last_logged_exception;\n+\/\/ This is called from InterpreterRuntime::exception_handler_for_exception(), which is the only\n+\/\/ easy way to be notified in the VM that an _athrow bytecode has been executed. (The alternative\n+\/\/ would be to add hooks into the interpreter and compiler, for all platforms ...).\n+\/\/\n+\/\/ Unfortunately, InterpreterRuntime::exception_handler_for_exception() is called for every level\n+\/\/ of the Java stack when looking for an exception handler. To avoid excessive output,\n+\/\/ we print the stack only when the bci points to an _athrow bytecode.\n+\/\/\n+\/\/ NOTE: exceptions that are NOT thrown by _athrow are handled by Exceptions::special_exception()\n+\/\/ and Exceptions::_throw()).\n+void Exceptions::log_exception_stacktrace(Handle exception, methodHandle method, int bci) {\n+  if (method->is_native() || (Bytecodes::Code) *method->bcp_from(bci) == Bytecodes::_athrow) {\n+    \/\/ TODO: it would be nice to filter out exceptions re-thrown by finally blocks (which include\n+    \/\/ try-with-resource statements):\n+    \/\/\n+    \/\/ try {\n+    \/\/     nullObject.toString(); \/\/ throws NPE\n+    \/\/ } finally {\n+    \/\/     do_something();\n+    \/\/ }\n+    \/\/\n+    \/\/ The finally block is compiled like this:\n+    \/\/\n+    \/\/   8: astore_1            \/\/ the exception thrown in the try block\n+    \/\/   9: invokestatic #23    \/\/ Method: do_something()V\n+    \/\/  12: aload_1\n+    \/\/  13: athrow              \/\/ re-throw exception\n+    \/\/ Exception table:\n+    \/\/  from    to  target type\n+    \/\/   0     3     8   any\n+    \/\/\n+    \/\/ However, we need to distinguish with finally blocks whose last statement is a throw:\n+    \/\/\n+    \/\/ try {\n+    \/\/     nullObject.toString(); \/\/ throws NPE\n+    \/\/ } finally {\n+    \/\/     throw new RuntimeException(\"\");\n+    \/\/ }\n+    \/\/\n+    \/\/ To do this, we need to check that:\n+    \/\/    - bci is the last bytecode of an exception handler\n+    \/\/    - the previous bytecode is an aload_1\n+    \/\/    - the catch type is \"any\" (#0).\n+    \/\/\n+    \/\/ But, the \"end of exception handler\" is not defined in the classfile, so we need to use\n+    \/\/ abstract interpretation to find out. Let's do that later ...\n+    log_exception_stacktrace(exception);\n+  }\n+}\n@@ -622,1 +675,1 @@\n-void Exceptions::maybe_log_call_stack(Handle exception, bool omit_if_same) {\n+void Exceptions::log_exception_stacktrace(Handle exception) {\n@@ -624,15 +677,15 @@\n-  if (st.is_enabled()) {\n-    oop exception_oop = exception();\n-    oop old_exception = NativeAccess<MO_SEQ_CST>::oop_atomic_xchg(&_last_logged_exception, exception_oop);\n-    if (omit_if_same && old_exception == exception_oop) {\n-      \/\/ This is called again when InterpreterRuntime::exception_handler_for_exception() is looking for\n-      \/\/ an exception handler. Don't print the stack again to avoid excessive output.\n-      \/\/\n-      \/\/ TODO: we should cache one exception per JavaThread, or else concurrently thrown exceptions\n-      \/\/ may cause excessive logging (this is probably rare).\n-    } else {\n-      JavaThread* t = JavaThread::current();\n-      if (t->has_last_Java_frame()) {\n-        t->print_active_stack_on(&st);\n-      }\n-    }\n+  ResourceMark rm;\n+  const char* detail_message = java_lang_Throwable::message_as_utf8(exception());\n+  if (detail_message != nullptr) {\n+    st.print_cr(\"Exception <%.*s: %.*s>\",\n+                MAX_LEN, exception->print_value_string(),\n+                MAX_LEN, detail_message);\n+  } else {\n+    st.print_cr(\"Exception <%.*s>\",\n+                MAX_LEN, exception->print_value_string());\n+  }\n+  JavaThread* t = JavaThread::current();\n+  if (t->has_last_Java_frame()) {\n+    t->print_active_stack_on(&st);\n+  } else {\n+    st.print_cr(\"(Cannot print stracktrace)\");\n@@ -640,4 +693,0 @@\n-}\n-\n-void Exceptions::clear_logging_cache() {\n-  NativeAccess<>::oop_store(&_last_logged_exception, nullptr);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":93,"deletions":44,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -195,3 +195,3 @@\n-  static void log_exception(Handle exception, const char* message, bool is_throw_bytecode = false);\n-\n-  static void clear_logging_cache();\n+  static void log_exception(Handle exception, const char* message);\n+  static void log_exception_stacktrace(Handle exception);\n+  static void log_exception_stacktrace(Handle exception, methodHandle method, int bci);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}