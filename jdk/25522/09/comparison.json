{"files":[{"patch":"@@ -503,0 +503,4 @@\n+    if (log_is_enabled(Info, exceptions, stacktrace)) {\n+      Exceptions::log_exception_stacktrace(h_exception, h_method, current_bci);\n+    }\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/access.inline.hpp\"\n@@ -117,9 +118,14 @@\n-    ResourceMark rm(thread);\n-    const char* exc_value = h_name != nullptr ? h_name->as_C_string() : \"null\";\n-    log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n-                        \"at [%s, line %d]\\nfor thread \" PTR_FORMAT \",\\n\"\n-                        \"throwing pre-allocated exception: %s\",\n-                        MAX_LEN, exc_value, message ? \": \" : \"\",\n-                        MAX_LEN, message ? message : \"\",\n-                        p2i(h_exception()), file, line, p2i(thread),\n-                        Universe::vm_exception()->print_value_string());\n+    if (log_is_enabled(Info, exceptions)) {\n+      ResourceMark rm(thread);\n+      const char* exc_value = h_name != nullptr ? h_name->as_C_string() : \"null\";\n+      log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n+                           \"at [%s, line %d]\\nfor thread \" PTR_FORMAT \",\\n\"\n+                           \"throwing pre-allocated exception: %s\",\n+                           MAX_LEN, exc_value, message ? \": \" : \"\",\n+                           MAX_LEN, message ? message : \"\",\n+                           p2i(h_exception()), file, line, p2i(thread),\n+                           Universe::vm_exception()->print_value_string());\n+    }\n+    if (log_is_enabled(Info, exceptions, stacktrace)) {\n+      log_exception_stacktrace(h_exception);\n+    }\n@@ -147,8 +153,13 @@\n-  \/\/ tracing (do this up front - so it works during boot strapping)\n-  \/\/ Note, the print_value_string() argument is not called unless logging is enabled!\n-  log_info(exceptions)(\"Exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n-                       \"thrown [%s, line %d]\\nfor thread \" PTR_FORMAT,\n-                       MAX_LEN, h_exception->print_value_string(),\n-                       message ? \": \" : \"\",\n-                       MAX_LEN, message ? message : \"\",\n-                       p2i(h_exception()), file, line, p2i(thread));\n+  if (log_is_enabled(Info, exceptions)) {\n+    \/\/ tracing (do this up front - so it works during boot strapping)\n+    \/\/ Note, the print_value_string() argument is not called unless logging is enabled!\n+    log_info(exceptions)(\"Exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n+                         \"thrown [%s, line %d]\\nfor thread \" PTR_FORMAT,\n+                         MAX_LEN, h_exception->print_value_string(),\n+                         message ? \": \" : \"\",\n+                         MAX_LEN, message ? message : \"\",\n+                         p2i(h_exception()), file, line, p2i(thread));\n+  }\n+  if (log_is_enabled(Info, exceptions, stacktrace)) {\n+    log_exception_stacktrace(h_exception);\n+  }\n@@ -612,0 +623,71 @@\n+\n+\/\/ This is called from InterpreterRuntime::exception_handler_for_exception(), which is the only\n+\/\/ easy way to be notified in the VM that an _athrow bytecode has been executed. (The alternative\n+\/\/ would be to add hooks into the interpreter and compiler, for all platforms ...).\n+\/\/\n+\/\/ Unfortunately, InterpreterRuntime::exception_handler_for_exception() is called for every level\n+\/\/ of the Java stack when looking for an exception handler. To avoid excessive output,\n+\/\/ we print the stack only when the bci points to an _athrow bytecode.\n+\/\/\n+\/\/ NOTE: exceptions that are NOT thrown by _athrow are handled by Exceptions::special_exception()\n+\/\/ and Exceptions::_throw()).\n+void Exceptions::log_exception_stacktrace(Handle exception, methodHandle method, int bci) {\n+  if (!method->is_native() && (Bytecodes::Code) *method->bcp_from(bci) == Bytecodes::_athrow) {\n+    \/\/ TODO: it would be nice to filter out exceptions re-thrown by finally blocks (which include\n+    \/\/ try-with-resource statements):\n+    \/\/\n+    \/\/ try {\n+    \/\/     nullObject.toString(); \/\/ throws NPE\n+    \/\/ } finally {\n+    \/\/     do_something();\n+    \/\/ }\n+    \/\/\n+    \/\/ The finally block is compiled like this:\n+    \/\/\n+    \/\/   8: astore_1            \/\/ the exception thrown in the try block\n+    \/\/   9: invokestatic #23    \/\/ Method: do_something()V\n+    \/\/  12: aload_1\n+    \/\/  13: athrow              \/\/ re-throw exception\n+    \/\/ Exception table:\n+    \/\/  from    to  target type\n+    \/\/   0     3     8   any\n+    \/\/\n+    \/\/ However, we need to distinguish with finally blocks whose last statement is a throw:\n+    \/\/\n+    \/\/ try {\n+    \/\/     nullObject.toString(); \/\/ throws NPE\n+    \/\/ } finally {\n+    \/\/     throw new RuntimeException(\"\");\n+    \/\/ }\n+    \/\/\n+    \/\/ To do this, we need to check that:\n+    \/\/    - bci is the last bytecode of an exception handler\n+    \/\/    - the previous bytecode is an aload_1\n+    \/\/    - the catch type is \"any\" (#0).\n+    \/\/\n+    \/\/ But, the \"end of exception handler\" is not defined in the classfile, so we need to use\n+    \/\/ abstract interpretation to find out. Let's do that later ...\n+    log_exception_stacktrace(exception);\n+  }\n+}\n+\n+\/\/ This should be called only from a live Java thread.\n+void Exceptions::log_exception_stacktrace(Handle exception) {\n+  LogStreamHandle(Info, exceptions, stacktrace) st;\n+  ResourceMark rm;\n+  const char* detail_message = java_lang_Throwable::message_as_utf8(exception());\n+  if (detail_message != nullptr) {\n+    st.print_cr(\"Exception <%.*s: %.*s>\",\n+                MAX_LEN, exception->print_value_string(),\n+                MAX_LEN, detail_message);\n+  } else {\n+    st.print_cr(\"Exception <%.*s>\",\n+                MAX_LEN, exception->print_value_string());\n+  }\n+  JavaThread* t = JavaThread::current();\n+  if (t->has_last_Java_frame()) {\n+    t->print_active_stack_on(&st);\n+  } else {\n+    st.print_cr(\"(Cannot print stracktrace)\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":99,"deletions":17,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,3 @@\n+\n+  \/\/ Logging\n+  static void maybe_log_call_stack(Handle exception, bool omit_if_same);\n@@ -193,0 +196,2 @@\n+  static void log_exception_stacktrace(Handle exception);\n+  static void log_exception_stacktrace(Handle exception, methodHandle method, int bci);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8141211 8147477\n+ * @bug 8141211 8147477 8358080\n@@ -37,0 +37,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -47,1 +49,1 @@\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n@@ -50,1 +52,15 @@\n-        output.shouldHaveExitValue(0);\n+        output.shouldMatch(\"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.bar[(]ExceptionsTest.java:[0-9]+\" +\n+                           \".*\\n.*\" +\n+                           \"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.foo[(]ExceptionsTest.java:[0-9]+\" +\n+                           \".*\\n.*\" +\n+                           \"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.main[(]ExceptionsTest.java:[0-9]+\");\n+\n+        \/\/ Note: \"(?s)\" means that the \".\" in the regexp can match the newline character.\n+        \/\/ To avoid verbosity, stack trace for bar2()->baz2() should be printed only once:\n+        \/\/ - It should be printed when the exception is thrown inside bzz2()\n+        \/\/ - It should not be printed when the interpreter is looking for an exception handler inside bar2()\n+        output.shouldMatch(\"(?s)baz2.*bar2\");\n+        output.shouldNotMatch(\"(?s)baz2.*bar2,*baz2.*bar2\");\n+\n+        \/\/ Two stack traces should include main()->foo2(), as an exception is thrown at two different BCIs in bar2().\n+        output.shouldMatch(\"(?s)foo2.*main.*foo2.*main\");\n@@ -60,1 +76,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:exceptions=info\",\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:exceptions,exceptions+stacktrace\",\n@@ -69,1 +85,1 @@\n-        updateEnvironment(pb, \"_JAVA_OPTIONS\", \"-Xlog:exceptions=info\");\n+        updateEnvironment(pb, \"_JAVA_OPTIONS\", \"-Xlog:exceptions,exceptions+stacktrace\");\n@@ -83,1 +99,10 @@\n-        public static void main(String[] args) throws Exception {\n+        public static void main(String[] args) {\n+            foo();\n+            foo2();\n+        }\n+\n+        static void foo() {\n+            bar();\n+        }\n+\n+        static void bar() {\n@@ -90,0 +115,24 @@\n+\n+        static void foo2() {\n+            try {\n+                bar2();\n+            } catch (Exception e) {\n+                System.out.println(\"Exception 2 caught.\");\n+            }\n+        }\n+\n+        static void bar2() {\n+            try {\n+                baz2();\n+            } catch (RuntimeException e) {\n+                throw e; \/\/ Rethrow -- should print a new callstack.\n+            }\n+        }\n+\n+        static void baz2() {\n+            bzz2();\n+        }\n+\n+        static void bzz2() {\n+            throw new RuntimeException(\"Test exception 2 for logging\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ExceptionsTest.java","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n--Xlog:exceptions=info\n+-Xlog:exceptions,exceptions+stacktrace\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ExceptionsTest_options_file","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}