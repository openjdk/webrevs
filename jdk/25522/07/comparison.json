{"files":[{"patch":"@@ -78,0 +78,1 @@\n+#include \"utilities\/exceptions.hpp\"\n@@ -546,0 +547,3 @@\n+\n+  \/\/ Whenever a GC happens, clear the exception logging cache to avoid stale oop pointers.\n+  Exceptions::clear_logging_cache();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -498,0 +498,4 @@\n+      bool is_throw_bytecode = false;\n+      if (!h_method->is_native()) {\n+        is_throw_bytecode = (Bytecodes::Code) *h_method->bcp_from(current_bci) == Bytecodes::_athrow;\n+      }\n@@ -501,1 +505,1 @@\n-      Exceptions::log_exception(h_exception, tempst.as_string());\n+      Exceptions::log_exception(h_exception, tempst.as_string(), is_throw_bytecode);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/access.inline.hpp\"\n@@ -126,0 +127,1 @@\n+    maybe_log_call_stack(h_exception, false);\n@@ -155,0 +157,1 @@\n+  maybe_log_call_stack(h_exception, false);\n@@ -598,1 +601,1 @@\n-void Exceptions::log_exception(Handle exception, const char* message) {\n+void Exceptions::log_exception(Handle exception, const char* message, bool is_throw_bytecode) {\n@@ -611,0 +614,30 @@\n+  maybe_log_call_stack(exception, !is_throw_bytecode);\n+}\n+\n+\/\/ We don't want to use an OopHandle, or else we may prevent this object from being collected.\n+\/\/ Whenever a GC happens, this will be cleared by Exceptions::clear_logging_cache().\n+static oop _last_logged_exception;\n+\n+\/\/ This should be called only from a live Java thread.\n+void Exceptions::maybe_log_call_stack(Handle exception, bool omit_if_same) {\n+  LogStreamHandle(Info, exceptions, stacktrace) st;\n+  if (st.is_enabled()) {\n+    oop exception_oop = exception();\n+    oop old_exception = NativeAccess<MO_SEQ_CST>::oop_atomic_xchg(&_last_logged_exception, exception_oop);\n+    if (omit_if_same && old_exception == exception_oop) {\n+      \/\/ This is called again when InterpreterRuntime::exception_handler_for_exception() is looking for\n+      \/\/ an exception handler. Don't print the stack again to avoid excessive output.\n+      \/\/\n+      \/\/ TODO: we should cache one exception per JavaThread, or else concurrently thrown exceptions\n+      \/\/ may cause excessive logging (this is probably rare).\n+    } else {\n+      JavaThread* t = JavaThread::current();\n+      if (t->has_last_Java_frame()) {\n+        t->print_active_stack_on(&st);\n+      }\n+    }\n+  }\n+}\n+\n+void Exceptions::clear_logging_cache() {\n+  NativeAccess<>::oop_store(&_last_logged_exception, nullptr);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,3 @@\n+\n+  \/\/ Logging\n+  static void maybe_log_call_stack(Handle exception, bool omit_if_same);\n@@ -192,1 +195,3 @@\n-  static void log_exception(Handle exception, const char* message);\n+  static void log_exception(Handle exception, const char* message, bool is_throw_bytecode = false);\n+\n+  static void clear_logging_cache();\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8141211 8147477\n+ * @bug 8141211 8147477 8358080\n@@ -37,0 +37,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -50,1 +52,15 @@\n-        output.shouldHaveExitValue(0);\n+        output.shouldMatch(\"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.bar[(]ExceptionsTest.java:[0-9]+\" +\n+                           \".*\\n.*\" +\n+                           \"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.foo[(]ExceptionsTest.java:[0-9]+\" +\n+                           \".*\\n.*\" +\n+                           \"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.main[(]ExceptionsTest.java:[0-9]+\");\n+\n+        \/\/ Note: \"(?s)\" means that the \".\" in the regexp can match the newline character.\n+        \/\/ To avoid verbosity, stack trace for bar2()->baz2() should be printed only once:\n+        \/\/ - It should be printed when the exception is thrown inside bzz2()\n+        \/\/ - It should not be printed when the interpreter is looking for an exception handler inside bar2()\n+        output.shouldMatch(\"(?s)baz2.*bar2\");\n+        output.shouldNotMatch(\"(?s)baz2.*bar2,*baz2.*bar2\");\n+\n+        \/\/ Two stack traces should include main()->foo2(), as an exception is thrown at two different BCIs in bar2().\n+        output.shouldMatch(\"(?s)foo2.*main.*foo2.*main\");\n@@ -60,1 +76,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:exceptions=info\",\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:exceptions,exceptions+stacktrace\",\n@@ -69,1 +85,1 @@\n-        updateEnvironment(pb, \"_JAVA_OPTIONS\", \"-Xlog:exceptions=info\");\n+        updateEnvironment(pb, \"_JAVA_OPTIONS\", \"-Xlog:exceptions,exceptions+stacktrace\");\n@@ -83,1 +99,10 @@\n-        public static void main(String[] args) throws Exception {\n+        public static void main(String[] args) {\n+            foo();\n+            foo2();\n+        }\n+\n+        static void foo() {\n+            bar();\n+        }\n+\n+        static void bar() {\n@@ -90,0 +115,24 @@\n+\n+        static void foo2() {\n+            try {\n+                bar2();\n+            } catch (Exception e) {\n+                System.out.println(\"Exception 2 caught.\");\n+            }\n+        }\n+\n+        static void bar2() {\n+            try {\n+                baz2();\n+            } catch (RuntimeException e) {\n+                throw e; \/\/ Rethrow -- should print a new callstack.\n+            }\n+        }\n+\n+        static void baz2() {\n+            bzz2();\n+        }\n+\n+        static void bzz2() {\n+            throw new RuntimeException(\"Test exception 2 for logging\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ExceptionsTest.java","additions":55,"deletions":6,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n--Xlog:exceptions=info\n+-Xlog:exceptions,exceptions+stacktrace\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ExceptionsTest_options_file","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}