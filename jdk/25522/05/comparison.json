{"files":[{"patch":"@@ -78,0 +78,1 @@\n+#include \"utilities\/exceptions.hpp\"\n@@ -546,0 +547,3 @@\n+\n+  \/\/ Whenever a GC happens, clear the exception logging cache to avoid stale oop pointers.\n+  Exceptions::clear_logging_cache();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/access.inline.hpp\"\n@@ -126,0 +127,1 @@\n+    maybe_log_call_stack(h_exception);\n@@ -155,0 +157,1 @@\n+  maybe_log_call_stack(h_exception);\n@@ -611,0 +614,24 @@\n+  maybe_log_call_stack(exception);\n+}\n+\n+\/\/ We don't want to use an OopHandle, or else we may prevent this object from being collected.\n+\/\/ Whenever a GC happens, this will be cleared by Exceptions::clear_logging_cache().\n+static oop _last_logged_exception;\n+\n+\/\/ This should be called only from a live Java thread.\n+void Exceptions::maybe_log_call_stack(Handle exception) {\n+  LogStreamHandle(Info, exceptions, stacktrace) st;\n+  if (st.is_enabled()) {\n+    oop exception_oop = exception();\n+    oop old_exception = NativeAccess<MO_SEQ_CST>::oop_atomic_xchg(&_last_logged_exception, exception_oop);\n+    if (old_exception != exception_oop) {\n+      JavaThread* t = JavaThread::current();\n+      if (t->has_last_Java_frame()) {\n+        t->print_active_stack_on(&st);\n+      }\n+    }\n+  }\n+}\n+\n+void Exceptions::clear_logging_cache() {\n+  NativeAccess<>::oop_store(&_last_logged_exception, nullptr);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,3 @@\n+\n+  \/\/ Logging\n+  static void maybe_log_call_stack(Handle exception);\n@@ -193,0 +196,2 @@\n+\n+  static void clear_logging_cache();\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8141211 8147477\n+ * @bug 8141211 8147477 8358080\n@@ -37,0 +37,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -48,0 +50,1 @@\n+        System.out.println(output.getStdout());\n@@ -50,1 +53,16 @@\n-        output.shouldHaveExitValue(0);\n+        output.shouldMatch(\"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.bar[(]ExceptionsTest.java:[0-9]+\" +\n+                           \".*\\n.*\" +\n+                           \"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.foo[(]ExceptionsTest.java:[0-9]+\" +\n+                           \".*\\n.*\" +\n+                           \"info..exceptions,stacktrace.*at ExceptionsTest[$]InternalClass.main[(]ExceptionsTest.java:[0-9]+\");\n+\n+        \/\/ To avoid verbosity, we shouldn't print the callstack of main->foo2->bar2 more than once\n+        String stdout = output.getStdout();\n+        Pattern p = Pattern.compile(\"foo2.*main\", Pattern.DOTALL);\n+        Matcher m = p.matcher(stdout);\n+        if (!m.find()) {\n+            throw new RuntimeException(\"Cannot find: \" + p);\n+        }\n+        if (m.find()) {\n+            throw new RuntimeException(\"Must not find \" + p + \" twice\");\n+        }\n@@ -60,1 +78,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:exceptions=info\",\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:exceptions,exceptions+stacktrace\",\n@@ -69,1 +87,1 @@\n-        updateEnvironment(pb, \"_JAVA_OPTIONS\", \"-Xlog:exceptions=info\");\n+        updateEnvironment(pb, \"_JAVA_OPTIONS\", \"-Xlog:exceptions,exceptions+stacktrace\");\n@@ -83,1 +101,10 @@\n-        public static void main(String[] args) throws Exception {\n+        public static void main(String[] args) {\n+            foo();\n+            foo2();\n+        }\n+\n+        static void foo() {\n+            bar();\n+        }\n+\n+        static void bar() {\n@@ -90,0 +117,12 @@\n+\n+        static void foo2() {\n+            try {\n+                bar2();\n+            } catch (Exception e) {\n+                System.out.println(\"Exception 2 caught.\");\n+            }\n+        }\n+\n+        static void bar2() {\n+            throw new RuntimeException(\"Test exception 2 for logging\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ExceptionsTest.java","additions":45,"deletions":6,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n--Xlog:exceptions=info\n+-Xlog:exceptions,exceptions+stacktrace\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ExceptionsTest_options_file","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}