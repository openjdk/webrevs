{"files":[{"patch":"@@ -43,0 +43,5 @@\n+\/\/\n+\/\/ When a memory area is free (kept by the virtual memory manager) a\n+\/\/ single placeholder is covering that memory area. When memory is\n+\/\/ allocated from the manager the placeholder is split into granule\n+\/\/ sized placeholders to allow mapping operations on that granularity.\n@@ -55,3 +60,11 @@\n-    static void split_into_placeholder_granules(zoffset start, size_t size) {\n-      for (uintptr_t addr = untype(start); addr < untype(start) + size; addr += ZGranuleSize) {\n-        split_placeholder(to_zoffset(addr), ZGranuleSize);\n+    \/\/ Turn the single placeholder covering the memory area into granule\n+    \/\/ sized placeholders.\n+    static void split_into_granule_sized_placeholders(zoffset start, size_t size) {\n+      assert(size >= ZGranuleSize, \"Must be at least one granule\");\n+      assert(is_aligned(size, ZGranuleSize), \"Must be granule aligned\");\n+\n+      \/\/ Don't call split_placeholder on the last granule, since it is already\n+      \/\/ a placeholder and the system call would therefore fail.\n+      const size_t limit = size - ZGranuleSize;\n+      for (size_t offset = 0; offset < limit; offset += ZGranuleSize) {\n+        split_placeholder(start + offset, ZGranuleSize);\n@@ -64,0 +77,1 @@\n+      \/\/ Granule sized areas are already covered by a single placeholder\n@@ -69,0 +83,3 @@\n+    \/\/ Called when a memory area is returned to the memory manager but can't\n+    \/\/ be merged with an already existing area. Make sure this area is covered\n+    \/\/ by a single placeholder.\n@@ -71,0 +88,1 @@\n+\n@@ -74,0 +92,2 @@\n+    \/\/ Called when a complete memory area in the memory manager is allocated.\n+    \/\/ Create granule sized placeholders for the entire area.\n@@ -76,2 +96,2 @@\n-      \/\/ Don't try split the last granule - VirtualFree will fail\n-      split_into_placeholder_granules(area->start(), area->size() - ZGranuleSize);\n+\n+      split_into_granule_sized_placeholders(area->start(), area->size());\n@@ -80,0 +100,2 @@\n+    \/\/ Called when a memory area is allocated at the front of an exising memory area.\n+    \/\/ Turn the first part of the memory area into granule sized placeholders.\n@@ -81,0 +103,1 @@\n+      assert(area->size() > size, \"Must be larger than what we try to split out\");\n@@ -82,1 +105,6 @@\n-      split_into_placeholder_granules(area->start(), size);\n+\n+      \/\/ Split the area into two placeholders\n+      split_placeholder(area->start(), size);\n+\n+      \/\/ Split the first part into granule sized placeholders\n+      split_into_granule_sized_placeholders(area->start(), size);\n@@ -85,0 +113,2 @@\n+    \/\/ Called when a memory area is allocated at the end of an existing memory area.\n+    \/\/ Turn the second part of the memory area into granule sized placeholders.\n@@ -86,0 +116,1 @@\n+      assert(area->size() > size, \"Must be larger than what we try to split out\");\n@@ -87,2 +118,7 @@\n-      \/\/ Don't try split the last granule - VirtualFree will fail\n-      split_into_placeholder_granules(to_zoffset(untype(area->end()) - size), size - ZGranuleSize);\n+\n+      \/\/ Split the area into two placeholders\n+      const zoffset start = to_zoffset(area->end() - size);\n+      split_placeholder(start, size);\n+\n+      \/\/ Split the second part into granule sized placeholders\n+      split_into_granule_sized_placeholders(start, size);\n@@ -91,0 +127,2 @@\n+    \/\/ Called when freeing a memory area and it can be merged at the start of an\n+    \/\/ existing area. Coalesce the underlying placeholders into one.\n@@ -93,1 +131,3 @@\n-      coalesce_into_one_placeholder(to_zoffset(untype(area->start()) - size), area->size() + size);\n+\n+      const zoffset start = area->start() - size;\n+      coalesce_into_one_placeholder(start, area->size() + size);\n@@ -96,0 +136,2 @@\n+    \/\/ Called when freeing a memory area and it can be merged at the end of an\n+    \/\/ existing area. Coalesce the underlying placeholders into one.\n@@ -98,0 +140,1 @@\n+\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zVirtualMemory_windows.cpp","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+  friend class ZMapperTest;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef _WINDOWS\n+\n+#include \"gc\/z\/zAddress.inline.hpp\"\n+#include \"gc\/z\/zGlobals.hpp\"\n+#include \"gc\/z\/zList.inline.hpp\"\n+#include \"gc\/z\/zMemory.inline.hpp\"\n+#include \"gc\/z\/zSyscall_windows.hpp\"\n+#include \"gc\/z\/zVirtualMemory.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+using namespace testing;\n+\n+#define EXPECT_ALLOC_OK(offset) EXPECT_NE(offset, zoffset(UINTPTR_MAX))\n+\n+class ZMapperTest : public Test {\n+private:\n+  static constexpr size_t ZMapperTestReservationSize = 32 * M;\n+\n+  static bool            _initialized;\n+  static ZMemoryManager* _va;\n+\n+  ZVirtualMemoryManager* _vmm;\n+\n+public:\n+  bool reserve_for_test() {\n+    \/\/ Initialize platform specific parts before reserving address space\n+    _vmm->pd_initialize_before_reserve();\n+\n+    \/\/ Reserve address space\n+    if (!_vmm->pd_reserve(ZOffset::address_unsafe(zoffset(0)), ZMapperTestReservationSize)) {\n+      return false;\n+    }\n+\n+    \/\/ Make the address range free before setting up callbacks below\n+    _va->free(zoffset(0), ZMapperTestReservationSize);\n+\n+    \/\/ Initialize platform specific parts after reserving address space\n+    _vmm->pd_initialize_after_reserve();\n+\n+    return true;\n+  }\n+\n+  virtual void SetUp() {\n+    ZSyscall::initialize();\n+    ZGlobalsPointers::initialize();\n+\n+    \/\/ Fake a ZVirtualMemoryManager\n+    _vmm = (ZVirtualMemoryManager*)os::malloc(sizeof(ZVirtualMemoryManager), mtTest);\n+\n+    \/\/ Construct its internal ZMemoryManager\n+    _va = new (&_vmm->_manager) ZMemoryManager();\n+\n+    \/\/ Reserve address space for the test\n+    if (!reserve_for_test()) {\n+      \/\/ Failed to reserve address space\n+      GTEST_SKIP();\n+      return;\n+    }\n+\n+    _initialized = true;\n+  }\n+\n+  virtual void TearDown() {\n+    if (_initialized) {\n+      _vmm->pd_unreserve(ZOffset::address_unsafe(zoffset(0)), 0);\n+    }\n+    os::free(_vmm);\n+  }\n+\n+  static void test_alloc_low_address() {\n+    \/\/ Verify that we get placeholder for first granule\n+    zoffset bottom = _va->alloc_low_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    _va->free(bottom, ZGranuleSize);\n+\n+    \/\/ Alloc something larger than a granule and free it\n+    bottom = _va->alloc_low_address(ZGranuleSize * 3);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    _va->free(bottom, ZGranuleSize * 3);\n+\n+    \/\/ Free with more memory allocated\n+    bottom = _va->alloc_low_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    zoffset next = _va->alloc_low_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(next);\n+\n+    _va->free(bottom, ZGranuleSize);\n+    _va->free(next, ZGranuleSize);\n+  }\n+\n+  static void test_alloc_high_address() {\n+    \/\/ Verify that we get placeholder for last granule\n+    zoffset high = _va->alloc_high_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(high);\n+\n+    zoffset prev = _va->alloc_high_address(ZGranuleSize);\n+    EXPECT_ALLOC_OK(prev);\n+\n+    _va->free(high, ZGranuleSize);\n+    _va->free(prev, ZGranuleSize);\n+\n+    \/\/ Alloc something larger than a granule and return it\n+    high = _va->alloc_high_address(ZGranuleSize * 2);\n+    EXPECT_ALLOC_OK(high);\n+\n+    _va->free(high, ZGranuleSize * 2);\n+  }\n+\n+  static void test_alloc_whole_area() {\n+    \/\/ Alloc the whole reservation\n+    zoffset bottom = _va->alloc_low_address(ZMapperTestReservationSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    \/\/ Free two chunks and then allocate them again\n+    _va->free(bottom, ZGranuleSize * 4);\n+    _va->free(bottom + ZGranuleSize * 6, ZGranuleSize * 6);\n+\n+    zoffset offset = _va->alloc_low_address(ZGranuleSize * 4);\n+    EXPECT_ALLOC_OK(offset);\n+\n+    offset = _va->alloc_low_address(ZGranuleSize * 6);\n+    EXPECT_ALLOC_OK(offset);\n+\n+    \/\/ Now free it all, and verify it can be re-allocated\n+    _va->free(bottom, ZMapperTestReservationSize);\n+\n+    bottom = _va->alloc_low_address(ZMapperTestReservationSize);\n+    EXPECT_ALLOC_OK(bottom);\n+\n+    _va->free(bottom, ZMapperTestReservationSize);\n+  }\n+};\n+\n+bool ZMapperTest::_initialized   = false;\n+ZMemoryManager* ZMapperTest::_va = nullptr;\n+\n+TEST_VM_F(ZMapperTest, test_alloc_low_address) {\n+  test_alloc_low_address();\n+}\n+\n+TEST_VM_F(ZMapperTest, test_alloc_high_address) {\n+  test_alloc_high_address();\n+}\n+\n+TEST_VM_F(ZMapperTest, test_alloc_whole_area) {\n+  test_alloc_whole_area();\n+}\n+\n+#endif \/\/ _WINDOWS\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zMapper_windows.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}