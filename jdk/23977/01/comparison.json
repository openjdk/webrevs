{"files":[{"patch":"@@ -420,1 +420,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist, const Unique_Node_List* root_and_safepoints) {\n@@ -471,1 +471,1 @@\n-  debug_only(verify_graph_edges(true\/*check for no_dead_code*\/);)\n+  debug_only(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n@@ -4202,1 +4202,1 @@\n-void Compile::verify_bidirectional_edges(Unique_Node_List &visited) {\n+void Compile::verify_bidirectional_edges(Unique_Node_List& visited, const Unique_Node_List* root_and_safepoints) const {\n@@ -4205,2 +4205,16 @@\n-  Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n-  nstack.push(_root);\n+  Node_List nstack(MAX2(stack_size, (uint) OptoNodeListSize));\n+  if (root_and_safepoints != nullptr) {\n+    assert(root_and_safepoints->member(_root), \"root is not in root_and_safepoints\");\n+    for (unsigned int i = 0, limit = root_and_safepoints->size(); i < limit; i++) {\n+      Node* root_or_safepoint = root_and_safepoints->at(i);\n+      \/\/ If the node is a safepoint, let's check it still has a control input\n+      \/\/ Lack of control input signified that this node was killed by CCP or\n+      \/\/ recursively by remove_globally_dead_node and it shouldn't be a starting\n+      \/\/ point.\n+      if (!root_or_safepoint->is_SafePoint() || root_or_safepoint->in(0) != nullptr) {\n+        nstack.push(root_or_safepoint);\n+      }\n+    }\n+  } else {\n+    nstack.push(_root);\n+  }\n@@ -4256,1 +4270,1 @@\n-void Compile::verify_graph_edges(bool no_dead_code) {\n+void Compile::verify_graph_edges(bool no_dead_code, const Unique_Node_List* root_and_safepoints) const {\n@@ -4261,1 +4275,1 @@\n-    verify_bidirectional_edges(visited);\n+    verify_bidirectional_edges(visited, root_and_safepoints);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1025,1 +1025,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist);\n+  void disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist, const Unique_Node_List* root_and_safepoints = nullptr);\n@@ -1232,5 +1232,19 @@\n-  \/\/ Walk the node list, verifying that there is a one-to-one\n-  \/\/ correspondence between Use-Def edges and Def-Use edges\n-  \/\/ The option no_dead_code enables stronger checks that the\n-  \/\/ graph is strongly connected from root in both directions.\n-  void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;\n+  \/\/ Walk the node list, verifying that there is a one-to-one correspondence\n+  \/\/ between Use-Def edges and Def-Use edges The option no_dead_code enables\n+  \/\/ stronger checks that the graph is strongly connected from starting points\n+  \/\/ in both directions.\n+  \/\/ root_and_safepoints is used to give the starting points for the traversal.\n+  \/\/ If not supplied, only root is used. When this check is called after CCP,\n+  \/\/ we need to start traversal from Root and safepoints, just like CCP does its\n+  \/\/ own traversal (see PhaseCCP::transform for reasons).\n+  \/\/\n+  \/\/ To call this function, there are 2 ways to go:\n+  \/\/ - give root_and_safepoints to start traversal everywhere needed (like after CCP),\n+  \/\/ - if the whole graph is assumed to be reachable from Root's input,\n+  \/\/   root_and_safepoints is not needed (like in PhaseRemoveUseless).\n+  \/\/\n+  \/\/ Failure to specify root_and_safepoints in case the graph is not fully\n+  \/\/ reachable from Root's input make this check unsound (can miss inconsistencies)\n+  \/\/ and even incomplete (can make up non-existing problems) if no_dead_code is\n+  \/\/ true.\n+  void verify_graph_edges(bool no_dead_code = false, const Unique_Node_List* root_and_safepoints = nullptr) const PRODUCT_RETURN;\n@@ -1239,1 +1253,1 @@\n-  void verify_bidirectional_edges(Unique_Node_List &visited);\n+  void verify_bidirectional_edges(Unique_Node_List& visited, const Unique_Node_List* root_and_safepoints = nullptr) const;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1743,1 +1743,1 @@\n-  bool member( Node *n ) { return _in_worklist.test(n->_idx) != 0; }\n+  bool member(const Node* n) const { return _in_worklist.test(n->_idx) != 0; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2113,1 +2113,1 @@\n-  C->disconnect_useless_nodes(useful, _worklist);\n+  C->disconnect_useless_nodes(useful, _worklist, &_root_and_safepoints);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335708\n+ * @summary Crash Compile::verify_graph_edges with dead code check when safepoints are reachable but not connected back to Root's inputs\n+ * @library \/test\/lib\n+ *\n+ * @run driver compiler.loopopts.VerifyGraphEdgesWithDeadCodeCheckFromSafepoints\n+ * @run main\/othervm\n+ *       -XX:+IgnoreUnrecognizedVMOptions\n+ *       -XX:-TieredCompilation -XX:+VerifyGraphEdges\n+ *       -XX:+StressIGVN -Xcomp\n+ *       -XX:CompileCommand=compileonly,compiler.loopopts.VerifyGraphEdgesWithDeadCodeCheckFromSafepoints::mainTest\n+ *       compiler.loopopts.VerifyGraphEdgesWithDeadCodeCheckFromSafepoints\n+ *\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import jdk.test.lib.Utils;\n+\n+public class VerifyGraphEdgesWithDeadCodeCheckFromSafepoints {\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = new Thread() {\n+            public void run() {\n+                VerifyGraphEdgesWithDeadCodeCheckFromSafepoints instance = new VerifyGraphEdgesWithDeadCodeCheckFromSafepoints();\n+                byte[] a = new byte[997];\n+                for (int i = 0; i < 100; ++i) {\n+                    instance.mainTest(a, a);\n+                }\n+            }\n+        };\n+        \/\/ Give thread some time to trigger compilation\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(500));\n+    }\n+\n+    public void mainTest(byte[] a, byte[] b) {\n+        int i = 0;\n+        while (i < (a.length - 4)) {\n+            a[i] = b[i];\n+        }\n+        while (true) {\n+            a[i] = b[i];\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/VerifyGraphEdgesWithDeadCodeCheckFromSafepoints.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}