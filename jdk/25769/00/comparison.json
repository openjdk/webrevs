{"files":[{"patch":"@@ -10530,1 +10530,2 @@\n-  predicate(!UseAPX);\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1 cost agnostic if immI src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10544,1 +10545,2 @@\n-  predicate(UseAPX);\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1_ndd cost agnostic if immI src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10562,0 +10564,1 @@\n+  ins_cost(150);\n@@ -11204,1 +11207,2 @@\n-  predicate(!UseAPX);\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1 cost agnostic if immL32 src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11218,1 +11222,2 @@\n-  predicate(UseAPX);\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1_ndd cost agnostic if immL32 src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11237,0 +11242,1 @@\n+  ins_cost(150);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,13 @@\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W0 F2 \/r\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF};\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF2};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/AndnTestI.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,0 +62,17 @@\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W0 F3 \/3(opcode extension)\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF,\n+                (byte) 0x38};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF3,\n+                (byte) 0b0001_1000}; \/\/ bits 543 == 011 (3)\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BlsiTestI.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,1 +60,18 @@\n-                (byte) 0b0001_0000}; \/\/ bits 543 == 011 (3)\n+                (byte) 0b0001_0000}; \/\/ bits 543 == 010 (2)\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W1 F3 \/2(opcode extension part of ModRM.REG)\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF,\n+                (byte) 0x38};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF3,\n+                (byte) 0b0001_0000}; \/\/ bits 543 == 010 (2)\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BlsmskTestI.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,1 +61,19 @@\n-                (byte) 0b0000_1000}; \/\/ bits 543 == 011 (3)\n+                (byte) 0b0000_1000}; \/\/ bits 543 == 001 (1)\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W1 F3 \/1(opcode extension part of ModRM.REG)\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF,\n+                (byte) 0x38};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF3,\n+                (byte) 0b0000_1000}; \/\/ bits 543 == 001 (1)\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BlsrTestI.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,2 @@\n-        if (!((BmiTestCase) testCase).verifyPositive(nativeCode)) {\n+        boolean use_apx = CPUInfo.hasFeature(\"apx_f\");\n+        if (!((BmiTestCase) testCase).verifyPositive(nativeCode, use_apx)) {\n@@ -127,0 +128,2 @@\n+        protected byte[] instrMaskAPX;\n+        protected byte[] instrPatternAPX;\n@@ -163,0 +166,7 @@\n+        protected int countCpuInstructionsAPX(byte[] nativeCode) {\n+            if (instrMaskAPX == null || instrPatternAPX == null) {\n+                return 0;\n+            }\n+            return countCpuInstructions(nativeCode, instrMaskAPX, instrPatternAPX);\n+        }\n+\n@@ -184,2 +194,6 @@\n-        public boolean verifyPositive(byte[] nativeCode) {\n-            final int cnt = countCpuInstructions(nativeCode);\n+        public boolean verifyPositive(byte[] nativeCode, boolean use_apx) {\n+            int cnt = countCpuInstructions(nativeCode);\n+            if (use_apx) {\n+                System.out.println(\"CHECKING APX INST PATTERNS\");\n+                cnt += countCpuInstructionsAPX(nativeCode);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BmiIntrinsicBase.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,15 @@\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W0 F5 \/r\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF5};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BzhiTestI2L.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,4 @@\n+\n+        \/\/ REX2 variant\n+        instrMaskAPX = new byte[]{(byte) 0xFF, (byte) 0xFF, (byte)0x80, (byte) 0xFF};\n+        instrPatternAPX = new byte[]{(byte) 0xF3, (byte) 0xD5, (byte) 0x80, (byte) 0xBD};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/LZcntTestI.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,4 @@\n+\n+        \/\/ REX2 variant\n+        instrMaskAPX = new byte[]{(byte) 0xFF, (byte) 0xFF, (byte)0x80, (byte) 0xFF};\n+        instrPatternAPX = new byte[]{(byte) 0xF3, (byte) 0xD5, (byte) 0x80, (byte) 0xBC};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/TZcntTestI.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}