{"files":[{"patch":"@@ -1299,0 +1299,3 @@\n+\/\/ Unimplemented\n+size_t os::get_rss() { return 0; }\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1465,0 +1465,12 @@\n+size_t os::get_rss() {\n+  size_t result = 0;\n+#ifdef __APPLE__\n+  mach_task_basic_info info;\n+  mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;\n+  if (task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &count) == KERN_SUCCESS) {\n+    result = info.resident_size;\n+  }\n+#endif \/\/ __APPLE__\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2459,0 +2459,9 @@\n+size_t os::get_rss() {\n+  size_t result = 0;\n+  os::Linux::meminfo_t mi;\n+  if (os::Linux::query_process_memory_info(&mi) && mi.vmrss != -1) {\n+    result = (size_t)mi.vmrss * K;\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2031,0 +2031,11 @@\n+size_t os::get_rss() {\n+  size_t result = 0;\n+  PROCESS_MEMORY_COUNTERS pm;\n+  ZeroMemory(&pm, sizeof(pm));\n+  pm.cb = sizeof(pm);\n+  if (GetProcessMemoryInfo(GetCurrentProcess(), &pm, sizeof(pm))) {\n+    result = pm.WorkingSetSize;\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+  LOG_TAG(rss) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1365,0 +1365,15 @@\n+                                                                            \\\n+  product(ccstr, RssLimit, nullptr, DIAGNOSTIC,                             \\\n+          \"Limit to Resident Set Size. The JVM will periodically \"          \\\n+          \"check if that limit had been reached and, if true, \"             \\\n+          \"generate a fatal error. The limit can be either given as a \"     \\\n+          \"memory size (e.g. \\\"2G\\\") or as a percentage of \"                \\\n+          \"the total available memory on this machine or in this \"          \\\n+          \"container (e.g. \\\"-XX:RssLimit=80%%\\\"). A value of 0 (default) \" \\\n+          \"disables this feature.\")                                         \\\n+                                                                            \\\n+  product(uint, RssLimitCheckInterval, 5000, DIAGNOSTIC,                    \\\n+          \"If RssLimit is set, interval, in ms, at which the JVM will \"     \\\n+          \"check the process resident set size.\"                            \\\n+          range(10, UINT_MAX))                                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -773,0 +773,3 @@\n+  \/\/ Returns the process working set size (rss); 0 if unsupported.\n+  static size_t get_rss();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-              \"improper PeriodicTask interval time\");\n+              \"improper PeriodicTask interval time: %zu\", interval_time);\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  int interval() const { return _interval; }\n+\n","filename":"src\/hotspot\/share\/runtime\/task.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+#include \"services\/rsswatch.hpp\"\n@@ -771,0 +772,5 @@\n+  \/\/ Start RSS watcher task if needed\n+  if (RssLimit != nullptr) {\n+    RssWatcher::initialize(RssLimit);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"services\/rsswatch.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+static void check_rss(size_t limit) {\n+  const size_t rss = os::get_rss();\n+  log_trace(os, rss)(\"Rss=%zu\", rss);\n+  if (rss >= limit) {\n+    fatal(\"Resident Set Size (%zu bytes) reached RssLimit (%zu bytes).\", rss, limit);\n+  }\n+}\n+\n+class RssAbsoluteLimitTask : public PeriodicTask {\n+  const size_t _limit;\n+public:\n+  RssAbsoluteLimitTask(size_t limit, unsigned interval_ms) :\n+    PeriodicTask(interval_ms), _limit(limit) {\n+    log_info(os, rss)(\"RssWatcher task: interval=%ums, limit=\" PROPERFMT,\n+                      interval(), PROPERFMTARGS(_limit));\n+  }\n+  void task() override {\n+    check_rss(_limit);\n+  }\n+};\n+\n+class RssRelativeLimitTask : public PeriodicTask {\n+  const double _percent;\n+  size_t _limit;\n+\n+  void update_limit() {\n+    const size_t limit_100 = os::physical_memory();\n+    const size_t limit_x = (size_t)(((double)limit_100 * _percent) \/ 100.0f);\n+    if (limit_x != _limit) { \/\/ limit changed?\n+      _limit = limit_x;\n+      log_info(os, rss)(\"Setting RssWatcher limit to %zu bytes (%.2f%% of total memory of %zu bytes)\",\n+                        limit_x, _percent, limit_100);\n+    }\n+  }\n+\n+public:\n+\n+  RssRelativeLimitTask(double limit_percent, unsigned interval_ms) :\n+    PeriodicTask(interval_ms), _percent(limit_percent), _limit(0) {\n+    log_info(os, rss)(\"RssWatcher task: interval=%ums, \"\n+                      \"limit=%.2f%% of total memory\", interval(), _percent);\n+  }\n+\n+  void task() override {\n+    update_limit();\n+    check_rss(_limit);\n+  }\n+};\n+\n+static bool parse_percentage(const char* s, const char** tail, double* percentage) {\n+  double v = 0;\n+  char sign;\n+  int chars_read = 0;\n+  if (sscanf(s, \"%lf%c%n\", &v, &sign, &chars_read) >= 2 && sign == '%') {\n+    if (v > 100.0) {\n+      vm_exit_during_initialization(\"Failed to parse RssLimit\", \"Not a valid percentage\");\n+    }\n+    *percentage = v;\n+    *tail = s + chars_read;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void RssWatcher::initialize(const char* limit_option) {\n+  assert(limit_option != nullptr, \"Invalid argument\");\n+\n+  bool is_absolute = true;\n+  size_t limit = 0;\n+  double percentage = 0;\n+  const char* s = limit_option;\n+\n+  if (parse_percentage(s, &s, &percentage)) {\n+    is_absolute = false;\n+  } else {\n+    if (!parse_integer(s, (char**)&s, &limit) || limit == 0) {\n+      vm_exit_during_initialization(\"Failed to parse RssLimit\", \"Not a valid limit size\");\n+    }\n+  }\n+\n+  \/\/ PeriodicTask has some limitations:\n+  \/\/ - minimum task time\n+  \/\/ - task time aligned to (non-power-of-2) alignment.\n+  \/\/ For convenience, we just adjust the interval.\n+  unsigned interval = RssLimitCheckInterval;\n+  interval \/= PeriodicTask::interval_gran;\n+  interval *= PeriodicTask::interval_gran;\n+  interval = MAX2(interval, (unsigned)PeriodicTask::min_interval);\n+  if (interval != RssLimitCheckInterval) {\n+    log_warning(os, rss)(\"RssLimit interval has been adjusted to %ums\", interval);\n+  }\n+  PeriodicTask* const task = (is_absolute) ?\n+       (PeriodicTask*) new RssAbsoluteLimitTask(limit, interval) :\n+       (PeriodicTask*) new RssRelativeLimitTask(percentage, interval);\n+  task->enroll();\n+}\n","filename":"src\/hotspot\/share\/services\/rsswatch.cpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SERVICES_RSSWATCH_HPP\n+#define SERVICES_RSSWATCH_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ A facility that will periodically check RSS, and, if a threshold is\n+\/\/ reached, stop the VM with a fatal error. Controlled by -XX:RssLimit=xxx\n+\/\/ and -XX:RssWatchInterval\n+\n+struct RssWatcher: public AllStatic {\n+\n+  static void initialize(const char* limit_option);\n+\n+};\n+\n+#endif \/\/ OS_LINUX_RSSWATCH_HPP\n","filename":"src\/hotspot\/share\/services\/rsswatch.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=test-absolute-limit\n+ * @summary Verify -XX:RssLimit with an absolute limit\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-absolute-limit\n+ *\/\n+\n+\/*\n+ * @test id=test-relative-limit\n+ * @summary Verify -XX:RssLimit with a relative limit\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-relative-limit\n+ *\/\n+\n+\/*\n+ * @test id=test-high-interval\n+ * @summary Verify -XX:RssLimit with an absolute limit\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-high-interval\n+ *\/\n+\n+\/*\n+ * @test id=test-default-interval\n+ * @summary Verify -XX:RssLimit with an absolute limit\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-default-interval\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class RssLimitTest {\n+\n+    private static OutputAnalyzer runWithSettings(String... extraSettings) throws IOException {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ RssLimit is diagnostic\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:os+rss\");\n+        args.addAll(Arrays.asList(extraSettings));\n+        args.add(RssLimitTest.class.getName());\n+        args.add(\"sleep\");\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        return new OutputAnalyzer(pb.start());\n+    }\n+\n+    private static void testAbsoluteLimit() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimit=100m\", \"-XX:RssLimitCheckInterval=100\",\n+                \"-Xmx100m\", \"-Xms100m\", \"-XX:+AlwaysPreTouch\");\n+        o.shouldNotHaveExitValue(0);\n+        o.shouldContain(\"RssWatcher task: interval=100ms, limit=100M\");\n+        o.shouldMatch(\"#  fatal error: Resident Set Size \\\\(\\\\d+ bytes\\\\) reached RssLimit \\\\(104857600 bytes\\\\)\");\n+    }\n+\n+    private static void testRelativeLimit() throws IOException {\n+        \/\/ We start with 0,01% of total memory. Depending on the size of the test machine,\n+        \/\/ this may or may not crash us.\n+        DecimalFormat format = (DecimalFormat) DecimalFormat.getInstance();\n+        char dot = format.getDecimalFormatSymbols().getDecimalSeparator();\n+        String limitPercent = \"0\" + dot + \"01%\";\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimit=\" + limitPercent, \"-XX:RssLimitCheckInterval=100\",\n+                \"-Xmx100m\", \"-Xms100m\", \"-XX:+AlwaysPreTouch\");\n+        o.shouldContain(\"RssWatcher task: interval=100ms, limit=\" + limitPercent + \" of total memory\");\n+        String pat = \"Setting RssWatcher limit to (\\\\d+) bytes \\\\(0.01% of total memory of \\\\d+ bytes\\\\)\";\n+        String limitString = o.firstMatch(pat, 1);\n+        long limit = Long.parseLong(limitString);\n+        if (limit < 100 * 1024 * 1024) {\n+            o.shouldNotHaveExitValue(0);\n+        }\n+        if (o.getExitValue() != 0) {\n+            o.shouldMatch(\"#  fatal error: Resident Set Size \\\\(\\\\d+ bytes\\\\) reached RssLimit \\\\(\" + limit + \" bytes\\\\).*\");\n+        }\n+    }\n+\n+    private static void testLimitWithVeryHighInterval() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimit=100m\", \"-XX:RssLimitCheckInterval=120000\",\n+                \"-Xmx100m\", \"-Xms100m\", \"-XX:+AlwaysPreTouch\");\n+        o.shouldContain(\"RssWatcher task: interval=120000ms, limit=100M\");\n+        o.shouldNotContain(\"Error\");\n+        o.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testPercentageWithDefaultInterval() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimit=99%\",\n+                \"-Xmx100m\", \"-Xms100m\", \"-XX:+AlwaysPreTouch\");\n+        o.shouldContain(\"RssWatcher task: interval=5000ms, limit=99.00% of total memory\");\n+        o.shouldNotContain(\"Error\");\n+        o.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        switch (args[0]) {\n+            case \"sleep\":\n+                Thread.sleep(1000);\n+                break;\n+            case \"test-absolute-limit\":\n+                testAbsoluteLimit();\n+                break;\n+            case \"test-relative-limit\":\n+                testRelativeLimit();\n+                break;\n+            case \"test-high-interval\":\n+                testLimitWithVeryHighInterval();\n+                break;\n+            case \"test-default-interval\":\n+                testPercentageWithDefaultInterval();\n+                break;\n+            default:\n+                throw new RuntimeException(\"Invalid argument (\" + args[0] + \")\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/RssLimitTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}