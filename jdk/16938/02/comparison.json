{"files":[{"patch":"@@ -1299,0 +1299,3 @@\n+\/\/ Unimplemented\n+size_t os::get_RSS() { return 0; }\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1465,0 +1465,12 @@\n+size_t os::get_RSS() {\n+  size_t result = 0;\n+#ifdef __APPLE__\n+  mach_task_basic_info info;\n+  mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;\n+  if (task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &count) == KERN_SUCCESS) {\n+    result = info.resident_size;\n+  }\n+#endif \/\/ __APPLE__\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2459,0 +2459,9 @@\n+size_t os::get_RSS() {\n+  size_t result = 0;\n+  os::Linux::meminfo_t mi;\n+  if (os::Linux::query_process_memory_info(&mi) && mi.vmrss != -1) {\n+    result = (size_t)mi.vmrss * K;\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2031,0 +2031,11 @@\n+size_t os::get_RSS() {\n+  size_t result = 0;\n+  PROCESS_MEMORY_COUNTERS pm;\n+  ZeroMemory(&pm, sizeof(pm));\n+  pm.cb = sizeof(pm);\n+  if (GetProcessMemoryInfo(GetCurrentProcess(), &pm, sizeof(pm))) {\n+    result = pm.WorkingSetSize;\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+  LOG_TAG(rss) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1365,0 +1365,18 @@\n+  product(size_t, RssLimit, 0, DIAGNOSTIC,                                  \\\n+          \"Limit to Resident Set Size. The JVM will periodically \"          \\\n+          \"check if that limit had been reached and, if true, \"             \\\n+          \"generate a fatal error. A value of 0 (default) disables the \"    \\\n+          \"limit.\")                                                         \\\n+          range(0, SIZE_MAX)                                                \\\n+                                                                            \\\n+  product(uint, RssLimitPercent, 0, DIAGNOSTIC,                             \\\n+          \"Limit to Resident Set Size, given as percent of the total \"      \\\n+          \"physical memory of the machine or the memory limit of the \"      \\\n+          \"container. A value of 0 (default) disables the limit.\")          \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, RssLimitCheckInterval, 1000, DIAGNOSTIC,                    \\\n+          \"If RssLimit or RssLimitPercent are set, interval, in ms, at \"    \\\n+          \"which the JVM will check the process resident set size.\")        \\\n+          range(10, INT_MAX)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -773,0 +773,3 @@\n+  \/\/ Returns the process working set size (rss); 0 if unsupported.\n+  static size_t get_RSS();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-              \"improper PeriodicTask interval time\");\n+              \"improper PeriodicTask interval time: %zu\", interval_time);\n","filename":"src\/hotspot\/share\/runtime\/task.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  int interval() const { return _interval; }\n+\n","filename":"src\/hotspot\/share\/runtime\/task.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+#include \"services\/rsswatch.hpp\"\n@@ -771,0 +772,3 @@\n+  \/\/ Start RSS watcher task if needed\n+  RssWatcher::initialize();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"services\/rsswatch.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class RssLimitTask : public PeriodicTask {\n+protected:\n+  RssLimitTask() : PeriodicTask(RssLimitCheckInterval) {}\n+  void check_rss(size_t limit) {\n+    const size_t rss = os::get_RSS();\n+    log_trace(os, rss)(\"Rss=%zu\", rss);\n+    if (rss >= limit) {\n+      fatal(\"Resident Set Size (%zu bytes) reached RssLimit (%zu bytes).\", rss, limit);\n+    }\n+  }\n+};\n+\n+class RssAbsoluteLimitTask : public RssLimitTask {\n+  const size_t _limit;\n+public:\n+  RssAbsoluteLimitTask(size_t limit) :\n+    _limit(limit) {\n+    log_info(os, rss)(\"RssWatcher task: interval=%ums, limit=\" PROPERFMT,\n+                      interval(), PROPERFMTARGS(_limit));\n+  }\n+  void task() override {\n+    check_rss(_limit);\n+  }\n+};\n+\n+class RssRelativeLimitTask : public RssLimitTask {\n+  const unsigned _percent;\n+  size_t _limit;\n+\n+  void update_limit() {\n+    const size_t limit_100 = os::physical_memory();\n+    const size_t limit_x = (size_t)(((double)limit_100 * _percent) \/ 100.0f);\n+    if (limit_x != _limit) { \/\/ limit changed?\n+      _limit = limit_x;\n+      log_info(os, rss)(\"Setting RssWatcher limit to %zu bytes (%u%% of total memory of %zu bytes)\",\n+                        limit_x, _percent, limit_100);\n+    }\n+  }\n+\n+public:\n+\n+  RssRelativeLimitTask(unsigned percent) :\n+    _percent(percent), _limit(0) {\n+    log_info(os, rss)(\"RssWatcher task: interval=%ums, \"\n+                      \"limit=%u%% of total memory\", interval(), _percent);\n+  }\n+\n+  void task() override {\n+    update_limit();\n+    check_rss(_limit);\n+  }\n+};\n+\n+void RssWatcher::initialize() {\n+\n+  if (RssLimit == 0 && RssLimitPercent == 0) {\n+    return;\n+  }\n+\n+  if (RssLimit > 0 && RssLimitPercent > 0) {\n+    vm_exit_during_initialization(\"Please specify either RssLimit or RssLimitPercent, but not both\");\n+  }\n+\n+  if (os::get_RSS() == 0) {\n+    log_warning(os, rss)(\"RssLimit specified, but not supported by the Operating System.\");\n+    return;\n+  }\n+\n+  \/\/ Sanity-check the interval given. We use PeriodicTask, and that has some limitations:\n+  \/\/ - minimum task time\n+  \/\/ - task time aligned to (non-power-of-2) alignment.\n+  \/\/ For convenience, we just adjust the interval.\n+  unsigned interval = RssLimitCheckInterval;\n+  interval \/= PeriodicTask::interval_gran;\n+  interval *= PeriodicTask::interval_gran;\n+  interval = MAX2(interval, (unsigned)PeriodicTask::min_interval);\n+  if (interval != RssLimitCheckInterval) {\n+    log_warning(os, rss)(\"RssLimit interval has been adjusted to %ums\", interval);\n+  }\n+\n+  RssLimitTask* const task = (RssLimit > 0) ?\n+       (RssLimitTask*)new RssAbsoluteLimitTask(RssLimit) :\n+       (RssLimitTask*)new RssRelativeLimitTask(RssLimitPercent);\n+\n+  task->enroll();\n+}\n","filename":"src\/hotspot\/share\/services\/rsswatch.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SERVICES_RSSWATCH_HPP\n+#define SERVICES_RSSWATCH_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ A facility that will periodically check RSS, and, if a threshold is\n+\/\/ reached, stop the VM with a fatal error. Controlled by -XX:RssLimit=xxx\n+\/\/ and -XX:RssWatchInterval\n+\n+struct RssWatcher: public AllStatic {\n+\n+  static void initialize();\n+\n+};\n+\n+#endif \/\/ OS_LINUX_RSSWATCH_HPP\n","filename":"src\/hotspot\/share\/services\/rsswatch.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=test-absolute-limit\n+ * @summary Verify -XX:RssLimit with an absolute limit\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-absolute-limit\n+ *\/\n+\n+\/*\n+ * @test id=test-relative-limit\n+ * @summary Verify -XX:RssLimit with a relative limit\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-relative-limit\n+ *\/\n+\n+\/*\n+ * @test id=test-high-interval\n+ * @summary Verify -XX:RssLimit with a high interval\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-high-interval\n+ *\/\n+\n+\/*\n+ * @test id=test-default-interval\n+ * @summary Verify -XX:RssLimit default interval\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-default-interval\n+ *\/\n+\n+\/*\n+ * @test id=test-default-off\n+ * @summary Verify -XX:RssLimit is off by default\n+ * @requires vm.flagless\n+ * @requires os.family != \"aix\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver RssLimitTest test-default-off\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class RssLimitTest {\n+\n+    private static OutputAnalyzer runWithSettings(String... extraSettings) throws IOException {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ RssLimit is diagnostic\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:os+rss\");\n+        args.addAll(Arrays.asList(extraSettings));\n+        args.add(RssLimitTest.class.getName());\n+        args.add(\"sleep\");\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        return new OutputAnalyzer(pb.start());\n+    }\n+\n+    private static void testAbsoluteLimit() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimit=100m\", \"-XX:RssLimitCheckInterval=100\",\n+                \"-Xmx100m\", \"-Xms100m\", \"-XX:+AlwaysPreTouch\");\n+        o.shouldNotHaveExitValue(0);\n+        o.shouldContain(\"RssWatcher task: interval=100ms, limit=100M\");\n+        o.shouldMatch(\"#  fatal error: Resident Set Size \\\\(\\\\d+ bytes\\\\) reached RssLimit \\\\(104857600 bytes\\\\)\");\n+    }\n+\n+    private static void testRelativeLimit() throws IOException {\n+        \/\/ We start with 0,01% of total memory. Depending on the size of the test machine,\n+        \/\/ this may or may not crash us.\n+        DecimalFormat format = (DecimalFormat) DecimalFormat.getInstance();\n+        char dot = format.getDecimalFormatSymbols().getDecimalSeparator();\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimitPercent=1\", \"-XX:RssLimitCheckInterval=100\",\n+                \"-Xmx100m\", \"-Xms100m\", \"-XX:+AlwaysPreTouch\");\n+        o.shouldContain(\"RssWatcher task: interval=100ms, limit=1% of total memory\");\n+        String pat = \"Setting RssWatcher limit to (\\\\d+) bytes \\\\(1% of total memory of \\\\d+ bytes\\\\)\";\n+        String limitString = o.firstMatch(pat, 1);\n+        long limit = Long.parseLong(limitString);\n+        if (limit < 100 * 1024 * 1024) {\n+            o.shouldNotHaveExitValue(0);\n+        }\n+        if (o.getExitValue() != 0) {\n+            o.shouldMatch(\"#  fatal error: Resident Set Size \\\\(\\\\d+ bytes\\\\) reached RssLimit \\\\(\" + limit + \" bytes\\\\).*\");\n+        }\n+    }\n+\n+    private static void testLimitWithVeryHighInterval() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimit=100m\", \"-XX:RssLimitCheckInterval=120000\",\n+                \"-Xmx100m\");\n+        o.shouldContain(\"RssWatcher task: interval=120000ms, limit=100M\");\n+        o.shouldNotContain(\"Error\");\n+        o.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testPercentageWithDefaultInterval() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\n+                \"-XX:RssLimitPercent=99\",\n+                \"-Xmx100m\");\n+        o.shouldContain(\"RssWatcher task: interval=1000ms, limit=99% of total memory\");\n+        o.shouldNotContain(\"Error\");\n+        o.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testDefaultOff() throws IOException {\n+        OutputAnalyzer o = runWithSettings(\"-Xmx100m\");\n+        o.shouldNotContain(\"RssWatcher\");\n+        o.shouldNotContain(\"Error\");\n+        o.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        switch (args[0]) {\n+            case \"sleep\":\n+                Thread.sleep(1000);\n+                break;\n+            case \"test-absolute-limit\":\n+                testAbsoluteLimit();\n+                break;\n+            case \"test-relative-limit\":\n+                testRelativeLimit();\n+                break;\n+            case \"test-high-interval\":\n+                testLimitWithVeryHighInterval();\n+                break;\n+            case \"test-default-interval\":\n+                testPercentageWithDefaultInterval();\n+                break;\n+            case \"test-default-off\":\n+                testDefaultOff();\n+                break;\n+            default:\n+                throw new RuntimeException(\"Invalid argument (\" + args[0] + \")\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/RssLimitTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}