{"files":[{"patch":"@@ -2897,1 +2897,1 @@\n-                        boolean hasTypeArgs = false;\n+                        boolean inTypeArgs = false;\n@@ -2903,2 +2903,3 @@\n-                                case COMMA: if (balance == 1 && !hasTypeArgs) hasComma = true; break;\n-                                case LT: hasTypeArgs = true;\n+                                case COMMA: if (balance == 1 && !inTypeArgs) hasComma = true; break;\n+                                case LT: inTypeArgs = true; break;\n+                                case GT: inTypeArgs = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile T8326204.java\n+ * @compile T8326204a.java\n@@ -32,1 +32,1 @@\n-public class T8326204 {\n+public class T8326204a {\n","filename":"test\/langtools\/tools\/javac\/T8326204a.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/javac\/T8326204.java","status":"renamed"},{"patch":"@@ -0,0 +1,13 @@\n+import java.util.Map;\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8326204\n+ * @summary yield statements doesn't allow cast expressions with more than 1 type arguments\n+ * @compile\/fail\/ref=T8326204b.out -XDrawDiagnostics --should-stop=at=FLOW -XDdev T8326204b.java\n+ *\/\n+public class T8326204b {\n+    private static void t(int i) { yield((Map<String, String>) null, 2); }\n+\n+    private static void yield(Map<String, String> m, int j) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8326204b.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8326204b.java:10:36: compiler.err.invalid.yield\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8326204b.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}