{"files":[{"patch":"@@ -85,2 +85,1 @@\n-        POSIX_SPAWN,\n-        VFORK\n+        POSIX_SPAWN\n@@ -101,22 +100,7 @@\n-            LaunchMechanism lm = LaunchMechanism.valueOf(s.toUpperCase(Locale.ROOT));\n-            switch (OperatingSystem.current()) {\n-                case LINUX: {\n-                    \/\/ All options are valid for Linux, but VFORK is deprecated and results\n-                    \/\/ in a warning\n-                    if (lm == LaunchMechanism.VFORK) {\n-                        System.err.println(\"VFORK MODE DEPRECATED\");\n-                        System.err.println(\"\"\"\n-                                          The VFORK launch mechanism has been deprecated for being dangerous.\n-                                          It will be removed in a future java version. Either remove the\n-                                          jdk.lang.Process.launchMechanism property (preferred) or use FORK mode\n-                                          instead (-Djdk.lang.Process.launchMechanism=FORK).\n-                                          \"\"\");\n-                    }\n-                    return lm;\n-                }\n-                case AIX:\n-                case MACOS:\n-                    if (lm != LaunchMechanism.VFORK) {\n-                        return lm; \/\/ All but VFORK are valid\n-                    }\n-                    break;\n+            String launchMechanism = s.toUpperCase(Locale.ROOT);\n+            if (launchMechanism.equals(\"VFORK\") && OperatingSystem.isLinux()) {\n+                System.err.println(\"\"\"\n+                                   The VFORK launch mechanism has been removed. Please either remove the\n+                                   jdk.lang.Process.launchMechanism property (preferred) or use FORK mode\n+                                   instead (-Djdk.lang.Process.launchMechanism=FORK).\n+                                   \"\"\");\n@@ -124,0 +108,1 @@\n+            return LaunchMechanism.valueOf(launchMechanism);\n@@ -269,1 +254,0 @@\n-     *   3 - vfork(2) and exec(2)\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":25,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * There are three ways to fork off:\n+ * On the OS-side are four ways to fork off:\n@@ -77,14 +77,4 @@\n- *    the parent. Things that can go wrong include:\n- *    - Programming errors in the child process before the exec(2) call may\n- *      trash memory in the parent process, most commonly the stack of the\n- *      thread invoking vfork.\n- *    - Signals received by the child before the exec(2) call may be at best\n- *      misdirected to the parent, at worst immediately kill child and parent.\n- *\n- *    This is mitigated by very strict rules about what one is allowed to do in\n- *    the child process between vfork(2) and exec(2), which is basically nothing.\n- *    However, we always broke this rule by doing the pre-exec work between\n- *    vfork(2) and exec(2).\n- *\n- *    Also note that vfork(2) has been deprecated by the OpenGroup, presumably\n- *    because of its many dangers.\n+ *    the parent.\n+ *    *** This mode is inherently dangerous, and the danger partly outside the control\n+ *        of the programmer (for details, see JDK-8357090). Therefore, we deprecated\n+ *        the vfork mode with JDK 25 and removed if with JDK 26. ***\n@@ -96,9 +86,8 @@\n- * Aside from these three possibilities there is a forth option:  posix_spawn(3).\n- * Where fork\/vfork\/clone all fork off the process and leave pre-exec work and\n- * calling exec(2) to the user, posix_spawn(3) offers the user fork+exec-like\n- * functionality in one package, similar to CreateProcess() on Windows.\n- *\n- * It is not a system call in itself, but usually a wrapper implemented within\n- * the libc in terms of one of (fork|vfork|clone)+exec - so whether or not it\n- * has advantages over calling the naked (fork|vfork|clone) functions depends\n- * on how posix_spawn(3) is implemented.\n+ * D) posix_spawn(3): Where fork\/vfork\/clone all fork off the process and leave\n+ * pre-exec work and calling exec(2) to the user, posix_spawn(3) offers the user\n+ * fork+exec-like functionality in one package, similar to CreateProcess() on Windows.\n+ * It is not a system call, but usually a wrapper implemented within the libc in terms\n+ * of one of (fork|vfork|clone)+exec - so whether or not it has advantages over calling\n+ * the naked (fork|vfork|clone) functions depends on how posix_spawn(3) is implemented.\n+ * Note, however, that even if posix_spawn(3) uses vfork(2) internally, that is still fine -\n+ * the assumption here is that the libc developers know how to mitigate the vfork problems.\n@@ -489,22 +478,0 @@\n-\/* vfork(2) is deprecated on Darwin *\/\n-#ifndef __APPLE__\n-static pid_t\n-vforkChild(ChildStuff *c) {\n-    volatile pid_t resultPid;\n-\n-    \/*\n-     * We separate the call to vfork into a separate function to make\n-     * very sure to keep stack of child from corrupting stack of parent,\n-     * as suggested by the scary gcc warning:\n-     *  warning: variable 'foo' might be clobbered by 'longjmp' or 'vfork'\n-     *\/\n-    resultPid = vfork();\n-\n-    if (resultPid == 0) {\n-        childProcess(c);\n-    }\n-    assert(resultPid != 0);  \/* childProcess never returns *\/\n-    return resultPid;\n-}\n-#endif\n-\n@@ -655,5 +622,0 @@\n-\/* vfork(2) is deprecated on Darwin*\/\n-      #ifndef __APPLE__\n-      case MODE_VFORK:\n-        return vforkChild(c);\n-      #endif\n@@ -768,3 +730,0 @@\n-          case MODE_VFORK:\n-            throwInternalIOException(env, errno, \"vfork failed\", c->mode);\n-            break;\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":13,"deletions":54,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -208,25 +208,0 @@\n-\/**\n- * Exec FILE as a traditional Bourne shell script (i.e. one without #!).\n- * If we could do it over again, we would probably not support such an ancient\n- * misfeature, but compatibility wins over sanity.  The original support for\n- * this was imported accidentally from execvp().\n- *\/\n-static void\n-execve_as_traditional_shell_script(const char *file,\n-                                   const char *argv[],\n-                                   const char *const envp[])\n-{\n-    \/* Use the extra word of space provided for us in argv by caller. *\/\n-    const char *argv0 = argv[0];\n-    const char *const *end = argv;\n-    while (*end != NULL)\n-        ++end;\n-    memmove(argv+2, argv+1, (end-argv) * sizeof(*end));\n-    argv[0] = \"\/bin\/sh\";\n-    argv[1] = file;\n-    execve(argv[0], (char **) argv, (char **) envp);\n-    \/* Can't even exec \/bin\/sh?  Big trouble, but let's soldier on... *\/\n-    memmove(argv+1, argv+2, (end-argv) * sizeof(*end));\n-    argv[0] = argv0;\n-}\n-\n@@ -242,10 +217,3 @@\n-    if (mode == MODE_VFORK) {\n-        \/* shared address space; be very careful. *\/\n-        execve(file, (char **) argv, (char **) envp);\n-        if (errno == ENOEXEC)\n-            execve_as_traditional_shell_script(file, argv, envp);\n-    } else {\n-        \/* unshared address space; we can mutate environ. *\/\n-        environ = (char **) envp;\n-        execvp(file, (char **) argv);\n-    }\n+    \/* unshared address space; we can mutate environ. *\/\n+    environ = (char **) envp;\n+    execvp(file, (char **) argv);\n@@ -409,6 +377,4 @@\n-    \/\/ Reset any mask signals from parent, but not in VFORK mode\n-    if (p->mode != MODE_VFORK) {\n-        sigset_t unblock_signals;\n-        sigemptyset(&unblock_signals);\n-        sigprocmask(SIG_SETMASK, &unblock_signals, NULL);\n-    }\n+    \/\/ Reset any mask signals from parent\n+    sigset_t unblock_signals;\n+    sigemptyset(&unblock_signals);\n+    sigprocmask(SIG_SETMASK, &unblock_signals, NULL);\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":7,"deletions":41,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-#define MODE_VFORK 3\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}