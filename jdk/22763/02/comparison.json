{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -45,1 +46,1 @@\n-public class WriteBarrier {\n+public abstract class WriteBarrier {\n@@ -53,2 +54,0 @@\n-    private Object[] realReferencesSmall;\n-    private Object[] nullReferencesSmall;\n@@ -58,2 +57,0 @@\n-    private Object[] realReferencesLarge;\n-    private Object[] nullReferencesLarge;\n@@ -62,0 +59,3 @@\n+    private Object nullRef;\n+    private Object realRef;\n+\n@@ -87,2 +87,0 @@\n-        realReferencesSmall = new Object[NUM_REFERENCES_SMALL];\n-        nullReferencesSmall = new Object[NUM_REFERENCES_SMALL];\n@@ -92,2 +90,0 @@\n-        realReferencesLarge = new Object[NUM_REFERENCES_LARGE];\n-        nullReferencesLarge = new Object[NUM_REFERENCES_LARGE];\n@@ -102,1 +98,0 @@\n-            realReferencesSmall[i] = new Object();\n@@ -107,1 +102,0 @@\n-            realReferencesLarge[i] = new Object();\n@@ -110,0 +104,2 @@\n+        realRef = new Object();\n+\n@@ -127,0 +123,5 @@\n+    \/\/ This and the other testArrayWriteBarrierFast benchmarks below should not\n+    \/\/ be inlined into the JMH-generated harness method. If the methods were\n+    \/\/ inlined, we might spill in the main loop (on x64) depending on very\n+    \/\/ subtle conditions (such as whether LinuxPerfAsmProfiler is enabled!),\n+    \/\/ which could distort the results.\n@@ -128,0 +129,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -130,1 +132,1 @@\n-            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realReferencesSmall[indicesSmall[i]];\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = realRef;\n@@ -135,0 +137,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -137,1 +140,1 @@\n-            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = nullReferencesSmall[indicesSmall[i]];\n+            theArraySmall[indicesSmall[NUM_REFERENCES_SMALL - i - 1]] = nullRef;\n@@ -142,0 +145,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -144,1 +148,1 @@\n-            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = realReferencesLarge[indicesLarge[i]];\n+            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = realRef;\n@@ -149,0 +153,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -151,1 +156,1 @@\n-            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = nullReferencesLarge[indicesLarge[i]];\n+            theArrayLarge[indicesLarge[NUM_REFERENCES_LARGE - i - 1]] = nullRef;\n@@ -163,0 +168,11 @@\n+\n+    \/\/ This run is useful to compare different GC barrier models without being\n+    \/\/ affected by C2 unrolling the main loop differently for each model.\n+    @Fork(value = 3, jvmArgs = {\"-XX:LoopUnrollLimit=1\"})\n+    public static class WithoutUnrolling extends WriteBarrier {}\n+\n+    \/\/ This run is useful to study the interaction of GC barriers and loop\n+    \/\/ unrolling. Check that the main loop in the testArray benchmarks is\n+    \/\/ unrolled (or not) as expected for the studied GC barrier model.\n+    @Fork(value = 3)\n+    public static class WithDefaultUnrolling extends WriteBarrier {}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/WriteBarrier.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"}]}