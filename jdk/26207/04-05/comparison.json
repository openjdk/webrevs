{"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","binary":true,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/\/ TEMP: Touch file to force GitHub to recognize as text, not binary\n+\n@@ -39,0 +39,1 @@\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n@@ -153,0 +154,1 @@\n+  friend class VM_G1ShrinkHeap;\n@@ -196,0 +198,2 @@\n+  G1HeapEvaluationTask* _heap_evaluation_task;\n+\n@@ -582,0 +586,4 @@\n+  \/\/ Request an immediate heap contraction of (at most) the given number of bytes. \n+  \/\/ Returns true if any pages were actually uncommitted.\n+  bool request_heap_shrink(size_t shrink_bytes);\n+\n@@ -922,0 +930,2 @@\n+  \/\/ The heap sizing policy.\n+  G1HeapSizingPolicy* heap_sizing_policy() const { return _heap_sizing_policy; }\n@@ -1348,0 +1358,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/\/ TEMP: Touch file to force GitHub to recognize as text, not binary\n+\n@@ -27,0 +27,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"  \/\/ For flag declarations\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"gc\/g1\/g1HeapRegionManager.inline.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -32,0 +36,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -35,0 +41,8 @@\n+\/\/ Initialize static member\n+jlong G1HeapSizingPolicy::_uncommit_delay_ms = 0;\n+\n+void G1HeapSizingPolicy::initialize() {\n+  \/\/ Flag values are available at this point\n+  _uncommit_delay_ms = (jlong)G1UncommitDelayMillis;\n+}\n+\n@@ -440,0 +454,148 @@\n+\n+void G1HeapSizingPolicy::get_uncommit_candidates(GrowableArray<G1HeapRegion*>* candidates) {\n+  uint inactive_regions = 0;\n+\n+  \/\/ Check each heap region for inactivity\n+  class UncommitCandidatesClosure : public G1HeapRegionClosure {\n+    GrowableArray<G1HeapRegion*>* _candidates;\n+    uint* _inactive_regions;\n+    const G1HeapSizingPolicy* _policy;\n+  public:\n+    UncommitCandidatesClosure(GrowableArray<G1HeapRegion*>* candidates, \n+                             uint* inactive_regions,\n+                             const G1HeapSizingPolicy* policy) :\n+      _candidates(candidates),\n+      _inactive_regions(inactive_regions),\n+      _policy(policy) {}\n+\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n+      if (r->is_empty() && _policy->should_uncommit_region(r)) {\n+        _candidates->append(r);\n+        (*_inactive_regions)++;\n+      }\n+      return false;\n+    }\n+  } cl(candidates, &inactive_regions, this);\n+\n+  _g1h->heap_region_iterate(&cl);\n+\n+  if (inactive_regions > 0) {\n+    log_debug(gc, sizing)(\"Uncommit candidates found: %u inactive regions out of %u total regions\",\n+                  inactive_regions, _g1h->max_num_regions());\n+    log_debug(gc, sizing)(\"Region state transition: %u regions found eligible for uncommit after scan\",\n+                  inactive_regions);\n+  }\n+  log_debug(gc, sizing)(\"Full region scan: found %u inactive regions out of %u total regions\",\n+                       inactive_regions,\n+                       _g1h->max_num_regions());\n+}\n+\n+bool G1HeapSizingPolicy::should_uncommit_region(G1HeapRegion* hr) const {\n+  \/\/ Note: Caller already guarantees hr->is_empty() is true\n+  \/\/ Empty regions should always be free and not in collection set in normal operation\n+\n+  jlong current_time = os::javaTimeMillis();\n+  jlong last_access = hr->last_access_time();\n+  jlong elapsed = current_time - last_access;\n+\n+  log_trace(gc, sizing)(\"Region %u uncommit check: elapsed=\" JLONG_FORMAT \"ms threshold=\" JLONG_FORMAT \"ms last_access=\" JLONG_FORMAT \" now=\" JLONG_FORMAT \" empty=%s\",\n+                     hr->hrm_index(), elapsed, (jlong)_uncommit_delay_ms, last_access, current_time, \n+                     hr->is_empty() ? \"true\" : \"false\");\n+\n+  bool should_uncommit = elapsed > (jlong)_uncommit_delay_ms;\n+  if (should_uncommit) {\n+    log_debug(gc, sizing)(\"Region state transition: Region %u transitioning from active to inactive after \" JLONG_FORMAT \"ms idle\",\n+                  hr->hrm_index(), elapsed);\n+  }\n+\n+  return should_uncommit;\n+}\n+\n+size_t G1HeapSizingPolicy::evaluate_heap_resize(bool& expand) {\n+  expand = false; \/\/ Time-based sizing only handles uncommit, never expansion\n+\n+  if (!G1UseTimeBasedHeapSizing) {\n+    return 0;\n+  }\n+\n+  \/\/ Don't resize during GC\n+  if (_g1h->is_stw_gc_active()) {\n+    return 0;\n+  }\n+\n+  \/\/ Must hold Heap_lock during heap resizing\n+  MutexLocker ml(Heap_lock);\n+\n+  ResourceMark rm; \/\/ Ensure GrowableArray resources are properly released\n+\n+  \/\/ Find regions eligible for uncommit  \n+  GrowableArray<G1HeapRegion*> candidates;\n+  get_uncommit_candidates(&candidates);\n+\n+  uint inactive_count = candidates.length();\n+  uint total_regions = _g1h->max_num_regions();\n+\n+  \/\/ Need minimum number of inactive regions to proceed\n+  if (inactive_count >= G1MinRegionsToUncommit) {\n+    size_t region_size = G1HeapRegion::GrainBytes;\n+    size_t current_heap = _g1h->capacity();\n+    size_t min_heap = MAX2((size_t)InitialHeapSize, MinHeapSize);  \/\/ Never go below initial size\n+\n+    \/\/ Calculate maximum bytes we can uncommit while respecting min heap size\n+    size_t max_shrink_bytes = current_heap > min_heap ? current_heap - min_heap : 0;\n+\n+    log_trace(gc, sizing)(\"Time-based evaluation details: current_heap=%zuB min_heap=%zuB \"\n+                         \"region_size=%zuB max_shrink=%zuB initial_size=%zuB\",\n+                         current_heap, min_heap, region_size, max_shrink_bytes, InitialHeapSize);\n+\n+    if (max_shrink_bytes > 0 && region_size > 0) {\n+      size_t max_inactive_regions = max_shrink_bytes \/ region_size;\n+\n+      \/\/ Calculate maximum uncommit target as the smaller of:\n+      \/\/ 1. No more than 25% of inactive regions\n+      \/\/ 2. No more than 10% of total committed regions\n+      \/\/ 3. No more than max_shrink_bytes worth of regions\n+      size_t committed_regions = current_heap \/ region_size;\n+\n+      \/\/ Upper limits:\n+      size_t by_inactive = static_cast<size_t>(inactive_count) \/ 4;    \/\/ 25%\n+      size_t by_total = static_cast<size_t>(committed_regions) \/ 10;   \/\/ 10%\n+\n+      size_t regions_to_uncommit = \n+          MIN2(by_total, MIN2(by_inactive, max_inactive_regions));\n+\n+      size_t shrink_bytes = regions_to_uncommit * region_size;\n+      shrink_bytes = MIN2(shrink_bytes, current_heap - MinHeapSize);\n+\n+      if (current_heap - shrink_bytes < InitialHeapSize) {\n+        log_info(gc, sizing)(\"Time-based uncommit skipped: would reduce heap below initial size (%zuMB < %zuMB)\",\n+                            (current_heap - shrink_bytes) \/ M, InitialHeapSize \/ M);\n+        log_debug(gc, sizing)(\"Skipping uncommit - would reduce heap below initial size: \"\n+                             \"current=%zuB shrink=%zuB result=%zuB initial=%zuB min=%zuB\",\n+                             current_heap, shrink_bytes, current_heap - shrink_bytes, \n+                             InitialHeapSize, MinHeapSize);\n+        return 0;\n+      }\n+\n+      if (shrink_bytes > 0) {\n+        log_info(gc, sizing)(\"Time-based uncommit: found %u inactive regions, uncommitting %zu regions (%zuMB)\",\n+                            inactive_count, regions_to_uncommit, shrink_bytes \/ M);\n+        log_debug(gc, sizing)(\"Time-based heap uncommit evaluation: Found %u inactive regions out of %u total regions, \"\n+                             \"target shrink: %zuB (max allowed: %zuB)\",\n+                             inactive_count, total_regions, shrink_bytes, max_shrink_bytes);\n+        log_debug(gc, sizing)(\"Region state transition: %zu regions selected for uncommit\",\n+                     regions_to_uncommit);\n+      }\n+\n+      return shrink_bytes;\n+    }\n+  }\n+\n+  log_trace(gc, sizing)(\"Time-based heap evaluation: no uncommit needed \"\n+                       \"(inactive=%u min_required=%zu heap=%zuB min=%zuB)\",\n+                       inactive_count, G1MinRegionsToUncommit,\n+                       _g1h->capacity(), MAX2((size_t)InitialHeapSize, MinHeapSize));\n+\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":163,"deletions":1,"binary":false,"changes":164,"status":"modified"}]}