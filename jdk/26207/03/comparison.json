{"files":[{"patch":"@@ -1,11 +1,15 @@\n-*\t-text\n-*\tencoding=utf-8\n-*.java\tdiff=java\n-*.c\tdiff=cpp\n-*.h\tdiff=cpp\n-*.cpp\tdiff=cpp\n-*.hpp\tdiff=cpp\n-*.md\tdiff=markdown\n-*.sh\tdiff=bash\n-*.html\tdiff=html\n-*.css\tdiff=css\n+# default: auto-detect text\n+*           text=auto\n+\n+# force C\/C++ sources to LF-only and text diffs\n+*.cpp       text eol=lf diff=cpp\n+*.hpp       text eol=lf diff=cpp\n+*.c         text eol=lf diff=cpp\n+*.h         text eol=lf diff=cpp\n+\n+# other languages\n+*.java      text diff=java\n+*.md        text diff=markdown\n+*.sh        text diff=bash\n+*.html      text diff=html\n+*.css       text diff=css\n","filename":".gitattributes","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -205,1 +206,2 @@\n-  assert(Heap_lock->owner() != nullptr, \"Should be owned on this thread's behalf.\");\n+  assert(Heap_lock->owner() != nullptr || SafepointSynchronize::is_at_safepoint(),\n+         \"Should be owned on this thread's behalf or at safepoint.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class G1HeapSizingPolicy;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  if (result != nullptr) {\n-    return result;\n+  if (result == nullptr) {\n+    result = mutator_alloc_region(node_index)->attempt_allocation(min_word_size, desired_word_size, actual_word_size);\n@@ -61,1 +61,1 @@\n-  return mutator_alloc_region(node_index)->attempt_allocation(min_word_size, desired_word_size, actual_word_size);\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+﻿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1HeapEvaluationTask.hpp\"\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+G1HeapEvaluationTask::G1HeapEvaluationTask(G1CollectedHeap* g1h, G1HeapSizingPolicy* heap_sizing_policy) :\n+  PeriodicTask(G1TimeBasedEvaluationIntervalMillis),  \/\/ Use PeriodicTask with interval\n+  _g1h(g1h),\n+  _heap_sizing_policy(heap_sizing_policy) {\n+}\n+\n+void G1HeapEvaluationTask::task() {\n+  \/\/ This runs on WatcherThread during idle periods - perfect for time-based evaluation!\n+  log_debug(gc, sizing)(\"Starting heap evaluation\");\n+\n+  if (!G1UseTimeBasedHeapSizing) {\n+    return;\n+  }\n+\n+  \/\/ Ensure we're not running during GC activity\n+  if (_g1h->is_stw_gc_active()) {\n+    log_trace(gc, sizing)(\"GC active, skipping time-based evaluation\");\n+    return;\n+  }\n+\n+  ResourceMark rm; \/\/ Ensure temporary resources are released\n+\n+  bool should_expand = false;\n+  size_t resize_amount = _heap_sizing_policy->evaluate_heap_resize(should_expand);\n+\n+  if (resize_amount > 0) {\n+    \/\/ Time-based evaluation only handles uncommit\/shrinking, never expansion\n+    if (should_expand) {\n+      log_warning(gc, sizing)(\"Time-based evaluation unexpected expansion request ignored (resize_amount=%zuB)\", resize_amount);\n+      \/\/ This should not happen since time-based policy only handles uncommit\n+      assert(false, \"Time-based heap sizing should never request expansion\");\n+    } else {\n+      log_info(gc, sizing)(\"Time-based evaluation: shrinking heap by %zuMB\", resize_amount \/ M);\n+      log_debug(gc, sizing)(\"Time-based evaluation recommends shrinking by %zuB\", resize_amount);\n+      _g1h->request_heap_shrink(resize_amount);\n+    }\n+  } else {\n+    \/\/ Periodic info log for ongoing evaluation activity (less frequent)\n+    static int evaluation_count = 0;\n+    if (++evaluation_count % 10 == 0) { \/\/ Log every 10th evaluation when no action taken\n+      log_info(gc, sizing)(\"Time-based evaluation: no heap uncommit needed (evaluation #%d)\", evaluation_count);\n+    }\n+  }\n+\n+  \/\/ No need to schedule - PeriodicTask automatically reschedules itself!\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+﻿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n+#define SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n+\n+#include \"runtime\/task.hpp\"  \/\/ Changed from g1ServiceThread.hpp\n+#include \"gc\/g1\/g1_globals.hpp\"\n+\n+class G1CollectedHeap;\n+class G1HeapSizingPolicy;\n+\n+\/\/ Time-based heap evaluation task that runs during idle periods\n+class G1HeapEvaluationTask : public PeriodicTask {  \/\/ Changed from G1ServiceTask\n+  G1CollectedHeap* _g1h;\n+  G1HeapSizingPolicy* _heap_sizing_policy;\n+\n+public:\n+  G1HeapEvaluationTask(G1CollectedHeap* g1h, G1HeapSizingPolicy* heap_sizing_policy);\n+  virtual void task() override;  \/\/ Changed from execute() to task()\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1HEAPEVALUATIONTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapEvaluationTask.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -122,0 +122,1 @@\n+  record_activity(); \/\/ Record region initialization\n@@ -252,0 +253,1 @@\n+  _last_access_timestamp(os::javaTimeMillis()), \/\/ Initialize timestamp with milliseconds to match uncommit check\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+﻿\/*\n@@ -37,0 +37,2 @@\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -73,0 +75,1 @@\n+  friend class G1Allocator;  \/\/ For access to record_activity()\n@@ -74,0 +77,1 @@\n+private:\n@@ -252,0 +256,3 @@\n+  \/\/ Time-based heap sizing: tracks last allocation\/access time\n+  jlong _last_access_timestamp;\n+\n@@ -553,0 +560,19 @@\n+  \/\/ Time-based heap sizing methods\n+  void record_activity() {\n+    _last_access_timestamp = os::javaTimeMillis();  \/\/ Use milliseconds to match uncommit check\n+  }\n+\n+  jlong last_access_time() const {\n+    return _last_access_timestamp;\n+  }\n+\n+  \/\/ Returns true if the region has been inactive for longer than the uncommit delay\n+  bool should_uncommit(uint64_t delay) const {\n+    if (!is_empty()) {\n+      return false;\n+    }\n+    jlong current_time = os::javaTimeMillis();\n+    jlong elapsed = current_time - _last_access_timestamp;\n+    return elapsed > (jlong)delay;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+﻿\/*\n@@ -29,0 +29,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/g1HeapRegion.hpp\"\n@@ -30,0 +32,3 @@\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -69,0 +74,6 @@\n+  \/\/ MinOverThresholdForGrowth must be less than the number of recorded\n+  \/\/ pause times in G1Analytics, representing the minimum number of pause\n+  \/\/ time ratios that exceed GCTimeRatio before a heap expansion will be triggered.\n+  const static uint MinOverThresholdForGrowth = 4;\n+  static jlong _uncommit_delay_ms;  \/\/ Delay before uncommitting inactive regions\n+\n@@ -96,1 +107,0 @@\n-public:\n@@ -101,0 +111,6 @@\n+\n+  \/\/ Methods for time-based sizing\n+  void get_uncommit_candidates(GrowableArray<G1HeapRegion*>* candidates);\n+  bool should_uncommit_region(G1HeapRegion* hr) const;\n+\n+public:\n@@ -106,0 +122,4 @@\n+  \/\/ If an expansion would be appropriate, because recent GC overhead had\n+  \/\/ exceeded the desired limit, return an amount to expand by.\n+  size_t young_collection_expansion_amount();\n+\n@@ -110,0 +130,8 @@\n+  \/\/ Clear ratio tracking data used by expansion_amount().\n+  void clear_ratio_check_data();\n+\n+  \/\/ Time-based sizing methods\n+  static void initialize();\n+  static jlong uncommit_delay() { return _uncommit_delay_ms; }\n+  size_t evaluate_heap_resize(bool& expand);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -51,0 +51,7 @@\n+\n+  \/\/ Print a message about time-based heap sizing configuration.\n+  if (G1UseTimeBasedHeapSizing) {\n+    log_info_p(gc, init)(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+    log_info_p(gc, init)(\"  evaluation_interval=%zums, uncommit_delay=%zums, min_regions_to_uncommit=%zu\",\n+                         G1TimeBasedEvaluationIntervalMillis, G1UncommitDelayMillis, G1MinRegionsToUncommit);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1InitLogger.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -373,0 +373,19 @@\n+  product(bool, G1UseTimeBasedHeapSizing, false, EXPERIMENTAL,              \\\n+          \"Enable time-based heap sizing to uncommit memory from inactive \" \\\n+          \"regions independent of GC cycles\")                               \\\n+                                                                            \\\n+  product(uintx, G1TimeBasedEvaluationIntervalMillis, 60000, MANAGEABLE,    \\\n+          \"Interval in milliseconds between periodic heap-size evaluations \"\\\n+          \"when G1UseTimeBasedHeapSizing is enabled\")                       \\\n+          range(1000, LP64_ONLY(max_jlong) NOT_LP64(max_uintx \/ 2))         \\\n+                                                                            \\\n+  product(uintx, G1UncommitDelayMillis, 300000, MANAGEABLE,                 \\\n+          \"A region is considered inactive if it has not been accessed \"    \\\n+          \"within this many milliseconds\")                                  \\\n+          range(1000, LP64_ONLY(max_jlong) NOT_LP64(max_uintx \/ 2))         \\\n+                                                                            \\\n+  product(size_t, G1MinRegionsToUncommit, 10, EXPERIMENTAL,                 \\\n+          \"Minimum number of inactive regions required before G1 will \"     \\\n+          \"attempt to uncommit memory\")                                     \\\n+          range(1, max_uintx)                                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  LOG_TAG(sizing) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  template(G1ShrinkHeap)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#if INCLUDE_G1GC\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#endif \/\/ INCLUDE_G1GC\n@@ -641,0 +644,6 @@\n+#if INCLUDE_G1GC\n+void VM_G1ShrinkHeap::doit() {\n+  _g1h->shrink(_bytes);\n+}\n+#endif \/\/ INCLUDE_G1GC\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class G1CollectedHeap;\n+\n@@ -294,0 +296,15 @@\n+#if INCLUDE_G1GC\n+class VM_G1ShrinkHeap : public VM_Operation {\n+ private:\n+  G1CollectedHeap* _g1h;\n+  size_t _bytes;\n+ public:\n+  VM_G1ShrinkHeap(G1CollectedHeap* g1h, size_t bytes)\n+    : _g1h(g1h), _bytes(bytes) {}\n+  VMOp_Type type() const override { return VMOp_G1ShrinkHeap; }\n+  const char* name() const override { return \"G1ShrinkHeap\"; }\n+  bool is_gc_operation() const override { return true; }\n+  void doit() override;\n+};\n+#endif \/\/ INCLUDE_G1GC\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+﻿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestG1RegionUncommit\n+ * @requires vm.gc.G1\n+ * @summary Test that G1 uncommits regions based on time threshold\n+ * @bug 8357445\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -Xms8m -Xmx256m -XX:G1HeapRegionSize=1M\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+G1UseTimeBasedHeapSizing\n+ *                   -XX:G1UncommitDelayMillis=3000 -XX:G1TimeBasedEvaluationIntervalMillis=2000\n+ *                   -XX:G1MinRegionsToUncommit=2\n+ *                   -Xlog:gc*,gc+sizing*=debug\n+ *                   gc.g1.TestG1RegionUncommit\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RegionUncommit {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ If no args, run the subprocess with log analysis\n+        if (args.length == 0) {\n+            testTimeBasedEvaluation();\n+            testMinimumHeapBoundary();\n+            testConcurrentAllocationUncommit();\n+        } else if (\"subprocess\".equals(args[0])) {\n+            \/\/ This is the subprocess that does the actual allocation\/deallocation\n+            runTimeBasedUncommitTest();\n+        } else if (\"minheap\".equals(args[0])) {\n+            runMinHeapBoundaryTest();\n+        } else if (\"concurrent\".equals(args[0])) {\n+            runConcurrentTest();\n+        }\n+    }\n+\n+    static void testTimeBasedEvaluation() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms8m\", \"-Xmx256m\", \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-XX:G1UncommitDelayMillis=3000\", \"-XX:G1TimeBasedEvaluationIntervalMillis=2000\",\n+            \"-XX:G1MinRegionsToUncommit=2\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"subprocess\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify the time-based evaluation logic is working\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldContain(\"Region state transition:\");\n+        output.shouldContain(\"transitioning from active to inactive\");\n+        output.shouldContain(\"Uncommit candidates found:\");\n+        output.shouldContain(\"Time-based heap uncommit evaluation:\");\n+        output.shouldContain(\"target shrink:\");\n+\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Test passed - time-based uncommit verified!\");\n+    }\n+\n+    static void runTimeBasedUncommitTest() throws Exception {\n+        final int allocSize = 64 * 1024 * 1024; \/\/ 64MB allocation - much larger than initial 8MB\n+        Object keepAlive;\n+        Object keepAlive2; \/\/ Keep some memory allocated to prevent full shrinkage\n+\n+        System.out.println(\"=== Testing G1 Time-Based Uncommit ===\");\n+\n+        \/\/ Phase 1: Allocate memory to force significant heap expansion\n+        System.out.println(\"Phase 1: Allocating large amount of memory\");\n+        keepAlive = new byte[allocSize];\n+\n+        \/\/ Phase 2: Keep some memory allocated, free the rest to create inactive regions\n+        \/\/ This ensures current_heap > min_heap so uncommit is possible\n+        System.out.println(\"Phase 2: Partially freeing memory, keeping some allocated\");\n+        keepAlive2 = new byte[24 * 1024 * 1024]; \/\/ Keep 24MB allocated\n+        keepAlive = null; \/\/ Free the 64MB, leaving regions available for uncommit\n+        System.gc();\n+        System.gc(); \/\/ Double GC to ensure the 64MB is cleaned up\n+\n+        \/\/ Phase 3: Wait for regions to become inactive and uncommit to occur\n+        System.out.println(\"Phase 3: Waiting for time-based uncommit...\");\n+\n+        \/\/ Wait long enough for:\n+        \/\/ 1. G1UncommitDelayMillis (3000ms) - regions to become inactive\n+        \/\/ 2. G1TimeBasedEvaluationIntervalMillis (2000ms) - evaluation to run\n+        \/\/ 3. Multiple evaluation cycles to ensure uncommit happens\n+        Thread.sleep(15000); \/\/ 15 seconds should be plenty\n+\n+        \/\/ Clean up remaining allocation\n+        keepAlive2 = null;\n+        System.gc();\n+\n+        System.out.println(\"=== Test completed ===\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+\n+    static void testMinimumHeapBoundary() throws Exception {\n+        System.out.println(\"Testing minimum heap boundary conditions...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms32m\", \"-Xmx64m\",  \/\/ Small heap to test boundaries\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-XX:G1UncommitDelayMillis=2000\", \/\/ Short delay\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc+sizing=debug,gc+task=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"minheap\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should not uncommit below initial heap size\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Minimum heap boundary test passed!\");\n+    }\n+\n+    static void testConcurrentAllocationUncommit() throws Exception {\n+        System.out.println(\"Testing concurrent allocation and uncommit...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ Frequent evaluation\n+            \"-XX:G1UncommitDelayMillis=2000\",\n+            \"-XX:G1MinRegionsToUncommit=2\",\n+            \"-Xlog:gc+sizing=debug,gc+task=debug\",\n+            \"gc.g1.TestG1RegionUncommit\", \"concurrent\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should handle concurrent operations safely\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Concurrent allocation\/uncommit test passed!\");\n+    }\n+\n+    static void runMinHeapBoundaryTest() throws Exception {\n+        System.out.println(\"=== Min Heap Boundary Test ===\");\n+\n+        List<byte[]> memory = new ArrayList<>();\n+\n+        \/\/ Allocate close to max\n+        for (int i = 0; i < 28; i++) { \/\/ 28MB, close to 32MB limit\n+            memory.add(new byte[1024 * 1024]);\n+        }\n+\n+        \/\/ Clear and wait for uncommit attempt\n+        memory.clear();\n+        System.gc();\n+        Thread.sleep(8000); \/\/ Wait longer than uncommit delay\n+\n+        System.out.println(\"MinHeapBoundaryTest completed\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+\n+    static void runConcurrentTest() throws Exception {\n+        System.out.println(\"=== Concurrent Test ===\");\n+\n+        final List<byte[]> sharedMemory = new ArrayList<>();\n+        final boolean[] stopFlag = {false};\n+\n+        \/\/ Start allocation thread\n+        Thread allocThread = new Thread(() -> {\n+            int iterations = 0;\n+            while (!stopFlag[0] && iterations < 50) {\n+                try {\n+                    \/\/ Allocate\n+                    for (int j = 0; j < 5; j++) {\n+                        synchronized (sharedMemory) {\n+                            sharedMemory.add(new byte[1024 * 1024]); \/\/ 1MB\n+                        }\n+                        Thread.sleep(10);\n+                    }\n+\n+                    \/\/ Clear some\n+                    synchronized (sharedMemory) {\n+                        if (sharedMemory.size() > 10) {\n+                            for (int k = 0; k < 5; k++) {\n+                                if (!sharedMemory.isEmpty()) {\n+                                    sharedMemory.remove(0);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    System.gc();\n+                    Thread.sleep(50);\n+                    iterations++;\n+                } catch (InterruptedException e) {\n+                    break;\n+                }\n+            }\n+        });\n+\n+        allocThread.start();\n+\n+        \/\/ Let it run for a while to trigger time-based evaluation\n+        Thread.sleep(8000);\n+\n+        stopFlag[0] = true;\n+        allocThread.join(2000);\n+\n+        synchronized (sharedMemory) {\n+            sharedMemory.clear();\n+        }\n+        System.gc();\n+\n+        System.out.println(\"ConcurrentTest completed\");\n+        Runtime.getRuntime().halt(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestG1RegionUncommit.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+﻿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedHeapConfig\n+ * @bug 8357445\n+ * @summary Test configuration settings and error conditions for time-based heap sizing\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+G1UseTimeBasedHeapSizing\n+ *     -Xms16m -Xmx64m -XX:G1HeapRegionSize=1M\n+ *     -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *     -XX:G1UncommitDelayMillis=10000\n+ *     -XX:G1MinRegionsToUncommit=2\n+ *     -Xlog:gc*,gc+sizing*=debug\n+ *     gc.g1.TestTimeBasedHeapConfig\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTimeBasedHeapConfig {\n+\n+    public static void main(String[] args) throws Exception {\n+        testConfigurationParameters();\n+        testBoundaryValues();\n+        testEdgeCaseConfigurations();\n+    }\n+\n+    static void testConfigurationParameters() throws Exception {\n+        \/\/ Test default settings\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-Xms16m\", \"-Xmx64m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BasicTest\"\n+        });\n+    }\n+\n+    private static void verifyVMConfig(String[] opts) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(opts);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class BasicTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            \/\/ Initial allocation\n+            allocateMemory(8); \/\/ 8MB\n+            System.gc();\n+            Thread.sleep(1000);\n+\n+            \/\/ Clean up\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(2000);\n+\n+            System.out.println(\"Basic configuration test completed successfully\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 2 == 0) Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    static void testBoundaryValues() throws Exception {\n+        \/\/ Test minimum values\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-Xms8m\", \"-Xmx32m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ 1 second minimum\n+            \"-XX:G1UncommitDelayMillis=1000\", \/\/ 1 second minimum\n+            \"-XX:G1MinRegionsToUncommit=1\", \/\/ 1 region minimum\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BoundaryTest\"\n+        });\n+\n+        \/\/ Test maximum reasonable values\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-Xms32m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=300000\", \/\/ 5 minutes\n+            \"-XX:G1UncommitDelayMillis=300000\", \/\/ 5 minutes\n+            \"-XX:G1MinRegionsToUncommit=50\", \/\/ 50 regions\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$BoundaryTest\"\n+        });\n+    }\n+\n+    static void testEdgeCaseConfigurations() throws Exception {\n+        \/\/ Test with very small heap (should still work)\n+        verifyVMConfig(new String[] {\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-Xms4m\", \"-Xmx8m\", \/\/ Very small heap\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=2000\",\n+            \"-XX:G1UncommitDelayMillis=3000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapConfig$SmallHeapTest\"\n+        });\n+    }\n+\n+    public static class BoundaryTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"BoundaryTest: Starting\");\n+\n+            \/\/ Test with boundary conditions\n+            allocateMemory(4); \/\/ 4MB\n+            Thread.sleep(2000);\n+\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(5000); \/\/ Wait for evaluation\n+\n+            System.out.println(\"BoundaryTest: Completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    public static class SmallHeapTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"SmallHeapTest: Starting with very small heap\");\n+\n+            \/\/ With 4-8MB heap, just allocate a small amount\n+            byte[] smallAlloc = new byte[1024 * 1024]; \/\/ 1MB\n+            Thread.sleep(2000);\n+\n+            smallAlloc = null;\n+            System.gc();\n+            Thread.sleep(5000);\n+\n+            System.out.println(\"SmallHeapTest: Completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedHeapConfig.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+﻿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedHeapSizing\n+ * @bug 8357445\n+ * @summary Test time-based heap sizing functionality in G1\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+G1UseTimeBasedHeapSizing\n+ *     -Xms32m -Xmx128m -XX:G1HeapRegionSize=1M\n+ *     -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *     -XX:G1UncommitDelayMillis=10000\n+ *     -XX:G1MinRegionsToUncommit=2\n+ *     -Xlog:gc*,gc+sizing*=debug\n+ *     gc.g1.TestTimeBasedHeapSizing\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTimeBasedHeapSizing {\n+\n+    private static final String TEST_VM_OPTS = \"-XX:+UseG1GC \" +\n+        \"-XX:+UnlockExperimentalVMOptions \" +\n+        \"-XX:+G1UseTimeBasedHeapSizing \" +\n+        \"-XX:G1TimeBasedEvaluationIntervalMillis=5000 \" +\n+        \"-XX:G1UncommitDelayMillis=10000 \" +\n+        \"-XX:G1MinRegionsToUncommit=2 \" +\n+        \"-XX:G1HeapRegionSize=1M \" +\n+        \"-Xmx128m -Xms32m \" +\n+        \"-Xlog:gc*,gc+sizing*=debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testBasicFunctionality();\n+        testHumongousObjectHandling();\n+        testRapidAllocationCycles();\n+        testLargeHumongousObjects();\n+    }\n+\n+    static void testBasicFunctionality() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$BasicFunctionalityTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldContain(\"Full region scan:\");\n+\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class BasicFunctionalityTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"BasicFunctionalityTest: Starting heap activity\");\n+\n+            \/\/ Create significant heap activity\n+            for (int cycle = 0; cycle < 3; cycle++) {\n+                System.out.println(\"Allocation cycle \" + cycle);\n+                allocateMemory(25);  \/\/ 25MB per cycle\n+                Thread.sleep(200);   \/\/ Brief pause\n+                clearMemory();\n+                System.gc();\n+                Thread.sleep(200);\n+            }\n+\n+            System.out.println(\"BasicFunctionalityTest: Starting idle period\");\n+\n+            \/\/ Sleep to allow time-based evaluation\n+            Thread.sleep(18000);  \/\/ 18 seconds\n+\n+            System.out.println(\"BasicFunctionalityTest: Completed idle period\");\n+\n+            \/\/ Final cleanup\n+            clearMemory();\n+            Thread.sleep(500);\n+\n+            System.out.println(\"BasicFunctionalityTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 4 == 0) Thread.sleep(10);\n+            }\n+        }\n+\n+        static void clearMemory() {\n+            arrays.clear();\n+            System.gc();\n+        }\n+    }\n+\n+    static void testHumongousObjectHandling() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$HumongousObjectTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testRapidAllocationCycles() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedHeapSizing$RapidCycleTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"Starting heap evaluation\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testLargeHumongousObjects() throws Exception {\n+        System.out.println(\"Testing large humongous object activity tracking...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1UncommitDelayMillis=5000\",\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedHeapSizing$LargeHumongousTest\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Large humongous objects should not affect uncommit safety\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Large humongous object test passed!\");\n+    }\n+\n+    public static class HumongousObjectTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> humongousObjects = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"HumongousObjectTest: Starting\");\n+\n+            \/\/ Allocate humongous objects (> 512KB for 1MB regions)\n+            for (int i = 0; i < 8; i++) {\n+                humongousObjects.add(new byte[800 * 1024]); \/\/ 800KB humongous\n+                System.out.println(\"Allocated humongous object \" + (i + 1));\n+                Thread.sleep(200);\n+            }\n+\n+            \/\/ Keep them alive for a while\n+            Thread.sleep(3000);\n+\n+            \/\/ Clear and test uncommit behavior\n+            humongousObjects.clear();\n+            System.gc();\n+            Thread.sleep(12000); \/\/ Wait for uncommit delay\n+\n+            System.out.println(\"HumongousObjectTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class RapidCycleTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> memory = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RapidCycleTest: Starting\");\n+\n+            \/\/ Rapid allocation\/deallocation cycles\n+            for (int cycle = 0; cycle < 15; cycle++) {\n+                \/\/ Quick allocation\n+                for (int i = 0; i < 8; i++) {\n+                    memory.add(new byte[MB]); \/\/ 1MB\n+                }\n+\n+                \/\/ Quick deallocation\n+                memory.clear();\n+                System.gc();\n+\n+                \/\/ Brief pause\n+                Thread.sleep(100);\n+\n+                if (cycle % 5 == 0) {\n+                    System.out.println(\"Completed cycle \" + cycle);\n+                }\n+            }\n+\n+            \/\/ Final wait for time-based evaluation\n+            Thread.sleep(12000);\n+\n+            System.out.println(\"RapidCycleTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class LargeHumongousTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"=== Large Humongous Object Test ===\");\n+\n+            \/\/ Allocate several large humongous objects (multiple regions each)\n+            List<byte[]> humongousObjects = new ArrayList<>();\n+\n+            \/\/ Each region is 1MB, so allocate 2MB objects (humongous spanning multiple regions)\n+            for (int i = 0; i < 5; i++) {\n+                humongousObjects.add(new byte[2 * 1024 * 1024]);\n+                System.gc(); \/\/ Force potential region transitions\n+                Thread.sleep(100);\n+            }\n+\n+            \/\/ Hold some, release others to create mixed region states\n+            humongousObjects.remove(0);\n+            humongousObjects.remove(0);\n+            System.gc();\n+\n+            \/\/ Wait for time-based evaluation with humongous regions present\n+            Thread.sleep(8000);\n+\n+            \/\/ Clean up\n+            humongousObjects.clear();\n+            System.gc();\n+\n+            System.out.println(\"LargeHumongousTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedHeapSizing.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+﻿\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/**\n+ * @test TestTimeBasedRegionTracking\n+ * @bug 8357445\n+ * @summary Test region activity tracking and state transitions for time-based heap sizing\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\/sun.management\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+G1UseTimeBasedHeapSizing\n+ *      -Xms32m -Xmx128m -XX:G1HeapRegionSize=1M\n+ *      -XX:G1TimeBasedEvaluationIntervalMillis=5000\n+ *      -XX:G1UncommitDelayMillis=10000\n+ *      -XX:G1MinRegionsToUncommit=2\n+ *      -Xlog:gc*,gc+sizing*=debug gc.g1.TestTimeBasedRegionTracking\n+ *\/\n+\n+import java.util.*;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class TestTimeBasedRegionTracking {\n+\n+    private static final String TEST_VM_OPTS = \"-XX:+UseG1GC \" +\n+        \"-XX:+UnlockExperimentalVMOptions \" +\n+        \"-XX:+G1UseTimeBasedHeapSizing \" +\n+        \"-XX:G1TimeBasedEvaluationIntervalMillis=5000 \" +\n+        \"-XX:G1UncommitDelayMillis=10000 \" +\n+        \"-XX:G1MinRegionsToUncommit=2 \" +\n+        \"-XX:G1HeapRegionSize=1M \" +\n+        \"-Xmx128m -Xms32m \" +\n+        \"-Xlog:gc*,gc+sizing*=debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        testRegionStateTransitions();\n+        testConcurrentRegionAccess();\n+        testRegionLifecycleEdgeCases();\n+        testSafepointRaceConditions();\n+    }\n+\n+    static void testRegionStateTransitions() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$RegionTransitionTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify region state changes\n+        output.shouldContain(\"Region state transition:\");\n+        output.shouldContain(\"Uncommit candidates found:\");\n+\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static class RegionTransitionTest {\n+        private static final int MB = 1024 * 1024;\n+        private static ArrayList<byte[]> arrays = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            \/\/ Phase 1: Active allocation\n+            allocateMemory(32); \/\/ 32MB\n+            System.gc();\n+\n+            \/\/ Phase 2: Idle period\n+            arrays.clear();\n+            System.gc();\n+            Thread.sleep(15000); \/\/ Wait for uncommit\n+\n+            \/\/ Phase 3: Reallocation\n+            allocateMemory(16); \/\/ 16MB\n+            System.gc();\n+\n+            \/\/ Clean up and wait for final uncommit evaluation\n+            arrays = null;\n+            System.gc();\n+            Thread.sleep(2000);\n+            Runtime.getRuntime().halt(0);\n+        }\n+\n+        static void allocateMemory(int mb) throws InterruptedException {\n+            for (int i = 0; i < mb; i++) {\n+                arrays.add(new byte[MB]);\n+                if (i % 4 == 0) Thread.sleep(10);\n+            }\n+        }\n+    }\n+\n+    static void testConcurrentRegionAccess() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$ConcurrentAccessTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify concurrent access is handled safely\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testRegionLifecycleEdgeCases() throws Exception {\n+        String[] command = new String[TEST_VM_OPTS.split(\" \").length + 1];\n+        System.arraycopy(TEST_VM_OPTS.split(\" \"), 0, command, 0, TEST_VM_OPTS.split(\" \").length);\n+        command[command.length - 1] = \"gc.g1.TestTimeBasedRegionTracking$RegionLifecycleEdgeCaseTest\";\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Verify region lifecycle edge cases are handled\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static void testSafepointRaceConditions() throws Exception {\n+        System.out.println(\"Testing safepoint and allocation race conditions...\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+            \"-XX:+UseG1GC\",\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:+G1UseTimeBasedHeapSizing\",\n+            \"-Xms64m\", \"-Xmx256m\",\n+            \"-XX:G1HeapRegionSize=1M\",\n+            \"-XX:G1TimeBasedEvaluationIntervalMillis=1000\", \/\/ Frequent evaluation (minimum allowed)\n+            \"-XX:G1UncommitDelayMillis=1000\", \/\/ Short delay\n+            \"-XX:G1MinRegionsToUncommit=1\",\n+            \"-Xlog:gc*,gc+sizing*=debug\",\n+            \"gc.g1.TestTimeBasedRegionTracking$SafepointRaceTest\"\n+        );\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Should handle safepoint races without errors\n+        output.shouldContain(\"G1 Time-Based Heap Sizing enabled (uncommit-only)\");\n+        output.shouldHaveExitValue(0);\n+        System.out.println(\"Safepoint race conditions test passed!\");\n+    }\n+\n+    public static class ConcurrentAccessTest {\n+        private static final int MB = 1024 * 1024;\n+        private static final List<byte[]> sharedMemory = new ArrayList<>();\n+        private static volatile boolean stopThreads = false;\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"ConcurrentAccessTest: Starting\");\n+\n+            \/\/ Start multiple allocation threads\n+            Thread[] threads = new Thread[3];\n+            for (int t = 0; t < threads.length; t++) {\n+                final int threadId = t;\n+                threads[t] = new Thread(() -> {\n+                    int iterations = 0;\n+                    while (!stopThreads && iterations < 30) {\n+                        try {\n+                            \/\/ Allocate\n+                            for (int i = 0; i < 3; i++) {\n+                                synchronized (sharedMemory) {\n+                                    sharedMemory.add(new byte[512 * 1024]); \/\/ 512KB\n+                                }\n+                                Thread.sleep(10);\n+                            }\n+\n+                            \/\/ Clear some memory\n+                            synchronized (sharedMemory) {\n+                                if (sharedMemory.size() > 15) {\n+                                    for (int i = 0; i < 5; i++) {\n+                                        if (!sharedMemory.isEmpty()) {\n+                                            sharedMemory.remove(0);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            if (iterations % 10 == 0) {\n+                                System.gc();\n+                            }\n+\n+                            iterations++;\n+                            Thread.sleep(50);\n+                        } catch (InterruptedException e) {\n+                            break;\n+                        }\n+                    }\n+                    System.out.println(\"Thread \" + threadId + \" completed \" + iterations + \" iterations\");\n+                });\n+                threads[t].start();\n+            }\n+\n+            \/\/ Let threads run for a while\n+            Thread.sleep(8000);\n+\n+            stopThreads = true;\n+            for (Thread t : threads) {\n+                t.join(2000);\n+            }\n+\n+            synchronized (sharedMemory) {\n+                sharedMemory.clear();\n+            }\n+            System.gc();\n+            Thread.sleep(3000);\n+\n+            System.out.println(\"ConcurrentAccessTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class RegionLifecycleEdgeCaseTest {\n+        private static final int MB = 1024 * 1024;\n+        private static List<Object> memory = new ArrayList<>();\n+\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"RegionLifecycleEdgeCaseTest: Starting\");\n+\n+            \/\/ Phase 1: Mixed allocation patterns\n+            \/\/ Small objects\n+            for (int i = 0; i < 100; i++) {\n+                memory.add(new byte[8 * 1024]); \/\/ 8KB objects\n+            }\n+\n+            \/\/ Medium objects\n+            for (int i = 0; i < 20; i++) {\n+                memory.add(new byte[40 * 1024]); \/\/ 40KB objects\n+            }\n+\n+            \/\/ Large objects (but not humongous)\n+            for (int i = 0; i < 5; i++) {\n+                memory.add(new byte[300 * 1024]); \/\/ 300KB objects\n+            }\n+\n+            Thread.sleep(2000);\n+\n+            \/\/ Phase 2: Create fragmentation by selective deallocation\n+            for (int i = memory.size() - 1; i >= 0; i -= 2) {\n+                memory.remove(i);\n+            }\n+\n+            System.gc();\n+            Thread.sleep(3000);\n+\n+            \/\/ Phase 3: Add humongous objects\n+            for (int i = 0; i < 3; i++) {\n+                memory.add(new byte[900 * 1024]); \/\/ 900KB humongous\n+                Thread.sleep(500);\n+            }\n+\n+            Thread.sleep(2000);\n+\n+            \/\/ Phase 4: Final cleanup\n+            memory.clear();\n+            System.gc();\n+            Thread.sleep(12000); \/\/ Wait for multiple evaluation cycles\n+\n+            System.out.println(\"RegionLifecycleEdgeCaseTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+\n+    public static class SafepointRaceTest {\n+        public static void main(String[] args) throws Exception {\n+            System.out.println(\"=== Safepoint Race Conditions Test ===\");\n+\n+            final AtomicBoolean stopFlag = new AtomicBoolean(false);\n+            final List<byte[]> sharedMemory = Collections.synchronizedList(new ArrayList<>());\n+\n+            \/\/ Start multiple threads to create allocation pressure\n+            Thread[] threads = new Thread[3];\n+            for (int i = 0; i < threads.length; i++) {\n+                final int threadId = i;\n+                threads[i] = new Thread(() -> {\n+                    int iteration = 0;\n+                    while (!stopFlag.get() && iteration < 20) {\n+                        try {\n+                            \/\/ Allocate and deallocate rapidly\n+                            for (int j = 0; j < 5; j++) {\n+                                sharedMemory.add(new byte[512 * 1024]); \/\/ 512KB\n+                            }\n+\n+                            \/\/ Force GC to trigger safepoints\n+                            if (iteration % 3 == 0) {\n+                                System.gc();\n+                            }\n+\n+                            \/\/ Clear some allocations\n+                            synchronized (sharedMemory) {\n+                                if (sharedMemory.size() > 10) {\n+                                    for (int k = 0; k < 3; k++) {\n+                                        if (!sharedMemory.isEmpty()) {\n+                                            sharedMemory.remove(0);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            Thread.sleep(100); \/\/ Brief pause\n+                            iteration++;\n+                        } catch (InterruptedException e) {\n+                            break;\n+                        }\n+                    }\n+                });\n+                threads[i].start();\n+            }\n+\n+            \/\/ Let threads run during time-based evaluation\n+            Thread.sleep(8000);\n+\n+            \/\/ Stop threads\n+            stopFlag.set(true);\n+            for (Thread thread : threads) {\n+                thread.join(2000);\n+            }\n+\n+            \/\/ Clean up\n+            sharedMemory.clear();\n+            System.gc();\n+\n+            System.out.println(\"SafepointRaceTest: Test completed\");\n+            Runtime.getRuntime().halt(0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestTimeBasedRegionTracking.java","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"}]}