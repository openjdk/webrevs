{"files":[{"patch":"@@ -1,296 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except011.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except011\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except011 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    private static final String className = \"nsk.stress.except.except011oops\";\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        Class oops;\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-\n-        int index = 0;\n-        pool[index++] = new Object();\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check ExceptionInInitializerError:\n-        try {\n-            oops = Class.forName(className);\n-            log[messages++] = \"Failure: ExceptionInInitializerError failed to throw\";\n-            exitCode = 2;\n-        } catch (ExceptionInInitializerError eiie) {\n-            String message = eiie.getException().getMessage();\n-            if (!message.equals(\"except011oops\")) {\n-                log[messages++] =\n-                        \"Failure: ExceptionInInitializerError: unexpected target exception\";\n-                exitCode = 2;\n-            } else if (TRACE_ON)\n-                log[messages++] = \"Success: ExceptionInInitializerError thrown as expected\";\n-        } catch (ClassNotFoundException cnfe) {\n-            log[messages++] = \"Failure: ExceptionInInitializerError: target class not found\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: ExceptionInInitializerError: thrown OutOfMemoryError\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some OOME, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc(); \/\/ Empty memory to be able to write to the output\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except011.java","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.stress.except;\n-\n-\/**\n- * This class throws exception while static initialization.\n- * The test should load this class via reflection in order\n- * to hold the exception until runtime.\n- *\n- * @see nsk.stress.except.except011\n- *\/\n-public class except011oops {\n-    static boolean truth = true;\n-\n-    static {\n-        if (truth)\n-            throw new RuntimeException(\"except011oops\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except011oops.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"}]}