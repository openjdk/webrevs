{"files":[{"patch":"@@ -432,0 +432,2 @@\n+     * @throws IllegalArgumentException if {@code tk} is {@link TypeKind#VOID void}\n+     *         or {@code slot} is out of range\n@@ -443,0 +445,2 @@\n+     * @throws IllegalArgumentException if {@code tk} is {@link TypeKind#VOID void}\n+     *         or {@code slot} is out of range\n@@ -796,0 +800,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -809,0 +814,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -825,0 +831,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -838,0 +845,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -880,0 +888,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -928,0 +937,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -961,0 +971,1 @@\n+     * @throws IllegalArgumentException if {@code b} is out of range of byte\n@@ -1097,0 +1108,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1142,0 +1154,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1309,0 +1322,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1354,0 +1368,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -1729,0 +1744,1 @@\n+     * @throws IllegalArgumentException if {@code slot} or {@code val} is out of range\n@@ -1742,0 +1758,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2000,0 +2017,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2162,0 +2180,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2231,0 +2250,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -2281,0 +2301,1 @@\n+     * @throws IllegalArgumentException if {@code dims} is out of range\n@@ -2292,0 +2313,1 @@\n+     * or if {@code dims} is out of range\n@@ -2330,0 +2352,2 @@\n+     * @throws IllegalArgumentException when the {@code typeKind} is not a legal\n+     *         primitive array component type\n@@ -2426,0 +2450,1 @@\n+     * @throws IllegalArgumentException if {@code s} is out of range of short\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -115,1 +116,1 @@\n-         *         {@link Opcode.Kind#DISCONTINUED_RET}.\n+         *         {@link Opcode.Kind#DISCONTINUED_RET} or if {@code slot} is out of range\n@@ -118,1 +119,1 @@\n-            Util.checkKind(op, Opcode.Kind.DISCONTINUED_RET);\n+            BytecodeHelpers.validateRet(op, slot);\n@@ -126,0 +127,1 @@\n+         * @throws IllegalArgumentException if {@code slot} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+     * @throws IllegalArgumentException if {@code slot} or {@code constant} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+     * @throws IllegalArgumentException if {@code kind} is\n+     *         {@link TypeKind#VOID void} or {@code slot} is out of range\n@@ -67,1 +69,2 @@\n-        return of(BytecodeHelpers.loadOpcode(kind, slot), slot);\n+        var opcode = BytecodeHelpers.loadOpcode(kind, slot); \/\/ validates slot, trusted\n+        return new AbstractInstruction.UnboundLoadInstruction(opcode, slot);\n@@ -77,1 +80,1 @@\n-     *         {@link Opcode.Kind#LOAD}.\n+     *         {@link Opcode.Kind#LOAD} or {@code slot} is out of range\n@@ -81,0 +84,1 @@\n+        BytecodeHelpers.validateSlot(op, slot, true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -109,0 +110,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n@@ -106,0 +107,1 @@\n+     * @throws IllegalArgumentException if {@code slot} is out of range\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -61,0 +62,1 @@\n+     * @throws IllegalArgumentException if {@code dimensions} is out of range\n@@ -64,0 +66,1 @@\n+        BytecodeHelpers.validateMultiArrayDimensions(dimensions);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewMultiArrayInstruction.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+     * @throws IllegalArgumentException if {@code kind} is {@link\n+     *         TypeKind#VOID void} or {@code slot} is out of range\n@@ -66,1 +68,2 @@\n-        return of(BytecodeHelpers.storeOpcode(kind, slot), slot);\n+        var opcode = BytecodeHelpers.storeOpcode(kind, slot); \/\/ validates slot\n+        return new AbstractInstruction.UnboundStoreInstruction(opcode, slot);\n@@ -76,1 +79,1 @@\n-     *         {@link Opcode.Kind#STORE}.\n+     *         {@link Opcode.Kind#STORE} or {@code slot} is out of range\n@@ -80,0 +83,1 @@\n+        BytecodeHelpers.validateSlot(op, slot, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -851,3 +851,3 @@\n-            super(slot <= 255 && constant < 128 && constant > -127\n-                  ? Opcode.IINC\n-                  : Opcode.IINC_W);\n+            super(BytecodeHelpers.validateAndIsWideIinc(slot, constant)\n+                  ? Opcode.IINC_W\n+                  : Opcode.IINC);\n@@ -870,1 +870,1 @@\n-            writer.writeIncrement(slot, constant);\n+            writer.writeIncrement(op == Opcode.IINC_W, slot, constant);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+            BytecodeHelpers.validateSlot(slot);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Objects;\n@@ -63,0 +64,8 @@\n+    public static IllegalArgumentException slotOutOfBounds(int slot) {\n+        return new IllegalArgumentException(\"Invalid slot index :\".concat(Integer.toString(slot)));\n+    }\n+\n+    public static IllegalArgumentException slotOutOfBounds(Opcode opcode, int slot) {\n+        return new IllegalArgumentException(\"Invalid slot index %d for %s\".formatted(slot, opcode));\n+    }\n+\n@@ -81,1 +90,7 @@\n-            default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ALOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ALOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -91,1 +106,7 @@\n-            default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.FLOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.FLOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -101,1 +122,7 @@\n-            default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.DLOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.DLOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -111,1 +138,7 @@\n-            default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.LLOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.LLOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -121,1 +154,7 @@\n-            default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ILOAD;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ILOAD_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -143,1 +182,7 @@\n-            default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ASTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ASTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -153,1 +198,7 @@\n-            default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.FSTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.FSTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -163,1 +214,7 @@\n-            default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.DSTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.DSTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -173,1 +230,7 @@\n-            default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.LSTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.LSTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -183,1 +246,7 @@\n-            default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n+            default -> {\n+                if ((slot & 0xFF) == slot)\n+                    yield Opcode.ISTORE;\n+                if ((slot & 0xFFFF) == slot)\n+                    yield Opcode.ISTORE_W;\n+                throw slotOutOfBounds(slot);\n+            }\n@@ -308,0 +377,42 @@\n+    public static void validateSlot(Opcode opcode, int slot, boolean load) {\n+        int size = opcode.sizeIfFixed();\n+        if (size == 1 && slot == (load ? intrinsicLoadSlot(opcode) : intrinsicStoreSlot(opcode)) ||\n+                size == 2 && slot == (slot & 0xFF) ||\n+                size == 4 && slot == (slot & 0xFFFF))\n+            return;\n+        throw slotOutOfBounds(opcode, slot);\n+    }\n+\n+    public static void validateSlot(int slot) {\n+        if ((slot & 0xFFFF) != slot)\n+            throw slotOutOfBounds(slot);\n+    }\n+\n+    public static boolean validateAndIsWideIinc(int slot, int val) {\n+        var ret = false;\n+        if ((slot & 0xFF) != slot) {\n+            validateSlot(slot);\n+            ret = true;\n+        }\n+        if ((byte) val != val) {\n+            if ((short) val != val) {\n+                throw new IllegalArgumentException(\"cannot encode as S2: \".concat(String.valueOf(val)));\n+            }\n+            ret = true;\n+        }\n+        return ret;\n+    }\n+\n+    public static void validateRet(Opcode opcode, int slot) {\n+        if (opcode == Opcode.RET && slot == (slot & 0xFF) ||\n+                opcode == Opcode.RET_W && slot == (slot & 0xFFFF))\n+            return;\n+        Objects.requireNonNull(opcode);\n+        throw slotOutOfBounds(opcode, slot);\n+    }\n+\n+    public static void validateMultiArrayDimensions(int value) {\n+        if (value < 1 || value > 0xFF)\n+            throw new IllegalArgumentException(\"Not a valid array dimension: \".concat(String.valueOf(value)));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":121,"deletions":10,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                    case LOAD -> LoadInstruction.of(o, BytecodeHelpers.intrinsicLoadSlot(o));\n+                    case LOAD -> new AbstractInstruction.UnboundLoadInstruction(o, BytecodeHelpers.intrinsicLoadSlot(o));\n@@ -64,1 +64,1 @@\n-                    case STORE -> StoreInstruction.of(o, BytecodeHelpers.intrinsicStoreSlot(o));\n+                    case STORE -> new AbstractInstruction.UnboundStoreInstruction(o, BytecodeHelpers.intrinsicStoreSlot(o));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -509,6 +509,6 @@\n-    public void writeIncrement(int slot, int val) {\n-        Opcode opcode = (slot < 256 && val < 128 && val > -127)\n-                        ? IINC\n-                        : IINC_W;\n-        writeBytecode(opcode);\n-        if (opcode.isWide()) {\n+    public void writeIncrement(boolean wide, int slot, int val) {\n+        if (wide) {\n+            bytecodesBufWriter.writeU1(RawBytecodeHelper.WIDE);\n+        }\n+        bytecodesBufWriter.writeU1(RawBytecodeHelper.IINC);\n+        if (wide) {\n@@ -1219,1 +1219,1 @@\n-        writeIncrement(slot, val);\n+        writeIncrement(validateAndIsWideIinc(slot, val), slot, val);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341277\n+ * @summary Testing ClassFile instruction argument validation.\n+ * @run junit InstructionValidationTest\n+ *\/\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.instruction.*;\n+import java.util.List;\n+import java.util.function.ObjIntConsumer;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static java.lang.classfile.Opcode.*;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class InstructionValidationTest {\n+\n+    @Test\n+    void testArgumentConstant() {\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n+\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int) Short.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int) Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int) Byte.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int) Byte.MAX_VALUE + 1));\n+    }\n+\n+    \/**\n+     * Tests the bad slot argument IAE for load, store, increment, and ret.\n+     *\/\n+    @Test\n+    void testSlots() {\n+        record Result(boolean shouldFail, int slot) {\n+        }\n+\n+        List<Integer> badSlots = List.of(-1, 72694, -42, 0x10000, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        List<Integer> u2OnlySlots = List.of(0x100, 1000, 0xFFFF);\n+        List<Integer> u1Slots = List.of(0, 2, 15, 0xFF);\n+\n+        List<Integer> badU1Slots = Stream.concat(badSlots.stream(), u2OnlySlots.stream()).toList();\n+        List<Integer> u2Slots = Stream.concat(u1Slots.stream(), u2OnlySlots.stream()).toList();\n+        List<Result> u2Cases = Stream.concat(\n+                badSlots.stream().map(i -> new Result(true, i)),\n+                u2Slots.stream().map(i -> new Result(false, i))\n+        ).toList();\n+        List<Result> u1Cases = Stream.concat(\n+                badU1Slots.stream().map(i -> new Result(true, i)),\n+                u1Slots.stream().map(i -> new Result(false, i))\n+        ).toList();\n+        List<Integer> nonIntrinsicValues = Stream.of(badSlots, u2Slots, u1Slots).<Integer>mapMulti(List::forEach)\n+                .filter(i -> i < 0 || i > 3).toList();\n+\n+        Label[] capture = new Label[1];\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            capture[0] = cob.startLabel();\n+            cob.return_();\n+        }));\n+        Label dummyLabel = capture[0];\n+\n+        List<ObjIntConsumer<CodeBuilder>> cbFactories = List.of(\n+                CodeBuilder::aload,\n+                CodeBuilder::iload,\n+                CodeBuilder::lload,\n+                CodeBuilder::dload,\n+                CodeBuilder::fload,\n+                CodeBuilder::astore,\n+                CodeBuilder::istore,\n+                CodeBuilder::lstore,\n+                CodeBuilder::dstore,\n+                CodeBuilder::fstore\n+        );\n+\n+        for (var r : u2Cases) {\n+            var fails = r.shouldFail;\n+            var i = r.slot;\n+            for (var fac : cbFactories) {\n+                \/\/check(fails, () -> execute(cob -> fac.accept(cob, i)));\n+            }\n+            for (TypeKind tk : TypeKind.values()) {\n+                if (tk == TypeKind.VOID)\n+                    continue;\n+                \/\/check(fails, () -> execute(cob -> cob.loadLocal(tk, i)));\n+                \/\/check(fails, () -> execute(cob -> cob.storeLocal(tk, i)));\n+                check(fails, () -> LoadInstruction.of(tk, i));\n+                check(fails, () -> StoreInstruction.of(tk, i));\n+            }\n+            \/\/check(fails, () -> execute(cob -> cob.iinc(i, 1)));\n+            check(fails, () -> IncrementInstruction.of(i, 1));\n+            check(fails, () -> DiscontinuedInstruction.RetInstruction.of(i));\n+            check(fails, () -> DiscontinuedInstruction.RetInstruction.of(RET_W, i));\n+            check(fails, () -> LocalVariable.of(i, \"test\", CD_Object, dummyLabel, dummyLabel));\n+            check(fails, () -> LocalVariableType.of(i, \"test\", Signature.of(CD_Object), dummyLabel, dummyLabel));\n+        }\n+\n+        for (var r : u1Cases) {\n+            var fails = r.shouldFail;\n+            var i = r.slot;\n+            for (var u1Op : List.of(ALOAD, ILOAD, LLOAD, FLOAD, DLOAD))\n+                check(fails, () -> LoadInstruction.of(u1Op, i));\n+            for (var u1Op : List.of(ASTORE, ISTORE, LSTORE, FSTORE, DSTORE))\n+                check(fails, () -> StoreInstruction.of(u1Op, i));\n+            check(fails, () -> DiscontinuedInstruction.RetInstruction.of(RET, i));\n+        }\n+\n+        for (var i : nonIntrinsicValues) {\n+            for (var intrinsicOp : List.of(ALOAD_0, ILOAD_0, LLOAD_0, FLOAD_0, DLOAD_0, ALOAD_1, ILOAD_1, LLOAD_1, FLOAD_1, DLOAD_1,\n+                    ALOAD_2, ILOAD_2, LLOAD_2, FLOAD_2, DLOAD_2, ALOAD_3, ILOAD_3, LLOAD_3, FLOAD_3, DLOAD_3)) {\n+                assertThrows(IllegalArgumentException.class, () -> LoadInstruction.of(intrinsicOp, i));\n+            }\n+            for (var intrinsicOp : List.of(ASTORE_0, ISTORE_0, LSTORE_0, FSTORE_0, DSTORE_0, ASTORE_1, ISTORE_1, LSTORE_1, FSTORE_1, DSTORE_1,\n+                    ASTORE_2, ISTORE_2, LSTORE_2, FSTORE_2, DSTORE_2, ASTORE_3, ISTORE_3, LSTORE_3, FSTORE_3, DSTORE_3)) {\n+                assertThrows(IllegalArgumentException.class, () -> StoreInstruction.of(intrinsicOp, i));\n+            }\n+        }\n+    }\n+\n+    static void check(boolean fails, Executable exec) {\n+        if (fails) {\n+            assertThrows(IllegalArgumentException.class, exec);\n+        } else {\n+            assertDoesNotThrow(exec);\n+        }\n+    }\n+\n+    @Test\n+    void testIincConstant() {\n+        IncrementInstruction.of(0, 2);\n+        IncrementInstruction.of(0, Short.MAX_VALUE);\n+        IncrementInstruction.of(0, Short.MIN_VALUE);\n+        assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(0, Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(0, Short.MIN_VALUE - 1));\n+    }\n+\n+    @Test\n+    void testNewMultiArrayDimension() {\n+        ClassEntry ce = ConstantPoolBuilder.of().classEntry(CD_Class);\n+        NewMultiArrayInstruction.of(ce, 1);\n+        NewMultiArrayInstruction.of(ce, 13);\n+        NewMultiArrayInstruction.of(ce, 0xFF);\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, 0));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, 0x100));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, -1));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, Integer.MIN_VALUE));\n+        assertThrows(IllegalArgumentException.class, () -> NewMultiArrayInstruction.of(ce, Integer.MAX_VALUE));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Testing ClassFile constant instruction argument validation.\n- * @run junit OpcodesValidationTest\n- *\/\n-import java.lang.classfile.instruction.ConstantInstruction;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-import static java.lang.classfile.Opcode.*;\n-\n-class OpcodesValidationTest {\n-\n-    @Test\n-    void testArgumentConstant() {\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n-        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n-\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MIN_VALUE - 1));\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MAX_VALUE + 1));\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MIN_VALUE - 1));\n-        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MAX_VALUE + 1));\n-    }\n-}\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"}]}