{"files":[{"patch":"@@ -2280,1 +2280,2 @@\n-      \/\/assert(false, \"compiler should always document failure\");\n+      assert(ci_env.failure_reason() != nullptr, \"expect failure reason\");\n+      assert(false, \"compiler should always document failure: %s\", ci_env.failure_reason());\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,1 +254,5 @@\n-        regalloc->C->record_method_not_compilable(\"illegal oopMap register name\");\n+        stringStream ss;\n+        ss.print(\"illegal oopMap register name: \");\n+        r->print_on(&ss);\n+        assert(false, \"%s\", ss.as_string());\n+        regalloc->C->record_method_not_compilable(ss.as_string());\n@@ -321,1 +325,5 @@\n-        regalloc->C->record_method_not_compilable(\"illegal oopMap register name\");\n+        stringStream ss;\n+        ss.print(\"illegal oopMap register name: \");\n+        r->print_on(&ss);\n+        assert(false, \"%s\", ss.as_string());\n+        regalloc->C->record_method_not_compilable(ss.as_string());\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -756,1 +756,5 @@\n-      record_method_not_compilable(\"cannot parse method\");\n+      const char* reason = InlineTree::check_can_parse(method());\n+      assert(reason != nullptr, \"expect reason for parse failure\");\n+      stringStream ss;\n+      ss.print(\"cannot parse method: %s\", reason);\n+      record_method_not_compilable(ss.as_string());\n@@ -765,1 +769,4 @@\n-        record_method_not_compilable(\"method parse failed\");\n+        assert(failure_reason() != nullptr, \"expect reason for parse failure\");\n+        stringStream ss;\n+        ss.print(\"method parse failed: %s\", failure_reason());\n+        record_method_not_compilable(ss.as_string());\n@@ -3925,0 +3932,2 @@\n+    \/\/ Do not compile method that is only a trivial infinite loop,\n+    \/\/ since the content of the loop may have been eliminated.\n@@ -3990,0 +3999,1 @@\n+\n@@ -3992,0 +4002,2 @@\n+        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n+        assert(false, \"malformed control flow\");\n@@ -4010,0 +4022,3 @@\n+        DEBUG_ONLY( n->fast_out(j)->dump(); );\n+        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n+        assert(false, \"infinite loop\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    assert(false, \"unreachable loop\");\n","filename":"src\/hotspot\/share\/opto\/domgraph.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1503,0 +1503,1 @@\n+    assert(false, \"early schedule failed\");\n@@ -1603,0 +1604,1 @@\n+        assert(false, \"local schedule failed\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4313,0 +4313,1 @@\n+      assert(false, \"empty program detected during loop optimization\");\n@@ -5174,0 +5175,1 @@\n+          \/\/ This is a rare case that we do not want to handle in C2.\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+      \/\/ Bailout. We do not have space to represent all arguments.\n@@ -314,0 +315,1 @@\n+    \/\/ Bailout. We do not have space to represent all arguments.\n@@ -361,0 +363,1 @@\n+      assert(false, \"instruction match failed\");\n@@ -392,1 +395,9 @@\n-    C->record_method_not_compilable(\"graph lost\"); \/\/ %%% cannot happen?\n+    \/\/ New graph lost. This is due to a compilation failure we encountered earlier.\n+    stringStream ss;\n+    if (C->failure_reason() != nullptr) {\n+      ss.print(\"graph lost: %s\", C->failure_reason());\n+    } else {\n+      assert(C->failure_reason() != nullptr, \"graph lost: reason unknown\");\n+      ss.print(\"graph lost: reason unknown\");\n+    }\n+    C->record_method_not_compilable(ss.as_string());\n@@ -1245,0 +1256,1 @@\n+      \/\/ Bailout. For example not enough space on stack for all arguments. Happens for methods with too many arguments.\n@@ -1437,0 +1449,1 @@\n+      \/\/ Bailout. We do not have space to represent all arguments.\n@@ -1624,0 +1637,1 @@\n+    \/\/ Bailout. Can for example be hit with a deep chain of operations.\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2847,0 +2847,2 @@\n+      DEBUG_ONLY( pinch->dump(); );\n+      assert(false, \"too many D-U pinch points: %d >= %d\", pinch->_idx, _regalloc->node_regs_max_index());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,0 +211,1 @@\n+    \/\/ Bailout. But we should probably kick into normal compilation?\n@@ -216,0 +217,2 @@\n+    assert(false, \"OSR starts with an immediate trap\");\n+    \/\/ Bailout. But we should probably kick into normal compilation?\n@@ -256,0 +259,1 @@\n+    assert(false, \"OSR in empty or breakpointed method\");\n@@ -432,0 +436,1 @@\n+    assert(false, \"type flow failed during parsing\");\n@@ -510,0 +515,1 @@\n+      assert(false, \"type flow analysis failed for OSR compilation\");\n@@ -1047,0 +1053,1 @@\n+      assert(false, \"Can't determine return type.\");\n@@ -1122,0 +1129,1 @@\n+    \/\/ Bailout expected, this is a very rare edge case.\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+      assert(false, \"RA Split failed: attempt to clone node with anti_dependence\");\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}