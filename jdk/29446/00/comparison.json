{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n@@ -75,1 +74,1 @@\n-  return AtomicAccess::load(&_head) == nullptr;\n+  return _head.load_relaxed() == nullptr;\n@@ -80,1 +79,1 @@\n-  ZMarkStackListNode* head = AtomicAccess::load(&_head);\n+  ZMarkStackListNode* head = _head.load_relaxed();\n@@ -90,1 +89,1 @@\n-    ZMarkStackListNode* prev = AtomicAccess::cmpxchg(&_head, head, node, memory_order_release);\n+    ZMarkStackListNode* const prev = _head.compare_exchange(head, node, memory_order_release);\n@@ -96,1 +95,1 @@\n-      AtomicAccess::inc(&_length, memory_order_relaxed);\n+      _length.add_then_fetch(1, memory_order_relaxed);\n@@ -106,1 +105,1 @@\n-  ZMarkStackListNode* volatile* const hazard_ptr = marking_smr->hazard_ptr();\n+  Atomic<ZMarkStackListNode*>& hazard_ptr = marking_smr->hazard_ptr();\n@@ -108,1 +107,1 @@\n-  ZMarkStackListNode* head = AtomicAccess::load(&_head);\n+  ZMarkStackListNode* head = _head.load_relaxed();\n@@ -118,1 +117,1 @@\n-    AtomicAccess::store(hazard_ptr, head);\n+    hazard_ptr.store_relaxed(head);\n@@ -130,1 +129,1 @@\n-    ZMarkStackListNode* const head_after_publish = AtomicAccess::load_acquire(&_head);\n+    ZMarkStackListNode* const head_after_publish = _head.load_acquire();\n@@ -144,1 +143,1 @@\n-    ZMarkStackListNode* const prev = AtomicAccess::cmpxchg(&_head, head, next, memory_order_relaxed);\n+    ZMarkStackListNode* const prev = _head.compare_exchange(head, next, memory_order_relaxed);\n@@ -152,1 +151,1 @@\n-      AtomicAccess::release_store(hazard_ptr, (ZMarkStackListNode*)nullptr);\n+      hazard_ptr.release_store(nullptr);\n@@ -155,1 +154,1 @@\n-      AtomicAccess::dec(&_length, memory_order_relaxed);\n+      _length.sub_then_fetch(1, memory_order_relaxed);\n@@ -170,1 +169,1 @@\n-  const ssize_t result = AtomicAccess::load(&_length);\n+  const ssize_t result = _length.load_relaxed();\n@@ -208,1 +207,1 @@\n-  _nstripes_mask = new_nstripes_mask;\n+  _nstripes_mask.store_relaxed(new_nstripes_mask);\n@@ -224,1 +223,1 @@\n-  if (AtomicAccess::cmpxchg(&_nstripes_mask, old_nstripes_mask, new_nstripes_mask) == old_nstripes_mask) {\n+  if (_nstripes_mask.compare_set(old_nstripes_mask, new_nstripes_mask)) {\n@@ -233,1 +232,1 @@\n-  return AtomicAccess::load(&_nstripes_mask) + 1;\n+  return _nstripes_mask.load_relaxed() + 1;\n@@ -261,1 +260,1 @@\n-  const size_t mask = AtomicAccess::load(&_nstripes_mask);\n+  const size_t mask = _nstripes_mask.load_relaxed();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.cpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -75,2 +76,2 @@\n-  ZMarkStackListNode* volatile _head;\n-  ssize_t volatile             _length;\n+  Atomic<ZMarkStackListNode*> _head;\n+  Atomic<ssize_t>             _length;\n@@ -106,2 +107,2 @@\n-  size_t      _nstripes_mask;\n-  ZMarkStripe _stripes[ZMarkStripesMax];\n+  Atomic<size_t> _nstripes_mask;\n+  ZMarkStripe    _stripes[ZMarkStripesMax];\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  const size_t index = (addr >> ZMarkStripeShift) & AtomicAccess::load(&_nstripes_mask);\n+  const size_t index = (addr >> ZMarkStripeShift) & _nstripes_mask.load_relaxed();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"runtime\/atomicAccess.hpp\"\n@@ -73,1 +72,1 @@\n-    ZMarkStackListNode* const hazard = AtomicAccess::load(&remote_state->_hazard_ptr);\n+    ZMarkStackListNode* const hazard = remote_state->_hazard_ptr.load_relaxed();\n@@ -110,2 +109,2 @@\n-ZMarkStackListNode* volatile* ZMarkingSMR::hazard_ptr() {\n-  return &_worker_states.addr()->_hazard_ptr;\n+Atomic<ZMarkStackListNode*>& ZMarkingSMR::hazard_ptr() {\n+  return _worker_states.addr()->_hazard_ptr;\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkingSMR.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -37,3 +38,3 @@\n-    ZMarkStackListNode* volatile _hazard_ptr;\n-    ZArray<ZMarkStackListNode*>  _scanned_hazards;\n-    ZArray<ZMarkStackListNode*>  _freeing;\n+    Atomic<ZMarkStackListNode*> _hazard_ptr;\n+    ZArray<ZMarkStackListNode*> _scanned_hazards;\n+    ZArray<ZMarkStackListNode*> _freeing;\n@@ -50,1 +51,1 @@\n-  ZMarkStackListNode* volatile* hazard_ptr();\n+  Atomic<ZMarkStackListNode*>& hazard_ptr();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkingSMR.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}