{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-public interface AsymmetricKey extends Key {\n+public non-sealed interface AsymmetricKey extends Key, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/AsymmetricKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+\/**\n+ * This interface is implemented by security API classes that contain\n+ * binary-encodable key or certificate material.\n+ * These APIs or their subclasses typically provide methods to convert\n+ * their instances to and from byte arrays in the Distinguished\n+ * Encoding Rules (DER) format (ITU X.690).\n+ *\n+ * @see AsymmetricKey\n+ * @see KeyPair\n+ * @see PKCS8EncodedKeySpec\n+ * @see X509EncodedKeySpec\n+ * @see EncryptedPrivateKeyInfo\n+ * @see X509Certificate\n+ * @see X509CRL\n+ * @see PEMRecord\n+ *\n+ * @since 25\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public sealed interface DEREncodable permits AsymmetricKey, KeyPair,\n+    PKCS8EncodedKeySpec, X509EncodedKeySpec, EncryptedPrivateKeyInfo,\n+    X509Certificate, X509CRL, PEMRecord {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-public final class KeyPair implements java.io.Serializable {\n+public final class KeyPair implements java.io.Serializable, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPair.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.rsa.RSAPrivateCrtKeyImpl;\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.*;\n+import java.security.spec.*;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * {@code PEMDecoder} implements a decoder for Privacy-Enhanced Mail (PEM) data.\n+ * PEM is a textual encoding used to store and transfer security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * and footer.\n+ *\n+ * <p> The {@linkplain #decode(String)} and {@linkplain #decode(InputStream)}\n+ * methods return an instance of a class that matches the data\n+ * type and implements {@link DEREncodable}. The following types are\n+ * decoded into Java API cryptographic object that implement\n+ * {@link DEREncodable}:\n+ * <pre>\n+ *     PRIVATE KEY, RSA PRIVATE KEY, PUBLIC KEY, CERTIFICATE,\n+ *     X509 CERTIFICATE, X509 CRL, and ENCRYPTED PRIVATE KEY.\n+ * <\/pre>\n+ *\n+ * <p> If the PEM does not have a JCE object representation, it returns a\n+ * {@link PEMRecord}.\n+ *\n+ * <p> The {@linkplain #decode(String, Class)} and\n+ * {@linkplain #decode(InputStream, Class)} methods take a Class parameter\n+ * which determines the type of {@code DEREncodable} that is returned. These\n+ * methods are useful when extracting or changing the return class.\n+ * The Class parameter can specify the returned\n+ * key object from a PEM containing a public and private key.  If only\n+ * the private key is required, {@code PrivateKey.class} can be used.\n+ * If the Class parameter is set to {@code X509EncodedKeySpec.class}, the\n+ * public key will be returned in that format.  Any type of PEM data can be\n+ * decoded into a {@code PEMRecord} by specifying {@code PEMRecord.class}.\n+ * If the Class parameter doesn't match the PEM content, an\n+ * {@code IllegalArgumentException} will be thrown.\n+ *\n+ * <p> A new {@code PEMDecoder} instance is created when configured\n+ * with {@linkplain #withFactory(Provider)} and\/or\n+ * {@linkplain #withDecryption(char[])}. {@linkplain #withFactory(Provider)}\n+ * configures the decoder to use only {@linkplain KeyFactory} and\n+ * {@linkplain CertificateFactory} instances from the given {@code Provider}.\n+ * {@link#withDecryption(char[])} configures the decoder to decrypt all\n+ * encrypted private key PEM data using the given password.\n+ * Configuring an instance for decryption does not prevent decoding with\n+ * unencrypted PEM. Any encrypted PEM that does not use the configured password\n+ * will throw a {@link RuntimeException}. When encrypted PEM is used with a\n+ * decoder not configured for decryption, an {@link EncryptedPrivateKeyInfo}\n+ * object is returned.  {@code EncryptedPrivateKeyInfo} methods must be used to\n+ * retrieve the {@link PrivateKey}.\n+ *\n+ * <p>This class is immutable and thread-safe.\n+ *\n+ * <p> Here is an example of decoding a {@code PrivateKey} object:\n+ * {@snippet lang = java:\n+ *     PEMDecoder pd = PEMDecoder.of();\n+ *     PrivateKey priKey = pd.decode(priKeyPEM, PrivateKey.class);\n+ * }\n+ *\n+ * @see PEMEncoder\n+ * @see PEMRecord\n+ * @see EncryptedPrivateKeyInfo\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc1421\n+ *       RFC 1421: Privacy Enhancement for Internet Electronic Mail\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @since 25\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMDecoder {\n+    private final Provider factory;\n+    private final PBEKeySpec password;\n+\n+    \/\/ Singleton instance for PEMDecoder\n+    private final static PEMDecoder PEM_DECODER = new PEMDecoder(null, null);\n+\n+    \/**\n+     * Creates an instance with a specific KeyFactory and\/or password.\n+     * @param withFactory KeyFactory provider\n+     * @param withPassword char[] password for EncryptedPrivateKeyInfo\n+     *                    decryption\n+     *\/\n+    private PEMDecoder(Provider withFactory, PBEKeySpec withPassword) {\n+        password = withPassword;\n+        factory = withFactory;\n+    }\n+\n+    \/**\n+     * Returns an instance of {@code PEMDecoder}.\n+     *\n+     * @return a new {@code PEMDecoder} instance\n+     *\/\n+    public static PEMDecoder of() {\n+        return PEM_DECODER;\n+    }\n+\n+    \/**\n+     * After the header, footer, and base64 have been separated, identify the\n+     * header and footer and proceed with decoding the base64 for the\n+     * appropriate type.\n+     *\/\n+    private DEREncodable decode(PEMRecord pem) {\n+        Base64.Decoder decoder = Base64.getMimeDecoder();\n+        if (pem.type() == null) {\n+            return pem;\n+        }\n+\n+        try {\n+            return switch (pem.type()) {\n+                case Pem.PUBLIC_KEY -> {\n+                    X509EncodedKeySpec spec =\n+                        new X509EncodedKeySpec(decoder.decode(pem.pem()));\n+                    yield (getKeyFactory(spec.getAlgorithm())).\n+                        generatePublic(spec);\n+                }\n+                case Pem.PRIVATE_KEY -> {\n+                    PKCS8Key p8key = new PKCS8Key(decoder.decode(pem.pem()));\n+                    String algo = p8key.getAlgorithm();\n+                    KeyFactory kf = getKeyFactory(algo);\n+                    DEREncodable d = kf.generatePrivate(\n+                        new PKCS8EncodedKeySpec(p8key.getEncoded(), algo));\n+\n+                    \/\/ Look for a public key inside the pkcs8 encoding.\n+                    if (p8key.getPubKeyEncoded() != null) {\n+                        \/\/ Check if this is a OneAsymmetricKey encoding\n+                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                            p8key.getPubKeyEncoded(), algo);\n+                        yield new KeyPair(getKeyFactory(algo).\n+                            generatePublic(spec), (PrivateKey) d);\n+\n+                    } else if (d instanceof PKCS8Key p8 &&\n+                        p8.getPubKeyEncoded() != null) {\n+                        \/\/ If the KeyFactory decoded an algorithm-specific\n+                        \/\/ encodings, look for the public key again.  This\n+                        \/\/ happens with EC and SEC1-v2 encoding\n+                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                            p8.getPubKeyEncoded(), algo);\n+                        yield new KeyPair(getKeyFactory(algo).\n+                            generatePublic(spec), p8);\n+                    } else {\n+                        \/\/ No public key, return the private key.\n+                        yield d;\n+                    }\n+                }\n+                case Pem.ENCRYPTED_PRIVATE_KEY -> {\n+                    if (password == null) {\n+                        yield new EncryptedPrivateKeyInfo(decoder.decode(\n+                            pem.pem()));\n+                    }\n+                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem())).\n+                        getKey(password.getPassword());\n+                }\n+                case Pem.CERTIFICATE, Pem.X509_CERTIFICATE,\n+                     Pem.X_509_CERTIFICATE -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n+                    yield (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n+                }\n+                case Pem.X509_CRL, Pem.CRL -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n+                    yield (X509CRL) cf.generateCRL(\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n+                }\n+                case Pem.RSA_PRIVATE_KEY -> {\n+                    KeyFactory kf = getKeyFactory(\"RSA\");\n+                    yield kf.generatePrivate(\n+                        RSAPrivateCrtKeyImpl.getKeySpec(decoder.decode(\n+                            pem.pem())));\n+                }\n+                default -> pem;\n+            };\n+        } catch (GeneralSecurityException | IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns a {@link DEREncodable} from the given {@code String}.\n+     *\n+     * <p> This method reads the {@code String} until PEM data is found\n+     * or the end of the {@code String} is reached.  If no PEM data is found,\n+     * an {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p> This method returns a Java API cryptographic object,\n+     * such as a {@code PrivateKey}, if the PEM type is supported.\n+     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n+     * If no cryptographic object is found, a {@link PEMRecord} will be\n+     * returned containing the type identifier and Base64-encoded data.\n+     * Any non-PEM data preceding the PEM header will be stored in\n+     * {@code leadingData}.\n+     *\n+     * <p>If no PEM data is found, an {@code IllegalArgumentException} is\n+     * thrown.\n+     *\n+     * <p> Input consumed by this method is read in as\n+     * {@link java.nio.charset.StandardCharsets#UTF_8 UTF-8}.\n+     *\n+     * @param str a String containing PEM data\n+     * @return a {@code DEREncodable}\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws NullPointerException when {@code str} is null.\n+     *\/\n+    public DEREncodable decode(String str) {\n+        Objects.requireNonNull(str);\n+        DEREncodable de;\n+        try {\n+            return decode(new ByteArrayInputStream(\n+                str.getBytes(StandardCharsets.UTF_8)));\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns a {@link DEREncodable} from the given\n+     * {@code InputStream}.\n+     *\n+     * <p>This method reads the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  It can be called repeatedly\n+     * on the {@code InputStream} to decode additional PEM data.\n+     * The {@code InputStream} read pointer will remain at the end of\n+     * the PEM footer unless an IOException occurs.\n+     *\n+     * <p> This method returns a Java API cryptographic object,\n+     * such as a {@code PrivateKey}, if the PEM type is supported.\n+     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n+     * If no cryptographic object is found, a {@link PEMRecord} will be\n+     * returned containing the type identifier and Base64-encoded data.\n+     * Any non-PEM data preceding the PEM header will be stored in\n+     * {@code leadingData}.\n+     *\n+     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n+     * thrown.\n+     *\n+     * @param is InputStream containing PEM data\n+     * @return a {@code DEREncodable}\n+     * @throws IOException on IO error with the {@code InputStream}\n+     * @throws EOFException the end of {@code InputStream} has been\n+     * unexpectedly reached.\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws NullPointerException when {@code is} is null.\n+     *\/\n+    public DEREncodable decode(InputStream is) throws IOException {\n+        Objects.requireNonNull(is);\n+        PEMRecord pem = Pem.readPEM(is);\n+        return decode(pem);\n+    }\n+\n+    \/**\n+     * Decodes and returns a {@code DEREncodable} of the specified class from\n+     * the given PEM string. {@code tClass} must extend {@link DEREncodable}\n+     * and be an appropriate class for the PEM type.\n+     *\n+     * <p> This method reads the {@code String} until PEM data is found\n+     * or the end of the {@code String} is reached.  If no PEM data is found,\n+     * an {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p> If the class parameter is {@code PEMRecord.class},\n+     * a {@linkplain PEMRecord} is returned containing the\n+     * type identifier and Base64 encoding. Any non-PEM data preceding\n+     * the PEM header will be stored in {@code leadingData}.  Other\n+     * class parameters will not return preceding non-PEM data.\n+     *\n+     * <p> Input consumed by this method is read in as\n+     * {@link java.nio.charset.StandardCharsets#UTF_8 UTF-8}.\n+     *\n+     * <p> For all other class parameters, {@code IllegalArgumentException} is\n+     * thrown when not PEM data is found.  All non-PEM data is ignored.\n+     *\n+     * @param <S> Class type parameter that extends {@code DEREncodable}.\n+     * @param str the String containing PEM data\n+     * @param tClass the returned object class that implements\n+     * {@code DEREncodable}.\n+     * @return a {@code DEREncodable} specified by {@code tClass}\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws ClassCastException if {@code tClass} is invalid for the PEM type.\n+     * @throws NullPointerException when any input values are null.\n+     *\n+     * @see PEMDecoder for how {@code tClass} can be used.\n+     *\/\n+    public <S extends DEREncodable> S decode(String str, Class<S> tClass) {\n+        Objects.requireNonNull(str);\n+        try {\n+            return decode(new ByteArrayInputStream(\n+                str.getBytes(StandardCharsets.UTF_8)), tClass);\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given\n+     * {@link InputStream}.  The class must extend {@link DEREncodable} and be\n+     * an appropriate class for the PEM type.\n+     *\n+     * <p> This method reads the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  It can be called repeatedly\n+     * on the {@code InputStream} to decode additional PEM data.\n+     * The {@code InputStream} read pointer will remain at the end of\n+     * the PEM footer unless an IOException occurs.\n+     *\n+     * <p> If the class parameter is {@code PEMRecord.class},\n+     * a {@linkplain PEMRecord} is returned containing the\n+     * type identifier and Base64 encoding. Any non-PEM data preceding\n+     * the PEM header will be stored in {@code leadingData}.  Other\n+     * class parameters will not return preceding non-PEM data.\n+     *\n+     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n+     * thrown.\n+     *\n+     * @param <S> Class type parameter that extends {@code DEREncodable}.\n+     * @param is an InputStream containing PEM data\n+     * @param tClass the returned object class that implements\n+     *   {@code DEREncodable}.\n+     * @return a {@code DEREncodable} typecast to {@code tClass}\n+     * @throws IOException on IO error with the {@code InputStream}\n+     * @throws EOFException when reading pass the end of the\n+     * {@code InputStream}.\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws ClassCastException if {@code tClass} is invalid for the PEM type.\n+     * @throws NullPointerException when any input values are null.\n+     *\n+     * @see #decode(InputStream)\n+     * @see #decode(String, Class)\n+     *\/\n+    public <S extends DEREncodable> S decode(InputStream is, Class<S> tClass)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+        Objects.requireNonNull(tClass);\n+        PEMRecord pem = Pem.readPEM(is);\n+\n+        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+            return tClass.cast(pem);\n+        }\n+        DEREncodable so = decode(pem);\n+\n+        \/*\n+         * If the object is a KeyPair, check if the tClass is set to class\n+         * specific to a private or public key.  Because PKCS8v2 can be a\n+         * KeyPair, it is possible for someone to assume all their PEM private\n+         * keys are only PrivateKey and not KeyPair.\n+         *\/\n+        if (so instanceof KeyPair kp) {\n+            if ((PrivateKey.class).isAssignableFrom(tClass) ||\n+                (PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPrivate();\n+            }\n+            if ((PublicKey.class).isAssignableFrom(tClass) ||\n+                (X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPublic();\n+            }\n+        }\n+\n+        \/*\n+         * KeySpec use getKeySpec after the Key has been generated.  Even though\n+         * returning a binary encoding after the Base64 decoding is ok when the\n+         * user wants PKCS8EncodedKeySpec, generating the key verifies the\n+         * binary encoding and allows the KeyFactory to use the provider's\n+         * KeySpec()\n+         *\/\n+\n+        if ((EncodedKeySpec.class).isAssignableFrom(tClass) &&\n+            so instanceof Key key) {\n+            try {\n+                \/\/ unchecked suppressed as we know tClass comes from KeySpec\n+                \/\/ KeyType not relevant here.  We just want KeyFactory\n+                if ((PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    so = getKeyFactory(key.getAlgorithm()).\n+                        getKeySpec(key, PKCS8EncodedKeySpec.class);\n+                } else if ((X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    so = getKeyFactory(key.getAlgorithm())\n+                        .getKeySpec(key, X509EncodedKeySpec.class);\n+                } else {\n+                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                }\n+            } catch (InvalidKeySpecException e) {\n+                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n+                    \"specified (\" + tClass.getName() +\") for key (\" +\n+                    key.getClass().getName() +\")\", e);\n+            }\n+        }\n+\n+        return tClass.cast(so);\n+    }\n+\n+    private KeyFactory getKeyFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return KeyFactory.getInstance(algorithm);\n+            }\n+            return KeyFactory.getInstance(algorithm, factory);\n+        } catch(GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/\/ Convenience method to avoid provider getInstance checks clutter\n+    private CertificateFactory getCertFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return CertificateFactory.getInstance(algorithm);\n+            }\n+            return CertificateFactory.getInstance(algorithm, factory);\n+        } catch (GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Configures and returns a new {@code PEMDecoder} instance from the\n+     * current instance that will use {@link KeyFactory} and\n+     * {@link CertificateFactory} classes from the specified {@link Provider}.\n+     * Any errors using the {@code provider} will occur during decoding.\n+     *\n+     * <p>If {@code provider} is {@code null}, a new instance is returned with\n+     * the default provider configuration.\n+     *\n+     * @param provider the factory provider\n+     * @return a new configured {@code PEMDecoder} instance\n+     *\/\n+    public PEMDecoder withFactory(Provider provider) {\n+        return new PEMDecoder(provider, password);\n+    }\n+\n+    \/**\n+     * Returns a copy of this PEMDecoder that will decrypt encrypted PEM data\n+     * such as encrypted private keys with the specified password.\n+     * Non-encrypted PEM may still be decoded from this instance.\n+     *\n+     * @param password the password to decrypt encrypted PEM data.  This array\n+     *                 is cloned and stored in the new instance.\n+     * @return a new configured {@code PEMDecoder} instance\n+     * @throws NullPointerException if {@code password} is null.\n+     *\/\n+    public PEMDecoder withDecryption(char[] password) {\n+        return new PEMDecoder(factory, new PBEKeySpec(password));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.Pem;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\/**\n+ * {@code PEMEncoder} implements an encoder for Privacy-Enhanced Mail (PEM)\n+ * data.  PEM is a textual encoding used to store and transfer security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * and footer.\n+ *\n+ * <p> Encoding may be performed on Java API cryptographic objects that\n+ * implement {@link DEREncodable}.\n+ *\n+ * <p> Private keys can be encrypted and encoded by configuring a\n+ * {@code PEMEncoder} with the {@linkplain #withEncryption(char[])} method,\n+ * which takes a password and returns a new {@code PEMEncoder} instance\n+ * configured to encrypt the key with that password. Alternatively, a\n+ * private key encrypted as an {@code EncryptedKeyInfo} object can be encoded\n+ * directly to PEM by passing it to the encode method\n+ *\n+ * <p> PKCS #8 2.0 defines the ASN.1 OneAsymmetricKey structure, which may\n+ * contain both private and public keys.\n+ * {@link KeyPair} objects passed to the {@code encode} methods are encoded as a\n+ * OneAsymmetricKey structure using the \"PRIVATE KEY\" type.\n+ *\n+ * <p> When encoding a {@link PEMRecord}, the API surrounds the\n+ * {@linkplain PEMRecord#pem()} with a generated the PEM header and footer\n+ * from {@linkplain PEMRecord#type()}. {@linkplain PEMRecord#leadingData()} is\n+ * not included in the encoding.  {@code PEMRecord} will not preform\n+ * validity checks on the data.\n+ *\n+ * <p> This class is immutable and thread-safe.\n+ *\n+ * <p> Here is an example of encoding a {@code PrivateKey} object:\n+ * {@snippet lang = java:\n+ *     PEMEncoder pe = PEMEncoder.of();\n+ *     byte[] pemData = pe.encode(privKey);\n+ * }\n+ *\n+ * <p> Here is an example that encrypts and encodes a private key using the\n+ * specified password.\n+ * {@snippet lang = java:\n+ *     PEMEncoder pe = PEMEncoder.of().withEncryption(password);\n+ *     byte[] pemData = pe.encode(privKey);\n+ * }\n+ *\n+ * @see PEMDecoder\n+ * @see PEMRecord\n+ * @see EncryptedPrivateKeyInfo\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc1421\n+ *       RFC 1421: Privacy Enhancement for Internet Electronic Mail\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMEncoder {\n+\n+    \/\/ Singleton instance of PEMEncoder\n+    private static final PEMEncoder PEM_ENCODER = new PEMEncoder(null);\n+\n+    \/\/ Stores the password for an encrypted encoder that isn't setup yet.\n+    private PBEKeySpec keySpec;\n+    \/\/ Stores the key after the encoder is ready to encrypt.  The prevents\n+    \/\/ repeated SecretKeyFactory calls if the encoder is used on multiple keys.\n+    private SecretKey key;\n+    \/\/ Makes SecretKeyFactory generation thread-safe.\n+    private final ReentrantLock lock;\n+\n+    \/**\n+     * Instantiate a {@code PEMEncoder} for Encrypted Private Keys.\n+     *\n+     * @param pbe contains the password spec used for encryption.\n+     *\/\n+    private PEMEncoder(PBEKeySpec pbe) {\n+        keySpec = pbe;\n+        key = null;\n+        lock = new ReentrantLock();\n+    }\n+\n+    \/**\n+     * Returns a new instance of {@code PEMEncoder}.\n+     *\n+     * @return a new {@code PEMEncoder} instance\n+     *\/\n+    public static PEMEncoder of() {\n+        return PEM_ENCODER;\n+    }\n+\n+    \/**\n+     * Encodes the specified {@code DEREncodable} and returns a PEM encoded\n+     * string.\n+     *\n+     * @param de the {@code DEREncodable} to be encoded.\n+     * @return a byte array containing the PEM encoded data\n+     * @throws IllegalArgumentException If the DEREncodable cannot be encoded\n+     * @throws NullPointerException if {@code de} is {@code null}.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public String encodeToString(DEREncodable de) {\n+        Objects.requireNonNull(de);\n+        return switch (de) {\n+            case PublicKey pu -> buildKey(null, pu.getEncoded());\n+            case PrivateKey pr -> buildKey(pr.getEncoded(), null);\n+            case KeyPair kp -> {\n+                if (kp.getPublic() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PublicKey.\");\n+                }\n+                if (kp.getPrivate() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PrivateKey.\");\n+                }\n+                yield buildKey(kp.getPrivate().getEncoded(),\n+                    kp.getPublic().getEncoded());\n+            }\n+            case X509EncodedKeySpec x ->\n+                buildKey(null, x.getEncoded());\n+            case PKCS8EncodedKeySpec p ->\n+                buildKey(p.getEncoded(), null);\n+            case EncryptedPrivateKeyInfo epki -> {\n+                try {\n+                    yield Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n+                        epki.getEncoded());\n+                } catch (IOException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case X509Certificate c -> {\n+                try {\n+                    if (isEncrypted()) {\n+                        throw new IllegalArgumentException(\"Certificates \" +\n+                            \"cannot be encrypted\");\n+                    }\n+                    yield Pem.pemEncoded(Pem.CERTIFICATE, c.getEncoded());\n+                } catch (CertificateEncodingException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case X509CRL crl -> {\n+                try {\n+                    if (isEncrypted()) {\n+                        throw new IllegalArgumentException(\"CRLs cannot be \" +\n+                            \"encrypted\");\n+                    }\n+                    yield Pem.pemEncoded(Pem.X509_CRL, crl.getEncoded());\n+                } catch (CRLException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case PEMRecord rec -> Pem.pemEncoded(rec);\n+\n+            default -> throw new IllegalArgumentException(\"PEM does not \" +\n+                \"support \" + de.getClass().getCanonicalName());\n+        };\n+    }\n+\n+    \/**\n+     * Encodes the specified {@code DEREncodable} and returns the PEM encoding\n+     * in a byte array.\n+     *\n+     * @param de the {@code DEREncodable} to be encoded.\n+     * @return a PEM encoded byte array\n+     * @throws IllegalArgumentException if the DEREncodable cannot be encoded\n+     * @throws NullPointerException if {@code de} is {@code null}.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public byte[] encode(DEREncodable de) {\n+        return encodeToString(de).getBytes(StandardCharsets.ISO_8859_1);\n+    }\n+\n+    \/**\n+     * Returns a new {@code PEMEncoder} instance configured with the default\n+     * encryption algorithm and a given password.\n+     *\n+     * <p> Only {@link PrivateKey} objects can be encrypted with this newly\n+     * configured instance.  Encoding other {@link DEREncodable} objects will\n+     * throw an {@code IllegalArgumentException}.\n+     *\n+     * @implNote The default algorithm is defined by Security Property {@code\n+     * jdk.epkcs8.defaultAlgorithm} using default password-based encryption\n+     * parameters by the supporting provider.  If you need more control over\n+     * the encryption algorithm and parameters, use\n+     * {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n+     * String, AlgorithmParameterSpec, Provider, SecureRandom)} and use the\n+     * returned object with {@link #encode(DEREncodable)}.\n+     *\n+     * @param password sets the encryption password.  The array is cloned and\n+     *                stored in the new instance. {@code null} is a valid value.\n+     * @return a new configured {@code PEMEncoder} instance\n+     *\/\n+    public PEMEncoder withEncryption(char[] password) {\n+        \/\/ PBEKeySpec clones the password\n+        return new PEMEncoder(new PBEKeySpec(password));\n+    }\n+\n+    \/**\n+     * Build PEM encoding.\n+     *\/\n+    private String buildKey(byte[] privateBytes, byte[] publicBytes) {\n+        DerOutputStream out = new DerOutputStream();\n+        Cipher cipher;\n+\n+        if (privateBytes == null && publicBytes == null) {\n+            throw new IllegalArgumentException(\"No encoded data given by the \" +\n+                \"DEREncodable.\");\n+        }\n+\n+        \/\/ If `keySpec` is non-null, then `key` hasn't been established.\n+        \/\/ Setting a `key' prevents repeated key generations operations.\n+        \/\/ withEncryption() is a configuration method and cannot throw an\n+        \/\/ exception; therefore generation is delayed.\n+        if (keySpec != null) {\n+            \/\/ For thread safety\n+            lock.lock();\n+            if (key == null) {\n+                try {\n+                    key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n+                        generateSecret(keySpec);\n+                    keySpec.clearPassword();\n+                    keySpec = null;\n+                } catch (GeneralSecurityException e) {\n+                    throw new RuntimeException(\"Security property \" +\n+                        \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                        \"valid algorithm.  Operation cannot be performed.\", e);\n+                } finally {\n+                    lock.unlock();\n+                }\n+            } else {\n+                lock.unlock();\n+            }\n+        }\n+\n+        \/\/ If `key` is non-null, this is an encoder ready to encrypt.\n+        if (key != null) {\n+            if (privateBytes == null || publicBytes != null) {\n+                throw new IllegalArgumentException(\"Can only encrypt a \" +\n+                    \"PrivateKey.\");\n+            }\n+\n+            try {\n+                cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n+                cipher.init(Cipher.ENCRYPT_MODE, key);\n+            } catch (GeneralSecurityException e) {\n+                throw new RuntimeException(\"Security property \" +\n+                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                    \"valid algorithm.  Operation cannot be performed.\", e);\n+            }\n+\n+            new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n+                cipher.getParameters()).encode(out);\n+\n+            try {\n+                out.putOctetString(cipher.doFinal(privateBytes));\n+                return Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n+                    DerValue.wrap(DerValue.tag_Sequence, out).toByteArray());\n+            } catch (GeneralSecurityException e) {\n+                throw new IllegalArgumentException(e);\n+            }\n+        }\n+\n+        \/\/ X509 only\n+        if (publicBytes != null && privateBytes == null) {\n+            if (publicBytes.length == 0) {\n+                throw new IllegalArgumentException(\"No public key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n+\n+            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicBytes);\n+        }\n+\n+        \/\/ PKCS8 only\n+        if (publicBytes == null && privateBytes != null) {\n+            if (privateBytes.length == 0) {\n+                throw new IllegalArgumentException(\"No private key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n+\n+            return Pem.pemEncoded(Pem.PRIVATE_KEY, privateBytes);\n+        }\n+\n+        \/\/ OneAsymmetricKey\n+        if (privateBytes.length == 0) {\n+            throw new IllegalArgumentException(\"No private key encoding \" +\n+                \"given by the DEREncodable.\");\n+        }\n+\n+        if (publicBytes.length == 0) {\n+            throw new IllegalArgumentException(\"No public key encoding \" +\n+                \"given by the DEREncodable.\");\n+        }\n+        try {\n+            return Pem.pemEncoded(Pem.PRIVATE_KEY,\n+                PKCS8Key.getEncoded(publicBytes, privateBytes));\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    private boolean isEncrypted() {\n+        return (key != null || keySpec != null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.util.Pem;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * {@code PEMRecord} is a {@link DEREncodable} that represents Privacy-Enhanced\n+ * Mail (PEM) data by its type and Base64 form.  {@link PEMDecoder} and\n+ * {@link PEMEncoder} use {@code PEMRecord} when representing the data as a\n+ * cryptographic object is not desired or the type has no\n+ * {@code DEREncodable}.\n+ *\n+ * <p> {@code type} and {@code pem} may not be {@code null}.\n+ * {@code leadingData} may be null if no non-PEM data preceded PEM header\n+ * during decoding.  {@code leadingData} maybe be useful for reading metadata\n+ * that accompanies PEM data.\n+ *\n+ * <p> During the instantiation of this record, there is no validation\n+ * for the {@code type} or {@code pem}. {@code leadingData} is not\n+ * defensively copied.\n+ *\n+ * @param type The type identifier in the PEM header without PEM syntax labels.\n+ *           For a public key, {@code type} would be \"PUBLIC KEY\".\n+ * @param pem Any data between the PEM header and footer.\n+ * @param leadingData Any non-PEM data preceding the PEM header when decoding.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @see PEMDecoder\n+ * @see PEMEncoder\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public record PEMRecord(String type, String pem, byte[] leadingData)\n+    implements DEREncodable {\n+\n+    \/**\n+     * Creates a {@code PEMRecord} instance with the given parameters.\n+     *\n+     * @param type the type identifier\n+     * @param pem the Base64-encoded data encapsulated by the PEM header and\n+     *           footer.\n+     * @param leadingData Any non-PEM data read during the decoding process\n+     *                    before the PEM header.  This value maybe {@code null}.\n+     * @throws IllegalArgumentException if the {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code pem} are\n+     * {@code null}.\n+     *\/\n+    public PEMRecord(String type, String pem, byte[] leadingData) {\n+        Objects.requireNonNull(type, \"\\\"type\\\" may not be null.\");\n+        Objects.requireNonNull(type, \"\\\"pem\\\" may not be null.\");\n+\n+        \/\/ With no validity checking on `type`, the constructor accept anything\n+        \/\/ including lowercase.  The onus is on the caller.\n+        if (type.startsWith(\"-\") || type.contains(\"BEGIN\") ||\n+            type.contains(\"END\") || type.endsWith(\"-\")) {\n+            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n+                \"Only the PEM type identifier is allowed\");\n+        }\n+\n+        this.type = type;\n+        this.pem = pem;\n+        this.leadingData = leadingData;\n+    }\n+\n+    \/**\n+     * Creates a {@code PEMRecord} instance with a given {@code type} and\n+     * {@code pem} data in String form.  {@code leadingData} is set to null.\n+     *\n+     * @param type the PEM type identifier\n+     * @param pem the Base64-encoded data encapsulated by the PEM header and\n+     *           footer.\n+     * @throws IllegalArgumentException if the {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code pem} are\n+     * {@code null}.\n+     *\/\n+    public PEMRecord(String type, String pem) {\n+        this(type, pem, null);\n+    }\n+\n+    \/**\n+     * Creates a {@code PEMRecord} instance with a given String {@code type} and\n+     * byte array {@code pem}.  {@code leadingData} is set to null.\n+\n+     * @param type the PEM type identifier\n+     * @param pem the Base64-encoded data encapsulated by the PEM header and\n+     *           footer.\n+     * @throws IllegalArgumentException if the {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code pem} are\n+     * {@code null}.\n+     *\/\n+    public PEMRecord(String type, byte[] pem) {\n+        this(type, new String(pem, StandardCharsets.ISO_8859_1), null);\n+    }\n+\n+    \/**\n+     * Returns the binary encoding from the Base64 data contained in\n+     * {@code pem}.\n+     *\n+     * @throws IllegalArgumentException if {@code pem} cannot be decoded.\n+     * @return a new array of the binary encoding each time this\n+     * method is called.\n+     *\/\n+    public byte[] getEncoded() {\n+        return Base64.getMimeDecoder().decode(pem);\n+    }\n+\n+    \/**\n+     * Returns the type and Base64 encoding in PEM format.  {@code leadingData}\n+     * is not returned by this method.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Pem.pemEncoded(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-public abstract class X509CRL extends CRL implements X509Extension {\n+public abstract non-sealed class X509CRL extends CRL implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CRL.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,2 +110,2 @@\n-public abstract class X509Certificate extends Certificate\n-implements X509Extension {\n+public abstract non-sealed class X509Certificate extends Certificate\n+    implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509Certificate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -30,0 +31,1 @@\n+import java.io.IOException;\n@@ -50,1 +52,1 @@\n-    private String algorithmName;\n+    private final String algorithmName;\n@@ -67,0 +69,7 @@\n+        String algName = null;\n+        try {\n+            algName = KeyUtil.getAlgorithm(this.encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n+        algorithmName = algName;\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import sun.security.util.KeyUtil;\n+\n+import java.io.IOException;\n+import java.security.DEREncodable;\n+\n@@ -30,2 +35,2 @@\n- * encoded according to the ASN.1 type {@code PrivateKeyInfo}.\n- * The {@code PrivateKeyInfo} syntax is defined in the PKCS#8 standard\n+ * encoded according to the ASN.1 type {@code OneAsymmetricKey}.\n+ * The {@code OneAsymmetricKey} syntax is defined in the PKCS#8 standard\n@@ -35,1 +40,1 @@\n- * PrivateKeyInfo ::= SEQUENCE {\n+ * OneAsymmetricKey ::= SEQUENCE {\n@@ -39,1 +44,7 @@\n- *   attributes [0] IMPLICIT Attributes OPTIONAL }\n+ *   attributes       [0] Attributes OPTIONAL,\n+ *   ...,\n+ *   [[2: publicKey  [1] PublicKey OPTIONAL ]],\n+ *   ...\n+ * }\n+ *\n+ * PrivateKeyInfo ::= OneAsymmetricKey\n@@ -41,1 +52,1 @@\n- * Version ::= INTEGER\n+ * Version ::= INTEGER { v1(0), v2(1) }\n@@ -47,0 +58,2 @@\n+ * PublicKey ::= BIT STRING\n+ *\n@@ -59,0 +72,3 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *     RFC 5958: Asymmetric Key Packages\n+ *\n@@ -62,1 +78,2 @@\n-public class PKCS8EncodedKeySpec extends EncodedKeySpec {\n+public non-sealed class PKCS8EncodedKeySpec extends EncodedKeySpec implements\n+    DEREncodable {\n@@ -66,0 +83,3 @@\n+     * This constructor extracts the algorithm name from the encoded bytes,\n+     * which may be an OID if no standard algorithm name is defined. If the\n+     * algorithm name cannot be extracted, it is set to null.\n@@ -74,0 +94,9 @@\n+        \/* Uncomment when JEP 513 integrates\n+        String algorithm = null;\n+        try {\n+            algorithm = KeyUtil.getAlgorithm(encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n+        super(encodedKey, algorithm);\n+         *\/\n@@ -104,1 +133,1 @@\n-     * Returns the key bytes, encoded according to the PKCS #8 standard.\n+     * Returns the private key bytes, encoded according to the PKCS #8 standard.\n@@ -106,1 +135,1 @@\n-     * @return the PKCS #8 encoding of the key. Returns a new array\n+     * @return the PKCS #8 encoding of the private key. Returns a new array\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import sun.security.util.KeyUtil;\n+\n+import java.io.IOException;\n+import java.security.DEREncodable;\n+\n@@ -52,1 +57,2 @@\n-public class X509EncodedKeySpec extends EncodedKeySpec {\n+public non-sealed class X509EncodedKeySpec extends EncodedKeySpec implements\n+    DEREncodable {\n@@ -56,0 +62,3 @@\n+     * This constructor extracts the algorithm name from the encoded bytes,\n+     * which may be an OID if no standard algorithm name is defined. If the\n+     * algorithm name cannot be extracted, it is set to null.\n@@ -64,0 +73,9 @@\n+        \/* Uncomment when JEP 513 integrates\n+        String algorithm = null;\n+        try {\n+            algorithm = KeyUtil.getAlgorithm(encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n+        super(encodedKey, algorithm);\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,9 @@\n-import java.io.*;\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.IOException;\n@@ -31,4 +39,1 @@\n-import sun.security.x509.AlgorithmId;\n-import sun.security.util.DerValue;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n+import java.util.Objects;\n@@ -58,1 +63,1 @@\n-public class EncryptedPrivateKeyInfo {\n+public non-sealed class EncryptedPrivateKeyInfo implements DEREncodable {\n@@ -65,1 +70,1 @@\n-    \/\/ In all other cases, algid is non null and params is null.\n+    \/\/ In all other cases, algid is non-null and params is null.\n@@ -76,2 +81,2 @@\n-     * Constructs (i.e., parses) an {@code EncryptedPrivateKeyInfo} from\n-     * its ASN.1 encoding.\n+     * Constructs an {@code EncryptedPrivateKeyInfo} from a given encrypted\n+     * PKCS#8 ASN.1 encoding.\n@@ -80,3 +85,2 @@\n-     * @exception NullPointerException if the {@code encoded} is\n-     * {@code null}.\n-     * @exception IOException if error occurs when parsing the ASN.1 encoding.\n+     * @throws NullPointerException if {@code encoded} is {@code null}.\n+     * @throws IOException if error occurs when parsing the ASN.1 encoding.\n@@ -85,4 +89,1 @@\n-        if (encoded == null) {\n-            throw new NullPointerException(\"the encoded parameter \" +\n-                \"must be non-null\");\n-        }\n+        Objects.requireNonNull(encoded);\n@@ -191,0 +192,1 @@\n+\n@@ -204,1 +206,1 @@\n-        \/\/ one and only one is non null\n+        \/\/ one and only one is non-null\n@@ -222,0 +224,11 @@\n+    \/**\n+     * Create an EncryptedPrivateKeyInfo object from the given components\n+     *\/\n+    private EncryptedPrivateKeyInfo(byte[] encoded, byte[] eData,\n+        AlgorithmId id, AlgorithmParameters p) {\n+        this.encoded = encoded;\n+        encryptedData = eData;\n+        algid = id;\n+        params = p;\n+    }\n+\n@@ -311,0 +324,285 @@\n+    \/**\n+     * Create and encrypt an {@code EncryptedPrivateKeyInfo} from a given\n+     * PrivateKey.  A valid password-based encryption (PBE) algorithm and\n+     * password must be specified.\n+     *\n+     * <p> The PBE algorithm string format details can be found in the\n+     * <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+     * Cipher section<\/a> of the Java Security Standard Algorithm Names\n+     * Specification.\n+     *\n+     * @param key the {@code PrivateKey} to encrypt.\n+     * @param password the password used during encryption.\n+     * @param algorithm the PBE encryption algorithm.  The default algorithm is\n+     *                  will be used if {@code null}.  However, {@code null} is\n+     *                  not allowed when {@code params} is non-null.\n+     * @param params the {@code AlgorithmParameterSpec} to be used with\n+     *               encryption.  The provider default will be used if\n+     *               {@code null}.\n+     * @param provider the {@code Provider} is used for PBE\n+     *                 {@link SecretKeyFactory} generation and {@link Cipher}\n+     *                 encryption operations. The default provider list will be\n+     *                 used if {@code null}.\n+     * @return {@code EncryptedPrivateKeyInfo}\n+     * @throws IllegalArgumentException on initialization errors based on the\n+     * arguments passed to the method. The cause may include\n+     * InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+     * or NoSuchPaddingException.\n+     * @throws RuntimeException on an encryption errors.  The cause may include\n+     * IllegalBlockSizeException, BadPaddingException, or InvalidKeyException.\n+     * @throws NullPointerException if the key or password are null. Also, if\n+     * {@code params} is non-null when {@code algorithm} is {@code null}.\n+     *\n+     * @implNote The encryption uses the algorithm set by\n+     * `jdk.epkcs8.defaultAlgorithm` Security Property\n+     *  and default the {@code AlgorithmParameterSpec} of that provider.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider) {\n+\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        SecretKey skey;\n+        Objects.requireNonNull(key);\n+        if (algorithm == null) {\n+            if (params != null) {\n+                throw new NullPointerException(\"algorithm must be specified\" +\n+                    \" if params is non-null.\");\n+            }\n+            algorithm = Pem.DEFAULT_ALGO;\n+        }\n+\n+        try {\n+            SecretKeyFactory factory;\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+            }\n+            skey = factory.generateSecret(keySpec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        return encryptKeyImpl(key, algorithm, skey, params, provider, null);\n+    }\n+\n+    \/**\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * {@code PrivateKey} and password.  Default algorithm and parameters are\n+     * used.\n+     *\n+     * @param key The {@code PrivateKey} to encrypt.\n+     * @param password the password used in the PBE encryption.  This array is\n+     *                 cloned before being used.\n+     * @return {@code EncryptedPrivateKeyInfo}\n+     * @throws IllegalArgumentException on initialization errors based on the\n+     * arguments passed to the method.  The cause may include\n+     * InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+     * or NoSuchPaddingException.\n+     * @throws RuntimeException on an encryption errors. The cause may include\n+     * IllegalBlockSizeException, BadPaddingException, or InvalidKeyException.\n+     * @throws NullPointerException when the key or password is null.\n+     *\n+     * @implNote The `jdk.epkcs8.defaultAlgorithm` Security Property defines\n+     * the default encryption algorithm and the {@code AlgorithmParameterSpec}\n+     * are the provider's algorithm defaults.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password) {\n+        if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n+            throw new RuntimeException(\"Security property \" +\n+                \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                \"valid algorithm.  Operation cannot be performed.\");\n+        }\n+        return encryptKey(key, password, Pem.DEFAULT_ALGO, null, null);\n+    }\n+\n+    \/**\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * {@link PrivateKey} using the {@code encKey} and given parameters.\n+     *\n+     * @param key The {@code PrivateKey} to encrypt.\n+     * @param encKey the password-based encryption (PBE) {@code Key} used to\n+     *              encrypt {@code key}.\n+     * @param algorithm the PBE encryption algorithm.  The default algorithm is\n+     *                 will be used if {@code null}.  However, {@code null} is\n+     *                 not allowed when {@code params} is non-null.\n+     * @param params the {@code AlgorithmParameterSpec} to be used with\n+     *               encryption. The provider list default will be used if\n+     *               {@code null}.\n+     * @param random the {@code SecureRandom} instance used during\n+     *               encryption.  The default will be used if {@code null}.\n+     * @param provider the {@code Provider} is used for {@link Cipher}\n+     *                encryption operation.  The default provider list will be\n+     *                used if {@code null}.\n+     * @return {@code EncryptedPrivateKeyInfo}\n+     * @throws IllegalArgumentException on initialization errors based on the\n+     * arguments passed to the method. The cause may include\n+     * InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+     * or NoSuchPaddingException.\n+     * @throws RuntimeException on an encryption errors.  The cause may include\n+     * IllegalBlockSizeException, BadPaddingException, or InvalidKeyException.\n+     * @throws NullPointerException if the key or password are null. Also, if\n+     * {@code params} is non-null when {@code algorithm} is {@code null}.\n+     *\n+     * @implNote The `jdk.epkcs8.defaultAlgorithm` Security Property defines\n+     * the default encryption algorithm and the {@code AlgorithmParameterSpec}\n+     * are the provider's algorithm defaults.\n+\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key, Key encKey,\n+        String algorithm, AlgorithmParameterSpec params, Provider provider,\n+        SecureRandom random) {\n+        if (algorithm == null) {\n+            if (params != null) {\n+                throw new NullPointerException(\"algorithm must be specified \" +\n+                    \"if params is non-null.\");\n+            }\n+\n+            if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n+                throw new RuntimeException(\"Security property \" +\n+                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                    \"valid algorithm.  Operation cannot be performed.\");\n+            }\n+            algorithm = Pem.DEFAULT_ALGO;\n+        }\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(encKey);\n+        return encryptKeyImpl(key, algorithm, encKey, params, provider, random);\n+    }\n+\n+\n+    private static EncryptedPrivateKeyInfo encryptKeyImpl(PrivateKey key,\n+        String algorithm, Key encryptKey, AlgorithmParameterSpec params,\n+        Provider provider, SecureRandom random) {\n+        AlgorithmId algId;\n+        byte[] encryptedData;\n+        Cipher c;\n+        DerOutputStream out;\n+\n+        if (random == null) {\n+            random = JCAUtil.getDefSecureRandom();\n+        }\n+        try {\n+            if (provider == null) {\n+                c = Cipher.getInstance(algorithm);\n+            } else {\n+                c = Cipher.getInstance(algorithm, provider);\n+            }\n+            c.init(Cipher.ENCRYPT_MODE, encryptKey, params, random);\n+            encryptedData = c.doFinal(key.getEncoded());\n+            algId = new AlgorithmId(Pem.getPBEID(algorithm), c.getParameters());\n+            out = new DerOutputStream();\n+            algId.encode(out);\n+            out.putOctetString(encryptedData);\n+        } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException |\n+                 NoSuchPaddingException e) {\n+            throw new IllegalArgumentException(e);\n+        } catch (IllegalBlockSizeException | BadPaddingException |\n+                 InvalidKeyException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return new EncryptedPrivateKeyInfo(\n+            DerValue.wrap(DerValue.tag_Sequence, out).toByteArray(),\n+            encryptedData, algId, c.getParameters());\n+    }\n+\n+    \/**\n+     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n+     *\n+     * @param password this array is cloned and used for PBE decryption.\n+     *                 {@code null} may be used.\n+     * @return {@code PrivateKey}\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password) throws InvalidKeyException {\n+        return getKey(password, null);\n+    }\n+\n+    \/**\n+     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n+     * using the given provider.\n+     *\n+     * @param password this array is cloned and used for PBE decryption.\n+     *                 {@code null} may be used.\n+     * @param provider this {@code Provider} is used for all key generations.\n+     *                 It is used when generating the PBE encryption key,\n+     *                 {@code SecretKeyFactory}, and the {@code PrivateKey},\n+     *                 {@code KeyFactory}.  A {@code null} value will use the default\n+     *                 provider configuration.\n+     * @return {@code PrivateKey}\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password, Provider provider)\n+        throws InvalidKeyException {\n+        return getKeyImpl(new PBEKeySpec(password), provider);\n+    }\n+\n+    private PrivateKey getKeyImpl(PBEKeySpec keySpec, Provider provider)\n+        throws InvalidKeyException {\n+        SecretKeyFactory skf;\n+        PKCS8EncodedKeySpec p8KeySpec;\n+        try {\n+            if (provider == null) {\n+                skf = SecretKeyFactory.getInstance(getAlgName());\n+                p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n+            } else {\n+                skf = SecretKeyFactory.getInstance(getAlgName(), provider);\n+                p8KeySpec = getKeySpec(skf.generateSecret(keySpec), provider);\n+            }\n+\n+            return PKCS8Key.parseKey(p8KeySpec.getEncoded(), provider);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new RuntimeException(e);\n+        } catch (InvalidKeySpecException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n+     * using the given provider.\n+     *\n+     * @param decryptKey this is the decryption key and cannot be {@code null}.\n+     * @param provider the {@code Provider} is used for Cipher decryption and\n+     *                 {@code PrivateKey} generation. A {@code null} value will\n+     *                 use the default provider configuration.\n+     * @return {@code PrivateKey}\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     * @throws NullPointerException if {@code decryptKey} is null.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(Key decryptKey, Provider provider)\n+        throws InvalidKeyException {\n+        try {\n+            PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n+            if (provider == null) {\n+                return KeyFactory.getInstance(p.getAlgorithm())\n+                    .generatePrivate(p);\n+            }\n+            return KeyFactory.getInstance(p.getAlgorithm(),\n+                provider).generatePrivate(p);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":316,"deletions":18,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+        @JEP(number=470, title=\"PEM Encodings of Cryptographic Objects\", status=\"Preview\")\n+        PEM_API,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.security.pkcs.PKCS8Key;\n+\n@@ -87,2 +89,1 @@\n-        if (key instanceof ECKey) {\n-            ECKey ecKey = (ECKey)key;\n+        if (key instanceof ECKey ecKey) {\n@@ -150,1 +151,1 @@\n-            throws InvalidKeySpecException {\n+        throws InvalidKeySpecException {\n@@ -162,1 +163,1 @@\n-            throws InvalidKeySpecException {\n+        throws InvalidKeySpecException {\n@@ -174,10 +175,5 @@\n-            throws InvalidKeyException {\n-        if (key instanceof ECPublicKey) {\n-            if (key instanceof ECPublicKeyImpl) {\n-                return key;\n-            }\n-            ECPublicKey ecKey = (ECPublicKey)key;\n-            return new ECPublicKeyImpl(\n-                ecKey.getW(),\n-                ecKey.getParams()\n-            );\n+        throws InvalidKeyException {\n+        if (key instanceof ECPublicKeyImpl) {\n+            return key;\n+        } else if (key instanceof ECPublicKey ecKey) {\n+            return new ECPublicKeyImpl(ecKey.getW(), ecKey.getParams());\n@@ -185,2 +181,1 @@\n-            byte[] encoded = key.getEncoded();\n-            return new ECPublicKeyImpl(encoded);\n+            return new ECPublicKeyImpl(key.getEncoded());\n@@ -195,10 +190,5 @@\n-            throws InvalidKeyException {\n-        if (key instanceof ECPrivateKey) {\n-            if (key instanceof ECPrivateKeyImpl) {\n-                return key;\n-            }\n-            ECPrivateKey ecKey = (ECPrivateKey)key;\n-            return new ECPrivateKeyImpl(\n-                ecKey.getS(),\n-                ecKey.getParams()\n-            );\n+        throws InvalidKeyException {\n+        if (key instanceof ECPrivateKeyImpl) {\n+            return key;\n+        } else if (key instanceof ECPrivateKey ecKey) {\n+            return new ECPrivateKeyImpl(ecKey.getS(), ecKey.getParams());\n@@ -212,3 +202,0 @@\n-        } else {\n-            throw new InvalidKeyException(\"Private keys must be instance \"\n-                + \"of ECPrivateKey or have PKCS#8 encoding\");\n@@ -216,0 +203,3 @@\n+\n+        throw new InvalidKeyException(\"Private keys must be instance \"\n+            + \"of ECPrivateKey or have PKCS#8 encoding\");\n@@ -220,14 +210,16 @@\n-            throws GeneralSecurityException {\n-        if (keySpec instanceof X509EncodedKeySpec) {\n-            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n-            return new ECPublicKeyImpl(x509Spec.getEncoded());\n-        } else if (keySpec instanceof ECPublicKeySpec) {\n-            ECPublicKeySpec ecSpec = (ECPublicKeySpec)keySpec;\n-            return new ECPublicKeyImpl(\n-                ecSpec.getW(),\n-                ecSpec.getParams()\n-            );\n-        } else {\n-            throw new InvalidKeySpecException(\"Only ECPublicKeySpec \"\n-                + \"and X509EncodedKeySpec supported for EC public keys\");\n-        }\n+        throws GeneralSecurityException {\n+        return switch (keySpec) {\n+            case X509EncodedKeySpec x -> new ECPublicKeyImpl(x.getEncoded());\n+            case ECPublicKeySpec e ->\n+                new ECPublicKeyImpl(e.getW(), e.getParams());\n+            case PKCS8EncodedKeySpec p8 -> {\n+                PKCS8Key p8key = new ECPrivateKeyImpl(p8.getEncoded());\n+                if (!p8key.hasPublicKey()) {\n+                    throw new InvalidKeySpecException(\"No public key found.\");\n+                }\n+                yield new ECPublicKeyImpl(p8key.getPubKeyEncoded());\n+            }\n+            default ->\n+                throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                    \" not supported.\");\n+        };\n@@ -238,8 +230,9 @@\n-            throws GeneralSecurityException {\n-        if (keySpec instanceof PKCS8EncodedKeySpec) {\n-            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;\n-            byte[] encoded = pkcsSpec.getEncoded();\n-            try {\n-                return new ECPrivateKeyImpl(encoded);\n-            } finally {\n-                Arrays.fill(encoded, (byte) 0);\n+        throws GeneralSecurityException {\n+        return switch (keySpec) {\n+            case PKCS8EncodedKeySpec p8 -> {\n+                byte[] encoded = p8.getEncoded();\n+                try {\n+                    yield new ECPrivateKeyImpl(encoded);\n+                } finally {\n+                    Arrays.fill(encoded, (byte) 0);\n+                }\n@@ -247,7 +240,6 @@\n-        } else if (keySpec instanceof ECPrivateKeySpec) {\n-            ECPrivateKeySpec ecSpec = (ECPrivateKeySpec)keySpec;\n-            return new ECPrivateKeyImpl(ecSpec.getS(), ecSpec.getParams());\n-        } else {\n-            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \"\n-                + \"and PKCS8EncodedKeySpec supported for EC private keys\");\n-        }\n+            case ECPrivateKeySpec e ->\n+                new ECPrivateKeyImpl(e.getS(), e.getParams());\n+            default ->\n+                throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                    \" not supported.\");\n+        };\n@@ -257,1 +249,1 @@\n-            throws InvalidKeySpecException {\n+        throws InvalidKeySpecException {\n@@ -266,2 +258,1 @@\n-        if (key instanceof ECPublicKey) {\n-            ECPublicKey ecKey = (ECPublicKey)key;\n+        if (key instanceof ECPublicKey ecKey) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":53,"deletions":62,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import sun.security.x509.X509Key;\n@@ -76,0 +77,1 @@\n+    private byte[] domainParams;  \/\/Currently unsupported\n@@ -114,1 +116,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -136,1 +138,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -156,1 +158,1 @@\n-    private byte[] getArrayS0() {\n+    public byte[] getArrayS() {\n@@ -160,5 +162,1 @@\n-        return arrayS;\n-    }\n-\n-    public byte[] getArrayS() {\n-        return getArrayS0().clone();\n+        return arrayS.clone();\n@@ -172,0 +170,3 @@\n+    \/**\n+     * Parse the ASN.1 of the privateKey Octet\n+     *\/\n@@ -173,0 +174,1 @@\n+        \/\/ Parse private key material from PKCS8Key.decode()\n@@ -174,1 +176,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n@@ -181,1 +183,1 @@\n-            if (version != 1) {\n+            if (version != V2) {\n@@ -187,10 +189,2 @@\n-            while (data.available() != 0) {\n-                DerValue value = data.getDerValue();\n-                if (value.isContextSpecific((byte) 0)) {\n-                    \/\/ ignore for now\n-                } else if (value.isContextSpecific((byte) 1)) {\n-                    \/\/ ignore for now\n-                } else {\n-                    throw new InvalidKeyException(\"Unexpected value: \" + value);\n-                }\n-            }\n+\n+            \/\/ Validate parameters stored from PKCS8Key.decode()\n@@ -203,0 +197,22 @@\n+\n+            if (data.available() == 0) {\n+                return;\n+            }\n+\n+            DerValue value = data.getDerValue();\n+            if (value.isContextSpecific((byte) 0)) {\n+                domainParams = value.getDataBytes();  \/\/ Save DER sequence\n+                if (data.available() == 0) {\n+                    return;\n+                }\n+                value = data.getDerValue();\n+            }\n+\n+            if (value.isContextSpecific((byte) 1)) {\n+                DerValue bits = value.withTag(DerValue.tag_BitString);\n+                pubKeyEncoded = new X509Key(algid,\n+                    bits.data.getUnalignedBitString()).getEncoded();\n+            } else {\n+                throw new InvalidKeyException(\"Unexpected value: \" + value);\n+            }\n+\n@@ -208,1 +224,0 @@\n-    @Override\n@@ -213,1 +228,1 @@\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS0());\n+        MutablePoint pub = ops.multiply(ecParams.getGenerator(), arrayS);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":38,"deletions":23,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,3 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.security.*;\n@@ -163,0 +160,10 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new XDHPrivateKeyImpl(p8.getEncoded());\n+            if (!p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            XDHPublicKeyImpl result =\n+                new XDHPublicKeyImpl(p8key.getPubKeyEncoded());\n+            checkLockedParams(InvalidKeySpecException::new,\n+                result.getParams());\n+            return result;\n@@ -164,2 +171,2 @@\n-            throw new InvalidKeySpecException(\n-                \"Only X509EncodedKeySpec and XECPublicKeySpec are supported\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            this.key = val.toByteArray();\n+            this.privKeyMaterial = val.toByteArray();\n@@ -70,1 +70,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -105,1 +105,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,3 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.security.*;\n@@ -156,0 +153,6 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new EdDSAPrivateKeyImpl(p8.getEncoded());\n+            if (!p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            return new EdDSAPublicKeyImpl(p8key.getPubKeyEncoded());\n@@ -157,2 +160,2 @@\n-            throw new InvalidKeySpecException(\n-                \"Only X509EncodedKeySpec and EdECPublicKeySpec are supported\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-            this.key = val.toByteArray();\n+            privKeyMaterial = val.toByteArray();\n@@ -74,1 +74,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -84,2 +84,2 @@\n-        if (params.getKeyLength() != this.h.length) {\n-            throw new InvalidKeyException(\"key length is \" + this.h.length +\n+        if (params.getKeyLength() != h.length) {\n+            throw new InvalidKeyException(\"key length is \" + h.length +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-            this.key = val.toByteArray();\n+            this.privKeyMaterial = val.toByteArray();\n@@ -93,1 +93,1 @@\n-            rawBytes = new DerInputStream(key).getOctetString();\n+            rawBytes = new DerInputStream(privKeyMaterial).getOctetString();\n@@ -132,1 +132,1 @@\n-        Arrays.fill(key, (byte)0);\n+        Arrays.fill(privKeyMaterial, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,8 @@\n-import java.io.*;\n-import java.security.Key;\n-import java.security.KeyRep;\n-import java.security.PrivateKey;\n-import java.security.KeyFactory;\n-import java.security.MessageDigest;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.security.*;\n@@ -40,4 +40,0 @@\n-import jdk.internal.access.SharedSecrets;\n-import sun.security.x509.*;\n-import sun.security.util.*;\n-\n@@ -59,1 +55,1 @@\n- * We support this format but do not parse attributes and publicKey now.\n+ * We support this format but do not parse attributes.\n@@ -70,2 +66,2 @@\n-    \/* The key bytes, without the algorithm information *\/\n-    protected byte[] key;\n+    \/* The private key OctetString for the algorithm subclasses to decode *\/\n+    protected byte[] privKeyMaterial;\n@@ -73,1 +69,1 @@\n-    \/* The encoded for the key. Created on demand by encode(). *\/\n+    \/* The pkcs8 encoding of this key(s). Created on demand. *\/\n@@ -76,0 +72,9 @@\n+    \/* The encoded x509 public key for v2 *\/\n+    protected byte[] pubKeyEncoded = null;\n+\n+    \/* ASN.1 Attributes *\/\n+    private byte[] attributes;\n+\n+    \/* PKCS8 version of the PEM *\/\n+    private int version;\n+\n@@ -77,2 +82,2 @@\n-    private static final int V1 = 0;\n-    private static final int V2 = 1;\n+    public static final int V1 = 0;\n+    public static final int V2 = 1;\n@@ -83,1 +88,1 @@\n-     * {@link #algid} and {@link #key}.\n+     * {@link #algid} and {@link #privKeyMaterial}.\n@@ -94,1 +99,1 @@\n-    protected PKCS8Key(byte[] input) throws InvalidKeyException {\n+    public PKCS8Key(byte[] input) throws InvalidKeyException {\n@@ -102,0 +107,16 @@\n+    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+        throws InvalidKeyException {\n+        this(privEncoding);\n+        pubKeyEncoded = pubEncoding;\n+        version = V2;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    \/**\n+     * Method for decoding PKCS8 v1 and v2 formats. Decoded values are stored\n+     * in this class, key material remains in DER format for algorithm\n+     * subclasses to decode.\n+     *\/\n@@ -108,1 +129,2 @@\n-            int version = val.data.getInteger();\n+            \/\/ Support check for V1, aka 0, and V2, aka 1.\n+            version = val.data.getInteger();\n@@ -112,2 +134,5 @@\n-            algid = AlgorithmId.parse (val.data.getDerValue ());\n-            key = val.data.getOctetString();\n+            \/\/ Parse and store AlgorithmID\n+            algid = AlgorithmId.parse(val.data.getDerValue());\n+\n+            \/\/ Store key material for subclasses to parse\n+            privKeyMaterial = val.data.getOctetString();\n@@ -115,1 +140,1 @@\n-            DerValue next;\n+            \/\/ PKCS8 v1 typically ends here\n@@ -119,2 +144,7 @@\n-            next = val.data.getDerValue();\n-            if (next.isContextSpecific((byte)0)) {\n+\n+            \/\/ OPTIONAL Context tag 0 for Attributes for PKCS8 v1 & v2\n+            \/\/ Uses 0xA0 context-specific\/constructed or 0x80\n+            \/\/ context-specific\/primitive.\n+            DerValue v = val.data.getDerValue();\n+            if (v.isContextSpecific((byte)0)) {\n+                attributes = v.getDataBytes();  \/\/ Save DER sequence\n@@ -124,1 +154,1 @@\n-                next = val.data.getDerValue();\n+                v = val.data.getDerValue();\n@@ -127,3 +157,8 @@\n-            if (next.isContextSpecific((byte)1)) {\n-                if (version == V1) {\n-                    throw new InvalidKeyException(\"publicKey seen in v1\");\n+            \/\/ OPTIONAL context tag 1 for Public Key for PKCS8 v2 only\n+            if (version == V2) {\n+                if (v.isContextSpecific((byte)1)) {\n+                    DerValue bits = v.withTag(DerValue.tag_BitString);\n+                    pubKeyEncoded = new X509Key(algid,\n+                        bits.getUnalignedBitString()).getEncoded();\n+                } else {\n+                    throw new InvalidKeyException(\"Invalid context tag\");\n@@ -135,0 +170,1 @@\n+\n@@ -157,1 +193,1 @@\n-     * @exception IOException on data format errors\n+     * @exception InvalidKeyException on data format errors\n@@ -159,1 +195,7 @@\n-    public static PrivateKey parseKey(byte[] encoded) throws IOException {\n+    public static PrivateKey parseKey(byte[] encoded)\n+        throws InvalidKeyException {\n+        return parseKey(encoded, null);\n+    }\n+\n+    public static PrivateKey parseKey(byte[] encoded, Provider provider)\n+        throws InvalidKeyException {\n@@ -162,2 +204,3 @@\n-            byte[] internal = rawKey.getEncodedInternal();\n-            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(internal);\n+\n+            PKCS8EncodedKeySpec pkcs8KeySpec =\n+                new PKCS8EncodedKeySpec(rawKey.generateEncoding());\n@@ -166,1 +209,2 @@\n-                result = KeyFactory.getInstance(rawKey.algid.getName())\n+                if (provider == null) {\n+                    result = KeyFactory.getInstance(rawKey.algid.getName())\n@@ -168,0 +212,4 @@\n+                } else {\n+                    result = KeyFactory.getInstance(rawKey.algid.getName(),\n+                        provider).generatePrivate(pkcs8KeySpec);\n+                }\n@@ -179,2 +227,2 @@\n-        } catch (InvalidKeyException e) {\n-            throw new IOException(\"corrupt private key\", e);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(e);\n@@ -191,0 +239,8 @@\n+    public byte[] getPubKeyEncoded() {\n+        return pubKeyEncoded;\n+    }\n+\n+    public boolean hasPublicKey() {\n+        return (pubKeyEncoded != null);\n+    }\n+\n@@ -194,1 +250,1 @@\n-    public AlgorithmId  getAlgorithmId () {\n+    public AlgorithmId getAlgorithmId () {\n@@ -213,0 +269,19 @@\n+    \/**\n+     * With a given encoded Public and Private key, generate and return a\n+     * PKCS8v2 DER-encoded byte[].\n+     *\n+     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param privKeyEncoded DER-encoded PrivateKey\n+     * @return DER-encoded byte array\n+     * @throws IOException thrown on encoding failure\n+     *\/\n+    public static byte[] getEncoded(byte[] pubKeyEncoded, byte[] privKeyEncoded)\n+        throws IOException {\n+        try {\n+            return new PKCS8Key(privKeyEncoded, pubKeyEncoded).\n+                generateEncoding();\n+        } catch (InvalidKeyException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n@@ -221,7 +296,5 @@\n-            DerOutputStream tmp = new DerOutputStream();\n-            tmp.putInteger(V1);\n-            algid.encode(tmp);\n-            tmp.putOctetString(key);\n-            DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-            encodedKey = out.toByteArray();\n-            out.clear();\n+            try {\n+                encodedKey = generateEncoding();\n+            } catch (IOException e) {\n+               return null;\n+            }\n@@ -232,0 +305,38 @@\n+    private byte[] generateEncoding() throws IOException {\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(version);\n+        algid.encode(out);\n+        out.putOctetString(privKeyMaterial);\n+\n+        if (version == V2) {\n+            if (attributes != null) {\n+                out.writeImplicit(\n+                    DerValue.createTag((byte) (DerValue.TAG_CONTEXT |\n+                        DerValue.TAG_CONSTRUCT), false, (byte) 0),\n+                    new DerOutputStream().putOctetString(attributes));\n+\n+            }\n+\n+            if (pubKeyEncoded != null) {\n+                X509Key x = new X509Key();\n+                try {\n+                    x.decode(pubKeyEncoded);\n+                } catch (InvalidKeyException e) {\n+                    throw new IOException(e);\n+                }\n+\n+                \/\/ X509Key x = X509Key.parse(pubKeyEncoded);\n+                DerOutputStream pubOut = new DerOutputStream();\n+                pubOut.putUnalignedBitString(x.getKey());\n+                out.writeImplicit(\n+                    DerValue.createTag(DerValue.TAG_CONTEXT, false,\n+                        (byte) 1), pubOut);\n+            }\n+        }\n+\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        encodedKey = val.toByteArray();\n+        val.clear();\n+        return encodedKey;\n+    }\n+\n@@ -301,1 +412,1 @@\n-        Arrays.fill(key, (byte)0);\n+        Arrays.fill(privKeyMaterial, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":158,"deletions":47,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -84,1 +84,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPrivateKey.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -303,2 +302,2 @@\n-        } catch (IOException ioe) {\n-            throw new UnrecoverableKeyException(ioe.getMessage());\n+        } catch (InvalidKeyException e) {\n+            throw new UnrecoverableKeyException(e.getMessage());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.security.PEMRecord;\n@@ -39,0 +40,1 @@\n+import sun.security.util.Pem;\n@@ -559,65 +561,6 @@\n-            \/\/ Read BASE64 encoded data, might skip info at the beginning\n-            ByteArrayOutputStream data = new ByteArrayOutputStream();\n-\n-            \/\/ Step 1: Read until header is found\n-            int hyphen = (c=='-') ? 1: 0;   \/\/ count of consequent hyphens\n-            int last = (c=='-') ? -1: c;    \/\/ the char before hyphen\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    \/\/ We accept useless data after the last block,\n-                    \/\/ say, empty lines.\n-                    return null;\n-                }\n-                if (next == '-') {\n-                    hyphen++;\n-                } else {\n-                    hyphen = 0;\n-                    last = next;\n-                }\n-                if (hyphen == 5 && (last == -1 || last == '\\r' || last == '\\n')) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 2: Read the rest of header, determine the line end\n-            int end;\n-            StringBuilder header = new StringBuilder(\"-----\");\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next == '\\n') {\n-                    end = '\\n';\n-                    break;\n-                }\n-                if (next == '\\r') {\n-                    next = is.read();\n-                    if (next == -1) {\n-                        throw new IOException(\"Incomplete data\");\n-                    }\n-                    if (next == '\\n') {\n-                        end = '\\n';\n-                    } else {\n-                        end = '\\r';\n-                        \/\/ Skip all white space chars\n-                        if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                            data.write(next);\n-                        }\n-                    }\n-                    break;\n-                }\n-                header.append((char)next);\n-            }\n-\n-            \/\/ Step 3: Read the data\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next != '-') {\n-                    \/\/ Skip all white space chars\n-                    if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                        data.write(next);\n+            try {\n+                PEMRecord rec;\n+                try {\n+                    rec = Pem.readPEM(is, (c == '-' ? true : false));\n+                    if (rec.pem() == null) {\n+                        return null;\n@@ -625,13 +568,2 @@\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 4: Consume the footer\n-            StringBuilder footer = new StringBuilder(\"-\");\n-            while (true) {\n-                int next = is.read();\n-                \/\/ Add next == '\\n' for maximum safety, in case endline\n-                \/\/ is not consistent.\n-                if (next == -1 || next == end || next == '\\n') {\n-                    break;\n+                } catch (EOFException e) {\n+                    return null;\n@@ -639,8 +571,1 @@\n-                if (next != '\\r') footer.append((char)next);\n-            }\n-\n-            checkHeaderFooter(header.toString().stripTrailing(),\n-                    footer.toString().stripTrailing());\n-\n-            try {\n-                return Base64.getDecoder().decode(data.toByteArray());\n+                return Base64.getDecoder().decode(rec.pem());\n@@ -653,18 +578,0 @@\n-    private static void checkHeaderFooter(String header,\n-            String footer) throws IOException {\n-        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n-                !header.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal header: \" + header);\n-        }\n-        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n-                !footer.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal footer: \" + footer);\n-        }\n-        String headerType = header.substring(11, header.length()-5);\n-        String footerType = footer.substring(9, footer.length()-5);\n-        if (!headerType.equals(footerType)) {\n-            throw new IOException(\"Header and footer do not match: \" +\n-                    header + \" \" + footer);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":12,"deletions":105,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -335,0 +336,7 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new PKCS8Key(p8.getEncoded());\n+            if (!p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            return RSAPublicKeyImpl.newKey(type, \"X.509\",\n+                p8key.getPubKeyEncoded());\n@@ -336,2 +344,1 @@\n-            throw new InvalidKeySpecException(\"Only RSAPublicKeySpec \"\n-                + \"and X509EncodedKeySpec supported for RSA public keys\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() + \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+    \/\/ RSA or RSA-PSS KeyType\n@@ -104,1 +105,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -240,1 +241,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -307,1 +308,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -340,1 +341,1 @@\n-            BigInteger[] comps = parseASN1(key);\n+            BigInteger[] comps = parsePKCS1(privKeyMaterial);\n@@ -354,0 +355,24 @@\n+    \/**\n+     * With a given PKCS#1\/slleay\/OpenSSL old default RSA binary encoding,\n+     * decode and return the proper RSA encoded KeySpec\n+     * @param encoded RSA binary encoding\n+     * @return KeySpec\n+     * @throws InvalidKeyException on decoding failure\n+     *\/\n+    public static KeySpec getKeySpec(byte[] encoded) throws\n+        InvalidKeyException {\n+        try {\n+            BigInteger[] comps = parsePKCS1(encoded);\n+            if ((comps[1].signum() == 0) || (comps[3].signum() == 0) ||\n+                (comps[4].signum() == 0) || (comps[5].signum() == 0) ||\n+                (comps[6].signum() == 0) || (comps[7].signum() == 0)) {\n+                return new RSAPrivateKeySpec(comps[0], comps[2]);\n+            } else {\n+                return new RSAPrivateCrtKeySpec(comps[0],\n+                    comps[1], comps[2], comps[3], comps[4], comps[5],\n+                    comps[6], comps[7]);\n+            }\n+        } catch (IOException ioe) {\n+            throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -202,1 +202,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -221,1 +221,1 @@\n-            BigInteger[] comps = parseASN1(getKey().toByteArray());\n+            BigInteger[] comps = parsePKCS1(getKey().toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+    public static final byte TAG_CONSTRUCT = (byte)0x020;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -460,0 +461,50 @@\n+\n+    \/**\n+     * With a given DER encoded bytes, read through and return the AlgorithmID\n+     * stored if it can be found.\n+     *\n+     * @param encoded DER encoded bytes\n+     * @return AlgorithmID stored in the DER encoded bytes\n+     * @throws IOException\n+     *\/\n+    public static AlgorithmId getAlgorithm(byte[] encoded) throws IOException {\n+        DerInputStream is = new DerInputStream(encoded);\n+        DerValue value = is.getDerValue();\n+        if (value.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Unknown DER Format:  Value 1 not a Sequence\");\n+        }\n+\n+        is = value.data;\n+        value = is.getDerValue();\n+        \/\/ This route is for:  RSAPublic, Encrypted RSAPrivate, EC Public,\n+        \/\/ Encrypted EC Private,\n+        if (value.tag == DerValue.tag_Sequence) {\n+            return AlgorithmId.parse(value);\n+        } else if (value.tag == DerValue.tag_Integer) {\n+            \/\/ RSAPrivate, ECPrivate\n+            \/\/ current value is version, which can be ignored\n+            value = is.getDerValue();\n+            if (value.tag == DerValue.tag_OctetString) {\n+                value = is.getDerValue();\n+                if (value.tag == DerValue.tag_Sequence) {\n+                    return AlgorithmId.parse(value);\n+                } else {\n+                    \/\/ OpenSSL\/X9.62 (0xA0)\n+                    ObjectIdentifier oid = value.data.getOID();\n+                    AlgorithmId algo = new AlgorithmId(oid, (AlgorithmParameters) null);\n+                    if (CurveDB.lookup(algo.getName()) != null) {\n+                        return new AlgorithmId(AlgorithmId.EC_oid);\n+                    }\n+\n+                }\n+\n+            } else if (value.tag == DerValue.tag_Sequence) {\n+                \/\/ Public Key\n+                return AlgorithmId.parse(value);\n+            }\n+\n+        }\n+        throw new IOException(\"No algorithm detected\");\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import java.io.IOException;\n+import sun.security.x509.AlgorithmId;\n+\n+import java.io.*;\n@@ -30,0 +32,4 @@\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PEMRecord;\n+import java.security.Security;\n+import java.util.Arrays;\n@@ -31,0 +37,3 @@\n+import java.util.HexFormat;\n+import java.util.Objects;\n+import java.util.regex.Pattern;\n@@ -36,0 +45,28 @@\n+    private static final char WS = 0x20;  \/\/ Whitespace\n+\n+    \/\/ Default algorithm from jdk.epkcs8.defaultAlgorithm in java.security\n+    public static final String DEFAULT_ALGO;\n+\n+    \/\/ Pattern matching for EKPI operations\n+    private static final Pattern pbePattern;\n+\n+    \/\/ Lazy initialized PBES2 OID value\n+    private static ObjectIdentifier PBES2OID;\n+\n+    \/\/ Lazy initialized singleton encoder.\n+    private static Base64.Encoder b64Encoder;\n+\n+    static {\n+        DEFAULT_ALGO = Security.getProperty(\"jdk.epkcs8.defaultAlgorithm\");\n+        pbePattern = Pattern.compile(\"^PBEWith.*And.*\");\n+    }\n+\n+    public static final String CERTIFICATE = \"CERTIFICATE\";\n+    public static final String X509_CERTIFICATE = \"X509 CERTIFICATE\";\n+    public static final String X_509_CERTIFICATE = \"X.509 CERTIFICATE\";\n+    public static final String X509_CRL = \"X509 CRL\";\n+    public static final String CRL = \"CRL\";\n+    public static final String PUBLIC_KEY = \"PUBLIC KEY\";\n+    public static final String RSA_PRIVATE_KEY = \"RSA PRIVATE KEY\";\n+    public static final String ENCRYPTED_PRIVATE_KEY = \"ENCRYPTED PRIVATE KEY\";\n+    public static final String PRIVATE_KEY = \"PRIVATE KEY\";\n@@ -43,1 +80,0 @@\n-     * @throws java.io.IOException if input is invalid\n@@ -45,4 +81,3 @@\n-    public static byte[] decode(String input) throws IOException {\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\")\n-                .getBytes(StandardCharsets.ISO_8859_1);\n-        try {\n+    public static byte[] decode(String input) {\n+        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+            getBytes(StandardCharsets.ISO_8859_1);\n@@ -50,2 +85,33 @@\n-        } catch (IllegalArgumentException e) {\n-            throw new IOException(e);\n+    }\n+\n+    \/**\n+     * Return the OID for a given PBE algorithm.  PBES1 has an OID for each\n+     * algorithm, while PBES2 has one OID for everything that complies with\n+     * the formatting.  Therefore, if the algorithm is not PBES1, it will\n+     * return PBES2.  Cipher will determine if this is a valid PBE algorithm.\n+     * PBES2 specifies AES as the cipher algorithm, but any block cipher could\n+     * be supported.\n+     *\/\n+    public static ObjectIdentifier getPBEID(String algorithm) {\n+\n+        \/\/ Verify pattern matches PBE Standard Name spec\n+        if (!pbePattern.matcher(algorithm).matches()) {\n+            throw new IllegalArgumentException(\"Invalid algorithm format.\");\n+        }\n+\n+        \/\/ Return the PBES1 OID if it matches\n+        try {\n+            return AlgorithmId.get(algorithm).getOID();\n+        } catch (NoSuchAlgorithmException e) {\n+            \/\/ fall-through\n+        }\n+\n+        \/\/ Lazy initialize\n+        if (PBES2OID == null) {\n+            try {\n+                \/\/ Set to the hardcoded OID in KnownOID.java\n+                PBES2OID = AlgorithmId.get(\"PBES2\").getOID();\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ Should never fail.\n+                throw new IllegalArgumentException(e);\n+            }\n@@ -53,0 +119,14 @@\n+        return PBES2OID;\n+    }\n+\n+    \/*\n+     * RFC 7468 has some rules what generators should return given a historical\n+     * type name.  This converts read in PEM to the RFC.  Change the type to\n+     * be uniform is likely to help apps from not using all 3 certificate names.\n+     *\/\n+    private static String typeConverter(String type) {\n+        return switch (type) {\n+            case Pem.X509_CERTIFICATE, Pem.X_509_CERTIFICATE -> Pem.CERTIFICATE;\n+            case Pem.CRL -> Pem.X509_CRL;\n+            default -> type;\n+        };\n@@ -54,0 +134,195 @@\n+\n+    \/**\n+     * Read the PEM text and return it in it's three components:  header,\n+     * base64, and footer.\n+     *\n+     * The method will leave the stream after reading the end of line of the\n+     * footer or end of file\n+     * @param is The pem data\n+     * @param shortHeader if true, the hyphen length is 4 because the first\n+     *                    hyphen is assumed to have been read.  This is needed\n+     *                    for the CertificateFactory X509 implementation.\n+     * @return A new Pem object containing the three components\n+     * @throws IOException on read errors\n+     * @throws EOFException when there is nothing to read\n+     *\/\n+    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+\n+        int hyphen = (shortHeader ? 1 : 0);\n+        int eol = 0;\n+\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(6);\n+        \/\/ Find starting hyphens\n+        do {\n+            int d = is.read();\n+            switch (d) {\n+                case '-' -> hyphen++;\n+                case -1 -> {\n+                    if (os.size() == 0) {\n+                        throw new EOFException(\"No data available\");\n+                    }\n+                    throw new IllegalArgumentException(\"No PEM data found\");\n+                }\n+                default -> hyphen = 0;\n+            }\n+            os.write(d);\n+        } while (hyphen != 5);\n+\n+        StringBuilder sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+        hyphen = 0;\n+        int c;\n+\n+        \/\/ Get header definition until first hyphen\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n+                case '\\n', '\\r' -> throw new IOException(\"Incomplete header\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify header ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                default ->\n+                    throw new IOException(\"Incomplete header\");\n+            }\n+        } while (hyphen < 5);\n+\n+        sb.append(\"-----\");\n+        String header = sb.toString();\n+        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n+            !header.endsWith(\"-----\")) {\n+            throw new IOException(\"Illegal header: \" + header);\n+        }\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(1024);\n+\n+        \/\/ Determine the line break using the char after the last hyphen\n+        switch (is.read()) {\n+            case WS -> {} \/\/ skip whitespace\n+            case '\\r' -> {\n+                c = is.read();\n+                if (c == '\\n') {\n+                    eol = '\\n';\n+                } else {\n+                    eol = '\\r';\n+                    sb.append((char) c);\n+                }\n+            }\n+            case '\\n' -> eol = '\\n';\n+            default ->\n+                throw new IOException(\"No EOL character found\");\n+        }\n+\n+        \/\/ Read data until we find the first footer hyphen.\n+        do {\n+            switch (c = is.read()) {\n+                case -1 ->\n+                    throw new EOFException(\"Incomplete header\");\n+                case '-' -> hyphen++;\n+                case WS, '\\t', '\\n', '\\r' -> {} \/\/ skip whitespace, tab, etc\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        String data = sb.toString();\n+\n+        \/\/ Verify footer starts with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n+                default -> throw new IOException(\"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+\n+        \/\/ Look for Complete header by looking for the end of the hyphens\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n+                default -> throw new IOException(\"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        while ((c = is.read()) != eol && c != -1 && c != '\\r' && c != WS) {\n+            throw new IOException(\"Invalid PEM format:  \" +\n+                \"No EOL char found in footer:  0x\" +\n+                HexFormat.of().toHexDigits((byte) c));\n+        }\n+\n+        sb.append(\"-----\");\n+        String footer = sb.toString();\n+        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n+            !footer.endsWith(\"-----\")) {\n+            \/\/ Not an IOE because the read pointer is correctly at the end.\n+            throw new IllegalArgumentException(\"Illegal footer: \" + footer);\n+        }\n+\n+        \/\/ Verify the object type in the header and the footer are the same.\n+        String headerType = header.substring(11, header.length() - 5);\n+        String footerType = footer.substring(9, footer.length() - 5);\n+        if (!headerType.equals(footerType)) {\n+            throw new IllegalArgumentException(\"Header and footer do not \" +\n+                \"match: \" + headerType + \" \" + footerType);\n+        }\n+\n+        \/\/ If there was data before finding the 5 dashes of the PEM header,\n+        \/\/ backup 5 characters and save that data.\n+        byte[] preData = null;\n+        if (os.size() > 5) {\n+            preData = Arrays.copyOf(os.toByteArray(), os.size() - 5);\n+        }\n+\n+        return new PEMRecord(typeConverter(headerType), data, preData);\n+    }\n+\n+    public static PEMRecord readPEM(InputStream is) throws IOException {\n+        return readPEM(is, false);\n+    }\n+\n+    public static String pemEncoded(String type, byte[] der) {\n+        if (b64Encoder == null) {\n+            b64Encoder = Base64.getMimeEncoder(64,\n+                System.lineSeparator().getBytes());\n+        }\n+        return pemEncoded(new PEMRecord(type, b64Encoder.encodeToString(der)));\n+    }\n+\n+    \/**\n+     * Construct a String-based encoding based off the type.  leadingData\n+     * is not used with this method.\n+     * @return PEM in a string\n+     *\/\n+    public static String pemEncoded(PEMRecord pem) {\n+        StringBuilder sb = new StringBuilder(1024);\n+        sb.append(\"-----BEGIN \").append(pem.type()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        sb.append(pem.pem());\n+        sb.append(System.lineSeparator());\n+        sb.append(\"-----END \").append(pem.type()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        return sb.toString();\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":284,"deletions":9,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -86,1 +85,2 @@\n-    private X509Key(AlgorithmId algid, BitArray key) {\n+    @SuppressWarnings(\"this-escape\")\n+    public X509Key(AlgorithmId algid, BitArray key) {\n@@ -103,1 +103,1 @@\n-    protected BitArray getKey() {\n+    public BitArray getKey() {\n@@ -132,1 +132,1 @@\n-                                      in.data.getUnalignedBitString());\n+                in.data.getUnalignedBitString());\n@@ -143,0 +143,20 @@\n+    \/*\n+     * Parses X.509 subject public key DER and return it as a\n+     * X509Key.  Useful for PKCS8v2.\n+     *\/\n+    public static X509Key parse(byte[] encoded) throws IOException\n+    {\n+        DerValue in = new DerValue(encoded);\n+\n+        if (in.tag != DerValue.tag_Sequence)\n+            throw new IOException(\"corrupt subject key\");\n+\n+        AlgorithmId algorithm = AlgorithmId.parse(in.data.getDerValue());\n+        BitArray keyBits = in.data.getUnalignedBitString();\n+\n+        if (in.data.available() != 0)\n+            throw new IOException(\"excess subject key\");\n+\n+        return new X509Key(algorithm, keyBits);\n+    }\n+\n@@ -157,1 +177,1 @@\n-        encode();\n+        getEncodedInternal();\n@@ -246,1 +266,1 @@\n-    public AlgorithmId  getAlgorithmId() { return algid; }\n+    public AlgorithmId getAlgorithmId() { return algid; }\n@@ -263,1 +283,1 @@\n-    public byte[] getEncodedInternal() {\n+    private byte[] getEncodedInternal() {\n@@ -317,1 +337,1 @@\n-    void decode(DerValue val) throws InvalidKeyException {\n+    public void decode(DerValue val) throws InvalidKeyException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1552,0 +1552,9 @@\n+\n+#\n+# Default algorithm for PEMEncoder Encrypted PKCS#8\n+#\n+# This property defines the default password-based encryption algorithm for\n+# java.security.PEMEncoder when configured for encryption with the\n+# withEncryption method.\n+#\n+jdk.epkcs8.defaultAlgorithm=PBEWithHmacSHA256AndAES_128\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,427 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.DEREncodable;\n+import java.security.KeyPair;\n+import java.security.PEMRecord;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.*;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Library class for PEMEncoderTest and PEMDecoderTest\n+ *\/\n+class PEMData {\n+    public static final Entry ecsecp256 = new Entry(\"ecsecp256\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgkW3Jx561NlEgBnut\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqhRANCAASL+REY4vvAI9M3gonaml5K3lRgHq5w\n+        +OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fop224ANvB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry rsapriv = new Entry(\"rsapriv\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\n+        WqcWcoJqfdLEyBT+\n+        -----END PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    public static final Entry rsaprivbc = new Entry(\"rsaprivbc\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\n+        WqcWcoJqfdLEyBT+\n+        -----END PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    public static final Entry ec25519priv = new Entry(\"ed25519priv\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MC4CAQAwBQYDK2VwBCIEIFFZsmD+OKk67Cigc84\/2fWtlKsvXWLSoMJ0MHh4jI4I\n+        -----END PRIVATE KEY-----\n+        \"\"\", EdECPrivateKey.class);\n+\n+    public static final Entry rsapub = new Entry(\"rsapub\",\n+        \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\n+        XCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PUBLIC KEY-----\n+        \"\"\", RSAPublicKey.class);\n+\n+    public static final Entry rsapubbc = new Entry(\"rsapubbc\",\n+        \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\n+        XCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PUBLIC KEY-----\n+        \"\"\", RSAPublicKey.class);\n+\n+    public static final Entry ecsecp256pub = new Entry(\"ecsecp256pub\", \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi\/kRGOL7wCPTN4KJ2ppeSt5UYB6u\n+        cPjjuKDtFTXbguOIFDdZ65O\/8HTUqS\/sVzRF+dg7H3\/tkQ\/36KdtuADbwQ==\n+        -----END PUBLIC KEY-----\n+        \"\"\", ECPublicKey.class);\n+\n+    \/\/ EC key with explicit parameters -- Not currently supported by SunEC\n+    public static final String pubec_explicit = \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIIBSzCCAQMGByqGSM49AgEwgfcCAQEwLAYHKoZIzj0BAQIhAP\/\/\/\/8AAAABAAAA\n+        AAAAAAAAAAAA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/MFsEIP\/\/\/\/8AAAABAAAAAAAAAAAAAAAA\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/8BCBaxjXYqjqT57PrvVV2mIa8ZR0GsMxTsPY7zjw+J9JgSwMVAMSd\n+        NgiG5wSTamZ44ROdJreBn36QBEEEaxfR8uEsQkf4vOblY6RA8ncDfYEt6zOg9KE5\n+        RdiYwpZP40Li\/hp\/m47n60p8D54WK84zV2sxXs7LtkBoN79R9QIhAP\/\/\/\/8AAAAA\n+        \/\/\/\/\/\/\/\/\/\/+85vqtpxeehPO5ysL8YyVRAgEBA0IABIv5ERji+8Aj0zeCidqaXkre\n+        VGAernD447ig7RU124LjiBQ3WeuTv\/B01Kkv7Fc0RfnYOx9\/7ZEP9+inbbgA28E=\n+        -----END PUBLIC KEY-----\n+        \"\"\";\n+\n+    public static final Entry oasbcpem = new Entry(\"oasbcpem\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIIDCAIBATANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZbOdOvmvU3jl7+\n+        cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW3qGR2DuBEaMy0mkg8hfKcSpH\n+        LaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAEC\n+        gYEAwNkDkTv5rlX8nWLuLJV5kh\/TH9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692\n+        SdzR0dCSk7LGgN9qCYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\n+        \/kI+EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5aeKZQSkNAX\n+        G+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGPg6Wo1usF2bKqk8vjko9i\n+        oZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZaJz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE\n+        8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL\n+        0lGPCiOLu9RcQp7L81aF79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57\n+        AkBh75t86onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8ObWqcW\n+        coJqfdLEyBT+gYGNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\/nLzxYC+TH6gwjOWvMiNMiJo\n+        P4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGjMtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarb\n+        D6D4yRY1hWHluiuOtzhxuueCuf9hXCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry oasrfc8410 = new Entry(\"oasrfc8410\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MHICAQEwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06\/nwoy\/HU++CXqI9EdVhC\n+        oB8wHQYKKoZIhvcNAQkJFDEPDA1DdXJkbGUgQ2hhaXJzgSEAGb9ECWmEzf6FQbrB\n+        Z9w7lshQhqowtrbLDFw4rXAxZuE=\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry rsaOpenSSL = new Entry(\"rsaOpenSSL\",\n+        \"\"\"\n+        -----BEGIN RSA PRIVATE KEY-----\n+        MIIEowIBAAKCAQEAqozTLan1qFcOCWnS63jXQn5lLyGOKDv3GM11n2zkGGrChayj\n+        cSzB2KTlDmN9NgOyFdqGNWbSgdmXR5ToHGHYwaKubJoQIoPQcsipWDI156d3+X\/8\n+        BxCGY8l5nYwvS4olOXc+2kEjeFF1eamnm9IQ5DHZfaFPl0ri4Yfm1YHBAbt\/7HvF\n+        3MBjgBj1xSsSFLW4O6ws6guRVGDfKBVyyRNUhRTbSua\/nEz0wAjxF2PWT+ZTHS6M\n+        0siYwVTuPI4\/n4ItoYoahvGb9JskkXP+bc\/QZJCTFYdyxF5tKqVMSdYaJTxop02p\n+        Jo3oeafVKSlBrr0K731xgNBKqBud44aKT5R96QIDAQABAoIBAQCD9Q\/T7gOvayPm\n+        LqXOISJURV1emRTXloX5\/8Y5QtQ8\/CVjrg6Lm3ikefjsKBgR+cwJUpmyqcrIQyXk\n+        cZchlqdSMt\/IEW\/YdKqMlStJnRfOE+ok9lx2ztdcT9+0AWn6hXmFu\/i6f9nE1yoQ\n+        py6SxnbhSJyhsnTVd1CR9Uep\/InsHvYW\/15WlVMD1VuCSIt9sefqXwavbAfBaqbn\n+        mjwBB\/ulsqKhHSuRq\/QWqlj+jyGqhhYmTguC1Qwt0woDbThiHtK+suCTAlGBj\/A+\n+        IZ1U9d+VsHBcWDKBkxmlKWcJAGR3xXiKKy9vfzC+DU7L99kgay80VZarDyXgiy78\n+        9xMMzRMBAoGBANoxnZhu1bUFtLqTJ1HfDm6UB+1zVd2Mu4DXYdy\/AHjoaCLp05OQ\n+        0ZeyhO\/eXPT+eGpzCxkWD7465KO\/QDfnp54p\/NS73jaJVdWQHBhzJx1MymqURy3N\n+        JQeW4+ojzwSmVXcrs7Og6EBa4L+PWLpMLW2kODniCY+vp9f5LS6m8UPJAoGBAMgZ\n+        4rBw7B9YFZZW\/EE4eos4Q7KtA5tEP6wvCq04oxfiSytWXifYX0ToPp0CHhZlWOxk\n+        v9a\/BDGqM7AxAQJs7mmIvT5AT2V1w7oTbFPnnAo6pQtLcfaxdFFqr0h6t0sXSOKC\n+        rQeZAqqFqwuOyP7vT0goGlBruHkwS21NKkzCyzkhAoGAc2JjhbWu+8Cdt0CUPX5o\n+        ol9T5eTlFnkSuuqrTNIQzN+SGkxu341o2QDFvhdoLwLW6OwXhVeeUanROSqtKiMu\n+        B70Kf\/EtbMephXtk8CUNHTh7nmr1TSo8F8xakHoJQts3PQL2T9qal1W3nnWOpU4d\n+        g+qg9TMsfTiV2OdjVlVgJskCgYBSnjV1qjojuue22hVvDFW0c7en5z2M9wHfItEi\n+        sjbMnrdwnklj5Dd5qPZpNz2a+59ag0Kd9OJTazXKMoF7MeTCGB4ivMTLXHNCudBJ\n+        WGCZ7JrGbhEQzTX8g7L5lwlk7KlANLoiX++03lm\/\/OVKNR6j6ULsH33cM6+A4pJr\n+        fSYRYQKBgCr9iMTmL0x+n6AmMNecR+MhDxi99Oy0s2EBAYqN9g\/8yNgwM4KR0cjz\n+        EcgIOtkvoTrJ9Cquvuj+O7\/d2yNoH0SZQ4IYJKq47\/Z4kKhwXzJnBCCCBKgkjfub\n+        RTQSNnSEgTaBD29l7FrhNRHX9lIKFZ23caCTBS6o3q3+KgPbq7ao\n+        -----END RSA PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    static final Entry ed25519ep8 = new Entry(\"ed25519ep8\",\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\", EdECPrivateKey.class, \"fish\".toCharArray());\n+\n+    \/\/ This is not meant to be decrypted and to stay as an EKPI\n+    static final Entry ed25519ekpi = new Entry(\"ed25519ekpi\",\n+        ed25519ep8.pem(), EncryptedPrivateKeyInfo.class, null);\n+\n+    static final Entry rsaCert = new Entry(\"rsaCert\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIErDCCApQCCQD7ndjWbI\/x0DANBgkqhkiG9w0BAQsFADAXMRUwEwYDVQQDDAxQ\n+        RU0gVGVzdCBSU0EwIBcNMjQwMTA5MjMzNDIwWhgPMjA1MTA1MjYyMzM0MjBaMBcx\n+        FTATBgNVBAMMDFBFTSBUZXN0IFJTQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC\n+        AgoCggIBAKgO\/Pciro8xn5iNjcVCR4IuXP+V1PNATtKAlMbWzwGVOupKgRcNeRbA\n+        N9RlljxSgEChIWs0\/DB9VsAw1wCIVeuIVxv0ZvhVAcuD8Yyl58eev1rptsSJhTkN\n+        YJFxEPSP2kfWDxS21ltbg1bnY\/c1SQbzWawDLJN16G+ICzQXo68UB5fCZV9Ugfgf\n+        9USPkCiC6aFt+RT7eQaN\/JrjtCm+mFf4VbK7jYW7D8AfjviEY1HQCnPoTjHBxdy+\n+        o5s4aIOx1Wuu9wMoGuLXgY3do5\/OSDCfByk7rc1drQB9GOKf2gkR8PL9TjK+R3Lq\n+        wCA0a3jlCBiGPlH3oeZJrnp7jhAh\/tVxbsd7yIdhQnasbiTfhew132AdPXoQE+ic\n+        PFoh8MMtG1bdzt8EbvePC3GOjeyIP6f2Ixrh3B6wXzzYmJqBwON+X8TLQolcI1pa\n+        Q7AUz5BScy3lO9nyJE\/FJkX+Mr6n7WCdudCrQNP+0M845UvkgFyf4FcM7uUVugBm\n+        AXy7sCqZgTeLdqHyTElMCoWzBa3MHKyiSCh8GUJH+I1yBY1gG95j3tITIOFvbZrk\n+        vDiMwNtV9T6Ta2mb0+38GfKjbI6PF4DVrzB6xc7Q6\/GwyhOb86YLOLlEHJfhuc+C\n+        Pdy8hQrrulm2jiCO\/skvHucABNJ2CENyWa7ljNJkcN6GNTziz4AhAgMBAAEwDQYJ\n+        KoZIhvcNAQELBQADggIBAKFQE2AgYgc7\/xzwveUAiZ55tfcds07UnazLCOdpz+JJ\n+        W4MOt\/1Qi9mUylqDEymfNZVLPd2dEjB4wJ57XBUjL+kXkH1SocuskxQPf05iz5zT\n+        pEwg2fTmU73ilKMs5Q113nBnL9ZZtlRKCh1Oc5LvLW799uVXnU4UdSpWOBU9ePGY\n+        +H1wUKf+e0\/BkveQsZERYcamH9O9U\/+h+bbhr3GpT1AVnuDRyF28OvRwARDCOVyy\n+        ifh+xCR3WCnNcgfwCoH6cE1aXDKHchlAAZtvjc1lLud7\/ECIg+15keVfTYk4HEbH\n+        j\/lprxyH7y99lMmRLQpnTve54RrZGGmg51UD7OmwPHLMGibfQkw6QgdNsggIYD6p\n+        L91spgRRB+i4PTovocndOMR2RYgQEelGNqv8MsoUC7oRNxPCHxIEGuUPH1Vf3jnk\n+        mTHbVzpjy57UtfcYp1uBFDf8WoWO1Mi6oXRw2YQA1YSMm1+3ftphxydcbRuBlS7O\n+        6Iiqk6XlFG9Dpd2jjAQQzJGtnC0QDgGz6\/KGp1bGEhRnOWju07eLWvPbyaX5zeSh\n+        8gOYV33zkPhziWJt4uFMFIi7N2DLEk5UVZv1KTLZlfPl55DRs7j\/Sb4vKHpB17AO\n+        meVknxVvifDVY0TIz57t28Accsk6ClBCxNPluPU\/8YLGAZJYsdDXjGcndQ13s5G7\n+        -----END CERTIFICATE-----\n+        \"\"\", X509Certificate.class);\n+\n+    static final Entry ecCert = new Entry(\"ecCert\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIBFzCBvgIJAOGVk\/ky59ojMAoGCCqGSM49BAMCMBMxETAPBgNVBAMMCFBFTSB0\n+        ZXN0MCAXDTI0MDEwOTIzMzEwNloYDzIwNTEwNTI2MjMzMTA2WjATMREwDwYDVQQD\n+        DAhQRU0gdGVzdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGYI0jD7JZzw4RYD\n+        y9DCfaYNz0CHrpr9gJU5NXe6czvuNBdAOl\/lJGQ1pqpEQSQaMDII68obvQyQQyFY\n+        lU3G9QAwCgYIKoZIzj0EAwIDSAAwRQIgMwYld7aBzkcRt9mn27YOed5+n0xN1y8Q\n+        VEcFjLI\/tBYCIQDU3szDZ\/PK2mUZwtgQxLqHdh+f1JY0UwQS6M8QUvoDHw==\n+        -----END CERTIFICATE-----\n+        \"\"\", X509Certificate.class);\n+\n+    \/\/ EC cert with explicit parameters -- Not currently supported by SunEC\n+    static final String ecCertEX = \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIICrDCCAjMCCQDKAlI7uc1CVDAKBggqhkjOPQQDAjATMREwDwYDVQQDDAhQRU0g\n+        dGVzdDAgFw0yNDAxMDkyMzIxNTlaGA8yMDUxMDUyNjIzMjE1OVowEzERMA8GA1UE\n+        AwwIUEVNIHRlc3QwggHMMIIBZAYHKoZIzj0CATCCAVcCAQEwPAYHKoZIzj0BAQIx\n+        AP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/+\/\/\/\/\/wAAAAAAAAAA\/\/\/\/\n+        \/zB7BDD\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/v\/\/\/\/8AAAAAAAAA\n+        AP\/\/\/\/wEMLMxL6fiPufkmI4Fa+P4LRkYHZxu\/oFBEgMUCI9QE4daxlY5jYou0Z0q\n+        hcjt0+wq7wMVAKM1kmqjGaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCt\n+        dG4dO2KLp5uYWfdB4IJUKjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi\/kpLc\n+        Kfj0Hb0omhR86doxE7XwuMAKYLHOHX6BnXpDHXyQ6g5fAjEA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/x2NNgfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBA2IABO+IbTh6\n+        WqyzmxdCeJ0uUQ2v2jKxRuCKRyPlYAnpBmmQypsRS+GBdbBa0Mu6MTnVJh5uvqXn\n+        q7IuHVEiE3EFKw0DNW30nINuQg6lTv6PgN\/4nYBqsl5FQgzk2SYN3bw+7jAKBggq\n+        hkjOPQQDAgNnADBkAjATCnbbn3CgPRPi9Nym0hKpBAXc30D4eVB3mz8snK0oKU0+\n+        VP3F0EWcyM2QDSZCXIgCMHWknAhIGFTHxqypYUV8eAd3SY7ujZ6EPR0uG\/\/csBWG\n+        IqHcgr8slqi35ycQn5yMsQ==\n+        -----END CERTIFICATE-----\n+        \"\"\";\n+\n+    static final Entry ecsecp384 = new Entry(\"ecsecp384\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDBVS52ZSKZ0oES7twD2\n+        GGwRIVu3uHlGIwlu0xzFe7sgIPntca2bHfYMhgGxrlCm0q+hZANiAAQNWgwWfLX8\n+        8pYVjvwbfvDF9f+Oa9w6JjrfpWwFAUI6b1OPgrNUh+yXtUXnQNXnfUcIu0Os53bM\n+        8fTqPkQl6RyWEDHeXqJK8zTBHMeBq9nLfDPSbzQgLDyC64Orn0D8exM=\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry ecCSR = new Entry(\"ecCSR\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE REQUEST-----\n+        MIICCTCCAbACAQAwRTELMAkGA1UEBhMCVVMxDTALBgNVBAgMBFRlc3QxFDASBgNV\n+        BAcMC1NhbnRhIENsYXJhMREwDwYDVQQDDAhUZXN0IENTUjCCAUswggEDBgcqhkjO\n+        PQIBMIH3AgEBMCwGByqGSM49AQECIQD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/zBbBCD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/AQgWsY1\n+        2Ko6k+ez671VdpiGvGUdBrDMU7D2O848PifSYEsDFQDEnTYIhucEk2pmeOETnSa3\n+        gZ9+kARBBGsX0fLhLEJH+Lzm5WOkQPJ3A32BLeszoPShOUXYmMKWT+NC4v4af5uO\n+        5+tKfA+eFivOM1drMV7Oy7ZAaDe\/UfUCIQD\/\/\/\/\/AAAAAP\/\/\/\/\/\/\/\/\/\/vOb6racX\n+        noTzucrC\/GMlUQIBAQNCAAT3UJgGXD7xMwFSzBnkhsEXz3eJLjIE0HTP1Ax6x7QX\n+        G3\/+Z\/qgOZ6UQCxeHOWMEgF1Ufc\/tZkzgbvxWJ6gokeToBUwEwYJKoZIhvcNAQkH\n+        MQYMBGZpc2gwCgYIKoZIzj0EAwIDRwAwRAIgUBTdrMDE4BqruYRh1rRyKQBf48WR\n+        kIX8R4dBK9h1VRcCIEBR2Mzvku\/huTbWTwKVlXBZeEmwIlxKwpRepPtViXcW\n+        -----END CERTIFICATE REQUEST-----\n+        \"\"\", PEMRecord.class);\n+\n+    public static final String preData = \"TEXT BLAH TEXT BLAH\" +\n+        System.lineSeparator();\n+    public static final String postData = \"FINISHED\" + System.lineSeparator();\n+\n+    public static final Entry ecCSRWithData = new Entry(\"ecCSRWithData\",\n+        preData + \"\"\"\n+        -----BEGIN CERTIFICATE REQUEST-----\n+        MIICCTCCAbACAQAwRTELMAkGA1UEBhMCVVMxDTALBgNVBAgMBFRlc3QxFDASBgNV\n+        BAcMC1NhbnRhIENsYXJhMREwDwYDVQQDDAhUZXN0IENTUjCCAUswggEDBgcqhkjO\n+        PQIBMIH3AgEBMCwGByqGSM49AQECIQD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/zBbBCD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/AQgWsY1\n+        2Ko6k+ez671VdpiGvGUdBrDMU7D2O848PifSYEsDFQDEnTYIhucEk2pmeOETnSa3\n+        gZ9+kARBBGsX0fLhLEJH+Lzm5WOkQPJ3A32BLeszoPShOUXYmMKWT+NC4v4af5uO\n+        5+tKfA+eFivOM1drMV7Oy7ZAaDe\/UfUCIQD\/\/\/\/\/AAAAAP\/\/\/\/\/\/\/\/\/\/vOb6racX\n+        noTzucrC\/GMlUQIBAQNCAAT3UJgGXD7xMwFSzBnkhsEXz3eJLjIE0HTP1Ax6x7QX\n+        G3\/+Z\/qgOZ6UQCxeHOWMEgF1Ufc\/tZkzgbvxWJ6gokeToBUwEwYJKoZIhvcNAQkH\n+        MQYMBGZpc2gwCgYIKoZIzj0EAwIDRwAwRAIgUBTdrMDE4BqruYRh1rRyKQBf48WR\n+        kIX8R4dBK9h1VRcCIEBR2Mzvku\/huTbWTwKVlXBZeEmwIlxKwpRepPtViXcW\n+        -----END CERTIFICATE REQUEST-----\n+        \"\"\" + postData, PEMRecord.class);\n+\n+    public record Entry(String name, String pem, Class clazz, char[] password,\n+                        byte[] der) {\n+\n+        public Entry(String name, String pem, Class clazz, char[] password,\n+            byte[] der) {\n+            this.name = name;\n+            this.pem = pem;\n+            this.clazz = clazz;\n+            this.password = password;\n+            if (pem != null && pem.length() > 0) {\n+                String[] pemtext = pem.split(\"-----\");\n+                this.der = Base64.getMimeDecoder().decode(pemtext[2]);\n+            } else {\n+                this.der = null;\n+            }\n+        }\n+        Entry(String name, String pem, Class clazz, char[] password) {\n+            this(name, pem, clazz, password, null);\n+        }\n+\n+        Entry(String name, String pem, Class clazz) {\n+            this(name, pem, clazz, null, null);\n+        }\n+\n+        public Entry newClass(String name, Class c) {\n+            return new Entry(name, pem, c, password);\n+        }\n+\n+        public Entry newClass(Class c) {\n+            return newClass(name, c);\n+        }\n+\n+        Entry makeCRLF(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\\r\\n\"),\n+                clazz, password());\n+        }\n+\n+        Entry makeCR(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\\r\"),\n+                clazz, password());\n+        }\n+\n+        Entry makeNoCRLF(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\"),\n+                clazz, password());\n+        }\n+    }\n+\n+    static public Entry getEntry(String varname) {\n+        return getEntry(passList, varname);\n+    }\n+\n+    static public Entry getEntry(List<Entry> list, String varname) {\n+        for (Entry entry : list) {\n+            if (entry.name.compareToIgnoreCase(varname) == 0) {\n+                return entry;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static List<Entry> passList = new ArrayList<>();\n+    static List<Entry> entryList = new ArrayList<>();\n+    static List<Entry> pubList = new ArrayList<>();\n+    static List<Entry> privList = new ArrayList<>();\n+    static List<Entry> oasList = new ArrayList<>();\n+    static List<Entry> certList = new ArrayList<>();\n+    static List<Entry> encryptedList = new ArrayList<>();\n+    static List<Entry> failureEntryList = new ArrayList<>();\n+\n+    static {\n+        pubList.add(rsapub);\n+        pubList.add(rsapubbc);\n+        pubList.add(ecsecp256pub.makeCR(\"ecsecp256pub-r\"));\n+        pubList.add(ecsecp256pub.makeCRLF(\"ecsecp256pub-rn\"));\n+        privList.add(rsapriv);\n+        privList.add(rsaprivbc);\n+        privList.add(ecsecp256);\n+        privList.add(ecsecp384);\n+        privList.add(ec25519priv);\n+        privList.add(ed25519ekpi);  \/\/ The non-EKPI version needs decryption\n+        privList.add(rsaOpenSSL);\n+        oasList.add(oasrfc8410);\n+        oasList.add(oasbcpem);\n+\n+        certList.add(rsaCert);\n+        certList.add(ecCert);\n+\n+        entryList.addAll(pubList);\n+        entryList.addAll(privList);\n+        entryList.addAll(oasList);\n+        entryList.addAll(certList);\n+\n+        encryptedList.add(ed25519ep8);\n+\n+        passList.addAll(entryList);\n+        passList.addAll(encryptedList);\n+\n+        failureEntryList.add(new Entry(\"emptyPEM\", \"\", DEREncodable.class, null));\n+        failureEntryList.add(new Entry(\"nullPEM\", null, DEREncodable.class, null));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":427,"deletions":0,"binary":false,"changes":427,"status":"added"},{"patch":"@@ -0,0 +1,461 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.util\n+ * @summary Testing basic PEM API decoding\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.io.*;\n+import java.lang.Class;\n+import java.security.*;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.*;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.*;\n+import java.util.Arrays;\n+\n+import sun.security.util.Pem;\n+\n+public class PEMDecoderTest {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws IOException {\n+        System.out.println(\"Decoder test:\");\n+        PEMData.entryList.forEach(PEMDecoderTest::test);\n+        System.out.println(\"Decoder test returning DEREncodable class:\");\n+        PEMData.entryList.forEach(entry -> test(entry, DEREncodable.class));\n+        System.out.println(\"Decoder test with encrypted PEM:\");\n+        PEMData.encryptedList.forEach(PEMDecoderTest::testEncrypted);\n+        System.out.println(\"Decoder test with OAS:\");\n+        testTwoKeys();\n+        System.out.println(\"Decoder test RSA PEM setting RSAKey.class returned:\");\n+        test(PEMData.rsapriv, RSAKey.class);\n+        System.out.println(\"Decoder test failures:\");\n+        PEMData.failureEntryList.forEach(PEMDecoderTest::testFailure);\n+        System.out.println(\"Decoder test ecsecp256 PEM asking for ECPublicKey.class returned:\");\n+        testFailure(PEMData.ecsecp256, ECPublicKey.class);\n+        System.out.println(\"Decoder test rsapriv PEM setting P8EKS.class returned:\");\n+        testClass(PEMData.rsapriv, RSAPrivateKey.class);\n+        System.out.println(\"Decoder test rsaOpenSSL P1 PEM asking for RSAPublicKey.class returned:\");\n+        testFailure(PEMData.rsaOpenSSL, RSAPublicKey.class);\n+        System.out.println(\"Decoder test rsapub PEM asking X509EKS.class returned:\");\n+        testClass(PEMData.rsapub, X509EncodedKeySpec.class, true);\n+        System.out.println(\"Decoder test rsapriv PEM asking X509EKS.class returned:\");\n+        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test RSAcert PEM asking X509EKS.class returned:\");\n+        testClass(PEMData.rsaCert, X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test OAS RFC PEM asking PrivateKey.class returned:\");\n+        testClass(PEMData.oasrfc8410, PrivateKey.class, true);\n+        testClass(PEMData.oasrfc8410, PublicKey.class, true);\n+        System.out.println(\"Decoder test ecsecp256:\");\n+        testFailure(PEMData.ecsecp256pub.makeNoCRLF(\"pubecpem-no\"));\n+        System.out.println(\"Decoder test RSAcert with decryption Decoder:\");\n+        PEMDecoder d = PEMDecoder.of().withDecryption(\"123\".toCharArray());\n+        d.decode(PEMData.rsaCert.pem());\n+        System.out.println(\"Decoder test ecsecp256 with decryption Decoder:\");\n+        PrivateKey pkey = ((KeyPair) d.decode(PEMData.ecsecp256.pem())).getPrivate();\n+        System.out.println(\"Decoder test ecsecp256 to P8EKS:\");\n+        PKCS8EncodedKeySpec p8 = d.decode(PEMData.ecsecp256.pem(),\n+            PKCS8EncodedKeySpec.class);\n+\n+        System.out.println(\"Checking if decode() returns the same encoding:\");\n+        PEMData.privList.forEach(PEMDecoderTest::testDERCheck);\n+        PEMData.oasList.forEach(PEMDecoderTest::testDERCheck);\n+\n+        System.out.println(\"Check a Signature\/Verify op is successful:\");\n+        PEMData.privList.forEach(PEMDecoderTest::testSignature);\n+        PEMData.oasList.forEach(PEMDecoderTest::testSignature);\n+\n+        System.out.println(\"Checking if ecCSR with preData:\");\n+        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEMRecord.class);\n+        if (result instanceof PEMRecord rec) {\n+            if (PEMData.preData.compareTo(new String(rec.leadingData())) != 0) {\n+                System.err.println(\"expected: \" + PEMData.preData);\n+                System.err.println(\"received: \" + new String(rec.leadingData()));\n+                throw new AssertionError(\"ecCSRWithData preData wrong\");\n+            }\n+            if (rec.pem().lastIndexOf(\"F\") > rec.pem().length() - 5) {\n+                System.err.println(\"received: \" + rec.pem());\n+                throw new AssertionError(\"ecCSRWithData: \" +\n+                    \"End of PEM data has an unexpected character\");\n+            }\n+        } else {\n+            throw new AssertionError(\"ecCSRWithData didn't return a PEMRecord\");\n+        }\n+\n+        System.out.println(\"Decoding RSA pub using class PEMRecord:\");\n+        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEMRecord.class);\n+        if (!(result instanceof PEMRecord)) {\n+            throw new AssertionError(\"pubecpem didn't return a PEMRecord\");\n+        }\n+        if (((PEMRecord) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n+            throw new AssertionError(\"pubecpem PEMRecord didn't decode as a Public Key\");\n+        }\n+\n+        \/\/testInputStream();\n+        testPEMRecord(PEMData.rsapub);\n+        testPEMRecord(PEMData.ecCert);\n+        testPEMRecord(PEMData.ec25519priv);\n+        testPEMRecord(PEMData.ecCSR);\n+        testPEMRecord(PEMData.ecCSRWithData);\n+        testPEMRecordDecode(PEMData.rsapub);\n+        testPEMRecordDecode(PEMData.ecCert);\n+        testPEMRecordDecode(PEMData.ec25519priv);\n+        \/\/testPEMRecordDecode(PEMData.ecCSR);\n+        \/\/estPEMRecordDecode(PEMData.ecCSRWithData);\n+    }\n+\n+    static void testInputStream() throws IOException {\n+        ByteArrayOutputStream ba = new ByteArrayOutputStream(2048);\n+        OutputStreamWriter os = new OutputStreamWriter(ba);\n+        os.write(PEMData.preData);\n+        os.write(PEMData.rsapub.pem());\n+        os.write(PEMData.preData);\n+        os.write(PEMData.rsapub.pem());\n+        os.write(PEMData.postData);\n+        os.flush();\n+        ByteArrayInputStream is = new ByteArrayInputStream(ba.toByteArray());\n+\n+        System.out.println(\"Decoding 2 RSA pub with pre & post data:\");\n+        PEMRecord obj;\n+        int keys = 0;\n+        while (keys++ < 2) {\n+            obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+            if (!PEMData.preData.equalsIgnoreCase(\n+                new String(obj.leadingData()))) {\n+                System.out.println(\"expected: \\\"\" + PEMData.preData + \"\\\"\");\n+                System.out.println(\"returned: \\\"\" +\n+                    new String(obj.leadingData()) + \"\\\"\");\n+                throw new AssertionError(\"Leading data incorrect\");\n+            }\n+            System.out.println(\"  Read public key.\");\n+        }\n+        obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+        if (obj.pem() != null) {\n+            throw new AssertionError(\"3rd PEMRecord shouldn't have PEM data\");\n+        }\n+\n+        System.out.println(\"  Checking post data...\");\n+        if (!PEMData.postData.equalsIgnoreCase(new String(obj.leadingData()))) {\n+            System.out.println(\"expected: \\\"\" + PEMData.postData + \"\\\"\");\n+            System.out.println(\"returned: \\\"\" + new String(obj.leadingData()) +\n+                \"\\\"\");\n+            throw new AssertionError(\"Post bytes incorrect\");\n+        }\n+\n+        \/\/ End of stream\n+        try {\n+            System.out.println(\"Failed: There should be no PEMRecord: \" +\n+                PEMDecoder.of().decode(is, PEMRecord.class));\n+        } catch (EOFException e) {\n+            System.out.println(\"Success\");\n+            return;\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Caught unexpected exception \" +\n+                \"should have been IOE EOF.\");\n+        }\n+\n+        throw new AssertionError(\"Failed\");\n+    }\n+\n+    static void testPEMRecord(PEMData.Entry entry) {\n+        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        String expected = entry.pem().split(\"-----\")[2].replace(System.lineSeparator(), \"\");\n+        if (!r.pem().equalsIgnoreCase(expected)) {\n+            System.err.println(\"expected: \" + expected);\n+            System.err.println(\"received: \" + r.pem());\n+            throw new AssertionError(\"PEMRecord expected pem \" +\n+                \"does not match.\");\n+        }\n+\n+        boolean result = switch(r.type()) {\n+            case Pem.PRIVATE_KEY ->\n+                PrivateKey.class.isAssignableFrom(entry.clazz());\n+            case Pem.PUBLIC_KEY ->\n+                PublicKey.class.isAssignableFrom(entry.clazz());\n+            case Pem.CERTIFICATE, Pem.X509_CERTIFICATE ->\n+                entry.clazz().isAssignableFrom(X509Certificate.class);\n+            case Pem.X509_CRL ->\n+                entry.clazz().isAssignableFrom(X509CRL.class);\n+            case \"CERTIFICATE REQUEST\" ->\n+                entry.clazz().isAssignableFrom(PEMRecord.class);\n+            default -> false;\n+        };\n+\n+        if (!result) {\n+            System.err.println(\"PEMRecord type is a \" + r.type());\n+            System.err.println(\"Entry is a \" + entry.clazz().getName());\n+            throw new AssertionError(\"PEMRecord class didn't match:\" +\n+                entry.name());\n+        }\n+        System.out.println(\"Success (\" + entry.name() + \")\");\n+    }\n+\n+\n+    static void testPEMRecordDecode(PEMData.Entry entry) {\n+        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        DEREncodable de = PEMDecoder.of().decode(r.toString());\n+\n+        boolean result = switch(r.type()) {\n+            case Pem.PRIVATE_KEY ->\n+                PrivateKey.class.isAssignableFrom(de.getClass());\n+            case Pem.PUBLIC_KEY ->\n+                PublicKey.class.isAssignableFrom(de.getClass());\n+            case Pem.CERTIFICATE, Pem.X509_CERTIFICATE ->\n+                (de instanceof X509Certificate);\n+            case Pem.X509_CRL -> (de instanceof X509CRL);\n+            case \"CERTIFICATE REQUEST\" -> (de instanceof PEMRecord);\n+            default -> false;\n+        };\n+\n+        if (!result) {\n+            System.err.println(\"Entry is a \" + entry.clazz().getName());\n+            System.err.println(\"PEMRecord type is a \" + r.type());\n+            System.err.println(\"Returned was a \" + entry.clazz().getName());\n+            throw new AssertionError(\"PEMRecord class didn't match:\" +\n+                entry.name());\n+        }\n+        System.out.println(\"Success (\" + entry.name() + \")\");\n+    }\n+\n+\n+    static void testFailure(PEMData.Entry entry) {\n+        testFailure(entry, entry.clazz());\n+    }\n+\n+    static void testFailure(PEMData.Entry entry, Class c) {\n+        try {\n+            test(entry.pem(), c, PEMDecoder.of());\n+            throw new AssertionError(\"Failure with \" +\n+                entry.name() + \":  Not supposed to succeed.\");\n+        } catch (NullPointerException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        } catch (IOException | RuntimeException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        }\n+    }\n+\n+    static DEREncodable testEncrypted(PEMData.Entry entry) {\n+        PEMDecoder decoder = PEMDecoder.of();\n+        if (!Objects.equals(entry.clazz(), EncryptedPrivateKeyInfo.class)) {\n+            decoder = decoder.withDecryption(entry.password());\n+        }\n+\n+        try {\n+            return test(entry.pem(), entry.clazz(), decoder);\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    \/\/ Change the Entry to use the given class as the expected class returned\n+    static DEREncodable test(PEMData.Entry entry, Class c) {\n+        return test(entry.newClass(c));\n+    }\n+\n+    \/\/ Run test with a given Entry\n+    static DEREncodable test(PEMData.Entry entry) {\n+        try {\n+            DEREncodable r = test(entry.pem(), entry.clazz(), PEMDecoder.of());\n+            System.out.println(\"PASS (\" + entry.name() + \")\");\n+            return r;\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    static List getInterfaceList(Class ccc) {\n+        Class<?>[] interfaces = ccc.getInterfaces();\n+        List<Class> list = new ArrayList<>(Arrays.asList(interfaces));\n+        var x = ccc.getSuperclass();\n+        if (x != null) {\n+            list.add(x);\n+        }\n+        List<Class> results = new ArrayList<>(list);\n+        if (list.size() > 0) {\n+            for (Class cname : list) {\n+                try {\n+                    if (cname != null &&\n+                        cname.getName().startsWith(\"java.security.\")) {\n+                        results.addAll(getInterfaceList(cname));\n+                    }\n+                } catch (Exception e) {\n+                    System.err.println(\"Exception with \" + cname);\n+                }\n+            }\n+        }\n+        return results;\n+    }\n+\n+    \/**\n+     * Perform the decoding test with the given decoder, on the given pem, and\n+     * expect the clazz to be returned.\n+     *\/\n+    static DEREncodable test(String pem, Class clazz, PEMDecoder decoder)\n+        throws IOException {\n+        DEREncodable pk = decoder.decode(pem);\n+\n+        \/\/ Check that clazz matches what pk returned.\n+        if (pk.getClass().equals(clazz)) {\n+            return pk;\n+        }\n+\n+        \/\/ Search interfaces and inheritance to find a match with clazz\n+        List<Class> list = getInterfaceList(pk.getClass());\n+        for (Class cc : list) {\n+            if (cc != null && cc.equals(clazz)) {\n+                return pk;\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Entry did not contain expected: \" +\n+            clazz.getName());\n+    }\n+\n+    \/\/ Run the same key twice through the same decoder and make sure the\n+    \/\/ result is the same\n+    static void testTwoKeys() throws IOException {\n+        PublicKey p1, p2;\n+        PEMDecoder pd = PEMDecoder.of();\n+        p1 = pd.decode(PEMData.rsapub.pem(), RSAPublicKey.class);\n+        p2 = pd.decode(PEMData.rsapub.pem(), RSAPublicKey.class);\n+        if (!Arrays.equals(p1.getEncoded(), p2.getEncoded())) {\n+            System.err.println(\"These two should have matched:\");\n+            System.err.println(hex.parseHex(new String(p1.getEncoded())));\n+            System.err.println(hex.parseHex(new String(p2.getEncoded())));\n+            throw new AssertionError(\"Two decoding of the same\" +\n+                \" key failed to match: \");\n+        }\n+    }\n+\n+    static void testClass(PEMData.Entry entry, Class clazz) throws IOException {\n+        var pk = PEMDecoder.of().decode(entry.pem(), clazz);\n+    }\n+\n+    static void testClass(PEMData.Entry entry, Class clazz, boolean pass)\n+        throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (pass) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Run test with a given Entry\n+    static void testDERCheck(PEMData.Entry entry) {\n+        if (entry.name().equals(\"rsaOpenSSL\") ||  \/\/ PKCS1 data\n+            entry.name().equals(\"ed25519ekpi\")) {\n+            return;\n+        }\n+\n+        PKCS8EncodedKeySpec p8 = PEMDecoder.of().decode(entry.pem(),\n+                PKCS8EncodedKeySpec.class);\n+        int result = Arrays.compare(entry.der(), p8.getEncoded());\n+        if (result != 0) {\n+            System.err.println(\"Compare error with \" + entry.name() + \"(\" +\n+                result + \")\");\n+            System.err.println(\"Expected DER: \" + HexFormat.of().\n+                formatHex(entry.der()));\n+            System.err.println(\"Returned DER: \" + HexFormat.of().\n+                formatHex(p8.getEncoded()));\n+                throw new AssertionError(\"Failed to match \" +\n+                \"expected DER\");\n+        }\n+        System.out.println(\"PASS (\" + entry.name() + \")\");\n+        System.out.flush();\n+    }\n+\n+    \/**\n+     * Run decoded keys through Signature to make sure they are valid keys\n+     *\/\n+    static void testSignature(PEMData.Entry entry) {\n+        Signature s;\n+        byte[] data = \"12345678\".getBytes();\n+        PrivateKey privateKey;\n+\n+        DEREncodable d = PEMDecoder.of().decode(entry.pem());\n+        switch (d) {\n+            case PrivateKey p -> privateKey = p;\n+            case KeyPair kp -> privateKey = kp.getPrivate();\n+            case EncryptedPrivateKeyInfo e -> {\n+                System.out.println(\"SKIP: EncryptedPrivateKeyInfo \" +\n+                    entry.name());\n+                return;\n+            }\n+            default -> throw new AssertionError(\"Private key \" +\n+                \"should not be null\");\n+        }\n+\n+        String algorithm = switch(privateKey.getAlgorithm()) {\n+            case \"EC\" -> \"SHA256withECDSA\";\n+            case \"EdDSA\" -> \"EdDSA\";\n+            case null -> {\n+                System.out.println(\"Algorithm is null \" +\n+                    entry.name());\n+                throw new AssertionError(\"PrivateKey algorithm\" +\n+                    \"should not be null\");\n+            }\n+            default -> \"SHA256with\" + privateKey.getAlgorithm();\n+        };\n+\n+        try {\n+            if (d instanceof PrivateKey) {\n+                s = Signature.getInstance(algorithm);\n+                s.initSign(privateKey);\n+                s.update(data);\n+                s.sign();\n+                System.out.println(\"PASS (Sign): \" + entry.name());\n+            } else if (d instanceof KeyPair) {\n+                s = Signature.getInstance(algorithm);\n+                s.initSign(privateKey);\n+                s.update(data);\n+                byte[] sig = s.sign();\n+                s.initVerify(((KeyPair)d).getPublic());\n+                s.verify(sig);\n+                System.out.println(\"PASS (Sign\/Verify): \" + entry.name());\n+            } else {\n+                System.out.println(\"SKIP: \" + entry.name());\n+            }\n+        } catch (Exception e) {\n+            System.out.println(\"FAIL: \" + entry.name());\n+            throw new AssertionError(e);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":461,"deletions":0,"binary":false,"changes":461,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing basic PEM API encoding\n+ * @enablePreview\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+public class PEMEncoderTest {\n+\n+    static Map<String, DEREncodable> keymap;\n+    final static Pattern CR = Pattern.compile(\"\\r\");\n+    final static Pattern LF = Pattern.compile(\"\\n\");\n+    final static Pattern LSDEFAULT = Pattern.compile(System.lineSeparator());\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        PEMEncoder encoder = PEMEncoder.of();\n+\n+        \/\/ These entries are removed\n+        var newEntryList = new ArrayList<>(PEMData.entryList);\n+        newEntryList.remove(PEMData.getEntry(\"rsaOpenSSL\"));\n+        newEntryList.remove(PEMData.getEntry(\"ecsecp256\"));\n+        newEntryList.remove(PEMData.getEntry(\"ecsecp384\"));\n+        keymap = generateObjKeyMap(newEntryList);\n+        System.out.println(\"Same instance re-encode test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        System.out.println(\"New instance re-encode test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance re-encode testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        System.out.println(\"New instance re-encode testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key,\n+            PEMEncoder.of()));\n+\n+        keymap = generateObjKeyMap(PEMData.encryptedList);\n+        System.out.println(\"Same instance Encoder match test:\");\n+        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        System.out.println(\"Same instance Encoder new withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        System.out.println(\"New instance Encoder and withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance encrypted Encoder test:\");\n+        PEMEncoder encEncoder = encoder.withEncryption(\"fish\".toCharArray());\n+        keymap.keySet().stream().forEach(key -> testSameEncryptor(key, encEncoder));\n+        try {\n+            encoder.withEncryption(null);\n+        } catch (Exception e) {\n+            if (!(e instanceof NullPointerException)) {\n+                throw new Exception(\"Should have been a NullPointerException thrown\");\n+            }\n+        }\n+    }\n+\n+    static Map generateObjKeyMap(List<PEMData.Entry> list) {\n+        Map<String, DEREncodable> keymap = new HashMap<>();\n+        PEMDecoder pemd = PEMDecoder.of();\n+        for (PEMData.Entry entry : list) {\n+            try {\n+                if (entry.password() != null) {\n+                    keymap.put(entry.name(), pemd.withDecryption(\n+                        entry.password()).decode(entry.pem()));\n+                } else {\n+                    keymap.put(entry.name(), pemd.decode(entry.pem(),\n+                        entry.clazz()));\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"Verify PEMDecoderTest passes before \" +\n+                    \"debugging this test.\");\n+                throw new AssertionError(\"Failed to initialize map on\" +\n+                    \" entry \\\"\" + entry.name() + \"\\\"\", e);\n+            }\n+        }\n+        return keymap;\n+    }\n+\n+    static void test(String key, PEMEncoder encoder) {\n+        byte[] result;\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            result = encoder.encode(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, new String(result, StandardCharsets.UTF_8));\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testToString(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            result = encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testEncrypted(String key, PEMEncoder encoder) {\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            encoder.withEncryption(\n+                    (entry.password() != null ? entry.password() :\n+                        \"fish\".toCharArray()))\n+                .encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failed with \" +\n+                entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testSameEncryptor(String key, PEMEncoder encoder) {\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failured with \" +\n+                entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testEncryptedMatch(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            PrivateKey pkey = (PrivateKey) keymap.get(key);\n+            EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(entry.pem(),\n+                EncryptedPrivateKeyInfo.class);\n+            if (entry.password() != null) {\n+                EncryptedPrivateKeyInfo.encryptKey(pkey, entry.password(),\n+                    Pem.DEFAULT_ALGO, ekpi.getAlgParameters().\n+                        getParameterSpec(PBEParameterSpec.class),\n+                    null);\n+            }\n+            result = encoder.encodeToString(ekpi);\n+        } catch (RuntimeException | InvalidParameterSpecException e) {\n+            throw new AssertionError(\"Encrypted encoder failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void checkResults(PEMData.Entry entry, String result) {\n+        String pem = new String(entry.pem());\n+        \/\/ The below matches the \\r\\n generated PEM with the PEM passed\n+        \/\/ into the test.\n+        pem = CR.matcher(pem).replaceAll(\"\");\n+        pem = LF.matcher(pem).replaceAll(\"\");\n+        result = LSDEFAULT.matcher(result).replaceAll(\"\");\n+        try {\n+            if (pem.compareTo(result) != 0) {\n+                System.out.println(\"expected:\\n\" + pem);\n+                System.out.println(\"generated:\\n\" + result);\n+                indexDiff(pem, result);\n+            }\n+        } catch (AssertionError e) {\n+            throw new AssertionError(\"Encoder PEM mismatch \" +\n+                entry.name(), e);\n+        }\n+    }\n+\n+    static void indexDiff(String a, String b) {\n+        String lenerr = \"\";\n+        int len = a.length();\n+        int lenb = b.length();\n+        if (len != lenb) {\n+            lenerr = \":  Length mismatch: \" + len + \" vs \" + lenb;\n+            len = Math.min(len, lenb);\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (a.charAt(i) != b.charAt(i)) {\n+                throw new AssertionError(\"Char mistmatch, index #\" + i +\n+                    \"  (\" + a.charAt(i) + \" vs \" + b.charAt(i) + \")\" + lenerr);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing encryptKey\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.AlgorithmParameters;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.util.Arrays;\n+\n+public class EncryptKey {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+        AlgorithmParameters ap = ekpi.getAlgParameters();\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n+        var e = EncryptedPrivateKeyInfo.encryptKey(priKey, password,\n+            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n+            null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n+        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/EncryptKey.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing getKey\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.util.Arrays;\n+\n+public class GetKey {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+\n+        \/\/ Test getKey(password)\n+        if (!Arrays.equals(priKey.getEncoded(),\n+            ekpi.getKey(password).getEncoded())) {\n+            throw new AssertionError(\"getKey(char[]) didn't \"\n+                + \"match with expected.\");\n+        }\n+\n+        \/\/ Test getKey(key, provider)\n+        if (!Arrays.equals(priKey.getEncoded(),\n+            ekpi.getKey(key, null).getEncoded())) {\n+            throw new AssertionError(\"getKey(key, provider) \" +\n+                \"didn't match with expected.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKey.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,1 @@\n- * @compile -XDignore.symbol.file PKCS8Test.java\n- * @run testng PKCS8Test\n+ * @run main PKCS8Test\n@@ -37,1 +36,0 @@\n-import java.io.IOException;\n@@ -39,0 +37,1 @@\n+import java.security.InvalidKeyException;\n@@ -44,2 +43,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n@@ -48,1 +45,0 @@\n-import sun.security.util.DerValue;\n@@ -65,2 +61,1 @@\n-    @Test\n-    public void test() throws IOException {\n+    public static void main(String[] args) throws Exception {\n@@ -74,1 +69,2 @@\n-        Assert.assertTrue(Arrays.equals(encodedKey, EXPECTED),\n+        if (!Arrays.equals(encodedKey, EXPECTED)) {\n+            throw new AssertionError(\n@@ -76,2 +72,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedKey));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedKey));\n+        }\n@@ -81,4 +78,3 @@\n-        Assert.assertEquals(decodedKey.getAlgorithm(), ALGORITHM);\n-        Assert.assertEquals(decodedKey.getFormat(), FORMAT);\n-        Assert.assertEquals(decodedKey.getAlgorithmId().toString(),\n-                EXPECTED_ALG_ID_CHRS);\n+        assert(ALGORITHM.equalsIgnoreCase(decodedKey.getAlgorithm()));\n+        assert(FORMAT.equalsIgnoreCase(decodedKey.getFormat()));\n+        assert(EXPECTED_ALG_ID_CHRS.equalsIgnoreCase(decodedKey.getAlgorithmId().toString()));\n@@ -87,1 +83,3 @@\n-        Assert.assertTrue(Arrays.equals(encodedOutput, EXPECTED),\n+        if (!Arrays.equals(encodedOutput, EXPECTED)) {\n+\n+            throw new AssertionError(\n@@ -89,2 +87,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedOutput));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedOutput));\n+        }\n@@ -94,8 +93,15 @@\n-        enlarge(1, \"810100\");  \/\/ public key for v2\n-        enlarge(1, \"8000\", \"810100\");  \/\/ both\n-\n-        Assert.assertThrows(() -> enlarge(2));  \/\/ bad ver\n-        Assert.assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n-        Assert.assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n-        Assert.assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n-        Assert.assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+\n+        \/\/ PKCSv2 testing done by PEMEncoder\/PEMDecoder tests\n+\n+        assertThrows(() -> enlarge(2));\n+        assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n+        assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n+        assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n+        assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+    }\n+\n+    private static void assertThrows(Runnable o) {\n+        try {\n+            o.run();\n+            throw new AssertionError(\"Test failed\");\n+        } catch (Exception e) {}\n@@ -110,1 +116,1 @@\n-    static void enlarge(int newVersion, String... fields) throws IOException {\n+    static void enlarge(int newVersion, String... fields) {\n@@ -119,4 +125,8 @@\n-        Assert.assertTrue(length < 127);\n-        original[1] = (byte)(length - 2);   \/\/ the length field inside DER\n-        original[4] = (byte)newVersion;     \/\/ the version inside DER\n-        PKCS8Key.parseKey(original);\n+        assert (length < 127);\n+        original[1] = (byte) (length - 2);   \/\/ the length field inside DER\n+        original[4] = (byte) newVersion;     \/\/ the version inside DER\n+        try {\n+            PKCS8Key.parseKey(original);\n+        } catch (InvalidKeyException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"}]}