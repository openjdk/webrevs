{"files":[{"patch":"@@ -61,1 +61,2 @@\n- * <p> If the PEM does not have a JCE object representation, it returns a\n+ * <p>>If the PEM does not have a cryptographic object representation,\n+ * {@code decode(String)} and {@code decode(InputStream)} will return a\n@@ -68,3 +69,3 @@\n- * The Class parameter can specify the returned\n- * key object from a PEM containing a public and private key.  If only\n- * the private key is required, {@code PrivateKey.class} can be used.\n+ * For example, if the PEM contains both public and private keys, the\n+ * Class parameter can specify which to return. Use\n+ * {@code PrivateKey.class} to return only the private key.\n@@ -88,2 +89,1 @@\n- * object is returned.  {@code EncryptedPrivateKeyInfo} methods must be used to\n- * retrieve the {@link PrivateKey}.\n+ * object is returned.\n@@ -99,0 +99,8 @@\n+ * <p> Here is an example that decryption with a factory provider:\n+ * specified password:\n+ * {@snippet lang = java:\n+ *     PEMEncoder pe = PEMEncoder.of().withDecryption(password).\n+ *         withFactory(provider);\n+ *     byte[] pemData = pe.encode(privKey);\n+ * }\n+ *\n@@ -133,1 +141,1 @@\n-     * @return a new {@code PEMDecoder} instance\n+     * @return a {@code PEMDecoder} instance\n@@ -234,3 +242,0 @@\n-     * <p>If no PEM data is found, an {@code IllegalArgumentException} is\n-     * thrown.\n-     *\n@@ -281,5 +286,4 @@\n-     * @throws IOException on IO error with the {@code InputStream}\n-     * @throws EOFException the end of {@code InputStream} has been\n-     * unexpectedly reached.\n-     * @throws IllegalArgumentException on error in decoding or no PEM data\n-     * found\n+     * @throws IOException on IO or PEM syntax error where the\n+     * {@code InputStream} did not complete decoding.\n+     * @throws EOFException at the end of the {@code InputStream}.\n+     * @throws IllegalArgumentException on error in decoding\n@@ -312,3 +316,0 @@\n-     * <p> For all other class parameters, {@code IllegalArgumentException} is\n-     * thrown when not PEM data is found.  All non-PEM data is ignored.\n-     *\n@@ -324,2 +325,0 @@\n-     *\n-     * @see PEMDecoder for how {@code tClass} can be used.\n@@ -363,5 +362,4 @@\n-     * @throws IOException on IO error with the {@code InputStream}\n-     * @throws EOFException when reading pass the end of the\n-     * {@code InputStream}.\n-     * @throws IllegalArgumentException on error in decoding or no PEM data\n-     * found\n+     * @throws IOException on IO or PEM syntax error where the\n+     * {@code InputStream} did not complete decoding.\n+     * @throws EOFException at the end of the {@code InputStream}.\n+     * @throws IllegalArgumentException on error in decoding\n@@ -458,4 +456,4 @@\n-     * Configures and returns a new {@code PEMDecoder} instance from the\n-     * current instance that will use {@link KeyFactory} and\n-     * {@link CertificateFactory} classes from the specified {@link Provider}.\n-     * Any errors using the {@code provider} will occur during decoding.\n+     * Returns a copy of this {@code PEMDecoder} instance that uses\n+     * {@link KeyFactory} and {@link CertificateFactory} implementations\n+     * from the specified {@link Provider} to produce cryptographic objects.\n+     * Any errors using the {@code Provider} will occur during decoding.\n@@ -468,0 +466,1 @@\n+     * @throws NullPointerException if {@code provider} is null.\n@@ -470,0 +469,1 @@\n+        Objects.requireNonNull(\"provider cannot be null\");\n@@ -474,3 +474,3 @@\n-     * Returns a copy of this PEMDecoder that will decrypt encrypted PEM data\n-     * such as encrypted private keys with the specified password.\n-     * Non-encrypted PEM may still be decoded from this instance.\n+     * Returns a copy of this {@code PEMDecoder} that decodes and decrypts\n+     * encrypted private keys using the specified password.\n+     * Non-encrypted PEM can still be decoded from this instance.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n- * directly to PEM by passing it to the encode method\n+ * directly to PEM by passing it to the {@code encode} or\n+ * {@code encodeToString} methods.\n@@ -66,1 +67,2 @@\n- * {@link KeyPair} objects passed to the {@code encode} methods are encoded as a\n+ * {@link KeyPair} objects passed to the {@code encode} or\n+ * {@code encodeToString} methods are encoded as a\n@@ -70,1 +72,1 @@\n- * {@linkplain PEMRecord#pem()} with a generated the PEM header and footer\n+ * {@linkplain PEMRecord#pem()} with the PEM header and footer\n@@ -72,1 +74,1 @@\n- * not included in the encoding.  {@code PEMRecord} will not preform\n+ * not included in the encoding.  {@code PEMRecord} will not perform\n@@ -84,1 +86,1 @@\n- * specified password.\n+ * specified password:\n@@ -127,1 +129,1 @@\n-     * Returns a new instance of {@code PEMEncoder}.\n+     * Returns a instance of {@code PEMEncoder}.\n@@ -129,1 +131,1 @@\n-     * @return a new {@code PEMEncoder} instance\n+     * @return a {@code PEMEncoder}\n@@ -139,4 +141,5 @@\n-     * @param de the {@code DEREncodable} to be encoded.\n-     * @return a byte array containing the PEM encoded data\n-     * @throws IllegalArgumentException If the DEREncodable cannot be encoded\n-     * @throws NullPointerException if {@code de} is {@code null}.\n+     * @param de the {@code DEREncodable} to be encoded\n+     * @return a {@code String} containing the PEM encoded data\n+     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be\n+     * encoded\n+     * @throws NullPointerException if {@code de} is {@code null}\n@@ -207,1 +210,1 @@\n-     * @param de the {@code DEREncodable} to be encoded.\n+     * @param de the {@code DEREncodable} to be encoded\n@@ -209,2 +212,3 @@\n-     * @throws IllegalArgumentException if the DEREncodable cannot be encoded\n-     * @throws NullPointerException if {@code de} is {@code null}.\n+     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be\n+     * encoded\n+     * @throws NullPointerException if {@code de} is {@code null}\n@@ -218,2 +222,2 @@\n-     * Returns a new {@code PEMEncoder} instance configured with the default\n-     * encryption algorithm and a given password.\n+     * Returns a new {@code PEMEncoder} instance configured for encryption\n+     * with the default algorithm and a given password.\n@@ -225,4 +229,5 @@\n-     * @implNote The default algorithm is defined by Security Property {@code\n-     * jdk.epkcs8.defaultAlgorithm} using default password-based encryption\n-     * parameters by the supporting provider.  If you need more control over\n-     * the encryption algorithm and parameters, use\n+     * @implNote\n+     * The default password-based encryption algorithm is defined\n+     * by the {@code jdk.epkcs8.defaultAlgorithm} security property and\n+     * uses the default encryption parameters of the provider that is selected.\n+     * For greater flexibility with encryption options and parameters, use\n@@ -233,2 +238,2 @@\n-     * @param password sets the encryption password.  The array is cloned and\n-     *                stored in the new instance. {@code null} is a valid value.\n+     * @param password the encryption password.  The array is cloned and\n+     *                stored in the new instance.\n@@ -236,0 +241,1 @@\n+     * @throws NullPointerException when password is {@code null}\n@@ -239,0 +245,1 @@\n+        Objects.requireNonNull(password, \"password cannot be null.\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * during decoding.  {@code leadingData} maybe be useful for reading metadata\n+ * during decoding.  {@code leadingData} may be be useful for reading metadata\n@@ -50,1 +50,2 @@\n- * defensively copied.\n+ * defensively copied and does not return a clone when\n+ * {@linkplain #leadingData()} is called.\n@@ -52,1 +53,1 @@\n- * @param type The type identifier in the PEM header without PEM syntax labels.\n+ * @param type the type identifier in the PEM header without PEM syntax labels.\n@@ -54,2 +55,2 @@\n- * @param pem Any data between the PEM header and footer.\n- * @param leadingData Any non-PEM data preceding the PEM header when decoding.\n+ * @param pem any data between the PEM header and footer.\n+ * @param leadingData any non-PEM data preceding the PEM header when decoding.\n@@ -73,1 +74,1 @@\n-     * @param leadingData Any non-PEM data read during the decoding process\n+     * @param leadingData any non-PEM data read during the decoding process\n@@ -81,2 +82,2 @@\n-        Objects.requireNonNull(type, \"\\\"type\\\" may not be null.\");\n-        Objects.requireNonNull(type, \"\\\"pem\\\" may not be null.\");\n+        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n+        Objects.requireNonNull(type, \"\\\"pem\\\" cannot be null.\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -325,3 +325,3 @@\n-     * Create and encrypt an {@code EncryptedPrivateKeyInfo} from a given\n-     * PrivateKey.  A valid password-based encryption (PBE) algorithm and\n-     * password must be specified.\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * {@code PrivateKey}.  A valid password-based encryption (PBE) algorithm\n+     * and password must be specified.\n@@ -334,1 +334,1 @@\n-     * @param key the {@code PrivateKey} to encrypt.\n+     * @param key the {@code PrivateKey} to be encrypted\n@@ -346,1 +346,1 @@\n-     * @return {@code EncryptedPrivateKeyInfo}\n+     * @return a {@code EncryptedPrivateKeyInfo}\n@@ -353,1 +353,1 @@\n-     * @throws NullPointerException if the key or password are null. Also, if\n+     * @throws NullPointerException if the key or password are null. If\n@@ -367,1 +367,0 @@\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n@@ -369,1 +368,3 @@\n-        Objects.requireNonNull(key);\n+        Objects.requireNonNull(key, \"key cannot be null\");\n+        Objects.requireNonNull(password, \"password cannot be null.\");\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n@@ -397,1 +398,1 @@\n-     * @param key The {@code PrivateKey} to encrypt.\n+     * @param key The {@code PrivateKey} to be encrypted\n@@ -400,1 +401,1 @@\n-     * @return {@code EncryptedPrivateKeyInfo}\n+     * @return a {@code EncryptedPrivateKeyInfo}\n@@ -427,1 +428,1 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from the given\n@@ -430,1 +431,1 @@\n-     * @param key The {@code PrivateKey} to encrypt.\n+     * @param key the {@code PrivateKey} to be encrypted\n@@ -434,1 +435,1 @@\n-     *                 will be used if {@code null}.  However, {@code null} is\n+     *                 will be used if {@code null}; however, {@code null} is\n@@ -444,1 +445,1 @@\n-     * @return {@code EncryptedPrivateKeyInfo}\n+     * @return a {@code EncryptedPrivateKeyInfo}\n@@ -451,2 +452,3 @@\n-     * @throws NullPointerException if the key or password are null. Also, if\n-     * {@code params} is non-null when {@code algorithm} is {@code null}.\n+     * @throws NullPointerException if the {@code key} or {@code encKey} are\n+     * null. If {@code params} is non-null, {@code algorithm} cannot be\n+     * {@code null}.\n@@ -457,1 +459,1 @@\n-\n+     *\n@@ -464,0 +466,3 @@\n+\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(encKey);\n@@ -477,2 +482,0 @@\n-        Objects.requireNonNull(key);\n-        Objects.requireNonNull(encKey);\n@@ -482,1 +485,0 @@\n-\n@@ -522,26 +524,4 @@\n-     *                 {@code null} may be used.\n-     * @return {@code PrivateKey}\n-     * @throws InvalidKeyException if an error occurs during parsing of the\n-     * encrypted data or creation of the key object.\n-     *\n-     * @since 25\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n-    public PrivateKey getKey(char[] password) throws InvalidKeyException {\n-        return getKey(password, null);\n-    }\n-\n-    \/**\n-     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n-     * using the given provider.\n-     *\n-     * @param password this array is cloned and used for PBE decryption.\n-     *                 {@code null} may be used.\n-     * @param provider this {@code Provider} is used for all key generations.\n-     *                 It is used when generating the PBE encryption key,\n-     *                 {@code SecretKeyFactory}, and the {@code PrivateKey},\n-     *                 {@code KeyFactory}.  A {@code null} value will use the default\n-     *                 provider configuration.\n-     * @return {@code PrivateKey}\n-     * @throws InvalidKeyException if an error occurs during parsing of the\n-     * encrypted data or creation of the key object.\n+     * @return a {@code PrivateKey}\n+     * @throws GeneralSecurityException if an error occurs parsing or\n+     * decrypting the encrypted data, or producing the key object.\n+     * @throws NullPointerException if password is null.\n@@ -552,7 +532,1 @@\n-    public PrivateKey getKey(char[] password, Provider provider)\n-        throws InvalidKeyException {\n-        return getKeyImpl(new PBEKeySpec(password), provider);\n-    }\n-\n-    private PrivateKey getKeyImpl(PBEKeySpec keySpec, Provider provider)\n-        throws InvalidKeyException {\n+    public PrivateKey getKey(char[] password) throws GeneralSecurityException {\n@@ -561,8 +535,4 @@\n-        try {\n-            if (provider == null) {\n-                skf = SecretKeyFactory.getInstance(getAlgName());\n-                p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n-            } else {\n-                skf = SecretKeyFactory.getInstance(getAlgName(), provider);\n-                p8KeySpec = getKeySpec(skf.generateSecret(keySpec), provider);\n-            }\n+        Objects.requireNonNull(password, \"password cannot be null\");\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        skf = SecretKeyFactory.getInstance(getAlgName());\n+        p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n@@ -570,6 +540,1 @@\n-            return PKCS8Key.parseKey(p8KeySpec.getEncoded(), provider);\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new RuntimeException(e);\n-        } catch (InvalidKeySpecException e) {\n-            throw new RuntimeException(e);\n-        }\n+        return PKCS8Key.parseKey(p8KeySpec.getEncoded());\n@@ -586,3 +551,3 @@\n-     * @return {@code PrivateKey}\n-     * @throws InvalidKeyException if an error occurs during parsing of the\n-     * encrypted data or creation of the key object.\n+     * @return a {@code PrivateKey}\n+     * @throws GeneralSecurityException if an error occurs parsing or\n+     * decrypting the encrypted data, or producing the key object.\n@@ -595,11 +560,6 @@\n-        throws InvalidKeyException {\n-        try {\n-            PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n-            if (provider == null) {\n-                return KeyFactory.getInstance(p.getAlgorithm())\n-                    .generatePrivate(p);\n-            }\n-            return KeyFactory.getInstance(p.getAlgorithm(),\n-                provider).generatePrivate(p);\n-        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n-            throw new InvalidKeyException(e);\n+        throws GeneralSecurityException {\n+        Objects.requireNonNull(\"decryptKey cannot be null.\");\n+        PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n+        if (provider == null) {\n+            return KeyFactory.getInstance(p.getAlgorithm()).\n+                generatePrivate(p);\n@@ -607,0 +567,2 @@\n+        return KeyFactory.getInstance(p.getAlgorithm(),\n+            provider).generatePrivate(p);\n@@ -654,6 +616,2 @@\n-        if (decryptKey == null) {\n-            throw new NullPointerException(\"decryptKey is null\");\n-        }\n-        if (providerName == null) {\n-            throw new NullPointerException(\"provider is null\");\n-        }\n+        Objects.requireNonNull(decryptKey, \"decryptKey is null\");\n+        Objects.requireNonNull(providerName, \"provider is null\");\n@@ -688,6 +646,2 @@\n-        if (decryptKey == null) {\n-            throw new NullPointerException(\"decryptKey is null\");\n-        }\n-        if (provider == null) {\n-            throw new NullPointerException(\"provider is null\");\n-        }\n+        Objects.requireNonNull(decryptKey, \"decryptKey is null\");\n+        Objects.requireNonNull(provider, \"provider is null\");\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":47,"deletions":93,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+    \/\/ Return the internal arrayS byte[], if arrayS is null generate it.\n@@ -162,1 +163,1 @@\n-        return arrayS.clone();\n+        return arrayS;\n@@ -228,1 +229,1 @@\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), arrayS);\n+        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                    throw new IllegalArgumentException(\"No PEM data found\");\n+                    throw new EOFException(\"No PEM data found\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,20 +143,0 @@\n-    \/*\n-     * Parses X.509 subject public key DER and return it as a\n-     * X509Key.  Useful for PKCS8v2.\n-     *\/\n-    public static X509Key parse(byte[] encoded) throws IOException\n-    {\n-        DerValue in = new DerValue(encoded);\n-\n-        if (in.tag != DerValue.tag_Sequence)\n-            throw new IOException(\"corrupt subject key\");\n-\n-        AlgorithmId algorithm = AlgorithmId.parse(in.data.getDerValue());\n-        BitArray keyBits = in.data.getUnalignedBitString();\n-\n-        if (in.data.available() != 0)\n-            throw new IOException(\"excess subject key\");\n-\n-        return new X509Key(algorithm, keyBits);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"}]}