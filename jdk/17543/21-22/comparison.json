{"files":[{"patch":"@@ -62,1 +62,2 @@\n- *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (Only supported when passed as a {@code Class} parameter)<\/li>\n+ *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (Only supported when passed as\n+ *  a {@code Class} parameter)<\/li>\n@@ -64,2 +65,4 @@\n- *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (Only supported when passed as a {@code Class} parameter)<\/li>\n- *  <li>PRIVATE KEY : {@code KeyPair} (if the encoding also contains a public key)<\/li>\n+ *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (Only supported when passed\n+ *  as a {@code Class} parameter)<\/li>\n+ *  <li>PRIVATE KEY : {@code KeyPair} (if the encoding also contains a\n+ *  public key)<\/li>\n@@ -67,1 +70,2 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (if configured with Decryption)<\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (if configured with\n+ *  Decryption)<\/li>\n@@ -173,3 +177,0 @@\n-        if (pem.type() == null) {\n-            return pem;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n- *  <li>{@code PrivateKey} (if configured with encryption): ENCRYPTED PRIVATE KEY<\/li>\n+ *  <li>{@code PrivateKey} (if configured with encryption):\n+ *  ENCRYPTED PRIVATE KEY<\/li>\n@@ -302,1 +303,1 @@\n-                    throw new RuntimeException(\"Security property \" +\n+                    throw new IllegalArgumentException(\"Security property \" +\n@@ -324,1 +325,1 @@\n-                throw new RuntimeException(\"Security property \" +\n+                throw new IllegalArgumentException(\"Security property \" +\n@@ -329,3 +330,0 @@\n-            new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n-                cipher.getParameters()).encode(out);\n-\n@@ -333,0 +331,2 @@\n+                new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n+                    cipher.getParameters()).encode(out);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -64,0 +63,2 @@\n+ *\n+ * @since 25\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -546,3 +546,10 @@\n-        if (provider == null) {\n-            return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded())).\n-                generatePrivate(p);\n+        try {\n+            if (provider == null) {\n+                return KeyFactory.getInstance(\n+                    KeyUtil.getAlgorithm(p.getEncoded())).\n+                    generatePrivate(p);\n+            }\n+            return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded()),\n+                provider).generatePrivate(p);\n+        } catch (IOException e) {\n+            throw new GeneralSecurityException(e);\n@@ -550,2 +557,0 @@\n-        return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded()),\n-            provider).generatePrivate(p);\n@@ -676,1 +681,0 @@\n-    @SuppressWarnings(\"fallthrough\")\n@@ -679,15 +683,2 @@\n-        DerInputStream in = new DerInputStream(encodedKey);\n-        DerValue[] values = in.getSequence(3);\n-\n-        switch (values.length) {\n-        case 4:\n-            checkTag(values[3], DerValue.TAG_CONTEXT, \"attributes\");\n-            \/* fall through *\/\n-        case 3:\n-            checkTag(values[0], DerValue.tag_Integer, \"version\");\n-            String keyAlg = AlgorithmId.parse(values[1]).getName();\n-            checkTag(values[2], DerValue.tag_OctetString, \"privateKey\");\n-            return new PKCS8EncodedKeySpec(encodedKey, keyAlg);\n-        default:\n-            throw new IOException(\"invalid key encoding\");\n-        }\n+            return new PKCS8EncodedKeySpec(encodedKey,\n+                KeyUtil.getAlgorithm(encodedKey));\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -565,3 +565,0 @@\n-                    if (rec.pem() == null) {\n-                        return null;\n-                    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-    public static String getAlgorithm(byte[] encoded) {\n+    public static String getAlgorithm(byte[] encoded) throws IOException {\n@@ -495,2 +495,2 @@\n-            \/\/ We want the result, not the details why it failed.\n-            return null;\n+            throw new IOException(\"No recognized algorithm detected in \" +\n+                \"encoding\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    private static final byte[] CRLF = new byte[] {'\\r', '\\n'};\n@@ -238,2 +239,1 @@\n-                case WS, '\\t','\\r' -> {} \/\/ skip whitespace, tab, etc\n-                case '\\n' -> {}\n+                case WS, '\\t', '\\r', '\\n' -> {} \/\/ skip whitespace and tab\n@@ -295,1 +295,1 @@\n-            throw new IllegalArgumentException(\"Header and footer do not \" +\n+            throw new IOException(\"Header and footer do not \" +\n@@ -313,0 +313,12 @@\n+    private static String pemEncoded(String type, String base64) {\n+        return\n+            \"-----BEGIN \" + type + \"-----\\r\\n\" +\n+            base64 + (!base64.endsWith(\"\\n\") ? \"\\r\\n\" : \"\") +\n+            \"-----END \" + type + \"-----\\r\\n\";\n+    }\n+\n+    \/**\n+     * Construct a String-based encoding based off the type.  leadingData\n+     * is not used with this method.\n+     * @return PEM in a string\n+     *\/\n@@ -315,1 +327,1 @@\n-            b64Encoder = Base64.getMimeEncoder(0, new byte[0]);\n+            b64Encoder = Base64.getMimeEncoder(64, CRLF);\n@@ -317,1 +329,1 @@\n-        return pemEncoded(new PEMRecord(type, b64Encoder.encodeToString(der)));\n+        return pemEncoded(type, b64Encoder.encodeToString(der));\n@@ -326,9 +338,2 @@\n-        StringBuilder sb = new StringBuilder(1024);\n-        sb.append(\"-----BEGIN \").append(pem.type()).append(\"-----\");\n-        sb.append(System.lineSeparator());\n-        sb.append(pem.pem().replaceAll(\"(.{64})\", \"$1\" +\n-            System.lineSeparator()));\n-        sb.append(System.lineSeparator());\n-        sb.append(\"-----END \").append(pem.type()).append(\"-----\");\n-        sb.append(System.lineSeparator());\n-        return sb.toString();\n+        String p = pem.pem().replaceAll(\"(.{64})\", \"$1\\r\\n\");\n+        return pemEncoded(pem.type(), p);\n@@ -336,2 +341,0 @@\n-\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -323,0 +323,5 @@\n+    final static Pattern CR = Pattern.compile(\"\\r\");\n+    final static Pattern LF = Pattern.compile(\"\\n\");\n+    final static Pattern LSDEFAULT = Pattern.compile(System.lineSeparator());\n+\n+\n@@ -369,1 +374,2 @@\n-                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\"),\n+                LF.matcher(CR.matcher(pem).replaceAll(\"\")).\n+                    replaceAll(\"\"),\n@@ -427,0 +433,43 @@\n+\n+    static void checkResults(PEMData.Entry entry, String result) {\n+        try {\n+            checkResults(entry.pem(), result);\n+        } catch (AssertionError e) {\n+            throw new AssertionError(\"Encoder PEM mismatch \" +\n+                entry.name(), e);\n+        }\n+    }\n+\n+    static void checkResults(String expected, String result) {\n+        \/\/ The below matches the \\r\\n generated PEM with the PEM passed\n+        \/\/ into the test.\n+        String pem = LF.matcher(CR.matcher(expected).replaceAll(\"\")).\n+            replaceAll(\"\");\n+        result = LF.matcher(CR.matcher(result).replaceAll(\"\")).\n+            replaceAll(\"\");\n+        try {\n+            if (pem.compareTo(result) != 0) {\n+                System.out.println(\"expected:\\n\" + pem);\n+                System.out.println(\"generated:\\n\" + result);\n+                indexDiff(pem, result);\n+            }\n+        } catch (AssertionError e) {\n+            throw new AssertionError(\"Encoder PEM mismatch \");\n+        }\n+    }\n+\n+    static void indexDiff(String a, String b) {\n+        String lenerr = \"\";\n+        int len = a.length();\n+        int lenb = b.length();\n+        if (len != lenb) {\n+            lenerr = \":  Length mismatch: \" + len + \" vs \" + lenb;\n+            len = Math.min(len, lenb);\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (a.charAt(i) != b.charAt(i)) {\n+                throw new AssertionError(\"Char mistmatch, index #\" + i +\n+                    \"  (\" + a.charAt(i) + \" vs \" + b.charAt(i) + \")\" + lenerr);\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,2 @@\n+        System.out.println(\"Decoder test ecsecp256:\");\n+        testFailure(PEMData.ecsecp256pub.makeNoCRLF(\"pubecpem-no\"));\n@@ -84,2 +86,2 @@\n-        System.out.println(\"Decoder test ecsecp256 with decryption Decoder:\");\n-        PrivateKey pkey = ((KeyPair) d.decode(PEMData.ecsecp256.pem())).getPrivate();\n+        System.out.println(\"Decoder test ecsecp256 private key with decryption Decoder:\");\n+        ((KeyPair) d.decode(PEMData.ecsecp256.pem())).getPrivate();\n@@ -87,2 +89,1 @@\n-        PKCS8EncodedKeySpec p8 = d.decode(PEMData.ecsecp256.pem(),\n-            PKCS8EncodedKeySpec.class);\n+        d.decode(PEMData.ecsecp256.pem(), PKCS8EncodedKeySpec.class);\n@@ -98,0 +99,2 @@\n+        System.out.println(\"Checking if ecCSR:\");\n+        test(PEMData.ecCSR);\n@@ -123,0 +126,40 @@\n+\n+        testInputStream();\n+        testPEMRecord(PEMData.rsapub);\n+        testPEMRecord(PEMData.ecCert);\n+        testPEMRecord(PEMData.ec25519priv);\n+        testPEMRecord(PEMData.ecCSR);\n+        testPEMRecord(PEMData.ecCSRWithData);\n+        testPEMRecordDecode(PEMData.rsapub);\n+        testPEMRecordDecode(PEMData.ecCert);\n+        testPEMRecordDecode(PEMData.ec25519priv);\n+        testPEMRecordDecode(PEMData.ecCSR);\n+        testPEMRecordDecode(PEMData.ecCSRWithData);\n+\n+        d = PEMDecoder.of();\n+        EncryptedPrivateKeyInfo ekpi =\n+            d.decode(PEMData.ed25519ep8.pem(), EncryptedPrivateKeyInfo.class);\n+        PrivateKey privateKey;\n+        try {\n+            privateKey = ekpi.getKey(PEMData.ed25519ep8.password());\n+        } catch (GeneralSecurityException e) {\n+            throw new AssertionError(\"ed25519ep8 error\", e);\n+        }\n+\n+        \/\/ PBE\n+        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey,\n+            \"password\".toCharArray(),\"PBEWithMD5AndDES\", null, null);\n+        try {\n+            ekpi.getKey(\"password\".toCharArray());\n+        } catch (Exception e) {\n+            throw new AssertionError(\"error getting key\", e);\n+        }\n+\n+        \/\/ PBES2\n+        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey\n+            , \"password\".toCharArray());\n+        try {\n+            ekpi.getKey(\"password\".toCharArray());\n+        } catch (Exception e) {\n+            throw new AssertionError(\"error getting key\", e);\n+        }\n@@ -150,11 +193,5 @@\n-        obj = PEMDecoder.of().decode(is, PEMRecord.class);\n-        if (obj.pem() != null) {\n-            throw new AssertionError(\"3rd PEMRecord shouldn't have PEM data\");\n-        }\n-\n-        System.out.println(\"  Checking post data...\");\n-        if (!PEMData.postData.equalsIgnoreCase(new String(obj.leadingData()))) {\n-            System.out.println(\"expected: \\\"\" + PEMData.postData + \"\\\"\");\n-            System.out.println(\"returned: \\\"\" + new String(obj.leadingData()) +\n-                \"\\\"\");\n-            throw new AssertionError(\"Post bytes incorrect\");\n+        try {\n+            PEMDecoder.of().decode(is, PEMRecord.class);\n+            throw new AssertionError(\"3rd entry returned a PEMRecord\");\n+        } catch (EOFException e) {\n+            System.out.println(\"Success: No 3rd entry found.  EOFE thrown.\");\n@@ -181,5 +218,6 @@\n-        if (!r.pem().equalsIgnoreCase(expected)) {\n-            System.err.println(\"expected: \" + expected);\n-            System.err.println(\"received: \" + r.pem());\n-            throw new AssertionError(\"PEMRecord expected pem \" +\n-                \"does not match.\");\n+        try {\n+            PEMData.checkResults(expected, r.pem());\n+        } catch (AssertionError e) {\n+            System.err.println(\"expected:\\n\" + expected);\n+            System.err.println(\"received:\\n\" + r.pem());\n+            throw e;\n@@ -246,0 +284,6 @@\n+            if (entry.pem().indexOf('\\r') != -1) {\n+                System.out.println(\"Found a CR.\");\n+            }\n+            if (entry.pem().indexOf('\\n') != -1) {\n+                System.out.println(\"Found a LF\");\n+            }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":65,"deletions":21,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.util.regex.Pattern;\n@@ -48,4 +47,0 @@\n-    final static Pattern CR = Pattern.compile(\"\\r\");\n-    final static Pattern LF = Pattern.compile(\"\\n\");\n-    final static Pattern LSDEFAULT = Pattern.compile(System.lineSeparator());\n-\n@@ -93,1 +88,1 @@\n-        checkResults(PEMData.ed25519ep8, pemRecord.toString());\n+        PEMData.checkResults(PEMData.ed25519ep8, pemRecord.toString());\n@@ -128,1 +123,1 @@\n-        checkResults(entry, new String(result, StandardCharsets.UTF_8));\n+        PEMData.checkResults(entry, new String(result, StandardCharsets.UTF_8));\n@@ -142,1 +137,1 @@\n-        checkResults(entry, result);\n+        PEMData.checkResults(entry, result);\n@@ -200,1 +195,1 @@\n-        checkResults(entry, result);\n+        PEMData.checkResults(entry, result);\n@@ -203,36 +198,0 @@\n-\n-    static void checkResults(PEMData.Entry entry, String result) {\n-        String pem = new String(entry.pem());\n-        \/\/ The below matches the \\r\\n generated PEM with the PEM passed\n-        \/\/ into the test.\n-        pem = CR.matcher(pem).replaceAll(\"\");\n-        pem = LF.matcher(pem).replaceAll(\"\");\n-        result = LF.matcher(CR.matcher(pem).replaceAll(\"\")).\n-            replaceAll(\"\");\n-        try {\n-            if (pem.compareTo(result) != 0) {\n-                System.out.println(\"expected:\\n\" + pem);\n-                System.out.println(\"generated:\\n\" + result);\n-                indexDiff(pem, result);\n-            }\n-        } catch (AssertionError e) {\n-            throw new AssertionError(\"Encoder PEM mismatch \" +\n-                entry.name(), e);\n-        }\n-    }\n-\n-    static void indexDiff(String a, String b) {\n-        String lenerr = \"\";\n-        int len = a.length();\n-        int lenb = b.length();\n-        if (len != lenb) {\n-            lenerr = \":  Length mismatch: \" + len + \" vs \" + lenb;\n-            len = Math.min(len, lenb);\n-        }\n-        for (int i = 0; i < len; i++) {\n-            if (a.charAt(i) != b.charAt(i)) {\n-                throw new AssertionError(\"Char mistmatch, index #\" + i +\n-                    \"  (\" + a.charAt(i) + \" vs \" + b.charAt(i) + \")\" + lenerr);\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":4,"deletions":45,"binary":false,"changes":49,"status":"modified"}]}