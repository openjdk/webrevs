{"files":[{"patch":"@@ -37,4 +37,5 @@\n- * This is a top-level interface for security classes that contain cryptographic\n- * data which may not be related or have a common class hierarchy.  These\n- * security objects provide standard binary encoding, like ASN.1, and possible\n- * type formats, like X.509 and PKCS#8.\n+ * This interface is implemented by security API classes that contain\n+ * binary-encodable key or certificate material.\n+ * These APIs or their subclasses typically provide methods to convert\n+ * their instances to and from byte arrays in the Distinguished\n+ * Encoding Rules (DER) format (ITU X.690).\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,3 +53,3 @@\n- * type and implements {@link DEREncodable}. The\n- * following types are decoded into Java Cryptographic Extensions (JCE) object\n- * representations:\n+ * type and implements {@link DEREncodable}. The following types are\n+ * decoded into Java API cryptographic object that implement\n+ * {@link DEREncodable}:\n@@ -133,1 +133,1 @@\n-     * @return new {@code PEMDecoder} instance\n+     * @return a new {@code PEMDecoder} instance\n@@ -220,2 +220,1 @@\n-     * Decodes and returns a cryptographic representative {@link DEREncodable}\n-     * from the given {@code String}.\n+     * Decodes and returns a {@link DEREncodable} from the given {@code String}.\n@@ -223,3 +222,11 @@\n-     * <p>This method reads the {@code String} until the first PEM data is found\n-     * or the end the {@code String} is reached.  Non-PEM data before the PEM\n-     * header is ignored by the decoder.\n+     * <p> This method reads the {@code String} until PEM data is found\n+     * or the end of the {@code String} is reached.  If no PEM data is found,\n+     * an {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p> This method returns a Java API cryptographic object,\n+     * such as a {@code PrivateKey}, if the PEM type is supported.\n+     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n+     * If no cryptographic object is found, a {@link PEMRecord} will be\n+     * returned containing the type identifier and Base64-encoded data.\n+     * Any non-PEM data preceding the PEM header will be stored in\n+     * {@code leadingData}.\n@@ -230,1 +237,1 @@\n-     * <p> Byte streams consumed by methods in this class are read in as\n+     * <p> Input consumed by this method is read in as\n@@ -234,5 +241,4 @@\n-     * @return {@code DEREncodable} that is cryptographically representative of\n-     * the data is returned.  {@code PEMRecord} will not be returned.\n-     * @throws IllegalArgumentException on error in decoding.\n-     * @throws NullPointerException when {@code str} is null or there is no\n-     * Java API cryptographic representation {@code DEREncodable} for the data.\n+     * @return a {@code DEREncodable}\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws NullPointerException when {@code str} is null.\n@@ -244,1 +250,1 @@\n-            de = decode(new ByteArrayInputStream(\n+            return decode(new ByteArrayInputStream(\n@@ -250,4 +256,0 @@\n-        if (de == null || de instanceof PEMRecord) {\n-            return null;\n-        }\n-        return de;\n@@ -257,2 +259,2 @@\n-     * Decodes and returns a cryptographic representative {@link DEREncodable}\n-     * from the given {@code InputStream}.\n+     * Decodes and returns a {@link DEREncodable} from the given\n+     * {@code InputStream}.\n@@ -261,5 +263,4 @@\n-     * found or until the end of the stream.  The {@code InputStream} will\n-     * be left at the end of the PEM footer.  This method may be repeatedly\n-     * used on an {@code InputStream} to decode additional PEM data.  Non-PEM\n-     * data in the {@code InputStream} before the PEM header is ignored by the\n-     * decoder.\n+     * found or until the end of the stream.  It can be called repeatedly\n+     * on the {@code InputStream} to decode additional PEM data.\n+     * The {@code InputStream} read pointer will remain at the end of\n+     * the PEM footer unless an IOException occurs.\n@@ -267,3 +268,7 @@\n-     * <p>A {@code DEREncodable} that is a Java API cryptographic\n-     * representation of the data is returned.  {@code PEMRecord} will not be\n-     * returned.\n+     * <p> This method returns a Java API cryptographic object,\n+     * such as a {@code PrivateKey}, if the PEM type is supported.\n+     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n+     * If no cryptographic object is found, a {@link PEMRecord} will be\n+     * returned containing the type identifier and Base64-encoded data.\n+     * Any non-PEM data preceding the PEM header will be stored in\n+     * {@code leadingData}.\n@@ -271,1 +276,1 @@\n-     * <p>If no PEM data is found, an {@code IllegalArgumentException} is\n+     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n@@ -275,2 +280,1 @@\n-     * @return a {@code DEREncodable} that is a Java API cryptographic\n-     * representation of the data.\n+     * @return a {@code DEREncodable}\n@@ -278,5 +282,5 @@\n-     * @throws EOFException when reading pass the end of the\n-     * {@code InputStream}.\n-     * @throws IllegalArgumentException on error in decoding.\n-     * @throws NullPointerException when {@code str} is null or there is no\n-     * Java API cryptographic representation {@code DEREncodable} for the data.\n+     * @throws EOFException the end of {@code InputStream} has been\n+     * unexpectedly reached.\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws NullPointerException when {@code is} is null.\n@@ -287,6 +291,1 @@\n-        DEREncodable de = decode(pem);\n-\n-        if (de == null || de instanceof PEMRecord) {\n-            return null;\n-        }\n-        return de;\n+        return decode(pem);\n@@ -300,1 +299,9 @@\n-     * <p> Only the first PEM data read will be returned.\n+     * <p> This method reads the {@code String} until PEM data is found\n+     * or the end of the {@code String} is reached.  If no PEM data is found,\n+     * an {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p> If the class parameter is {@code PEMRecord.class},\n+     * a {@linkplain PEMRecord} is returned containing the\n+     * type identifier and Base64 encoding. Any non-PEM data preceding\n+     * the PEM header will be stored in {@code leadingData}.  Other\n+     * class parameters will not return preceding non-PEM data.\n@@ -302,7 +309,2 @@\n-     * <p> If the class parameter is {@code PEMRecord.class}, any data before\n-     * the PEM header will be stored in {@code leadingData}.  The {@code type}\n-     * and {@code pem} will contain the type identifier and Base64 encoding\n-     * respectively.  If no PEM is read, both {@code type} and {@code pem}\n-     * are set to null, but any non-PEM data read will be stored in\n-     * {@code leadingData}.  If no data is read,\n-     * {@code IllegalArgumentException} is thrown.\n+     * <p> Input consumed by this method is read in as\n+     * {@link java.nio.charset.StandardCharsets#UTF_8 UTF-8}.\n@@ -317,4 +319,4 @@\n-     * @return {@code DEREncodable} typecast to {@code tClass} or null if no\n-     * data is found.\n-     * @throws IllegalArgumentException on error in decoding.\n-     * @throws ClassCastException if the given class is invalid for the PEM.\n+     * @return a {@code DEREncodable} specified by {@code tClass}\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws ClassCastException if {@code tClass} is invalid for the PEM type.\n@@ -341,6 +343,5 @@\n-     * <p>This method reads the {@code InputStream} until PEM data is\n-     * found or until the end of the stream.  The {@code InputStream} will\n-     * be left at the end of the PEM footer.  This method may be repeatedly\n-     * used on an {@code InputStream} to decode additional PEM data.  Non-PEM\n-     * data in the {@code InputStream} before the PEM header is ignored by the\n-     * decoder.\n+     * <p> This method reads the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  It can be called repeatedly\n+     * on the {@code InputStream} to decode additional PEM data.\n+     * The {@code InputStream} read pointer will remain at the end of\n+     * the PEM footer unless an IOException occurs.\n@@ -348,7 +349,5 @@\n-     * <p> If the class parameter is {@code PEMRecord.class}, any data before\n-     * the PEM header will be stored in {@code leadingData}.  The {@code type}\n-     * and {@code pem} will contain the type identifier and Base64 encoding\n-     * respectively.  If no PEM is read, both {@code type} and {@code pem}\n-     * are set to null, but any non-PEM data read will be stored in\n-     * {@code leadingData}.  If no data is read,\n-     * {@code IllegalArgumentException} is thrown.\n+     * <p> If the class parameter is {@code PEMRecord.class},\n+     * a {@linkplain PEMRecord} is returned containing the\n+     * type identifier and Base64 encoding. Any non-PEM data preceding\n+     * the PEM header will be stored in {@code leadingData}.  Other\n+     * class parameters will not return preceding non-PEM data.\n@@ -356,2 +355,2 @@\n-     * <p> For all other class parameters, {@code IllegalArgumentException} is\n-     * thrown when not PEM data is found.  All non-PEM data is ignored.\n+     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n+     * thrown.\n@@ -363,2 +362,2 @@\n-     * @return {@code DEREncodable} typecast to {@code tClass}\n-     * @throws IOException on IO error with the {@code InputStream}.\n+     * @return a {@code DEREncodable} typecast to {@code tClass}\n+     * @throws IOException on IO error with the {@code InputStream}\n@@ -367,2 +366,3 @@\n-     * @throws IllegalArgumentException on error in decoding.\n-     * @throws ClassCastException if the given class is invalid for the PEM.\n+     * @throws IllegalArgumentException on error in decoding or no PEM data\n+     * found\n+     * @throws ClassCastException if {@code tClass} is invalid for the PEM type.\n@@ -467,1 +467,1 @@\n-     * @return new configured {@code PEMDecoder} instance\n+     * @return a new configured {@code PEMDecoder} instance\n@@ -480,1 +480,1 @@\n-     * @return new configured {@code PEMDecoder} instance\n+     * @return a new configured {@code PEMDecoder} instance\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n- * <p> Encoding may be performed on cryptographic objects that implement\n- * {@link DEREncodable}.\n+ * <p> Encoding may be performed on Java API cryptographic objects that\n+ * implement {@link DEREncodable}.\n@@ -96,2 +96,0 @@\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n- *       RFC 5958: Asymmetric Key Packages\n@@ -131,1 +129,1 @@\n-     * @return new {@code PEMEncoder} instance\n+     * @return a new {@code PEMEncoder} instance\n@@ -210,1 +208,1 @@\n-     * @return PEM encoded byte array\n+     * @return a PEM encoded byte array\n@@ -237,1 +235,1 @@\n-     * @return new configured {@code PEMEncoder} instance\n+     * @return a new configured {@code PEMEncoder} instance\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -39,2 +40,2 @@\n- * Java API cryptographic object is not desired or there is no other\n- * {@code DEREncodable} for the type.\n+ * cryptographic object is not desired or the type has no\n+ * {@code DEREncodable}.\n@@ -42,4 +43,4 @@\n- * <p>{@code PEMRecord} may have a null {@code type} and {@code pem} when\n- * there is no PEM data.  If there is PEM data, {@code type} and\n- * {@code pem} will both be non-null. {@code leadingData} may be null if the\n- * decoded data only contains PEM data. All values can never be null.\n+ * <p> {@code type} and {@code pem} may not be {@code null}.\n+ * {@code leadingData} may be null if no non-PEM data preceded PEM header\n+ * during decoding.  {@code leadingData} maybe be useful for reading metadata\n+ * that accompanies PEM data.\n@@ -47,4 +48,2 @@\n- * <p> During the instantiation of this record, there is no validation for the\n- * {@code type} or {@code pem}.\n- *\n- * <p>This class is thread-safe.  {@code leadingData} is not\n+ * <p> During the instantiation of this record, there is no validation\n+ * for the {@code type} or {@code pem}. {@code leadingData} is not\n@@ -53,2 +52,2 @@\n- * @param type The type identifier in the PEM header.  For a public key,\n- * {@code type} would be \"PUBLIC KEY\".\n+ * @param type The type identifier in the PEM header without PEM syntax labels.\n+ *           For a public key, {@code type} would be \"PUBLIC KEY\".\n@@ -56,3 +55,1 @@\n- * @param leadingData Any non-PEM data read during the decoding process\n- * before the PEM header. This can be useful when reading metadata that\n- * accompanies PEM data.\n+ * @param leadingData Any non-PEM data preceding the PEM header when decoding.\n@@ -73,3 +70,3 @@\n-     * @param type the type identifier in the PEM header and footer, or\n-     *             {@code null} if there is no PEM data.\n-     * @param pem the data between the PEM header and footer.\n+     * @param type the type identifier\n+     * @param pem the Base64-encoded data encapsulated by the PEM header and\n+     *           footer.\n@@ -78,1 +75,4 @@\n-     * @throws IllegalArgumentException on incorrect input values\n+     * @throws IllegalArgumentException if the {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code pem} are\n+     * {@code null}.\n@@ -81,8 +81,2 @@\n-        if (type == null && pem == null && leadingData == null) {\n-            throw new IllegalArgumentException(\"All values may not be null.\");\n-        }\n-\n-        if (type == null && pem != null || type != null && pem == null) {\n-            throw new IllegalArgumentException(\"\\\"type\\\" and \\\"pem\\\" must be\" +\n-                \" both null or non-null\");\n-        }\n+        Objects.requireNonNull(type, \"\\\"type\\\" may not be null.\");\n+        Objects.requireNonNull(type, \"\\\"pem\\\" may not be null.\");\n@@ -92,4 +86,4 @@\n-        if (type != null && (type.startsWith(\"-\") || type.contains(\"BEGIN\") ||\n-            type.contains(\"END\") || type.endsWith(\"-\"))) {\n-            throw new IllegalArgumentException(\"Only the PEM type identifier \" +\n-                \"is allowed\");\n+        if (type.startsWith(\"-\") || type.contains(\"BEGIN\") ||\n+            type.contains(\"END\") || type.endsWith(\"-\")) {\n+            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n+                \"Only the PEM type identifier is allowed\");\n@@ -107,5 +101,7 @@\n-     * @param type the type identifier in the PEM header and footer, or\n-     * {@code null} if there is no PEM data.\n-     * @param pem the Base64-encoded data between the PEM header and footer.\n-     *\n-     * @see #PEMRecord(String, String, byte[])\n+     * @param type the PEM type identifier\n+     * @param pem the Base64-encoded data encapsulated by the PEM header and\n+     *           footer.\n+     * @throws IllegalArgumentException if the {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code pem} are\n+     * {@code null}.\n@@ -120,5 +116,8 @@\n-     *\n-     * @param type the type identifier in the PEM header and footer, or {@code null} if there is no PEM data.\n-     * @param pem the Base64-encoded data between the PEM header and footer.\n-     *\n-     * @see #PEMRecord(String, String, byte[])\n+\n+     * @param type the PEM type identifier\n+     * @param pem the Base64-encoded data encapsulated by the PEM header and\n+     *           footer.\n+     * @throws IllegalArgumentException if the {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code pem} are\n+     * {@code null}.\n@@ -136,1 +135,1 @@\n-     * method is called, or null if {@code pem} is null.\n+     * method is called.\n@@ -139,1 +138,1 @@\n-        return (pem == null ? null : Base64.getMimeDecoder().decode(pem));\n+        return Base64.getMimeDecoder().decode(pem);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":42,"deletions":43,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                    return new PEMRecord(null, null, os.toByteArray());\n+                    throw new IllegalArgumentException(\"No PEM data found\");\n@@ -183,2 +183,1 @@\n-                case '\\n', '\\r' -> throw new IllegalArgumentException(\n-                    \"Incomplete header\");\n+                case '\\n', '\\r' -> throw new IOException(\"Incomplete header\");\n@@ -194,1 +193,1 @@\n-                    throw new IllegalArgumentException(\"Incomplete header\");\n+                    throw new IOException(\"Incomplete header\");\n@@ -202,1 +201,1 @@\n-            throw new IllegalArgumentException(\"Illegal header: \" + header);\n+            throw new IOException(\"Illegal header: \" + header);\n@@ -222,1 +221,1 @@\n-                throw new IllegalArgumentException(\"No EOL character found\");\n+                throw new IOException(\"No EOL character found\");\n@@ -243,2 +242,1 @@\n-                default -> throw new IllegalArgumentException(\n-                    \"Incomplete footer\");\n+                default -> throw new IOException(\"Incomplete footer\");\n@@ -266,2 +264,1 @@\n-                default -> throw new IllegalArgumentException(\n-                    \"Incomplete footer\");\n+                default -> throw new IOException(\"Incomplete footer\");\n@@ -272,1 +269,1 @@\n-            throw new IllegalArgumentException(\"Invalid PEM format:  \" +\n+            throw new IOException(\"Invalid PEM format:  \" +\n@@ -281,0 +278,1 @@\n+            \/\/ Not an IOE because the read pointer is correctly at the end.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-        testInputStream();\n+        \/\/testInputStream();\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}