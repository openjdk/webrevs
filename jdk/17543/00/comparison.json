{"files":[{"patch":"@@ -37,1 +37,1 @@\n-public interface AsymmetricKey extends Key {\n+public non-sealed interface AsymmetricKey extends Key, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/AsymmetricKey.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+\/**\n+ * This is a top-level interface for security classes that contain cryptographic\n+ * data which may not be related or have a common class hierarchy.  These\n+ * security objects provide standard binary encoding, like ASN.1, and type\n+ * formats, like X.509 and PKCS#8.  These encodings are used in some form with\n+ * {@link KeyFactory} and {@link java.security.cert.CertificateFactory},\n+ *\n+ * @see Key\n+ * @see KeyPair\n+ * @see EncodedKeySpec\n+ * @see EncryptedPrivateKeyInfo\n+ * @see X509Certificate\n+ * @see X509CRL\n+ *\n+ * @since 24\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public sealed interface DEREncodable permits AsymmetricKey, KeyPair, X509CRL,\n+    X509Certificate, PKCS8EncodedKeySpec, X509EncodedKeySpec,\n+    EncryptedPrivateKeyInfo {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/security\/Key.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-public final class KeyPair implements java.io.Serializable {\n+public final class KeyPair implements java.io.Serializable, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPair.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.rsa.RSAPrivateCrtKeyImpl;\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.io.*;\n+import java.security.cert.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * PEMDecoder is an immutable Privacy-Enhanced Mail (PEM) decoding class.\n+ * PEM is a textual encoding used for storing and transferring security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL). Defined in RFC 1421 and RFC 7468, PEM consists of a\n+ * Base64-formatted binary encoding surrounded by a type identifying header\n+ * and footer.\n+ * <p>\n+ * Decoding methods return a class that matches the data type and implements\n+ * {@link DEREncodable}.\n+ * If a return class is specified, an IllegalAlgorithmException is thrown if\n+ * data is not valid for the class.\n+ * <p>\n+ * When passing input data into {@code decode}, the application is responsible\n+ * for processing input data non-PEM text. All data before the PEM\n+ * header will be ignored.\n+ * <p>\n+ * A new immutable PEMDecoder instance is returned by\n+ * {@linkplain #withFactory} and\/or {@linkplain #withDecryption}.  Configuring\n+ * an instance for decryption does not prevent decoding with unencrypted PEM.\n+ * Any encrypted PEM that does not use the configured password will cause an\n+ * exception. A decoder instance not configured with decryption will return an\n+ * {@link EncryptedPrivateKeyInfo} with encrypted PEM.  EncryptedPrivateKeyInfo\n+ * methods must be used to retrieve the {@link PrivateKey}.\n+ * <p>\n+ * PEMDecoder supports the follow types:\n+ * <pre>\n+ *     PRIVATE KEY, RSA PRIVATE KEY, PUBLIC KEY, CERTIFICATE, CRL, and\n+ *     ENCRYPTED PRIVATE KEY.\n+ * <\/pre>\n+ * @apiNote\n+ * Here is an example of encoding a PrivateKey object:\n+ * <pre>\n+ *     PEMDecoder pd = PEMDecoder.of();\n+ *     PrivateKey priKey = pd.decode(PriKeyPEM);\n+ * <\/pre>\n+ *\n+ * @since 24\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMDecoder {\n+    private final Provider factory;\n+    private final char[] password;\n+\n+    \/\/ Singleton instance for PEMDecoder\n+    private final static PEMDecoder PEM_DECODER = new PEMDecoder(null, null);\n+\n+    \/**\n+     * Creates a immutable instance with a specific KeyFactory and\/or password.\n+     * @param withFactory KeyFactory provider\n+     * @param withPassword char[] password for EncryptedPrivateKeyInfo\n+     *                    decryption\n+     *\/\n+    private PEMDecoder(Provider withFactory, char[] withPassword) {\n+        super();\n+        factory = withFactory;\n+        password = withPassword;\n+    }\n+\n+    \/**\n+     * Returns an instance of PEMDecoder.  This instance may be repeatedly used\n+     * to decode different PEM text.\n+     *\n+     * @return returns a PEMDecoder\n+     *\/\n+    public static PEMDecoder of() {\n+        return PEM_DECODER;\n+    }\n+\n+    \/**\n+     * After the header, footer, and base64 have been separated, identify the\n+     * header and footer and proceed with decoding the base64 for the\n+     * appropriate type.\n+     *\/\n+    private DEREncodable decode(byte[] data, byte[] header, byte[] footer)\n+        throws IOException {\n+        Pem.KeyType keyType;\n+\n+        if (Arrays.mismatch(header, Pem.PUBHEADER) == -1 &&\n+            Arrays.mismatch(footer, Pem.PUBFOOTER) == -1) {\n+            keyType = Pem.KeyType.PUBLIC;\n+        } else if (Arrays.mismatch(header, Pem.PKCS8HEADER) == -1 &&\n+            Arrays.mismatch(footer, Pem.PKCS8FOOTER) == -1) {\n+            keyType = Pem.KeyType.PRIVATE;\n+        } else if (Arrays.mismatch(header, Pem.PKCS8ENCHEADER) == -1 &&\n+            Arrays.mismatch(footer, Pem.PKCS8ENCFOOTER) == -1) {\n+            keyType = Pem.KeyType.ENCRYPTED_PRIVATE;\n+        } else if (Arrays.mismatch(header, Pem.CERTHEADER) == -1 &&\n+            Arrays.mismatch(footer, Pem.CERTFOOTER) == -1) {\n+            keyType = Pem.KeyType.CERTIFICATE;\n+        } else if (Arrays.mismatch(header, Pem.CRLHEADER) == -1 &&\n+            Arrays.mismatch(footer, Pem.CRLFOOTER) == -1) {\n+            keyType = Pem.KeyType.CRL;\n+        } else if (Arrays.mismatch(header, Pem.PKCS1HEADER) == -1 &&\n+            Arrays.mismatch(footer, Pem.PKCS1FOOTER) == -1) {\n+            keyType = Pem.KeyType.PKCS1;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported PEM header\/footer\");\n+        }\n+\n+        if (password != null) {\n+            if (keyType != Pem.KeyType.ENCRYPTED_PRIVATE) {\n+                throw new IllegalArgumentException(\"Decoder configured only \" +\n+                    \"for encrypted PEM.\");\n+            }\n+        }\n+\n+        Base64.Decoder decoder = Base64.getMimeDecoder();\n+\n+        try {\n+            return switch (keyType) {\n+                case PUBLIC -> {\n+                    X509EncodedKeySpec spec =\n+                        new X509EncodedKeySpec(decoder.decode(data));\n+                    yield ((KeyFactory) getFactory(keyType,\n+                        spec.getAlgorithm())).generatePublic(spec);\n+\n+                }\n+                case PRIVATE -> {\n+                    PKCS8Key p8key = new PKCS8Key(decoder.decode(data));\n+                    PrivateKey priKey;\n+                    KeyFactory kf = (KeyFactory)\n+                        getFactory(keyType, p8key.getAlgorithm());\n+                    priKey = kf.generatePrivate(\n+                        new PKCS8EncodedKeySpec(p8key.getEncoded(),\n+                            p8key.getAlgorithm()));\n+                    \/\/ If there is a public key, it's an OAS.\n+                    if (p8key.getPubKeyEncoded() != null) {\n+                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                            p8key.getPubKeyEncoded(), p8key.getAlgorithm());\n+                        yield new KeyPair(((KeyFactory)\n+                            getFactory(keyType, p8key.getAlgorithm()))\n+                            .generatePublic(spec),\n+                            priKey);\n+                    }\n+                    yield priKey;\n+                }\n+                case ENCRYPTED_PRIVATE -> {\n+                    if (password == null) {\n+                        yield new EncryptedPrivateKeyInfo(decoder.decode(data));\n+                    }\n+                    yield new EncryptedPrivateKeyInfo(decoder.decode(data)).\n+                        getKey(password);\n+                }\n+                case CERTIFICATE -> {\n+                    CertificateFactory cf =\n+                        (CertificateFactory) getFactory(keyType, \"X509\");\n+                    yield (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(decoder.decode(data)));\n+                }\n+                case CRL -> {\n+                    CertificateFactory cf =\n+                        (CertificateFactory) getFactory(keyType, \"X509\");\n+                    yield (X509CRL) cf.generateCRL(\n+                        new ByteArrayInputStream(decoder.decode(data)));\n+                }\n+                case PKCS1 -> {\n+                    KeyFactory kf = (KeyFactory) getFactory(keyType, \"RSA\");\n+                    yield kf.generatePrivate(\n+                        RSAPrivateCrtKeyImpl.getKeySpec(decoder.decode(data)));\n+                }\n+                default ->\n+                    throw new IllegalArgumentException(\"Unsupported type or \" +\n+                        \"not properly formatted PEM\");\n+            };\n+        } catch (GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns {@link DEREncodable} from the given string.\n+     *\n+     * @param str PEM data in a String.\n+     * @return an DEREncodable generated from the PEM data.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public DEREncodable decode(String str) {\n+        Objects.requireNonNull(str);\n+        try {\n+            return decode(new ByteArrayInputStream(str.getBytes()));\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns a {@link DEREncodable} from the given\n+     * {@code InputStream}.\n+     * The method will read the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  Non-PEM data in the\n+     * {@code InputStream} before the PEM header will be ignored by the decoder.\n+     *\n+     * @param is InputStream containing PEM data.\n+     * @return an DEREncodable generated from the PEM data.\n+     * @throws IOException on IO error with the InputStream.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public DEREncodable decode(InputStream is) throws IOException {\n+        Objects.requireNonNull(is);\n+        Pem pem = Pem.readPEM(is);\n+        if (pem == null) {\n+            throw new IllegalArgumentException(\"No PEM data found.\");\n+        }\n+        return decode(pem.getData(), pem.getHeader(), pem.getFooter());\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given PEM string.  The\n+     * class must extend {@link DEREncodable} and be the appropriate class for\n+     * the PEM type.\n+     *\n+     * <p>With the {@code tClass} argument, the returned object may be cast to a\n+     * subclass or converted to a different return class, if\n+     * appropriate for that PEM data.  Using EC public key PEM as an example,\n+     * {@code tClass} may be set to {@code PublicKey.class},\n+     * {@code ECPublicKey}, or a {@code X509EncodedKeySpec}.  {@code PublicKey}\n+     * is useful for algorithm-agnostic methods, {@code ECPublicKey} for\n+     * algorithm-specific operations, or {@code X509EncodedKeySpec} if the\n+     * X.509 binary encoding is desired instead of a Key object.  An IOException\n+     * will be thrown if the class is incorrect for the given PEM data.\n+     *\n+     * @param <S> Class type parameter that extends {@link DEREncodable}\n+     * @param string the String containing PEM data.\n+     * @param tClass  the returned object class that implementing\n+     * {@link DEREncodable}.\n+     * @return The DEREncodable typecast to tClass.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public <S extends DEREncodable> S decode(String string, Class<S> tClass) {\n+        Objects.requireNonNull(string);\n+        try {\n+            return decode(new ByteArrayInputStream(string.getBytes()), tClass);\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given PEM stream.  The\n+     * class must extend {@link DEREncodable} and be an appropriate class for\n+     * the PEM type.\n+     *\n+     * <p>See {@link PEMDecoder#decode(String, Class)} for details about\n+     * {@code tClass}.\n+     * <br>See {@link PEMDecoder#decode(InputStream)} for details on using an\n+     * {@code InputStream}.\n+     *\n+     * @param <S> Class type parameter that extends {@code DEREncodable}\n+     * @param is an InputStream containing PEM data.\n+     * @param tClass the returned object class that implementing\n+     *   {@code DEREncodable}.\n+     * @return  tClass.\n+     * @throws IOException on IO error with the InputStream.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public <S extends DEREncodable> S decode(InputStream is, Class<S> tClass)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+        Objects.requireNonNull(tClass);\n+        Pem pem = Pem.readPEM(is);\n+        if (pem == null) {\n+            throw new IllegalArgumentException(\"No PEM data found.\");\n+        }\n+\n+        DEREncodable so =\n+            decode(pem.getData(), pem.getHeader(), pem.getFooter());\n+\n+        \/*\n+         * If the object is a KeyPair, check if the tClass is set to class\n+         * specific to a private or public key.  Because PKCS8v2 can be a\n+         * KeyPair, it is possible for someone to assume all their PEM private\n+         * keys are only PrivateKey and not KeyPair.\n+         *\/\n+        if (so instanceof KeyPair kp) {\n+            if ((PrivateKey.class).isAssignableFrom(tClass) ||\n+                (PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPrivate();\n+            }\n+            if ((PublicKey.class).isAssignableFrom(tClass) ||\n+                (X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPublic();\n+            }\n+        }\n+\n+        \/*\n+         * KeySpec use getKeySpec after the Key has been generated.  Even though\n+         * returning a binary encoding after the Base64 decoding is ok when the\n+         * user wants PKCS8EncodedKeySpec, generating the key verifies the\n+         * binary encoding and allows the KeyFactory to use the provider's\n+         * KeySpec()\n+         *\/\n+\n+        if ((EncodedKeySpec.class).isAssignableFrom(tClass) &&\n+            so instanceof Key key) {\n+            try {\n+                \/\/ unchecked suppressed as we know tClass comes from KeySpec\n+                \/\/ KeyType not relevant here.  We just want KeyFactory\n+                if ((PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    ((KeyFactory) getFactory(Pem.KeyType.PRIVATE,\n+                        key.getAlgorithm())).getKeySpec(key,\n+                        PKCS8EncodedKeySpec.class);\n+                } else if ((X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    ((KeyFactory) getFactory(Pem.KeyType.PUBLIC,\n+                        key.getAlgorithm()))\n+                        .getKeySpec(key, X509EncodedKeySpec.class);\n+                } else {\n+                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                }\n+            } catch (InvalidKeySpecException e) {\n+                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n+                    \"specified (\" + tClass.getName() +\") for key (\" +\n+                    key.getClass().getName() +\")\", e);\n+            }\n+        }\n+\n+        return tClass.cast(so);\n+    }\n+\n+    \/\/ Convenience method to avoid provider getInstance checks clutter\n+    private Object getFactory(Pem.KeyType type, String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return switch (type) {\n+                    case PUBLIC, PRIVATE, PKCS1 ->\n+                        KeyFactory.getInstance(algorithm);\n+                    case CERTIFICATE, CRL ->\n+                        CertificateFactory.getInstance(algorithm);\n+                    default -> null;  \/\/ no possible\n+                };\n+            } else {\n+                return switch (type) {\n+                    case PUBLIC, PRIVATE, PKCS1 ->\n+                        KeyFactory.getInstance(algorithm, factory);\n+                    case CERTIFICATE, CRL ->\n+                        CertificateFactory.getInstance(algorithm, factory);\n+                    default -> null;  \/\/ no possible\n+                };\n+            }\n+        } catch (GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Configures and return a new PEMDecoder instance from the current instance\n+     * that will use Factory classes from the specified Provider.\n+     *\n+     * @param provider the Factory provider.\n+     * @return a new PEM decoder instance.\n+     *\/\n+    public PEMDecoder withFactory(Provider provider) {\n+        return new PEMDecoder(provider, password);\n+    }\n+\n+    \/**\n+     * Returns a new PEMDecoder instance from the current instance configured\n+     * to decrypt encrypted PEM data with given password.\n+     * Non-encrypted PEM may still be decoded from this instance.\n+     *\n+     * @param password the password to decrypt encrypted PEM data.\n+     * @return the decoder\n+     * @throws NullPointerException if password is null.\n+     *\/\n+    public PEMDecoder withDecryption(char[] password) {\n+        char[] pwd = password.clone();\n+        return new PEMDecoder(factory, pwd);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.Pem;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.*;\n+import java.security.cert.Certificate;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * PEMEncoder is an immutable Privacy-Enhanced Mail (PEM) encoding class.\n+ * PEM is a textual encoding used for storing and transferring security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL). Defined in RFC 1421 and RFC 7468, PEM consists of a\n+ * Base64-formatted binary encoding surrounded by a type identifying header\n+ * and footer.\n+ * <p>\n+ * Encoding may be performed on objects that implement {@link DEREncodable}.\n+ * <p>\n+ * Encrypted private key PEM data can be built by calling the encode methods\n+ * on a PEMEncoder instance returned by {@link #withEncryption(char[])} or\n+ * by passing an {@link EncryptedPrivateKeyInfo} object into the encode methods.\n+ * <p>\n+ * PKCS8 v2.0 allows OneAsymmetric encoding, which is a private and public\n+ * key in the same PEM.  This is supported by using the {@link KeyPair} class\n+ * with the encode methods.\n+ * <p>\n+ * PEMEncoder supports the follow types:\n+ * <pre>\n+ *     PRIVATE KEY, PUBLIC KEY, CERTIFICATE, CRL, and ENCRYPTED PRIVATE KEY.\n+ * <\/pre>\n+ *\n+ * @apiNote\n+ * Here is an example of encoding a PrivateKey object:\n+ * <pre>\n+ *     PEMEncoder pe = PEMEncoder.of();\n+ *     byte[] pemData = pe.encode(privKey);\n+ * <\/pre>\n+ *\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMEncoder {\n+\n+    \/\/ Singleton instance of PEMEncoder\n+    private static final PEMEncoder PEM_ENCODER = new PEMEncoder(null);\n+\n+    \/\/ If non-null, encoder is configured for encryption\n+    private Cipher cipher = null;\n+    private final char[] password;\n+\n+    \/**\n+     * Instantiate a new PEMEncoder for Encrypted Private Keys.\n+     *\n+     * @param pwd is the password to generate the Cipher key with.\n+     *\/\n+    private PEMEncoder(char[] pwd) {\n+        password = pwd;\n+    }\n+\n+    \/**\n+     * Returns an instance of PEMEncoder.\n+     *\n+     * @return PEMEncoder instance\n+     *\/\n+    static public PEMEncoder of() {\n+        return PEM_ENCODER;\n+    }\n+\n+    \/**\n+     * Construct a String-based encoding based off the {@code keyType} given.\n+     *\n+     * @param keyType the key type\n+     * @param encoded the encoded\n+     * @return the string\n+     *\/\n+    private byte[] pemEncoded(Pem.KeyType keyType, byte[] encoded) {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n+        switch (keyType) {\n+            case PUBLIC -> {\n+                os.writeBytes(Pem.PUBHEADER);\n+                os.writeBytes(Pem.LINESEPARATOR);\n+                os.writeBytes(convertToPEM(encoded));\n+                os.writeBytes(Pem.PUBFOOTER);\n+                os.writeBytes(Pem.LINESEPARATOR);\n+            }\n+            case PRIVATE -> {\n+                os.writeBytes(Pem.PKCS8HEADER);\n+                os.writeBytes(Pem.LINESEPARATOR);\n+                os.writeBytes(convertToPEM(encoded));\n+                os.writeBytes(Pem.PKCS8FOOTER);\n+                os.writeBytes(Pem.LINESEPARATOR);\n+            }\n+            case ENCRYPTED_PRIVATE -> {\n+                os.writeBytes(Pem.PKCS8ENCHEADER);\n+                os.writeBytes(Pem.LINESEPARATOR);\n+                os.writeBytes(convertToPEM(encoded));\n+                os.writeBytes(Pem.PKCS8ENCFOOTER);\n+                os.writeBytes(Pem.LINESEPARATOR);\n+            }\n+            default -> {\n+                return new byte[0];\n+            }\n+        }\n+        return os.toByteArray();\n+    }\n+\n+    static byte[] convertToPEM(byte[] encoding) {\n+        if (encoding.length == 0) {\n+            return new byte[0];\n+        }\n+        Base64.Encoder e = Base64.getMimeEncoder(64, Pem.LINESEPARATOR);\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n+        os.writeBytes(e.encode(encoding));\n+        os.writeBytes(Pem.LINESEPARATOR);\n+        return os.toByteArray();\n+    }\n+\n+    \/**\n+     * Encoded a given {@code DEREncodable} and return the PEM encoding in a\n+     * String\n+     *\n+     * @param so a cryptographic object to be PEM encoded that implements\n+     *           DEREncodable.\n+     * @return PEM encoding in a String\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public String encodeToString(DEREncodable so) {\n+        return new String(encode(so), StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Encoded a given {@code DEREncodable} into PEM.\n+     *\n+     * @param so the object that implements DEREncodable.\n+     * @return a PEM encoded byte[] of the given DEREncodable.\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public byte[] encode(DEREncodable so) {\n+        Objects.requireNonNull(so);\n+        return switch (so) {\n+            case PublicKey pu -> build(null, pu.getEncoded());\n+            case PrivateKey pr -> build(pr.getEncoded(), null);\n+            case KeyPair kp -> {\n+                if (kp.getPublic() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PublicKey.\");\n+                }\n+\n+                if (kp.getPrivate() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PrivateKey.\");\n+                }\n+                yield build(kp.getPrivate().getEncoded(),\n+                    kp.getPublic().getEncoded());\n+            }\n+            case X509EncodedKeySpec x -> build(null, x.getEncoded());\n+            case PKCS8EncodedKeySpec p -> build(p.getEncoded(), null);\n+            case EncryptedPrivateKeyInfo epki -> {\n+                if (password != null) {\n+                    throw new IllegalArgumentException(\"encrypt was \" +\n+                        \"incorrectly used\");\n+                }\n+                try {\n+                    yield pemEncoded(Pem.KeyType.ENCRYPTED_PRIVATE, epki.getEncoded());\n+                } catch (IOException e) {\n+                    throw new SecurityException(e);\n+                }\n+            }\n+            case Certificate c -> {\n+                ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n+                os.writeBytes(Pem.CERTHEADER);\n+                try {\n+                    os.writeBytes(Base64.getMimeEncoder(64, Pem.LINESEPARATOR)\n+                        .encode(c.getEncoded()));\n+                } catch (CertificateEncodingException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+                os.writeBytes(Pem.CERTFOOTER);\n+                yield os.toByteArray();\n+            }\n+            case CRL crl -> {\n+                X509CRL xcrl = (X509CRL)crl;\n+                ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n+                os.writeBytes(Pem.CRLHEADER);\n+                try {\n+                    os.writeBytes(Base64.getMimeEncoder(64, Pem.LINESEPARATOR)\n+                        .encode(xcrl.getEncoded()));\n+                } catch (CRLException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+                os.writeBytes(Pem.CRLFOOTER);\n+                yield os.toByteArray();\n+            }\n+            default -> throw new IllegalArgumentException(\"PEM does not \" +\n+                \"support \" + so.getClass().getCanonicalName());\n+        };\n+    }\n+\n+    \/**\n+     * Returns a new immutable PEMEncoder instance configured to the default\n+     * encrypt algorithm and a given password.\n+     *\n+     * <p> Only {@link PrivateKey} will be encrypted with this newly configured\n+     * instance.  Other {@link DEREncodable} classes that do not support\n+     * encrypted PEM will cause encode() to throw an IOException.\n+     *\n+     * <p> Default algorithm defined by Security Property {@code\n+     * jdk.epkcs8.defaultAlgorithm}.  To configure all the encryption options\n+     * see {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, char[], String,\n+     * AlgorithmParameterSpec, Provider)} and use the returned object with\n+     * {@link #encode(DEREncodable)}.\n+     *\n+     * @param password the password\n+     * @return a new PEMEncoder\n+     * @throws NullPointerException if password is null.\n+     *\/\n+    public PEMEncoder withEncryption(char[] password) {\n+        char[] pwd = password.clone();\n+        return new PEMEncoder(pwd);\n+    }\n+\n+    \/**\n+     * Build PEM encoding.\n+     *\/\n+    private byte[] build(byte[] privateBytes, byte[] publicBytes) {\n+        DerOutputStream out = new DerOutputStream();\n+\n+        \/\/ Encrypted PKCS8\n+        if (password != null) {\n+            if (privateBytes == null || publicBytes != null) {\n+                throw new IllegalArgumentException(\"Can only encrypt a \" +\n+                    \"PrivateKey.\");\n+            }\n+\n+            \/\/ PBEKeySpec clones the password array\n+            PBEKeySpec spec = new PBEKeySpec(password);\n+            Arrays.fill(password, (char)0x0);\n+\n+            if (cipher == null) {\n+                try {\n+                    SecretKeyFactory factory;\n+                    factory = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO);\n+                    cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n+                    cipher.init(Cipher.ENCRYPT_MODE, factory.generateSecret(spec));\n+                } catch (GeneralSecurityException e) {\n+                    throw new SecurityException(\"Security property \" +\n+                        \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                        \"valid algorithm.\", e);\n+                }\n+            }\n+\n+            new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n+                cipher.getParameters()).encode(out);\n+            try {\n+                out.putOctetString(cipher.doFinal(privateBytes));\n+            } catch (GeneralSecurityException e) {\n+                throw new IllegalArgumentException(e);\n+            }\n+\n+            return pemEncoded(Pem.KeyType.ENCRYPTED_PRIVATE,\n+                DerValue.wrap(DerValue.tag_Sequence, out).toByteArray());\n+        }\n+\n+        \/\/ X509 only\n+        if (publicBytes != null && privateBytes == null) {\n+            return pemEncoded(Pem.KeyType.PUBLIC, publicBytes);\n+        }\n+        \/\/ PKCS8 only\n+        if (publicBytes == null && privateBytes != null) {\n+            return pemEncoded(Pem.KeyType.PRIVATE, privateBytes);\n+        }\n+        \/\/ OAS\n+        try {\n+            return pemEncoded(Pem.KeyType.PRIVATE,\n+                PKCS8Key.getEncoded(publicBytes, privateBytes));\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CRL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/Certificate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-public abstract class X509CRL extends CRL implements X509Extension {\n+public abstract non-sealed class X509CRL extends CRL implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CRL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-public abstract class X509Certificate extends Certificate\n-implements X509Extension {\n+public abstract non-sealed class X509Certificate extends Certificate\n+implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509Certificate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -30,0 +31,2 @@\n+import java.io.IOException;\n+import java.security.DEREncodable;\n@@ -67,0 +70,5 @@\n+        try {\n+            algorithmName = KeyUtil.getAlgorithm(this.encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error just leave algorithmName as is\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/KeySpec.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.security.DEREncodable;\n+\n@@ -62,1 +64,1 @@\n-public class PKCS8EncodedKeySpec extends EncodedKeySpec {\n+public final class PKCS8EncodedKeySpec extends EncodedKeySpec implements DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.security.DEREncodable;\n+\n@@ -52,1 +54,2 @@\n-public class X509EncodedKeySpec extends EncodedKeySpec {\n+public final class X509EncodedKeySpec extends EncodedKeySpec implements\n+    DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,8 @@\n-import java.io.*;\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.IOException;\n@@ -31,4 +38,1 @@\n-import sun.security.x509.AlgorithmId;\n-import sun.security.util.DerValue;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n+import java.util.Objects;\n@@ -53,1 +57,1 @@\n- * @see java.security.spec.PKCS8EncodedKeySpec\n+ * @see PKCS8EncodedKeySpec\n@@ -58,1 +62,1 @@\n-public class EncryptedPrivateKeyInfo {\n+public final class EncryptedPrivateKeyInfo implements DEREncodable {\n@@ -76,7 +80,5 @@\n-     * Constructs (i.e., parses) an {@code EncryptedPrivateKeyInfo} from\n-     * its ASN.1 encoding.\n-     * @param encoded the ASN.1 encoding of this object. The contents of\n-     * the array are copied to protect against subsequent modification.\n-     * @exception NullPointerException if the {@code encoded} is\n-     * {@code null}.\n-     * @exception IOException if error occurs when parsing the ASN.1 encoding.\n+     * Constructs an {@code EncryptedPrivateKeyInfo} from a given Encrypted\n+     * PKCS#8 ASN.1 encoding.\n+     * @param encoded the ASN.1 encoding to be parsed.\n+     * @throws NullPointerException if {@code encoded} is {@code null}.\n+     * @throws IOException if error occurs when parsing the ASN.1 encoding.\n@@ -85,4 +87,1 @@\n-        if (encoded == null) {\n-            throw new NullPointerException(\"the encoded parameter \" +\n-                \"must be non-null\");\n-        }\n+        Objects.requireNonNull(encoded);\n@@ -189,0 +188,1 @@\n+\n@@ -202,1 +202,1 @@\n-        \/\/ one and only one is non null\n+        \/\/ one and only one is non-null\n@@ -220,0 +220,8 @@\n+    private EncryptedPrivateKeyInfo(byte[] encoded, byte[] eData,\n+        AlgorithmId id, AlgorithmParameters p) {\n+        this.encoded = encoded;\n+        encryptedData = eData;\n+        algid = id;\n+        params = p;\n+    }\n+\n@@ -307,0 +315,132 @@\n+    \/**\n+     * Returns an {@code EncryptedPrivateKeyInfo} from a given PrivateKey,\n+     * password, and encryption options.  A valid password-based encryption\n+     * algorithm must be specified.  AlgorithmParameterSpec,\n+     * {@code params}, will use the provider default if {@code null} is\n+     * passed.  If {@code provider} is {@code null}, the provider will be\n+     * selected through the default configuration.\n+     *\n+     * @param key the PrivateKey object to encrypt.\n+     * @param password the password used in the PBE encryption.\n+     * @param algorithm the algorithm to encrypt with.\n+     * @param params the AlgorithmParameterSpec to encrypt with.\n+     * @param provider the Provider that will perform the encryption\n+     * @return an EncryptedPrivateKeyInfo.\n+     * @throws IllegalArgumentException when arguments passed are incorrect.\n+     * @throws SecurityException on a cryptographic errors.\n+     * @throws NullPointerException if {@code algorithm} is null.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider) {\n+\n+        AlgorithmId algid;\n+        byte[] encryptedData;\n+        Cipher cipher;\n+\n+        Objects.requireNonNull(algorithm);\n+        DerOutputStream out = new DerOutputStream();\n+\n+        var spec = new PBEKeySpec(password);\n+        SecretKey skey;\n+        SecretKeyFactory factory;\n+        try {\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+                cipher = Cipher.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+                cipher = Cipher.getInstance(algorithm, provider);\n+            }\n+            skey = factory.generateSecret(spec);\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException |\n+                 InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        try {\n+            cipher.init(Cipher.ENCRYPT_MODE, skey, params);\n+            encryptedData = cipher.doFinal(key.getEncoded());\n+            algid = new AlgorithmId(Pem.getPBEID(algorithm),\n+                cipher.getParameters());\n+            algid.encode(out);\n+            out.putOctetString(encryptedData);\n+        } catch (InvalidAlgorithmParameterException |\n+                 IllegalBlockSizeException | BadPaddingException |\n+                 InvalidKeyException e) {\n+            throw new SecurityException(e);\n+        }\n+        return new EncryptedPrivateKeyInfo(\n+            DerValue.wrap(DerValue.tag_Sequence, out).toByteArray(),\n+            encryptedData, algid, cipher.getParameters());\n+    }\n+\n+    \/**\n+     * Creates and encrypts an `EncryptedPrivateKeyInfo` from a given PrivateKey\n+     * and password.\n+     * <p>\n+     * The encryption uses the algorithm set by `jdk.epkcs8.defaultAlgorithm`\n+     * Security Property by the default provider and default the\n+     * AlgorithmParameterSpec of that provider.\n+     *\n+     * @param key The PrivateKey object to encrypt.\n+     * @param password the password used in the PBE encryption.\n+     * @return an EncryptedPrivateKeyInfo.\n+     * @throws IllegalArgumentException when arguments passed are incorrect.\n+     * @throws SecurityException on a cryptographic errors.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password) {\n+        return encryptKey(key, password, Pem.DEFAULT_ALGO, null, null);\n+    }\n+\n+    \/**\n+     * Return a PrivateKey from the encrypted data in the object.\n+     *\n+     * @param password the password used in the PBE encryption.\n+     * @return a PrivateKey\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 24\n+     *\/\n+    public PrivateKey getKey(char[] password) throws InvalidKeyException {\n+        return getKey(password, null);\n+    }\n+    \/**\n+     * Return a PrivateKey from the object's encrypted data with a KeyFactory\n+     * from the given Provider.\n+     *\n+     * @param password the password\n+     * @param provider the KeyFactory provider used to generate the key.\n+     * @return a PrivateKey\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password, Provider provider)\n+        throws InvalidKeyException {\n+        try {\n+            PBEKeySpec pks = new PBEKeySpec(password);\n+            SecretKeyFactory skf;\n+            PKCS8EncodedKeySpec keySpec;\n+            if (provider == null) {\n+                skf = SecretKeyFactory.getInstance(getAlgName());\n+                keySpec = getKeySpec(skf.generateSecret(pks));\n+            } else {\n+                skf = SecretKeyFactory.getInstance(getAlgName(), provider);\n+                keySpec = getKeySpec(skf.generateSecret(pks), provider);\n+            }\n+            return PKCS8Key.parseKey(keySpec.getEncoded());\n+        } catch (GeneralSecurityException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n@@ -312,4 +452,3 @@\n-     * @exception NullPointerException if {@code decryptKey}\n-     * is {@code null}.\n-     * @exception NoSuchAlgorithmException if cannot find appropriate\n-     * cipher to decrypt the encrypted data.\n+     * @exception NullPointerException if {@code decryptKey} is {@code null}.\n+     * @exception NoSuchAlgorithmException Cannot find appropriate cipher to\n+     * decrypt.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":163,"deletions":24,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+        \/\/XXX Number will change when assigned\n+        @JEP(number=999, title=\"PEM API\", status=\"Preview\")\n+        PEM_API,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.io.IOException;\n@@ -220,1 +223,1 @@\n-            throws GeneralSecurityException {\n+        throws GeneralSecurityException {\n@@ -222,8 +225,15 @@\n-            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n-            return new ECPublicKeyImpl(x509Spec.getEncoded());\n-        } else if (keySpec instanceof ECPublicKeySpec) {\n-            ECPublicKeySpec ecSpec = (ECPublicKeySpec)keySpec;\n-            return new ECPublicKeyImpl(\n-                ecSpec.getW(),\n-                ecSpec.getParams()\n-            );\n+            return new ECPublicKeyImpl(((X509EncodedKeySpec)keySpec).getEncoded());\n+\n+        } else if (keySpec instanceof ECPublicKeySpec ecSpec) {\n+            return new ECPublicKeyImpl(ecSpec.getW(), ecSpec.getParams());\n+\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key;\n+            try {\n+                p8key = new ECPrivateKeyImpl(\n+                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            } catch (Exception e) {\n+                throw new GeneralSecurityException(e);\n+            }\n+            return new ECPublicKeyImpl(p8key.getPubKeyEncoded());\n+\n@@ -240,2 +250,1 @@\n-            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;\n-            byte[] encoded = pkcsSpec.getEncoded();\n+            byte[] encoded = ((PKCS8EncodedKeySpec) keySpec).getEncoded();\n@@ -247,2 +256,2 @@\n-        } else if (keySpec instanceof ECPrivateKeySpec) {\n-            ECPrivateKeySpec ecSpec = (ECPrivateKeySpec)keySpec;\n+\n+        } else if (keySpec instanceof ECPrivateKeySpec ecSpec) {\n@@ -250,0 +259,1 @@\n+\n@@ -251,2 +261,3 @@\n-            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \"\n-                + \"and PKCS8EncodedKeySpec supported for EC private keys\");\n+            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \" +\n+                \"and PKCS8EncodedKeySpec supported for EC private keys. \" +\n+                keySpec.getClass().getName() + \" provided.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":27,"deletions":16,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -136,1 +136,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -156,1 +156,1 @@\n-    private byte[] getArrayS0() {\n+    public byte[] getArrayS() {\n@@ -160,5 +160,1 @@\n-        return arrayS;\n-    }\n-\n-    public byte[] getArrayS() {\n-        return getArrayS0().clone();\n+        return arrayS.clone();\n@@ -173,0 +169,1 @@\n+        \/\/ Parse private key material from PKCS8Key.decode()\n@@ -174,1 +171,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n@@ -197,0 +194,2 @@\n+\n+            \/\/ Validate parameters stored from PKCS8Key.decode()\n@@ -208,1 +207,0 @@\n-    @Override\n@@ -213,1 +211,1 @@\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS0());\n+        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,4 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.io.IOException;\n+import java.security.*;\n@@ -163,0 +161,8 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key = (PKCS8Key) XDHPrivateKeyImpl.parseKey((\n+                    (PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            XDHPublicKeyImpl result =\n+                new XDHPublicKeyImpl(p8key.getPubKeyEncoded());\n+            checkLockedParams(InvalidKeySpecException::new,\n+                result.getParams());\n+            return result;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            this.key = val.toByteArray();\n+            this.privKeyMaterial = val.toByteArray();\n@@ -70,1 +70,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -105,1 +105,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,3 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.security.*;\n@@ -156,0 +153,9 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key = null;\n+            try {\n+                p8key = new EdDSAPrivateKeyImpl(\n+                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            } catch (Exception e) {\n+                throw new InvalidKeyException(e);\n+            }\n+            return new EdDSAPublicKeyImpl(p8key.getPubKeyEncoded());\n@@ -157,2 +163,2 @@\n-            throw new InvalidKeySpecException(\n-                \"Only X509EncodedKeySpec and EdECPublicKeySpec are supported\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \"not supported\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-            this.key = val.toByteArray();\n+            privKeyMaterial = val.toByteArray();\n@@ -74,1 +74,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -84,2 +84,2 @@\n-        if (params.getKeyLength() != this.h.length) {\n-            throw new InvalidKeyException(\"key length is \" + this.h.length +\n+        if (params.getKeyLength() != h.length) {\n+            throw new InvalidKeyException(\"key length is \" + h.length +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,11 @@\n-import java.io.*;\n-import java.security.Key;\n-import java.security.KeyRep;\n-import java.security.PrivateKey;\n-import java.security.KeyFactory;\n-import java.security.MessageDigest;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.DerInputStream;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.security.*;\n@@ -40,4 +43,0 @@\n-import jdk.internal.access.SharedSecrets;\n-import sun.security.x509.*;\n-import sun.security.util.*;\n-\n@@ -46,1 +45,1 @@\n- *\n+ * <p>\n@@ -58,1 +57,1 @@\n- *\n+ * <p>\n@@ -71,1 +70,1 @@\n-    protected byte[] key;\n+    protected byte[] privKeyMaterial;\n@@ -76,0 +75,3 @@\n+    \/* The encoded x509 public key for v2 *\/\n+    protected byte[] pubKeyEncoded = null;\n+\n@@ -79,0 +81,2 @@\n+    private byte[] attributes;\n+    private int version;\n@@ -83,1 +87,1 @@\n-     * {@link #algid} and {@link #key}.\n+     * {@link #algid} and {@link #privKeyMaterial}.\n@@ -94,1 +98,1 @@\n-    protected PKCS8Key(byte[] input) throws InvalidKeyException {\n+    public PKCS8Key(byte[] input) throws InvalidKeyException {\n@@ -102,0 +106,16 @@\n+    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+        throws InvalidKeyException {\n+        this(privEncoding);\n+        pubKeyEncoded = pubEncoding;\n+        version = V2;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    \/**\n+     * Method for decoding PKCS8 v1 and v2 formats. Decoded values are stored\n+     * in this class, key material remains in DER format for algorithm\n+     * subclasses to decode.\n+     *\/\n@@ -108,1 +128,2 @@\n-            int version = val.data.getInteger();\n+            \/\/ Support check for V1, aka 0, and V2, aka 1.\n+            version = val.data.getInteger();\n@@ -112,2 +133,5 @@\n-            algid = AlgorithmId.parse (val.data.getDerValue ());\n-            key = val.data.getOctetString();\n+            \/\/ Parse and store AlgorithmID\n+            algid = AlgorithmId.parse(val.data.getDerValue());\n+\n+            \/\/ Store key material for subclasses to parse\n+            privKeyMaterial = val.data.getOctetString();\n@@ -115,1 +139,1 @@\n-            DerValue next;\n+            \/\/ PKCS8 v1 typically ends here\n@@ -119,2 +143,8 @@\n-            next = val.data.getDerValue();\n-            if (next.isContextSpecific((byte)0)) {\n+\n+            \/\/ OPTIONAL Context tag 0 for Attributes for PKCS8 v1 & v2\n+            \/\/ Uses 0xA0 constructed define-length\n+            var result = val.data.getOptionalConstructed(0,\n+                DerValue.tag_Sequence);\n+            if (result.isPresent()) {\n+                attributes = new DerInputStream(result.get().getDataBytes()).\n+                    toByteArray();\n@@ -124,1 +154,0 @@\n-                next = val.data.getDerValue();\n@@ -127,3 +156,8 @@\n-            if (next.isContextSpecific((byte)1)) {\n-                if (version == V1) {\n-                    throw new InvalidKeyException(\"publicKey seen in v1\");\n+            \/\/ OPTIONAL context tag 1 for Public Key for PKCS8 v2 only\n+            if (version == V2) {\n+                result = val.data.getOptionalImplicitContextSpecific(1,\n+                    DerValue.tag_BitString);\n+                if (result.isPresent()) {\n+                    \/\/ Store public key material for later parsing\n+                    pubKeyEncoded = new X509Key(algid,\n+                        result.get().getUnalignedBitString()).getEncoded();\n@@ -135,0 +169,1 @@\n+\n@@ -159,1 +194,1 @@\n-    public static PrivateKey parseKey(byte[] encoded) throws IOException {\n+    public static PrivateKey parseKey(byte[] encoded) throws InvalidKeyException {\n@@ -162,2 +197,3 @@\n-            byte[] internal = rawKey.getEncodedInternal();\n-            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(internal);\n+            byte[] internal = rawKey.generateEncoding();\n+            PKCS8EncodedKeySpec pkcs8KeySpec =\n+                new PKCS8EncodedKeySpec(internal);\n@@ -179,2 +215,2 @@\n-        } catch (InvalidKeyException e) {\n-            throw new IOException(\"corrupt private key\", e);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(e);\n@@ -191,0 +227,12 @@\n+    public byte[] getPubKeyEncoded() {\n+        return pubKeyEncoded;\n+    }\n+\n+    public byte[] getPrivKeyMaterial() {\n+        return privKeyMaterial;\n+    }\n+\n+    public boolean hasPublicKey() {\n+        return (pubKeyEncoded == null ? false : true);\n+    }\n+\n@@ -194,1 +242,1 @@\n-    public AlgorithmId  getAlgorithmId () {\n+    public AlgorithmId getAlgorithmId () {\n@@ -213,0 +261,20 @@\n+    \/**\n+     * With a given encoded Public and Private key, generate and return a\n+     * PKCS8v2 DER-encoded byte[].\n+     *\n+     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param privKeyEncoded DER-encoded PrivateKey\n+     * @return DER-encoded byte array\n+     * @throws IOException thrown on encoding failure\n+     *\/\n+    public static byte[] getEncoded(byte[] pubKeyEncoded, byte[] privKeyEncoded)\n+        throws IOException {\n+        PKCS8Key privKey;\n+        try {\n+            privKey = new PKCS8Key(privKeyEncoded, pubKeyEncoded);\n+        } catch (InvalidKeyException e) {\n+            throw new IOException(e);\n+        }\n+        return privKey.generateEncoding();\n+    }\n+\n@@ -221,7 +289,22 @@\n-            DerOutputStream tmp = new DerOutputStream();\n-            tmp.putInteger(V1);\n-            algid.encode(tmp);\n-            tmp.putOctetString(key);\n-            DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-            encodedKey = out.toByteArray();\n-            out.clear();\n+            try {\n+                encodedKey = generateEncoding();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+                \/\/ encodedKey is still null\n+            }\n+        }\n+        return encodedKey;\n+    }\n+\n+    private byte[] generateEncoding() throws IOException {\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger((pubKeyEncoded == null) ? 0 : 1);\n+        algid.encode(out);\n+        out.putOctetString(privKeyMaterial);\n+\n+        if (attributes != null) {\n+            out.writeImplicit(\n+                DerValue.createTag((byte) (DerValue.TAG_CONTEXT |\n+                    DerValue.TAG_CONSTRUCT), false, (byte) 0),\n+                new DerOutputStream().putOctetString(attributes));\n+\n@@ -229,0 +312,13 @@\n+\n+        if (pubKeyEncoded != null) {\n+            X509Key x = (X509Key) X509Key.parseKey(pubKeyEncoded);\n+            DerOutputStream pubOut = new DerOutputStream();\n+            pubOut.putUnalignedBitString(x.getKey());\n+            out.writeImplicit(\n+                DerValue.createTag(DerValue.TAG_CONTEXT, false, (byte) 1),\n+                pubOut);\n+        }\n+\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        encodedKey = val.toByteArray();\n+        val.clear();\n@@ -301,1 +397,1 @@\n-        Arrays.fill(key, (byte)0);\n+        Arrays.fill(privKeyMaterial, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":138,"deletions":42,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -84,1 +84,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPrivateKey.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -303,2 +303,2 @@\n-        } catch (IOException ioe) {\n-            throw new UnrecoverableKeyException(ioe.getMessage());\n+        } catch (InvalidKeyException e) {\n+            throw new UnrecoverableKeyException(e.getMessage());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import sun.security.util.Pem;\n@@ -559,81 +560,3 @@\n-            \/\/ Read BASE64 encoded data, might skip info at the beginning\n-            ByteArrayOutputStream data = new ByteArrayOutputStream();\n-\n-            \/\/ Step 1: Read until header is found\n-            int hyphen = (c=='-') ? 1: 0;   \/\/ count of consequent hyphens\n-            int last = (c=='-') ? -1: c;    \/\/ the char before hyphen\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    \/\/ We accept useless data after the last block,\n-                    \/\/ say, empty lines.\n-                    return null;\n-                }\n-                if (next == '-') {\n-                    hyphen++;\n-                } else {\n-                    hyphen = 0;\n-                    last = next;\n-                }\n-                if (hyphen == 5 && (last == -1 || last == '\\r' || last == '\\n')) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 2: Read the rest of header, determine the line end\n-            int end;\n-            StringBuilder header = new StringBuilder(\"-----\");\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next == '\\n') {\n-                    end = '\\n';\n-                    break;\n-                }\n-                if (next == '\\r') {\n-                    next = is.read();\n-                    if (next == -1) {\n-                        throw new IOException(\"Incomplete data\");\n-                    }\n-                    if (next == '\\n') {\n-                        end = '\\n';\n-                    } else {\n-                        end = '\\r';\n-                        \/\/ Skip all white space chars\n-                        if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                            data.write(next);\n-                        }\n-                    }\n-                    break;\n-                }\n-                header.append((char)next);\n-            }\n-\n-            \/\/ Step 3: Read the data\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next != '-') {\n-                    \/\/ Skip all white space chars\n-                    if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                        data.write(next);\n-                    }\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 4: Consume the footer\n-            StringBuilder footer = new StringBuilder(\"-\");\n-            while (true) {\n-                int next = is.read();\n-                \/\/ Add next == '\\n' for maximum safety, in case endline\n-                \/\/ is not consistent.\n-                if (next == -1 || next == end || next == '\\n') {\n-                    break;\n-                }\n-                if (next != '\\r') footer.append((char)next);\n+            Pem pem = Pem.readPEM(is, (c == '-' ? true : false));\n+            if (pem == null) {\n+                return null;\n@@ -641,4 +564,0 @@\n-\n-            checkHeaderFooter(header.toString().stripTrailing(),\n-                    footer.toString().stripTrailing());\n-\n@@ -646,1 +565,1 @@\n-                return Base64.getDecoder().decode(data.toByteArray());\n+                return Base64.getDecoder().decode(pem.getData());\n@@ -653,18 +572,0 @@\n-    private static void checkHeaderFooter(String header,\n-            String footer) throws IOException {\n-        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n-                !header.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal header: \" + header);\n-        }\n-        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n-                !footer.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal footer: \" + footer);\n-        }\n-        String headerType = header.substring(11, header.length()-5);\n-        String footerType = footer.substring(9, footer.length()-5);\n-        if (!headerType.equals(footerType)) {\n-            throw new IOException(\"Header and footer do not match: \" +\n-                    header + \" \" + footer);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":6,"deletions":105,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -336,0 +337,9 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key;\n+            try {\n+                p8key = new PKCS8Key(((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            } catch (Exception e) {\n+                throw new GeneralSecurityException(e);\n+            }\n+            return RSAPublicKeyImpl.newKey(type, \"X.509\",\n+                p8key.getPubKeyEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+    \/\/ RSA or RSS-PSS KeyType\n@@ -104,1 +105,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -240,1 +241,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -307,1 +308,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -340,1 +341,1 @@\n-            BigInteger[] comps = parseASN1(key);\n+            BigInteger[] comps = parsePKCS1(privKeyMaterial);\n@@ -354,0 +355,25 @@\n+    \/**\n+     * With a given PKCS#1\/slleay\/OpenSSL old default RSA binary encoding,\n+     * decode and return the proper RSA encoded KeySpec\n+     * @param encoded RSA binary encoding\n+     * @return KeySpec\n+     * @throws InvalidKeyException on decoding failure\n+     *\/\n+\n+    public static KeySpec getKeySpec(byte[] encoded) throws\n+        InvalidKeyException {\n+        try {\n+            BigInteger[] comps = parsePKCS1(encoded);\n+            if ((comps[1].signum() == 0) || (comps[3].signum() == 0) ||\n+                (comps[4].signum() == 0) || (comps[5].signum() == 0) ||\n+                (comps[6].signum() == 0) || (comps[7].signum() == 0)) {\n+                return new RSAPrivateKeySpec(comps[0], comps[2]);\n+            } else {\n+                return new RSAPrivateCrtKeySpec(comps[0],\n+                    comps[1], comps[2], comps[3], comps[4], comps[5],\n+                    comps[6], comps[7]);\n+            }\n+        } catch (IOException ioe) {\n+            throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -202,1 +202,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -221,1 +221,1 @@\n-            BigInteger[] comps = parseASN1(getKey().toByteArray());\n+            BigInteger[] comps = parsePKCS1(getKey().toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -412,0 +412,22 @@\n+\n+    \/**\n+     * Returns the restored DerValue if the next DerValue is\n+     * an constructed define-length value tagged by {@code n}.\n+     *\n+     * @param n the expected tag\n+     * @param tag the real tag for the IMPLICIT type\n+     * @return the restored DerValue, or empty if not found or stream at end\n+     * @throws IOException if an I\/O error happens\n+     *\/\n+\n+    public Optional<DerValue> getOptionalConstructed(int n, byte tag)\n+        throws IOException {\n+        if (checkNextTag(t -> (t & 0x0c0) == 0x080 && (t & 0x020) == 0x020 &&\n+            (t & 0x01f) == n)) {\n+            DerValue v = getDerValue(); \/\/ [n]\n+            \/\/ restore tag because IMPLICIT has overwritten it\n+            return Optional.of(v.withTag(tag));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    public static final byte TAG_CONSTRUCT = (byte)0x020;\n@@ -194,1 +195,1 @@\n-     * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.\n+     * Returns true if the CONTEXT SPECIFIC bit is set in the type tag.\n@@ -200,1 +201,1 @@\n-     * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.\n+     * Returns true if the CONTEXT SPECIFIC TAG matches the passed tag.\n@@ -211,1 +212,1 @@\n-    \/** Returns true iff the CONSTRUCTED bit is set in the type tag. *\/\n+    \/** Returns true if the CONSTRUCTED bit is set in the type tag. *\/\n@@ -215,1 +216,1 @@\n-     * Returns true iff the CONSTRUCTED TAG matches the passed tag.\n+     * Returns true if the CONSTRUCTED TAG matches the passed tag.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -448,0 +449,50 @@\n+\n+    \/**\n+     * With a given DER encoded bytes, read through and return the AlgorithmID\n+     * stored if it can be found.\n+     *\n+     * @param encoded DER encoded bytes\n+     * @return AlgorithmID stored in the DER encoded bytes\n+     * @throws IOException\n+     *\/\n+    public static AlgorithmId getAlgorithm(byte[] encoded) throws IOException {\n+        DerInputStream is = new DerInputStream(encoded);\n+        DerValue value = is.getDerValue();\n+        if (value.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Unknown DER Format:  Value 1 not a Sequence\");\n+        }\n+\n+        is = value.data;\n+        value = is.getDerValue();\n+        \/\/ This route is for:  RSAPublic, Encrypted RSAPrivate, EC Public,\n+        \/\/ Encrypted EC Private,\n+        if (value.tag == DerValue.tag_Sequence) {\n+            return AlgorithmId.parse(value);\n+        } else if (value.tag == DerValue.tag_Integer) {\n+            \/\/ RSAPrivate, ECPrivate\n+            \/\/ current value is version, which can be ignored\n+            value = is.getDerValue();\n+            if (value.tag == DerValue.tag_OctetString) {\n+                value = is.getDerValue();\n+                if (value.tag == DerValue.tag_Sequence) {\n+                    return AlgorithmId.parse(value);\n+                } else {\n+                    \/\/ OpenSSL\/X9.62 (0xA0)\n+                    ObjectIdentifier oid = value.data.getOID();\n+                    AlgorithmId algo = new AlgorithmId(oid, (AlgorithmParameters) null);\n+                    if (CurveDB.lookup(algo.getName()) != null) {\n+                        return new AlgorithmId(AlgorithmId.EC_oid);\n+                    }\n+\n+                }\n+\n+            } else if (value.tag == DerValue.tag_Sequence) {\n+                \/\/ Public Key\n+                return AlgorithmId.parse(value);\n+            }\n+\n+        }\n+        throw new IOException(\"No algorithm detected\");\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import java.io.IOException;\n+import sun.security.x509.AlgorithmId;\n+\n+import java.io.*;\n@@ -30,0 +32,3 @@\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Security;\n+import java.util.Arrays;\n@@ -31,0 +36,2 @@\n+import java.util.HexFormat;\n+import java.util.Objects;\n@@ -37,0 +44,71 @@\n+    \/**\n+     * Public Key PEM header & footer\n+     *\/\n+    public static final byte[] PUBHEADER = \"-----BEGIN PUBLIC KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+    public static final byte[] PUBFOOTER = \"-----END PUBLIC KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    \/**\n+     * Private Key PEM header & footer\n+     *\/\n+    public static final byte[] PKCS8HEADER = \"-----BEGIN PRIVATE KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+    public static final byte[] PKCS8FOOTER = \"-----END PRIVATE KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    \/**\n+     * Encrypted Private Key PEM header & footer\n+     *\/\n+    public static final byte[] PKCS8ENCHEADER = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+    public static final byte[] PKCS8ENCFOOTER = \"-----END ENCRYPTED PRIVATE KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    \/**\n+     * Certificate PEM header & footer\n+     *\/\n+    public static final byte[] CERTHEADER = \"-----BEGIN CERTIFICATE-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+    public static final byte[] CERTFOOTER = \"-----END CERTIFICATE-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    \/**\n+     * CRL PEM header & footer\n+     *\/\n+    public static final byte[] CRLHEADER = \"-----BEGIN X509 CRL-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+    public static final byte[] CRLFOOTER = \"-----END X509 CRL-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    \/**\n+     * PKCS#1\/slleay\/OpenSSL RSA PEM header & footer\n+     *\/\n+    public static final byte[] PKCS1HEADER = \"-----BEGIN RSA PRIVATE KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+    public static final byte[] PKCS1FOOTER = \"-----END RSA PRIVATE KEY-----\"\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    public static final byte[] LINESEPARATOR = System.lineSeparator()\n+        .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    public enum KeyType {\n+        UNKNOWN, PRIVATE, PUBLIC, ENCRYPTED_PRIVATE, CERTIFICATE, CRL, PKCS1\n+    }\n+\n+    private static final char WS = 0x20;  \/\/ Whitespace\n+\n+    \/\/ Default algorithm from jdk.epkcs8.defaultAlgorithm in java.security\n+    public static final String DEFAULT_ALGO;\n+    static {\n+        DEFAULT_ALGO = Security.getProperty(\"jdk.epkcs8.defaultAlgorithm\");\n+    }\n+\n+    private byte[] header, footer;\n+    private byte[] data;\n+\n+    private Pem(byte[] header, byte[] data, byte[] footer) {\n+        this.header = header;\n+        this.data = data;\n+        this.footer = footer;\n+    }\n@@ -45,1 +123,1 @@\n-    public static byte[] decode(String input) throws IOException {\n+    public static byte[] decode(String input) {\n@@ -47,2 +125,1 @@\n-                .getBytes(StandardCharsets.ISO_8859_1);\n-        try {\n+            .getBytes(StandardCharsets.ISO_8859_1);\n@@ -50,2 +127,100 @@\n-        } catch (IllegalArgumentException e) {\n-            throw new IOException(e);\n+    }\n+\n+    \/**\n+     * Extract the OID from the PBE algorithm.  PBEKS2, which are all AES-based,\n+     * has uses one OID for all the standard algorithm, while PBEKS1 uses\n+     * individual ones.\n+     *\/\n+    public static ObjectIdentifier getPBEID(String algorithm) {\n+        try {\n+            if (algorithm.contains(\"AES\")) {\n+                return AlgorithmId.get(\"PBES2\").getOID();\n+            } else {\n+                return AlgorithmId.get(algorithm).getOID();\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    public static Pem readPEM(InputStream is) throws IOException {\n+        return readPEM(is, false);\n+    }\n+\n+    \/**\n+     * Read the PEM text and return it in it's three components:  header,\n+     * base64, and footer\n+     * @param is The pem data\n+     * @param shortHeader if true, the hyphen length is 4 because the first\n+     *                    hyphen is assumed to have been read.\n+     * @return A new Pem object containing the three components\n+     * @throws IOException on read errors\n+     *\/\n+    public static Pem readPEM(InputStream is, boolean shortHeader)\n+        throws IOException{\n+        Objects.requireNonNull(is);\n+\n+        int hyphen = (shortHeader ? 1 : 0);\n+        int endchar = 0;\n+\n+        \/\/ Find starting hyphens\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> {\n+                    return null;\n+                }\n+                default -> hyphen = 0;\n+            }\n+        } while (hyphen != 5);\n+\n+        StringBuilder sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+        hyphen = 0;\n+        int c;\n+\n+        \/\/ Get header definition until first hyphen\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                case '\\n', '\\r' -> throw new IllegalArgumentException(\n+                    \"Incomplete header\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify header ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                default ->\n+                    throw new IllegalArgumentException(\"Incomplete header\");\n+            }\n+        } while (hyphen < 5);\n+\n+        sb.append(\"-----\");\n+        String header = sb.toString();\n+        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n+            !header.endsWith(\"-----\")) {\n+            throw new IllegalArgumentException(\"Illegal header: \" + header);\n+        }\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(1024);\n+\n+        \/\/ Determine the line break using the char after the last hyphen\n+        switch (c = is.read()) {\n+            case WS -> {} \/\/ skip char\n+            case '\\r' -> {\n+                c = is.read();\n+                if (c == '\\n') {\n+                    endchar = '\\n';\n+                } else {\n+                    endchar = '\\r';\n+                    sb.append((char) c);\n+                }\n+            }\n+            case '\\n' -> endchar = '\\n';\n+            default -> sb.append((char) c);\n@@ -53,0 +228,92 @@\n+\n+        \/\/ Read data until we find the first footer hyphen.\n+        do {\n+            switch (c = is.read()) {\n+                case -1 ->\n+                    throw new IllegalArgumentException(\"Incomplete header\");\n+                case '-' -> hyphen++;\n+                case 9, '\\n', '\\r', WS -> {} \/\/ skip char\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        String data = sb.toString();\n+\n+        \/\/ Verify footer starts with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> throw new IllegalArgumentException(\n+                    \"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+\n+        \/\/ Look for Complete header by looking for the end of the hyphens\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> throw new IllegalArgumentException(\n+                    \"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        if (endchar != 0) {\n+            while ((c = is.read()) != endchar && c != -1 && c != '\\r' &&\n+                c != WS) {\n+                throw new IllegalArgumentException(\"Invalid PEM format:  \" +\n+                    \"No end of line char found in footer:  0x\" +\n+                    HexFormat.of().toHexDigits((byte) c));\n+            }\n+        }\n+\n+        sb.append(\"-----\");\n+        String footer = sb.toString();\n+        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n+            !footer.endsWith(\"-----\")) {\n+            throw new IOException(\"Illegal footer: \" + footer);\n+        }\n+\n+        String headerType = header.substring(11, header.length() - 5);\n+        String footerType = footer.substring(9, footer.length() - 5);\n+        if (!headerType.equals(footerType)) {\n+            throw new IOException(\"Header and footer do not match: \" +\n+                header + \" \" + footer);\n+        }\n+\n+        return new Pem(header.getBytes(StandardCharsets.ISO_8859_1),\n+            data.getBytes(StandardCharsets.ISO_8859_1),\n+            footer.getBytes(StandardCharsets.ISO_8859_1));\n+    }\n+\n+    public byte[] getData() {\n+        return data;\n+    }\n+\n+    public byte[] getHeader() {\n+        return header;\n+    }\n+\n+    public byte[] getFooter() {\n+        return footer;\n+    }\n+\n+    public void clean() {\n+        Arrays.fill(data, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":274,"deletions":7,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -86,1 +85,2 @@\n-    private X509Key(AlgorithmId algid, BitArray key) {\n+    @SuppressWarnings(\"this-escape\")\n+    public X509Key(AlgorithmId algid, BitArray key) {\n@@ -103,1 +103,1 @@\n-    protected BitArray getKey() {\n+    public BitArray getKey() {\n@@ -157,1 +157,1 @@\n-        encode();\n+        getEncodedInternal();\n@@ -246,1 +246,1 @@\n-    public AlgorithmId  getAlgorithmId() { return algid; }\n+    public AlgorithmId getAlgorithmId() { return algid; }\n@@ -263,1 +263,1 @@\n-    public byte[] getEncodedInternal() {\n+    private byte[] getEncodedInternal() {\n@@ -317,1 +317,1 @@\n-    void decode(DerValue val) throws InvalidKeyException {\n+    public void decode(DerValue val) throws InvalidKeyException {\n@@ -341,0 +341,18 @@\n+    \/**\n+     * Parses X509 public key.  With PKCS8v2 allowing public keys in private key\n+     * encoding, this method allows PKCS8Key access, but keeps the code in this\n+     * file.\n+     *\/\n+    public static PublicKey parseKey(byte[] encoded) throws IOException {\n+        PublicKey pubKey;\n+        try {\n+            X509EncodedKeySpec spec = new X509EncodedKeySpec(encoded);\n+            pubKey = KeyFactory.getInstance(spec.getAlgorithm())\n+                .generatePublic(spec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            \/\/ Ignore and return raw key\n+            throw new IOException(\"error with encoding\");\n+        }\n+        return pubKey;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1538,0 +1538,8 @@\n+\n+#\n+# Default algorithm for PEMEncoder Encrypted PKCS#8\n+#\n+# This property defines default Public-based Encryption algorithm for\n+# java.security.PEMEncoder is configured for encryption with `withEncryption()`.\n+#\n+jdk.epkcs8.defaultAlgorithm=PBEWithHmacSHA256AndAES_128\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.DEREncodable;\n+import java.security.cert.Certificate;\n+import java.security.interfaces.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Library class for PEMEncoderTest and PEMDecoderTest\n+ *\/\n+class PEMCerts {\n+    public static final String ecprivpem = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\\\n+        MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgkW3Jx561NlEgBnut\\\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqhRANCAASL+REY4vvAI9M3gonaml5K3lRgHq5w\\\n+        +OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fop224ANvB\\\n+        -----END PRIVATE KEY-----\\\n+        \"\"\";\n+\n+    public static final String privpem = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\\\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\\\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\\\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\\\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\\\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\\\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\\\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\\\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\\\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\\\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\\\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\\\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\\\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\\\n+        WqcWcoJqfdLEyBT+\\\n+        -----END PRIVATE KEY-----\\\n+        \"\"\";\n+\n+    public static final String privpembc = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\\\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\\\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\\\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\\\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\\\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\\\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\\\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\\\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\\\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\\\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\\\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\\\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\\\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\\\n+        WqcWcoJqfdLEyBT+\\\n+        -----END PRIVATE KEY-----\\\n+        \"\"\";\n+\n+    public static final String privpemed25519 = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\\\n+        MC4CAQAwBQYDK2VwBCIEIFFZsmD+OKk67Cigc84\/2fWtlKsvXWLSoMJ0MHh4jI4I\\\n+        -----END PRIVATE KEY-----\\\n+        \"\"\";\n+\n+    public static final String pubrsapem = \"\"\"\n+        -----BEGIN PUBLIC KEY-----\\\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\\\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\\\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\\\n+        XCYEHZS1cqd8wokFPwIDAQAB\\\n+        -----END PUBLIC KEY-----\\\n+        \"\"\";\n+\n+    public static final String pubrsapembc = \"\"\"\n+        -----BEGIN PUBLIC KEY-----\\\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\\\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\\\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\\\n+        XCYEHZS1cqd8wokFPwIDAQAB\\\n+        -----END PUBLIC KEY-----\\\n+        \"\"\";\n+\n+    public static final String pubrsaold =\n+        \"-----BEGIN PUBLIC KEY-----\\n\" +\n+            \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\\n\" +\n+            \"\/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\\n\" +\n+            \"MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\\n\" +\n+            \"XCYEHZS1cqd8wokFPwIDAQAB\\n\" +\n+            \"-----END PUBLIC KEY-----\\n\";\n+\n+    public static final String pubecpem =\n+        \"-----BEGIN PUBLIC KEY-----\\r\\n\" +\n+            \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi\/kRGOL7wCPTN4KJ2ppeSt5UYB6u\\r\\n\" +\n+            \"cPjjuKDtFTXbguOIFDdZ65O\/8HTUqS\/sVzRF+dg7H3\/tkQ\/36KdtuADbwQ==\\r\\n\" +\n+            \"-----END PUBLIC KEY-----\\r\\n\";\n+\n+    \/\/ EC key with explicit parameters -- Not currently supported by SunEC\n+    public static final String pubec_explicit = \"\"\"\n+        -----BEGIN PUBLIC KEY-----\\\n+        MIIBSzCCAQMGByqGSM49AgEwgfcCAQEwLAYHKoZIzj0BAQIhAP\/\/\/\/8AAAABAAAA\\\n+        AAAAAAAAAAAA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/MFsEIP\/\/\/\/8AAAABAAAAAAAAAAAAAAAA\/\/\/\/\\\n+        \/\/\/\/\/\/\/\/\/\/\/8BCBaxjXYqjqT57PrvVV2mIa8ZR0GsMxTsPY7zjw+J9JgSwMVAMSd\\\n+        NgiG5wSTamZ44ROdJreBn36QBEEEaxfR8uEsQkf4vOblY6RA8ncDfYEt6zOg9KE5\\\n+        RdiYwpZP40Li\/hp\/m47n60p8D54WK84zV2sxXs7LtkBoN79R9QIhAP\/\/\/\/8AAAAA\\\n+        \/\/\/\/\/\/\/\/\/\/+85vqtpxeehPO5ysL8YyVRAgEBA0IABIv5ERji+8Aj0zeCidqaXkre\\\n+        VGAernD447ig7RU124LjiBQ3WeuTv\/B01Kkv7Fc0RfnYOx9\/7ZEP9+inbbgA28E=\\\n+        -----END PUBLIC KEY-----\\\n+        \"\"\";\n+\n+    public static final String oasbcpem = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\\n\\\n+        MIIDCAIBATANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZbOdOvmvU3jl7+\\n\\\n+        cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW3qGR2DuBEaMy0mkg8hfKcSpH\\n\\\n+        LaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAEC\\n\\\n+        gYEAwNkDkTv5rlX8nWLuLJV5kh\/TH9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692\\n\\\n+        SdzR0dCSk7LGgN9qCYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\\n\\\n+        \/kI+EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5aeKZQSkNAX\\n\\\n+        G+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGPg6Wo1usF2bKqk8vjko9i\\n\\\n+        oZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZaJz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE\\n\\\n+        8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL\\n\\\n+        0lGPCiOLu9RcQp7L81aF79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57\\n\\\n+        AkBh75t86onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8ObWqcW\\n\\\n+        coJqfdLEyBT+gYGNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\/nLzxYC+TH6gwjOWvMiNMiJo\\n\\\n+        P4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGjMtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarb\\n\\\n+        D6D4yRY1hWHluiuOtzhxuueCuf9hXCYEHZS1cqd8wokFPwIDAQAB\\\n+        -----END PRIVATE KEY-----\\n\n+        \"\"\";\n+\n+    public static final String oasrfc8410 = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\\\n+        MHICAQEwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06\/nwoy\/HU++CXqI9EdVhC\\\n+        oB8wHQYKKoZIhvcNAQkJFDEPDA1DdXJkbGUgQ2hhaXJzgSEAGb9ECWmEzf6FQbrB\\\n+        Z9w7lshQhqowtrbLDFw4rXAxZuE=\\\n+        -----END PRIVATE KEY-----\\\n+        \"\"\";\n+\n+    public static final String rsaOpenSSL = \"\"\"\n+        -----BEGIN RSA PRIVATE KEY-----\\\n+        MIIEowIBAAKCAQEAqozTLan1qFcOCWnS63jXQn5lLyGOKDv3GM11n2zkGGrChayj\\\n+        cSzB2KTlDmN9NgOyFdqGNWbSgdmXR5ToHGHYwaKubJoQIoPQcsipWDI156d3+X\/8\\\n+        BxCGY8l5nYwvS4olOXc+2kEjeFF1eamnm9IQ5DHZfaFPl0ri4Yfm1YHBAbt\/7HvF\\\n+        3MBjgBj1xSsSFLW4O6ws6guRVGDfKBVyyRNUhRTbSua\/nEz0wAjxF2PWT+ZTHS6M\\\n+        0siYwVTuPI4\/n4ItoYoahvGb9JskkXP+bc\/QZJCTFYdyxF5tKqVMSdYaJTxop02p\\\n+        Jo3oeafVKSlBrr0K731xgNBKqBud44aKT5R96QIDAQABAoIBAQCD9Q\/T7gOvayPm\\\n+        LqXOISJURV1emRTXloX5\/8Y5QtQ8\/CVjrg6Lm3ikefjsKBgR+cwJUpmyqcrIQyXk\\\n+        cZchlqdSMt\/IEW\/YdKqMlStJnRfOE+ok9lx2ztdcT9+0AWn6hXmFu\/i6f9nE1yoQ\\\n+        py6SxnbhSJyhsnTVd1CR9Uep\/InsHvYW\/15WlVMD1VuCSIt9sefqXwavbAfBaqbn\\\n+        mjwBB\/ulsqKhHSuRq\/QWqlj+jyGqhhYmTguC1Qwt0woDbThiHtK+suCTAlGBj\/A+\\\n+        IZ1U9d+VsHBcWDKBkxmlKWcJAGR3xXiKKy9vfzC+DU7L99kgay80VZarDyXgiy78\\\n+        9xMMzRMBAoGBANoxnZhu1bUFtLqTJ1HfDm6UB+1zVd2Mu4DXYdy\/AHjoaCLp05OQ\\\n+        0ZeyhO\/eXPT+eGpzCxkWD7465KO\/QDfnp54p\/NS73jaJVdWQHBhzJx1MymqURy3N\\\n+        JQeW4+ojzwSmVXcrs7Og6EBa4L+PWLpMLW2kODniCY+vp9f5LS6m8UPJAoGBAMgZ\\\n+        4rBw7B9YFZZW\/EE4eos4Q7KtA5tEP6wvCq04oxfiSytWXifYX0ToPp0CHhZlWOxk\\\n+        v9a\/BDGqM7AxAQJs7mmIvT5AT2V1w7oTbFPnnAo6pQtLcfaxdFFqr0h6t0sXSOKC\\\n+        rQeZAqqFqwuOyP7vT0goGlBruHkwS21NKkzCyzkhAoGAc2JjhbWu+8Cdt0CUPX5o\\\n+        ol9T5eTlFnkSuuqrTNIQzN+SGkxu341o2QDFvhdoLwLW6OwXhVeeUanROSqtKiMu\\\n+        B70Kf\/EtbMephXtk8CUNHTh7nmr1TSo8F8xakHoJQts3PQL2T9qal1W3nnWOpU4d\\\n+        g+qg9TMsfTiV2OdjVlVgJskCgYBSnjV1qjojuue22hVvDFW0c7en5z2M9wHfItEi\\\n+        sjbMnrdwnklj5Dd5qPZpNz2a+59ag0Kd9OJTazXKMoF7MeTCGB4ivMTLXHNCudBJ\\\n+        WGCZ7JrGbhEQzTX8g7L5lwlk7KlANLoiX++03lm\/\/OVKNR6j6ULsH33cM6+A4pJr\\\n+        fSYRYQKBgCr9iMTmL0x+n6AmMNecR+MhDxi99Oy0s2EBAYqN9g\/8yNgwM4KR0cjz\\\n+        EcgIOtkvoTrJ9Cquvuj+O7\/d2yNoH0SZQ4IYJKq47\/Z4kKhwXzJnBCCCBKgkjfub\\\n+        RTQSNnSEgTaBD29l7FrhNRHX9lIKFZ23caCTBS6o3q3+KgPbq7ao\\\n+        -----END RSA PRIVATE KEY-----\\\n+        \"\"\";\n+\n+    private static final String encEdECKey = \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+\n+    private static final String rsaCert = \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIErDCCApQCCQD7ndjWbI\/x0DANBgkqhkiG9w0BAQsFADAXMRUwEwYDVQQDDAxQ\n+        RU0gVGVzdCBSU0EwIBcNMjQwMTA5MjMzNDIwWhgPMjA1MTA1MjYyMzM0MjBaMBcx\n+        FTATBgNVBAMMDFBFTSBUZXN0IFJTQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC\n+        AgoCggIBAKgO\/Pciro8xn5iNjcVCR4IuXP+V1PNATtKAlMbWzwGVOupKgRcNeRbA\n+        N9RlljxSgEChIWs0\/DB9VsAw1wCIVeuIVxv0ZvhVAcuD8Yyl58eev1rptsSJhTkN\n+        YJFxEPSP2kfWDxS21ltbg1bnY\/c1SQbzWawDLJN16G+ICzQXo68UB5fCZV9Ugfgf\n+        9USPkCiC6aFt+RT7eQaN\/JrjtCm+mFf4VbK7jYW7D8AfjviEY1HQCnPoTjHBxdy+\n+        o5s4aIOx1Wuu9wMoGuLXgY3do5\/OSDCfByk7rc1drQB9GOKf2gkR8PL9TjK+R3Lq\n+        wCA0a3jlCBiGPlH3oeZJrnp7jhAh\/tVxbsd7yIdhQnasbiTfhew132AdPXoQE+ic\n+        PFoh8MMtG1bdzt8EbvePC3GOjeyIP6f2Ixrh3B6wXzzYmJqBwON+X8TLQolcI1pa\n+        Q7AUz5BScy3lO9nyJE\/FJkX+Mr6n7WCdudCrQNP+0M845UvkgFyf4FcM7uUVugBm\n+        AXy7sCqZgTeLdqHyTElMCoWzBa3MHKyiSCh8GUJH+I1yBY1gG95j3tITIOFvbZrk\n+        vDiMwNtV9T6Ta2mb0+38GfKjbI6PF4DVrzB6xc7Q6\/GwyhOb86YLOLlEHJfhuc+C\n+        Pdy8hQrrulm2jiCO\/skvHucABNJ2CENyWa7ljNJkcN6GNTziz4AhAgMBAAEwDQYJ\n+        KoZIhvcNAQELBQADggIBAKFQE2AgYgc7\/xzwveUAiZ55tfcds07UnazLCOdpz+JJ\n+        W4MOt\/1Qi9mUylqDEymfNZVLPd2dEjB4wJ57XBUjL+kXkH1SocuskxQPf05iz5zT\n+        pEwg2fTmU73ilKMs5Q113nBnL9ZZtlRKCh1Oc5LvLW799uVXnU4UdSpWOBU9ePGY\n+        +H1wUKf+e0\/BkveQsZERYcamH9O9U\/+h+bbhr3GpT1AVnuDRyF28OvRwARDCOVyy\n+        ifh+xCR3WCnNcgfwCoH6cE1aXDKHchlAAZtvjc1lLud7\/ECIg+15keVfTYk4HEbH\n+        j\/lprxyH7y99lMmRLQpnTve54RrZGGmg51UD7OmwPHLMGibfQkw6QgdNsggIYD6p\n+        L91spgRRB+i4PTovocndOMR2RYgQEelGNqv8MsoUC7oRNxPCHxIEGuUPH1Vf3jnk\n+        mTHbVzpjy57UtfcYp1uBFDf8WoWO1Mi6oXRw2YQA1YSMm1+3ftphxydcbRuBlS7O\n+        6Iiqk6XlFG9Dpd2jjAQQzJGtnC0QDgGz6\/KGp1bGEhRnOWju07eLWvPbyaX5zeSh\n+        8gOYV33zkPhziWJt4uFMFIi7N2DLEk5UVZv1KTLZlfPl55DRs7j\/Sb4vKHpB17AO\n+        meVknxVvifDVY0TIz57t28Accsk6ClBCxNPluPU\/8YLGAZJYsdDXjGcndQ13s5G7\n+        -----END CERTIFICATE-----\n+        \"\"\";\n+\n+    private static final String ecCert = \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIBFzCBvgIJAOGVk\/ky59ojMAoGCCqGSM49BAMCMBMxETAPBgNVBAMMCFBFTSB0\n+        ZXN0MCAXDTI0MDEwOTIzMzEwNloYDzIwNTEwNTI2MjMzMTA2WjATMREwDwYDVQQD\n+        DAhQRU0gdGVzdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGYI0jD7JZzw4RYD\n+        y9DCfaYNz0CHrpr9gJU5NXe6czvuNBdAOl\/lJGQ1pqpEQSQaMDII68obvQyQQyFY\n+        lU3G9QAwCgYIKoZIzj0EAwIDSAAwRQIgMwYld7aBzkcRt9mn27YOed5+n0xN1y8Q\n+        VEcFjLI\/tBYCIQDU3szDZ\/PK2mUZwtgQxLqHdh+f1JY0UwQS6M8QUvoDHw==\n+        -----END CERTIFICATE-----\n+        \"\"\";\n+\n+    \/\/ EC cert with explicit parameters -- Not currently supported by SunEC\n+    private static final String ecCertEX = \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIICrDCCAjMCCQDKAlI7uc1CVDAKBggqhkjOPQQDAjATMREwDwYDVQQDDAhQRU0g\n+        dGVzdDAgFw0yNDAxMDkyMzIxNTlaGA8yMDUxMDUyNjIzMjE1OVowEzERMA8GA1UE\n+        AwwIUEVNIHRlc3QwggHMMIIBZAYHKoZIzj0CATCCAVcCAQEwPAYHKoZIzj0BAQIx\n+        AP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/+\/\/\/\/\/wAAAAAAAAAA\/\/\/\/\n+        \/zB7BDD\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/v\/\/\/\/8AAAAAAAAA\n+        AP\/\/\/\/wEMLMxL6fiPufkmI4Fa+P4LRkYHZxu\/oFBEgMUCI9QE4daxlY5jYou0Z0q\n+        hcjt0+wq7wMVAKM1kmqjGaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCt\n+        dG4dO2KLp5uYWfdB4IJUKjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi\/kpLc\n+        Kfj0Hb0omhR86doxE7XwuMAKYLHOHX6BnXpDHXyQ6g5fAjEA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/x2NNgfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBA2IABO+IbTh6\n+        WqyzmxdCeJ0uUQ2v2jKxRuCKRyPlYAnpBmmQypsRS+GBdbBa0Mu6MTnVJh5uvqXn\n+        q7IuHVEiE3EFKw0DNW30nINuQg6lTv6PgN\/4nYBqsl5FQgzk2SYN3bw+7jAKBggq\n+        hkjOPQQDAgNnADBkAjATCnbbn3CgPRPi9Nym0hKpBAXc30D4eVB3mz8snK0oKU0+\n+        VP3F0EWcyM2QDSZCXIgCMHWknAhIGFTHxqypYUV8eAd3SY7ujZ6EPR0uG\/\/csBWG\n+        IqHcgr8slqi35ycQn5yMsQ==\n+        -----END CERTIFICATE-----\n+        \"\"\";\n+\n+    public record Entry(String name, String pem, Class clazz, char[] password) {\n+\n+        public Entry newEntry(Entry e, Class c) {\n+            return new Entry(e.name, e.pem, c, e.password);\n+        }\n+\n+\n+    }\n+\n+    static public Entry getEntry(String varname) {\n+        return getEntry(passList, varname);\n+    }\n+\n+    static public Entry getEntry(List<Entry> list, String varname) {\n+        for (Entry entry : list) {\n+            if (entry.name.compareToIgnoreCase(varname) == 0) {\n+                return entry;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static String makeCRLF(String pem) {\n+        return Pattern.compile(\"\/n\").matcher(pem).replaceAll(\"\/r\/n\");\n+    }\n+\n+    static String makeCR(String pem) {\n+        return Pattern.compile(\"\/n\").matcher(pem).replaceAll(\"\/r\");\n+    }\n+\n+    static String makeNoCRLF(String pem) {\n+        return Pattern.compile(\"\/n\").matcher(pem).replaceAll(\"\");\n+    }\n+\n+    static List<Entry> passList = new ArrayList<>();\n+    static List<Entry> entryList = new ArrayList<>();\n+    static List<Entry> pubList = new ArrayList<>();\n+    static List<Entry> privList = new ArrayList<>();\n+    static List<Entry> oasList = new ArrayList<>();\n+    static List<Entry> certList = new ArrayList<>();\n+    static List<Entry> encryptedList = new ArrayList<>();\n+    static List<Entry> failureEntryList = new ArrayList<>();\n+\n+    static {\n+        pubList.add(new Entry(\"pubrsapem\", pubrsapem, RSAPublicKey.class, null));\n+        pubList.add(new Entry(\"pubrsapembc\", pubrsapembc, RSAPublicKey.class, null));\n+        pubList.add(new Entry(\"pubecpem-r\", makeCR(pubecpem), ECPublicKey.class, null));\n+        pubList.add(new Entry(\"pubecpem-no\", makeNoCRLF(pubecpem), ECPublicKey.class, null));\n+        pubList.add(new Entry(\"pubecpem-rn\", makeCRLF(pubecpem), ECPublicKey.class, null));\n+        privList.add(new Entry(\"privpem\", privpem, RSAPrivateKey.class, null));\n+        privList.add(new Entry(\"privpembc\", privpembc, RSAPrivateKey.class, null));\n+        privList.add(new Entry(\"ecprivpem\", ecprivpem, ECPrivateKey.class, null));\n+        privList.add(new Entry(\"privpemed25519\", privpemed25519, EdECPrivateKey.class, null));\n+        privList.add(new Entry(\"encEdECKey-EPKI\", encEdECKey, EncryptedPrivateKeyInfo.class, null));\n+        privList.add(new Entry(\"rsaOpenSSL\", rsaOpenSSL, RSAPrivateKey.class, null));\n+        oasList.add(new Entry(\"oasrfc8410\", oasrfc8410, DEREncodable.class, null));\n+        oasList.add(new Entry(\"oasbcpem\", oasbcpem, DEREncodable.class, null));\n+\n+        certList.add(new Entry(\"rsaCert\", rsaCert, Certificate.class, null));\n+        certList.add(new Entry(\"ecCert\", ecCert, Certificate.class, null));\n+\n+        entryList.addAll(pubList);\n+        entryList.addAll(privList);\n+        entryList.addAll(oasList);\n+        entryList.addAll(certList);\n+\n+        encryptedList.add(new Entry(\"encEdECKey\", encEdECKey, EdECPrivateKey.class, \"fish\".toCharArray()));\n+        encryptedList.add(new Entry(\"encEdECKey2\", encEdECKey, EncryptedPrivateKeyInfo.class, \"fish\".toCharArray()));\n+\n+        passList.addAll(entryList);\n+        passList.addAll(encryptedList);\n+\n+        failureEntryList.add(new Entry(\"emptyPEM\", \"\", DEREncodable.class, null));\n+        failureEntryList.add(new Entry(\"nullPEM\", null, DEREncodable.class, null));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMCerts.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing basic PEM API decodings\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.lang.Class;\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.*;\n+import java.util.Arrays;\n+\n+public class PEMDecoderTest {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    PEMDecoderTest() {\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        System.out.println(\"Decoder test:\");\n+        PEMCerts.entryList.stream().forEach(entry -> test(entry));\n+        System.out.println(\"Decoder test returning DEREncodable class:\");\n+        PEMCerts.entryList.stream().forEach(entry -> test(entry, DEREncodable.class));\n+        System.out.println(\"Decoder test with encrypted PEM:\");\n+        PEMCerts.encryptedList.stream().forEach(entry -> testEncrypted(entry));\n+        System.out.println(\"Decoder test with OAS:\");\n+        testTwoKeys();\n+        System.out.println(\"Decoder test RSA PEM setting RSAKey.class returned:\");\n+        test(PEMCerts.getEntry(\"privpem\"), RSAKey.class);\n+        System.out.println(\"Decoder test failures:\");\n+        PEMCerts.failureEntryList.stream().forEach(entry -> testFailure(entry));\n+        System.out.println(\"Decoder test ECpriv PEM asking for ECPublicKey.class returned:\");\n+        testFailure(PEMCerts.getEntry(\"ecprivpem\"), ECPublicKey.class);\n+        System.out.println(\"Decoder test RSApriv PEM setting P8EKS.class returned:\");\n+        testClass(PEMCerts.getEntry(\"privpem\"), RSAPrivateKey.class);\n+        System.out.println(\"Decoder test RSApriv P1 PEM asking for RSAPublicKey.class returned:\");\n+        testFailure(PEMCerts.getEntry(PEMCerts.privList, \"rsaOpenSSL\"), RSAPublicKey.class);\n+        System.out.println(\"Decoder test RSApriv PEM asking X509EKS.class returned:\");\n+        testClass(PEMCerts.getEntry(\"privpem\"), X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test RSAcert PEM asking X509EKS.class returned:\");\n+        testClass(PEMCerts.getEntry(\"rsaCert\"), X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test OAS RFC PEM asking PrivateKey.class returned:\");\n+        testClass(PEMCerts.getEntry(\"oasrfc8410\"), PrivateKey.class, true);\n+        testClass(PEMCerts.getEntry(\"oasrfc8410\"), PublicKey.class, true);\n+        System.out.println(\"Decoder test encEdECkey:\");\n+    }\n+\n+    static void testFailure(PEMCerts.Entry entry) {\n+        testFailure(entry, entry.clazz());\n+    }\n+\n+    static void testFailure(PEMCerts.Entry entry, Class c) {\n+        try {\n+            test(entry.pem(), c, PEMDecoder.of());\n+            throw new AssertionError(\"Failure with \" +\n+                entry.name() + \":  Not supposed to succeed.\");\n+        } catch (NullPointerException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        } catch (IOException | RuntimeException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        }\n+    }\n+\n+    static void testEncrypted(PEMCerts.Entry entry) {\n+        PEMDecoder decoder = PEMDecoder.of();\n+        if (!Objects.equals(entry.clazz(), EncryptedPrivateKeyInfo.class)) {\n+            decoder = decoder.withDecryption(entry.password());\n+        }\n+\n+        try {\n+            test(entry.pem(), entry.clazz(), decoder);\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    \/\/ Change the Entry to use the given class as the expected class returned\n+    static void test(PEMCerts.Entry entry, Class c) {\n+        test(entry.newEntry(entry, c));\n+    }\n+\n+    \/\/ Run test with a given Entry\n+    static void test(PEMCerts.Entry entry) {\n+        try {\n+            test(entry.pem(), entry.clazz(), PEMDecoder.of());\n+            System.out.println(\"PASS (\" + entry.name() + \")\");\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    static List getInterfaceList(Class ccc) {\n+        Class<?>[] interfaces = ccc.getInterfaces();\n+        List<Class> list = new ArrayList<>(Arrays.asList(interfaces));\n+        var x = ccc.getSuperclass();\n+        if (x != null) {\n+            list.add(x);\n+        }\n+        List<Class> results = new ArrayList<>(list);\n+        if (list.size() > 0) {\n+            for (Class cname : list) {\n+                try {\n+                    if (cname != null &&\n+                        cname.getName().startsWith(\"java.security.\")) {\n+                        results.addAll(getInterfaceList(cname));\n+                    }\n+                } catch (Exception e) {\n+                    System.err.println(\"Exception with \" + cname);\n+                }\n+            }\n+        }\n+        return results;\n+    }\n+\n+    \/**\n+     * Perform the decoding test with the given decoder, on the given pem, and\n+     * expect the clazz to be returned.\n+     *\/\n+    static void test(String pem, Class clazz, PEMDecoder decoder) throws IOException {\n+        var pk = decoder.decode(pem);\n+\n+        \/\/ Check that clazz matches what pk returned.\n+        if (pk.getClass().equals(clazz)) {\n+            return;\n+        }\n+\n+        \/\/ Search interfaces and inheritance to find a match with clazz\n+        List<Class> list = getInterfaceList(pk.getClass());\n+        for (Class cc : list) {\n+            if (cc != null && cc.equals(clazz)) {\n+                return;\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Entry did not contain expected: \" +\n+            clazz.getName());\n+    }\n+\n+    \/\/ Run the same key twice through the same decoder and make sure the\n+    \/\/ result is the same\n+    static void testTwoKeys() throws IOException {\n+        PublicKey p1, p2;\n+        PEMDecoder pd = PEMDecoder.of();\n+        p1 = pd.decode(PEMCerts.pubrsapem, RSAPublicKey.class);\n+        p2 = pd.decode(PEMCerts.pubrsapem, RSAPublicKey.class);\n+        if (!Arrays.equals(p1.getEncoded(), p2.getEncoded())) {\n+            System.err.println(\"These two should have matched:\");\n+            System.err.println(hex.parseHex(new String(p1.getEncoded())));\n+            System.err.println(hex.parseHex(new String(p2.getEncoded())));\n+            throw new AssertionError(\"Two decoding of the same key failed to\" +\n+                \" match: \");\n+        }\n+    }\n+\n+    static void testClass(PEMCerts.Entry entry, Class clazz) throws IOException {\n+        var pk = PEMDecoder.of().decode(entry.pem(), clazz);\n+    }\n+\n+    static void testClass(PEMCerts.Entry entry, Class clazz, boolean pass) throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (pass) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing basic PEM API encoding\n+ *\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+public class PEMEncoderTest {\n+\n+    static Map<String, DEREncodable> keymap;\n+    final static Pattern CR = Pattern.compile(\"\\r\");\n+    final static Pattern LF = Pattern.compile(\"\\n\");\n+    final static Pattern LSDEFAULT = Pattern.compile(System.lineSeparator());\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        PEMEncoder encoder = PEMEncoder.of();\n+\n+        PEMCerts.entryList.remove(PEMCerts.getEntry(\"rsaOpenSSL\"));\n+        keymap = generateObjKeyMap(PEMCerts.entryList);\n+        System.out.println(\"Same instance Encoder test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        System.out.println(\"New instance Encoder test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance Encoder testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        System.out.println(\"New instance Encoder testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key, PEMEncoder.of()));\n+\n+        keymap = generateObjKeyMap(PEMCerts.encryptedList);\n+        System.out.println(\"Same instance Encoder match test:\");\n+        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        System.out.println(\"Same instance Encoder new withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        System.out.println(\"New instance Encoder and withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        try {\n+            encoder.withEncryption(null);\n+        } catch (Exception e) {\n+            if (!(e instanceof NullPointerException)) {\n+                throw new Exception(\"Should have been a NullPointerException thrown\");\n+            }\n+        }\n+    }\n+\n+    static Map generateObjKeyMap(List<PEMCerts.Entry> list) {\n+        Map<String, DEREncodable> keymap = new HashMap<>();\n+        PEMDecoder pemd = PEMDecoder.of();\n+        for (PEMCerts.Entry entry : list) {\n+            try {\n+                if (entry.password() != null) {\n+                    keymap.put(entry.name(), pemd.withDecryption(entry.password()).decode(entry.pem()));\n+                } else {\n+                    keymap.put(entry.name(), pemd.decode(entry.pem()));\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"Verify PEMDecoderTest passes before debugging this test.\");\n+                throw new AssertionError(\"Failed to initialize map on\" +\n+                    \" entry \\\"\" + entry.name() + \"\\\"\", e);\n+            }\n+        }\n+        return keymap;\n+    }\n+\n+    static void test(String key, PEMEncoder encoder) {\n+        byte[] result;\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            result = encoder.encode(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" + entry.name(), e);\n+        }\n+\n+        checkResults(entry, new String(result, StandardCharsets.UTF_8));\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testToString(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            result = encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" + entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testEncrypted(String key, PEMEncoder encoder) {\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            encoder.withEncryption(\n+                (entry.password() != null ? entry.password() :\n+                    \"fish\".toCharArray()))\n+                .encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failured with \" + entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testEncryptedMatch(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            PrivateKey akey = (PrivateKey) keymap.get(key);\n+            EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(entry.pem(),\n+                EncryptedPrivateKeyInfo.class);\n+            if (entry.password() != null) {\n+                EncryptedPrivateKeyInfo.encryptKey(akey, entry.password(),\n+                    Pem.DEFAULT_ALGO,\n+                    ekpi.getAlgParameters().getParameterSpec(PBEParameterSpec.class),\n+                    null);\n+            }\n+            result = encoder.encodeToString(ekpi);\n+        } catch (RuntimeException | InvalidParameterSpecException e) {\n+            throw new AssertionError(\"Encrypted encoder failured with \" + entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void checkResults(PEMCerts.Entry entry, String result) {\n+        String pem = new String(entry.pem());\n+        \/\/ The below matches the \\r\\n generated PEM with the PEM passed\n+        \/\/ into the test.\n+        pem = CR.matcher(pem).replaceAll(\"\");\n+        pem = LF.matcher(pem).replaceAll(\"\");\n+        result = LSDEFAULT.matcher(result).replaceAll(\"\");\n+        try {\n+            if (pem.compareTo(result) != 0) {\n+                System.out.println(\"expected:\\n\" + pem);\n+                System.out.println(\"generated:\\n\" + result);\n+                indexDiff(pem, result);\n+            }\n+        } catch (AssertionError e) {\n+            throw new AssertionError(\"Encoder PEM mismatch \" + entry.name(), e);\n+        }\n+    }\n+\n+    static void indexDiff(String a, String b) {\n+        String lenerr = \"\";\n+        int len = a.length();\n+        int lenb = b.length();\n+        if (len != lenb) {\n+            lenerr = \":  Length mismatch: \" + len + \" vs \" + lenb;\n+            len = Math.min(len, lenb);\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (a.charAt(i) != b.charAt(i)) {\n+                throw new AssertionError(\"Char mistmatch, index #\" + i + \"  (\" + a.charAt(i) + \" vs \" + b.charAt(i) + \")\" + lenerr);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,1 @@\n- * @compile -XDignore.symbol.file PKCS8Test.java\n- * @run testng PKCS8Test\n+ * @run main PKCS8Test\n@@ -44,2 +43,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n@@ -48,1 +45,0 @@\n-import sun.security.util.DerValue;\n@@ -65,2 +61,1 @@\n-    @Test\n-    public void test() throws IOException {\n+    public static void main(String[] args) throws Exception {\n@@ -74,1 +69,2 @@\n-        Assert.assertTrue(Arrays.equals(encodedKey, EXPECTED),\n+        if (!Arrays.equals(encodedKey, EXPECTED)) {\n+            throw new AssertionError(\n@@ -76,2 +72,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedKey));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedKey));\n+        }\n@@ -81,4 +78,3 @@\n-        Assert.assertEquals(decodedKey.getAlgorithm(), ALGORITHM);\n-        Assert.assertEquals(decodedKey.getFormat(), FORMAT);\n-        Assert.assertEquals(decodedKey.getAlgorithmId().toString(),\n-                EXPECTED_ALG_ID_CHRS);\n+        assert(ALGORITHM.equalsIgnoreCase(decodedKey.getAlgorithm()));\n+        assert(FORMAT.equalsIgnoreCase(decodedKey.getFormat()));\n+        assert(EXPECTED_ALG_ID_CHRS.equalsIgnoreCase(decodedKey.getAlgorithmId().toString()));\n@@ -87,1 +83,3 @@\n-        Assert.assertTrue(Arrays.equals(encodedOutput, EXPECTED),\n+        if (!Arrays.equals(encodedOutput, EXPECTED)) {\n+\n+            throw new AssertionError(\n@@ -89,2 +87,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedOutput));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedOutput));\n+        }\n@@ -94,8 +93,15 @@\n-        enlarge(1, \"810100\");  \/\/ public key for v2\n-        enlarge(1, \"8000\", \"810100\");  \/\/ both\n-\n-        Assert.assertThrows(() -> enlarge(2));  \/\/ bad ver\n-        Assert.assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n-        Assert.assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n-        Assert.assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n-        Assert.assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+\n+        \/\/ PKCSv2 testing done by PEMEncoder\/PEMDecoder tests\n+\n+        assertThrows(() -> enlarge(2));\n+        assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n+        assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n+        assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n+        assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+    }\n+\n+    private static void assertThrows(Runnable o) {\n+        try {\n+            o.run();\n+            throw new AssertionError(\"Test failed\");\n+        } catch (Exception e) {}\n@@ -110,1 +116,1 @@\n-    static void enlarge(int newVersion, String... fields) throws IOException {\n+    static void enlarge(int newVersion, String... fields) {\n@@ -119,4 +125,8 @@\n-        Assert.assertTrue(length < 127);\n-        original[1] = (byte)(length - 2);   \/\/ the length field inside DER\n-        original[4] = (byte)newVersion;     \/\/ the version inside DER\n-        PKCS8Key.parseKey(original);\n+        assert (length < 127);\n+        original[1] = (byte) (length - 2);   \/\/ the length field inside DER\n+        original[4] = (byte) newVersion;     \/\/ the version inside DER\n+        try {\n+            PKCS8Key.parseKey(original);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+    permission java.security.SecurityPermission\n+                       \"getProperty.jdk.epkcs8.defaultAlgorithm\";\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/policy","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}