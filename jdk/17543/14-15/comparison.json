{"files":[{"patch":"@@ -44,2 +44,2 @@\n- * {@code PEMDecoder} is an immutable class for decoding Privacy-Enhanced Mail\n- * (PEM) data.  PEM is a textual encoding used to store and transfer security\n+ * {@code PEMDecoder} is used for decoding Privacy-Enhanced Mail (PEM) data.\n+ * PEM is a textual encoding used to store and transfer security\n@@ -60,4 +60,0 @@\n- * A specified return class must implement {@link DEREncodable} and be an\n- * appropriate JCE object class for the PEM; otherwise an\n- * {@link IllegalArgumentException} is thrown.\n- *\n@@ -68,1 +64,12 @@\n- * <p> A new immutable {@code PEMDecoder} instance is created when configured\n+ * For decode methods that accept a {@code Class<S> tClass} as input, they can\n+ * modify the return type to a specific {@code DEREncodable} subclass.\n+ * For example, {@code ECPublicKey.class} can be used to cast a\n+ * {@code PublicKey} to a {@code ECPublicKey}. {@code tClass} can specify\n+ * the returned key object from a PEM containing a public and private key.\n+ * If only the private key is required, {@code PrivateKey.class} can be used.\n+ * {@class PEMRecord.class} is used for returning PEM text. If {@code tClass}\n+ * is set to {@code X509EncodedKeySpec.class}, the public key will be returned\n+ * in that format. If {@code tClass} doesn't match the PEM content, an\n+ * {@code IllegalArgumentException} will be thrown.\n+ *\n+ * <p> A new {@code PEMDecoder} instance is created when configured\n@@ -72,3 +79,5 @@\n- * will throw an {@link SecurityException}.  A decoder instance not configured\n- * with decryption returns a {@link EncryptedPrivateKeyInfo} with encrypted\n- * PEM.  {@code EncryptedPrivateKeyInfo} methods must be used to retrieve the\n+ * will throw an {@link RuntimeException}.\n+ *\n+ * <p> When encrypted PEM is used with a decoder not configured for decryption,\n+ * an {@link EncryptedPrivateKeyInfo} object is returned.\n+ * {@code EncryptedPrivateKeyInfo} methods must be used to retrieve the\n@@ -81,0 +90,2 @@\n+ * <p>This class is immutable and thread-safe.\n+\n@@ -85,1 +96,1 @@\n- *     PrivateKey priKey = pd.decode(priKeyPEM);\n+ *     PrivateKey priKey = pd.decode(priKeyPEM, PrivateKey.class);\n@@ -88,0 +99,2 @@\n+ * @see PEMEncoder\n+ *\n@@ -105,2 +118,1 @@\n-     * Creates an immutable instance with a specific KeyFactory and\/or\n-     * password.\n+     * Creates an instance with a specific KeyFactory and\/or password.\n@@ -117,2 +129,1 @@\n-     * Returns an instance of {@code PEMDecoder}.  This instance may be repeatedly used\n-     * to decode different PEM text.\n+     * Returns an instance of {@code PEMDecoder}.\n@@ -203,1 +214,5 @@\n-     * Decodes and returns a {@link DEREncodable} from the given string.\n+     * Decodes and returns a {@link DEREncodable} from the given {@code String}.\n+     *\n+     * <p>This method reads the {@code String} until PEM data is found or until\n+     * the end is reached.  Non-PEM data before the PEM header is ignored by\n+     * the decoder.\n@@ -226,1 +241,1 @@\n-     * <p>This method will read the {@code InputStream} until PEM data is\n+     * <p>This method reads the {@code InputStream} until PEM data is\n@@ -228,3 +243,1 @@\n-     * {@code InputStream} before the PEM header will be ignored by the decoder.\n-     * If only non-PEM data is found a {@link PEMRecord} is returned with that\n-     * data.\n+     * {@code InputStream} before the PEM header is ignored by the decoder.\n@@ -242,1 +255,13 @@\n-        return decode(pem);\n+        DEREncodable d = decode(pem);\n+        \/\/ If d is a PEMRecord, return no leadingData and if there is no type()\n+        \/\/ throw IAE.\n+        if (d instanceof PEMRecord p) {\n+            if (p.type() != null) {\n+                if (p.leadingData() != null) {\n+                    return new PEMRecord(p.type(), p.pem());\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"No PEM data found.\");\n+            }\n+        }\n+        return d;\n@@ -250,11 +275,0 @@\n-     * <p>\n-     * {@code tClass} can be used to change the return type instance:\n-     * <ul>\n-     * <li> Cast to a {@code DEREncodable} subclass, such\n-     * as an EC public key to a {@code ECPublicKey}.<\/li>\n-     * <li> Extract a key from a PEM with two keys, like taking only\n-     * {@code PrivateKey}<\/li>\n-     * <li> Convert to a different class, like storing the public key's\n-     * binary encoding in {@link X509EncodedKeySpec}.<\/li>\n-     * <li> Store the PEM a {@link PEMRecord}.<\/li>\n-     *<\/ul>\n@@ -269,0 +283,2 @@\n+     *\n+     * @see PEMDecoder for how {@code tClass} can be used.\n@@ -384,3 +400,3 @@\n-     * current instance that will use KeyFactory and CertificateFactory classes\n-     * from the specified {@link Provider}.  Any errors using the\n-     * {@code provider} will occur during decoding.\n+     * current instance that will use {@link KeyFactory} and\n+     * {@link CertificateFactory} classes from the specified {@link Provider}.\n+     * Any errors using the {@code provider} will occur during decoding.\n@@ -391,1 +407,1 @@\n-     * @param provider the Factory provider.\n+     * @param provider the factory provider.\n@@ -399,2 +415,2 @@\n-     * Returns a new {@code PEMDecoder} instance from the current instance\n-     * configured to decrypt encrypted PEM data with given password.\n+     * Returns a copy of this PEMDecoder that will decrypt encrypted PEM data\n+     * such as encrypted private keys with the specified password.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":54,"deletions":38,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n- * PEMEncoder is an immutable class for Privacy-Enhanced Mail (PEM)\n- * data.  PEM is a textual encoding used to store and transfer security\n+ * {@code PEMEncoder} is used for encoding Privacy-Enhanced Mail (PEM) data.\n+ * PEM is a textual encoding used to store and transfer security\n@@ -75,0 +75,2 @@\n+ * <p>This class is immutable and thread-safe.\n+ *\n@@ -84,0 +86,1 @@\n+ * @see PEMDecoder\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import sun.security.util.Pem;\n+\n@@ -38,1 +40,1 @@\n- * <p> Types with Java API representation, such as a {@link PrivateKey},\n+ * <p>Types with Java API representation, such as a {@link PrivateKey},\n@@ -42,1 +44,2 @@\n- * with {@code leadingData}.\n+ * with {@code leadingData}.  {@code leadingData} can depend on which\n+ * decode() methods is used.\n@@ -44,1 +47,1 @@\n- * <p> {@code PEMRecord} may have a null {@code type} and {@code pem} when\n+ * <p>{@code PEMRecord} may have a null {@code type} and {@code pem} when\n@@ -62,0 +65,3 @@\n+ *\n+ * @see PEMDecoder\n+ * @see PEMEncoder\n@@ -85,1 +91,3 @@\n-        if (type == null && pem == null && leadingData == null) {\n+        this.leadingData = (leadingData == null ? null : leadingData.clone());\n+\n+        if (type == null && pem == null && this.leadingData == null) {\n@@ -104,1 +112,0 @@\n-        this.leadingData = leadingData;\n@@ -145,0 +152,19 @@\n+\n+    \/**\n+     * Returns the leadingData that maybe stored in this record.\n+     * {@code null} will be returned if there is none.\n+     *\n+     * @return a copy of the leadingData.\n+     *\/\n+    public byte[] leadingData() {\n+        return (leadingData == null ? null : leadingData.clone());\n+    }\n+\n+    \/**\n+     * Returns the type and Base64 encoding in PEM format.  {@code leadingData}\n+     * is not returned by this method.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Pem.pemEncoded(this);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-public final class PKCS8EncodedKeySpec extends EncodedKeySpec implements\n+public non-sealed class PKCS8EncodedKeySpec extends EncodedKeySpec implements\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-public final class X509EncodedKeySpec extends EncodedKeySpec implements\n+public non-sealed class X509EncodedKeySpec extends EncodedKeySpec implements\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-public final class EncryptedPrivateKeyInfo implements DEREncodable {\n+public non-sealed class EncryptedPrivateKeyInfo implements DEREncodable {\n@@ -346,3 +346,6 @@\n-     * @throws IllegalArgumentException when an argument causes an\n-     * initialization error.\n-     * @throws SecurityException on a cryptographic errors.\n+     * @throws IllegalArgumentException on initialization errors based on the\n+     * arguments passed to the method. The cause may include\n+     * InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+     * or NoSuchPaddingException.\n+     * @throws RuntimeException on an encryption errors.  The cause may include\n+     * IllegalBlockSizeException, BadPaddingException, or InvalidKeyException.\n@@ -395,2 +398,5 @@\n-     * arguments passed to the method.\n-     * @throws SecurityException on a encryption errors.\n+     * arguments passed to the method.  The cause may include\n+     * InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+     * or NoSuchPaddingException.\n+     * @throws RuntimeException on an encryption errors. The cause may include\n+     * IllegalBlockSizeException, BadPaddingException, or InvalidKeyException.\n@@ -410,1 +416,1 @@\n-            throw new SecurityException(\"Security property \" +\n+            throw new RuntimeException(\"Security property \" +\n@@ -438,2 +444,5 @@\n-     *                                  arguments passed to the method.\n-     * @throws SecurityException on an encryption errors.\n+     * arguments passed to the method. The cause may include\n+     * InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+     * or NoSuchPaddingException.\n+     * @throws RuntimeException on an encryption errors.  The cause may include\n+     * IllegalBlockSizeException, BadPaddingException, or InvalidKeyException.\n@@ -459,1 +468,1 @@\n-            throw new SecurityException(\"Security property \" +\n+            throw new RuntimeException(\"Security property \" +\n@@ -499,1 +508,1 @@\n-            throw new SecurityException(e);\n+            throw new RuntimeException(e);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-                X509Key x = (X509Key) X509Key.parseKey(pubKeyEncoded);\n+                X509Key x = X509Key.parse(pubKeyEncoded);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -288,3 +288,1 @@\n-        return new PEMRecord(\n-            header.substring(11, header.lastIndexOf('-') - 4), data,\n-            preData);\n+        return new PEMRecord(headerType, data, preData);\n@@ -298,1 +296,2 @@\n-     * Construct a String-based encoding based off the type.\n+     * Construct a String-based encoding based off the type.  leadingData\n+     * is not used with this method.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-                                      in.data.getUnalignedBitString());\n+                in.data.getUnalignedBitString());\n@@ -143,0 +143,21 @@\n+    \/*\n+     * Parses X.509 subject public key DER and return it as a\n+     * X509Key.  Useful for PKCS8v2.\n+     *\/\n+    public static X509Key parse(byte[] encoded) throws IOException\n+    {\n+        DerValue in = new DerValue(encoded);\n+        AlgorithmId algorithm;\n+\n+        if (in.tag != DerValue.tag_Sequence)\n+            throw new IOException(\"corrupt subject key\");\n+\n+        algorithm = AlgorithmId.parse(in.data.getDerValue());\n+        BitArray keyBits = in.data.getUnalignedBitString();\n+\n+        if (in.data.available() != 0)\n+            throw new IOException(\"excess subject key\");\n+\n+        return new X509Key(algorithm, keyBits);\n+    }\n+\n@@ -341,6 +362,1 @@\n-    \/**\n-     * Parses X509 public key.  With PKCS8v2 allowing public keys in private key\n-     * encoding, this method allows PKCS8Key access, but keeps the code in this\n-     * file.\n-     *\/\n-    public static PublicKey parseKey(byte[] encoded) throws IOException {\n+  \/*  public static PublicKey parseKey(byte[] encoded) throws IOException {\n@@ -349,0 +365,1 @@\n+\n@@ -358,1 +375,1 @@\n-\n+*\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-    public static class FakeX509Spec extends EncodedKeySpec {\n+    public static class FakeX509Spec extends X509EncodedKeySpec {\n@@ -136,5 +136,0 @@\n-\n-        @Override\n-        public String getFormat() {\n-            return null;\n-        }\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        DEREncodable result = test(PEMData.ecCSRWithData);\n+        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEMRecord.class);\n@@ -137,0 +137,5 @@\n+        testPEMRecordDecode(PEMData.rsapub);\n+        testPEMRecordDecode(PEMData.ecCert);\n+        testPEMRecordDecode(PEMData.ec25519priv);\n+        testPEMRecordDecode(PEMData.ecCSR);\n+        testPEMRecordDecode(PEMData.ecCSRWithData);\n@@ -226,0 +231,27 @@\n+    static void testPEMRecordDecode(PEMData.Entry entry) {\n+        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        DEREncodable de = PEMDecoder.of().decode(r.toString());\n+\n+        boolean result = switch(r.type()) {\n+            case Pem.PRIVATE_KEY ->\n+                PrivateKey.class.isAssignableFrom(de.getClass());\n+            case Pem.PUBLIC_KEY ->\n+                PublicKey.class.isAssignableFrom(de.getClass());\n+            case Pem.CERTIFICATE, Pem.X509_CERTIFICATE ->\n+                (de instanceof X509Certificate);\n+            case Pem.X509_CRL -> (de instanceof X509CRL);\n+            case \"CERTIFICATE REQUEST\" -> (de instanceof PEMRecord);\n+            default -> false;\n+        };\n+\n+        if (!result) {\n+            System.err.println(\"Entry is a \" + entry.clazz().getName());\n+            System.err.println(\"PEMRecord type is a \" + r.type());\n+            System.err.println(\"Returned was a \" + entry.clazz().getName());\n+            throw new AssertionError(\"PEMRecord class didn't match:\" +\n+                entry.name());\n+        }\n+        System.out.println(\"Success (\" + entry.name() + \")\");\n+    }\n+\n+\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}