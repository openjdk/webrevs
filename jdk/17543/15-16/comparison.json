{"files":[{"patch":"@@ -44,1 +44,1 @@\n- * {@code PEMDecoder} is used for decoding Privacy-Enhanced Mail (PEM) data.\n+ * {@code PEMDecoder} implements a decoder for Privacy-Enhanced Mail (PEM) data.\n@@ -51,2 +51,3 @@\n- * <p> Decoding methods return an instance of a class that matches the data\n- * type and implements {@link DEREncodable} unless otherwise specified. The\n+ * <p> The {@linkplain #decode(String)} and {@linkplain #decode(InputStream)}\n+ * methods return an instance of a class that matches the data\n+ * type and implements {@link DEREncodable}. The\n@@ -64,9 +65,12 @@\n- * For decode methods that accept a {@code Class<S> tClass} as input, they can\n- * modify the return type to a specific {@code DEREncodable} subclass.\n- * For example, {@code ECPublicKey.class} can be used to cast a\n- * {@code PublicKey} to a {@code ECPublicKey}. {@code tClass} can specify\n- * the returned key object from a PEM containing a public and private key.\n- * If only the private key is required, {@code PrivateKey.class} can be used.\n- * {@class PEMRecord.class} is used for returning PEM text. If {@code tClass}\n- * is set to {@code X509EncodedKeySpec.class}, the public key will be returned\n- * in that format. If {@code tClass} doesn't match the PEM content, an\n+ * <p> The {@linkplain #decode(String, Class)} and\n+ * {@linkplain #decode(InputStream, Class)} methods take a Class parameter\n+ * which determines the type of {@code DEREncodable} that is returned. These\n+ * methods are useful when casting, extracting, or changing return class.\n+ * {@code ECPublicKey.class} can be used to cast a {@code PublicKey}\n+ * to a {@code ECPublicKey}. The Class parameter can specify the returned\n+ * key object from a PEM containing a public and private key.  If only\n+ * the private key is required, {@code PrivateKey.class} can be used.\n+ * If the Class parameter is set to {@code X509EncodedKeySpec.class}, the\n+ * public key will be returned in that format.  Any type of PEM data can be\n+ * decoded into a {@code PEMRecord} by specifying {@code PEMRecord.class}.\n+ * If the Class parameter doesn't match the PEM content, an\n@@ -76,1 +80,6 @@\n- * with {@linkplain #withFactory} and\/or {@linkplain #withDecryption}.\n+ * with {@linkplain #withFactory(Provider)} and\/or\n+ * {@linkplain #withDecryption(char[])}. {@linkplain #withFactory(Provider)}\n+ * configures the decoder to use only {@linkplain KeyFactory} and\n+ * {@linkplain CertificateFactory} instances from the given {@code Provider}.\n+ * {@link#withDecryption(char[])} configures the decoder to decrypt all\n+ * encrypted private key PEM data using the given password.\n@@ -79,6 +88,4 @@\n- * will throw an {@link RuntimeException}.\n- *\n- * <p> When encrypted PEM is used with a decoder not configured for decryption,\n- * an {@link EncryptedPrivateKeyInfo} object is returned.\n- * {@code EncryptedPrivateKeyInfo} methods must be used to retrieve the\n- * {@link PrivateKey}.\n+ * will throw a {@link RuntimeException}. When encrypted PEM is used with a\n+ * decoder not configured for decryption, an {@link EncryptedPrivateKeyInfo}\n+ * object is returned.  {@code EncryptedPrivateKeyInfo} methods must be used to\n+ * retrieve the {@link PrivateKey}.\n@@ -91,4 +98,3 @@\n-\n- * @apiNote\n- * Here is an example of decoding a PrivateKey object:\n- * <pre>\n+ *\n+ * <p> Here is an example of decoding a {@code PrivateKey} object:\n+ * {@snippet lang = java:\n@@ -97,1 +103,1 @@\n- * <\/pre>\n+ * }\n@@ -100,0 +106,2 @@\n+ * @see PEMRecord\n+ * @see EncryptedPrivateKeyInfo\n@@ -131,1 +139,1 @@\n-     * @return returns a {@code PEMDecoder}\n+     * @return new {@code PEMDecoder} instance\n@@ -144,0 +152,3 @@\n+        if (pem.type() == null) {\n+            return pem;\n+        }\n@@ -190,1 +201,2 @@\n-                case Pem.CERTIFICATE, Pem.X509_CERTIFICATE -> {\n+                case Pem.CERTIFICATE, Pem.X509_CERTIFICATE,\n+                     Pem.X_509_CERTIFICATE -> {\n@@ -195,1 +207,1 @@\n-                case Pem.X509_CRL -> {\n+                case Pem.X509_CRL, Pem.CRL -> {\n@@ -220,4 +232,3 @@\n-     * @param str a String containing PEM data.\n-     * @return a {@code DEREncodable} generated from the PEM data.\n-     * @throws IllegalArgumentException on error in decoding or if the PEM is\n-     * unsupported.\n+     * @param str a String containing PEM data\n+     * @return {@code DEREncodable} generated from the PEM data.\n+     * @throws IllegalArgumentException on error in decoding.\n@@ -245,5 +256,4 @@\n-     * @param is InputStream containing PEM data.\n-     * @return an {@code DEREncodable} generated from the data read.\n-     * @throws IOException on IO error with the InputStream.\n-     * @throws IllegalArgumentException on error in decoding or if the PEM is\n-     * unsupported.\n+     * @param is InputStream containing PEM data\n+     * @return {@code DEREncodable} generated from the data read.\n+     * @throws IOException on IO error with the InputStream\n+     * @throws IllegalArgumentException on error in decoding.\n@@ -276,1 +286,1 @@\n-     * @param str the String containing PEM data.\n+     * @param str the String containing PEM data\n@@ -279,1 +289,1 @@\n-     * @return a {@code DEREncodable} typecast to {@code tClass}.\n+     * @return {@code DEREncodable} typecast to {@code tClass}.\n@@ -303,1 +313,1 @@\n-     * @param is an InputStream containing PEM data.\n+     * @param is an InputStream containing PEM data\n@@ -306,1 +316,1 @@\n-     * @return a {@code DEREncodable} typecast to {@code tClass}.\n+     * @return {@code DEREncodable} typecast to {@code tClass}\n@@ -407,2 +417,2 @@\n-     * @param provider the factory provider.\n-     * @return a new PEM decoder instance.\n+     * @param provider the factory provider\n+     * @return new configured {@code PEMDecoder} instance\n@@ -421,1 +431,1 @@\n-     * @return a new PEM decoder instance.\n+     * @return new configured {@code PEMDecoder} instance\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":53,"deletions":43,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -55,3 +55,1 @@\n- * that implement {@link DEREncodable} and support\n- * {@linkplain PKCS8EncodedKeySpec PKCS#8} or\n- * {@linkplain X509EncodedKeySpec X509} formats.\n+ * that implement {@link DEREncodable}.\n@@ -59,3 +57,3 @@\n- * <p> Encrypted private key PEM data can be built by calling the encode methods\n- * on a PEMEncoder instance returned by {@link #withEncryption(char[])} or\n- * by passing an {@link EncryptedPrivateKeyInfo} object into the encode methods.\n+ * <p> Encrypted private key PEM data can be built by encoding with a\n+ * {@code PEMEncoder} instance returned by {@linkplain #withEncryption(char[])}\n+ * or by encoding an {@link EncryptedPrivateKeyInfo} .\n@@ -63,2 +61,2 @@\n- * <p> PKCS8 2.0 allows OneAsymmetricKey encoding, which may contain both private\n- * and public keys in the same PEM.This is supported by using the\n+ * <p> PKCS #8 2.0 allows OneAsymmetricKey encoding, which may contain both\n+ * private and public keys in the same PEM. This is supported by using the\n@@ -72,1 +70,1 @@\n- * <p>{@code String} values returned by this class use character set\n+ * <p>{@code String} values encoded use character set\n@@ -77,2 +75,1 @@\n- * @apiNote\n- * Here is an example of encoding a PrivateKey object:\n+ * <p>Here is an example of encoding a {@code PrivateKey} object:\n@@ -84,2 +81,7 @@\n- * @see PKCS8EncodedKeySpec\n- * @see X509EncodedKeySpec\n+ * <p>To make the {@code PEMEncoder} encrypt the above private key, only the\n+ * encryption method is needed.\n+ * {@snippet lang = java:\n+ *     PEMEncoder pe = PEMEncoder.of().withEncryption(password);\n+ *     byte[] pemData = pe.encode(privKey);\n+ * }\n+ *\n@@ -87,0 +89,2 @@\n+ * @see PEMRecord\n+ * @see EncryptedPrivateKeyInfo\n@@ -90,0 +94,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -110,1 +116,1 @@\n-     * Instantiate a new PEMEncoder for Encrypted Private Keys.\n+     * Instantiate a new {@code PEMEncoder} for Encrypted Private Keys.\n@@ -121,1 +127,1 @@\n-     * Returns a new instance of PEMEncoder.\n+     * Returns a new instance of {@code PEMEncoder}.\n@@ -123,1 +129,1 @@\n-     * @return PEMEncoder instance\n+     * @return new {@code PEMEncoder} instance\n@@ -125,1 +131,1 @@\n-    static public PEMEncoder of() {\n+    public static PEMEncoder of() {\n@@ -130,2 +136,2 @@\n-     * Encoded a given {@code DEREncodable} and return the PEM encoding in a\n-     * String\n+     * Encode the specified {@code DEREncodable} and return the PEM encoding in a\n+     * string.\n@@ -133,8 +139,5 @@\n-     * @param de a cryptographic object to be PEM encoded that implements\n-     *           {@code DEREncodable}.\n-     * @return PEM encoding in a String\n-     * @throws IllegalArgumentException when the passed object returns a null\n-     * binary encoding. An exception is thrown when PEMEncoder is\n-     * configured for encryption while encoding a {@code DEREncodable} that does\n-     * not support encryption.\n-     * @throws NullPointerException when object passed is null.\n+     * @param de the {@code DEREncodable} to be encoded.\n+     * @return PEM encoding in a string\n+     * @throws IllegalArgumentException when encoding the {@code DEREncodable}\n+     * fails.\n+     * @throws NullPointerException if {@code de} is {@code null}.\n@@ -202,1 +205,1 @@\n-     * Encodes a given {@code DEREncodable} into PEM.\n+     * Encodes the specified {@code DEREncodable} into PEM.\n@@ -204,7 +207,5 @@\n-     * @param de the object that implements {@code DEREncodable}.\n-     * @return a PEM encoded byte[] of the given {@code DEREncodable}.\n-     * @throws IllegalArgumentException when the passed object returns a null\n-     * binary encoding. An exception is thrown when PEMEncoder is\n-     * configured for encryption while encoding a {@code DEREncodable} that does\n-     * not support encryption.\n-     * @throws NullPointerException when object passed is null.\n+     * @param de the {@code DEREncodable} to be encoded.\n+     * @return PEM encoded byte array\n+     * @throws IllegalArgumentException when encoding the {@code DEREncodable}\n+     * fails.\n+     * @throws NullPointerException if {@code de} is {@code null}.\n@@ -218,1 +219,1 @@\n-     * Returns a new immutable PEMEncoder instance configured to the default\n+     * Returns a new {@code PEMEncoder} instance configured with the default\n@@ -221,3 +222,3 @@\n-     * <p> Only {@link PrivateKey} will be encrypted with this newly configured\n-     * instance.  Other {@link DEREncodable} classes that do not support\n-     * encrypted PEM will cause encode() to throw an IllegalArgumentException.\n+     * <p> Only {@link PrivateKey} objects can be encrypted with this newly\n+     * configured instance.  Encoding other {@link DEREncodable} objects will\n+     * throw an{@code IllegalArgumentException}.\n@@ -225,5 +226,6 @@\n-     * @implNote Default algorithm defined by Security Property {@code\n-     * jdk.epkcs8.defaultAlgorithm}.  To configure all the encryption options\n-     * see {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, char[], String,\n-     * AlgorithmParameterSpec, Provider)} and use the returned object with\n-     * {@link #encode(DEREncodable)}.\n+     * @implNote The default algorithm is defined by Security Property {@code\n+     * jdk.epkcs8.defaultAlgorithm} using default password-based encryption\n+     * parameters by the supporting provider.  To configure all the encryption\n+     * options see {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n+     * String, AlgorithmParameterSpec, Provider, SecureRandom)} and use the\n+     * returned object with {@link #encode(DEREncodable)}.\n@@ -232,2 +234,2 @@\n-     *                stored in the new instance. {@code null} is a valid entry.\n-     * @return a new PEMEncoder\n+     *                stored in the new instance. {@code null} is a valid value.\n+     * @return new configured {@code PEMEncoder} instance\n@@ -266,1 +268,1 @@\n-                    throw new SecurityException(\"Security property \" +\n+                    throw new RuntimeException(\"Security property \" +\n@@ -288,1 +290,1 @@\n-                throw new SecurityException(\"Security property \" +\n+                throw new RuntimeException(\"Security property \" +\n@@ -326,10 +328,4 @@\n-        try {\n-            if (privateBytes.length == 0) {\n-                throw new IllegalArgumentException(\"No private key encoding \" +\n-                    \"given by the DEREncodable.\");\n-            }\n-\n-            if (publicBytes.length == 0) {\n-                throw new IllegalArgumentException(\"No public key encoding \" +\n-                    \"given by the DEREncodable.\");\n-            }\n+        if (privateBytes.length == 0) {\n+            throw new IllegalArgumentException(\"No private key encoding \" +\n+                \"given by the DEREncodable.\");\n+        }\n@@ -337,0 +333,5 @@\n+        if (publicBytes.length == 0) {\n+            throw new IllegalArgumentException(\"No public key encoding \" +\n+                \"given by the DEREncodable.\");\n+        }\n+        try {\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":59,"deletions":58,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -56,0 +58,3 @@\n+ * <p>This class is immutable and thread-safe.  {@code leadingData} is not\n+ * defensively copied.\n+ *\n@@ -69,0 +74,1 @@\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n@@ -73,5 +79,1 @@\n-     * Return a PEMRecord instance with the given parameters.\n-     *\n-     * <p> When {@code type} is given a properly formatted PEM header, only the\n-     * identifier will be set (ie: {@code PUBLIC KEY}).  Otherwise, {@code type}\n-     * will be set to what was passed in.\n+     * Creates a {@code PEMRecord} instance with the given parameters.\n@@ -79,7 +81,3 @@\n-     * <p> When {@code type} is given a correctly formatted PEM header, only the\n-     * identifier is set (for example, {@code PUBLIC KEY}). Otherwise,\n-     * {@code type} is set to the value that was passed in.\n-     *\n-     * @param type The type identifier in the PEM header and footer.\n-     *             If there is no PEM data, this value will be {@code null}.\n-     * @param pem The data between the PEM header and footer.\n+     * @param type the type identifier in the PEM header and footer, or\n+     *             {@code null} if there is no PEM data.\n+     * @param pem the data between the PEM header and footer.\n@@ -88,1 +86,1 @@\n-     * @throws IllegalArgumentException on incorrect input values.\n+     * @throws IllegalArgumentException on incorrect input values\n@@ -91,3 +89,1 @@\n-        this.leadingData = (leadingData == null ? null : leadingData.clone());\n-\n-        if (type == null && pem == null && this.leadingData == null) {\n+        if (type == null && pem == null && leadingData == null) {\n@@ -112,0 +108,1 @@\n+        this.leadingData = leadingData;\n@@ -115,1 +112,1 @@\n-     * Returns a PEMRecord instance with a given {@code type} and {@code pem}\n+     * Creates a {@code PEMRecord} instance with a given {@code type} and {@code pem}\n@@ -118,2 +115,1 @@\n-     * @param type The type identifier in the PEM header and footer.\n-     *             If there is no PEM data, this value will be {@code null}.\n+     * @param type the type identifier in the PEM header and footer, or {@code null} if there is no PEM data.\n@@ -129,1 +125,1 @@\n-     * Returns a PEMRecord instance with a given String {@code type} and\n+     * Creates a {@code PEMRecord} instance with a given String {@code type} and\n@@ -132,3 +128,2 @@\n-     * @param type The type identifier in the PEM header and footer.\n-     *             If there is no PEM data, this value will be {@code null}.\n-     * @param pem The data between the PEM header and footer.\n+     * @param type the type identifier in the PEM header and footer, or {@code null} if there is no PEM data.\n+     * @param pem the data between the PEM header and footer.\n@@ -146,2 +141,3 @@\n-     * @throws IllegalArgumentException if {@code pem} could not be decoded.\n-     * @return binary encoding or null if {@code pem} is null.\n+     * @throws IllegalArgumentException if {@code pem} cannot be decoded.\n+     * @return Returns a new array of the binary encoding each time this\n+     * method is called, or null if {@code pem} is null.\n@@ -153,10 +149,0 @@\n-    \/**\n-     * Returns the leadingData that maybe stored in this record.\n-     * {@code null} will be returned if there is none.\n-     *\n-     * @return a copy of the leadingData.\n-     *\/\n-    public byte[] leadingData() {\n-        return (leadingData == null ? null : leadingData.clone());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -61,3 +61,0 @@\n-     * This constructor extracts the algorithm name from the encoded bytes,\n-     * which may be an OID if no standard algorithm name is defined. If the\n-     * algorithm name cannot be extracted, it is set to null.\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import sun.security.util.KeyUtil;\n+\n+import java.io.IOException;\n@@ -32,2 +35,2 @@\n- * encoded according to the ASN.1 type {@code PrivateKeyInfo}.\n- * The {@code PrivateKeyInfo} syntax is defined in the PKCS#8 standard\n+ * encoded according to the ASN.1 type {@code OneAsymmetricKey}.\n+ * The {@code OneAsymmetricKey} syntax is defined in the PKCS#8 standard\n@@ -37,1 +40,1 @@\n- * PrivateKeyInfo ::= SEQUENCE {\n+ * OneAsymmetricKey ::= SEQUENCE {\n@@ -41,1 +44,1 @@\n- *   attributes       [0] IMPLICIT Attributes OPTIONAL,\n+ *   attributes       [0] Attributes OPTIONAL,\n@@ -80,0 +83,3 @@\n+     * This constructor extracts the algorithm name from the encoded bytes,\n+     * which may be an OID if no standard algorithm name is defined. If the\n+     * algorithm name cannot be extracted, it is set to null.\n@@ -88,0 +94,9 @@\n+        \/* Uncomment when JEP 513 integrates\n+        String algorithm = null;\n+        try {\n+            algorithm = KeyUtil.getAlgorithm(encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n+        super(encodedKey, algorithm);\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import sun.security.util.KeyUtil;\n+\n+import java.io.IOException;\n@@ -59,0 +62,3 @@\n+     * This constructor extracts the algorithm name from the encoded bytes,\n+     * which may be an OID if no standard algorithm name is defined. If the\n+     * algorithm name cannot be extracted, it is set to null.\n@@ -67,0 +73,9 @@\n+        \/* Uncomment when JEP 513 integrates\n+        String algorithm = null;\n+        try {\n+            algorithm = KeyUtil.getAlgorithm(encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n+        super(encodedKey, algorithm);\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-     * @param encoded the ASN.1 encoding which is cloned and then parsed.\n+     * @param encoded the ASN.1 encoding of this object. The contents of\n+     * the array are copied to protect against subsequent modification.\n@@ -333,1 +334,1 @@\n-     * @param key the PrivateKey object to encrypt.\n+     * @param key the {@code PrivateKey} to encrypt.\n@@ -345,1 +346,1 @@\n-     * @return an EncryptedPrivateKeyInfo.\n+     * @return {@code EncryptedPrivateKeyInfo}\n@@ -367,0 +368,1 @@\n+        SecretKey skey;\n@@ -368,3 +370,6 @@\n-        if (algorithm == null && params != null) {\n-            throw new NullPointerException(\"algorithm must be specified if \" +\n-                \"params is non-null.\");\n+        if (algorithm == null) {\n+            if (params != null) {\n+                throw new NullPointerException(\"algorithm must be specified\" +\n+                    \" if params is non-null.\");\n+            }\n+            algorithm = Pem.DEFAULT_ALGO;\n@@ -372,1 +377,0 @@\n-        SecretKey skey;\n@@ -393,1 +397,1 @@\n-     * @param key The {@code PrivateKey} object to encrypt.\n+     * @param key The {@code PrivateKey} to encrypt.\n@@ -396,1 +400,1 @@\n-     * @return an {@code EncryptedPrivateKeyInfo}.\n+     * @return {@code EncryptedPrivateKeyInfo}\n@@ -403,1 +407,1 @@\n-     * @throws NullPointerException when the password is null.\n+     * @throws NullPointerException when the key or password is null.\n@@ -414,1 +418,0 @@\n-        char[] pass = password.clone();\n@@ -420,2 +423,1 @@\n-        return encryptKey(key, pass, Pem.DEFAULT_ALGO,\n-            null, null);\n+        return encryptKey(key, password, Pem.DEFAULT_ALGO, null, null);\n@@ -428,1 +430,1 @@\n-     * @param key is the {@code PrivateKey} to be encrypted.\n+     * @param key The {@code PrivateKey} to encrypt.\n@@ -441,2 +443,2 @@\n-     *                 used if {@code null}.\n-     * @return an {@code EncryptedPrivateKeyInfo}.\n+     *                used if {@code null}.\n+     * @return {@code EncryptedPrivateKeyInfo}\n@@ -462,4 +464,5 @@\n-        if (algorithm == null && params != null) {\n-            throw new NullPointerException(\"algorithm must be specified if \" +\n-                \"params is non-null.\");\n-        }\n+        if (algorithm == null) {\n+            if (params != null) {\n+                throw new NullPointerException(\"algorithm must be specified \" +\n+                    \"if params is non-null.\");\n+            }\n@@ -467,4 +470,6 @@\n-        if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n-            throw new RuntimeException(\"Security property \" +\n-                \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n-                \"valid algorithm.  Operation cannot be performed.\");\n+            if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n+                throw new RuntimeException(\"Security property \" +\n+                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                    \"valid algorithm.  Operation cannot be performed.\");\n+            }\n+            algorithm = Pem.DEFAULT_ALGO;\n@@ -474,3 +479,1 @@\n-        return encryptKeyImpl(key,\n-            (algorithm == null ? Pem.DEFAULT_ALGO : algorithm), encKey, params,\n-            provider, random);\n+        return encryptKeyImpl(key, algorithm, encKey, params, provider, random);\n@@ -520,1 +523,1 @@\n-     * @return a {@code PrivateKey}\n+     * @return {@code PrivateKey}\n@@ -542,1 +545,1 @@\n-     * @return a {@code PrivateKey}\n+     * @return {@code PrivateKey}\n@@ -568,2 +571,4 @@\n-        } catch (GeneralSecurityException e) {\n-            throw new InvalidKeyException(e);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new RuntimeException(e);\n+        } catch (InvalidKeySpecException e) {\n+            throw new RuntimeException(e);\n@@ -578,6 +583,4 @@\n-     * @param provider this {@code Provider} is used for all key generations.\n-     *                 It is used when generating the PBE encryption key,\n-     *                 {@code SecretKeyFactory}, and the {@code PrivateKey},\n-     *                 {@code KeyFactory}.  A {@code null} value will use the\n-     *                 default provider configuration.\n-     * @return a {@code PrivateKey}\n+     * @param provider the {@code Provider} is used for Cipher decryption and\n+     *                 {@code PrivateKey} generation. A {@code null} value will\n+     *                 use the default provider configuration.\n+     * @return {@code PrivateKey}\n@@ -586,1 +589,1 @@\n-     * @throws NullPointerException if {@code key} is null.\n+     * @throws NullPointerException if {@code decryptKey} is null.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -243,3 +243,2 @@\n-                throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \" +\n-                    \"and PKCS8EncodedKeySpec supported for EC private keys. \" +\n-                    keySpec.getClass().getName() + \" provided.\");\n+                throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                    \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    protected int version;\n+    private int version;\n@@ -193,1 +193,1 @@\n-     * @exception IOException on data format errors\n+     * @exception InvalidKeyException on data format errors\n@@ -243,4 +243,0 @@\n-    public byte[] getPrivKeyMaterial() {\n-        return privKeyMaterial;\n-    }\n-\n@@ -248,1 +244,1 @@\n-        return (pubKeyEncoded == null ? false : true);\n+        return (pubKeyEncoded != null);\n@@ -284,1 +280,0 @@\n-        PKCS8Key privKey;\n@@ -286,1 +281,2 @@\n-            privKey = new PKCS8Key(privKeyEncoded, pubKeyEncoded);\n+            return new PKCS8Key(privKeyEncoded, pubKeyEncoded).\n+                generateEncoding();\n@@ -290,1 +286,0 @@\n-        return privKey.generateEncoding();\n@@ -304,2 +299,1 @@\n-                \/\/ encodedKey is still null\n-                throw new SecurityException(e);\n+               return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -344,2 +344,1 @@\n-            throw new InvalidKeySpecException(\"Only RSAPublicKeySpec \"\n-                + \"and X509EncodedKeySpec supported for RSA public keys\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() + \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -362,1 +362,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    \/\/ Lazy initialize singleton encoder.\n+    \/\/ Lazy initialized singleton encoder.\n@@ -66,0 +66,1 @@\n+    public static final String X_509_CERTIFICATE = \"X.509 CERTIFICATE\";\n@@ -67,0 +68,1 @@\n+    public static final String CRL = \"CRL\";\n@@ -120,0 +122,13 @@\n+    \/*\n+     * RFC 7468 has some rules what generators should return given a historical\n+     * type name.  This converts read in PEM to the RFC.  Change the type to\n+     * be uniform is likely to help apps from not using all 3 certificate names.\n+     *\/\n+    private static String typeConverter(String type) {\n+        return switch (type) {\n+            case Pem.X509_CERTIFICATE, Pem.X_509_CERTIFICATE -> Pem.CERTIFICATE;\n+            case Pem.CRL -> Pem.X509_CRL;\n+            default -> type;\n+        };\n+    }\n+\n@@ -288,1 +303,1 @@\n-        return new PEMRecord(headerType, data, preData);\n+        return new PEMRecord(typeConverter(headerType), data, preData);\n@@ -295,9 +310,1 @@\n-    \/**\n-     * Construct a String-based encoding based off the type.  leadingData\n-     * is not used with this method.\n-     * @return the string\n-     *\/\n-    public static String pemEncoded(String type, byte[] data) {\n-        StringBuilder sb = new StringBuilder(1024);\n-        sb.append(\"-----BEGIN \").append(type).append(\"-----\");\n-        sb.append(System.lineSeparator());\n+    public static String pemEncoded(String type, byte[] der) {\n@@ -308,5 +315,1 @@\n-        sb.append(b64Encoder.encodeToString(data));\n-        sb.append(System.lineSeparator());\n-        sb.append(\"-----END \").append(type).append(\"-----\");\n-        sb.append(System.lineSeparator());\n-        return sb.toString();\n+        return pemEncoded(new PEMRecord(type, b64Encoder.encodeToString(der)));\n@@ -315,0 +318,5 @@\n+    \/**\n+     * Construct a String-based encoding based off the type.  leadingData\n+     * is not used with this method.\n+     * @return PEM in a string\n+     *\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -362,14 +362,0 @@\n-  \/*  public static PublicKey parseKey(byte[] encoded) throws IOException {\n-        PublicKey pubKey;\n-        try {\n-\n-            X509EncodedKeySpec spec = new X509EncodedKeySpec(encoded);\n-            pubKey = KeyFactory.getInstance(spec.getAlgorithm())\n-                .generatePublic(spec);\n-        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n-            \/\/ Ignore and return raw key\n-            throw new IOException(\"error with encoding\");\n-        }\n-        return pubKey;\n-    }\n-*\/\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1556,2 +1556,3 @@\n-# This property defines default Public-based Encryption algorithm for\n-# java.security.PEMEncoder is configured for encryption with `withEncryption()`.\n+# This property defines the default password-based encryption algorithm for\n+# java.security.PEMEncoder when configured for encryption with the\n+# withEncryption method.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}