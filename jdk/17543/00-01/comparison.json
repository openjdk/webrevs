{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import sun.security.util.PEMRecord;\n@@ -38,1 +39,0 @@\n-import java.util.Arrays;\n@@ -117,1 +117,1 @@\n-    private DEREncodable decode(byte[] data, byte[] header, byte[] footer)\n+    private DEREncodable decode(PEMRecord pem)\n@@ -119,23 +119,0 @@\n-        Pem.KeyType keyType;\n-\n-        if (Arrays.mismatch(header, Pem.PUBHEADER) == -1 &&\n-            Arrays.mismatch(footer, Pem.PUBFOOTER) == -1) {\n-            keyType = Pem.KeyType.PUBLIC;\n-        } else if (Arrays.mismatch(header, Pem.PKCS8HEADER) == -1 &&\n-            Arrays.mismatch(footer, Pem.PKCS8FOOTER) == -1) {\n-            keyType = Pem.KeyType.PRIVATE;\n-        } else if (Arrays.mismatch(header, Pem.PKCS8ENCHEADER) == -1 &&\n-            Arrays.mismatch(footer, Pem.PKCS8ENCFOOTER) == -1) {\n-            keyType = Pem.KeyType.ENCRYPTED_PRIVATE;\n-        } else if (Arrays.mismatch(header, Pem.CERTHEADER) == -1 &&\n-            Arrays.mismatch(footer, Pem.CERTFOOTER) == -1) {\n-            keyType = Pem.KeyType.CERTIFICATE;\n-        } else if (Arrays.mismatch(header, Pem.CRLHEADER) == -1 &&\n-            Arrays.mismatch(footer, Pem.CRLFOOTER) == -1) {\n-            keyType = Pem.KeyType.CRL;\n-        } else if (Arrays.mismatch(header, Pem.PKCS1HEADER) == -1 &&\n-            Arrays.mismatch(footer, Pem.PKCS1FOOTER) == -1) {\n-            keyType = Pem.KeyType.PKCS1;\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported PEM header\/footer\");\n-        }\n@@ -144,1 +121,1 @@\n-            if (keyType != Pem.KeyType.ENCRYPTED_PRIVATE) {\n+            if (!PEMRecord.ENCRYPTED_PRIVATE_KEY.equalsIgnoreCase(pem.id())) {\n@@ -153,2 +130,2 @@\n-            return switch (keyType) {\n-                case PUBLIC -> {\n+            return switch (pem.id()) {\n+                case PEMRecord.PUBLIC_KEY -> {\n@@ -156,3 +133,3 @@\n-                        new X509EncodedKeySpec(decoder.decode(data));\n-                    yield ((KeyFactory) getFactory(keyType,\n-                        spec.getAlgorithm())).generatePublic(spec);\n+                        new X509EncodedKeySpec(decoder.decode(pem.pem()));\n+                    yield (getKeyFactory(spec.getAlgorithm())).\n+                        generatePublic(spec);\n@@ -161,2 +138,2 @@\n-                case PRIVATE -> {\n-                    PKCS8Key p8key = new PKCS8Key(decoder.decode(data));\n+                case PEMRecord.PRIVATE_KEY -> {\n+                    PKCS8Key p8key = new PKCS8Key(decoder.decode(pem.pem()));\n@@ -164,2 +141,1 @@\n-                    KeyFactory kf = (KeyFactory)\n-                        getFactory(keyType, p8key.getAlgorithm());\n+                    KeyFactory kf = getKeyFactory(p8key.getAlgorithm());\n@@ -173,4 +149,2 @@\n-                        yield new KeyPair(((KeyFactory)\n-                            getFactory(keyType, p8key.getAlgorithm()))\n-                            .generatePublic(spec),\n-                            priKey);\n+                        yield new KeyPair(getKeyFactory(p8key.getAlgorithm()).\n+                            generatePublic(spec), priKey);\n@@ -180,1 +154,1 @@\n-                case ENCRYPTED_PRIVATE -> {\n+                case PEMRecord.ENCRYPTED_PRIVATE_KEY -> {\n@@ -182,1 +156,1 @@\n-                        yield new EncryptedPrivateKeyInfo(decoder.decode(data));\n+                        yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem()));\n@@ -184,1 +158,1 @@\n-                    yield new EncryptedPrivateKeyInfo(decoder.decode(data)).\n+                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem())).\n@@ -187,3 +161,3 @@\n-                case CERTIFICATE -> {\n-                    CertificateFactory cf =\n-                        (CertificateFactory) getFactory(keyType, \"X509\");\n+                case PEMRecord.CERTIFICATE,\n+                    PEMRecord.X509_CERTIFICATE -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n@@ -191,1 +165,1 @@\n-                        new ByteArrayInputStream(decoder.decode(data)));\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n@@ -193,3 +167,2 @@\n-                case CRL -> {\n-                    CertificateFactory cf =\n-                        (CertificateFactory) getFactory(keyType, \"X509\");\n+                case PEMRecord.X509_CRL -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n@@ -197,1 +170,1 @@\n-                        new ByteArrayInputStream(decoder.decode(data)));\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n@@ -199,2 +172,2 @@\n-                case PKCS1 -> {\n-                    KeyFactory kf = (KeyFactory) getFactory(keyType, \"RSA\");\n+                case PEMRecord.RSA_PRIVATE_KEY -> {\n+                    KeyFactory kf = getKeyFactory(\"RSA\");\n@@ -202,1 +175,1 @@\n-                        RSAPrivateCrtKeyImpl.getKeySpec(decoder.decode(data)));\n+                        RSAPrivateCrtKeyImpl.getKeySpec(decoder.decode(pem.pem())));\n@@ -246,1 +219,1 @@\n-        Pem pem = Pem.readPEM(is);\n+        PEMRecord pem = Pem.readPEM(is);\n@@ -250,1 +223,1 @@\n-        return decode(pem.getData(), pem.getHeader(), pem.getFooter());\n+        return decode(pem);\n@@ -309,1 +282,1 @@\n-        Pem pem = Pem.readPEM(is);\n+        PEMRecord pem = Pem.readPEM(is);\n@@ -314,2 +287,5 @@\n-        DEREncodable so =\n-            decode(pem.getData(), pem.getHeader(), pem.getFooter());\n+        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+            return tClass.cast(pem);\n+        }\n+\n+        DEREncodable so = decode(pem);\n@@ -348,3 +324,2 @@\n-                    ((KeyFactory) getFactory(Pem.KeyType.PRIVATE,\n-                        key.getAlgorithm())).getKeySpec(key,\n-                        PKCS8EncodedKeySpec.class);\n+                    getKeyFactory(key.getAlgorithm()).\n+                        getKeySpec(key, PKCS8EncodedKeySpec.class);\n@@ -352,2 +327,1 @@\n-                    ((KeyFactory) getFactory(Pem.KeyType.PUBLIC,\n-                        key.getAlgorithm()))\n+                    getKeyFactory(key.getAlgorithm())\n@@ -368,0 +342,12 @@\n+\n+    private KeyFactory getKeyFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return KeyFactory.getInstance(algorithm);\n+            }\n+            return KeyFactory.getInstance(algorithm, factory);\n+        } catch(GeneralSecurityException e){\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n@@ -369,1 +355,1 @@\n-    private Object getFactory(Pem.KeyType type, String algorithm) {\n+    private CertificateFactory getCertFactory(String algorithm) {\n@@ -372,15 +358,1 @@\n-                return switch (type) {\n-                    case PUBLIC, PRIVATE, PKCS1 ->\n-                        KeyFactory.getInstance(algorithm);\n-                    case CERTIFICATE, CRL ->\n-                        CertificateFactory.getInstance(algorithm);\n-                    default -> null;  \/\/ no possible\n-                };\n-            } else {\n-                return switch (type) {\n-                    case PUBLIC, PRIVATE, PKCS1 ->\n-                        KeyFactory.getInstance(algorithm, factory);\n-                    case CERTIFICATE, CRL ->\n-                        CertificateFactory.getInstance(algorithm, factory);\n-                    default -> null;  \/\/ no possible\n-                };\n+                return CertificateFactory.getInstance(algorithm);\n@@ -388,0 +360,1 @@\n+            return CertificateFactory.getInstance(algorithm, factory);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":52,"deletions":79,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import sun.security.util.PEMRecord;\n@@ -90,0 +91,1 @@\n+    private static Base64.Encoder b64Encoder;\n@@ -110,4 +112,1 @@\n-     * Construct a String-based encoding based off the {@code keyType} given.\n-     *\n-     * @param keyType the key type\n-     * @param encoded the encoded\n+     * Construct a String-based encoding based off the id type.\n@@ -116,27 +115,7 @@\n-    private byte[] pemEncoded(Pem.KeyType keyType, byte[] encoded) {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n-        switch (keyType) {\n-            case PUBLIC -> {\n-                os.writeBytes(Pem.PUBHEADER);\n-                os.writeBytes(Pem.LINESEPARATOR);\n-                os.writeBytes(convertToPEM(encoded));\n-                os.writeBytes(Pem.PUBFOOTER);\n-                os.writeBytes(Pem.LINESEPARATOR);\n-            }\n-            case PRIVATE -> {\n-                os.writeBytes(Pem.PKCS8HEADER);\n-                os.writeBytes(Pem.LINESEPARATOR);\n-                os.writeBytes(convertToPEM(encoded));\n-                os.writeBytes(Pem.PKCS8FOOTER);\n-                os.writeBytes(Pem.LINESEPARATOR);\n-            }\n-            case ENCRYPTED_PRIVATE -> {\n-                os.writeBytes(Pem.PKCS8ENCHEADER);\n-                os.writeBytes(Pem.LINESEPARATOR);\n-                os.writeBytes(convertToPEM(encoded));\n-                os.writeBytes(Pem.PKCS8ENCFOOTER);\n-                os.writeBytes(Pem.LINESEPARATOR);\n-            }\n-            default -> {\n-                return new byte[0];\n-            }\n+    private String pemEncoded(PEMRecord pem) {\n+        StringBuffer sb = new StringBuffer(1024);\n+        sb.append(\"-----BEGIN \").append(pem.id()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        if (b64Encoder == null) {\n+            b64Encoder = Base64.getMimeEncoder(64,\n+                System.lineSeparator().getBytes());\n@@ -144,12 +123,6 @@\n-        return os.toByteArray();\n-    }\n-\n-    static byte[] convertToPEM(byte[] encoding) {\n-        if (encoding.length == 0) {\n-            return new byte[0];\n-        }\n-        Base64.Encoder e = Base64.getMimeEncoder(64, Pem.LINESEPARATOR);\n-        ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n-        os.writeBytes(e.encode(encoding));\n-        os.writeBytes(Pem.LINESEPARATOR);\n-        return os.toByteArray();\n+        sb.append(b64Encoder.encodeToString(\n+            pem.pem().getBytes(StandardCharsets.ISO_8859_1)));\n+        sb.append(System.lineSeparator());\n+        sb.append(\"-----END \").append(pem.id()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        return sb.toString();\n@@ -173,16 +146,0 @@\n-        return new String(encode(so), StandardCharsets.UTF_8);\n-    }\n-\n-    \/**\n-     * Encoded a given {@code DEREncodable} into PEM.\n-     *\n-     * @param so the object that implements DEREncodable.\n-     * @return a PEM encoded byte[] of the given DEREncodable.\n-     * @throws IllegalArgumentException when the passed object returns a null\n-     * binary encoding. An exception is thrown when PEMEncoder is\n-     * configured for encryption while encoding a DEREncodable that does\n-     * not support encryption.\n-     * @throws NullPointerException when object passed is null.\n-     * @see #withEncryption(char[])\n-     *\/\n-    public byte[] encode(DEREncodable so) {\n@@ -214,1 +171,2 @@\n-                    yield pemEncoded(Pem.KeyType.ENCRYPTED_PRIVATE, epki.getEncoded());\n+                    yield pemEncoded(new PEMRecord(\n+                        PEMRecord.ENCRYPTED_PRIVATE_KEY, epki.getEncoded()));\n@@ -220,2 +178,0 @@\n-                ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n-                os.writeBytes(Pem.CERTHEADER);\n@@ -223,2 +179,2 @@\n-                    os.writeBytes(Base64.getMimeEncoder(64, Pem.LINESEPARATOR)\n-                        .encode(c.getEncoded()));\n+                    yield pemEncoded(new PEMRecord(PEMRecord.CERTIFICATE,\n+                        c.getEncoded()));\n@@ -228,2 +184,0 @@\n-                os.writeBytes(Pem.CERTFOOTER);\n-                yield os.toByteArray();\n@@ -233,2 +187,0 @@\n-                ByteArrayOutputStream os = new ByteArrayOutputStream(1024);\n-                os.writeBytes(Pem.CRLHEADER);\n@@ -236,2 +188,2 @@\n-                    os.writeBytes(Base64.getMimeEncoder(64, Pem.LINESEPARATOR)\n-                        .encode(xcrl.getEncoded()));\n+                    yield pemEncoded(new PEMRecord(PEMRecord.X509_CRL,\n+                        xcrl.getEncoded()));\n@@ -241,2 +193,0 @@\n-                os.writeBytes(Pem.CRLFOOTER);\n-                yield os.toByteArray();\n@@ -249,0 +199,16 @@\n+    \/**\n+     * Encoded a given {@code DEREncodable} into PEM.\n+     *\n+     * @param so the object that implements DEREncodable.\n+     * @return a PEM encoded byte[] of the given DEREncodable.\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public byte[] encode(DEREncodable so) {\n+        return encodeToString(so).getBytes(StandardCharsets.ISO_8859_1);\n+    }\n+\n@@ -275,1 +241,1 @@\n-    private byte[] build(byte[] privateBytes, byte[] publicBytes) {\n+    private String build(byte[] privateBytes, byte[] publicBytes) {\n@@ -310,2 +276,2 @@\n-            return pemEncoded(Pem.KeyType.ENCRYPTED_PRIVATE,\n-                DerValue.wrap(DerValue.tag_Sequence, out).toByteArray());\n+            return pemEncoded(new PEMRecord(PEMRecord.ENCRYPTED_PRIVATE_KEY,\n+                DerValue.wrap(DerValue.tag_Sequence, out).toByteArray()));\n@@ -316,1 +282,1 @@\n-            return pemEncoded(Pem.KeyType.PUBLIC, publicBytes);\n+            return pemEncoded(new PEMRecord(PEMRecord.PUBLIC_KEY, publicBytes));\n@@ -320,1 +286,2 @@\n-            return pemEncoded(Pem.KeyType.PRIVATE, privateBytes);\n+            return pemEncoded(new PEMRecord(PEMRecord.PRIVATE_KEY,\n+                privateBytes));\n@@ -324,2 +291,2 @@\n-            return pemEncoded(Pem.KeyType.PRIVATE,\n-                PKCS8Key.getEncoded(publicBytes, privateBytes));\n+            return pemEncoded(new PEMRecord(PEMRecord.PRIVATE_KEY,\n+                PKCS8Key.getEncoded(publicBytes, privateBytes)));\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":46,"deletions":79,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import sun.security.util.PEMRecord;\n@@ -560,4 +561,0 @@\n-            Pem pem = Pem.readPEM(is, (c == '-' ? true : false));\n-            if (pem == null) {\n-                return null;\n-            }\n@@ -565,1 +562,5 @@\n-                return Base64.getDecoder().decode(pem.getData());\n+                PEMRecord pem = Pem.readPEM(is, (c == '-' ? true : false));\n+                if (pem == null) {\n+                    return null;\n+                }\n+                return Base64.getDecoder().decode(pem.pem());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * A Record for PEM\n+ *\n+ * @param id      The PEM header and footer value that identifies the data.\n+ * @param pem     The Base64 encoded data only in byte[] format\n+ *\/\n+public record PEMRecord(String id, String pem) {\n+\n+    public static final String PUBLIC_KEY = \"PUBLIC KEY\";\n+    public static final String ENCRYPTED_PRIVATE_KEY = \"ENCRYPTED PRIVATE KEY\";\n+    public static final String PRIVATE_KEY = \"PRIVATE KEY\";\n+    public static final String RSA_PRIVATE_KEY = \"RSA PRIVATE KEY\";\n+    public static final String CERTIFICATE = \"CERTIFICATE\";\n+    public static final String X509_CERTIFICATE = \"X509 CERTIFICATE\";\n+    public static final String X509_CRL = \"X509 CRL\";\n+\n+    \/**\n+     * Get an instance of a PEMRecord.\n+     *\n+     * @param id  The PEM header and footer value that identifies the data.\n+     * @param pem The Base64 encoded data only in byte[] format\n+     *\/\n+    public PEMRecord(String id, byte[] pem) {\n+        this(id, new String(pem, StandardCharsets.ISO_8859_1));\n+    }\n+\n+    \/**\n+     * Instantiates a new Pem record.\n+     *\n+     * @param id      The PEM header and footer value that identifies the data.\n+     * @param pem     The Base64 encoded data only in byte[] format\n+     *\/\n+    public PEMRecord(String id, String pem) {\n+        if (id.startsWith(\"-----\")) {\n+            \/\/ decode id in the\n+            this.id = id.substring(11, id.lastIndexOf('-') - 4);\n+        } else {\n+            this.id = id;\n+        }\n+        \n+        this.pem = pem;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PEMRecord.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Arrays;\n@@ -43,56 +42,0 @@\n-\n-    \/**\n-     * Public Key PEM header & footer\n-     *\/\n-    public static final byte[] PUBHEADER = \"-----BEGIN PUBLIC KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-    public static final byte[] PUBFOOTER = \"-----END PUBLIC KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    \/**\n-     * Private Key PEM header & footer\n-     *\/\n-    public static final byte[] PKCS8HEADER = \"-----BEGIN PRIVATE KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-    public static final byte[] PKCS8FOOTER = \"-----END PRIVATE KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    \/**\n-     * Encrypted Private Key PEM header & footer\n-     *\/\n-    public static final byte[] PKCS8ENCHEADER = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-    public static final byte[] PKCS8ENCFOOTER = \"-----END ENCRYPTED PRIVATE KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    \/**\n-     * Certificate PEM header & footer\n-     *\/\n-    public static final byte[] CERTHEADER = \"-----BEGIN CERTIFICATE-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-    public static final byte[] CERTFOOTER = \"-----END CERTIFICATE-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    \/**\n-     * CRL PEM header & footer\n-     *\/\n-    public static final byte[] CRLHEADER = \"-----BEGIN X509 CRL-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-    public static final byte[] CRLFOOTER = \"-----END X509 CRL-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    \/**\n-     * PKCS#1\/slleay\/OpenSSL RSA PEM header & footer\n-     *\/\n-    public static final byte[] PKCS1HEADER = \"-----BEGIN RSA PRIVATE KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-    public static final byte[] PKCS1FOOTER = \"-----END RSA PRIVATE KEY-----\"\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    public static final byte[] LINESEPARATOR = System.lineSeparator()\n-        .getBytes(StandardCharsets.ISO_8859_1);\n-\n-    public enum KeyType {\n-        UNKNOWN, PRIVATE, PUBLIC, ENCRYPTED_PRIVATE, CERTIFICATE, CRL, PKCS1\n-    }\n-\n@@ -107,8 +50,0 @@\n-    private byte[] header, footer;\n-    private byte[] data;\n-\n-    private Pem(byte[] header, byte[] data, byte[] footer) {\n-        this.header = header;\n-        this.data = data;\n-        this.footer = footer;\n-    }\n@@ -124,2 +59,2 @@\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\")\n-            .getBytes(StandardCharsets.ISO_8859_1);\n+        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+            getBytes(StandardCharsets.ISO_8859_1);\n@@ -146,1 +81,1 @@\n-    public static Pem readPEM(InputStream is) throws IOException {\n+    public static PEMRecord readPEM(InputStream is) throws IOException {\n@@ -159,1 +94,1 @@\n-    public static Pem readPEM(InputStream is, boolean shortHeader)\n+    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n@@ -301,19 +236,1 @@\n-        return new Pem(header.getBytes(StandardCharsets.ISO_8859_1),\n-            data.getBytes(StandardCharsets.ISO_8859_1),\n-            footer.getBytes(StandardCharsets.ISO_8859_1));\n-    }\n-\n-    public byte[] getData() {\n-        return data;\n-    }\n-\n-    public byte[] getHeader() {\n-        return header;\n-    }\n-\n-    public byte[] getFooter() {\n-        return footer;\n-    }\n-\n-    public void clean() {\n-        Arrays.fill(data, (byte)0);\n+        return new PEMRecord(header, data);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":5,"deletions":88,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +127,1 @@\n-    public static class FakeX509Spec extends X509EncodedKeySpec {\n+    public static class FakeX509Spec extends EncodedKeySpec {\n@@ -134,0 +135,5 @@\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @enablePreview\n@@ -49,0 +50,1 @@\n+\/\/        test(new PEMCerts.Entry(\"oasrfc8410\", PEMCerts.oasrfc8410, PrivateKey.class, null));\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- *\n+ * @enablePreview\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.security.InvalidKeyException;\n@@ -130,1 +131,1 @@\n-        } catch (IOException e) {\n+        } catch (InvalidKeyException e) {\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}