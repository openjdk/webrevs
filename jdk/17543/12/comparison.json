{"files":[{"patch":"@@ -37,1 +37,1 @@\n-public interface AsymmetricKey extends Key {\n+public non-sealed interface AsymmetricKey extends Key, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/AsymmetricKey.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+\/**\n+ * This is a top-level interface for security classes that contain cryptographic\n+ * data which may not be related or have a common class hierarchy.  These\n+ * security objects provide standard binary encoding, like ASN.1, and type\n+ * formats, like X.509 and PKCS#8.  These encodings are used in some form with\n+ * {@link KeyFactory} and {@link java.security.cert.CertificateFactory},\n+ *\n+ * @see Key\n+ * @see KeyPair\n+ * @see EncodedKeySpec\n+ * @see EncryptedPrivateKeyInfo\n+ * @see X509Certificate\n+ * @see X509CRL\n+ *\n+ * @since 24\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public sealed interface DEREncodable permits AsymmetricKey, KeyPair, PEMRecord, X509CRL, X509Certificate, PKCS8EncodedKeySpec, X509EncodedKeySpec, EncryptedPrivateKeyInfo {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-public final class KeyPair implements java.io.Serializable {\n+public final class KeyPair implements java.io.Serializable, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPair.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.rsa.RSAPrivateCrtKeyImpl;\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.*;\n+import java.security.cert.*;\n+import java.security.spec.*;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * {@code PEMDecoder} is an immutable class for Privacy-Enhanced Mail (PEM)\n+ * data.  PEM is a textual encoding used to store and transfer security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * and footer.\n+ *\n+ * <p> Decoding methods return an instance of a class that matches the data\n+ * type and implements {@link DEREncodable} unless specified. The following\n+ * types are decoded into Java Cryptographic Extensions (JCE) object:\n+ * <pre>\n+ *     PRIVATE KEY, RSA PRIVATE KEY, PUBLIC KEY, CERTIFICATE,\n+ *     X509 CERTIFICATE, X509 CRL, and ENCRYPTED PRIVATE KEY.\n+ * <\/pre>\n+ *\n+ * A specified return class must extend {@link DEREncodable} and be an\n+ * appropriate JCE object class for the PEM; otherwise an\n+ * {@link IllegalArgumentException} is thrown.\n+ *\n+ * <p> If the PEM does not have a corresponding JCE object, it returns a\n+ * {@link PEMRecord}. Any PEM can be decoded into a {@code PEMRecord} if the\n+ * class is specified. Decoding a {@code PEMRecord} returns corresponding\n+ * JCE object or throws a {@link IllegalArgumentException} if no object is\n+ * available.\n+ *\n+ * <p> A new immutable {@code PEMDecoder} instance is created by using\n+ * {@linkplain #withFactory} and\/or {@linkplain #withDecryption}.  Configuring\n+ * an instance for decryption does not prevent decoding with unencrypted PEM.\n+ * Any encrypted PEM that does not use the configured password will throw an\n+ * {@link SecurityException}. A decoder instance not configured with decryption\n+ * returns an {@link EncryptedPrivateKeyInfo} with encrypted PEM.\n+ * EncryptedPrivateKeyInfo methods must be used to retrieve the\n+ * {@link PrivateKey}.\n+ *\n+ * <p> {@code String} values returned by this class use character set\n+ * {@link java.nio.charset.StandardCharsets#ISO_8859_1 ISO-8859-1}\n+ *\n+ * @apiNote\n+ * Here is an example of encoding a PrivateKey object:\n+ * <pre>\n+ *     PEMDecoder pd = PEMDecoder.of();\n+ *     PrivateKey priKey = pd.decode(PriKeyPEM);\n+ * <\/pre>\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc1421\n+ *       RFC 1421: Privacy Enhancement for Internet Electronic Mail\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @since 25\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMDecoder {\n+    private final Provider factory;\n+    private final PBEKeySpec password;\n+\n+    \/\/ Singleton instance for PEMDecoder\n+    private final static PEMDecoder PEM_DECODER = new PEMDecoder(null, null);\n+\n+    \/**\n+     * Creates an immutable instance with a specific KeyFactory and\/or\n+     * password.\n+     * @param withFactory KeyFactory provider\n+     * @param withPassword char[] password for EncryptedPrivateKeyInfo\n+     *                    decryption\n+     *\/\n+    private PEMDecoder(Provider withFactory, PBEKeySpec withPassword) {\n+        password = withPassword;\n+        factory = withFactory;\n+    }\n+\n+    \/**\n+     * Returns an instance of {@code PEMDecoder}.  This instance may be repeatedly used\n+     * to decode different PEM text.\n+     *\n+     * @return returns a {@code PEMDecoder}\n+     *\/\n+    public static PEMDecoder of() {\n+        return PEM_DECODER;\n+    }\n+\n+    \/**\n+     * After the header, footer, and base64 have been separated, identify the\n+     * header and footer and proceed with decoding the base64 for the\n+     * appropriate type.\n+     *\/\n+    private DEREncodable decode(PEMRecord pem) {\n+        Base64.Decoder decoder = Base64.getMimeDecoder();\n+\n+        try {\n+            return switch (pem.type()) {\n+                case Pem.PUBLIC_KEY -> {\n+                    X509EncodedKeySpec spec =\n+                        new X509EncodedKeySpec(decoder.decode(pem.pem()));\n+                    yield (getKeyFactory(spec.getAlgorithm())).\n+                        generatePublic(spec);\n+                }\n+                case Pem.PRIVATE_KEY -> {\n+                    PKCS8Key p8key = new PKCS8Key(decoder.decode(pem.pem()));\n+                    KeyFactory kf = getKeyFactory(p8key.getAlgorithm());\n+                    DEREncodable d;\n+\n+                    d = kf.generatePrivate(\n+                        new PKCS8EncodedKeySpec(p8key.getEncoded(),\n+                            p8key.getAlgorithm()));\n+\n+                    \/\/ Look for a public key inside the pkcs8 encoding.\n+                    if (p8key.getPubKeyEncoded() != null) {\n+                        \/\/ Check if this is a OneAsymmetricKey encoding\n+                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                            p8key.getPubKeyEncoded(), p8key.getAlgorithm());\n+                        yield new KeyPair(getKeyFactory(p8key.getAlgorithm()).\n+                            generatePublic(spec), (PrivateKey) d);\n+\n+                    } else if (d instanceof PKCS8Key p8 &&\n+                        p8.getPubKeyEncoded() != null) {\n+                        \/\/ If the KeyFactory decoded an algorithm-specific\n+                        \/\/ encodings, look for the public key again.  This\n+                        \/\/ happens with EC and SEC1-v2 encoding\n+                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                            p8.getPubKeyEncoded(), p8.getAlgorithm());\n+                        yield new KeyPair(getKeyFactory(p8.getAlgorithm()).\n+                            generatePublic(spec), p8);\n+                    } else {\n+                        \/\/ No public key, return the private key.\n+                        yield d;\n+                    }\n+                }\n+                case Pem.ENCRYPTED_PRIVATE_KEY -> {\n+                    if (password == null) {\n+                        yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem()));\n+                    }\n+                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem())).\n+                        getKey(password.getPassword());\n+                }\n+                case Pem.CERTIFICATE, Pem.X509_CERTIFICATE -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n+                    yield (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n+                }\n+                case Pem.X509_CRL -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n+                    yield (X509CRL) cf.generateCRL(\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n+                }\n+                case Pem.RSA_PRIVATE_KEY -> {\n+                    KeyFactory kf = getKeyFactory(\"RSA\");\n+                    yield kf.generatePrivate(\n+                        RSAPrivateCrtKeyImpl.getKeySpec(decoder.decode(pem.pem())));\n+                }\n+                default -> pem;\n+            };\n+        } catch (GeneralSecurityException | IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns {@link DEREncodable} from the given string.\n+     *\n+     * @param str PEM data in a String.\n+     * @return an {@code DEREncodable} generated from the PEM data.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public DEREncodable decode(String str) {\n+        Objects.requireNonNull(str);\n+        try {\n+            return decode(new ByteArrayInputStream(str.getBytes()));\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns a {@link DEREncodable} from the given\n+     * {@code InputStream}.\n+     *\n+     * <p>The method will read the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  Non-PEM data in the\n+     * {@code InputStream} before the PEM header will be ignored by the decoder.\n+     * If only non-PEM data is found a {@link PEMRecord} is returned with that\n+     * data.\n+     *\n+     * @param is InputStream containing PEM data.\n+     * @return an {@code DEREncodable} generated from the data read.\n+     * @throws IOException on IO error with the InputStream\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public DEREncodable decode(InputStream is) throws IOException {\n+        Objects.requireNonNull(is);\n+        PEMRecord pem = Pem.readPEM(is);\n+        return decode(pem);\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given PEM string.\n+     * {@code tClass} must extend {@link DEREncodable} and be an appropriate\n+     * class for the PEM type.\n+     *\n+     * <p>\n+     * {@code tClass} can be used to change the return type instance:\n+     * <ul>\n+     * <li> Cast to a {@code DEREncodable} subclass, such\n+     * as an EC public key to a {@code ECPublicKey}.<\/li>\n+     * <li> Extract a key from a PEM with two keys, like taking only\n+     * {@code PrivateKey}<\/li>\n+     * <li> Convert to a different class, like storing the public key's\n+     * binary encoding in {@link X509EncodedKeySpec}.<\/li>\n+     * <li> Store the PEM a {@link PEMRecord}.<\/li>\n+     *<\/ul>\n+     * @param <S> Class type parameter that extends {@code DEREncodable}\n+     * @param string the String containing PEM data.\n+     * @param tClass the returned object class that implementing\n+     * {@code DEREncodable}.\n+     * @return A {@code DEREncodable} typecast to {@code tClass}.\n+     * @throws IllegalArgumentException on error in decoding.\n+     * @throws ClassCastException if the given class is invalid for the PEM.\n+     *\/\n+    public <S extends DEREncodable> S decode(String string, Class<S> tClass) {\n+        Objects.requireNonNull(string);\n+        try {\n+            return decode(new ByteArrayInputStream(string.getBytes()), tClass);\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given\n+     * {@link InputStream}.  The class must extend {@link DEREncodable} and be\n+     * an appropriate class for the PEM type.\n+     *\n+     * @param <S> Class type parameter that extends {@code DEREncodable}\n+     * @param is an InputStream containing PEM data.\n+     * @param tClass the returned object class that implementing\n+     *   {@code DEREncodable}.\n+     * @return A {@code DEREncodable} typecast to {@code tClass}\n+     * @throws IOException on IO error with the InputStream.\n+     * @throws IllegalArgumentException on error in decoding.\n+     * @throws ClassCastException if the given class is invalid for the PEM.\n+     *\n+     * @see #decode(InputStream)\n+     * @see #decode(String, Class)\n+     *\/\n+    public <S extends DEREncodable> S decode(InputStream is, Class<S> tClass)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+        Objects.requireNonNull(tClass);\n+        PEMRecord pem = Pem.readPEM(is);\n+\n+        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+        \/\/if (PEMRecord.class.isInstance(tClass)) {\n+            return tClass.cast(pem);\n+        }\n+        DEREncodable so = decode(pem);\n+\n+        \/*\n+         * If the object is a KeyPair, check if the tClass is set to class\n+         * specific to a private or public key.  Because PKCS8v2 can be a\n+         * KeyPair, it is possible for someone to assume all their PEM private\n+         * keys are only PrivateKey and not KeyPair.\n+         *\/\n+        if (so instanceof KeyPair kp) {\n+            if ((PrivateKey.class).isAssignableFrom(tClass) ||\n+                (PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPrivate();\n+            }\n+            if ((PublicKey.class).isAssignableFrom(tClass) ||\n+                (X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPublic();\n+            }\n+        }\n+\n+        \/*\n+         * KeySpec use getKeySpec after the Key has been generated.  Even though\n+         * returning a binary encoding after the Base64 decoding is ok when the\n+         * user wants PKCS8EncodedKeySpec, generating the key verifies the\n+         * binary encoding and allows the KeyFactory to use the provider's\n+         * KeySpec()\n+         *\/\n+\n+        if ((EncodedKeySpec.class).isAssignableFrom(tClass) &&\n+            so instanceof Key key) {\n+            try {\n+                \/\/ unchecked suppressed as we know tClass comes from KeySpec\n+                \/\/ KeyType not relevant here.  We just want KeyFactory\n+                if ((PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    so = getKeyFactory(key.getAlgorithm()).\n+                        getKeySpec(key, PKCS8EncodedKeySpec.class);\n+                } else if ((X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    so = getKeyFactory(key.getAlgorithm())\n+                        .getKeySpec(key, X509EncodedKeySpec.class);\n+                } else {\n+                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                }\n+            } catch (InvalidKeySpecException e) {\n+                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n+                    \"specified (\" + tClass.getName() +\") for key (\" +\n+                    key.getClass().getName() +\")\", e);\n+            }\n+        }\n+\n+        return tClass.cast(so);\n+    }\n+\n+    private KeyFactory getKeyFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return KeyFactory.getInstance(algorithm);\n+            }\n+            return KeyFactory.getInstance(algorithm, factory);\n+        } catch(GeneralSecurityException e){\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/\/ Convenience method to avoid provider getInstance checks clutter\n+    private CertificateFactory getCertFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return CertificateFactory.getInstance(algorithm);\n+            }\n+            return CertificateFactory.getInstance(algorithm, factory);\n+        } catch (GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Configures and returns a new {@code PEMDecoder} instance from the\n+     * current instance that will use KeyFactory and CertificateFactory classes\n+     * from the specified {@link Provider}.  Any errors using the\n+     * {@code provider} will occur during decoding.\n+     *\n+     * <p>If {@code params} is {@code null}, a new instance is returned with\n+     * the default provider configuration.\n+     *\n+     * @param provider the Factory provider.\n+     * @return a new PEM decoder instance.\n+     *\/\n+    public PEMDecoder withFactory(Provider provider) {\n+        return new PEMDecoder(provider, password);\n+    }\n+\n+    \/**\n+     * Returns a new {@code PEMDecoder} instance from the current instance\n+     * configured to decrypt encrypted PEM data with given password.\n+     * Non-encrypted PEM may still be decoded from this instance.\n+     *\n+     * @param password the password to decrypt encrypted PEM data.  This array\n+     *                 is cloned and stored in the new instance.\n+     * @return a new PEM decoder instance.\n+     * @throws NullPointerException if password is null.\n+     *\/\n+    public PEMDecoder withDecryption(char[] password) {\n+        return new PEMDecoder(factory, new PBEKeySpec(password));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -0,0 +1,368 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.Pem;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\/**\n+ * PEMEncoder is an immutable class for Privacy-Enhanced Mail (PEM)\n+ * data.  PEM is a textual encoding used to store and transfer security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * and footer.\n+ *\n+ * <p> Encoding may be performed on Java Cryptographic Extension (JCE) objects\n+ * that implement {@link DEREncodable} and support\n+ * {@linkplain PKCS8EncodedKeySpec PKCS#8} or\n+ * {@linkplain X509EncodedKeySpec X509} formats.\n+ *\n+ * <p> Encrypted private key PEM data can be built by calling the encode methods\n+ * on a PEMEncoder instance returned by {@link #withEncryption(char[])} or\n+ * by passing an {@link EncryptedPrivateKeyInfo} object into the encode methods.\n+ *\n+ * <p>PKCS8 v2.0 allows OneAsymmetricKey encoding, which is a private and public\n+ * key in the same PEM.  This is supported by using the {@link KeyPair} class\n+ * with the encode methods.\n+ *\n+ * <p> When encoding a {@link PEMRecord}, the API surrounds the\n+ * {@linkplain PEMRecord#pem()} with a generated the PEM header and footer\n+ * from {@linkplain PEMRecord#type()}.  It will not check the validity of\n+ * the data.\n+ *\n+ * <p>{@code String} values returned by this class use character set\n+ * {@link java.nio.charset.StandardCharsets#ISO_8859_1 ISO-8859-1}.\n+ *\n+ * @apiNote\n+ * Here is an example of encoding a PrivateKey object:\n+ * {@snippet lang = java:\n+ *     PEMEncoder pe = PEMEncoder.of();\n+ *     byte[] pemData = pe.encode(privKey);\n+ * }\n+ *\n+ * @see PKCS8EncodedKeySpec\n+ * @see X509EncodedKeySpec\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc1421\n+ *       RFC 1421: Privacy Enhancement for Internet Electronic Mail\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMEncoder {\n+\n+    \/\/ Singleton instance of PEMEncoder\n+    private static final PEMEncoder PEM_ENCODER = new PEMEncoder(null);\n+\n+    \/\/ Stores the password for an encrypted encoder that isn't setup yet.\n+    private PBEKeySpec keySpec;\n+    \/\/ Stores the key after the encoder is ready to encrypt.  The prevents\n+    \/\/ repeated SecretKeyFactory calls if the encoder is used on multiple keys.\n+    private SecretKey key;\n+    \/\/ Makes SecretKeyFactory generation thread-safe.\n+    private final ReentrantLock lock;\n+    \/\/ Lazy initialize singleton encoder.\n+    private static Base64.Encoder b64Encoder;\n+\n+    \/**\n+     * Instantiate a new PEMEncoder for Encrypted Private Keys.\n+     *\n+     * @param pbe contains the password spec used for encryption.\n+     *\/\n+    private PEMEncoder(PBEKeySpec pbe) {\n+        keySpec = pbe;\n+        lock = new ReentrantLock();\n+    }\n+\n+    \/**\n+     * Returns an instance of PEMEncoder.\n+     *\n+     * @return PEMEncoder instance\n+     *\/\n+    static public PEMEncoder of() {\n+        return PEM_ENCODER;\n+    }\n+\n+    \/**\n+     * Construct a String-based encoding based off the type type.\n+     * @return the string\n+     *\/\n+    private String pemEncoded(PEMRecord pem) {\n+        StringBuilder sb = new StringBuilder(1024);\n+        sb.append(\"-----BEGIN \").append(pem.type()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        if (b64Encoder == null) {\n+            b64Encoder = Base64.getMimeEncoder(64,\n+                System.lineSeparator().getBytes());\n+        }\n+        sb.append(b64Encoder.encodeToString(\n+            pem.pem().getBytes(StandardCharsets.ISO_8859_1)));\n+        sb.append(System.lineSeparator());\n+        sb.append(\"-----END \").append(pem.type()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Encoded a given {@code DEREncodable} and return the PEM encoding in a\n+     * String\n+     *\n+     * @param de a cryptographic object to be PEM encoded that implements\n+     *           DEREncodable.\n+     * @return PEM encoding in a String\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public String encodeToString(DEREncodable de) {\n+        Objects.requireNonNull(de);\n+        return switch (de) {\n+            case PublicKey pu -> buildKey(null, pu.getEncoded());\n+            case PrivateKey pr -> buildKey(pr.getEncoded(), null);\n+            case KeyPair kp -> {\n+                if (kp.getPublic() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PublicKey.\");\n+                }\n+                if (kp.getPrivate() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PrivateKey.\");\n+                }\n+                yield buildKey(kp.getPrivate().getEncoded(),\n+                    kp.getPublic().getEncoded());\n+            }\n+            case X509EncodedKeySpec x ->\n+                buildKey(null, x.getEncoded());\n+            case PKCS8EncodedKeySpec p ->\n+                buildKey(p.getEncoded(), null);\n+            case EncryptedPrivateKeyInfo epki -> {\n+                try {\n+                    yield pemEncoded(new PEMRecord(\n+                        Pem.ENCRYPTED_PRIVATE_KEY, epki.getEncoded()));\n+                } catch (IOException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case X509Certificate c -> {\n+                try {\n+                    if (isEncrypted()) {\n+                        throw new IllegalArgumentException(\"Certificates \" +\n+                            \"cannot be encrypted\");\n+                    }\n+                    yield pemEncoded(new PEMRecord(Pem.CERTIFICATE,\n+                        c.getEncoded()));\n+                } catch (CertificateEncodingException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case X509CRL crl -> {\n+                try {\n+                    if (isEncrypted()) {\n+                        throw new IllegalArgumentException(\"CRLs cannot be \" +\n+                            \"encrypted\");\n+                    }\n+                    yield pemEncoded(new PEMRecord(Pem.X509_CRL,\n+                        crl.getEncoded()));\n+                } catch (CRLException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case PEMRecord rec -> pemEncoded(rec);\n+\n+            default -> throw new IllegalArgumentException(\"PEM does not \" +\n+                \"support \" + de.getClass().getCanonicalName());\n+        };\n+    }\n+\n+    \/**\n+     * Encodes a given {@code DEREncodable} into PEM.\n+     *\n+     * @param de the object that implements DEREncodable.\n+     * @return a PEM encoded byte[] of the given DEREncodable.\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public byte[] encode(DEREncodable de) {\n+        return encodeToString(de).getBytes(StandardCharsets.ISO_8859_1);\n+    }\n+\n+    \/**\n+     * Returns a new immutable PEMEncoder instance configured to the default\n+     * encryption algorithm and a given password.\n+     *\n+     * <p> Only {@link PrivateKey} will be encrypted with this newly configured\n+     * instance.  Other {@link DEREncodable} classes that do not support\n+     * encrypted PEM will cause encode() to throw an IllegalArgumentException.\n+     *\n+     * @implNote Default algorithm defined by Security Property {@code\n+     * jdk.epkcs8.defaultAlgorithm}.  To configure all the encryption options\n+     * see {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, char[], String,\n+     * AlgorithmParameterSpec, Provider)} and use the returned object with\n+     * {@link #encode(DEREncodable)}.\n+     *\n+     * @param password sets the encryption password.  The array is cloned and\n+     *                stored in the new instance. {@code null} is a valid entry.\n+     * @return a new PEMEncoder\n+     *\/\n+    public PEMEncoder withEncryption(char[] password) {\n+        \/\/ PBEKeySpec clones the password\n+        return new PEMEncoder(new PBEKeySpec(password));\n+    }\n+\n+    \/**\n+     * Build PEM encoding.\n+     *\/\n+    private String buildKey(byte[] privateBytes, byte[] publicBytes) {\n+        DerOutputStream out = new DerOutputStream();\n+        Cipher cipher;\n+\n+        if (privateBytes == null && publicBytes == null) {\n+            throw new IllegalArgumentException(\"No encoded data given by the \" +\n+                \"DEREncodable.\");\n+        }\n+\n+        \/\/ If `keySpec` is non-null, then `key` hasn't been established.\n+        \/\/ Setting a `key' prevents repeated key generations operations.\n+        \/\/ withEncryption() is a configuration method and cannot throw an\n+        \/\/ exception; therefore generation is delayed.\n+        if (keySpec != null) {\n+            \/\/ For thread safety\n+            lock.lock();\n+            if (key == null) {\n+                try {\n+                    key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n+                        generateSecret(keySpec);\n+                    keySpec.clearPassword();\n+                    keySpec = null;\n+                } catch (GeneralSecurityException e) {\n+                    throw new SecurityException(\"Security property \" +\n+                        \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                        \"valid algorithm.  Operation cannot be performed.\", e);\n+                } finally {\n+                    lock.unlock();\n+                }\n+            } else {\n+                lock.unlock();\n+            }\n+        }\n+\n+        \/\/ If `key` is non-null, this is an encoder ready to encrypt.\n+        if (key != null) {\n+            if (privateBytes == null || publicBytes != null) {\n+                throw new IllegalArgumentException(\"Can only encrypt a \" +\n+                    \"PrivateKey.\");\n+            }\n+\n+            try {\n+                cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n+                cipher.init(Cipher.ENCRYPT_MODE, key);\n+            } catch (GeneralSecurityException e) {\n+                throw new SecurityException(\"Security property \" +\n+                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                    \"valid algorithm.  Operation cannot be performed.\", e);\n+            }\n+\n+            new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n+                cipher.getParameters()).encode(out);\n+\n+            try {\n+                out.putOctetString(cipher.doFinal(privateBytes));\n+                return pemEncoded(new PEMRecord(Pem.ENCRYPTED_PRIVATE_KEY,\n+                    DerValue.wrap(DerValue.tag_Sequence, out).toByteArray()));\n+            } catch (GeneralSecurityException e) {\n+                throw new IllegalArgumentException(e);\n+            }\n+        }\n+\n+        \/\/ X509 only\n+        if (publicBytes != null && privateBytes == null) {\n+            if (publicBytes.length == 0) {\n+                throw new IllegalArgumentException(\"No public key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n+\n+            return pemEncoded(new PEMRecord(Pem.PUBLIC_KEY, publicBytes));\n+        }\n+\n+        \/\/ PKCS8 only\n+        if (publicBytes == null && privateBytes != null) {\n+            if (privateBytes.length == 0) {\n+                throw new IllegalArgumentException(\"No private key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n+\n+            return pemEncoded(new PEMRecord(Pem.PRIVATE_KEY, privateBytes));\n+        }\n+\n+        \/\/ OneAsymmetricKey\n+        try {\n+            if (privateBytes.length == 0) {\n+                throw new IllegalArgumentException(\"No private key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n+\n+            if (publicBytes.length == 0) {\n+                throw new IllegalArgumentException(\"No public key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n+\n+            return pemEncoded(new PEMRecord(Pem.PRIVATE_KEY,\n+                PKCS8Key.getEncoded(publicBytes, privateBytes)));\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    private boolean isEncrypted() {\n+        return (key != null || keySpec != null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ *\n+ * {@code PEMRecord} is a {@link DEREncodable} that stores Privacy-Enhanced Mail\n+ * (PEM) data and can be used with all PEM data types.  It serves as the default\n+ * decoding class when the PEM data lacks a Java API cryptographic\n+ * representation. Types with representation, such as a {@link PrivateKey},\n+ * can return a {@code PEMRecord} when used with\n+ * {@linkplain PEMDecoder#decode(String, Class)}. Using {@code PEMRecord} can\n+ * be helpful when generating a representation is not desired or when used\n+ * with {@code leadingData}.\n+ * <p>\n+ * {@code PEMRecord} may have a null {@code type} and {@code pem} when\n+ * {@code PEMDecoder.decode()} methods encounter only non-PEM data and has\n+ * reached the end of the stream.\n+ * If there is PEM data, {@code type} and {@code pem} will both be non-null.\n+ * {@code leadingData} may be null if the input data only contains PEM data.\n+ * All values can never be null.\n+ *\n+ * During the instantiation of this record, there is no validation for the\n+ * {@code type} or {@code pem}.\n+ * There is no validity checking for {@code type} or {@code pem} during\n+ * instantiation of this record.\n+ *\n+ * @param type The type identifier in the PEM header.  For a public key,\n+ * {@code type} would be \"PUBLIC KEY\".\n+ * @param pem Any data between the PEM header and footer.\n+ * @param leadingData Any non-PEM data read during the decoding process\n+ * before the PEM header. This can be useful when reading metadata that\n+ * accompanies PEM data.\n+ *\n+ *\/\n+public record PEMRecord(String type, String pem, byte[] leadingData)\n+    implements DEREncodable {\n+\n+    \/**\n+     * Return a PEMRecord instance with the given parameters.\n+     *\n+     * When {@code type} is given a properly formatted PEM header, only the\n+     * identifier will be set (ie: {@code PUBLIC KEY}.  Otherwise, {@code type}\n+     * will be set to what was passed in.\n+     *\n+     * When {@code type} is given a correctly formatted PEM header, only the\n+     * identifier is set (for example, {@code PUBLIC KEY}). Otherwise,\n+     * {@code type} is set to the value that was passed in.\n+     *\n+     * @param type The type identifier in the PEM header and footer.\n+     *             If there is no PEM data, this value will be {@code null}.\n+     * @param pem The data between the PEM header and footer.\n+     * @param leadingData Any non-PEM data read during the decoding process\n+     *                    before the PEM header.  This value maybe {@code null}.\n+     *\/\n+    public PEMRecord(String type, String pem, byte[] leadingData) {\n+\n+        if (type == null && pem == null && leadingData == null) {\n+            throw new IllegalArgumentException(\"All values may not be null.\");\n+        }\n+\n+        if (type == null && pem != null || type != null && pem == null) {\n+            throw new IllegalArgumentException(\"\\\"type\\\" and \\\"pem\\\" must be\" +\n+                \" both null or non-null\");\n+        }\n+\n+        \/\/ With no validity checking on `type`, the constructor accept anything\n+        \/\/ including lowercase.  The onus is on the caller.\n+        if (type != null && type.startsWith(\"-----\")) {\n+            \/\/ Remove PEM headers syntax if present.\n+            this.type = type.substring(11, type.lastIndexOf('-') - 4);\n+        } else {\n+            this.type = type;\n+        }\n+\n+        this.pem = pem;\n+        this.leadingData = leadingData;\n+    }\n+\n+    \/**\n+     * Returns a PEMRecord instance with a given {@code type} and {@code pem}\n+     * data in String form.  {@code leadingData} is set to null.\n+     *\n+     * @param type The type identifier in the PEM header and footer.\n+     *             If there is no PEM data, this value will be {@code null}.\n+     * @param pem The data between the PEM header and footer.\n+     *\n+     * @see #PEMRecord(String, String, byte[])\n+     *\/\n+    public PEMRecord(String type, String pem) {\n+        this(type, pem, null);\n+    }\n+\n+    \/**\n+     * Returns a PEMRecord instance with a given String {@code type} and\n+     * byte array {@code pem}.  {@code leadingData} is set to null.\n+     *\n+     * @param type The type identifier in the PEM header and footer.\n+     *             If there is no PEM data, this value will be {@code null}.\n+     * @param pem The data between the PEM header and footer.\n+     *\n+     * @see #PEMRecord(String, String, byte[])\n+     *\/\n+    public PEMRecord(String type, byte[] pem) {\n+        this(type, new String(pem, StandardCharsets.ISO_8859_1), null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -110,1 +110,1 @@\n-public abstract class X509CRL extends CRL implements X509Extension {\n+public abstract non-sealed class X509CRL extends CRL implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CRL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-public abstract class X509Certificate extends Certificate\n-implements X509Extension {\n+public abstract non-sealed class X509Certificate extends Certificate\n+implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509Certificate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -30,0 +31,1 @@\n+import java.io.IOException;\n@@ -59,0 +61,3 @@\n+     * This constructor extracts the algorithm name from the encoded bytes,\n+     * which may be an OID if no standard algorithm name is defined. If the\n+     * algorithm name cannot be extracted, it is set to null.\n@@ -67,0 +72,5 @@\n+        try {\n+            algorithmName = KeyUtil.getAlgorithm(this.encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.security.DEREncodable;\n+\n@@ -39,1 +41,7 @@\n- *   attributes [0] IMPLICIT Attributes OPTIONAL }\n+ *   attributes       [0] IMPLICIT Attributes OPTIONAL,\n+ *   ...,\n+ *   [[2: publicKey  [1] PublicKey OPTIONAL ]],\n+ *   ...\n+ * }\n+ *\n+ * PrivateKeyInfo ::= OneAsymmetricKey\n@@ -41,1 +49,1 @@\n- * Version ::= INTEGER\n+ * Version ::= INTEGER { v1(0), v2(1) }\n@@ -47,0 +55,2 @@\n+ * PublicKey ::= BIT STRING\n+ *\n@@ -59,0 +69,3 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *     RFC 5958: Asymmetric Key Packages\n+ *\n@@ -62,1 +75,1 @@\n-public class PKCS8EncodedKeySpec extends EncodedKeySpec {\n+public final class PKCS8EncodedKeySpec extends EncodedKeySpec implements DEREncodable {\n@@ -104,1 +117,1 @@\n-     * Returns the key bytes, encoded according to the PKCS #8 standard.\n+     * Returns the private key bytes, encoded according to the PKCS #8 standard.\n@@ -106,1 +119,1 @@\n-     * @return the PKCS #8 encoding of the key. Returns a new array\n+     * @return the PKCS #8 encoding of the private key. Returns a new array\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.security.DEREncodable;\n+\n@@ -52,1 +54,2 @@\n-public class X509EncodedKeySpec extends EncodedKeySpec {\n+public final class X509EncodedKeySpec extends EncodedKeySpec implements\n+    DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,9 @@\n-import java.io.*;\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.IOException;\n@@ -31,4 +39,1 @@\n-import sun.security.x509.AlgorithmId;\n-import sun.security.util.DerValue;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n+import java.util.Objects;\n@@ -58,1 +63,1 @@\n-public class EncryptedPrivateKeyInfo {\n+public final class EncryptedPrivateKeyInfo implements DEREncodable {\n@@ -65,1 +70,1 @@\n-    \/\/ In all other cases, algid is non null and params is null.\n+    \/\/ In all other cases, algid is non-null and params is null.\n@@ -76,7 +81,5 @@\n-     * Constructs (i.e., parses) an {@code EncryptedPrivateKeyInfo} from\n-     * its ASN.1 encoding.\n-     * @param encoded the ASN.1 encoding of this object. The contents of\n-     * the array are copied to protect against subsequent modification.\n-     * @exception NullPointerException if the {@code encoded} is\n-     * {@code null}.\n-     * @exception IOException if error occurs when parsing the ASN.1 encoding.\n+     * Constructs an {@code EncryptedPrivateKeyInfo} from a given Encrypted\n+     * PKCS#8 ASN.1 encoding.\n+     * @param encoded the ASN.1 encoding which is cloned and then parsed.\n+     * @throws NullPointerException if {@code encoded} is {@code null}.\n+     * @throws IOException if error occurs when parsing the ASN.1 encoding.\n@@ -85,4 +88,1 @@\n-        if (encoded == null) {\n-            throw new NullPointerException(\"the encoded parameter \" +\n-                \"must be non-null\");\n-        }\n+        Objects.requireNonNull(encoded);\n@@ -191,0 +191,1 @@\n+\n@@ -204,1 +205,1 @@\n-        \/\/ one and only one is non null\n+        \/\/ one and only one is non-null\n@@ -222,0 +223,11 @@\n+    \/**\n+     * Create an EncryptedPrivateKeyInfo object from the given components\n+     *\/\n+    private EncryptedPrivateKeyInfo(byte[] encoded, byte[] eData,\n+        AlgorithmId id, AlgorithmParameters p) {\n+        this.encoded = encoded;\n+        encryptedData = eData;\n+        algid = id;\n+        params = p;\n+    }\n+\n@@ -311,0 +323,263 @@\n+    \/**\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * PrivateKey.  A valid password-based encryption (PBE) algorithm and\n+     * password must be specified.\n+     *\n+     * {@link AlgorithmParameterSpec} will use the provider default if\n+     * {@code params} is {@code null}.  The {@link Provider} will be selected\n+     * through the default provider list if {@code provider} is {@code null}\n+     *\n+     * The PBE algorithm string format details can be found in the\n+     * <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+     * Cipher section<\/a> of the Java Security Standard Algorithm Names\n+     * Specification.\n+     *\n+     * @param key the PrivateKey object to encrypt.\n+     * @param password the password used for generating the PBE key.\n+     * @param algorithm the PBE encryption algorithm.\n+     * @param params the parameters used with the PBE encryption.\n+     * @param provider the Provider that will perform the encryption.\n+     * @return an EncryptedPrivateKeyInfo.\n+     * @throws IllegalArgumentException when an argument causes an\n+     * initialization error.\n+     * @throws SecurityException on a cryptographic errors.\n+     * @throws NullPointerException if the key, password, or algorithm are null.\n+     * null.\n+     *\n+     * @implNote The encryption uses the algorithm set by\n+     * `jdk.epkcs8.defaultAlgorithm` Security Property\n+     *  and default the {@code AlgorithmParameterSpec} of that provider.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider) {\n+\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(algorithm);\n+        SecretKey skey;\n+\n+        try {\n+            SecretKeyFactory factory;\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+            }\n+            skey = factory.generateSecret(keySpec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        return encryptKeyImpl(key, algorithm, skey, params, provider, null);\n+    }\n+\n+    \/**\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * {@code PrivateKey} and password.  Default algorithm and parameters are\n+     * used.\n+     *\n+     * @param key The {@code PrivateKey} object to encrypt.\n+     * @param password the password used in the PBE encryption.  This array is\n+     *                 cloned before being used.\n+     * @return an {@code EncryptedPrivateKeyInfo}.\n+     * @throws IllegalArgumentException on initialization errors based on the\n+     * arguments passed to the method.\n+     * @throws SecurityException on a encryption errors.\n+     * @throws NullPointerException when the password is null.\n+     *\n+     * @implNote The `jdk.epkcs8.defaultAlgorithm` Security Property defines\n+     * the default encryption algorithm and the {@code AlgorithmParameterSpec}\n+     * are the provider's algorithm defaults.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password) {\n+        char[] pass = password.clone();\n+        if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n+            throw new SecurityException(\"Security property \" +\n+                \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                \"valid algorithm.  Operation cannot be performed.\");\n+        }\n+        return encryptKey(key, pass, Pem.DEFAULT_ALGO,\n+            null, null);\n+    }\n+\n+    \/**\n+     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * {@link PrivateKey} using the {@code encKey} and given parameters.\n+     *\n+     * If {@code algorithm} is {@code null} the default algorithm will be used.\n+     * {@code params} is null, the provider default will be used.\n+     * {@code params} is {@code null}.  The {@code provider} or {@code random} will\n+     * be selected through the default provider list if set to {@code null}.\n+     *\n+     * @param key the {@code PrivateKey} object to encrypt.\n+     * @param encKey the encryption {@code Key}\n+     * @param algorithm the password-based encryption (PBE) algorithm used to\n+     *                  encrypt the key encoding.\n+     * @param params the {@code AlgorithmParameterSpec} to be used with\n+     *               encryption.\n+     * @param random the {@code SecureRandom} instance used during\n+     *               encryption.\n+     * @param provider the {@code Provider} is used for KeyFactory and\n+     *                 encryption operations.\n+     * @return an {@code EncryptedPrivateKeyInfo}.\n+     * @throws IllegalArgumentException on initialization errors based on the\n+     *                                  arguments passed to the method.\n+     * @throws SecurityException on a encryption errors.\n+     * @throws NullPointerException when the {@code key} or {@code encKey} are\n+     * null.\n+     *\n+     * @implNote The encryption uses the algorithm set by\n+     * `jdk.epkcs8.defaultAlgorithm` Security Property by the default provider\n+     * and default the {@code AlgorithmParameterSpec} of that provider.\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key, Key encKey,\n+        String algorithm, AlgorithmParameterSpec params, Provider provider,\n+        SecureRandom random) {\n+        if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n+            throw new SecurityException(\"Security property \" +\n+                \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                \"valid algorithm.  Operation cannot be performed.\");\n+        }\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(encKey);\n+        return encryptKeyImpl(key,\n+            (algorithm == null ? Pem.DEFAULT_ALGO : algorithm), encKey, params,\n+            provider, random);\n+    }\n+\n+\n+    private static EncryptedPrivateKeyInfo encryptKeyImpl(PrivateKey key,\n+        String algorithm, Key encryptKey, AlgorithmParameterSpec params,\n+        Provider provider, SecureRandom random) {\n+        AlgorithmId algId;\n+        byte[] encryptedData;\n+        Cipher c;\n+        DerOutputStream out;\n+\n+        if (random == null) {\n+            random = JCAUtil.getDefSecureRandom();\n+        }\n+        try {\n+            if (provider == null) {\n+                c = Cipher.getInstance(algorithm);\n+            } else {\n+                c = Cipher.getInstance(algorithm, provider);\n+            }\n+            c.init(Cipher.ENCRYPT_MODE, encryptKey, params, random);\n+            encryptedData = c.doFinal(key.getEncoded());\n+            algId = new AlgorithmId(Pem.getPBEID(algorithm), c.getParameters());\n+            out = new DerOutputStream();\n+            algId.encode(out);\n+            out.putOctetString(encryptedData);\n+        } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException |\n+                 NoSuchPaddingException e) {\n+            throw new IllegalArgumentException(e);\n+        } catch (IllegalBlockSizeException | BadPaddingException |\n+                 InvalidKeyException e) {\n+            throw new SecurityException(e);\n+        }\n+        return new EncryptedPrivateKeyInfo(\n+            DerValue.wrap(DerValue.tag_Sequence, out).toByteArray(),\n+            encryptedData, algId, c.getParameters());\n+    }\n+\n+    \/**\n+     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n+     *\n+     * @param password this array is cloned and used for PBE decryption.\n+     *                 {@code null} may be used.\n+     * @return a {@code PrivateKey}\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password) throws InvalidKeyException {\n+        return getKey(password, null);\n+    }\n+\n+    \/**\n+     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n+     * using the given provider.\n+     *\n+     * @param password this array is cloned and used for PBE decryption.\n+     *                 {@code null} may be used.\n+     * @param provider this {@code Provider} is used for all key generations.\n+     *                 It is used when generating the PBE encryption key,\n+     *                 {@code SecretKeyFactory}, and the {@code PrivateKey},\n+     *                 {@code KeyFactory}.  A {@code null} value will use the default\n+     *                 provider configuration.\n+     * @return a {@code PrivateKey}\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password, Provider provider)\n+        throws InvalidKeyException {\n+        return getKeyImpl(new PBEKeySpec(password), provider);\n+    }\n+\n+    private PrivateKey getKeyImpl(PBEKeySpec keySpec, Provider provider)\n+        throws InvalidKeyException {\n+        SecretKeyFactory skf;\n+        PKCS8EncodedKeySpec p8KeySpec;\n+        try {\n+            if (provider == null) {\n+                skf = SecretKeyFactory.getInstance(getAlgName());\n+                p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n+            } else {\n+                skf = SecretKeyFactory.getInstance(getAlgName(), provider);\n+                p8KeySpec = getKeySpec(skf.generateSecret(keySpec), provider);\n+            }\n+\n+            return PKCS8Key.parseKey(p8KeySpec.getEncoded(), provider);\n+        } catch (GeneralSecurityException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code PrivateKey} from the encrypted data in this instance.\n+     * using the given provider.\n+     *\n+     * @param decryptKey this is the decryption key and cannot be {@code null}.\n+     * @param provider this {@code Provider} is used for all key generations.\n+     *                 It is used when generating the PBE encryption key,\n+     *                 {@code SecretKeyFactory}, and the {@code PrivateKey},\n+     *                 {@code KeyFactory}.  A {@code null} value will use the default\n+     *                 provider configuration.\n+     * @return a {@code PrivateKey}\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     * @throws NullPointerException if {@code key} is null.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(Key decryptKey, Provider provider)\n+        throws InvalidKeyException {\n+        try {\n+            PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n+            if (provider == null) {\n+                return KeyFactory.getInstance(p.getAlgorithm())\n+                    .generatePrivate(p);\n+            }\n+            return KeyFactory.getInstance(p.getAlgorithm(),\n+                provider).generatePrivate(p);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n@@ -316,4 +591,3 @@\n-     * @exception NullPointerException if {@code decryptKey}\n-     * is {@code null}.\n-     * @exception NoSuchAlgorithmException if cannot find appropriate\n-     * cipher to decrypt the encrypted data.\n+     * @exception NullPointerException if {@code decryptKey} is {@code null}.\n+     * @exception NoSuchAlgorithmException if cannot find appropriate cipher to\n+     * decrypt.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":298,"deletions":24,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+        \/\/XXX Number will change when assigned\n+        @JEP(number=999, title=\"PEM API\", status=\"Preview\")\n+        PEM_API,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.io.IOException;\n@@ -220,1 +223,1 @@\n-            throws GeneralSecurityException {\n+        throws GeneralSecurityException {\n@@ -222,8 +225,12 @@\n-            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n-            return new ECPublicKeyImpl(x509Spec.getEncoded());\n-        } else if (keySpec instanceof ECPublicKeySpec) {\n-            ECPublicKeySpec ecSpec = (ECPublicKeySpec)keySpec;\n-            return new ECPublicKeyImpl(\n-                ecSpec.getW(),\n-                ecSpec.getParams()\n-            );\n+            return new ECPublicKeyImpl(((X509EncodedKeySpec)keySpec).getEncoded());\n+\n+        } else if (keySpec instanceof ECPublicKeySpec ecSpec) {\n+            return new ECPublicKeyImpl(ecSpec.getW(), ecSpec.getParams());\n+\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new ECPrivateKeyImpl(p8.getEncoded());\n+            if (p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            return new ECPublicKeyImpl(p8key.getPubKeyEncoded());\n+\n@@ -231,2 +238,2 @@\n-            throw new InvalidKeySpecException(\"Only ECPublicKeySpec \"\n-                + \"and X509EncodedKeySpec supported for EC public keys\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \" not supported.\");\n@@ -240,2 +247,1 @@\n-            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;\n-            byte[] encoded = pkcsSpec.getEncoded();\n+            byte[] encoded = ((PKCS8EncodedKeySpec) keySpec).getEncoded();\n@@ -247,2 +253,2 @@\n-        } else if (keySpec instanceof ECPrivateKeySpec) {\n-            ECPrivateKeySpec ecSpec = (ECPrivateKeySpec)keySpec;\n+\n+        } else if (keySpec instanceof ECPrivateKeySpec ecSpec) {\n@@ -250,0 +256,1 @@\n+\n@@ -251,2 +258,3 @@\n-            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \"\n-                + \"and PKCS8EncodedKeySpec supported for EC private keys\");\n+            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \" +\n+                \"and PKCS8EncodedKeySpec supported for EC private keys. \" +\n+                keySpec.getClass().getName() + \" provided.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import sun.security.x509.X509Key;\n@@ -114,1 +115,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -136,1 +137,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -156,1 +157,1 @@\n-    private byte[] getArrayS0() {\n+    public byte[] getArrayS() {\n@@ -160,5 +161,1 @@\n-        return arrayS;\n-    }\n-\n-    public byte[] getArrayS() {\n-        return getArrayS0().clone();\n+        return arrayS.clone();\n@@ -172,0 +169,3 @@\n+    \/**\n+     * Parse the ASN.1 of the privateKey Octet\n+     *\/\n@@ -173,0 +173,1 @@\n+        \/\/ Parse private key material from PKCS8Key.decode()\n@@ -174,1 +175,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n@@ -190,3 +191,11 @@\n-                    \/\/ ignore for now\n-                } else if (value.isContextSpecific((byte) 1)) {\n-                    \/\/ ignore for now\n+                    attributes = value.getDataBytes();  \/\/ Save DER sequence\n+                    if (data.available() == 0) {\n+                        return;\n+                    }\n+                    value = data.getDerValue();\n+                }\n+                if (value.isContextSpecific((byte) 1)) {\n+                    DerValue bits = value.withTag(DerValue.tag_BitString);\n+                    BitArray bitArray = bits.data.getUnalignedBitString();\n+                    pubKeyEncoded = new X509Key(algid,\n+                        bitArray).getEncoded();\n@@ -197,0 +206,2 @@\n+\n+            \/\/ Validate parameters stored from PKCS8Key.decode()\n@@ -208,1 +219,0 @@\n-    @Override\n@@ -213,1 +223,1 @@\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS0());\n+        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,4 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.io.IOException;\n+import java.security.*;\n@@ -163,0 +161,10 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new XDHPrivateKeyImpl(p8.getEncoded());\n+            if (!p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            XDHPublicKeyImpl result =\n+                new XDHPublicKeyImpl(p8key.getPubKeyEncoded());\n+            checkLockedParams(InvalidKeySpecException::new,\n+                result.getParams());\n+            return result;\n@@ -164,2 +172,2 @@\n-            throw new InvalidKeySpecException(\n-                \"Only X509EncodedKeySpec and XECPublicKeySpec are supported\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            this.key = val.toByteArray();\n+            this.privKeyMaterial = val.toByteArray();\n@@ -70,1 +70,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -105,1 +105,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,3 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.security.*;\n@@ -156,0 +153,6 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new EdDSAPrivateKeyImpl(p8.getEncoded());\n+            if (!p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            return new EdDSAPublicKeyImpl(p8key.getPubKeyEncoded());\n@@ -157,2 +160,2 @@\n-            throw new InvalidKeySpecException(\n-                \"Only X509EncodedKeySpec and EdECPublicKeySpec are supported\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \" not supported.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-            this.key = val.toByteArray();\n+            privKeyMaterial = val.toByteArray();\n@@ -74,1 +74,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -84,2 +84,2 @@\n-        if (params.getKeyLength() != this.h.length) {\n-            throw new InvalidKeyException(\"key length is \" + this.h.length +\n+        if (params.getKeyLength() != h.length) {\n+            throw new InvalidKeyException(\"key length is \" + h.length +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            this.key = val.toByteArray();\n+            this.privKeyMaterial = val.toByteArray();\n@@ -93,1 +93,1 @@\n-            rawBytes = new DerInputStream(key).getOctetString();\n+            rawBytes = new DerInputStream(privKeyMaterial).getOctetString();\n@@ -132,1 +132,1 @@\n-        Arrays.fill(key, (byte)0);\n+        Arrays.fill(privKeyMaterial, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,8 @@\n-import java.io.*;\n-import java.security.Key;\n-import java.security.KeyRep;\n-import java.security.PrivateKey;\n-import java.security.KeyFactory;\n-import java.security.MessageDigest;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.security.*;\n@@ -39,4 +39,1 @@\n-\n-import jdk.internal.access.SharedSecrets;\n-import sun.security.x509.*;\n-import sun.security.util.*;\n+import java.util.Optional;\n@@ -46,1 +43,1 @@\n- *\n+ * <p>\n@@ -58,1 +55,1 @@\n- *\n+ * <p>\n@@ -70,2 +67,2 @@\n-    \/* The key bytes, without the algorithm information *\/\n-    protected byte[] key;\n+    \/* The private key OctetString for the algorithm subclasses to decode *\/\n+    protected byte[] privKeyMaterial;\n@@ -73,1 +70,1 @@\n-    \/* The encoded for the key. Created on demand by encode(). *\/\n+    \/* The pkcs8 encoding of this key(s). Created on demand. *\/\n@@ -76,0 +73,9 @@\n+    \/* The encoded x509 public key for v2 *\/\n+    protected byte[] pubKeyEncoded = null;\n+\n+    \/* ASN.1 Attributes *\/\n+    protected byte[] attributes;\n+\n+    \/* PKCS8 version of the PEM *\/\n+    protected int version;\n+\n@@ -83,1 +89,1 @@\n-     * {@link #algid} and {@link #key}.\n+     * {@link #algid} and {@link #privKeyMaterial}.\n@@ -94,1 +100,1 @@\n-    protected PKCS8Key(byte[] input) throws InvalidKeyException {\n+    public PKCS8Key(byte[] input) throws InvalidKeyException {\n@@ -102,0 +108,16 @@\n+    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+        throws InvalidKeyException {\n+        this(privEncoding);\n+        pubKeyEncoded = pubEncoding;\n+        version = V2;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    \/**\n+     * Method for decoding PKCS8 v1 and v2 formats. Decoded values are stored\n+     * in this class, key material remains in DER format for algorithm\n+     * subclasses to decode.\n+     *\/\n@@ -108,1 +130,2 @@\n-            int version = val.data.getInteger();\n+            \/\/ Support check for V1, aka 0, and V2, aka 1.\n+            version = val.data.getInteger();\n@@ -112,2 +135,2 @@\n-            algid = AlgorithmId.parse (val.data.getDerValue ());\n-            key = val.data.getOctetString();\n+            \/\/ Parse and store AlgorithmID\n+            algid = AlgorithmId.parse(val.data.getDerValue());\n@@ -115,1 +138,4 @@\n-            DerValue next;\n+            \/\/ Store key material for subclasses to parse\n+            privKeyMaterial = val.data.getOctetString();\n+\n+            \/\/ PKCS8 v1 typically ends here\n@@ -119,2 +145,7 @@\n-            next = val.data.getDerValue();\n-            if (next.isContextSpecific((byte)0)) {\n+\n+            \/\/ OPTIONAL Context tag 0 for Attributes for PKCS8 v1 & v2\n+            \/\/ Uses 0xA0 context-specific\/constructed or 0x80\n+            \/\/ context-specific\/primitive.\n+            DerValue v = val.data.getDerValue();\n+            if (v.isContextSpecific((byte)0)) {\n+                attributes = v.getDataBytes();  \/\/ Save DER sequence\n@@ -124,1 +155,1 @@\n-                next = val.data.getDerValue();\n+                v = val.data.getDerValue();\n@@ -127,3 +158,8 @@\n-            if (next.isContextSpecific((byte)1)) {\n-                if (version == V1) {\n-                    throw new InvalidKeyException(\"publicKey seen in v1\");\n+            \/\/ OPTIONAL context tag 1 for Public Key for PKCS8 v2 only\n+            if (version == V2) {\n+                if (v.isContextSpecific((byte)1)) {\n+                    DerValue bits = v.withTag(DerValue.tag_BitString);\n+                    pubKeyEncoded = new X509Key(algid,\n+                        bits.getUnalignedBitString()).getEncoded();\n+                } else {\n+                    throw new InvalidKeyException(\"Invalid context tag\");\n@@ -135,0 +171,1 @@\n+\n@@ -159,1 +196,7 @@\n-    public static PrivateKey parseKey(byte[] encoded) throws IOException {\n+    public static PrivateKey parseKey(byte[] encoded)\n+        throws InvalidKeyException {\n+        return parseKey(encoded, null);\n+    }\n+\n+    public static PrivateKey parseKey(byte[] encoded, Provider provider)\n+        throws InvalidKeyException {\n@@ -162,2 +205,3 @@\n-            byte[] internal = rawKey.getEncodedInternal();\n-            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(internal);\n+            byte[] internal = rawKey.generateEncoding();\n+            PKCS8EncodedKeySpec pkcs8KeySpec =\n+                new PKCS8EncodedKeySpec(internal);\n@@ -166,1 +210,2 @@\n-                result = KeyFactory.getInstance(rawKey.algid.getName())\n+                if (provider == null) {\n+                    result = KeyFactory.getInstance(rawKey.algid.getName())\n@@ -168,0 +213,4 @@\n+                } else {\n+                    result = KeyFactory.getInstance(rawKey.algid.getName(),\n+                        provider).generatePrivate(pkcs8KeySpec);\n+                }\n@@ -179,2 +228,2 @@\n-        } catch (InvalidKeyException e) {\n-            throw new IOException(\"corrupt private key\", e);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(e);\n@@ -191,0 +240,12 @@\n+    public byte[] getPubKeyEncoded() {\n+        return pubKeyEncoded;\n+    }\n+\n+    public byte[] getPrivKeyMaterial() {\n+        return privKeyMaterial;\n+    }\n+\n+    public boolean hasPublicKey() {\n+        return (pubKeyEncoded == null ? false : true);\n+    }\n+\n@@ -194,1 +255,1 @@\n-    public AlgorithmId  getAlgorithmId () {\n+    public AlgorithmId getAlgorithmId () {\n@@ -213,0 +274,20 @@\n+    \/**\n+     * With a given encoded Public and Private key, generate and return a\n+     * PKCS8v2 DER-encoded byte[].\n+     *\n+     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param privKeyEncoded DER-encoded PrivateKey\n+     * @return DER-encoded byte array\n+     * @throws IOException thrown on encoding failure\n+     *\/\n+    public static byte[] getEncoded(byte[] pubKeyEncoded, byte[] privKeyEncoded)\n+        throws IOException {\n+        PKCS8Key privKey;\n+        try {\n+            privKey = new PKCS8Key(privKeyEncoded, pubKeyEncoded);\n+        } catch (InvalidKeyException e) {\n+            throw new IOException(e);\n+        }\n+        return privKey.generateEncoding();\n+    }\n+\n@@ -221,7 +302,33 @@\n-            DerOutputStream tmp = new DerOutputStream();\n-            tmp.putInteger(V1);\n-            algid.encode(tmp);\n-            tmp.putOctetString(key);\n-            DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-            encodedKey = out.toByteArray();\n-            out.clear();\n+            try {\n+                encodedKey = generateEncoding();\n+            } catch (IOException e) {\n+                \/\/ encodedKey is still null\n+                throw new SecurityException(e);\n+            }\n+        }\n+        return encodedKey;\n+    }\n+\n+    private byte[] generateEncoding() throws IOException {\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(version);\n+        algid.encode(out);\n+        out.putOctetString(privKeyMaterial);\n+\n+        if (version == V2) {\n+            if (attributes != null) {\n+                out.writeImplicit(\n+                    DerValue.createTag((byte) (DerValue.TAG_CONTEXT |\n+                        DerValue.TAG_CONSTRUCT), false, (byte) 0),\n+                    new DerOutputStream().putOctetString(attributes));\n+\n+            }\n+\n+            if (pubKeyEncoded != null) {\n+                X509Key x = (X509Key) X509Key.parseKey(pubKeyEncoded);\n+                DerOutputStream pubOut = new DerOutputStream();\n+                pubOut.putUnalignedBitString(x.getKey());\n+                out.writeImplicit(\n+                    DerValue.createTag(DerValue.TAG_CONTEXT, false,\n+                        (byte) 1), pubOut);\n+            }\n@@ -229,0 +336,4 @@\n+\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        encodedKey = val.toByteArray();\n+        val.clear();\n@@ -301,1 +412,1 @@\n-        Arrays.fill(key, (byte)0);\n+        Arrays.fill(privKeyMaterial, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":156,"deletions":45,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -84,1 +84,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPrivateKey.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -303,2 +303,2 @@\n-        } catch (IOException ioe) {\n-            throw new UnrecoverableKeyException(ioe.getMessage());\n+        } catch (InvalidKeyException e) {\n+            throw new UnrecoverableKeyException(e.getMessage());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.security.PEMRecord;\n@@ -39,0 +40,1 @@\n+import sun.security.util.Pem;\n@@ -559,65 +561,6 @@\n-            \/\/ Read BASE64 encoded data, might skip info at the beginning\n-            ByteArrayOutputStream data = new ByteArrayOutputStream();\n-\n-            \/\/ Step 1: Read until header is found\n-            int hyphen = (c=='-') ? 1: 0;   \/\/ count of consequent hyphens\n-            int last = (c=='-') ? -1: c;    \/\/ the char before hyphen\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    \/\/ We accept useless data after the last block,\n-                    \/\/ say, empty lines.\n-                    return null;\n-                }\n-                if (next == '-') {\n-                    hyphen++;\n-                } else {\n-                    hyphen = 0;\n-                    last = next;\n-                }\n-                if (hyphen == 5 && (last == -1 || last == '\\r' || last == '\\n')) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 2: Read the rest of header, determine the line end\n-            int end;\n-            StringBuilder header = new StringBuilder(\"-----\");\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next == '\\n') {\n-                    end = '\\n';\n-                    break;\n-                }\n-                if (next == '\\r') {\n-                    next = is.read();\n-                    if (next == -1) {\n-                        throw new IOException(\"Incomplete data\");\n-                    }\n-                    if (next == '\\n') {\n-                        end = '\\n';\n-                    } else {\n-                        end = '\\r';\n-                        \/\/ Skip all white space chars\n-                        if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                            data.write(next);\n-                        }\n-                    }\n-                    break;\n-                }\n-                header.append((char)next);\n-            }\n-\n-            \/\/ Step 3: Read the data\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next != '-') {\n-                    \/\/ Skip all white space chars\n-                    if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                        data.write(next);\n+            try {\n+                PEMRecord rec;\n+                try {\n+                    rec = Pem.readPEM(is, (c == '-' ? true : false));\n+                    if (rec.pem() == null) {\n+                        return null;\n@@ -625,13 +568,2 @@\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 4: Consume the footer\n-            StringBuilder footer = new StringBuilder(\"-\");\n-            while (true) {\n-                int next = is.read();\n-                \/\/ Add next == '\\n' for maximum safety, in case endline\n-                \/\/ is not consistent.\n-                if (next == -1 || next == end || next == '\\n') {\n-                    break;\n+                } catch (EOFException e) {\n+                    return null;\n@@ -639,8 +571,1 @@\n-                if (next != '\\r') footer.append((char)next);\n-            }\n-\n-            checkHeaderFooter(header.toString().stripTrailing(),\n-                    footer.toString().stripTrailing());\n-\n-            try {\n-                return Base64.getDecoder().decode(data.toByteArray());\n+                return Base64.getDecoder().decode(rec.pem());\n@@ -653,18 +578,0 @@\n-    private static void checkHeaderFooter(String header,\n-            String footer) throws IOException {\n-        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n-                !header.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal header: \" + header);\n-        }\n-        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n-                !footer.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal footer: \" + footer);\n-        }\n-        String headerType = header.substring(11, header.length()-5);\n-        String footerType = footer.substring(9, footer.length()-5);\n-        if (!headerType.equals(footerType)) {\n-            throw new IOException(\"Header and footer do not match: \" +\n-                    header + \" \" + footer);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":12,"deletions":105,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -335,0 +336,7 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec p8) {\n+            PKCS8Key p8key = new PKCS8Key(p8.getEncoded());\n+            if (!p8key.hasPublicKey()) {\n+                throw new InvalidKeySpecException(\"No public key found.\");\n+            }\n+            return RSAPublicKeyImpl.newKey(type, \"X.509\",\n+                p8key.getPubKeyEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    \/\/ RSA or RSS-PSS KeyType\n@@ -104,1 +105,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -240,1 +241,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -307,1 +308,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -340,1 +341,1 @@\n-            BigInteger[] comps = parseASN1(key);\n+            BigInteger[] comps = parsePKCS1(privKeyMaterial);\n@@ -354,0 +355,25 @@\n+    \/**\n+     * With a given PKCS#1\/slleay\/OpenSSL old default RSA binary encoding,\n+     * decode and return the proper RSA encoded KeySpec\n+     * @param encoded RSA binary encoding\n+     * @return KeySpec\n+     * @throws InvalidKeyException on decoding failure\n+     *\/\n+\n+    public static KeySpec getKeySpec(byte[] encoded) throws\n+        InvalidKeyException {\n+        try {\n+            BigInteger[] comps = parsePKCS1(encoded);\n+            if ((comps[1].signum() == 0) || (comps[3].signum() == 0) ||\n+                (comps[4].signum() == 0) || (comps[5].signum() == 0) ||\n+                (comps[6].signum() == 0) || (comps[7].signum() == 0)) {\n+                return new RSAPrivateKeySpec(comps[0], comps[2]);\n+            } else {\n+                return new RSAPrivateCrtKeySpec(comps[0],\n+                    comps[1], comps[2], comps[3], comps[4], comps[5],\n+                    comps[6], comps[7]);\n+            }\n+        } catch (IOException ioe) {\n+            throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -202,1 +202,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -221,1 +221,1 @@\n-            BigInteger[] comps = parseASN1(getKey().toByteArray());\n+            BigInteger[] comps = parsePKCS1(getKey().toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    public static final byte TAG_CONSTRUCT = (byte)0x020;\n@@ -194,1 +195,1 @@\n-     * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.\n+     * Returns true if the CONTEXT SPECIFIC bit is set in the type tag.\n@@ -200,1 +201,1 @@\n-     * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.\n+     * Returns true if the CONTEXT SPECIFIC TAG matches the passed tag.\n@@ -211,1 +212,1 @@\n-    \/** Returns true iff the CONSTRUCTED bit is set in the type tag. *\/\n+    \/** Returns true if the CONSTRUCTED bit is set in the type tag. *\/\n@@ -215,1 +216,1 @@\n-     * Returns true iff the CONSTRUCTED TAG matches the passed tag.\n+     * Returns true if the CONSTRUCTED TAG matches the passed tag.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -432,0 +433,50 @@\n+\n+    \/**\n+     * With a given DER encoded bytes, read through and return the AlgorithmID\n+     * stored if it can be found.\n+     *\n+     * @param encoded DER encoded bytes\n+     * @return AlgorithmID stored in the DER encoded bytes\n+     * @throws IOException\n+     *\/\n+    public static AlgorithmId getAlgorithm(byte[] encoded) throws IOException {\n+        DerInputStream is = new DerInputStream(encoded);\n+        DerValue value = is.getDerValue();\n+        if (value.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Unknown DER Format:  Value 1 not a Sequence\");\n+        }\n+\n+        is = value.data;\n+        value = is.getDerValue();\n+        \/\/ This route is for:  RSAPublic, Encrypted RSAPrivate, EC Public,\n+        \/\/ Encrypted EC Private,\n+        if (value.tag == DerValue.tag_Sequence) {\n+            return AlgorithmId.parse(value);\n+        } else if (value.tag == DerValue.tag_Integer) {\n+            \/\/ RSAPrivate, ECPrivate\n+            \/\/ current value is version, which can be ignored\n+            value = is.getDerValue();\n+            if (value.tag == DerValue.tag_OctetString) {\n+                value = is.getDerValue();\n+                if (value.tag == DerValue.tag_Sequence) {\n+                    return AlgorithmId.parse(value);\n+                } else {\n+                    \/\/ OpenSSL\/X9.62 (0xA0)\n+                    ObjectIdentifier oid = value.data.getOID();\n+                    AlgorithmId algo = new AlgorithmId(oid, (AlgorithmParameters) null);\n+                    if (CurveDB.lookup(algo.getName()) != null) {\n+                        return new AlgorithmId(AlgorithmId.EC_oid);\n+                    }\n+\n+                }\n+\n+            } else if (value.tag == DerValue.tag_Sequence) {\n+                \/\/ Public Key\n+                return AlgorithmId.parse(value);\n+            }\n+\n+        }\n+        throw new IOException(\"No algorithm detected\");\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-            ECPoint g, BigInteger n, int h) {\n+        ECPoint g, BigInteger n, int h) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/NamedCurve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import java.io.IOException;\n+import sun.security.x509.AlgorithmId;\n+\n+import java.io.*;\n@@ -30,0 +32,4 @@\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PEMRecord;\n+import java.security.Security;\n+import java.util.Arrays;\n@@ -31,0 +37,3 @@\n+import java.util.HexFormat;\n+import java.util.Objects;\n+import java.util.regex.Pattern;\n@@ -36,0 +45,23 @@\n+    private static final char WS = 0x20;  \/\/ Whitespace\n+\n+    \/\/ Default algorithm from jdk.epkcs8.defaultAlgorithm in java.security\n+    public static final String DEFAULT_ALGO;\n+\n+    \/\/ Pattern matching for EKPI operations\n+    private static final Pattern pbePattern;\n+\n+    \/\/ Lazy initialized PBES2 OID value\n+    private static ObjectIdentifier PBES2OID;\n+\n+    static {\n+        DEFAULT_ALGO = Security.getProperty(\"jdk.epkcs8.defaultAlgorithm\");\n+        pbePattern = Pattern.compile(\"^PBEWith.*And.*\");\n+    }\n+\n+    public static final String CERTIFICATE = \"CERTIFICATE\";\n+    public static final String X509_CERTIFICATE = \"X509 CERTIFICATE\";\n+    public static final String X509_CRL = \"X509 CRL\";\n+    public static final String PUBLIC_KEY = \"PUBLIC KEY\";\n+    public static final String RSA_PRIVATE_KEY = \"RSA PRIVATE KEY\";\n+    public static final String ENCRYPTED_PRIVATE_KEY = \"ENCRYPTED PRIVATE KEY\";\n+    public static final String PRIVATE_KEY = \"PRIVATE KEY\";\n@@ -43,1 +75,0 @@\n-     * @throws java.io.IOException if input is invalid\n@@ -45,4 +76,3 @@\n-    public static byte[] decode(String input) throws IOException {\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\")\n-                .getBytes(StandardCharsets.ISO_8859_1);\n-        try {\n+    public static byte[] decode(String input) {\n+        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+            getBytes(StandardCharsets.ISO_8859_1);\n@@ -50,2 +80,106 @@\n-        } catch (IllegalArgumentException e) {\n-            throw new IOException(e);\n+    }\n+\n+    \/**\n+     * Return the OID for a given PBE algorithm.  PBES1 has an OID for each\n+     * algorithm, while PBES2 has one OID for everything that complies with\n+     * the formatting.  Therefore, if the algorithm is not PBES1, it will\n+     * return PBES2.  Cipher will determine if this is a valid PBE algorithm.\n+     * PBES2 specifies AES as the cipher algorithm, but any block cipher could\n+     * be supported.\n+     *\/\n+    public static ObjectIdentifier getPBEID(String algorithm) {\n+\n+        \/\/ Verify pattern matches PBE Standard Name spec\n+        if (!pbePattern.matcher(algorithm).matches()) {\n+            throw new IllegalArgumentException(\"Invalid algorithm format.\");\n+        }\n+\n+        \/\/ Return the PBES1 OID if it matches\n+        try {\n+            return AlgorithmId.get(algorithm).getOID();\n+        } catch (NoSuchAlgorithmException e) {\n+            \/\/ fall-through\n+        }\n+\n+        \/\/ Lazy initialize\n+        if (PBES2OID == null) {\n+            try {\n+                \/\/ Set to the hardcoded OID in KnownOID.java\n+                PBES2OID = AlgorithmId.get(\"PBES2\").getOID();\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ Should never fail.\n+                throw new IllegalArgumentException(e);\n+            }\n+        }\n+        return PBES2OID;\n+    }\n+\n+    \/**\n+     * Read the PEM text and return it in it's three components:  header,\n+     * base64, and footer.\n+     *\n+     * The method will leave the stream after reading the end of line of the\n+     * footer or end of file\n+     * @param is The pem data\n+     * @param shortHeader if true, the hyphen length is 4 because the first\n+     *                    hyphen is assumed to have been read.  This is needed\n+     *                    for the CertificateFactory X509 implementation.\n+     * @return A new Pem object containing the three components\n+     * @throws IOException on read errors\n+     * @throws EOFException when there is nothing to read\n+     *\/\n+    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+\n+        int hyphen = (shortHeader ? 1 : 0);\n+        int eol = 0;\n+\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(6);\n+        \/\/ Find starting hyphens\n+        do {\n+            int d = is.read();\n+            switch (d) {\n+                case '-' -> hyphen++;\n+                case -1 -> {\n+                    if (os.size() == 0) {\n+                        throw new EOFException(\"No data available\");\n+                    }\n+                    return new PEMRecord(null, null, os.toByteArray());\n+                }\n+                default -> hyphen = 0;\n+            }\n+            os.write(d);\n+        } while (hyphen != 5);\n+\n+        StringBuilder sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+        hyphen = 0;\n+        int c;\n+\n+        \/\/ Get header definition until first hyphen\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                case '\\n', '\\r' -> throw new IllegalArgumentException(\n+                    \"Incomplete header\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify header ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                default ->\n+                    throw new IllegalArgumentException(\"Incomplete header\");\n+            }\n+        } while (hyphen < 5);\n+\n+        sb.append(\"-----\");\n+        String header = sb.toString();\n+        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n+            !header.endsWith(\"-----\")) {\n+            throw new IllegalArgumentException(\"Illegal header: \" + header);\n@@ -53,0 +187,103 @@\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(1024);\n+\n+        \/\/ Determine the line break using the char after the last hyphen\n+        switch (is.read()) {\n+            case WS -> {} \/\/ skip whitespace\n+            case '\\r' -> {\n+                c = is.read();\n+                if (c == '\\n') {\n+                    eol = '\\n';\n+                } else {\n+                    eol = '\\r';\n+                    sb.append((char) c);\n+                }\n+            }\n+            case '\\n' -> eol = '\\n';\n+            default ->\n+                throw new IllegalArgumentException(\"No EOL character found\");\n+        }\n+\n+        \/\/ Read data until we find the first footer hyphen.\n+        do {\n+            switch (c = is.read()) {\n+                case -1 ->\n+                    throw new IllegalArgumentException(\"Incomplete header\");\n+                case '-' -> hyphen++;\n+                case WS, '\\t', '\\n', '\\r' -> {} \/\/ skip whitespace, tab, etc\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        String data = sb.toString();\n+\n+        \/\/ Verify footer starts with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> throw new IllegalArgumentException(\n+                    \"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+\n+        \/\/ Look for Complete header by looking for the end of the hyphens\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> throw new IllegalArgumentException(\n+                    \"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        while ((c = is.read()) != eol && c != -1 && c != '\\r' && c != WS) {\n+            throw new IllegalArgumentException(\"Invalid PEM format:  \" +\n+                \"No EOL char found in footer:  0x\" +\n+                HexFormat.of().toHexDigits((byte) c));\n+        }\n+\n+        sb.append(\"-----\");\n+        String footer = sb.toString();\n+        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n+            !footer.endsWith(\"-----\")) {\n+            throw new IllegalArgumentException(\"Illegal footer: \" + footer);\n+        }\n+\n+        \/\/ Verify the object type in the header and the footer are the same.\n+        String headerType = header.substring(11, header.length() - 5);\n+        String footerType = footer.substring(9, footer.length() - 5);\n+        if (!headerType.equals(footerType)) {\n+            throw new IllegalArgumentException(\"Header and footer do not \" +\n+                \"match: \" + headerType + \" \" + footerType);\n+        }\n+\n+        \/\/ If there was data before finding the 5 dashes of the PEM header,\n+        \/\/ backup 5 characters and save that data.\n+        byte[] preData = null;\n+        if (os.size() > 5) {\n+            preData = Arrays.copyOf(os.toByteArray(), os.size() - 5);\n+        }\n+\n+        return new PEMRecord(header, data, preData);\n+    }\n+\n+    public static PEMRecord readPEM(InputStream is) throws IOException {\n+        return readPEM(is, false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":246,"deletions":9,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -86,1 +85,2 @@\n-    private X509Key(AlgorithmId algid, BitArray key) {\n+    @SuppressWarnings(\"this-escape\")\n+    public X509Key(AlgorithmId algid, BitArray key) {\n@@ -103,1 +103,1 @@\n-    protected BitArray getKey() {\n+    public BitArray getKey() {\n@@ -157,1 +157,1 @@\n-        encode();\n+        getEncodedInternal();\n@@ -246,1 +246,1 @@\n-    public AlgorithmId  getAlgorithmId() { return algid; }\n+    public AlgorithmId getAlgorithmId() { return algid; }\n@@ -263,1 +263,1 @@\n-    public byte[] getEncodedInternal() {\n+    private byte[] getEncodedInternal() {\n@@ -317,1 +317,1 @@\n-    void decode(DerValue val) throws InvalidKeyException {\n+    public void decode(DerValue val) throws InvalidKeyException {\n@@ -341,0 +341,18 @@\n+    \/**\n+     * Parses X509 public key.  With PKCS8v2 allowing public keys in private key\n+     * encoding, this method allows PKCS8Key access, but keeps the code in this\n+     * file.\n+     *\/\n+    public static PublicKey parseKey(byte[] encoded) throws IOException {\n+        PublicKey pubKey;\n+        try {\n+            X509EncodedKeySpec spec = new X509EncodedKeySpec(encoded);\n+            pubKey = KeyFactory.getInstance(spec.getAlgorithm())\n+                .generatePublic(spec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            \/\/ Ignore and return raw key\n+            throw new IOException(\"error with encoding\");\n+        }\n+        return pubKey;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1529,0 +1529,8 @@\n+\n+#\n+# Default algorithm for PEMEncoder Encrypted PKCS#8\n+#\n+# This property defines default Public-based Encryption algorithm for\n+# java.security.PEMEncoder is configured for encryption with `withEncryption()`.\n+#\n+jdk.epkcs8.defaultAlgorithm=PBEWithHmacSHA256AndAES_128\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +128,1 @@\n-    public static class FakeX509Spec extends X509EncodedKeySpec {\n+    public static class FakeX509Spec extends EncodedKeySpec {\n@@ -135,0 +136,5 @@\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,427 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.DEREncodable;\n+import java.security.KeyPair;\n+import java.security.PEMRecord;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.*;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Library class for PEMEncoderTest and PEMDecoderTest\n+ *\/\n+class PEMData {\n+    public static final Entry ecsecp256 = new Entry(\"ecsecp256\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgkW3Jx561NlEgBnut\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqhRANCAASL+REY4vvAI9M3gonaml5K3lRgHq5w\n+        +OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fop224ANvB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry rsapriv = new Entry(\"rsapriv\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\n+        WqcWcoJqfdLEyBT+\n+        -----END PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    public static final Entry rsaprivbc = new Entry(\"rsaprivbc\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\n+        WqcWcoJqfdLEyBT+\n+        -----END PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    public static final Entry ec25519priv = new Entry(\"ed25519priv\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MC4CAQAwBQYDK2VwBCIEIFFZsmD+OKk67Cigc84\/2fWtlKsvXWLSoMJ0MHh4jI4I\n+        -----END PRIVATE KEY-----\n+        \"\"\", EdECPrivateKey.class);\n+\n+    public static final Entry rsapub = new Entry(\"rsapub\",\n+        \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\n+        XCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PUBLIC KEY-----\n+        \"\"\", RSAPublicKey.class);\n+\n+    public static final Entry rsapubbc = new Entry(\"rsapubbc\",\n+        \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\n+        XCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PUBLIC KEY-----\n+        \"\"\", RSAPublicKey.class);\n+\n+    public static final Entry ecsecp256pub = new Entry(\"ecsecp256pub\", \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi\/kRGOL7wCPTN4KJ2ppeSt5UYB6u\n+        cPjjuKDtFTXbguOIFDdZ65O\/8HTUqS\/sVzRF+dg7H3\/tkQ\/36KdtuADbwQ==\n+        -----END PUBLIC KEY-----\n+        \"\"\", ECPublicKey.class);\n+\n+    \/\/ EC key with explicit parameters -- Not currently supported by SunEC\n+    public static final String pubec_explicit = \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIIBSzCCAQMGByqGSM49AgEwgfcCAQEwLAYHKoZIzj0BAQIhAP\/\/\/\/8AAAABAAAA\n+        AAAAAAAAAAAA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/MFsEIP\/\/\/\/8AAAABAAAAAAAAAAAAAAAA\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/8BCBaxjXYqjqT57PrvVV2mIa8ZR0GsMxTsPY7zjw+J9JgSwMVAMSd\n+        NgiG5wSTamZ44ROdJreBn36QBEEEaxfR8uEsQkf4vOblY6RA8ncDfYEt6zOg9KE5\n+        RdiYwpZP40Li\/hp\/m47n60p8D54WK84zV2sxXs7LtkBoN79R9QIhAP\/\/\/\/8AAAAA\n+        \/\/\/\/\/\/\/\/\/\/+85vqtpxeehPO5ysL8YyVRAgEBA0IABIv5ERji+8Aj0zeCidqaXkre\n+        VGAernD447ig7RU124LjiBQ3WeuTv\/B01Kkv7Fc0RfnYOx9\/7ZEP9+inbbgA28E=\n+        -----END PUBLIC KEY-----\n+        \"\"\";\n+\n+    public static final Entry oasbcpem = new Entry(\"oasbcpem\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIIDCAIBATANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZbOdOvmvU3jl7+\n+        cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW3qGR2DuBEaMy0mkg8hfKcSpH\n+        LaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAEC\n+        gYEAwNkDkTv5rlX8nWLuLJV5kh\/TH9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692\n+        SdzR0dCSk7LGgN9qCYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\n+        \/kI+EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5aeKZQSkNAX\n+        G+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGPg6Wo1usF2bKqk8vjko9i\n+        oZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZaJz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE\n+        8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL\n+        0lGPCiOLu9RcQp7L81aF79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57\n+        AkBh75t86onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8ObWqcW\n+        coJqfdLEyBT+gYGNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\/nLzxYC+TH6gwjOWvMiNMiJo\n+        P4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGjMtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarb\n+        D6D4yRY1hWHluiuOtzhxuueCuf9hXCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry oasrfc8410 = new Entry(\"oasrfc8410\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MHICAQEwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06\/nwoy\/HU++CXqI9EdVhC\n+        oB8wHQYKKoZIhvcNAQkJFDEPDA1DdXJkbGUgQ2hhaXJzgSEAGb9ECWmEzf6FQbrB\n+        Z9w7lshQhqowtrbLDFw4rXAxZuE=\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry rsaOpenSSL = new Entry(\"rsaOpenSSL\",\n+        \"\"\"\n+        -----BEGIN RSA PRIVATE KEY-----\n+        MIIEowIBAAKCAQEAqozTLan1qFcOCWnS63jXQn5lLyGOKDv3GM11n2zkGGrChayj\n+        cSzB2KTlDmN9NgOyFdqGNWbSgdmXR5ToHGHYwaKubJoQIoPQcsipWDI156d3+X\/8\n+        BxCGY8l5nYwvS4olOXc+2kEjeFF1eamnm9IQ5DHZfaFPl0ri4Yfm1YHBAbt\/7HvF\n+        3MBjgBj1xSsSFLW4O6ws6guRVGDfKBVyyRNUhRTbSua\/nEz0wAjxF2PWT+ZTHS6M\n+        0siYwVTuPI4\/n4ItoYoahvGb9JskkXP+bc\/QZJCTFYdyxF5tKqVMSdYaJTxop02p\n+        Jo3oeafVKSlBrr0K731xgNBKqBud44aKT5R96QIDAQABAoIBAQCD9Q\/T7gOvayPm\n+        LqXOISJURV1emRTXloX5\/8Y5QtQ8\/CVjrg6Lm3ikefjsKBgR+cwJUpmyqcrIQyXk\n+        cZchlqdSMt\/IEW\/YdKqMlStJnRfOE+ok9lx2ztdcT9+0AWn6hXmFu\/i6f9nE1yoQ\n+        py6SxnbhSJyhsnTVd1CR9Uep\/InsHvYW\/15WlVMD1VuCSIt9sefqXwavbAfBaqbn\n+        mjwBB\/ulsqKhHSuRq\/QWqlj+jyGqhhYmTguC1Qwt0woDbThiHtK+suCTAlGBj\/A+\n+        IZ1U9d+VsHBcWDKBkxmlKWcJAGR3xXiKKy9vfzC+DU7L99kgay80VZarDyXgiy78\n+        9xMMzRMBAoGBANoxnZhu1bUFtLqTJ1HfDm6UB+1zVd2Mu4DXYdy\/AHjoaCLp05OQ\n+        0ZeyhO\/eXPT+eGpzCxkWD7465KO\/QDfnp54p\/NS73jaJVdWQHBhzJx1MymqURy3N\n+        JQeW4+ojzwSmVXcrs7Og6EBa4L+PWLpMLW2kODniCY+vp9f5LS6m8UPJAoGBAMgZ\n+        4rBw7B9YFZZW\/EE4eos4Q7KtA5tEP6wvCq04oxfiSytWXifYX0ToPp0CHhZlWOxk\n+        v9a\/BDGqM7AxAQJs7mmIvT5AT2V1w7oTbFPnnAo6pQtLcfaxdFFqr0h6t0sXSOKC\n+        rQeZAqqFqwuOyP7vT0goGlBruHkwS21NKkzCyzkhAoGAc2JjhbWu+8Cdt0CUPX5o\n+        ol9T5eTlFnkSuuqrTNIQzN+SGkxu341o2QDFvhdoLwLW6OwXhVeeUanROSqtKiMu\n+        B70Kf\/EtbMephXtk8CUNHTh7nmr1TSo8F8xakHoJQts3PQL2T9qal1W3nnWOpU4d\n+        g+qg9TMsfTiV2OdjVlVgJskCgYBSnjV1qjojuue22hVvDFW0c7en5z2M9wHfItEi\n+        sjbMnrdwnklj5Dd5qPZpNz2a+59ag0Kd9OJTazXKMoF7MeTCGB4ivMTLXHNCudBJ\n+        WGCZ7JrGbhEQzTX8g7L5lwlk7KlANLoiX++03lm\/\/OVKNR6j6ULsH33cM6+A4pJr\n+        fSYRYQKBgCr9iMTmL0x+n6AmMNecR+MhDxi99Oy0s2EBAYqN9g\/8yNgwM4KR0cjz\n+        EcgIOtkvoTrJ9Cquvuj+O7\/d2yNoH0SZQ4IYJKq47\/Z4kKhwXzJnBCCCBKgkjfub\n+        RTQSNnSEgTaBD29l7FrhNRHX9lIKFZ23caCTBS6o3q3+KgPbq7ao\n+        -----END RSA PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    static final Entry ed25519ep8 = new Entry(\"ed25519ep8\",\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\", EdECPrivateKey.class, \"fish\".toCharArray());\n+\n+    \/\/ This is not meant to be decrypted and to stay as an EKPI\n+    static final Entry ed25519ekpi = new Entry(\"ed25519ekpi\",\n+        ed25519ep8.pem(), EncryptedPrivateKeyInfo.class, null);\n+\n+    static final Entry rsaCert = new Entry(\"rsaCert\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIErDCCApQCCQD7ndjWbI\/x0DANBgkqhkiG9w0BAQsFADAXMRUwEwYDVQQDDAxQ\n+        RU0gVGVzdCBSU0EwIBcNMjQwMTA5MjMzNDIwWhgPMjA1MTA1MjYyMzM0MjBaMBcx\n+        FTATBgNVBAMMDFBFTSBUZXN0IFJTQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC\n+        AgoCggIBAKgO\/Pciro8xn5iNjcVCR4IuXP+V1PNATtKAlMbWzwGVOupKgRcNeRbA\n+        N9RlljxSgEChIWs0\/DB9VsAw1wCIVeuIVxv0ZvhVAcuD8Yyl58eev1rptsSJhTkN\n+        YJFxEPSP2kfWDxS21ltbg1bnY\/c1SQbzWawDLJN16G+ICzQXo68UB5fCZV9Ugfgf\n+        9USPkCiC6aFt+RT7eQaN\/JrjtCm+mFf4VbK7jYW7D8AfjviEY1HQCnPoTjHBxdy+\n+        o5s4aIOx1Wuu9wMoGuLXgY3do5\/OSDCfByk7rc1drQB9GOKf2gkR8PL9TjK+R3Lq\n+        wCA0a3jlCBiGPlH3oeZJrnp7jhAh\/tVxbsd7yIdhQnasbiTfhew132AdPXoQE+ic\n+        PFoh8MMtG1bdzt8EbvePC3GOjeyIP6f2Ixrh3B6wXzzYmJqBwON+X8TLQolcI1pa\n+        Q7AUz5BScy3lO9nyJE\/FJkX+Mr6n7WCdudCrQNP+0M845UvkgFyf4FcM7uUVugBm\n+        AXy7sCqZgTeLdqHyTElMCoWzBa3MHKyiSCh8GUJH+I1yBY1gG95j3tITIOFvbZrk\n+        vDiMwNtV9T6Ta2mb0+38GfKjbI6PF4DVrzB6xc7Q6\/GwyhOb86YLOLlEHJfhuc+C\n+        Pdy8hQrrulm2jiCO\/skvHucABNJ2CENyWa7ljNJkcN6GNTziz4AhAgMBAAEwDQYJ\n+        KoZIhvcNAQELBQADggIBAKFQE2AgYgc7\/xzwveUAiZ55tfcds07UnazLCOdpz+JJ\n+        W4MOt\/1Qi9mUylqDEymfNZVLPd2dEjB4wJ57XBUjL+kXkH1SocuskxQPf05iz5zT\n+        pEwg2fTmU73ilKMs5Q113nBnL9ZZtlRKCh1Oc5LvLW799uVXnU4UdSpWOBU9ePGY\n+        +H1wUKf+e0\/BkveQsZERYcamH9O9U\/+h+bbhr3GpT1AVnuDRyF28OvRwARDCOVyy\n+        ifh+xCR3WCnNcgfwCoH6cE1aXDKHchlAAZtvjc1lLud7\/ECIg+15keVfTYk4HEbH\n+        j\/lprxyH7y99lMmRLQpnTve54RrZGGmg51UD7OmwPHLMGibfQkw6QgdNsggIYD6p\n+        L91spgRRB+i4PTovocndOMR2RYgQEelGNqv8MsoUC7oRNxPCHxIEGuUPH1Vf3jnk\n+        mTHbVzpjy57UtfcYp1uBFDf8WoWO1Mi6oXRw2YQA1YSMm1+3ftphxydcbRuBlS7O\n+        6Iiqk6XlFG9Dpd2jjAQQzJGtnC0QDgGz6\/KGp1bGEhRnOWju07eLWvPbyaX5zeSh\n+        8gOYV33zkPhziWJt4uFMFIi7N2DLEk5UVZv1KTLZlfPl55DRs7j\/Sb4vKHpB17AO\n+        meVknxVvifDVY0TIz57t28Accsk6ClBCxNPluPU\/8YLGAZJYsdDXjGcndQ13s5G7\n+        -----END CERTIFICATE-----\n+        \"\"\", X509Certificate.class);\n+\n+    static final Entry ecCert = new Entry(\"ecCert\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIBFzCBvgIJAOGVk\/ky59ojMAoGCCqGSM49BAMCMBMxETAPBgNVBAMMCFBFTSB0\n+        ZXN0MCAXDTI0MDEwOTIzMzEwNloYDzIwNTEwNTI2MjMzMTA2WjATMREwDwYDVQQD\n+        DAhQRU0gdGVzdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGYI0jD7JZzw4RYD\n+        y9DCfaYNz0CHrpr9gJU5NXe6czvuNBdAOl\/lJGQ1pqpEQSQaMDII68obvQyQQyFY\n+        lU3G9QAwCgYIKoZIzj0EAwIDSAAwRQIgMwYld7aBzkcRt9mn27YOed5+n0xN1y8Q\n+        VEcFjLI\/tBYCIQDU3szDZ\/PK2mUZwtgQxLqHdh+f1JY0UwQS6M8QUvoDHw==\n+        -----END CERTIFICATE-----\n+        \"\"\", X509Certificate.class);\n+\n+    \/\/ EC cert with explicit parameters -- Not currently supported by SunEC\n+    static final String ecCertEX = \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIICrDCCAjMCCQDKAlI7uc1CVDAKBggqhkjOPQQDAjATMREwDwYDVQQDDAhQRU0g\n+        dGVzdDAgFw0yNDAxMDkyMzIxNTlaGA8yMDUxMDUyNjIzMjE1OVowEzERMA8GA1UE\n+        AwwIUEVNIHRlc3QwggHMMIIBZAYHKoZIzj0CATCCAVcCAQEwPAYHKoZIzj0BAQIx\n+        AP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/+\/\/\/\/\/wAAAAAAAAAA\/\/\/\/\n+        \/zB7BDD\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/v\/\/\/\/8AAAAAAAAA\n+        AP\/\/\/\/wEMLMxL6fiPufkmI4Fa+P4LRkYHZxu\/oFBEgMUCI9QE4daxlY5jYou0Z0q\n+        hcjt0+wq7wMVAKM1kmqjGaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCt\n+        dG4dO2KLp5uYWfdB4IJUKjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi\/kpLc\n+        Kfj0Hb0omhR86doxE7XwuMAKYLHOHX6BnXpDHXyQ6g5fAjEA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/x2NNgfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBA2IABO+IbTh6\n+        WqyzmxdCeJ0uUQ2v2jKxRuCKRyPlYAnpBmmQypsRS+GBdbBa0Mu6MTnVJh5uvqXn\n+        q7IuHVEiE3EFKw0DNW30nINuQg6lTv6PgN\/4nYBqsl5FQgzk2SYN3bw+7jAKBggq\n+        hkjOPQQDAgNnADBkAjATCnbbn3CgPRPi9Nym0hKpBAXc30D4eVB3mz8snK0oKU0+\n+        VP3F0EWcyM2QDSZCXIgCMHWknAhIGFTHxqypYUV8eAd3SY7ujZ6EPR0uG\/\/csBWG\n+        IqHcgr8slqi35ycQn5yMsQ==\n+        -----END CERTIFICATE-----\n+        \"\"\";\n+\n+    static final Entry ecsecp384 = new Entry(\"ecsecp384\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDBVS52ZSKZ0oES7twD2\n+        GGwRIVu3uHlGIwlu0xzFe7sgIPntca2bHfYMhgGxrlCm0q+hZANiAAQNWgwWfLX8\n+        8pYVjvwbfvDF9f+Oa9w6JjrfpWwFAUI6b1OPgrNUh+yXtUXnQNXnfUcIu0Os53bM\n+        8fTqPkQl6RyWEDHeXqJK8zTBHMeBq9nLfDPSbzQgLDyC64Orn0D8exM=\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class);\n+\n+    public static final Entry ecCSR = new Entry(\"ecCSR\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE REQUEST-----\n+        MIICCTCCAbACAQAwRTELMAkGA1UEBhMCVVMxDTALBgNVBAgMBFRlc3QxFDASBgNV\n+        BAcMC1NhbnRhIENsYXJhMREwDwYDVQQDDAhUZXN0IENTUjCCAUswggEDBgcqhkjO\n+        PQIBMIH3AgEBMCwGByqGSM49AQECIQD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/zBbBCD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/AQgWsY1\n+        2Ko6k+ez671VdpiGvGUdBrDMU7D2O848PifSYEsDFQDEnTYIhucEk2pmeOETnSa3\n+        gZ9+kARBBGsX0fLhLEJH+Lzm5WOkQPJ3A32BLeszoPShOUXYmMKWT+NC4v4af5uO\n+        5+tKfA+eFivOM1drMV7Oy7ZAaDe\/UfUCIQD\/\/\/\/\/AAAAAP\/\/\/\/\/\/\/\/\/\/vOb6racX\n+        noTzucrC\/GMlUQIBAQNCAAT3UJgGXD7xMwFSzBnkhsEXz3eJLjIE0HTP1Ax6x7QX\n+        G3\/+Z\/qgOZ6UQCxeHOWMEgF1Ufc\/tZkzgbvxWJ6gokeToBUwEwYJKoZIhvcNAQkH\n+        MQYMBGZpc2gwCgYIKoZIzj0EAwIDRwAwRAIgUBTdrMDE4BqruYRh1rRyKQBf48WR\n+        kIX8R4dBK9h1VRcCIEBR2Mzvku\/huTbWTwKVlXBZeEmwIlxKwpRepPtViXcW\n+        -----END CERTIFICATE REQUEST-----\n+        \"\"\", PEMRecord.class);\n+\n+    public static final String preData = \"TEXT BLAH TEXT BLAH\" +\n+        System.lineSeparator();\n+    public static final String postData = \"FINISHED\" + System.lineSeparator();\n+\n+    public static final Entry ecCSRWithData = new Entry(\"ecCSRWithData\",\n+        preData + \"\"\"\n+        -----BEGIN CERTIFICATE REQUEST-----\n+        MIICCTCCAbACAQAwRTELMAkGA1UEBhMCVVMxDTALBgNVBAgMBFRlc3QxFDASBgNV\n+        BAcMC1NhbnRhIENsYXJhMREwDwYDVQQDDAhUZXN0IENTUjCCAUswggEDBgcqhkjO\n+        PQIBMIH3AgEBMCwGByqGSM49AQECIQD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/zBbBCD\/\/\/\/\/AAAAAQAAAAAAAAAAAAAAAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/AQgWsY1\n+        2Ko6k+ez671VdpiGvGUdBrDMU7D2O848PifSYEsDFQDEnTYIhucEk2pmeOETnSa3\n+        gZ9+kARBBGsX0fLhLEJH+Lzm5WOkQPJ3A32BLeszoPShOUXYmMKWT+NC4v4af5uO\n+        5+tKfA+eFivOM1drMV7Oy7ZAaDe\/UfUCIQD\/\/\/\/\/AAAAAP\/\/\/\/\/\/\/\/\/\/vOb6racX\n+        noTzucrC\/GMlUQIBAQNCAAT3UJgGXD7xMwFSzBnkhsEXz3eJLjIE0HTP1Ax6x7QX\n+        G3\/+Z\/qgOZ6UQCxeHOWMEgF1Ufc\/tZkzgbvxWJ6gokeToBUwEwYJKoZIhvcNAQkH\n+        MQYMBGZpc2gwCgYIKoZIzj0EAwIDRwAwRAIgUBTdrMDE4BqruYRh1rRyKQBf48WR\n+        kIX8R4dBK9h1VRcCIEBR2Mzvku\/huTbWTwKVlXBZeEmwIlxKwpRepPtViXcW\n+        -----END CERTIFICATE REQUEST-----\n+        \"\"\" + postData, PEMRecord.class);\n+\n+    public record Entry(String name, String pem, Class clazz, char[] password,\n+                        byte[] der) {\n+\n+        public Entry(String name, String pem, Class clazz, char[] password,\n+            byte[] der) {\n+            this.name = name;\n+            this.pem = pem;\n+            this.clazz = clazz;\n+            this.password = password;\n+            if (pem != null && pem.length() > 0) {\n+                String[] pemtext = pem.split(\"-----\");\n+                this.der = Base64.getMimeDecoder().decode(pemtext[2]);\n+            } else {\n+                this.der = null;\n+            }\n+        }\n+        Entry(String name, String pem, Class clazz, char[] password) {\n+            this(name, pem, clazz, password, null);\n+        }\n+\n+        Entry(String name, String pem, Class clazz) {\n+            this(name, pem, clazz, null, null);\n+        }\n+\n+        public Entry newClass(String name, Class c) {\n+            return new Entry(name, pem, c, password);\n+        }\n+\n+        public Entry newClass(Class c) {\n+            return newClass(name, c);\n+        }\n+\n+        Entry makeCRLF(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\\r\\n\"),\n+                clazz, password());\n+        }\n+\n+        Entry makeCR(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\\r\"),\n+                clazz, password());\n+        }\n+\n+        Entry makeNoCRLF(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\"),\n+                clazz, password());\n+        }\n+    }\n+\n+    static public Entry getEntry(String varname) {\n+        return getEntry(passList, varname);\n+    }\n+\n+    static public Entry getEntry(List<Entry> list, String varname) {\n+        for (Entry entry : list) {\n+            if (entry.name.compareToIgnoreCase(varname) == 0) {\n+                return entry;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static List<Entry> passList = new ArrayList<>();\n+    static List<Entry> entryList = new ArrayList<>();\n+    static List<Entry> pubList = new ArrayList<>();\n+    static List<Entry> privList = new ArrayList<>();\n+    static List<Entry> oasList = new ArrayList<>();\n+    static List<Entry> certList = new ArrayList<>();\n+    static List<Entry> encryptedList = new ArrayList<>();\n+    static List<Entry> failureEntryList = new ArrayList<>();\n+\n+    static {\n+        pubList.add(rsapub);\n+        pubList.add(rsapubbc);\n+        pubList.add(ecsecp256pub.makeCR(\"ecsecp256pub-r\"));\n+        pubList.add(ecsecp256pub.makeCRLF(\"ecsecp256pub-rn\"));\n+        privList.add(rsapriv);\n+        privList.add(rsaprivbc);\n+        privList.add(ecsecp256);\n+        privList.add(ecsecp384);\n+        privList.add(ec25519priv);\n+        privList.add(ed25519ekpi);  \/\/ The non-EKPI version needs decryption\n+        privList.add(rsaOpenSSL);\n+        oasList.add(oasrfc8410);\n+        oasList.add(oasbcpem);\n+\n+        certList.add(rsaCert);\n+        certList.add(ecCert);\n+\n+        entryList.addAll(pubList);\n+        entryList.addAll(privList);\n+        entryList.addAll(oasList);\n+        entryList.addAll(certList);\n+\n+        encryptedList.add(ed25519ep8);\n+\n+        passList.addAll(entryList);\n+        passList.addAll(encryptedList);\n+\n+        failureEntryList.add(new Entry(\"emptyPEM\", \"\", DEREncodable.class, null));\n+        failureEntryList.add(new Entry(\"nullPEM\", null, DEREncodable.class, null));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":427,"deletions":0,"binary":false,"changes":427,"status":"added"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.util\n+ * @summary Testing basic PEM API decoding\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.io.*;\n+import java.lang.Class;\n+import java.security.*;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.*;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.*;\n+import java.util.Arrays;\n+\n+import sun.security.util.Pem;\n+\n+public class PEMDecoderTest {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws IOException {\n+        System.out.println(\"Decoder test:\");\n+        PEMData.entryList.forEach(PEMDecoderTest::test);\n+        System.out.println(\"Decoder test returning DEREncodable class:\");\n+        PEMData.entryList.forEach(entry -> test(entry, DEREncodable.class));\n+        System.out.println(\"Decoder test with encrypted PEM:\");\n+        PEMData.encryptedList.forEach(PEMDecoderTest::testEncrypted);\n+        System.out.println(\"Decoder test with OAS:\");\n+        testTwoKeys();\n+        System.out.println(\"Decoder test RSA PEM setting RSAKey.class returned:\");\n+        test(PEMData.rsapriv, RSAKey.class);\n+        System.out.println(\"Decoder test failures:\");\n+        PEMData.failureEntryList.forEach(PEMDecoderTest::testFailure);\n+        System.out.println(\"Decoder test ecsecp256 PEM asking for ECPublicKey.class returned:\");\n+        testFailure(PEMData.ecsecp256, ECPublicKey.class);\n+        System.out.println(\"Decoder test rsapriv PEM setting P8EKS.class returned:\");\n+        testClass(PEMData.rsapriv, RSAPrivateKey.class);\n+        System.out.println(\"Decoder test rsaOpenSSL P1 PEM asking for RSAPublicKey.class returned:\");\n+        testFailure(PEMData.rsaOpenSSL, RSAPublicKey.class);\n+        System.out.println(\"Decoder test rsapub PEM asking X509EKS.class returned:\");\n+        testClass(PEMData.rsapub, X509EncodedKeySpec.class, true);\n+        System.out.println(\"Decoder test rsapriv PEM asking X509EKS.class returned:\");\n+        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test RSAcert PEM asking X509EKS.class returned:\");\n+        testClass(PEMData.rsaCert, X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test OAS RFC PEM asking PrivateKey.class returned:\");\n+        testClass(PEMData.oasrfc8410, PrivateKey.class, true);\n+        testClass(PEMData.oasrfc8410, PublicKey.class, true);\n+        System.out.println(\"Decoder test ecsecp256:\");\n+        testFailure(PEMData.ecsecp256pub.makeNoCRLF(\"pubecpem-no\"));\n+        System.out.println(\"Decoder test RSAcert with decryption Decoder:\");\n+        PEMDecoder d = PEMDecoder.of().withDecryption(\"123\".toCharArray());\n+        d.decode(PEMData.rsaCert.pem());\n+        System.out.println(\"Decoder test ecsecp256 with decryption Decoder:\");\n+        PrivateKey pkey = ((KeyPair) d.decode(PEMData.ecsecp256.pem())).getPrivate();\n+        System.out.println(\"Decoder test ecsecp256 to P8EKS:\");\n+        PKCS8EncodedKeySpec p8 = d.decode(PEMData.ecsecp256.pem(),\n+            PKCS8EncodedKeySpec.class);\n+\n+        System.out.println(\"Checking if decode() returns the same encoding:\");\n+        PEMData.privList.forEach(PEMDecoderTest::testDERCheck);\n+        PEMData.oasList.forEach(PEMDecoderTest::testDERCheck);\n+\n+        System.out.println(\"Check a Signature\/Verify op is successful:\");\n+        PEMData.privList.forEach(PEMDecoderTest::testSignature);\n+        PEMData.oasList.forEach(PEMDecoderTest::testSignature);\n+\n+\n+        \/\/ PEMRecord tests\n+        System.out.println(\"Checking if ecCSR:\");\n+        test(PEMData.ecCSR);\n+\n+        System.out.println(\"Checking if ecCSR with preData:\");\n+        DEREncodable result = test(PEMData.ecCSRWithData);\n+        if (result instanceof PEMRecord rec) {\n+            if (PEMData.preData.compareTo(new String(rec.leadingData())) != 0) {\n+                System.err.println(\"expected: \" + PEMData.preData);\n+                System.err.println(\"received: \" + new String(rec.leadingData()));\n+                throw new AssertionError(\"ecCSRWithData preData wrong\");\n+            }\n+            if (rec.pem().lastIndexOf(\"F\") > rec.pem().length() - 5) {\n+                System.err.println(\"received: \" + rec.pem());\n+                throw new AssertionError(\"ecCSRWithData: \" +\n+                    \"End of PEM data has an unexpected character\");\n+            }\n+        } else {\n+            throw new AssertionError(\"ecCSRWithData didn't return a PEMRecord\");\n+        }\n+\n+        System.out.println(\"Decoding RSA pub using class PEMRecord:\");\n+        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEMRecord.class);\n+        if (!(result instanceof PEMRecord)) {\n+            throw new AssertionError(\"pubecpem didn't return a PEMRecord\");\n+        }\n+        if (((PEMRecord) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n+            throw new AssertionError(\"pubecpem PEMRecord didn't decode as a Public Key\");\n+        }\n+\n+        testInputStream();\n+        testPEMRecord(PEMData.rsapub);\n+        testPEMRecord(PEMData.ecCert);\n+        testPEMRecord(PEMData.ec25519priv);\n+        testPEMRecord(PEMData.ecCSR);\n+        testPEMRecord(PEMData.ecCSRWithData);\n+    }\n+\n+    static void testInputStream() throws IOException {\n+        ByteArrayOutputStream ba = new ByteArrayOutputStream(2048);\n+        OutputStreamWriter os = new OutputStreamWriter(ba);\n+        os.write(PEMData.preData);\n+        os.write(PEMData.rsapub.pem());\n+        os.write(PEMData.preData);\n+        os.write(PEMData.rsapub.pem());\n+        os.write(PEMData.postData);\n+        os.flush();\n+        ByteArrayInputStream is = new ByteArrayInputStream(ba.toByteArray());\n+\n+        System.out.println(\"Decoding 2 RSA pub with pre & post data:\");\n+        PEMRecord obj;\n+        int keys = 0;\n+        while (keys++ < 2) {\n+            obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+            if (!PEMData.preData.equalsIgnoreCase(\n+                new String(obj.leadingData()))) {\n+                System.out.println(\"expected: \\\"\" + PEMData.preData + \"\\\"\");\n+                System.out.println(\"returned: \\\"\" +\n+                    new String(obj.leadingData()) + \"\\\"\");\n+                throw new AssertionError(\"Leading data incorrect\");\n+            }\n+            System.out.println(\"  Read public key.\");\n+        }\n+        obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+        if (obj.pem() != null) {\n+            throw new AssertionError(\"3rd PEMRecord shouldn't have PEM data\");\n+        }\n+\n+        System.out.println(\"  Checking post data...\");\n+        if (!PEMData.postData.equalsIgnoreCase(new String(obj.leadingData()))) {\n+            System.out.println(\"expected: \\\"\" + PEMData.postData + \"\\\"\");\n+            System.out.println(\"returned: \\\"\" + new String(obj.leadingData()) +\n+                \"\\\"\");\n+            throw new AssertionError(\"Post bytes incorrect\");\n+        }\n+\n+        \/\/ End of stream\n+        try {\n+            System.out.println(\"Failed: There should be no PEMRecord: \" +\n+                PEMDecoder.of().decode(is, PEMRecord.class));\n+        } catch (EOFException e) {\n+            System.out.println(\"Success\");\n+            return;\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Caught unexpected exception \" +\n+                \"should have been IOE EOF.\");\n+        }\n+\n+        throw new AssertionError(\"Failed\");\n+    }\n+\n+    static void testPEMRecord(PEMData.Entry entry) {\n+        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        String expected = entry.pem().split(\"-----\")[2].replace(System.lineSeparator(), \"\");\n+        if (!r.pem().equalsIgnoreCase(expected)) {\n+            System.err.println(\"expected: \" + expected);\n+            System.err.println(\"received: \" + r.pem());\n+            throw new AssertionError(\"PEMRecord expected pem \" +\n+                \"does not match.\");\n+        }\n+\n+        boolean result = switch(r.type()) {\n+            case Pem.PRIVATE_KEY ->\n+                PrivateKey.class.isAssignableFrom(entry.clazz());\n+            case Pem.PUBLIC_KEY ->\n+                PublicKey.class.isAssignableFrom(entry.clazz());\n+            case Pem.CERTIFICATE, Pem.X509_CERTIFICATE ->\n+                entry.clazz().isAssignableFrom(X509Certificate.class);\n+            case Pem.X509_CRL ->\n+                entry.clazz().isAssignableFrom(X509CRL.class);\n+            case \"CERTIFICATE REQUEST\" ->\n+                entry.clazz().isAssignableFrom(PEMRecord.class);\n+            default -> false;\n+        };\n+\n+        if (!result) {\n+            System.err.println(\"PEMRecord type is a \" + r.type());\n+            System.err.println(\"Entry is a \" + entry.clazz().getName());\n+            throw new AssertionError(\"PEMRecord class didn't match:\" +\n+                entry.name());\n+        }\n+        System.out.println(\"Success (\" + entry.name() + \")\");\n+    }\n+\n+\n+    static void testFailure(PEMData.Entry entry) {\n+        testFailure(entry, entry.clazz());\n+    }\n+\n+    static void testFailure(PEMData.Entry entry, Class c) {\n+        try {\n+            test(entry.pem(), c, PEMDecoder.of());\n+            throw new AssertionError(\"Failure with \" +\n+                entry.name() + \":  Not supposed to succeed.\");\n+        } catch (NullPointerException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        } catch (IOException | RuntimeException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        }\n+    }\n+\n+    static DEREncodable testEncrypted(PEMData.Entry entry) {\n+        PEMDecoder decoder = PEMDecoder.of();\n+        if (!Objects.equals(entry.clazz(), EncryptedPrivateKeyInfo.class)) {\n+            decoder = decoder.withDecryption(entry.password());\n+        }\n+\n+        try {\n+            return test(entry.pem(), entry.clazz(), decoder);\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    \/\/ Change the Entry to use the given class as the expected class returned\n+    static DEREncodable test(PEMData.Entry entry, Class c) {\n+        return test(entry.newClass(c));\n+    }\n+\n+    \/\/ Run test with a given Entry\n+    static DEREncodable test(PEMData.Entry entry) {\n+        try {\n+            DEREncodable r = test(entry.pem(), entry.clazz(), PEMDecoder.of());\n+            System.out.println(\"PASS (\" + entry.name() + \")\");\n+            return r;\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    static List getInterfaceList(Class ccc) {\n+        Class<?>[] interfaces = ccc.getInterfaces();\n+        List<Class> list = new ArrayList<>(Arrays.asList(interfaces));\n+        var x = ccc.getSuperclass();\n+        if (x != null) {\n+            list.add(x);\n+        }\n+        List<Class> results = new ArrayList<>(list);\n+        if (list.size() > 0) {\n+            for (Class cname : list) {\n+                try {\n+                    if (cname != null &&\n+                        cname.getName().startsWith(\"java.security.\")) {\n+                        results.addAll(getInterfaceList(cname));\n+                    }\n+                } catch (Exception e) {\n+                    System.err.println(\"Exception with \" + cname);\n+                }\n+            }\n+        }\n+        return results;\n+    }\n+\n+    \/**\n+     * Perform the decoding test with the given decoder, on the given pem, and\n+     * expect the clazz to be returned.\n+     *\/\n+    static DEREncodable test(String pem, Class clazz, PEMDecoder decoder)\n+        throws IOException {\n+        DEREncodable pk = decoder.decode(pem);\n+\n+\/\/        if (pk instanceof KeyPair kp) {\n+\/\/            pk = kp.getPrivate();\n+\/\/        }\n+\n+        \/\/ Check that clazz matches what pk returned.\n+        if (pk.getClass().equals(clazz)) {\n+            return pk;\n+        }\n+\n+        \/\/ Search interfaces and inheritance to find a match with clazz\n+        List<Class> list = getInterfaceList(pk.getClass());\n+        for (Class cc : list) {\n+            if (cc != null && cc.equals(clazz)) {\n+                return pk;\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Entry did not contain expected: \" +\n+            clazz.getName());\n+    }\n+\n+    \/\/ Run the same key twice through the same decoder and make sure the\n+    \/\/ result is the same\n+    static void testTwoKeys() throws IOException {\n+        PublicKey p1, p2;\n+        PEMDecoder pd = PEMDecoder.of();\n+        p1 = pd.decode(PEMData.rsapub.pem(), RSAPublicKey.class);\n+        p2 = pd.decode(PEMData.rsapub.pem(), RSAPublicKey.class);\n+        if (!Arrays.equals(p1.getEncoded(), p2.getEncoded())) {\n+            System.err.println(\"These two should have matched:\");\n+            System.err.println(hex.parseHex(new String(p1.getEncoded())));\n+            System.err.println(hex.parseHex(new String(p2.getEncoded())));\n+            throw new AssertionError(\"Two decoding of the same\" +\n+                \" key failed to match: \");\n+        }\n+    }\n+\n+    static void testClass(PEMData.Entry entry, Class clazz) throws IOException {\n+        var pk = PEMDecoder.of().decode(entry.pem(), clazz);\n+    }\n+\n+    static void testClass(PEMData.Entry entry, Class clazz, boolean pass)\n+        throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (pass) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Run test with a given Entry\n+    static void testDERCheck(PEMData.Entry entry) {\n+        if (entry.name().equals(\"rsaOpenSSL\") ||  \/\/ PKCS1 data\n+            entry.name().equals(\"ed25519ekpi\")) {\n+            return;\n+        }\n+\n+        PKCS8EncodedKeySpec p8 = PEMDecoder.of().decode(entry.pem(),\n+                PKCS8EncodedKeySpec.class);\n+        int result = Arrays.compare(entry.der(), p8.getEncoded());\n+        if (result != 0) {\n+            System.err.println(\"Compare error with \" + entry.name() + \"(\" +\n+                result + \")\");\n+            System.err.println(\"Expected DER: \" + HexFormat.of().\n+                formatHex(entry.der()));\n+            System.err.println(\"Returned DER: \" + HexFormat.of().\n+                formatHex(p8.getEncoded()));\n+                throw new AssertionError(\"Failed to match \" +\n+                \"expected DER\");\n+        }\n+        System.out.println(\"PASS (\" + entry.name() + \")\");\n+        System.out.flush();\n+    }\n+\n+    \/**\n+     * Run decoded keys through Signature to make sure they are valid keys\n+     *\/\n+    static void testSignature(PEMData.Entry entry) {\n+        Signature s;\n+        byte[] data = \"12345678\".getBytes();\n+        PrivateKey privateKey;\n+\n+        DEREncodable d = PEMDecoder.of().decode(entry.pem());\n+        switch (d) {\n+            case PrivateKey p -> privateKey = p;\n+            case KeyPair kp -> privateKey = kp.getPrivate();\n+            case EncryptedPrivateKeyInfo e -> {\n+                System.out.println(\"SKIP: EncryptedPrivateKeyInfo \" +\n+                    entry.name());\n+                return;\n+            }\n+            default -> throw new AssertionError(\"Private key \" +\n+                \"should not be null\");\n+        }\n+\n+        String algorithm = switch(privateKey.getAlgorithm()) {\n+            case \"EC\" -> \"SHA256withECDSA\";\n+            case \"EdDSA\" -> \"EdDSA\";\n+            case null -> {\n+                System.out.println(\"Algorithm is null \" +\n+                    entry.name());\n+                throw new AssertionError(\"PrivateKey algorithm\" +\n+                    \"should not be null\");\n+            }\n+            default -> \"SHA256with\" + privateKey.getAlgorithm();\n+        };\n+\n+        try {\n+            if (d instanceof PrivateKey) {\n+                s = Signature.getInstance(algorithm);\n+                s.initSign(privateKey);\n+                s.update(data);\n+                s.sign();\n+                System.out.println(\"PASS (Sign): \" + entry.name());\n+            } else if (d instanceof KeyPair) {\n+                s = Signature.getInstance(algorithm);\n+                s.initSign(privateKey);\n+                s.update(data);\n+                byte[] sig = s.sign();\n+                s.initVerify(((KeyPair)d).getPublic());\n+                s.verify(sig);\n+                System.out.println(\"PASS (Sign\/Verify): \" + entry.name());\n+            } else {\n+                System.out.println(\"SKIP: \" + entry.name());\n+            }\n+        } catch (Exception e) {\n+            System.out.println(\"FAIL: \" + entry.name());\n+            throw new AssertionError(e);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing basic PEM API encoding\n+ * @enablePreview\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+public class PEMEncoderTest {\n+\n+    static Map<String, DEREncodable> keymap;\n+    final static Pattern CR = Pattern.compile(\"\\r\");\n+    final static Pattern LF = Pattern.compile(\"\\n\");\n+    final static Pattern LSDEFAULT = Pattern.compile(System.lineSeparator());\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        PEMEncoder encoder = PEMEncoder.of();\n+\n+        \/\/ These entries are removed\n+        var newEntryList = new ArrayList<>(PEMData.entryList);\n+        newEntryList.remove(PEMData.getEntry(\"rsaOpenSSL\"));\n+        newEntryList.remove(PEMData.getEntry(\"ecsecp256\"));\n+        newEntryList.remove(PEMData.getEntry(\"ecsecp384\"));\n+        keymap = generateObjKeyMap(newEntryList);\n+        System.out.println(\"Same instance re-encode test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        System.out.println(\"New instance re-encode test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance re-encode testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        System.out.println(\"New instance re-encode testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key,\n+            PEMEncoder.of()));\n+\n+        keymap = generateObjKeyMap(PEMData.encryptedList);\n+        System.out.println(\"Same instance Encoder match test:\");\n+        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        System.out.println(\"Same instance Encoder new withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        System.out.println(\"New instance Encoder and withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance encrypted Encoder test:\");\n+        PEMEncoder encEncoder = encoder.withEncryption(\"fish\".toCharArray());\n+        keymap.keySet().stream().forEach(key -> testSameEncryptor(key, encEncoder));\n+        try {\n+            encoder.withEncryption(null);\n+        } catch (Exception e) {\n+            if (!(e instanceof NullPointerException)) {\n+                throw new Exception(\"Should have been a NullPointerException thrown\");\n+            }\n+        }\n+    }\n+\n+    static Map generateObjKeyMap(List<PEMData.Entry> list) {\n+        Map<String, DEREncodable> keymap = new HashMap<>();\n+        PEMDecoder pemd = PEMDecoder.of();\n+        for (PEMData.Entry entry : list) {\n+            try {\n+                if (entry.password() != null) {\n+                    keymap.put(entry.name(), pemd.withDecryption(\n+                        entry.password()).decode(entry.pem()));\n+                } else {\n+                    keymap.put(entry.name(), pemd.decode(entry.pem(),\n+                        entry.clazz()));\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"Verify PEMDecoderTest passes before \" +\n+                    \"debugging this test.\");\n+                throw new AssertionError(\"Failed to initialize map on\" +\n+                    \" entry \\\"\" + entry.name() + \"\\\"\", e);\n+            }\n+        }\n+        return keymap;\n+    }\n+\n+    static void test(String key, PEMEncoder encoder) {\n+        byte[] result;\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            result = encoder.encode(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, new String(result, StandardCharsets.UTF_8));\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testToString(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            result = encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testEncrypted(String key, PEMEncoder encoder) {\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            encoder.withEncryption(\n+                    (entry.password() != null ? entry.password() :\n+                        \"fish\".toCharArray()))\n+                .encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failed with \" +\n+                entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testSameEncryptor(String key, PEMEncoder encoder) {\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failured with \" +\n+                entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testEncryptedMatch(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMData.Entry entry = PEMData.getEntry(key);\n+        try {\n+            PrivateKey pkey = (PrivateKey) keymap.get(key);\n+            EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(entry.pem(),\n+                EncryptedPrivateKeyInfo.class);\n+            if (entry.password() != null) {\n+                EncryptedPrivateKeyInfo.encryptKey(pkey, entry.password(),\n+                    Pem.DEFAULT_ALGO, ekpi.getAlgParameters().\n+                        getParameterSpec(PBEParameterSpec.class),\n+                    null);\n+            }\n+            result = encoder.encodeToString(ekpi);\n+        } catch (RuntimeException | InvalidParameterSpecException e) {\n+            throw new AssertionError(\"Encrypted encoder failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void checkResults(PEMData.Entry entry, String result) {\n+        String pem = new String(entry.pem());\n+        \/\/ The below matches the \\r\\n generated PEM with the PEM passed\n+        \/\/ into the test.\n+        pem = CR.matcher(pem).replaceAll(\"\");\n+        pem = LF.matcher(pem).replaceAll(\"\");\n+        result = LSDEFAULT.matcher(result).replaceAll(\"\");\n+        try {\n+            if (pem.compareTo(result) != 0) {\n+                System.out.println(\"expected:\\n\" + pem);\n+                System.out.println(\"generated:\\n\" + result);\n+                indexDiff(pem, result);\n+            }\n+        } catch (AssertionError e) {\n+            throw new AssertionError(\"Encoder PEM mismatch \" +\n+                entry.name(), e);\n+        }\n+    }\n+\n+    static void indexDiff(String a, String b) {\n+        String lenerr = \"\";\n+        int len = a.length();\n+        int lenb = b.length();\n+        if (len != lenb) {\n+            lenerr = \":  Length mismatch: \" + len + \" vs \" + lenb;\n+            len = Math.min(len, lenb);\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (a.charAt(i) != b.charAt(i)) {\n+                throw new AssertionError(\"Char mistmatch, index #\" + i +\n+                    \"  (\" + a.charAt(i) + \" vs \" + b.charAt(i) + \")\" + lenerr);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing encryptKey\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.AlgorithmParameters;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.util.Arrays;\n+\n+public class EncryptKey {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+        AlgorithmParameters ap = ekpi.getAlgParameters();\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n+        var e = EncryptedPrivateKeyInfo.encryptKey(priKey, password,\n+            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n+            null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n+        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/EncryptKey.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing getKey\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.util.Arrays;\n+\n+public class GetKey {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+\n+        \/\/ Test getKey(password)\n+        if (!Arrays.equals(priKey.getEncoded(),\n+            ekpi.getKey(password).getEncoded())) {\n+            throw new AssertionError(\"getKey(char[]) didn't \"\n+                + \"match with expected.\");\n+        }\n+\n+        \/\/ Test getKey(key, provider)\n+        if (!Arrays.equals(priKey.getEncoded(),\n+            ekpi.getKey(key, null).getEncoded())) {\n+            throw new AssertionError(\"getKey(key, provider) \" +\n+                \"didn't match with expected.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKey.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,1 @@\n- * @compile -XDignore.symbol.file PKCS8Test.java\n- * @run testng PKCS8Test\n+ * @run main PKCS8Test\n@@ -37,1 +36,0 @@\n-import java.io.IOException;\n@@ -39,0 +37,1 @@\n+import java.security.InvalidKeyException;\n@@ -44,2 +43,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n@@ -48,1 +45,0 @@\n-import sun.security.util.DerValue;\n@@ -65,2 +61,1 @@\n-    @Test\n-    public void test() throws IOException {\n+    public static void main(String[] args) throws Exception {\n@@ -74,1 +69,2 @@\n-        Assert.assertTrue(Arrays.equals(encodedKey, EXPECTED),\n+        if (!Arrays.equals(encodedKey, EXPECTED)) {\n+            throw new AssertionError(\n@@ -76,2 +72,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedKey));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedKey));\n+        }\n@@ -81,4 +78,3 @@\n-        Assert.assertEquals(decodedKey.getAlgorithm(), ALGORITHM);\n-        Assert.assertEquals(decodedKey.getFormat(), FORMAT);\n-        Assert.assertEquals(decodedKey.getAlgorithmId().toString(),\n-                EXPECTED_ALG_ID_CHRS);\n+        assert(ALGORITHM.equalsIgnoreCase(decodedKey.getAlgorithm()));\n+        assert(FORMAT.equalsIgnoreCase(decodedKey.getFormat()));\n+        assert(EXPECTED_ALG_ID_CHRS.equalsIgnoreCase(decodedKey.getAlgorithmId().toString()));\n@@ -87,1 +83,3 @@\n-        Assert.assertTrue(Arrays.equals(encodedOutput, EXPECTED),\n+        if (!Arrays.equals(encodedOutput, EXPECTED)) {\n+\n+            throw new AssertionError(\n@@ -89,2 +87,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedOutput));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedOutput));\n+        }\n@@ -94,8 +93,15 @@\n-        enlarge(1, \"810100\");  \/\/ public key for v2\n-        enlarge(1, \"8000\", \"810100\");  \/\/ both\n-\n-        Assert.assertThrows(() -> enlarge(2));  \/\/ bad ver\n-        Assert.assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n-        Assert.assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n-        Assert.assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n-        Assert.assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+\n+        \/\/ PKCSv2 testing done by PEMEncoder\/PEMDecoder tests\n+\n+        assertThrows(() -> enlarge(2));\n+        assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n+        assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n+        assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n+        assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+    }\n+\n+    private static void assertThrows(Runnable o) {\n+        try {\n+            o.run();\n+            throw new AssertionError(\"Test failed\");\n+        } catch (Exception e) {}\n@@ -110,1 +116,1 @@\n-    static void enlarge(int newVersion, String... fields) throws IOException {\n+    static void enlarge(int newVersion, String... fields) {\n@@ -119,4 +125,8 @@\n-        Assert.assertTrue(length < 127);\n-        original[1] = (byte)(length - 2);   \/\/ the length field inside DER\n-        original[4] = (byte)newVersion;     \/\/ the version inside DER\n-        PKCS8Key.parseKey(original);\n+        assert (length < 127);\n+        original[1] = (byte) (length - 2);   \/\/ the length field inside DER\n+        original[4] = (byte) newVersion;     \/\/ the version inside DER\n+        try {\n+            PKCS8Key.parseKey(original);\n+        } catch (InvalidKeyException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"}]}