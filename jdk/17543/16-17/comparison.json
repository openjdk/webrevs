{"files":[{"patch":"@@ -62,2 +62,1 @@\n- * {@link PEMRecord}. Any PEM can be decoded into a {@code PEMRecord} if the\n- * class is specified.\n+ * {@link PEMRecord}.\n@@ -68,3 +67,2 @@\n- * methods are useful when casting, extracting, or changing return class.\n- * {@code ECPublicKey.class} can be used to cast a {@code PublicKey}\n- * to a {@code ECPublicKey}. The Class parameter can specify the returned\n+ * methods are useful when extracting or changing the return class.\n+ * The Class parameter can specify the returned\n@@ -93,4 +91,0 @@\n- * <p> Byte streams consumed by methods in this class are assumed to represent\n- * characters encoded in the\n- * {@link java.nio.charset.StandardCharsets#ISO_8859_1 ISO-8859-1} charset.\n- *\n@@ -226,1 +220,9 @@\n-     * Decodes and returns a {@link DEREncodable} from the given {@code String}.\n+     * Decodes and returns a cryptographic representative {@link DEREncodable}\n+     * from the given {@code String}.\n+     *\n+     * <p>This method reads the {@code String} until the first PEM data is found\n+     * or the end the {@code String} is reached.  Non-PEM data before the PEM\n+     * header is ignored by the decoder.\n+     *\n+     * <p>If no PEM data is found, an {@code IllegalArgumentException} is\n+     * thrown.\n@@ -228,3 +230,2 @@\n-     * <p>This method reads the {@code String} until PEM data is found or until\n-     * the end is reached.  Non-PEM data before the PEM header is ignored by\n-     * the decoder.\n+     * <p> Byte streams consumed by methods in this class are read in as\n+     * {@link java.nio.charset.StandardCharsets#UTF_8 UTF-8}.\n@@ -233,1 +234,2 @@\n-     * @return {@code DEREncodable} generated from the PEM data.\n+     * @return {@code DEREncodable} that is cryptographically representative of\n+     * the data is returned.  {@code PEMRecord} will not be returned.\n@@ -235,1 +237,2 @@\n-     * @throws NullPointerException when {@code str} is null.\n+     * @throws NullPointerException when {@code str} is null or there is no\n+     * Java API cryptographic representation {@code DEREncodable} for the data.\n@@ -239,0 +242,1 @@\n+        DEREncodable de;\n@@ -240,2 +244,2 @@\n-            return decode(new ByteArrayInputStream(\n-                str.getBytes(StandardCharsets.ISO_8859_1)));\n+            de = decode(new ByteArrayInputStream(\n+                str.getBytes(StandardCharsets.UTF_8)));\n@@ -246,0 +250,4 @@\n+        if (de == null || de instanceof PEMRecord) {\n+            return null;\n+        }\n+        return de;\n@@ -249,2 +257,2 @@\n-     * Decodes and returns a {@link DEREncodable} from the given\n-     * {@code InputStream}.\n+     * Decodes and returns a cryptographic representative {@link DEREncodable}\n+     * from the given {@code InputStream}.\n@@ -253,2 +261,12 @@\n-     * found or until the end of the stream.  Non-PEM data in the\n-     * {@code InputStream} before the PEM header is ignored by the decoder.\n+     * found or until the end of the stream.  The {@code InputStream} will\n+     * be left at the end of the PEM footer.  This method may be repeatedly\n+     * used on an {@code InputStream} to decode additional PEM data.  Non-PEM\n+     * data in the {@code InputStream} before the PEM header is ignored by the\n+     * decoder.\n+     *\n+     * <p>A {@code DEREncodable} that is a Java API cryptographic\n+     * representation of the data is returned.  {@code PEMRecord} will not be\n+     * returned.\n+     *\n+     * <p>If no PEM data is found, an {@code IllegalArgumentException} is\n+     * thrown.\n@@ -257,2 +275,5 @@\n-     * @return {@code DEREncodable} generated from the data read.\n-     * @throws IOException on IO error with the InputStream\n+     * @return a {@code DEREncodable} that is a Java API cryptographic\n+     * representation of the data.\n+     * @throws IOException on IO error with the {@code InputStream}\n+     * @throws EOFException when reading pass the end of the\n+     * {@code InputStream}.\n@@ -260,1 +281,2 @@\n-     * @throws NullPointerException when {@code is} is null.\n+     * @throws NullPointerException when {@code str} is null or there is no\n+     * Java API cryptographic representation {@code DEREncodable} for the data.\n@@ -265,11 +287,4 @@\n-        DEREncodable d = decode(pem);\n-        \/\/ If d is a PEMRecord, return no leadingData and if there is no type()\n-        \/\/ throw IAE.\n-        if (d instanceof PEMRecord p) {\n-            if (p.type() != null) {\n-                if (p.leadingData() != null) {\n-                    return new PEMRecord(p.type(), p.pem());\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\"No PEM data found.\");\n-            }\n+        DEREncodable de = decode(pem);\n+\n+        if (de == null || de instanceof PEMRecord) {\n+            return null;\n@@ -277,1 +292,1 @@\n-        return d;\n+        return de;\n@@ -281,3 +296,16 @@\n-     * Decodes and returns the specified class for the given PEM string.\n-     * {@code tClass} must extend {@link DEREncodable} and be an appropriate\n-     * class for the PEM type.\n+     * Decodes and returns a {@code DEREncodable} of the specified class from\n+     * the given PEM string. {@code tClass} must extend {@link DEREncodable}\n+     * and be an appropriate class for the PEM type.\n+     *\n+     * <p> Only the first PEM data read will be returned.\n+     *\n+     * <p> If the class parameter is {@code PEMRecord.class}, any data before\n+     * the PEM header will be stored in {@code leadingData}.  The {@code type}\n+     * and {@code pem} will contain the type identifier and Base64 encoding\n+     * respectively.  If no PEM is read, both {@code type} and {@code pem}\n+     * are set to null, but any non-PEM data read will be stored in\n+     * {@code leadingData}.  If no data is read,\n+     * {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p> For all other class parameters, {@code IllegalArgumentException} is\n+     * thrown when not PEM data is found.  All non-PEM data is ignored.\n@@ -289,1 +317,2 @@\n-     * @return {@code DEREncodable} typecast to {@code tClass}.\n+     * @return {@code DEREncodable} typecast to {@code tClass} or null if no\n+     * data is found.\n@@ -300,1 +329,1 @@\n-                str.getBytes(StandardCharsets.ISO_8859_1)), tClass);\n+                str.getBytes(StandardCharsets.UTF_8)), tClass);\n@@ -312,0 +341,18 @@\n+     * <p>This method reads the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  The {@code InputStream} will\n+     * be left at the end of the PEM footer.  This method may be repeatedly\n+     * used on an {@code InputStream} to decode additional PEM data.  Non-PEM\n+     * data in the {@code InputStream} before the PEM header is ignored by the\n+     * decoder.\n+     *\n+     * <p> If the class parameter is {@code PEMRecord.class}, any data before\n+     * the PEM header will be stored in {@code leadingData}.  The {@code type}\n+     * and {@code pem} will contain the type identifier and Base64 encoding\n+     * respectively.  If no PEM is read, both {@code type} and {@code pem}\n+     * are set to null, but any non-PEM data read will be stored in\n+     * {@code leadingData}.  If no data is read,\n+     * {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p> For all other class parameters, {@code IllegalArgumentException} is\n+     * thrown when not PEM data is found.  All non-PEM data is ignored.\n+     *\n@@ -317,1 +364,3 @@\n-     * @throws IOException on IO error with the InputStream.\n+     * @throws IOException on IO error with the {@code InputStream}.\n+     * @throws EOFException when reading pass the end of the\n+     * {@code InputStream}.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":91,"deletions":42,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n- * {@code PEMEncoder} is used for encoding Privacy-Enhanced Mail (PEM) data.\n- * PEM is a textual encoding used to store and transfer security\n+ * {@code PEMEncoder} implements an encoder for Privacy-Enhanced Mail (PEM)\n+ * data.  PEM is a textual encoding used to store and transfer security\n@@ -54,2 +54,2 @@\n- * <p> Encoding may be performed on Java Cryptographic Extension (JCE) objects\n- * that implement {@link DEREncodable}.\n+ * <p> Encoding may be performed on cryptographic objects that implement\n+ * {@link DEREncodable}.\n@@ -57,3 +57,6 @@\n- * <p> Encrypted private key PEM data can be built by encoding with a\n- * {@code PEMEncoder} instance returned by {@linkplain #withEncryption(char[])}\n- * or by encoding an {@link EncryptedPrivateKeyInfo} .\n+ * <p> Private keys can be encrypted and encoded by configuring a\n+ * {@code PEMEncoder} with the {@linkplain #withEncryption(char[])} method,\n+ * which takes a password and returns a new {@code PEMEncoder} instance\n+ * configured to encrypt the key with that password. Alternatively, a\n+ * private key encrypted as an {@code EncryptedKeyInfo} object can be encoded\n+ * directly to PEM by passing it to the encode method\n@@ -61,3 +64,4 @@\n- * <p> PKCS #8 2.0 allows OneAsymmetricKey encoding, which may contain both\n- * private and public keys in the same PEM. This is supported by using the\n- * {@link KeyPair} class with the encode methods.\n+ * <p> PKCS #8 2.0 defines the ASN.1 OneAsymmetricKey structure, which may\n+ * contain both private and public keys.\n+ * {@link KeyPair} objects passed to the {@code encode} methods are encoded as a\n+ * OneAsymmetricKey structure using the \"PRIVATE KEY\" type.\n@@ -67,2 +71,3 @@\n- * from {@linkplain PEMRecord#type()}.  It will not check the validity of\n- * the data.\n+ * from {@linkplain PEMRecord#type()}. {@linkplain PEMRecord#leadingData()} is\n+ * not included in the encoding.  {@code PEMRecord} will not preform\n+ * validity checks on the data.\n@@ -70,2 +75,1 @@\n- * <p>{@code String} values encoded use character set\n- * {@link java.nio.charset.StandardCharsets#ISO_8859_1 ISO-8859-1}.\n+ * <p> This class is immutable and thread-safe.\n@@ -73,3 +77,1 @@\n- * <p>This class is immutable and thread-safe.\n- *\n- * <p>Here is an example of encoding a {@code PrivateKey} object:\n+ * <p> Here is an example of encoding a {@code PrivateKey} object:\n@@ -81,2 +83,2 @@\n- * <p>To make the {@code PEMEncoder} encrypt the above private key, only the\n- * encryption method is needed.\n+ * <p> Here is an example that encrypts and encodes a private key using the\n+ * specified password.\n@@ -116,1 +118,1 @@\n-     * Instantiate a new {@code PEMEncoder} for Encrypted Private Keys.\n+     * Instantiate a {@code PEMEncoder} for Encrypted Private Keys.\n@@ -136,1 +138,1 @@\n-     * Encode the specified {@code DEREncodable} and return the PEM encoding in a\n+     * Encodes the specified {@code DEREncodable} and returns a PEM encoded\n@@ -140,3 +142,2 @@\n-     * @return PEM encoding in a string\n-     * @throws IllegalArgumentException when encoding the {@code DEREncodable}\n-     * fails.\n+     * @return a byte array containing the PEM encoded data\n+     * @throws IllegalArgumentException If the DEREncodable cannot be encoded\n@@ -205,1 +206,2 @@\n-     * Encodes the specified {@code DEREncodable} into PEM.\n+     * Encodes the specified {@code DEREncodable} and returns the PEM encoding\n+     * in a byte array.\n@@ -209,2 +211,1 @@\n-     * @throws IllegalArgumentException when encoding the {@code DEREncodable}\n-     * fails.\n+     * @throws IllegalArgumentException if the DEREncodable cannot be encoded\n@@ -224,1 +225,1 @@\n-     * throw an{@code IllegalArgumentException}.\n+     * throw an {@code IllegalArgumentException}.\n@@ -228,2 +229,3 @@\n-     * parameters by the supporting provider.  To configure all the encryption\n-     * options see {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n+     * parameters by the supporting provider.  If you need more control over\n+     * the encryption algorithm and parameters, use\n+     * {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -42,7 +42,0 @@\n- * <p>Types with Java API representation, such as a {@link PrivateKey},\n- * can return a {@code PEMRecord} when used with\n- * {@linkplain PEMDecoder#decode(String, Class)}. Using {@code PEMRecord} can\n- * be helpful when generating a representation is not desired or when used\n- * with {@code leadingData}.  {@code leadingData} can depend on which\n- * decode() methods is used.\n- *\n@@ -50,2 +43,1 @@\n- * {@code PEMDecoder.decode()} methods encounter only non-PEM data and has\n- * reached the end of the stream. If there is PEM data, {@code type} and\n+ * there is no PEM data.  If there is PEM data, {@code type} and\n@@ -53,1 +45,1 @@\n- * input data only contains PEM data. All values can never be null.\n+ * decoded data only contains PEM data. All values can never be null.\n@@ -58,1 +50,1 @@\n- * <p>This class is immutable and thread-safe.  {@code leadingData} is not\n+ * <p>This class is thread-safe.  {@code leadingData} is not\n@@ -112,2 +104,2 @@\n-     * Creates a {@code PEMRecord} instance with a given {@code type} and {@code pem}\n-     * data in String form.  {@code leadingData} is set to null.\n+     * Creates a {@code PEMRecord} instance with a given {@code type} and\n+     * {@code pem} data in String form.  {@code leadingData} is set to null.\n@@ -115,2 +107,3 @@\n-     * @param type the type identifier in the PEM header and footer, or {@code null} if there is no PEM data.\n-     * @param pem The data between the PEM header and footer.\n+     * @param type the type identifier in the PEM header and footer, or\n+     * {@code null} if there is no PEM data.\n+     * @param pem the Base64-encoded data between the PEM header and footer.\n@@ -129,1 +122,1 @@\n-     * @param pem the data between the PEM header and footer.\n+     * @param pem the Base64-encoded data between the PEM header and footer.\n@@ -142,1 +135,1 @@\n-     * @return Returns a new array of the binary encoding each time this\n+     * @return a new array of the binary encoding each time this\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS());\n+        MutablePoint pub = ops.multiply(ecParams.getGenerator(), arrayS);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    protected byte[] attributes;\n+    private byte[] attributes;\n@@ -321,1 +321,8 @@\n-                X509Key x = X509Key.parse(pubKeyEncoded);\n+                X509Key x = new X509Key();\n+                try {\n+                    x.decode(pubKeyEncoded);\n+                } catch (InvalidKeyException e) {\n+                    throw new IOException(e);\n+                }\n+\n+                \/\/ X509Key x = X509Key.parse(pubKeyEncoded);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    \/\/ RSA or RSS-PSS KeyType\n+    \/\/ RSA or RSA-PSS KeyType\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,1 @@\n-                case -1 -> throw new IllegalArgumentException(\n-                    \"Input ended prematurely\");\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n@@ -230,1 +229,1 @@\n-                    throw new IllegalArgumentException(\"Incomplete header\");\n+                    throw new EOFException(\"Incomplete header\");\n@@ -243,2 +242,1 @@\n-                case -1 -> throw new IllegalArgumentException(\n-                    \"Input ended prematurely\");\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n@@ -258,2 +256,1 @@\n-                case -1 -> throw new IllegalArgumentException(\n-                    \"Input ended prematurely\");\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n@@ -268,2 +265,1 @@\n-                case -1 -> throw new IllegalArgumentException(\n-                    \"Input ended prematurely\");\n+                case -1 -> throw new EOFException(\"Input ended prematurely\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-        AlgorithmId algorithm;\n@@ -155,1 +154,1 @@\n-        algorithm = AlgorithmId.parse(in.data.getDerValue());\n+        AlgorithmId algorithm = AlgorithmId.parse(in.data.getDerValue());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,5 +100,0 @@\n-\n-        \/\/ PEMRecord tests\n-        System.out.println(\"Checking if ecCSR:\");\n-        test(PEMData.ecCSR);\n-\n@@ -140,2 +135,2 @@\n-        testPEMRecordDecode(PEMData.ecCSR);\n-        testPEMRecordDecode(PEMData.ecCSRWithData);\n+        \/\/testPEMRecordDecode(PEMData.ecCSR);\n+        \/\/estPEMRecordDecode(PEMData.ecCSRWithData);\n@@ -338,4 +333,0 @@\n-\/\/        if (pk instanceof KeyPair kp) {\n-\/\/            pk = kp.getPrivate();\n-\/\/        }\n-\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"}]}