{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import sun.security.util.KeyUtil;\n@@ -55,1 +56,1 @@\n- * The following lists the supported PEM types and the {@code DEREncodable}\n+ * <p> The following lists the supported PEM types and the {@code DEREncodable}\n@@ -65,1 +66,0 @@\n- *  <li>RSA PRIVATE KEY : {@code RSAPrivateKey}<\/li>\n@@ -71,1 +71,1 @@\n- * The {@code PublicKey} and {@code PrivateKey} types, an algorithm specific\n+ * <p> The {@code PublicKey} and {@code PrivateKey} types, an algorithm specific\n@@ -101,3 +101,3 @@\n- * will throw a {@link RuntimeException}. When an encrypted PEM is used with a\n- * decoder not configured for decryption, an {@link EncryptedPrivateKeyInfo}\n- * object is returned.\n+ * will throw a {@link RuntimeException}. When an encrypted private key PEM is\n+ * used with a decoder not configured for decryption, an\n+ * {@link EncryptedPrivateKeyInfo} object is returned.\n@@ -113,1 +113,1 @@\n- * <p> Here is an example of a {@code PEMDecoder} configured with decryption\n+ * <p> Here is an example of a {@code PEMEncoder} configured with decryption\n@@ -121,3 +121,3 @@\n- * @implNote An implementation may support other PEM types and DEREncodables.\n- * This implementation support PEM types:  {@code CERTIFICATE}, {@code X509 CRL},\n- * {@code PRIVATE KEY}, {@code PUBLIC KEY}, {@code ENCRYPTED PRIVATE KEY},\n+ * @implNote An implementation may support other PEM types and\n+ * {@code DEREncodables}. This implementation additionally supports PEM types:\n+ * {@code X509 CERTIFICATE}, {@code X.509 CERTIFICATE}, {@code CRL},\n@@ -182,1 +182,2 @@\n-                    yield (getKeyFactory(spec.getAlgorithm())).\n+                    yield getKeyFactory(\n+                        KeyUtil.getAlgorithm(spec.getEncoded())).\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n- *  <li>{@code X509EncodedKeySpec} : PUBLIC KEY<\/li>\n@@ -88,3 +87,0 @@\n- *  <li>{@code PKCS8EncodedKeySpec} : PRIVATE KEY<\/li>\n- *  <li>{@code KeyPair} : PRIVATE KEY<\/li>\n- *  <li>{@code EncryptedPrivateKeyInfo} : ENCRYPTED PRIVATE KEY<\/li>\n@@ -92,0 +88,4 @@\n+ *  <li>{@code EncryptedPrivateKeyInfo} : ENCRYPTED PRIVATE KEY<\/li>\n+ *  <li>{@code KeyPair} : PRIVATE KEY<\/li>\n+ *  <li>{@code X509EncodedKeySpec} : PUBLIC KEY<\/li>\n+ *  <li>{@code PKCS8EncodedKeySpec} : PRIVATE KEY<\/li>\n@@ -111,2 +111,1 @@\n- * This implementation support PEM types:  {@code CERTIFICATE}, {@code X509 CRL},\n- * {@code PRIVATE KEY}, {@code PUBLIC KEY}, and {@code ENCRYPTED PRIVATE KEY}.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -87,2 +88,2 @@\n-        if (type.startsWith(\"-\") || type.contains(\"BEGIN\") ||\n-            type.contains(\"END\") || type.endsWith(\"-\")) {\n+        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n+            type.startsWith(\"END \")) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import sun.security.util.KeyUtil;\n-\n-import java.io.IOException;\n@@ -82,3 +79,0 @@\n-     * This constructor extracts the algorithm name from the encoded bytes,\n-     * which may be an OID if no standard algorithm name is defined. If the\n-     * algorithm name cannot be extracted, it is set to null.\n@@ -93,7 +87,1 @@\n-        String algorithm = null;\n-        try {\n-            algorithm = KeyUtil.getAlgorithm(encodedKey).getName();\n-        } catch (IOException e) {\n-            \/\/ On error leave algorithmName as null.\n-        }\n-        super(encodedKey, algorithm);\n+        super(encodedKey);\n@@ -129,1 +117,1 @@\n-     * Returns the private key bytes, encoded according to the PKCS #8 standard.\n+     * Returns the key bytes, encoded according to the PKCS #8 standard.\n@@ -131,1 +119,1 @@\n-     * @return the PKCS #8 encoding of the private key. Returns a new array\n+     * @return the PKCS #8 encoding of the key. Returns a new array\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import sun.security.util.KeyUtil;\n-\n-import java.io.IOException;\n@@ -61,3 +58,0 @@\n-     * This constructor extracts the algorithm name from the encoded bytes,\n-     * which may be an OID if no standard algorithm name is defined. If the\n-     * algorithm name cannot be extracted, it is set to null.\n@@ -72,7 +66,1 @@\n-        String algorithm = null;\n-        try {\n-            algorithm = KeyUtil.getAlgorithm(encodedKey).getName();\n-        } catch (IOException e) {\n-            \/\/ On error leave algorithmName as null.\n-        }\n-        super(encodedKey, algorithm);\n+        super(encodedKey);\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -349,2 +349,2 @@\n-     * @throws RuntimeException on an encryption errors\n-     * @throws NullPointerException if the key or password are null. If\n+     * @throws RuntimeException on an encryption error\n+     * @throws NullPointerException if the key or password are {@code null}. If\n@@ -401,2 +401,2 @@\n-     * @throws RuntimeException on an encryption errors\n-     * @throws NullPointerException when the {code key} or {@code password}\n+     * @throws RuntimeException on an encryption error\n+     * @throws NullPointerException when the {@code key} or {@code password}\n@@ -438,1 +438,1 @@\n-     * @throws RuntimeException on an encryption errors\n+     * @throws RuntimeException on an encryption error\n@@ -440,1 +440,1 @@\n-     * null. If {@code params} is non-null, {@code algorithm} cannot be\n+     * {@code null}. If {@code params} is non-null, {@code algorithm} cannot be\n@@ -547,1 +547,1 @@\n-            return KeyFactory.getInstance(p.getAlgorithm()).\n+            return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded())).\n@@ -550,1 +550,1 @@\n-        return KeyFactory.getInstance(p.getAlgorithm(),\n+        return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded()),\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -483,0 +483,17 @@\n+    \/**\n+     * With a given DER encoded bytes, read through and return the AlgorithmID\n+     * stored if it can be found.  If none is found or there is an IOException,\n+     * null is returned.\n+     *\n+     * @param encoded DER encoded bytes\n+     * @return AlgorithmID stored in the DER encoded bytes or null.\n+     *\/\n+    public static String getAlgorithm(byte[] encoded) {\n+        try {\n+            return getAlgorithmId(encoded).getName();\n+        } catch (IOException e) {\n+            \/\/ We want the result, not the details why it failed.\n+            return null;\n+        }\n+    }\n+\n@@ -489,1 +506,1 @@\n-     * @throws IOException\n+     * @throws IOException if there was a DER or other parsing error\n@@ -491,1 +508,1 @@\n-    public static AlgorithmId getAlgorithm(byte[] encoded) throws IOException {\n+    public static AlgorithmId getAlgorithmId(byte[] encoded) throws IOException {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-        pbePattern = Pattern.compile(\"^PBEWith.*And.*\");\n+        pbePattern = Pattern.compile(\"^PBEWith.*And.*\",\n+            Pattern.CASE_INSENSITIVE);\n@@ -237,1 +238,2 @@\n-                case WS, '\\t', '\\n', '\\r' -> {} \/\/ skip whitespace, tab, etc\n+                case WS, '\\t','\\r' -> {} \/\/ skip whitespace, tab, etc\n+                case '\\n' -> {}\n@@ -286,1 +288,1 @@\n-            throw new IllegalArgumentException(\"Illegal footer: \" + footer);\n+            throw new IOException(\"Illegal footer: \" + footer);\n@@ -313,2 +315,1 @@\n-            b64Encoder = Base64.getMimeEncoder(64,\n-                System.lineSeparator().getBytes());\n+            b64Encoder = Base64.getMimeEncoder(0, new byte[0]);\n@@ -328,1 +329,2 @@\n-        sb.append(pem.pem());\n+        sb.append(pem.pem().replaceAll(\"(.{64})\", \"$1\" +\n+            System.lineSeparator()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-        System.out.println(\"Decoder test ecsecp256:\");\n-        testFailure(PEMData.ecsecp256pub.makeNoCRLF(\"pubecpem-no\"));\n@@ -125,12 +123,0 @@\n-\n-        \/\/testInputStream();\n-        testPEMRecord(PEMData.rsapub);\n-        testPEMRecord(PEMData.ecCert);\n-        testPEMRecord(PEMData.ec25519priv);\n-        testPEMRecord(PEMData.ecCSR);\n-        testPEMRecord(PEMData.ecCSRWithData);\n-        testPEMRecordDecode(PEMData.rsapub);\n-        testPEMRecordDecode(PEMData.ecCert);\n-        testPEMRecordDecode(PEMData.ec25519priv);\n-        \/\/testPEMRecordDecode(PEMData.ecCSR);\n-        \/\/estPEMRecordDecode(PEMData.ecCSRWithData);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+\n+        PEMDecoder d = PEMDecoder.of();\n+        PEMRecord pemRecord =\n+            d.decode(PEMData.ed25519ep8.pem(), PEMRecord.class);\n+        checkResults(PEMData.ed25519ep8, pemRecord.toString());\n@@ -205,1 +210,2 @@\n-        result = LSDEFAULT.matcher(result).replaceAll(\"\");\n+        result = LF.matcher(CR.matcher(pem).replaceAll(\"\")).\n+            replaceAll(\"\");\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}