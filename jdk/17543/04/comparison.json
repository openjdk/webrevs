{"files":[{"patch":"@@ -37,1 +37,1 @@\n-public interface AsymmetricKey extends Key {\n+public non-sealed interface AsymmetricKey extends Key, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/AsymmetricKey.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+\/**\n+ * This is a top-level interface for security classes that contain cryptographic\n+ * data which may not be related or have a common class hierarchy.  These\n+ * security objects provide standard binary encoding, like ASN.1, and type\n+ * formats, like X.509 and PKCS#8.  These encodings are used in some form with\n+ * {@link KeyFactory} and {@link java.security.cert.CertificateFactory},\n+ *\n+ * @see Key\n+ * @see KeyPair\n+ * @see EncodedKeySpec\n+ * @see EncryptedPrivateKeyInfo\n+ * @see X509Certificate\n+ * @see X509CRL\n+ *\n+ * @since 24\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public sealed interface DEREncodable permits AsymmetricKey, KeyPair, X509CRL,\n+    X509Certificate, PKCS8EncodedKeySpec, X509EncodedKeySpec,\n+    EncryptedPrivateKeyInfo {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-public final class KeyPair implements java.io.Serializable {\n+public final class KeyPair implements java.io.Serializable, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPair.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,390 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.rsa.RSAPrivateCrtKeyImpl;\n+import sun.security.util.PEMRecord;\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.io.*;\n+import java.security.cert.*;\n+import java.security.spec.*;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * PEMDecoder is an immutable Privacy-Enhanced Mail (PEM) decoding class.\n+ * PEM is a textual encoding used for storing and transferring security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL). Defined in RFC 1421 and RFC 7468, PEM consists of a\n+ * Base64-formatted binary encoding surrounded by a type identifying header\n+ * and footer.\n+ * <p>\n+ * Decoding methods return a class that matches the data type and implements\n+ * {@link DEREncodable}.\n+ * If a return class is specified, an IllegalAlgorithmException is thrown if\n+ * data is not valid for the class.\n+ * <p>\n+ * When passing input data into {@code decode}, the application is responsible\n+ * for processing input data non-PEM text. All data before the PEM\n+ * header will be ignored.\n+ * <p>\n+ * A new immutable PEMDecoder instance is returned by\n+ * {@linkplain #withFactory} and\/or {@linkplain #withDecryption}.  Configuring\n+ * an instance for decryption does not prevent decoding with unencrypted PEM.\n+ * Any encrypted PEM that does not use the configured password will cause an\n+ * exception. A decoder instance not configured with decryption will return an\n+ * {@link EncryptedPrivateKeyInfo} with encrypted PEM.  EncryptedPrivateKeyInfo\n+ * methods must be used to retrieve the {@link PrivateKey}.\n+ * <p>\n+ * PEMDecoder supports the follow types:\n+ * <pre>\n+ *     PRIVATE KEY, RSA PRIVATE KEY, PUBLIC KEY, CERTIFICATE, CRL, and\n+ *     ENCRYPTED PRIVATE KEY.\n+ * <\/pre>\n+ * @apiNote\n+ * Here is an example of encoding a PrivateKey object:\n+ * <pre>\n+ *     PEMDecoder pd = PEMDecoder.of();\n+ *     PrivateKey priKey = pd.decode(PriKeyPEM);\n+ * <\/pre>\n+ *\n+ * @since 24\n+ *\/\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMDecoder {\n+    private final Provider factory;\n+    private final char[] password;\n+\n+    \/\/ Singleton instance for PEMDecoder\n+    private final static PEMDecoder PEM_DECODER = new PEMDecoder(null, null);\n+\n+    \/**\n+     * Creates a immutable instance with a specific KeyFactory and\/or password.\n+     * @param withFactory KeyFactory provider\n+     * @param withPassword char[] password for EncryptedPrivateKeyInfo\n+     *                    decryption\n+     *\/\n+    private PEMDecoder(Provider withFactory, char[] withPassword) {\n+        password = withPassword != null ? withPassword.clone() : null;\n+        factory = withFactory;\n+    }\n+\n+    \/**\n+     * Returns an instance of PEMDecoder.  This instance may be repeatedly used\n+     * to decode different PEM text.\n+     *\n+     * @return returns a PEMDecoder\n+     *\/\n+    public static PEMDecoder of() {\n+        return PEM_DECODER;\n+    }\n+\n+    \/**\n+     * After the header, footer, and base64 have been separated, identify the\n+     * header and footer and proceed with decoding the base64 for the\n+     * appropriate type.\n+     *\/\n+    private DEREncodable decode(PEMRecord pem) throws IOException {\n+        if (password != null) {\n+            if (!PEMRecord.ENCRYPTED_PRIVATE_KEY.equalsIgnoreCase(pem.id())) {\n+                throw new IllegalArgumentException(\"Decoder configured only \" +\n+                    \"for encrypted PEM.\");\n+            }\n+        }\n+\n+        Base64.Decoder decoder = Base64.getMimeDecoder();\n+\n+        try {\n+            return switch (pem.id()) {\n+                case PEMRecord.PUBLIC_KEY -> {\n+                    X509EncodedKeySpec spec =\n+                        new X509EncodedKeySpec(decoder.decode(pem.pem()));\n+                    yield (getKeyFactory(spec.getAlgorithm())).\n+                        generatePublic(spec);\n+\n+                }\n+                case PEMRecord.PRIVATE_KEY -> {\n+                    PKCS8Key p8key = new PKCS8Key(decoder.decode(pem.pem()));\n+                    PrivateKey priKey;\n+                    KeyFactory kf = getKeyFactory(p8key.getAlgorithm());\n+                    priKey = kf.generatePrivate(\n+                        new PKCS8EncodedKeySpec(p8key.getEncoded(),\n+                            p8key.getAlgorithm()));\n+                    \/\/ If there is a public key, it's an OAS.\n+                    if (p8key.getPubKeyEncoded() != null) {\n+                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                            p8key.getPubKeyEncoded(), p8key.getAlgorithm());\n+                        yield new KeyPair(getKeyFactory(p8key.getAlgorithm()).\n+                            generatePublic(spec), priKey);\n+                    }\n+                    yield priKey;\n+                }\n+                case PEMRecord.ENCRYPTED_PRIVATE_KEY -> {\n+                    if (password == null) {\n+                        yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem()));\n+                    }\n+                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.pem())).\n+                        getKey(password);\n+                }\n+                case PEMRecord.CERTIFICATE,\n+                    PEMRecord.X509_CERTIFICATE -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n+                    yield (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n+                }\n+                case PEMRecord.X509_CRL -> {\n+                    CertificateFactory cf = getCertFactory(\"X509\");\n+                    yield (X509CRL) cf.generateCRL(\n+                        new ByteArrayInputStream(decoder.decode(pem.pem())));\n+                }\n+                case PEMRecord.RSA_PRIVATE_KEY -> {\n+                    KeyFactory kf = getKeyFactory(\"RSA\");\n+                    yield kf.generatePrivate(\n+                        RSAPrivateCrtKeyImpl.getKeySpec(decoder.decode(pem.pem())));\n+                }\n+                default ->\n+                    throw new IllegalArgumentException(\"Unsupported type or \" +\n+                        \"not properly formatted PEM\");\n+            };\n+        } catch (GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns {@link DEREncodable} from the given string.\n+     *\n+     * @param str PEM data in a String.\n+     * @return an DEREncodable generated from the PEM data.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public DEREncodable decode(String str) {\n+        Objects.requireNonNull(str);\n+        try {\n+            return decode(new ByteArrayInputStream(str.getBytes()));\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns a {@link DEREncodable} from the given\n+     * {@code InputStream}.\n+     * The method will read the {@code InputStream} until PEM data is\n+     * found or until the end of the stream.  Non-PEM data in the\n+     * {@code InputStream} before the PEM header will be ignored by the decoder.\n+     *\n+     * @param is InputStream containing PEM data.\n+     * @return an DEREncodable generated from the PEM data.\n+     * @throws IOException on IO error with the InputStream.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     *\/\n+    public DEREncodable decode(InputStream is) throws IOException {\n+        Objects.requireNonNull(is);\n+        PEMRecord pem = Pem.readPEM(is);\n+        if (pem == null) {\n+            throw new IllegalArgumentException(\"No PEM data found.\");\n+        }\n+        return decode(pem);\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given PEM string.  The\n+     * class must extend {@link DEREncodable} and be the appropriate class for\n+     * the PEM type.\n+     *\n+     * <p>With the {@code tClass} argument, the returned object may be cast to a\n+     * subclass or converted to a different return class, if\n+     * appropriate for that PEM data.  Using EC public key PEM as an example,\n+     * {@code tClass} may be set to {@code PublicKey.class},\n+     * {@code ECPublicKey}, or a {@code X509EncodedKeySpec}.  {@code PublicKey}\n+     * is useful for algorithm-agnostic methods, {@code ECPublicKey} for\n+     * algorithm-specific operations, or {@code X509EncodedKeySpec} if the\n+     * X.509 binary encoding is desired instead of a Key object.  An IOException\n+     * will be thrown if the class is incorrect for the given PEM data.\n+     *\n+     * @param <S> Class type parameter that extends {@link DEREncodable}\n+     * @param string the String containing PEM data.\n+     * @param tClass  the returned object class that implementing\n+     * {@link DEREncodable}.\n+     * @return The DEREncodable typecast to tClass.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     * @throws ClassCastException if the given class is invalid for the PEM .\n+     *\/\n+    public <S extends DEREncodable> S decode(String string, Class<S> tClass) {\n+        Objects.requireNonNull(string);\n+        try {\n+            return decode(new ByteArrayInputStream(string.getBytes()), tClass);\n+        } catch (IOException e) {\n+            \/\/ With all data contained in the String, there are no IO ops.\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Decodes and returns the specified class for the given PEM stream.  The\n+     * class must extend {@link DEREncodable} and be an appropriate class for\n+     * the PEM type.\n+     *\n+     * <p>See {@link PEMDecoder#decode(String, Class)} for details about\n+     * {@code tClass}.\n+     * <br>See {@link PEMDecoder#decode(InputStream)} for details on using an\n+     * {@code InputStream}.\n+     *\n+     * @param <S> Class type parameter that extends {@code DEREncodable}\n+     * @param is an InputStream containing PEM data.\n+     * @param tClass the returned object class that implementing\n+     *   {@code DEREncodable}.\n+     * @return  tClass.\n+     * @throws IOException on IO error with the InputStream.\n+     * @throws IllegalArgumentException on error in decoding or if the PEM is\n+     * unsupported.\n+     * @throws ClassCastException if the given class is invalid for the PEM .\n+     *\n+     *\/\n+    public <S extends DEREncodable> S decode(InputStream is, Class<S> tClass)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+        Objects.requireNonNull(tClass);\n+        PEMRecord pem = Pem.readPEM(is);\n+        if (pem == null) {\n+            throw new IllegalArgumentException(\"No PEM data found.\");\n+        }\n+\n+        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+            return tClass.cast(pem);\n+        }\n+\n+        DEREncodable so = decode(pem);\n+\n+        \/*\n+         * If the object is a KeyPair, check if the tClass is set to class\n+         * specific to a private or public key.  Because PKCS8v2 can be a\n+         * KeyPair, it is possible for someone to assume all their PEM private\n+         * keys are only PrivateKey and not KeyPair.\n+         *\/\n+        if (so instanceof KeyPair kp) {\n+            if ((PrivateKey.class).isAssignableFrom(tClass) ||\n+                (PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPrivate();\n+            }\n+            if ((PublicKey.class).isAssignableFrom(tClass) ||\n+                (X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                so = kp.getPublic();\n+            }\n+        }\n+\n+        \/*\n+         * KeySpec use getKeySpec after the Key has been generated.  Even though\n+         * returning a binary encoding after the Base64 decoding is ok when the\n+         * user wants PKCS8EncodedKeySpec, generating the key verifies the\n+         * binary encoding and allows the KeyFactory to use the provider's\n+         * KeySpec()\n+         *\/\n+\n+        if ((EncodedKeySpec.class).isAssignableFrom(tClass) &&\n+            so instanceof Key key) {\n+            try {\n+                \/\/ unchecked suppressed as we know tClass comes from KeySpec\n+                \/\/ KeyType not relevant here.  We just want KeyFactory\n+                if ((PKCS8EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    getKeyFactory(key.getAlgorithm()).\n+                        getKeySpec(key, PKCS8EncodedKeySpec.class);\n+                } else if ((X509EncodedKeySpec.class).isAssignableFrom(tClass)) {\n+                    getKeyFactory(key.getAlgorithm())\n+                        .getKeySpec(key, X509EncodedKeySpec.class);\n+                } else {\n+                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                }\n+            } catch (InvalidKeySpecException e) {\n+                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n+                    \"specified (\" + tClass.getName() +\") for key (\" +\n+                    key.getClass().getName() +\")\", e);\n+            }\n+        }\n+\n+        return tClass.cast(so);\n+    }\n+\n+\n+    private KeyFactory getKeyFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return KeyFactory.getInstance(algorithm);\n+            }\n+            return KeyFactory.getInstance(algorithm, factory);\n+        } catch(GeneralSecurityException e){\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/\/ Convenience method to avoid provider getInstance checks clutter\n+    private CertificateFactory getCertFactory(String algorithm) {\n+        try {\n+            if (factory == null) {\n+                return CertificateFactory.getInstance(algorithm);\n+            }\n+            return CertificateFactory.getInstance(algorithm, factory);\n+        } catch (GeneralSecurityException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Configures and return a new PEMDecoder instance from the current instance\n+     * that will use Factory classes from the specified Provider.\n+     *\n+     * @param provider the Factory provider.\n+     * @return a new PEM decoder instance.\n+     *\/\n+    public PEMDecoder withFactory(Provider provider) {\n+        return new PEMDecoder(provider, password);\n+    }\n+\n+    \/**\n+     * Returns a new PEMDecoder instance from the current instance configured\n+     * to decrypt encrypted PEM data with given password.\n+     * Non-encrypted PEM may still be decoded from this instance.\n+     *\n+     * @param password the password to decrypt encrypted PEM data.\n+     * @return the decoder\n+     * @throws NullPointerException if password is null.\n+     *\/\n+    public PEMDecoder withDecryption(char[] password) {\n+        char[] pwd = password.clone();\n+        return new PEMDecoder(factory, pwd);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.PEMRecord;\n+import sun.security.util.Pem;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\/**\n+ * PEMEncoder is an immutable Privacy-Enhanced Mail (PEM) encoding class.\n+ * PEM is a textual encoding used for storing and transferring security\n+ * objects, such as asymmetric keys, certificates, and certificate revocation\n+ * lists (CRL). Defined in RFC 1421 and RFC 7468, PEM consists of a\n+ * Base64-formatted binary encoding surrounded by a type identifying header\n+ * and footer.\n+ * <p>\n+ * Encoding may be performed on objects that implement {@link DEREncodable}.\n+ * <p>\n+ * Encrypted private key PEM data can be built by calling the encode methods\n+ * on a PEMEncoder instance returned by {@link #withEncryption(char[])} or\n+ * by passing an {@link EncryptedPrivateKeyInfo} object into the encode methods.\n+ * <p>\n+ * PKCS8 v2.0 allows OneAsymmetric encoding, which is a private and public\n+ * key in the same PEM.  This is supported by using the {@link KeyPair} class\n+ * with the encode methods.\n+ * <p>\n+ * PEMEncoder supports the follow types:\n+ * <pre>\n+ *     PRIVATE KEY, PUBLIC KEY, CERTIFICATE, CRL, and ENCRYPTED PRIVATE KEY.\n+ * <\/pre>\n+ *\n+ * @apiNote\n+ * Here is an example of encoding a PrivateKey object:\n+ * <pre>\n+ *     PEMEncoder pe = PEMEncoder.of();\n+ *     byte[] pemData = pe.encode(privKey);\n+ * <\/pre>\n+ *\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public final class PEMEncoder {\n+\n+    \/\/ Singleton instance of PEMEncoder\n+    private static final PEMEncoder PEM_ENCODER = new PEMEncoder(null);\n+\n+    \/\/ Stores the password for an encrypted encoder that isn't setup yet.\n+    private PBEKeySpec keySpec;\n+    \/\/ Stores the key after the encoder is ready to encrypt.  The prevents\n+    \/\/ repeated SecretKeyFactory calls if the encoder is used on multiple keys.\n+    private SecretKey key;\n+    \/\/ Makes SecretKeyFactory generation thread-safe.\n+    private final ReentrantLock lock;\n+    \/\/ Lazy initialize singleton encoder.\n+    private static Base64.Encoder b64Encoder;\n+\n+    \/**\n+     * Instantiate a new PEMEncoder for Encrypted Private Keys.\n+     *\n+     * @param pbe contains the password spec used for encryption.\n+     *\/\n+    private PEMEncoder(PBEKeySpec pbe) {\n+        keySpec = pbe;\n+        lock = new ReentrantLock();\n+    }\n+\n+    \/**\n+     * Returns an instance of PEMEncoder.\n+     *\n+     * @return PEMEncoder instance\n+     *\/\n+    static public PEMEncoder of() {\n+        return PEM_ENCODER;\n+    }\n+\n+    \/**\n+     * Construct a String-based encoding based off the id type.\n+     * @return the string\n+     *\/\n+    private String pemEncoded(PEMRecord pem) {\n+        StringBuilder sb = new StringBuilder(1024);\n+        sb.append(\"-----BEGIN \").append(pem.id()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        if (b64Encoder == null) {\n+            b64Encoder = Base64.getMimeEncoder(64,\n+                System.lineSeparator().getBytes());\n+        }\n+        sb.append(b64Encoder.encodeToString(\n+            pem.pem().getBytes(StandardCharsets.ISO_8859_1)));\n+        sb.append(System.lineSeparator());\n+        sb.append(\"-----END \").append(pem.id()).append(\"-----\");\n+        sb.append(System.lineSeparator());\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Encoded a given {@code DEREncodable} and return the PEM encoding in a\n+     * String\n+     *\n+     * @param de a cryptographic object to be PEM encoded that implements\n+     *           DEREncodable.\n+     * @return PEM encoding in a String\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public String encodeToString(DEREncodable de) {\n+        Objects.requireNonNull(de);\n+        return switch (de) {\n+            case PublicKey pu -> build(null, pu.getEncoded());\n+            case PrivateKey pr -> build(pr.getEncoded(), null);\n+            case KeyPair kp -> {\n+                if (kp.getPublic() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PublicKey.\");\n+                }\n+\n+                if (kp.getPrivate() == null) {\n+                    throw new IllegalArgumentException(\"KeyPair does not \" +\n+                        \"contain PrivateKey.\");\n+                }\n+                yield build(kp.getPrivate().getEncoded(),\n+                    kp.getPublic().getEncoded());\n+            }\n+            case X509EncodedKeySpec x -> build(null, x.getEncoded());\n+            case PKCS8EncodedKeySpec p -> build(p.getEncoded(), null);\n+            case EncryptedPrivateKeyInfo epki -> {\n+                try {\n+                    yield pemEncoded(new PEMRecord(\n+                        PEMRecord.ENCRYPTED_PRIVATE_KEY, epki.getEncoded()));\n+                } catch (IOException e) {\n+                    throw new SecurityException(e);\n+                }\n+            }\n+            case X509Certificate c -> {\n+                try {\n+                    yield pemEncoded(new PEMRecord(PEMRecord.CERTIFICATE,\n+                        c.getEncoded()));\n+                } catch (CertificateEncodingException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            case X509CRL crl -> {\n+                try {\n+                    yield pemEncoded(new PEMRecord(PEMRecord.X509_CRL,\n+                        crl.getEncoded()));\n+                } catch (CRLException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            default -> throw new IllegalArgumentException(\"PEM does not \" +\n+                \"support \" + de.getClass().getCanonicalName());\n+        };\n+    }\n+\n+    \/**\n+     * Encoded a given {@code DEREncodable} into PEM.\n+     *\n+     * @param de the object that implements DEREncodable.\n+     * @return a PEM encoded byte[] of the given DEREncodable.\n+     * @throws IllegalArgumentException when the passed object returns a null\n+     * binary encoding. An exception is thrown when PEMEncoder is\n+     * configured for encryption while encoding a DEREncodable that does\n+     * not support encryption.\n+     * @throws NullPointerException when object passed is null.\n+     * @see #withEncryption(char[])\n+     *\/\n+    public byte[] encode(DEREncodable de) {\n+        return encodeToString(de).getBytes(StandardCharsets.ISO_8859_1);\n+    }\n+\n+    \/**\n+     * Returns a new immutable PEMEncoder instance configured to the default\n+     * encryption algorithm and a given password.\n+     *\n+     * <p> Only {@link PrivateKey} will be encrypted with this newly configured\n+     * instance.  Other {@link DEREncodable} classes that do not support\n+     * encrypted PEM will cause encode() to throw an IllegalArgumentException.\n+     *\n+     * <p> Default algorithm defined by Security Property {@code\n+     * jdk.epkcs8.defaultAlgorithm}.  To configure all the encryption options\n+     * see {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, char[], String,\n+     * AlgorithmParameterSpec, Provider)} and use the returned object with\n+     * {@link #encode(DEREncodable)}.\n+     *\n+     * @param password the password\n+     * @return a new PEMEncoder\n+     * @throws NullPointerException if password is null.\n+     *\/\n+    public PEMEncoder withEncryption(char[] password) {\n+        \/\/ PBEKeySpec clones the password\n+        return new PEMEncoder(new PBEKeySpec(password));\n+    }\n+\n+    \/**\n+     * Build PEM encoding.\n+     *\/\n+    private String build(byte[] privateBytes, byte[] publicBytes) {\n+        DerOutputStream out = new DerOutputStream();\n+        Cipher cipher;\n+\n+        \/\/ If `keySpec` is non-null, then `key` hasn't been established.\n+        \/\/ Setting a `key' prevents repeated key generations operations.\n+        \/\/ withEncryption() is a configuration method and cannot throw an\n+        \/\/ exception; therefore generation is delayed.\n+        if (keySpec != null) {\n+            \/\/ For thread safety\n+            lock.lock();\n+            if (key == null) {\n+                try {\n+                    key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n+                        generateSecret(keySpec);\n+                    keySpec.clearPassword();\n+                    keySpec = null;\n+                } catch (GeneralSecurityException e) {\n+                    throw new SecurityException(\"Security property \" +\n+                        \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                        \"valid algorithm.  Operation cannot be performed.\", e);\n+                } finally {\n+                    lock.unlock();\n+                }\n+            } else {\n+                lock.unlock();\n+            }\n+        }\n+\n+        \/\/ If `key` is non-null, this is an encoder ready to encrypt.\n+        if (key != null) {\n+            if (privateBytes == null || publicBytes != null) {\n+                throw new IllegalArgumentException(\"Can only encrypt a \" +\n+                    \"PrivateKey.\");\n+            }\n+\n+            try {\n+                cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n+                cipher.init(Cipher.ENCRYPT_MODE, key);\n+            } catch (GeneralSecurityException e) {\n+                throw new SecurityException(\"Security property \" +\n+                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                    \"valid algorithm.  Operation cannot be performed.\", e);\n+            }\n+\n+            new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n+                cipher.getParameters()).encode(out);\n+\n+            try {\n+                out.putOctetString(cipher.doFinal(privateBytes));\n+                return pemEncoded(new PEMRecord(PEMRecord.ENCRYPTED_PRIVATE_KEY,\n+                    DerValue.wrap(DerValue.tag_Sequence, out).toByteArray()));\n+            } catch (GeneralSecurityException e) {\n+                throw new IllegalArgumentException(e);\n+            }\n+        }\n+\n+        \/\/ X509 only\n+        if (publicBytes != null && privateBytes == null) {\n+            return pemEncoded(new PEMRecord(PEMRecord.PUBLIC_KEY, publicBytes));\n+        }\n+        \/\/ PKCS8 only\n+        if (publicBytes == null && privateBytes != null) {\n+            return pemEncoded(new PEMRecord(PEMRecord.PRIVATE_KEY,\n+                privateBytes));\n+        }\n+        \/\/ OAS\n+        try {\n+            return pemEncoded(new PEMRecord(PEMRecord.PRIVATE_KEY,\n+                PKCS8Key.getEncoded(publicBytes, privateBytes)));\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -107,1 +107,1 @@\n-public abstract class X509CRL extends CRL implements X509Extension {\n+public abstract non-sealed class X509CRL extends CRL implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CRL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-public abstract class X509Certificate extends Certificate\n-implements X509Extension {\n+public abstract non-sealed class X509Certificate extends Certificate\n+implements X509Extension, DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509Certificate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -30,0 +31,1 @@\n+import java.io.IOException;\n@@ -53,2 +55,1 @@\n-        SharedSecrets.setJavaSecuritySpecAccess(\n-                EncodedKeySpec::clear);\n+        SharedSecrets.setJavaSecuritySpecAccess(EncodedKeySpec::clear);\n@@ -59,0 +60,3 @@\n+     * This constructor extracts the algorithm name from the encoded bytes,\n+     * which may be an OID if no standard algorithm name is defined. If the\n+     * algorithm name cannot be extracted, it is set to null.\n@@ -67,0 +71,5 @@\n+        try {\n+            algorithmName = KeyUtil.getAlgorithm(this.encodedKey).getName();\n+        } catch (IOException e) {\n+            \/\/ On error leave algorithmName as null.\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.security.DEREncodable;\n+\n@@ -62,1 +64,1 @@\n-public class PKCS8EncodedKeySpec extends EncodedKeySpec {\n+public final class PKCS8EncodedKeySpec extends EncodedKeySpec implements DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.security.DEREncodable;\n+\n@@ -52,1 +54,2 @@\n-public class X509EncodedKeySpec extends EncodedKeySpec {\n+public final class X509EncodedKeySpec extends EncodedKeySpec implements\n+    DEREncodable {\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,8 @@\n-import java.io.*;\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.pkcs.PKCS8Key;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.crypto.spec.PBEKeySpec;\n+import java.io.IOException;\n@@ -31,4 +38,1 @@\n-import sun.security.x509.AlgorithmId;\n-import sun.security.util.DerValue;\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n+import java.util.Objects;\n@@ -53,1 +57,1 @@\n- * @see java.security.spec.PKCS8EncodedKeySpec\n+ * @see PKCS8EncodedKeySpec\n@@ -58,1 +62,1 @@\n-public class EncryptedPrivateKeyInfo {\n+public final class EncryptedPrivateKeyInfo implements DEREncodable {\n@@ -65,1 +69,1 @@\n-    \/\/ In all other cases, algid is non null and params is null.\n+    \/\/ In all other cases, algid is non-null and params is null.\n@@ -76,7 +80,5 @@\n-     * Constructs (i.e., parses) an {@code EncryptedPrivateKeyInfo} from\n-     * its ASN.1 encoding.\n-     * @param encoded the ASN.1 encoding of this object. The contents of\n-     * the array are copied to protect against subsequent modification.\n-     * @exception NullPointerException if the {@code encoded} is\n-     * {@code null}.\n-     * @exception IOException if error occurs when parsing the ASN.1 encoding.\n+     * Constructs an {@code EncryptedPrivateKeyInfo} from a given Encrypted\n+     * PKCS#8 ASN.1 encoding.\n+     * @param encoded the ASN.1 encoding to be parsed.\n+     * @throws NullPointerException if {@code encoded} is {@code null}.\n+     * @throws IOException if error occurs when parsing the ASN.1 encoding.\n@@ -85,4 +87,1 @@\n-        if (encoded == null) {\n-            throw new NullPointerException(\"the encoded parameter \" +\n-                \"must be non-null\");\n-        }\n+        Objects.requireNonNull(encoded);\n@@ -189,0 +188,1 @@\n+\n@@ -202,1 +202,1 @@\n-        \/\/ one and only one is non null\n+        \/\/ one and only one is non-null\n@@ -220,0 +220,11 @@\n+    \/**\n+     * Create an EncryptedPrivateKeyInfo object from the given components\n+     *\/\n+    private EncryptedPrivateKeyInfo(byte[] encoded, byte[] eData,\n+        AlgorithmId id, AlgorithmParameters p) {\n+        this.encoded = encoded;\n+        encryptedData = eData;\n+        algid = id;\n+        params = p;\n+    }\n+\n@@ -307,0 +318,146 @@\n+    \/**\n+     * Returns an {@code EncryptedPrivateKeyInfo} from a given PrivateKey.\n+     * A valid password-based encryption (PBE) algorithm and password must be\n+     * specified.  AlgorithmParameterSpec, {@code params}, will use the\n+     * provider default if {@code null} is passed.  If {@code provider} is\n+     * {@code null}, the provider will be selected through the default\n+     * provider list.\n+     * <p>\n+     * The PBE algorithm string format details can be found in the\n+     * <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+     * Cipher section<\/a> of the Java Security Standard Algorithm Names\n+     * Specification.\n+     *\n+     * @param key the PrivateKey object to encrypt.\n+     * @param password the password used for generating the PBE key.\n+     * @param algorithm the PBE encryption algorithm.\n+     * @param params the parameters used with the PBE encryption.\n+     * @param provider the Provider that will perform the encryption.\n+     * @return an EncryptedPrivateKeyInfo.\n+     * @throws IllegalArgumentException when arguments passed are incorrect.\n+     * @throws SecurityException on a cryptographic errors.\n+     * @throws NullPointerException if an argument passed in is unexpectedly null.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider) {\n+\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        Objects.requireNonNull(algorithm);\n+        Cipher cipher;\n+        SecretKey skey;\n+\n+        try {\n+            SecretKeyFactory factory;\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+                cipher = Cipher.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+                cipher = Cipher.getInstance(algorithm, provider);\n+            }\n+            skey = factory.generateSecret(keySpec);\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException |\n+                 InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+\n+        AlgorithmId algId;\n+        byte[] encryptedData;\n+        DerOutputStream out = new DerOutputStream();\n+        try {\n+            cipher.init(Cipher.ENCRYPT_MODE, skey, params);\n+            encryptedData = cipher.doFinal(key.getEncoded());\n+            algId = new AlgorithmId(Pem.getPBEID(algorithm),\n+                cipher.getParameters());\n+            algId.encode(out);\n+            out.putOctetString(encryptedData);\n+        } catch (InvalidAlgorithmParameterException |\n+                 IllegalBlockSizeException | BadPaddingException |\n+                 InvalidKeyException e) {\n+            throw new SecurityException(e);\n+        }\n+        return new EncryptedPrivateKeyInfo(\n+            DerValue.wrap(DerValue.tag_Sequence, out).toByteArray(),\n+            encryptedData, algId, cipher.getParameters());\n+    }\n+\n+    \/**\n+     * Creates and encrypts an `EncryptedPrivateKeyInfo` from a given PrivateKey\n+     * and password.\n+     * <p>\n+     * The encryption uses the algorithm set by `jdk.epkcs8.defaultAlgorithm`\n+     * Security Property by the default provider and default the\n+     * AlgorithmParameterSpec of that provider.\n+     *\n+     * @param key The PrivateKey object to encrypt.\n+     * @param password the password used in the PBE encryption.\n+     * @return an EncryptedPrivateKeyInfo.\n+     * @throws IllegalArgumentException when arguments passed are incorrect.\n+     * @throws SecurityException on a cryptographic errors.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+        char[] password) {\n+        char[] pass = password.clone();\n+        if (Pem.DEFAULT_ALGO == null || Pem.DEFAULT_ALGO.length() == 0) {\n+            throw new SecurityException(\"Security property \" +\n+                \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n+                \"valid algorithm.  Operation cannot be performed.\");\n+        }\n+        return encryptKey(key, pass, Pem.DEFAULT_ALGO,\n+            null, null);\n+    }\n+\n+    \/**\n+     * Return a PrivateKey from the encrypted data in the object.\n+     *\n+     * @param password the password used in the PBE encryption.\n+     * @return a PrivateKey\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password) throws InvalidKeyException {\n+        return getKey(password, null);\n+    }\n+\n+    \/**\n+     * Return a PrivateKey from the object's encrypted data with a KeyFactory\n+     * from the given Provider.\n+     *\n+     * @param password the password\n+     * @param provider the KeyFactory provider used to generate the key.\n+     * @return a PrivateKey\n+     * @throws InvalidKeyException if an error occurs during parsing of the\n+     * encrypted data or creation of the key object.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public PrivateKey getKey(char[] password, Provider provider)\n+        throws InvalidKeyException {\n+        try {\n+            PBEKeySpec pks = new PBEKeySpec(password);\n+            SecretKeyFactory skf;\n+            PKCS8EncodedKeySpec keySpec;\n+            if (provider == null) {\n+                skf = SecretKeyFactory.getInstance(getAlgName());\n+                keySpec = getKeySpec(skf.generateSecret(pks));\n+            } else {\n+                skf = SecretKeyFactory.getInstance(getAlgName(), provider);\n+                keySpec = getKeySpec(skf.generateSecret(pks), provider);\n+            }\n+            return PKCS8Key.parseKey(keySpec.getEncoded());\n+        } catch (GeneralSecurityException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n@@ -312,4 +469,3 @@\n-     * @exception NullPointerException if {@code decryptKey}\n-     * is {@code null}.\n-     * @exception NoSuchAlgorithmException if cannot find appropriate\n-     * cipher to decrypt the encrypted data.\n+     * @exception NullPointerException if {@code decryptKey} is {@code null}.\n+     * @exception NoSuchAlgorithmException Cannot find appropriate cipher to\n+     * decrypt.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":181,"deletions":25,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+        \/\/XXX Number will change when assigned\n+        @JEP(number=999, title=\"PEM API\", status=\"Preview\")\n+        PEM_API,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.io.IOException;\n@@ -220,1 +223,1 @@\n-            throws GeneralSecurityException {\n+        throws GeneralSecurityException {\n@@ -222,8 +225,15 @@\n-            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;\n-            return new ECPublicKeyImpl(x509Spec.getEncoded());\n-        } else if (keySpec instanceof ECPublicKeySpec) {\n-            ECPublicKeySpec ecSpec = (ECPublicKeySpec)keySpec;\n-            return new ECPublicKeyImpl(\n-                ecSpec.getW(),\n-                ecSpec.getParams()\n-            );\n+            return new ECPublicKeyImpl(((X509EncodedKeySpec)keySpec).getEncoded());\n+\n+        } else if (keySpec instanceof ECPublicKeySpec ecSpec) {\n+            return new ECPublicKeyImpl(ecSpec.getW(), ecSpec.getParams());\n+\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key;\n+            try {\n+                p8key = new ECPrivateKeyImpl(\n+                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            } catch (Exception e) {\n+                throw new GeneralSecurityException(e);\n+            }\n+            return new ECPublicKeyImpl(p8key.getPubKeyEncoded());\n+\n@@ -240,2 +250,1 @@\n-            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;\n-            byte[] encoded = pkcsSpec.getEncoded();\n+            byte[] encoded = ((PKCS8EncodedKeySpec) keySpec).getEncoded();\n@@ -247,2 +256,2 @@\n-        } else if (keySpec instanceof ECPrivateKeySpec) {\n-            ECPrivateKeySpec ecSpec = (ECPrivateKeySpec)keySpec;\n+\n+        } else if (keySpec instanceof ECPrivateKeySpec ecSpec) {\n@@ -250,0 +259,1 @@\n+\n@@ -251,2 +261,3 @@\n-            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \"\n-                + \"and PKCS8EncodedKeySpec supported for EC private keys\");\n+            throw new InvalidKeySpecException(\"Only ECPrivateKeySpec \" +\n+                \"and PKCS8EncodedKeySpec supported for EC private keys. \" +\n+                keySpec.getClass().getName() + \" provided.\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":27,"deletions":16,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -136,1 +136,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -156,1 +156,1 @@\n-    private byte[] getArrayS0() {\n+    public byte[] getArrayS() {\n@@ -160,5 +160,1 @@\n-        return arrayS;\n-    }\n-\n-    public byte[] getArrayS() {\n-        return getArrayS0().clone();\n+        return arrayS.clone();\n@@ -173,0 +169,1 @@\n+        \/\/ Parse private key material from PKCS8Key.decode()\n@@ -174,1 +171,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n@@ -197,0 +194,2 @@\n+\n+            \/\/ Validate parameters stored from PKCS8Key.decode()\n@@ -208,1 +207,0 @@\n-    @Override\n@@ -213,1 +211,1 @@\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS0());\n+        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,4 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.io.IOException;\n+import java.security.*;\n@@ -163,0 +161,8 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key = (PKCS8Key) XDHPrivateKeyImpl.parseKey((\n+                    (PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            XDHPublicKeyImpl result =\n+                new XDHPublicKeyImpl(p8key.getPubKeyEncoded());\n+            checkLockedParams(InvalidKeySpecException::new,\n+                result.getParams());\n+            return result;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            this.key = val.toByteArray();\n+            this.privKeyMaterial = val.toByteArray();\n@@ -70,1 +70,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -105,1 +105,0 @@\n-    @Override\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHPrivateKeyImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,3 @@\n-import java.security.KeyFactorySpi;\n-import java.security.Key;\n-import java.security.PublicKey;\n-import java.security.PrivateKey;\n-import java.security.InvalidKeyException;\n-import java.security.ProviderException;\n+import sun.security.pkcs.PKCS8Key;\n+\n+import java.security.*;\n@@ -156,0 +153,9 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key = null;\n+            try {\n+                p8key = new EdDSAPrivateKeyImpl(\n+                    ((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            } catch (Exception e) {\n+                throw new InvalidKeyException(e);\n+            }\n+            return new EdDSAPublicKeyImpl(p8key.getPubKeyEncoded());\n@@ -157,2 +163,2 @@\n-            throw new InvalidKeySpecException(\n-                \"Only X509EncodedKeySpec and EdECPublicKeySpec are supported\");\n+            throw new InvalidKeySpecException(keySpec.getClass().getName() +\n+                \"not supported\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-            this.key = val.toByteArray();\n+            privKeyMaterial = val.toByteArray();\n@@ -74,1 +74,1 @@\n-            DerInputStream derStream = new DerInputStream(key);\n+            DerInputStream derStream = new DerInputStream(privKeyMaterial);\n@@ -84,2 +84,2 @@\n-        if (params.getKeyLength() != this.h.length) {\n-            throw new InvalidKeyException(\"key length is \" + this.h.length +\n+        if (params.getKeyLength() != h.length) {\n+            throw new InvalidKeyException(\"key length is \" + h.length +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAPrivateKeyImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,8 @@\n-import java.io.*;\n-import java.security.Key;\n-import java.security.KeyRep;\n-import java.security.PrivateKey;\n-import java.security.KeyFactory;\n-import java.security.MessageDigest;\n-import java.security.InvalidKeyException;\n-import java.security.NoSuchAlgorithmException;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+import sun.security.x509.X509Key;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.security.*;\n@@ -39,4 +39,1 @@\n-\n-import jdk.internal.access.SharedSecrets;\n-import sun.security.x509.*;\n-import sun.security.util.*;\n+import java.util.Optional;\n@@ -46,1 +43,1 @@\n- *\n+ * <p>\n@@ -58,1 +55,1 @@\n- *\n+ * <p>\n@@ -71,1 +68,1 @@\n-    protected byte[] key;\n+    protected byte[] privKeyMaterial;\n@@ -76,0 +73,3 @@\n+    \/* The encoded x509 public key for v2 *\/\n+    protected byte[] pubKeyEncoded = null;\n+\n@@ -79,0 +79,2 @@\n+    private byte[] attributes;\n+    private int version;\n@@ -83,1 +85,1 @@\n-     * {@link #algid} and {@link #key}.\n+     * {@link #algid} and {@link #privKeyMaterial}.\n@@ -94,1 +96,1 @@\n-    protected PKCS8Key(byte[] input) throws InvalidKeyException {\n+    public PKCS8Key(byte[] input) throws InvalidKeyException {\n@@ -102,0 +104,16 @@\n+    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+        throws InvalidKeyException {\n+        this(privEncoding);\n+        pubKeyEncoded = pubEncoding;\n+        version = V2;\n+    }\n+\n+    public int getVersion() {\n+        return version;\n+    }\n+\n+    \/**\n+     * Method for decoding PKCS8 v1 and v2 formats. Decoded values are stored\n+     * in this class, key material remains in DER format for algorithm\n+     * subclasses to decode.\n+     *\/\n@@ -108,1 +126,2 @@\n-            int version = val.data.getInteger();\n+            \/\/ Support check for V1, aka 0, and V2, aka 1.\n+            version = val.data.getInteger();\n@@ -112,2 +131,2 @@\n-            algid = AlgorithmId.parse (val.data.getDerValue ());\n-            key = val.data.getOctetString();\n+            \/\/ Parse and store AlgorithmID\n+            algid = AlgorithmId.parse(val.data.getDerValue());\n@@ -115,1 +134,4 @@\n-            DerValue next;\n+            \/\/ Store key material for subclasses to parse\n+            privKeyMaterial = val.data.getOctetString();\n+\n+            \/\/ PKCS8 v1 typically ends here\n@@ -119,2 +141,7 @@\n-            next = val.data.getDerValue();\n-            if (next.isContextSpecific((byte)0)) {\n+\n+            \/\/ OPTIONAL Context tag 0 for Attributes for PKCS8 v1 & v2\n+            \/\/ Uses 0xA0 constructed define-length or 0x80 constructed\n+            \/\/ indefinite.\n+            DerValue v = val.data.getDerValue();\n+            if (v.isContextSpecific((byte)0)) {\n+                attributes = v.getDataBytes();  \/\/ Save DER sequence\n@@ -124,1 +151,1 @@\n-                next = val.data.getDerValue();\n+                v = val.data.getDerValue();\n@@ -127,3 +154,8 @@\n-            if (next.isContextSpecific((byte)1)) {\n-                if (version == V1) {\n-                    throw new InvalidKeyException(\"publicKey seen in v1\");\n+            \/\/ OPTIONAL context tag 1 for Public Key for PKCS8 v2 only\n+            if (version == V2) {\n+                if (v.isContextSpecific((byte)1)) {\n+                    DerValue bits = v.withTag(DerValue.tag_BitString);\n+                    pubKeyEncoded = new X509Key(algid,\n+                        bits.getUnalignedBitString()).getEncoded();\n+                } else {\n+                    throw new InvalidKeyException(\"Invalid context tag\");\n@@ -135,0 +167,1 @@\n+\n@@ -159,1 +192,2 @@\n-    public static PrivateKey parseKey(byte[] encoded) throws IOException {\n+    public static PrivateKey parseKey(byte[] encoded)\n+        throws InvalidKeyException {\n@@ -162,2 +196,3 @@\n-            byte[] internal = rawKey.getEncodedInternal();\n-            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(internal);\n+            byte[] internal = rawKey.generateEncoding();\n+            PKCS8EncodedKeySpec pkcs8KeySpec =\n+                new PKCS8EncodedKeySpec(internal);\n@@ -179,2 +214,2 @@\n-        } catch (InvalidKeyException e) {\n-            throw new IOException(\"corrupt private key\", e);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(e);\n@@ -191,0 +226,12 @@\n+    public byte[] getPubKeyEncoded() {\n+        return pubKeyEncoded;\n+    }\n+\n+    public byte[] getPrivKeyMaterial() {\n+        return privKeyMaterial;\n+    }\n+\n+    public boolean hasPublicKey() {\n+        return (pubKeyEncoded == null ? false : true);\n+    }\n+\n@@ -194,1 +241,1 @@\n-    public AlgorithmId  getAlgorithmId () {\n+    public AlgorithmId getAlgorithmId () {\n@@ -213,0 +260,20 @@\n+    \/**\n+     * With a given encoded Public and Private key, generate and return a\n+     * PKCS8v2 DER-encoded byte[].\n+     *\n+     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param privKeyEncoded DER-encoded PrivateKey\n+     * @return DER-encoded byte array\n+     * @throws IOException thrown on encoding failure\n+     *\/\n+    public static byte[] getEncoded(byte[] pubKeyEncoded, byte[] privKeyEncoded)\n+        throws IOException {\n+        PKCS8Key privKey;\n+        try {\n+            privKey = new PKCS8Key(privKeyEncoded, pubKeyEncoded);\n+        } catch (InvalidKeyException e) {\n+            throw new IOException(e);\n+        }\n+        return privKey.generateEncoding();\n+    }\n+\n@@ -221,7 +288,6 @@\n-            DerOutputStream tmp = new DerOutputStream();\n-            tmp.putInteger(V1);\n-            algid.encode(tmp);\n-            tmp.putOctetString(key);\n-            DerValue out = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-            encodedKey = out.toByteArray();\n-            out.clear();\n+            try {\n+                encodedKey = generateEncoding();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+                \/\/ encodedKey is still null\n+            }\n@@ -232,0 +298,29 @@\n+    private byte[] generateEncoding() throws IOException {\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger((pubKeyEncoded == null) ? 0 : 1);\n+        algid.encode(out);\n+        out.putOctetString(privKeyMaterial);\n+\n+        if (attributes != null) {\n+            out.writeImplicit(\n+                DerValue.createTag((byte) (DerValue.TAG_CONTEXT |\n+                    DerValue.TAG_CONSTRUCT), false, (byte) 0),\n+                new DerOutputStream().putOctetString(attributes));\n+\n+        }\n+\n+        if (pubKeyEncoded != null) {\n+            X509Key x = (X509Key) X509Key.parseKey(pubKeyEncoded);\n+            DerOutputStream pubOut = new DerOutputStream();\n+            pubOut.putUnalignedBitString(x.getKey());\n+            out.writeImplicit(\n+                DerValue.createTag(DerValue.TAG_CONTEXT, false, (byte) 1),\n+                pubOut);\n+        }\n+\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n+        encodedKey = val.toByteArray();\n+        val.clear();\n+        return encodedKey;\n+    }\n+\n@@ -301,1 +396,1 @@\n-        Arrays.fill(key, (byte)0);\n+        Arrays.fill(privKeyMaterial, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":137,"deletions":42,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -84,1 +84,1 @@\n-            DerInputStream in = new DerInputStream(key);\n+            DerInputStream in = new DerInputStream(privKeyMaterial);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DSAPrivateKey.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -303,2 +303,2 @@\n-        } catch (IOException ioe) {\n-            throw new UnrecoverableKeyException(ioe.getMessage());\n+        } catch (InvalidKeyException e) {\n+            throw new UnrecoverableKeyException(e.getMessage());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/KeyProtector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import sun.security.util.PEMRecord;\n+import sun.security.util.Pem;\n@@ -559,11 +561,3 @@\n-            \/\/ Read BASE64 encoded data, might skip info at the beginning\n-            ByteArrayOutputStream data = new ByteArrayOutputStream();\n-\n-            \/\/ Step 1: Read until header is found\n-            int hyphen = (c=='-') ? 1: 0;   \/\/ count of consequent hyphens\n-            int last = (c=='-') ? -1: c;    \/\/ the char before hyphen\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    \/\/ We accept useless data after the last block,\n-                    \/\/ say, empty lines.\n+            try {\n+                PEMRecord pem = Pem.readPEM(is, (c == '-' ? true : false));\n+                if (pem == null) {\n@@ -572,75 +566,1 @@\n-                if (next == '-') {\n-                    hyphen++;\n-                } else {\n-                    hyphen = 0;\n-                    last = next;\n-                }\n-                if (hyphen == 5 && (last == -1 || last == '\\r' || last == '\\n')) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 2: Read the rest of header, determine the line end\n-            int end;\n-            StringBuilder header = new StringBuilder(\"-----\");\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next == '\\n') {\n-                    end = '\\n';\n-                    break;\n-                }\n-                if (next == '\\r') {\n-                    next = is.read();\n-                    if (next == -1) {\n-                        throw new IOException(\"Incomplete data\");\n-                    }\n-                    if (next == '\\n') {\n-                        end = '\\n';\n-                    } else {\n-                        end = '\\r';\n-                        \/\/ Skip all white space chars\n-                        if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                            data.write(next);\n-                        }\n-                    }\n-                    break;\n-                }\n-                header.append((char)next);\n-            }\n-\n-            \/\/ Step 3: Read the data\n-            while (true) {\n-                int next = is.read();\n-                if (next == -1) {\n-                    throw new IOException(\"Incomplete data\");\n-                }\n-                if (next != '-') {\n-                    \/\/ Skip all white space chars\n-                    if (next != 9 && next != 10 && next != 13 && next != 32) {\n-                        data.write(next);\n-                    }\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ Step 4: Consume the footer\n-            StringBuilder footer = new StringBuilder(\"-\");\n-            while (true) {\n-                int next = is.read();\n-                \/\/ Add next == '\\n' for maximum safety, in case endline\n-                \/\/ is not consistent.\n-                if (next == -1 || next == end || next == '\\n') {\n-                    break;\n-                }\n-                if (next != '\\r') footer.append((char)next);\n-            }\n-\n-            checkHeaderFooter(header.toString().stripTrailing(),\n-                    footer.toString().stripTrailing());\n-\n-            try {\n-                return Base64.getDecoder().decode(data.toByteArray());\n+                return Base64.getDecoder().decode(pem.pem());\n@@ -653,18 +573,0 @@\n-    private static void checkHeaderFooter(String header,\n-            String footer) throws IOException {\n-        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n-                !header.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal header: \" + header);\n-        }\n-        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n-                !footer.endsWith(\"-----\")) {\n-            throw new IOException(\"Illegal footer: \" + footer);\n-        }\n-        String headerType = header.substring(11, header.length()-5);\n-        String footerType = footer.substring(9, footer.length()-5);\n-        if (!headerType.equals(footerType)) {\n-            throw new IOException(\"Header and footer do not match: \" +\n-                    header + \" \" + footer);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":7,"deletions":105,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -336,0 +337,9 @@\n+        } else if (keySpec instanceof PKCS8EncodedKeySpec) {\n+            PKCS8Key p8key;\n+            try {\n+                p8key = new PKCS8Key(((PKCS8EncodedKeySpec)keySpec).getEncoded());\n+            } catch (Exception e) {\n+                throw new GeneralSecurityException(e);\n+            }\n+            return RSAPublicKeyImpl.newKey(type, \"X.509\",\n+                p8key.getPubKeyEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+    \/\/ RSA or RSS-PSS KeyType\n@@ -104,1 +105,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -240,1 +241,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n@@ -307,1 +308,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -340,1 +341,1 @@\n-            BigInteger[] comps = parseASN1(key);\n+            BigInteger[] comps = parsePKCS1(privKeyMaterial);\n@@ -354,0 +355,25 @@\n+    \/**\n+     * With a given PKCS#1\/slleay\/OpenSSL old default RSA binary encoding,\n+     * decode and return the proper RSA encoded KeySpec\n+     * @param encoded RSA binary encoding\n+     * @return KeySpec\n+     * @throws InvalidKeyException on decoding failure\n+     *\/\n+\n+    public static KeySpec getKeySpec(byte[] encoded) throws\n+        InvalidKeyException {\n+        try {\n+            BigInteger[] comps = parsePKCS1(encoded);\n+            if ((comps[1].signum() == 0) || (comps[3].signum() == 0) ||\n+                (comps[4].signum() == 0) || (comps[5].signum() == 0) ||\n+                (comps[6].signum() == 0) || (comps[7].signum() == 0)) {\n+                return new RSAPrivateKeySpec(comps[0], comps[2]);\n+            } else {\n+                return new RSAPrivateCrtKeySpec(comps[0],\n+                    comps[1], comps[2], comps[3], comps[4], comps[5],\n+                    comps[6], comps[7]);\n+            }\n+        } catch (IOException ioe) {\n+            throw new InvalidKeyException(\"Invalid PKCS#1 encoding\", ioe);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateCrtKeyImpl.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-        key = val.toByteArray();\n+        privKeyMaterial = val.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPrivateKeyImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-                BigInteger[] comps = parseASN1(encoded);\n+                BigInteger[] comps = parsePKCS1(encoded);\n@@ -202,1 +202,1 @@\n-    private static BigInteger[] parseASN1(byte[] raw) throws IOException {\n+    private static BigInteger[] parsePKCS1(byte[] raw) throws IOException {\n@@ -221,1 +221,1 @@\n-            BigInteger[] comps = parseASN1(getKey().toByteArray());\n+            BigInteger[] comps = parsePKCS1(getKey().toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPublicKeyImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    public static final byte TAG_CONSTRUCT = (byte)0x020;\n@@ -194,1 +195,1 @@\n-     * Returns true iff the CONTEXT SPECIFIC bit is set in the type tag.\n+     * Returns true if the CONTEXT SPECIFIC bit is set in the type tag.\n@@ -200,1 +201,1 @@\n-     * Returns true iff the CONTEXT SPECIFIC TAG matches the passed tag.\n+     * Returns true if the CONTEXT SPECIFIC TAG matches the passed tag.\n@@ -211,1 +212,1 @@\n-    \/** Returns true iff the CONSTRUCTED bit is set in the type tag. *\/\n+    \/** Returns true if the CONSTRUCTED bit is set in the type tag. *\/\n@@ -215,1 +216,1 @@\n-     * Returns true iff the CONSTRUCTED TAG matches the passed tag.\n+     * Returns true if the CONSTRUCTED TAG matches the passed tag.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerValue.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -448,0 +449,50 @@\n+\n+    \/**\n+     * With a given DER encoded bytes, read through and return the AlgorithmID\n+     * stored if it can be found.\n+     *\n+     * @param encoded DER encoded bytes\n+     * @return AlgorithmID stored in the DER encoded bytes\n+     * @throws IOException\n+     *\/\n+    public static AlgorithmId getAlgorithm(byte[] encoded) throws IOException {\n+        DerInputStream is = new DerInputStream(encoded);\n+        DerValue value = is.getDerValue();\n+        if (value.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"Unknown DER Format:  Value 1 not a Sequence\");\n+        }\n+\n+        is = value.data;\n+        value = is.getDerValue();\n+        \/\/ This route is for:  RSAPublic, Encrypted RSAPrivate, EC Public,\n+        \/\/ Encrypted EC Private,\n+        if (value.tag == DerValue.tag_Sequence) {\n+            return AlgorithmId.parse(value);\n+        } else if (value.tag == DerValue.tag_Integer) {\n+            \/\/ RSAPrivate, ECPrivate\n+            \/\/ current value is version, which can be ignored\n+            value = is.getDerValue();\n+            if (value.tag == DerValue.tag_OctetString) {\n+                value = is.getDerValue();\n+                if (value.tag == DerValue.tag_Sequence) {\n+                    return AlgorithmId.parse(value);\n+                } else {\n+                    \/\/ OpenSSL\/X9.62 (0xA0)\n+                    ObjectIdentifier oid = value.data.getOID();\n+                    AlgorithmId algo = new AlgorithmId(oid, (AlgorithmParameters) null);\n+                    if (CurveDB.lookup(algo.getName()) != null) {\n+                        return new AlgorithmId(AlgorithmId.EC_oid);\n+                    }\n+\n+                }\n+\n+            } else if (value.tag == DerValue.tag_Sequence) {\n+                \/\/ Public Key\n+                return AlgorithmId.parse(value);\n+            }\n+\n+        }\n+        throw new IOException(\"No algorithm detected\");\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * A Record for PEM\n+ *\n+ * @param id      The PEM header and footer value that identifies the data.\n+ * @param pem     The Base64 encoded data only in byte[] format\n+ *\/\n+public record PEMRecord(String id, String pem) {\n+\n+    public static final String PUBLIC_KEY = \"PUBLIC KEY\";\n+    public static final String ENCRYPTED_PRIVATE_KEY = \"ENCRYPTED PRIVATE KEY\";\n+    public static final String PRIVATE_KEY = \"PRIVATE KEY\";\n+    public static final String RSA_PRIVATE_KEY = \"RSA PRIVATE KEY\";\n+    public static final String CERTIFICATE = \"CERTIFICATE\";\n+    public static final String X509_CERTIFICATE = \"X509 CERTIFICATE\";\n+    public static final String X509_CRL = \"X509 CRL\";\n+\n+    \/**\n+     * Get an instance of a PEMRecord.\n+     *\n+     * @param id  The PEM header and footer value that identifies the data.\n+     * @param pem The Base64 encoded data only in byte[] format\n+     *\/\n+    public PEMRecord(String id, byte[] pem) {\n+        this(id, new String(pem, StandardCharsets.ISO_8859_1));\n+    }\n+\n+    \/**\n+     * Instantiates a new Pem record.\n+     *\n+     * @param id      The PEM header and footer value that identifies the data.\n+     * @param pem     The Base64 encoded data only in byte[] format\n+     *\/\n+    public PEMRecord(String id, String pem) {\n+        if (id.startsWith(\"-----\")) {\n+            \/\/ decode id in the\n+            this.id = id.substring(11, id.lastIndexOf('-') - 4);\n+        } else {\n+            this.id = id;\n+        }\n+\n+        this.pem = pem;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PEMRecord.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import java.io.IOException;\n+import sun.security.x509.AlgorithmId;\n+\n+import java.io.*;\n@@ -30,0 +32,4 @@\n+import java.security.AccessController;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivilegedAction;\n+import java.security.Security;\n@@ -31,0 +37,4 @@\n+import java.util.HexFormat;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -36,0 +46,19 @@\n+    private static final char WS = 0x20;  \/\/ Whitespace\n+\n+    \/\/ Default algorithm from jdk.epkcs8.defaultAlgorithm in java.security\n+    public static final String DEFAULT_ALGO;\n+\n+    \/\/ Pattern matching for EKPI operations\n+    private static final Pattern pbePattern;\n+\n+    \/\/ Lazy initialized PBES2 OID value\n+    private static ObjectIdentifier PBES2OID;\n+\n+    static {\n+        @SuppressWarnings(\"removal\")\n+        String d = AccessController.doPrivileged(\n+            (PrivilegedAction<String>) () ->\n+                Security.getProperty(\"jdk.epkcs8.defaultAlgorithm\"));\n+        DEFAULT_ALGO = d;\n+        pbePattern = Pattern.compile(\"^PBEWith.*And.*\");\n+    }\n@@ -43,1 +72,0 @@\n-     * @throws java.io.IOException if input is invalid\n@@ -45,4 +73,3 @@\n-    public static byte[] decode(String input) throws IOException {\n-        byte[] src = input.replaceAll(\"\\\\s+\", \"\")\n-                .getBytes(StandardCharsets.ISO_8859_1);\n-        try {\n+    public static byte[] decode(String input) {\n+        byte[] src = input.replaceAll(\"\\\\s+\", \"\").\n+            getBytes(StandardCharsets.ISO_8859_1);\n@@ -50,2 +77,181 @@\n-        } catch (IllegalArgumentException e) {\n-            throw new IOException(e);\n+    }\n+\n+    \/**\n+     * Return the OID for a given PBE algorithm.  PBES1 has an OID for each\n+     * algorithm, while PBES2 has one OID for everything that complies with\n+     * the formatting.  Therefore, if the algorithm is not PBES1, it will\n+     * return PBES2.  Cipher will determine if this is a valid PBE algorithm.\n+     * PBES2 specifies AES as the cipher algorithm, but any block cipher could\n+     * be supported.\n+     *\/\n+    public static ObjectIdentifier getPBEID(String algorithm) {\n+\n+        \/\/ Verify pattern matches PBE Standard Name spec\n+        if (!pbePattern.matcher(algorithm).matches()) {\n+            throw new IllegalArgumentException(\"Invalid algorithm format.\");\n+        }\n+\n+        \/\/ Return the PBES1 OID if it matches\n+        try {\n+            return AlgorithmId.get(algorithm).getOID();\n+        } catch (NoSuchAlgorithmException e) {\n+            \/\/ fall-through\n+        }\n+\n+        \/\/ Lazy initialize\n+        if (PBES2OID == null) {\n+            try {\n+                \/\/ Set to the hardcoded OID in KnownOID.java\n+                PBES2OID = AlgorithmId.get(\"PBES2\").getOID();\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ Should never fail.\n+                throw new IllegalArgumentException(e);\n+            }\n+        }\n+        return PBES2OID;\n+    }\n+\n+    \/**\n+     * Read the PEM text and return it in it's three components:  header,\n+     * base64, and footer.\n+     *\n+     * The method will leave the stream after reading the end of line of the\n+     * footer or end of file\n+     * @param is The pem data\n+     * @param shortHeader if true, the hyphen length is 4 because the first\n+     *                    hyphen is assumed to have been read.  This is needed\n+     *                    for the CertificateFactory X509 implementation.\n+     * @return A new Pem object containing the three components\n+     * @throws IOException on read errors\n+     *\/\n+    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n+        throws IOException {\n+        Objects.requireNonNull(is);\n+\n+        int hyphen = (shortHeader ? 1 : 0);\n+        int eol = 0;\n+\n+        \/\/ Find starting hyphens\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> {\n+                    return null;\n+                }\n+                default -> hyphen = 0;\n+            }\n+        } while (hyphen != 5);\n+\n+        StringBuilder sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+        hyphen = 0;\n+        int c;\n+\n+        \/\/ Get header definition until first hyphen\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                case '\\n', '\\r' -> throw new IllegalArgumentException(\n+                    \"Incomplete header\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify header ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                default ->\n+                    throw new IllegalArgumentException(\"Incomplete header\");\n+            }\n+        } while (hyphen < 5);\n+\n+        sb.append(\"-----\");\n+        String header = sb.toString();\n+        if (header.length() < 16 || !header.startsWith(\"-----BEGIN \") ||\n+            !header.endsWith(\"-----\")) {\n+            throw new IllegalArgumentException(\"Illegal header: \" + header);\n+        }\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(1024);\n+\n+        \/\/ Determine the line break using the char after the last hyphen\n+        switch (c = is.read()) {\n+            case WS -> {} \/\/ skip whitespace\n+            case '\\r' -> {\n+                c = is.read();\n+                if (c == '\\n') {\n+                    eol = '\\n';\n+                } else {\n+                    eol = '\\r';\n+                    sb.append((char) c);\n+                }\n+            }\n+            case '\\n' -> eol = '\\n';\n+            default ->\n+                throw new IllegalArgumentException(\"No EOL character found\");\n+        }\n+\n+        \/\/ Read data until we find the first footer hyphen.\n+        do {\n+            switch (c = is.read()) {\n+                case -1 ->\n+                    throw new IllegalArgumentException(\"Incomplete header\");\n+                case '-' -> hyphen++;\n+                case WS, '\\t', '\\n', '\\r' -> {} \/\/ skip whitespace, tab, etc\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        String data = sb.toString();\n+\n+        \/\/ Verify footer starts with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> throw new IllegalArgumentException(\n+                    \"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        hyphen = 0;\n+        sb = new StringBuilder(64);\n+        sb.append(\"-----\");\n+\n+        \/\/ Look for Complete header by looking for the end of the hyphens\n+        do {\n+            switch (c = is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> sb.append((char) c);\n+            }\n+        } while (hyphen == 0);\n+\n+        \/\/ Verify ending with 5 hyphens.\n+        do {\n+            switch (is.read()) {\n+                case '-' -> hyphen++;\n+                case -1 -> throw new IllegalArgumentException(\n+                    \"Input ended prematurely\");\n+                default -> throw new IllegalArgumentException(\n+                    \"Incomplete footer\");\n+            }\n+        } while (hyphen < 5);\n+\n+        while ((c = is.read()) != eol && c != -1 && c != '\\r' && c != WS) {\n+            throw new IllegalArgumentException(\"Invalid PEM format:  \" +\n+                \"No EOL char found in footer:  0x\" +\n+                HexFormat.of().toHexDigits((byte) c));\n+        }\n+\n+        sb.append(\"-----\");\n+        String footer = sb.toString();\n+        if (footer.length() < 14 || !footer.startsWith(\"-----END \") ||\n+            !footer.endsWith(\"-----\")) {\n+            throw new IOException(\"Illegal footer: \" + footer);\n@@ -53,0 +259,10 @@\n+\n+        \/\/ Verify the object type in the header and the footer are the same.\n+        String headerType = header.substring(11, header.length() - 5);\n+        String footerType = footer.substring(9, footer.length() - 5);\n+        if (!headerType.equals(footerType)) {\n+            throw new IOException(\"Header and footer do not match: \" +\n+                headerType + \" \" + footerType);\n+        }\n+\n+        return new PEMRecord(header, data);\n@@ -54,0 +270,5 @@\n+\n+    public static PEMRecord readPEM(InputStream is) throws IOException {\n+        return readPEM(is, false);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":230,"deletions":9,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -86,1 +85,2 @@\n-    private X509Key(AlgorithmId algid, BitArray key) {\n+    @SuppressWarnings(\"this-escape\")\n+    public X509Key(AlgorithmId algid, BitArray key) {\n@@ -103,1 +103,1 @@\n-    protected BitArray getKey() {\n+    public BitArray getKey() {\n@@ -157,1 +157,1 @@\n-        encode();\n+        getEncodedInternal();\n@@ -246,1 +246,1 @@\n-    public AlgorithmId  getAlgorithmId() { return algid; }\n+    public AlgorithmId getAlgorithmId() { return algid; }\n@@ -263,1 +263,1 @@\n-    public byte[] getEncodedInternal() {\n+    private byte[] getEncodedInternal() {\n@@ -317,1 +317,1 @@\n-    void decode(DerValue val) throws InvalidKeyException {\n+    public void decode(DerValue val) throws InvalidKeyException {\n@@ -341,0 +341,18 @@\n+    \/**\n+     * Parses X509 public key.  With PKCS8v2 allowing public keys in private key\n+     * encoding, this method allows PKCS8Key access, but keeps the code in this\n+     * file.\n+     *\/\n+    public static PublicKey parseKey(byte[] encoded) throws IOException {\n+        PublicKey pubKey;\n+        try {\n+            X509EncodedKeySpec spec = new X509EncodedKeySpec(encoded);\n+            pubKey = KeyFactory.getInstance(spec.getAlgorithm())\n+                .generatePublic(spec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            \/\/ Ignore and return raw key\n+            throw new IOException(\"error with encoding\");\n+        }\n+        return pubKey;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1538,0 +1538,8 @@\n+\n+#\n+# Default algorithm for PEMEncoder Encrypted PKCS#8\n+#\n+# This property defines default Public-based Encryption algorithm for\n+# java.security.PEMEncoder is configured for encryption with `withEncryption()`.\n+#\n+jdk.epkcs8.defaultAlgorithm=PBEWithHmacSHA256AndAES_128\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +127,1 @@\n-    public static class FakeX509Spec extends X509EncodedKeySpec {\n+    public static class FakeX509Spec extends EncodedKeySpec {\n@@ -134,0 +135,5 @@\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.security.DEREncodable;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Library class for PEMEncoderTest and PEMDecoderTest\n+ *\/\n+class PEMCerts {\n+    public static final Entry ecprivpem = new Entry(\"ecprivpem\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgkW3Jx561NlEgBnut\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqhRANCAASL+REY4vvAI9M3gonaml5K3lRgHq5w\n+        +OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fop224ANvB\n+        -----END PRIVATE KEY-----\n+        \"\"\", ECPrivateKey.class);\n+\n+    public static final Entry privpem = new Entry(\"privpem\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\n+        WqcWcoJqfdLEyBT+\n+        -----END PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    public static final Entry privpembc = new Entry(\"privpembc\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZb\n+        OdOvmvU3jl7+cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW\n+        3qGR2DuBEaMy0mkg8hfKcSpHLaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463\n+        OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAECgYEAwNkDkTv5rlX8nWLuLJV5kh\/T\n+        H9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692SdzR0dCSk7LGgN9q\n+        CYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\/kI+\n+        EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5ae\n+        KZQSkNAXG+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGP\n+        g6Wo1usF2bKqk8vjko9ioZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZa\n+        Jz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63\n+        Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL0lGPCiOLu9RcQp7L81aF\n+        79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57AkBh75t8\n+        6onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8Ob\n+        WqcWcoJqfdLEyBT+\n+        -----END PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    public static final Entry privec25519pem = new Entry(\"privpemed25519\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MC4CAQAwBQYDK2VwBCIEIFFZsmD+OKk67Cigc84\/2fWtlKsvXWLSoMJ0MHh4jI4I\n+        -----END PRIVATE KEY-----\n+        \"\"\", EdECPrivateKey.class);\n+\n+    public static final Entry pubrsapem = new Entry(\"pubrsapem\",\n+        \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\n+        XCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PUBLIC KEY-----\n+        \"\"\", RSAPublicKey.class);\n+\n+    public static final Entry pubrsapembc = new Entry(\"pubrsapembc\",\n+        \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\n+        \/nLzxYC+TH6gwjOWvMiNMiJoP4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGj\n+        MtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarbD6D4yRY1hWHluiuOtzhxuueCuf9h\n+        XCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PUBLIC KEY-----\n+        \"\"\", RSAPublicKey.class);\n+\n+    public static final Entry pubecpem = new Entry(\"pubecpem\", \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEi\/kRGOL7wCPTN4KJ2ppeSt5UYB6u\n+        cPjjuKDtFTXbguOIFDdZ65O\/8HTUqS\/sVzRF+dg7H3\/tkQ\/36KdtuADbwQ==\n+        -----END PUBLIC KEY-----\n+        \"\"\", ECPublicKey.class);\n+\n+    \/\/ EC key with explicit parameters -- Not currently supported by SunEC\n+    public static final String pubec_explicit = \"\"\"\n+        -----BEGIN PUBLIC KEY-----\n+        MIIBSzCCAQMGByqGSM49AgEwgfcCAQEwLAYHKoZIzj0BAQIhAP\/\/\/\/8AAAABAAAA\n+        AAAAAAAAAAAA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/MFsEIP\/\/\/\/8AAAABAAAAAAAAAAAAAAAA\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/8BCBaxjXYqjqT57PrvVV2mIa8ZR0GsMxTsPY7zjw+J9JgSwMVAMSd\n+        NgiG5wSTamZ44ROdJreBn36QBEEEaxfR8uEsQkf4vOblY6RA8ncDfYEt6zOg9KE5\n+        RdiYwpZP40Li\/hp\/m47n60p8D54WK84zV2sxXs7LtkBoN79R9QIhAP\/\/\/\/8AAAAA\n+        \/\/\/\/\/\/\/\/\/\/+85vqtpxeehPO5ysL8YyVRAgEBA0IABIv5ERji+8Aj0zeCidqaXkre\n+        VGAernD447ig7RU124LjiBQ3WeuTv\/B01Kkv7Fc0RfnYOx9\/7ZEP9+inbbgA28E=\n+        -----END PUBLIC KEY-----\n+        \"\"\";\n+\n+    public static final Entry oasbcpem = new Entry(\"oasbcpem\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIIDCAIBATANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAOtjMnCzPy4jCeZbOdOvmvU3jl7+\n+        cvPFgL5MfqDCM5a8yI0yImg\/hzibJJHLk3emUVBSnekgHvCqyGLW3qGR2DuBEaMy0mkg8hfKcSpH\n+        LaYjDYaspO27d2qtb6d1qtsPoPjJFjWFYeW6K463OHG654K5\/2FcJgQdlLVyp3zCiQU\/AgMBAAEC\n+        gYEAwNkDkTv5rlX8nWLuLJV5kh\/TH9a93SRZxw8qy5Bv7bZ7ZNrHP7uUkHbi7iPojKWRhwo43692\n+        SdzR0dCSk7LGgN9qCYvndsYR6gifVGBi0WF+St4+NdtcQ3VlNdsojy2BdIx0oC+r7i3bn+zc968O\n+        \/kI+EgdgrMcjjFqyx6tMHpECQQD8TYPKGHyN7Jdy28llCoUX\/sL\/yZ2vIi5mnDAFE5aeKZQSkNAX\n+        G+8i9Qbs\/Wdd5S3oZDqu+6DBn9gib80pYY05AkEA7tY59Oy8ka7nBlGPg6Wo1usF2bKqk8vjko9i\n+        oZQay7f86aB10QFcAjCr+cCUm16Lc9DwzWl02nNggRZaJz8eNwJBAO+1zfLjFOPa14F\/JHdlaVKE\n+        8EwKCFDuztsapd0M4Vtf8Zk6ERsDpU63Ml9T2zOwnM9g+whpdjDAZ59ATdJ1JrECQQDReJQ2SxeL\n+        0lGPCiOLu9RcQp7L81aF79G1bgp8WlAyEjlAkloiqEWRKiz7DDuKFR7Lwhognng9S+n87aS+PS57\n+        AkBh75t86onPAs4hkm+63dfzCojvEkALevO8J3OVX7YS5q9J1r75wDn60Ob0Zh+iiorpx8ObWqcW\n+        coJqfdLEyBT+gYGNADCBiQKBgQDrYzJwsz8uIwnmWznTr5r1N45e\/nLzxYC+TH6gwjOWvMiNMiJo\n+        P4c4mySRy5N3plFQUp3pIB7wqshi1t6hkdg7gRGjMtJpIPIXynEqRy2mIw2GrKTtu3dqrW+ndarb\n+        D6D4yRY1hWHluiuOtzhxuueCuf9hXCYEHZS1cqd8wokFPwIDAQAB\n+        -----END PRIVATE KEY-----\n+        \"\"\", DEREncodable.class);\n+\n+    public static final Entry oasrfc8410 = new Entry(\"oasrfc8410\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MHICAQEwBQYDK2VwBCIEINTuctv5E1hK1bbY8fdp+K06\/nwoy\/HU++CXqI9EdVhC\n+        oB8wHQYKKoZIhvcNAQkJFDEPDA1DdXJkbGUgQ2hhaXJzgSEAGb9ECWmEzf6FQbrB\n+        Z9w7lshQhqowtrbLDFw4rXAxZuE=\n+        -----END PRIVATE KEY-----\n+        \"\"\", DEREncodable.class);\n+\n+    public static final Entry rsaOpenSSL = new Entry(\"rsaOpenSSL\",\n+        \"\"\"\n+        -----BEGIN RSA PRIVATE KEY-----\n+        MIIEowIBAAKCAQEAqozTLan1qFcOCWnS63jXQn5lLyGOKDv3GM11n2zkGGrChayj\n+        cSzB2KTlDmN9NgOyFdqGNWbSgdmXR5ToHGHYwaKubJoQIoPQcsipWDI156d3+X\/8\n+        BxCGY8l5nYwvS4olOXc+2kEjeFF1eamnm9IQ5DHZfaFPl0ri4Yfm1YHBAbt\/7HvF\n+        3MBjgBj1xSsSFLW4O6ws6guRVGDfKBVyyRNUhRTbSua\/nEz0wAjxF2PWT+ZTHS6M\n+        0siYwVTuPI4\/n4ItoYoahvGb9JskkXP+bc\/QZJCTFYdyxF5tKqVMSdYaJTxop02p\n+        Jo3oeafVKSlBrr0K731xgNBKqBud44aKT5R96QIDAQABAoIBAQCD9Q\/T7gOvayPm\n+        LqXOISJURV1emRTXloX5\/8Y5QtQ8\/CVjrg6Lm3ikefjsKBgR+cwJUpmyqcrIQyXk\n+        cZchlqdSMt\/IEW\/YdKqMlStJnRfOE+ok9lx2ztdcT9+0AWn6hXmFu\/i6f9nE1yoQ\n+        py6SxnbhSJyhsnTVd1CR9Uep\/InsHvYW\/15WlVMD1VuCSIt9sefqXwavbAfBaqbn\n+        mjwBB\/ulsqKhHSuRq\/QWqlj+jyGqhhYmTguC1Qwt0woDbThiHtK+suCTAlGBj\/A+\n+        IZ1U9d+VsHBcWDKBkxmlKWcJAGR3xXiKKy9vfzC+DU7L99kgay80VZarDyXgiy78\n+        9xMMzRMBAoGBANoxnZhu1bUFtLqTJ1HfDm6UB+1zVd2Mu4DXYdy\/AHjoaCLp05OQ\n+        0ZeyhO\/eXPT+eGpzCxkWD7465KO\/QDfnp54p\/NS73jaJVdWQHBhzJx1MymqURy3N\n+        JQeW4+ojzwSmVXcrs7Og6EBa4L+PWLpMLW2kODniCY+vp9f5LS6m8UPJAoGBAMgZ\n+        4rBw7B9YFZZW\/EE4eos4Q7KtA5tEP6wvCq04oxfiSytWXifYX0ToPp0CHhZlWOxk\n+        v9a\/BDGqM7AxAQJs7mmIvT5AT2V1w7oTbFPnnAo6pQtLcfaxdFFqr0h6t0sXSOKC\n+        rQeZAqqFqwuOyP7vT0goGlBruHkwS21NKkzCyzkhAoGAc2JjhbWu+8Cdt0CUPX5o\n+        ol9T5eTlFnkSuuqrTNIQzN+SGkxu341o2QDFvhdoLwLW6OwXhVeeUanROSqtKiMu\n+        B70Kf\/EtbMephXtk8CUNHTh7nmr1TSo8F8xakHoJQts3PQL2T9qal1W3nnWOpU4d\n+        g+qg9TMsfTiV2OdjVlVgJskCgYBSnjV1qjojuue22hVvDFW0c7en5z2M9wHfItEi\n+        sjbMnrdwnklj5Dd5qPZpNz2a+59ag0Kd9OJTazXKMoF7MeTCGB4ivMTLXHNCudBJ\n+        WGCZ7JrGbhEQzTX8g7L5lwlk7KlANLoiX++03lm\/\/OVKNR6j6ULsH33cM6+A4pJr\n+        fSYRYQKBgCr9iMTmL0x+n6AmMNecR+MhDxi99Oy0s2EBAYqN9g\/8yNgwM4KR0cjz\n+        EcgIOtkvoTrJ9Cquvuj+O7\/d2yNoH0SZQ4IYJKq47\/Z4kKhwXzJnBCCCBKgkjfub\n+        RTQSNnSEgTaBD29l7FrhNRHX9lIKFZ23caCTBS6o3q3+KgPbq7ao\n+        -----END RSA PRIVATE KEY-----\n+        \"\"\", RSAPrivateKey.class);\n+\n+    private static final Entry encEdECKey = new Entry(\"encEdECKey\",\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\", EdECPrivateKey.class, \"fish\".toCharArray());\n+\n+    \/\/ This is not meant to be decrypted and to stay as an EKPI\n+    private static final Entry encEdECKeyEKPI = new Entry(\"encEdECKeyEPKI\",\n+        encEdECKey.pem(), EncryptedPrivateKeyInfo.class, null);\n+\n+    private static final Entry rsaCert = new Entry(\"rsaCert\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIErDCCApQCCQD7ndjWbI\/x0DANBgkqhkiG9w0BAQsFADAXMRUwEwYDVQQDDAxQ\n+        RU0gVGVzdCBSU0EwIBcNMjQwMTA5MjMzNDIwWhgPMjA1MTA1MjYyMzM0MjBaMBcx\n+        FTATBgNVBAMMDFBFTSBUZXN0IFJTQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCC\n+        AgoCggIBAKgO\/Pciro8xn5iNjcVCR4IuXP+V1PNATtKAlMbWzwGVOupKgRcNeRbA\n+        N9RlljxSgEChIWs0\/DB9VsAw1wCIVeuIVxv0ZvhVAcuD8Yyl58eev1rptsSJhTkN\n+        YJFxEPSP2kfWDxS21ltbg1bnY\/c1SQbzWawDLJN16G+ICzQXo68UB5fCZV9Ugfgf\n+        9USPkCiC6aFt+RT7eQaN\/JrjtCm+mFf4VbK7jYW7D8AfjviEY1HQCnPoTjHBxdy+\n+        o5s4aIOx1Wuu9wMoGuLXgY3do5\/OSDCfByk7rc1drQB9GOKf2gkR8PL9TjK+R3Lq\n+        wCA0a3jlCBiGPlH3oeZJrnp7jhAh\/tVxbsd7yIdhQnasbiTfhew132AdPXoQE+ic\n+        PFoh8MMtG1bdzt8EbvePC3GOjeyIP6f2Ixrh3B6wXzzYmJqBwON+X8TLQolcI1pa\n+        Q7AUz5BScy3lO9nyJE\/FJkX+Mr6n7WCdudCrQNP+0M845UvkgFyf4FcM7uUVugBm\n+        AXy7sCqZgTeLdqHyTElMCoWzBa3MHKyiSCh8GUJH+I1yBY1gG95j3tITIOFvbZrk\n+        vDiMwNtV9T6Ta2mb0+38GfKjbI6PF4DVrzB6xc7Q6\/GwyhOb86YLOLlEHJfhuc+C\n+        Pdy8hQrrulm2jiCO\/skvHucABNJ2CENyWa7ljNJkcN6GNTziz4AhAgMBAAEwDQYJ\n+        KoZIhvcNAQELBQADggIBAKFQE2AgYgc7\/xzwveUAiZ55tfcds07UnazLCOdpz+JJ\n+        W4MOt\/1Qi9mUylqDEymfNZVLPd2dEjB4wJ57XBUjL+kXkH1SocuskxQPf05iz5zT\n+        pEwg2fTmU73ilKMs5Q113nBnL9ZZtlRKCh1Oc5LvLW799uVXnU4UdSpWOBU9ePGY\n+        +H1wUKf+e0\/BkveQsZERYcamH9O9U\/+h+bbhr3GpT1AVnuDRyF28OvRwARDCOVyy\n+        ifh+xCR3WCnNcgfwCoH6cE1aXDKHchlAAZtvjc1lLud7\/ECIg+15keVfTYk4HEbH\n+        j\/lprxyH7y99lMmRLQpnTve54RrZGGmg51UD7OmwPHLMGibfQkw6QgdNsggIYD6p\n+        L91spgRRB+i4PTovocndOMR2RYgQEelGNqv8MsoUC7oRNxPCHxIEGuUPH1Vf3jnk\n+        mTHbVzpjy57UtfcYp1uBFDf8WoWO1Mi6oXRw2YQA1YSMm1+3ftphxydcbRuBlS7O\n+        6Iiqk6XlFG9Dpd2jjAQQzJGtnC0QDgGz6\/KGp1bGEhRnOWju07eLWvPbyaX5zeSh\n+        8gOYV33zkPhziWJt4uFMFIi7N2DLEk5UVZv1KTLZlfPl55DRs7j\/Sb4vKHpB17AO\n+        meVknxVvifDVY0TIz57t28Accsk6ClBCxNPluPU\/8YLGAZJYsdDXjGcndQ13s5G7\n+        -----END CERTIFICATE-----\n+        \"\"\", X509Certificate.class);\n+\n+    private static final Entry ecCert = new Entry(\"ecCert\",\n+        \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIIBFzCBvgIJAOGVk\/ky59ojMAoGCCqGSM49BAMCMBMxETAPBgNVBAMMCFBFTSB0\n+        ZXN0MCAXDTI0MDEwOTIzMzEwNloYDzIwNTEwNTI2MjMzMTA2WjATMREwDwYDVQQD\n+        DAhQRU0gdGVzdDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABGYI0jD7JZzw4RYD\n+        y9DCfaYNz0CHrpr9gJU5NXe6czvuNBdAOl\/lJGQ1pqpEQSQaMDII68obvQyQQyFY\n+        lU3G9QAwCgYIKoZIzj0EAwIDSAAwRQIgMwYld7aBzkcRt9mn27YOed5+n0xN1y8Q\n+        VEcFjLI\/tBYCIQDU3szDZ\/PK2mUZwtgQxLqHdh+f1JY0UwQS6M8QUvoDHw==\n+        -----END CERTIFICATE-----\n+        \"\"\", X509Certificate.class);\n+\n+    \/\/ EC cert with explicit parameters -- Not currently supported by SunEC\n+    private static final String ecCertEX = \"\"\"\n+        -----BEGIN CERTIFICATE-----\n+        MIICrDCCAjMCCQDKAlI7uc1CVDAKBggqhkjOPQQDAjATMREwDwYDVQQDDAhQRU0g\n+        dGVzdDAgFw0yNDAxMDkyMzIxNTlaGA8yMDUxMDUyNjIzMjE1OVowEzERMA8GA1UE\n+        AwwIUEVNIHRlc3QwggHMMIIBZAYHKoZIzj0CATCCAVcCAQEwPAYHKoZIzj0BAQIx\n+        AP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/+\/\/\/\/\/wAAAAAAAAAA\/\/\/\/\n+        \/zB7BDD\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/v\/\/\/\/8AAAAAAAAA\n+        AP\/\/\/\/wEMLMxL6fiPufkmI4Fa+P4LRkYHZxu\/oFBEgMUCI9QE4daxlY5jYou0Z0q\n+        hcjt0+wq7wMVAKM1kmqjGaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCt\n+        dG4dO2KLp5uYWfdB4IJUKjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi\/kpLc\n+        Kfj0Hb0omhR86doxE7XwuMAKYLHOHX6BnXpDHXyQ6g5fAjEA\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/x2NNgfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBA2IABO+IbTh6\n+        WqyzmxdCeJ0uUQ2v2jKxRuCKRyPlYAnpBmmQypsRS+GBdbBa0Mu6MTnVJh5uvqXn\n+        q7IuHVEiE3EFKw0DNW30nINuQg6lTv6PgN\/4nYBqsl5FQgzk2SYN3bw+7jAKBggq\n+        hkjOPQQDAgNnADBkAjATCnbbn3CgPRPi9Nym0hKpBAXc30D4eVB3mz8snK0oKU0+\n+        VP3F0EWcyM2QDSZCXIgCMHWknAhIGFTHxqypYUV8eAd3SY7ujZ6EPR0uG\/\/csBWG\n+        IqHcgr8slqi35ycQn5yMsQ==\n+        -----END CERTIFICATE-----\n+        \"\"\";\n+\n+    public record Entry(String name, String pem, Class clazz, char[] password) {\n+\n+        Entry(String name, String pem, Class clazz) {\n+            this(name, pem, clazz, null);\n+\n+        }\n+\n+        public Entry newClass(String name, Class c) {\n+            return new Entry(name, pem, c, password);\n+        }\n+\n+        public Entry newClass(Class c) {\n+            return newClass(name, c);\n+        }\n+\n+        Entry makeCRLF(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\\r\\n\"),\n+                clazz, password());\n+        }\n+\n+        Entry makeCR(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\\r\"),\n+                clazz, password());\n+        }\n+\n+        Entry makeNoCRLF(String name) {\n+            return new Entry(name,\n+                Pattern.compile(System.lineSeparator()).matcher(pem).replaceAll(\"\"),\n+                clazz, password());\n+        }\n+    }\n+\n+    static public Entry getEntry(String varname) {\n+        return getEntry(passList, varname);\n+    }\n+\n+    static public Entry getEntry(List<Entry> list, String varname) {\n+        for (Entry entry : list) {\n+            if (entry.name.compareToIgnoreCase(varname) == 0) {\n+                return entry;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static List<Entry> passList = new ArrayList<>();\n+    static List<Entry> entryList = new ArrayList<>();\n+    static List<Entry> pubList = new ArrayList<>();\n+    static List<Entry> privList = new ArrayList<>();\n+    static List<Entry> oasList = new ArrayList<>();\n+    static List<Entry> certList = new ArrayList<>();\n+    static List<Entry> encryptedList = new ArrayList<>();\n+    static List<Entry> failureEntryList = new ArrayList<>();\n+\n+    static {\n+        pubList.add(pubrsapem);\n+        pubList.add(pubrsapembc);\n+        pubList.add(pubecpem.makeCR(\"pubecpem-r\"));\n+        pubList.add(pubecpem.makeCRLF(\"pubecpem-rn\"));\n+        privList.add(privpem);\n+        privList.add(privpembc);\n+        privList.add(ecprivpem);\n+        privList.add(privec25519pem);\n+        privList.add(encEdECKeyEKPI);  \/\/ The non-EKPI version needs decryption\n+        privList.add(rsaOpenSSL);\n+        oasList.add(oasrfc8410);\n+        oasList.add(oasbcpem);\n+\n+        certList.add(rsaCert);\n+        certList.add(ecCert);\n+\n+        entryList.addAll(pubList);\n+        entryList.addAll(privList);\n+        entryList.addAll(oasList);\n+        entryList.addAll(certList);\n+\n+        encryptedList.add(encEdECKey);\n+\n+        passList.addAll(entryList);\n+        passList.addAll(encryptedList);\n+\n+        failureEntryList.add(new Entry(\"emptyPEM\", \"\", DEREncodable.class, null));\n+        failureEntryList.add(new Entry(\"nullPEM\", null, DEREncodable.class, null));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMCerts.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing basic PEM API decodings\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import java.lang.Class;\n+import java.io.IOException;\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.*;\n+import java.util.Arrays;\n+\n+public class PEMDecoderTest {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    PEMDecoderTest() {\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        System.out.println(\"Decoder test:\");\n+        PEMCerts.entryList.forEach(PEMDecoderTest::test);\n+        System.out.println(\"Decoder test returning DEREncodable class:\");\n+        PEMCerts.entryList.forEach(entry -> test(entry, DEREncodable.class));\n+        System.out.println(\"Decoder test with encrypted PEM:\");\n+        PEMCerts.encryptedList.forEach(PEMDecoderTest::testEncrypted);\n+        System.out.println(\"Decoder test with OAS:\");\n+        testTwoKeys();\n+        System.out.println(\"Decoder test RSA PEM setting RSAKey.class returned:\");\n+        test(PEMCerts.getEntry(\"privpem\"), RSAKey.class);\n+        System.out.println(\"Decoder test failures:\");\n+        PEMCerts.failureEntryList.forEach(PEMDecoderTest::testFailure);\n+        System.out.println(\"Decoder test ECpriv PEM asking for ECPublicKey.class returned:\");\n+        testFailure(PEMCerts.getEntry(\"ecprivpem\"), ECPublicKey.class);\n+        System.out.println(\"Decoder test RSApriv PEM setting P8EKS.class returned:\");\n+        testClass(PEMCerts.getEntry(\"privpem\"), RSAPrivateKey.class);\n+        System.out.println(\"Decoder test RSApriv P1 PEM asking for RSAPublicKey.class returned:\");\n+        testFailure(PEMCerts.getEntry(PEMCerts.privList, \"rsaOpenSSL\"), RSAPublicKey.class);\n+        System.out.println(\"Decoder test RSApriv PEM asking X509EKS.class returned:\");\n+        testClass(PEMCerts.getEntry(\"privpem\"), X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test RSAcert PEM asking X509EKS.class returned:\");\n+        testClass(PEMCerts.getEntry(\"rsaCert\"), X509EncodedKeySpec.class, false);\n+        System.out.println(\"Decoder test OAS RFC PEM asking PrivateKey.class returned:\");\n+        testClass(PEMCerts.getEntry(\"oasrfc8410\"), PrivateKey.class, true);\n+        testClass(PEMCerts.getEntry(\"oasrfc8410\"), PublicKey.class, true);\n+        System.out.println(\"Decoder test encEdECkey:\");\n+        testFailure(PEMCerts.pubecpem.makeNoCRLF(\"pubecpem-no\"));\n+    }\n+\n+    static void testFailure(PEMCerts.Entry entry) {\n+        testFailure(entry, entry.clazz());\n+    }\n+\n+    static void testFailure(PEMCerts.Entry entry, Class c) {\n+        try {\n+            test(entry.pem(), c, PEMDecoder.of());\n+            throw new AssertionError(\"Failure with \" +\n+                entry.name() + \":  Not supposed to succeed.\");\n+        } catch (NullPointerException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        } catch (IOException | RuntimeException e) {\n+            System.out.println(\"PASS (\" + entry.name() + \"):  \" + e.getClass() +\n+                \": \" + e.getMessage());\n+        }\n+    }\n+\n+    static DEREncodable testEncrypted(PEMCerts.Entry entry) {\n+        PEMDecoder decoder = PEMDecoder.of();\n+        if (!Objects.equals(entry.clazz(), EncryptedPrivateKeyInfo.class)) {\n+            decoder = decoder.withDecryption(entry.password());\n+        }\n+\n+        try {\n+            return test(entry.pem(), entry.clazz(), decoder);\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    \/\/ Change the Entry to use the given class as the expected class returned\n+    static DEREncodable test(PEMCerts.Entry entry, Class c) {\n+        return test(entry.newClass(c));\n+    }\n+\n+    \/\/ Run test with a given Entry\n+    static DEREncodable test(PEMCerts.Entry entry) {\n+        try {\n+            DEREncodable r = test(entry.pem(), entry.clazz(), PEMDecoder.of());\n+            System.out.println(\"PASS (\" + entry.name() + \")\");\n+            return r;\n+        } catch (Exception | AssertionError e) {\n+            throw new RuntimeException(\"Error with PEM (\" + entry.name() +\n+                \"):  \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    static List getInterfaceList(Class ccc) {\n+        Class<?>[] interfaces = ccc.getInterfaces();\n+        List<Class> list = new ArrayList<>(Arrays.asList(interfaces));\n+        var x = ccc.getSuperclass();\n+        if (x != null) {\n+            list.add(x);\n+        }\n+        List<Class> results = new ArrayList<>(list);\n+        if (list.size() > 0) {\n+            for (Class cname : list) {\n+                try {\n+                    if (cname != null &&\n+                        cname.getName().startsWith(\"java.security.\")) {\n+                        results.addAll(getInterfaceList(cname));\n+                    }\n+                } catch (Exception e) {\n+                    System.err.println(\"Exception with \" + cname);\n+                }\n+            }\n+        }\n+        return results;\n+    }\n+\n+    \/**\n+     * Perform the decoding test with the given decoder, on the given pem, and\n+     * expect the clazz to be returned.\n+     *\/\n+    static DEREncodable test(String pem, Class clazz, PEMDecoder decoder) throws IOException {\n+        var pk = decoder.decode(pem);\n+\n+        \/\/ Check that clazz matches what pk returned.\n+        if (pk.getClass().equals(clazz)) {\n+            return pk;\n+        }\n+\n+        \/\/ Search interfaces and inheritance to find a match with clazz\n+        List<Class> list = getInterfaceList(pk.getClass());\n+        for (Class cc : list) {\n+            if (cc != null && cc.equals(clazz)) {\n+                return pk;\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Entry did not contain expected: \" +\n+            clazz.getName());\n+    }\n+\n+    \/\/ Run the same key twice through the same decoder and make sure the\n+    \/\/ result is the same\n+    static void testTwoKeys() throws IOException {\n+        PublicKey p1, p2;\n+        PEMDecoder pd = PEMDecoder.of();\n+        p1 = pd.decode(PEMCerts.pubrsapem.pem(), RSAPublicKey.class);\n+        p2 = pd.decode(PEMCerts.pubrsapem.pem(), RSAPublicKey.class);\n+        if (!Arrays.equals(p1.getEncoded(), p2.getEncoded())) {\n+            System.err.println(\"These two should have matched:\");\n+            System.err.println(hex.parseHex(new String(p1.getEncoded())));\n+            System.err.println(hex.parseHex(new String(p2.getEncoded())));\n+            throw new AssertionError(\"Two decoding of the same key failed to\" +\n+                \" match: \");\n+        }\n+    }\n+\n+    static void testClass(PEMCerts.Entry entry, Class clazz) throws IOException {\n+        var pk = PEMDecoder.of().decode(entry.pem(), clazz);\n+    }\n+\n+    static void testClass(PEMCerts.Entry entry, Class clazz, boolean pass) throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (pass) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8298420\n+ * @summary Testing basic PEM API encoding\n+ * @enablePreview\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.spec.PBEParameterSpec;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+public class PEMEncoderTest {\n+\n+    static Map<String, DEREncodable> keymap;\n+    final static Pattern CR = Pattern.compile(\"\\r\");\n+    final static Pattern LF = Pattern.compile(\"\\n\");\n+    final static Pattern LSDEFAULT = Pattern.compile(System.lineSeparator());\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        PEMEncoder encoder = PEMEncoder.of();\n+\n+        PEMCerts.entryList.remove(PEMCerts.getEntry(\"rsaOpenSSL\"));\n+        keymap = generateObjKeyMap(PEMCerts.entryList);\n+        System.out.println(\"Same instance Encoder test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        System.out.println(\"New instance Encoder test:\");\n+        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance Encoder testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        System.out.println(\"New instance Encoder testToString:\");\n+        keymap.keySet().stream().forEach(key -> testToString(key, PEMEncoder.of()));\n+\n+        keymap = generateObjKeyMap(PEMCerts.encryptedList);\n+        System.out.println(\"Same instance Encoder match test:\");\n+        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        System.out.println(\"Same instance Encoder new withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        System.out.println(\"New instance Encoder and withEnc test:\");\n+        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        System.out.println(\"Same instance encrypted Encoder test:\");\n+        PEMEncoder encEncoder = encoder.withEncryption(\"fish\".toCharArray());\n+        keymap.keySet().stream().forEach(key -> testSameEncryptor(key, encEncoder));\n+        try {\n+            encoder.withEncryption(null);\n+        } catch (Exception e) {\n+            if (!(e instanceof NullPointerException)) {\n+                throw new Exception(\"Should have been a NullPointerException thrown\");\n+            }\n+        }\n+    }\n+\n+    static Map generateObjKeyMap(List<PEMCerts.Entry> list) {\n+        Map<String, DEREncodable> keymap = new HashMap<>();\n+        PEMDecoder pemd = PEMDecoder.of();\n+        for (PEMCerts.Entry entry : list) {\n+            try {\n+                if (entry.password() != null) {\n+                    keymap.put(entry.name(), pemd.withDecryption(\n+                        entry.password()).decode(entry.pem()));\n+                } else {\n+                    keymap.put(entry.name(), pemd.decode(entry.pem()));\n+                }\n+            } catch (Exception e) {\n+                System.err.println(\"Verify PEMDecoderTest passes before debugging this test.\");\n+                throw new AssertionError(\"Failed to initialize map on\" +\n+                    \" entry \\\"\" + entry.name() + \"\\\"\", e);\n+            }\n+        }\n+        return keymap;\n+    }\n+\n+    static void test(String key, PEMEncoder encoder) {\n+        byte[] result;\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            result = encoder.encode(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, new String(result, StandardCharsets.UTF_8));\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testToString(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            result = encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encoder use failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testEncrypted(String key, PEMEncoder encoder) {\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            encoder.withEncryption(\n+                    (entry.password() != null ? entry.password() :\n+                        \"fish\".toCharArray()))\n+                .encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failed with \" +\n+                entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    \/*\n+     Test cannot verify PEM was the same as known PEM because we have no\n+     public access to the AlgoritmID.params and PBES2Parameters.\n+     *\/\n+    static void testSameEncryptor(String key, PEMEncoder encoder) {\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            encoder.encodeToString(keymap.get(key));\n+        } catch (RuntimeException e) {\n+            throw new AssertionError(\"Encrypted encoder failured with \" +\n+                entry.name(), e);\n+        }\n+\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void testEncryptedMatch(String key, PEMEncoder encoder) {\n+        String result;\n+        PEMCerts.Entry entry = PEMCerts.getEntry(key);\n+        try {\n+            PrivateKey pkey = (PrivateKey) keymap.get(key);\n+            EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(entry.pem(),\n+                EncryptedPrivateKeyInfo.class);\n+            if (entry.password() != null) {\n+                EncryptedPrivateKeyInfo.encryptKey(pkey, entry.password(),\n+                    Pem.DEFAULT_ALGO, ekpi.getAlgParameters().\n+                        getParameterSpec(PBEParameterSpec.class),\n+                    null);\n+            }\n+            result = encoder.encodeToString(ekpi);\n+        } catch (RuntimeException | InvalidParameterSpecException e) {\n+            throw new AssertionError(\"Encrypted encoder failure with \" +\n+                entry.name(), e);\n+        }\n+\n+        checkResults(entry, result);\n+        System.out.println(\"PASS: \" + entry.name());\n+    }\n+\n+    static void checkResults(PEMCerts.Entry entry, String result) {\n+        String pem = new String(entry.pem());\n+        \/\/ The below matches the \\r\\n generated PEM with the PEM passed\n+        \/\/ into the test.\n+        pem = CR.matcher(pem).replaceAll(\"\");\n+        pem = LF.matcher(pem).replaceAll(\"\");\n+        result = LSDEFAULT.matcher(result).replaceAll(\"\");\n+        try {\n+            if (pem.compareTo(result) != 0) {\n+                System.out.println(\"expected:\\n\" + pem);\n+                System.out.println(\"generated:\\n\" + result);\n+                indexDiff(pem, result);\n+            }\n+        } catch (AssertionError e) {\n+            throw new AssertionError(\"Encoder PEM mismatch \" +\n+                entry.name(), e);\n+        }\n+    }\n+\n+    static void indexDiff(String a, String b) {\n+        String lenerr = \"\";\n+        int len = a.length();\n+        int lenb = b.length();\n+        if (len != lenb) {\n+            lenerr = \":  Length mismatch: \" + len + \" vs \" + lenb;\n+            len = Math.min(len, lenb);\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (a.charAt(i) != b.charAt(i)) {\n+                throw new AssertionError(\"Char mistmatch, index #\" + i +\n+                    \"  (\" + a.charAt(i) + \" vs \" + b.charAt(i) + \")\" + lenerr);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,1 @@\n- * @compile -XDignore.symbol.file PKCS8Test.java\n- * @run testng PKCS8Test\n+ * @run main PKCS8Test\n@@ -37,1 +36,0 @@\n-import java.io.IOException;\n@@ -39,0 +37,1 @@\n+import java.security.InvalidKeyException;\n@@ -44,2 +43,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n@@ -48,1 +45,0 @@\n-import sun.security.util.DerValue;\n@@ -65,2 +61,1 @@\n-    @Test\n-    public void test() throws IOException {\n+    public static void main(String[] args) throws Exception {\n@@ -74,1 +69,2 @@\n-        Assert.assertTrue(Arrays.equals(encodedKey, EXPECTED),\n+        if (!Arrays.equals(encodedKey, EXPECTED)) {\n+            throw new AssertionError(\n@@ -76,2 +72,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedKey));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedKey));\n+        }\n@@ -81,4 +78,3 @@\n-        Assert.assertEquals(decodedKey.getAlgorithm(), ALGORITHM);\n-        Assert.assertEquals(decodedKey.getFormat(), FORMAT);\n-        Assert.assertEquals(decodedKey.getAlgorithmId().toString(),\n-                EXPECTED_ALG_ID_CHRS);\n+        assert(ALGORITHM.equalsIgnoreCase(decodedKey.getAlgorithm()));\n+        assert(FORMAT.equalsIgnoreCase(decodedKey.getFormat()));\n+        assert(EXPECTED_ALG_ID_CHRS.equalsIgnoreCase(decodedKey.getAlgorithmId().toString()));\n@@ -87,1 +83,3 @@\n-        Assert.assertTrue(Arrays.equals(encodedOutput, EXPECTED),\n+        if (!Arrays.equals(encodedOutput, EXPECTED)) {\n+\n+            throw new AssertionError(\n@@ -89,2 +87,3 @@\n-                        .formatter(ASN1Formatter.formatter())\n-                        .toString(encodedOutput));\n+                    .formatter(ASN1Formatter.formatter())\n+                    .toString(encodedOutput));\n+        }\n@@ -94,8 +93,15 @@\n-        enlarge(1, \"810100\");  \/\/ public key for v2\n-        enlarge(1, \"8000\", \"810100\");  \/\/ both\n-\n-        Assert.assertThrows(() -> enlarge(2));  \/\/ bad ver\n-        Assert.assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n-        Assert.assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n-        Assert.assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n-        Assert.assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+\n+        \/\/ PKCSv2 testing done by PEMEncoder\/PEMDecoder tests\n+\n+        assertThrows(() -> enlarge(2));\n+        assertThrows(() -> enlarge(0, \"8000\", \"8000\")); \/\/ no dup\n+        assertThrows(() -> enlarge(0, \"810100\")); \/\/ no public in v1\n+        assertThrows(() -> enlarge(1, \"810100\", \"8000\")); \/\/ bad order\n+        assertThrows(() -> enlarge(1, \"820100\")); \/\/ bad tag\n+    }\n+\n+    private static void assertThrows(Runnable o) {\n+        try {\n+            o.run();\n+            throw new AssertionError(\"Test failed\");\n+        } catch (Exception e) {}\n@@ -110,1 +116,1 @@\n-    static void enlarge(int newVersion, String... fields) throws IOException {\n+    static void enlarge(int newVersion, String... fields) {\n@@ -119,4 +125,8 @@\n-        Assert.assertTrue(length < 127);\n-        original[1] = (byte)(length - 2);   \/\/ the length field inside DER\n-        original[4] = (byte)newVersion;     \/\/ the version inside DER\n-        PKCS8Key.parseKey(original);\n+        assert (length < 127);\n+        original[1] = (byte) (length - 2);   \/\/ the length field inside DER\n+        original[4] = (byte) newVersion;     \/\/ the version inside DER\n+        try {\n+            PKCS8Key.parseKey(original);\n+        } catch (InvalidKeyException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs\/pkcs8\/PKCS8Test.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"}]}