{"files":[{"patch":"@@ -362,1 +362,1 @@\n-      policy()->record_new_heap_size(num_regions());\n+      policy()->record_new_heap_size(num_committed_regions());\n@@ -1034,1 +1034,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1043,1 +1043,1 @@\n-    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.available());\n+    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.num_inactive_regions());\n@@ -1048,1 +1048,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1064,1 +1064,1 @@\n-    policy()->record_new_heap_size(num_regions());\n+    policy()->record_new_heap_size(num_committed_regions());\n@@ -1376,1 +1376,1 @@\n-  guarantee((max_reserved_regions() - 1) <= max_region_idx, \"too many regions\");\n+  guarantee((max_num_regions() - 1) <= max_region_idx, \"too many regions\");\n@@ -1381,1 +1381,1 @@\n-  G1FromCardCache::initialize(max_reserved_regions());\n+  G1FromCardCache::initialize(max_num_regions());\n@@ -1384,1 +1384,1 @@\n-  _rem_set->initialize(max_reserved_regions());\n+  _rem_set->initialize(max_num_regions());\n@@ -1393,1 +1393,1 @@\n-  G1FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n+  G1FreeRegionList::set_unrealistically_long_length(max_num_regions() + 1);\n@@ -1461,1 +1461,1 @@\n-  _collection_set.initialize(max_reserved_regions());\n+  _collection_set.initialize(max_num_regions());\n@@ -1560,1 +1560,1 @@\n-  return _hrm.length() * G1HeapRegion::GrainBytes;\n+  return _hrm.num_committed_regions() * G1HeapRegion::GrainBytes;\n@@ -2072,1 +2072,1 @@\n-  return max_regions() * G1HeapRegion::GrainBytes;\n+  return max_num_regions() * G1HeapRegion::GrainBytes;\n@@ -2220,1 +2220,1 @@\n-                       survivor_used_bytes, old_gen_used_bytes, num_regions());\n+                       survivor_used_bytes, old_gen_used_bytes, num_committed_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_reserved_regions() )\n+typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_num_regions() )\n@@ -974,1 +974,1 @@\n-    return _hrm.available() == 0;\n+    return _hrm.num_inactive_regions() == 0;\n@@ -984,1 +984,1 @@\n-  uint num_regions() const { return _hrm.length(); }\n+  uint num_committed_regions() const { return _hrm.num_committed_regions(); }\n@@ -986,6 +986,2 @@\n-  \/\/ The max number of regions reserved for the heap. Except for static array\n-  \/\/ sizing purposes you probably want to use max_regions().\n-  uint max_reserved_regions() const { return _hrm.reserved_length(); }\n-\n-  \/\/ Max number of regions that can be committed.\n-  uint max_regions() const { return _hrm.max_length(); }\n+  \/\/ The max number of regions reserved for the heap.\n+  uint max_num_regions() const { return _hrm.max_num_regions(); }\n@@ -996,0 +992,3 @@\n+  \/\/ The number of regions that are not completely free.\n+  uint num_used_regions() const { return _hrm.num_used_regions(); }\n+\n@@ -997,1 +996,1 @@\n-  uint num_free_or_available_regions() const { return num_free_regions() + _hrm.available(); }\n+  uint num_available_regions() const { return _hrm.num_available_regions(); }\n@@ -1003,2 +1002,0 @@\n-  \/\/ The number of regions that are not completely free.\n-  uint num_used_regions() const { return num_regions() - num_free_regions(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  _root_regions(_g1h->max_regions()),\n+  _root_regions(_g1h->max_num_regions()),\n@@ -516,3 +516,3 @@\n-  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_reserved_regions(), mtGC)),\n-  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n-  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n+  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_num_regions(), mtGC)),\n+  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n+  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n@@ -573,2 +573,2 @@\n-  uint max_reserved_regions = _g1h->max_reserved_regions();\n-  for (uint i = 0; i < max_reserved_regions; i++) {\n+  uint max_num_regions = _g1h->max_num_regions();\n+  for (uint i = 0; i < max_num_regions; i++) {\n@@ -616,2 +616,2 @@\n-    uint max_reserved_regions = _g1h->max_reserved_regions();\n-    for (uint i = 0; i < max_reserved_regions; i++) {\n+    uint max_num_regions = _g1h->max_num_regions();\n+    for (uint i = 0; i < max_num_regions; i++) {\n@@ -785,1 +785,1 @@\n-  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_regions()) \/ G1CMBitMap::heap_map_factor();\n+  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_committed_regions()) \/ G1CMBitMap::heap_map_factor();\n@@ -1437,1 +1437,1 @@\n-      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_regions()),\n+      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_committed_regions()),\n@@ -1439,1 +1439,1 @@\n-      log_debug(gc,ergo)(\"Running %s using %u workers for %u regions in heap\", cl.name(), num_workers, _g1h->num_regions());\n+      log_debug(gc,ergo)(\"Running %s using %u workers for %u regions in heap\", cl.name(), num_workers, _g1h->num_committed_regions());\n@@ -1443,1 +1443,1 @@\n-                                        _g1h->num_regions(), cl.total_selected_for_rebuild());\n+                                        _g1h->num_committed_regions(), cl.total_selected_for_rebuild());\n@@ -1450,1 +1450,1 @@\n-        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n+        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_committed_regions(), _g1h->policy()->candidates());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"Tried to access TAMS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_num_regions(), \"Tried to access TAMS for region %u out of bounds\", region);\n@@ -202,1 +202,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_num_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n@@ -208,1 +208,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"obj \" PTR_FORMAT \" outside heap %u\", p2i(obj), region);\n+  assert(region < _g1h->max_num_regions(), \"obj \" PTR_FORMAT \" outside heap %u\", p2i(obj), region);\n@@ -220,1 +220,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_num_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  uint max_wasted_regions_allowed = ((heap->num_regions() * G1HeapWastePercent) \/ 100);\n+  uint max_wasted_regions_allowed = ((heap->num_committed_regions() * G1HeapWastePercent) \/ 100);\n@@ -136,3 +136,3 @@\n-  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_regions(), mtGC);\n-  _compaction_tops = NEW_C_HEAP_ARRAY(HeapWord*, _heap->max_regions(), mtGC);\n-  for (uint j = 0; j < heap->max_regions(); j++) {\n+  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_num_regions(), mtGC);\n+  _compaction_tops = NEW_C_HEAP_ARRAY(HeapWord*, _heap->max_num_regions(), mtGC);\n+  for (uint j = 0; j < heap->max_num_regions(); j++) {\n@@ -418,1 +418,1 @@\n-  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n+  assert(start_serial < _heap->max_num_regions(), \"Called on empty parallel compaction queues\");\n@@ -430,1 +430,1 @@\n-  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n+  for (uint i = start_serial + 1; i < _heap->max_num_regions(); i++) {\n@@ -448,1 +448,1 @@\n-  uint max_reserved_regions = _heap->max_reserved_regions();\n+  uint max_num_regions = _heap->max_num_regions();\n@@ -452,1 +452,1 @@\n-  while (region_index < max_reserved_regions) {\n+  while (region_index < max_num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-    assert(region_index < _heap->max_regions(), \"sanity\");\n+    assert(region_index < _heap->max_num_regions(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  _committed_map.initialize(reserved_length());\n+  _committed_map.initialize(max_num_regions());\n@@ -180,1 +180,1 @@\n-  guarantee(num_regions <= available(),\n+  guarantee(num_regions <= num_inactive_regions(),\n@@ -245,1 +245,1 @@\n-  assert(length() >= num_regions, \"pre-condition\");\n+  assert(num_committed_regions() >= num_regions, \"pre-condition\");\n@@ -398,2 +398,2 @@\n-  if (available() >= 1) {\n-    for (uint i = 0; i < reserved_length(); i++) {\n+  if (num_inactive_regions() >= 1) {\n+    for (uint i = 0; i < max_num_regions(); i++) {\n@@ -474,1 +474,1 @@\n-  } while (candidate == G1_NO_HRM_INDEX && range.end() < reserved_length());\n+  } while (candidate == G1_NO_HRM_INDEX && range.end() < max_num_regions());\n@@ -481,1 +481,1 @@\n-  if (num_regions > (num_free_regions() + available())) {\n+  if (num_regions > num_available_regions()) {\n@@ -485,1 +485,1 @@\n-  return find_contiguous_in_range(0, reserved_length(), num_regions);\n+  return find_contiguous_in_range(0, max_num_regions(), num_regions);\n@@ -501,1 +501,1 @@\n-  uint len = reserved_length();\n+  uint len = max_num_regions();\n@@ -517,1 +517,1 @@\n-  uint len = reserved_length();\n+  uint len = max_num_regions();\n@@ -584,2 +584,2 @@\n-  assert(length() > 0, \"the region sequence should not be empty\");\n-  assert(length() <= _next_highest_used_hrm_index, \"invariant\");\n+  assert(num_committed_regions() > 0, \"the region sequence should not be empty\");\n+  assert(num_committed_regions() <= _next_highest_used_hrm_index, \"invariant\");\n@@ -587,1 +587,1 @@\n-  assert(num_regions_to_remove < length(), \"We should never remove all regions\");\n+  assert(num_regions_to_remove < num_committed_regions(), \"We should never remove all regions\");\n@@ -660,9 +660,9 @@\n-  guarantee(length() <= _next_highest_used_hrm_index,\n-            \"invariant: _length: %u _next_highest_used_hrm_index: %u\",\n-            length(), _next_highest_used_hrm_index);\n-  guarantee(_next_highest_used_hrm_index <= reserved_length(),\n-            \"invariant: _next_highest_used_hrm_index: %u _max_length: %u\",\n-            _next_highest_used_hrm_index, reserved_length());\n-  guarantee(length() <= max_length(),\n-            \"invariant: committed regions: %u max_regions: %u\",\n-            length(), max_length());\n+  guarantee(num_committed_regions() <= _next_highest_used_hrm_index,\n+            \"invariant: committed regions: %u _next_highest_used_hrm_index: %u\",\n+            num_committed_regions(), _next_highest_used_hrm_index);\n+  guarantee(_next_highest_used_hrm_index <= max_num_regions(),\n+            \"invariant: _next_highest_used_hrm_index: %u max_num_regions: %u\",\n+            _next_highest_used_hrm_index, max_num_regions());\n+  guarantee(num_committed_regions() <= max_num_regions(),\n+            \"invariant: committed regions: %u max_num_regions: %u\",\n+            num_committed_regions(), max_num_regions());\n@@ -695,1 +695,1 @@\n-  for (uint i = _next_highest_used_hrm_index; i < reserved_length(); i++) {\n+  for (uint i = _next_highest_used_hrm_index; i < max_num_regions(); i++) {\n@@ -699,1 +699,1 @@\n-  guarantee(num_committed == length(), \"Found %u committed regions, but should be %u\", num_committed, length());\n+  guarantee(num_committed == num_committed_regions(), \"Found %u committed regions, but should be %u\", num_committed, num_committed_regions());\n@@ -748,1 +748,1 @@\n-      _worker_chunk_size((_hrm->reserved_length() + num_workers - 1) \/ num_workers),\n+      _worker_chunk_size((_hrm->max_num_regions() + num_workers - 1) \/ num_workers),\n@@ -773,1 +773,1 @@\n-    uint end = MIN2(start + _worker_chunk_size, _hrm->reserved_length());\n+    uint end = MIN2(start + _worker_chunk_size, _hrm->max_num_regions());\n@@ -799,1 +799,1 @@\n-  uint const num_workers = clamp(max_length(), 1u, workers->active_workers());\n+  uint const num_workers = clamp(max_num_regions(), 1u, workers->active_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,1 @@\n-\/\/ * max_length() returns the maximum number of regions the heap may commit.\n-\/\/ * reserved_length() returns the maximum number of regions the heap has reserved.\n+\/\/ * max_num_regions() returns the maximum number of regions the heap has reserved.\n@@ -224,0 +223,2 @@\n+  uint num_used_regions() const { return num_committed_regions() - num_free_regions(); }\n+\n@@ -232,2 +233,2 @@\n-  \/\/ Return the number of regions available (uncommitted) regions.\n-  uint available() const { return max_length() - length(); }\n+  \/\/ Return the number of regions uncommitted or ready to be uncommitted.\n+  uint num_inactive_regions() const { return max_num_regions() - num_committed_regions(); }\n@@ -236,1 +237,1 @@\n-  uint length() const { return _committed_map.num_active(); }\n+  uint num_committed_regions() const { return _committed_map.num_active(); }\n@@ -239,1 +240,1 @@\n-  uint reserved_length() const { return (uint)_regions.length(); }\n+  uint max_num_regions() const { return (uint)_regions.length(); }\n@@ -241,2 +242,1 @@\n-  \/\/ Return maximum number of regions that heap can expand to.\n-  uint max_length() const { return reserved_length(); }\n+  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  if (index < reserved_length() && is_available(index) && at(index)->is_continues_humongous()) {\n+  if (index < max_num_regions() && is_available(index) && at(index)->is_continues_humongous()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  _young_gen_sizer.adjust_max_new_size(_g1h->max_regions());\n+  _young_gen_sizer.adjust_max_new_size(_g1h->max_num_regions());\n@@ -679,1 +679,1 @@\n-  assert(max_survivor_regions() + _g1h->num_used_regions() <= _g1h->max_regions(),\n+  assert(max_survivor_regions() + _g1h->num_used_regions() <= _g1h->max_num_regions(),\n@@ -681,1 +681,1 @@\n-         max_survivor_regions(), _g1h->num_used_regions(), _g1h->max_regions());\n+         max_survivor_regions(), _g1h->num_used_regions(), _g1h->max_num_regions());\n@@ -1203,1 +1203,1 @@\n-                               _g1h->num_free_or_available_regions());\n+                               _g1h->num_available_regions());\n@@ -1448,1 +1448,1 @@\n-  double result = (double)_g1h->num_regions() * G1OldCSetRegionThresholdPercent \/ 100;\n+  double result = (double)_g1h->num_committed_regions() * G1OldCSetRegionThresholdPercent \/ 100;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1435,1 +1435,1 @@\n-      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * G1HeapRegion::CardsPerRegion;\n+      (g1h->num_committed_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * G1HeapRegion::CardsPerRegion;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-  void initialize(uint max_reserved_regions);\n+  void initialize(uint max_num_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-  _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n+  _evac_failure_regions.pre_collection(_g1h->max_num_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  _allocation_failure_regions.reinitialize(g1h->max_reserved_regions());\n+  _allocation_failure_regions.reinitialize(g1h->max_num_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-    size_t nr = g1h->max_regions();\n+    size_t nr = g1h->max_num_regions();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}