{"files":[{"patch":"@@ -232,2 +232,0 @@\n-#elif defined(IA64)\n-static char cpu_arch[] = \"ia64\";\n@@ -1195,2 +1193,0 @@\n-  #elif  (defined IA64)\n-  static  Elf32_Half running_arch_code=EM_IA_64;\n@@ -1217,1 +1213,1 @@\n-         IA32, AMD64, IA64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n+         IA32, AMD64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n-  \/\/ page as large as 1G.\n+  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode.\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -464,3 +464,7 @@\n-\/\/ i386: 224, ia64: 1105, amd64: 186, sparc: 143\n-  #ifdef __ia64__\n-    #define SYS_gettid 1105\n+\/\/ i386: 224, amd64: 186, sparc: 143\n+  #if defined(__i386__)\n+    #define SYS_gettid 224\n+  #elif defined(__amd64__)\n+    #define SYS_gettid 186\n+  #elif defined(__sparc__)\n+    #define SYS_gettid 143\n@@ -468,13 +472,1 @@\n-    #ifdef __i386__\n-      #define SYS_gettid 224\n-    #else\n-      #ifdef __amd64__\n-        #define SYS_gettid 186\n-      #else\n-        #ifdef __sparc__\n-          #define SYS_gettid 143\n-        #else\n-          #error define gettid for the arch\n-        #endif\n-      #endif\n-    #endif\n+    #error \"Define SYS_gettid for this architecture\"\n@@ -482,2 +474,1 @@\n-#endif\n-\n+#endif \/\/ SYS_gettid\n@@ -1781,2 +1772,0 @@\n-#elif  (defined IA64)\n-  static  Elf32_Half running_arch_code=EM_IA_64;\n@@ -1815,1 +1804,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -2722,2 +2711,0 @@\n-#elif defined(IA64)\n-  strncpy(cpuinfo, \"IA64\", length);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -964,4 +964,0 @@\n-#if defined(IA64) && defined(LINUX)\n-    { SIGILL,  ILL_BADIADDR, \"ILL_BADIADDR\", \"Unimplemented instruction address\" },\n-    { SIGILL,  ILL_BREAK,    \"ILL_BREAK\",    \"Application Break instruction\" },\n-#endif\n@@ -981,3 +977,0 @@\n-#endif\n-#if defined(IA64) && !defined(AIX)\n-    { SIGSEGV, SEGV_PSTKOVF, \"SEGV_PSTKOVF\", \"Paragraph stack overflow\" },\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -959,1 +959,0 @@\n-          \/\/ IA64     1     1     1          1    1         50          41\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -227,4 +227,0 @@\n-#if (defined(IA64) && !defined(AIX))\n-  Node* adr_last_Java_fp = basic_plus_adr(top(), thread, in_bytes(JavaThread::last_Java_fp_offset()));\n-  store_to_memory(control(), adr_last_Java_fp, null(), T_ADDRESS, MemNode::unordered);\n-#endif\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  \/\/ On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish\n+  \/\/ On platforms with weak memory ordering (e.g., PPC) we distinguish\n@@ -569,1 +569,1 @@\n-  \/\/ On platforms with weak memory ordering (e.g., PPC, Ia64) we distinguish\n+  \/\/ On platforms with weak memory ordering (e.g., PPC) we distinguish\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-  \/\/ and memory stacks (ie. IA64).\n+  \/\/ and memory stacks.\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-                 IA64_ONLY(\"ia64\")               \\\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -610,3 +610,0 @@\n-  \/\/ Note: on ia64 this guarantee can be fooled by frames with no memory stack\n-  \/\/ in that it will fail to detect a problem when there is one. This needs\n-  \/\/ more work in tiger timeframe.\n@@ -2345,2 +2342,1 @@\n-    \/\/ 4852688: ProfileInterpreter is off by default for ia64.  The result is\n-    \/\/ infinite heroic-opt-uncommon-trap\/deopt\/recompile cycles, since the\n+    \/\/ The result is infinite heroic-opt-uncommon-trap\/deopt\/recompile cycles, since the\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,4 +167,2 @@\n-  \/\/ For sparc and ia32 use sp. ia64 can have memory frames that are empty so multiple frames\n-  \/\/ will have identical sp values. For ia64 the bsp (fp) value will serve. No real frame\n-  \/\/ should have an id() of null so it is a distinguishing value for an unmatchable frame.\n-  \/\/ We also have relationals which allow comparing a frame to anoth frame's id() allow\n+  \/\/ No real frame should have an id() of null so it is a distinguishing value for an unmatchable frame.\n+  \/\/ We also have relationals which allow comparing a frame to another frame's id() allowing\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  \/\/ on sparc\/ia64 which will catch violations of the resetting of last_Java_frame\n+  \/\/ which will catch violations of the resetting of last_Java_frame\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -858,2 +858,1 @@\n-  \/\/ only walk stack if %ebp is used as frame pointer; on ia64, it's not\n-  \/\/ possible to walk C stack without having the unwind table.\n+  \/\/ only walk stack if %ebp is used as frame pointer.\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-    case Bytecodes::_lookupswitch:                   \/\/ not rewritten on ia64\n+    case Bytecodes::_lookupswitch:\n","filename":"src\/hotspot\/share\/runtime\/relocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  \/\/ first value in the function descriptor (on IA64 and PPC64 they look as follows):\n+  \/\/ first value in the function descriptor (on PPC64 they look as follows):\n@@ -39,1 +39,0 @@\n-  \/\/ IA64 : [function entry point, GP (global pointer) value]\n@@ -41,1 +40,1 @@\n-  \/\/ assert(IA64_ONLY(2) PPC64_ONLY(3) * sizeof(address) == shdr.sh_entsize, \"Size mismatch for '.opd' section entries\");\n+  \/\/ assert(PPC64_ONLY(3) * sizeof(address) == shdr.sh_entsize, \"Size mismatch for '.opd' section entries\");\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,3 +38,2 @@\n-On PowerPC-64 (and other architectures like for example IA64) a pointer to a\n-function is not just a plain code address, but instead a pointer to a so called\n-function descriptor (which is simply a structure containing 3 pointers).\n+On PowerPC-64 a pointer to a function is not just a plain code address, but instead a pointer\n+to a so-called function descriptor (which is simply a structure containing 3 pointers).\n","filename":"src\/hotspot\/share\/utilities\/elfFuncDescTable.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -461,12 +461,0 @@\n-\/\/ This is a REALLY BIG HACK, but on AIX <sys\/systemcfg.h> unconditionally defines IA64.\n-\/\/ At least on AIX 7.1 this is a real problem because 'systemcfg.h' is indirectly included\n-\/\/ by 'pthread.h' and other common system headers.\n-\n-#if defined(IA64) && !defined(AIX)\n-#define IA64_ONLY(code) code\n-#define NOT_IA64(code)\n-#else\n-#define IA64_ONLY(code)\n-#define NOT_IA64(code) code\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}