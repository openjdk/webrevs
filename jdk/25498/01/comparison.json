{"files":[{"patch":"@@ -2222,0 +2222,20 @@\n+C2V_VMENTRY_NULL(jobjectArray, getAllMethods, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n+    JVMCI_THROW_NULL(NullPointerException);\n+  }\n+  if (!klass->is_instance_klass()) {\n+    JVMCIObjectArray methods = JVMCIENV->new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobjectArray(methods);\n+  }\n+\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  JVMCIObjectArray methods = JVMCIENV->new_ResolvedJavaMethod_array(iklass->methods()->length(), JVMCI_CHECK_NULL);\n+  for (int i = 0; i < iklass->methods()->length(); i++) {\n+    methodHandle mh(THREAD, iklass->methods()->at(i));\n+    JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n+    JVMCIENV->put_object_at(methods, i, method);\n+  }\n+  return JVMCIENV->get_jobjectArray(methods);\n+C2V_END\n+\n@@ -3357,0 +3377,1 @@\n+  {CC \"getAllMethods\",                                CC \"(\" HS_KLASS2 \")[\" RESOLVED_METHOD,                                                FN_PTR(getAllMethods)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -694,0 +694,1 @@\n+  declare_constant(ConstMethodFlags::_misc_is_overpass)                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1151,1 +1151,2 @@\n-     * Gets the {@link ResolvedJavaMethod}s for all the non-constructor methods of {@code klass}.\n+     * Gets the {@link ResolvedJavaMethod}s for all non-overpass and non-initializer\n+     * methods of {@code klass}.\n@@ -1159,0 +1160,9 @@\n+    \/**\n+     * Gets the {@link ResolvedJavaMethod}s for all methods of {@code klass}.\n+     *\/\n+    ResolvedJavaMethod[] getAllMethods(HotSpotResolvedObjectTypeImpl klass) {\n+        return getAllMethods(klass, klass.getKlassPointer());\n+    }\n+\n+    native ResolvedJavaMethod[] getAllMethods(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -576,0 +576,13 @@\n+    \/*\n+     * Currently in hotspot a method can either be a \"normal\" or an \"overpass\"\n+     * method. Overpass methods are instance methods which are created when\n+     * otherwise a valid candidate for method resolution would not be found.\n+     *\/\n+    @Override\n+    public boolean isDeclared() {\n+        if (isConstructor() || isClassInitializer()) {\n+            return false;\n+        }\n+        return (getConstMethodFlags() & config().constMethodFlagsIsOverpass) == 0;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1070,0 +1070,12 @@\n+    @Override\n+    public List<ResolvedJavaMethod> getAllMethods(boolean forceLink) {\n+        if (forceLink) {\n+            link();\n+        }\n+        ResolvedJavaMethod[] instanceMethods = runtime().compilerToVm.getAllMethods(this);\n+        if (instanceMethods.length == 0) {\n+            return List.of();\n+        }\n+        return Collections.unmodifiableList(Arrays.asList(instanceMethods));\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -299,0 +299,5 @@\n+    @Override\n+    public List<ResolvedJavaMethod> getAllMethods(boolean forceLink) {\n+        return List.of();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+    final int constMethodFlagsIsOverpass = getConstant(\"ConstMethodFlags::_misc_is_overpass\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+    \/**\n+     * Returns {@code true} if this method is contained in the array returned by\n+     * {@code getDeclaringClass().getDeclaredMethods()}\n+     *\/\n+    boolean isDeclared();\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.List;\n@@ -368,0 +369,11 @@\n+    \/**\n+     * Returns a list containing all methods present within this type. This list can\n+     * include methods implicitly created and used by the VM that are not present in\n+     * {@link #getDeclaredMethods}. The returned List is unmodifiable; calls to any\n+     * mutator method will always cause {@code UnsupportedOperationException} to be\n+     * thrown.\n+     *\n+     * @param forceLink if {@code true}, forces this type to be {@link #link linked}\n+     *\/\n+    List<ResolvedJavaMethod> getAllMethods(boolean forceLink);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -428,0 +428,13 @@\n+    @Test\n+    public void isDeclaredTest() {\n+        for (Map.Entry<Method, ResolvedJavaMethod> e : methods.entrySet()) {\n+            ResolvedJavaMethod m = e.getValue();\n+            boolean expectedDeclared = Arrays.stream(m.getDeclaringClass().getDeclaredMethods()).anyMatch(i -> i.equals(m));\n+            assertEquals(expectedDeclared, m.isDeclared());\n+        }\n+        for (Map.Entry<Constructor<?>, ResolvedJavaMethod> e : constructors.entrySet()) {\n+            ResolvedJavaMethod m = e.getValue();\n+            assertFalse(m.isDeclared());\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1022,0 +1022,12 @@\n+    @Test\n+    public void getAllMethodsTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Set<ResolvedJavaMethod> allMethods = new HashSet<>(type.getAllMethods(true));\n+            Stream<ResolvedJavaMethod> allKnownMethods = Stream.concat(Arrays.stream(type.getDeclaredMethods()), Arrays.stream(type.getDeclaredConstructors()));\n+            allKnownMethods = Stream.concat(allKnownMethods, Stream.ofNullable(type.getClassInitializer()));\n+            List<ResolvedJavaMethod> missingMethods = allKnownMethods.filter(m -> !allMethods.contains(m)).toList();\n+            assertTrue(missingMethods.toString(), missingMethods.isEmpty());\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}