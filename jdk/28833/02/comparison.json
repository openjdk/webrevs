{"files":[{"patch":"@@ -150,2 +150,3 @@\n-                Log.error(I18N.format(\"error.cert.not.found\", certificateSelector.signingIdentities().getFirst(),\n-                        keychain.map(Keychain::name).orElse(\"\")));\n+                var errMsg = I18N.format(\"error.cert.not.found\", certificateSelector.signingIdentities().getFirst(),\n+                        keychain.map(Keychain::name).orElse(\"\"));\n+                Log.error(I18N.format(\"message.error-header\", errMsg));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/SigningIdentityBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.jpackage.internal.util.Slot;\n@@ -106,0 +107,6 @@\n+        final var runner = new Runner(t -> {\n+            new ErrorReporter(_ -> {\n+                t.printStackTrace(err);\n+            }, Log::fatalError, Log.isVerbose()).reportError(t);\n+        });\n+\n@@ -107,7 +114,15 @@\n-            try {\n-                args = CommandLine.parse(args);\n-            } catch (FileNotFoundException|NoSuchFileException ex) {\n-                Log.fatalError(I18N.format(\"ERR_CannotParseOptions\", ex.getMessage()));\n-                return 1;\n-            } catch (IOException ex) {\n-                throw ExceptionBox.rethrowUnchecked(ex);\n+            var mappedArgs = Slot.<String[]>createEmpty();\n+\n+            int preprocessStatus = runner.run(() -> {\n+                try {\n+                    mappedArgs.set(CommandLine.parse(args));\n+                    return List.of();\n+                } catch (FileNotFoundException|NoSuchFileException ex) {\n+                    return List.of(new JPackageException(I18N.format(\"ERR_CannotParseOptions\", ex.getMessage()), ex));\n+                } catch (IOException ex) {\n+                    return List.of(ex);\n+                }\n+            });\n+\n+            if (preprocessStatus != 0) {\n+                return preprocessStatus;\n@@ -119,1 +134,1 @@\n-            final var parseResult = Utils.buildParser(OperatingSystem.current(), bundlingEnv).create().apply(args);\n+            final var parseResult = Utils.buildParser(OperatingSystem.current(), bundlingEnv).create().apply(mappedArgs.get());\n@@ -121,1 +136,1 @@\n-            return new Runner().run(() -> {\n+            return runner.run(() -> {\n@@ -167,2 +182,20 @@\n-\n-    record ErrorReporter(Consumer<Throwable> stackTracePrinter, Consumer<String> messagePrinter) {\n+    \/*\n+     * Exception (error) reporting:\n+     *\n+     * There are two types of exceptions to handle:\n+     *\n+     * 1. Exceptions explicitly thrown by jpackage code with localized,\n+     *    jpackage-specific error messages. These are usually instances of\n+     *    JPackageException.\n+     *\n+     * 2. Exceptions thrown by JDK code (for example, an NPE from Optional.of(...)).\n+     *    These should normally not occur or should be handled at the point\n+     *    where they arise. If they reach this level of exception handling,\n+     *    it indicates a flaw in jpackageâ€™s internal logic.\n+     *\n+     * Always print stack traces for exceptions of type #2.\n+     * Print stack traces for exceptions of type #1 only in verbose mode.\n+     * Always print the messages for exceptions of any type.\n+     *\/\n+\n+    record ErrorReporter(Consumer<Throwable> stackTracePrinter, Consumer<String> messagePrinter, boolean verbose) {\n@@ -174,0 +207,4 @@\n+        ErrorReporter(Consumer<Throwable> stackTracePrinter, Consumer<String> messagePrinter) {\n+            this(stackTracePrinter, messagePrinter, true);\n+        }\n+\n@@ -187,1 +224,5 @@\n-            stackTracePrinter.accept(t);\n+            var isAlienException = isAlienExceptionType(t);\n+\n+            if (isAlienException || verbose) {\n+                stackTracePrinter.accept(t);\n+            }\n@@ -190,1 +231,1 @@\n-            if (isAlienExceptionType(t)) {\n+            if (isAlienException) {\n@@ -219,1 +260,5 @@\n-    static final class Runner {\n+    record Runner(Consumer<Throwable> errorReporter) {\n+\n+        Runner {\n+            Objects.requireNonNull(errorReporter);\n+        }\n@@ -226,2 +271,1 @@\n-                var errorReporter = new ErrorReporter(Log::verbose, Log::fatalError);\n-                exceptions.forEach(errorReporter::reportError);\n+                exceptions.forEach(errorReporter);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":60,"deletions":16,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-message.error-header={0}\n+message.error-header=Error: {0}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,9 @@\n-            this(DottedVersion.greedy(app.version()));\n+            this(parse(app.version()));\n+        }\n+\n+        private static DottedVersion parse(String strVersion) {\n+            try {\n+                return DottedVersion.greedy(strVersion);\n+            } catch (IllegalArgumentException ex) {\n+                throw new JPackageException(ex.getMessage(), ex);\n+            }\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinApplicationMixin.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -38,0 +40,1 @@\n+import java.util.Map;\n@@ -41,0 +44,3 @@\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n@@ -43,0 +49,3 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -47,0 +56,1 @@\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -56,0 +66,15 @@\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_ErrorReporter(ErrorReporterTestSpec test) {\n+        test.run();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"message.error-header\", \"message.advice-header\"})\n+    public void test_ErrorReporter_format(String key) {\n+        var str = \"Hello!\";\n+        var msg = I18N.format(key, str);\n+        assertTrue(msg.contains(str));\n+        assertNotEquals(str, msg);\n+    }\n+\n@@ -82,0 +107,70 @@\n+    private static List<ErrorReporterTestSpec> test_ErrorReporter() {\n+        var data = new ArrayList<ErrorReporterTestSpec>();\n+\n+        for (var verbose : List.of(true, false)) {\n+            for (var makeCause : List.<UnaryOperator<Exception>>of(\n+                    ex -> ex,\n+                    \/\/ UncheckedIOException\n+                    ex -> {\n+                        if (ex instanceof IOException ioex) {\n+                            return new UncheckedIOException(ioex);\n+                        } else {\n+                            return null;\n+                        }\n+                    },\n+                    \/\/ ExceptionBox\n+                    ex -> {\n+                        try {\n+                            throw ExceptionBox.rethrowUnchecked(ex);\n+                        } catch (RuntimeException rex) {\n+                            if (rex != ex) {\n+                                return rex;\n+                            } else {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+            )) {\n+                for (var expect : List.of(\n+                        Map.entry(new IOException(\"I\/O error\"), true),\n+                        Map.entry(new NullPointerException(), true),\n+                        Map.entry(new JPackageException(\"Kaput!\"), false),\n+                        Map.entry(new ConfigException(\"It is broken\", \"Fix it!\"), false),\n+                        Map.entry(new ConfigException(\"It is broken. No advice how to fix it\", (String)null), false),\n+                        Map.entry(new Utils.ParseException(\"Malformed command line\"), false),\n+                        Map.entry(new StandardOption.AddLauncherIllegalArgumentException(\"Malformed value of --add-launcher option\"), false)\n+                )) {\n+                    var cause = makeCause.apply(expect.getKey());\n+                    if (cause == null) {\n+                        continue;\n+                    }\n+\n+                    var expectedOutput = new ArrayList<ExceptionFormatter>();\n+                    if (expect.getValue()) {\n+                        \/\/ An alien exception.\n+                        expectedOutput.add(ExceptionFormatter.STACK_TRACE);\n+                        expectedOutput.add(ExceptionFormatter.TO_STRING);\n+                    } else {\n+                        if (verbose) {\n+                            expectedOutput.add(ExceptionFormatter.STACK_TRACE);\n+                        }\n+                        if (expect.getKey() instanceof ConfigException cex) {\n+                            if (cex.getAdvice() != null) {\n+                                expectedOutput.add(ExceptionFormatter.MESSAGE_WITH_ADVICE);\n+                            } else {\n+                                expectedOutput.add(ExceptionFormatter.GET_MESSAGE);\n+                            }\n+                        } else {\n+                            expectedOutput.add(ExceptionFormatter.GET_MESSAGE);\n+                        }\n+                    }\n+\n+                    data.add(new ErrorReporterTestSpec(cause, expect.getKey(), verbose, expectedOutput));\n+                }\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+\n@@ -244,0 +339,91 @@\n+    private enum ExceptionFormatter {\n+        GET_MESSAGE(errorMessage(Exception::getMessage)),\n+        MESSAGE_WITH_ADVICE(ex -> {\n+            var advice = Objects.requireNonNull(((ConfigException)ex).getAdvice());\n+            var sb = new StringBuilder();\n+            sb.append(GET_MESSAGE.format(ex));\n+            sb.append(I18N.format(\"message.advice-header\", advice));\n+            sb.append(System.lineSeparator());\n+            return sb.toString();\n+        }),\n+        TO_STRING(errorMessage(Exception::toString)),\n+        STACK_TRACE(ex -> {\n+            var sink = new StringWriter();\n+            try (var pw = new PrintWriter(sink)) {\n+                ex.printStackTrace(pw);\n+            }\n+            return sink.toString();\n+        })\n+        ;\n+\n+        ExceptionFormatter(Function<Exception, String> formatter) {\n+            this.formatter = Objects.requireNonNull(formatter);\n+        }\n+\n+        String format(Exception v) {\n+            return formatter.apply(v);\n+        }\n+\n+        private static Function<Exception, String> errorMessage(Function<Exception, String> formatter) {\n+            Objects.requireNonNull(formatter);\n+            return ex -> {\n+                var msg = formatter.apply(ex);\n+                return I18N.format(\"message.error-header\", msg) + System.lineSeparator();\n+            };\n+        }\n+\n+        private final Function<Exception, String> formatter;\n+    }\n+\n+\n+    record ErrorReporterTestSpec(Exception cause, Exception expect, boolean verbose, List<ExceptionFormatter> expectOutput) {\n+\n+        ErrorReporterTestSpec {\n+            Objects.requireNonNull(cause);\n+            Objects.requireNonNull(expect);\n+            Objects.requireNonNull(expectOutput);\n+        }\n+\n+        ErrorReporterTestSpec(Exception cause, boolean verbose, List<ExceptionFormatter> expectOutput) {\n+            this(cause, cause, verbose, expectOutput);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var tokens = new ArrayList<String>();\n+\n+            if (cause == expect) {\n+                tokens.add(cause.toString());\n+            } else {\n+                tokens.add(String.format(\"[%s] => [%s]\", cause, expect));\n+            }\n+\n+            tokens.add(expectOutput.stream().map(Enum::name).collect(Collectors.joining(\"+\")));\n+\n+            if (verbose) {\n+                tokens.add(\"verbose\");\n+            }\n+\n+            return tokens.stream().collect(Collectors.joining(\"; \"));\n+        }\n+\n+        void run() {\n+            var sink = new StringWriter();\n+\n+            try (var pw = new PrintWriter(sink)) {\n+                new Main.ErrorReporter(t -> {\n+                    t.printStackTrace(pw);\n+                }, msg -> {\n+                    pw.println(msg);\n+                }, verbose).reportError(cause);\n+            }\n+\n+            var expected = expectOutput.stream().map(formatter -> {\n+                return formatter.format(expect);\n+            }).collect(Collectors.joining(\"\"));\n+\n+            assertEquals(expected, sink.toString());\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/MainTest.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"}]}