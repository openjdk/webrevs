{"files":[{"patch":"@@ -214,0 +214,1 @@\n+            case SUPER_INIT -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+        SUPER_INIT(JDK22, Fragments.FeatureSuperInit, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -940,0 +940,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -962,3 +964,2 @@\n-                \/\/ If this class appears as an anonymous class\n-                \/\/ in a superclass constructor call\n-                \/\/ disable implicit outer instance from being passed.\n+                \/\/ If this class appears as an anonymous class in a constructor\n+                \/\/ prologue, disable implicit outer instance from being passed.\n@@ -966,2 +967,1 @@\n-                if (env.info.isSelfCall &&\n-                        env.tree.hasTag(NEWCLASS)) {\n+                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n@@ -975,0 +975,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -984,0 +985,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -1047,0 +1050,3 @@\n+            \/\/ Is this method a constructor?\n+            boolean isConstructor = TreeInfo.isConstructor(tree);\n+\n@@ -1074,1 +1080,1 @@\n-                if (tree.name == names.init) {\n+                if (isConstructor) {\n@@ -1077,5 +1083,2 @@\n-                        JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                        if (app == null ||\n-                                TreeInfo.name(app.meth) != names._this ||\n-                                !checkFirstConstructorStat(app, tree, false)) {\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n+                        if (!TreeInfo.hasConstructorCall(tree, names._this)) {\n+                            log.error(tree, Errors.NonCanonicalConstructorInvokeAnotherConstructor(env.enclClass.sym));\n@@ -1107,5 +1110,1 @@\n-                            JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                            if (app != null &&\n-                                    (TreeInfo.name(app.meth) == names._this ||\n-                                            TreeInfo.name(app.meth) == names._super) &&\n-                                    checkFirstConstructorStat(app, tree, false)) {\n+                            if (TreeInfo.hasAnyConstructorCall(tree)) {\n@@ -1189,5 +1188,3 @@\n-                if (tree.name == names.init && owner.type != syms.objectType) {\n-                    JCBlock body = tree.body;\n-                    if (body.stats.isEmpty() ||\n-                            TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {\n-                        JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),\n+                if (isConstructor && owner.type != syms.objectType) {\n+                    if (!TreeInfo.hasAnyConstructorCall(tree)) {\n+                        JCStatement supCall = make.at(tree.body.pos).Exec(make.Apply(List.nil(),\n@@ -1195,1 +1192,1 @@\n-                        body.stats = body.stats.prepend(supCall);\n+                        tree.body.stats = tree.body.stats.prepend(supCall);\n@@ -1198,1 +1195,1 @@\n-                            TreeInfo.isSuperCall(body.stats.head)) {\n+                            TreeInfo.hasConstructorCall(tree, names._super)) {\n@@ -1228,0 +1225,3 @@\n+                \/\/ Start of constructor prologue\n+                localEnv.info.ctorPrologue = isConstructor;\n+\n@@ -1237,0 +1237,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -2521,7 +2522,0 @@\n-            \/\/ We are seeing a ...this(...) or ...super(...) call.\n-            \/\/ Check that this is the first statement in a constructor.\n-            checkFirstConstructorStat(tree, env.enclMethod, true);\n-\n-            \/\/ Record the fact\n-            \/\/ that this is a constructor call (using isSelfCall).\n-            localEnv.info.isSelfCall = true;\n@@ -2530,1 +2524,0 @@\n-            localEnv.info.constructorArgs = true;\n@@ -2532,1 +2525,0 @@\n-            localEnv.info.constructorArgs = false;\n@@ -2536,0 +2528,3 @@\n+            \/\/ Done with this()\/super() parameters. End of constructor prologue.\n+            env.info.ctorPrologue = false;\n+\n@@ -2664,20 +2659,0 @@\n-        \/** Check that given application node appears as first statement\n-         *  in a constructor call.\n-         *  @param tree          The application node\n-         *  @param enclMethod    The enclosing method of the application.\n-         *  @param error         Should an error be issued?\n-         *\/\n-        boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {\n-            if (enclMethod != null && enclMethod.name == names.init) {\n-                JCBlock body = enclMethod.body;\n-                if (body.stats.head.hasTag(EXEC) &&\n-                    ((JCExpressionStatement) body.stats.head).expr == tree)\n-                    return true;\n-            }\n-            if (error) {\n-                log.error(tree.pos(),\n-                        Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));\n-            }\n-            return false;\n-        }\n-\n@@ -4356,10 +4331,0 @@\n-        \/\/ In a constructor body,\n-        \/\/ if symbol is a field or instance method, check that it is\n-        \/\/ not accessed before the supertype constructor is called.\n-        if (symEnv.info.isSelfCall &&\n-            sym.kind.matches(KindSelector.VAL_MTH) &&\n-            sym.owner.kind == TYP &&\n-            (sym.flags() & STATIC) == 0) {\n-            chk.earlyRefError(tree.pos(), sym.kind == VAR ?\n-                                          sym : thisSym(tree.pos(), env));\n-        }\n@@ -4477,12 +4442,1 @@\n-            if (sym.name == names._this || sym.name == names._super) {\n-                \/\/ If `C' is the currently compiled class, check that\n-                \/\/ `C.this' does not appear in an explicit call to a constructor\n-                \/\/ also make sure that `super` is not used in constructor invocations\n-                if (env.info.isSelfCall &&\n-                        ((sym.name == names._this &&\n-                        site.tsym == env.enclClass.sym) ||\n-                        sym.name == names._super && env.info.constructorArgs &&\n-                        (sitesym.isInterface() || site.tsym == env.enclClass.sym))) {\n-                    chk.earlyRefError(tree.pos(), sym);\n-                }\n-            } else {\n+            if (sym.name != names._this && sym.name != names._super) {\n@@ -5672,0 +5626,3 @@\n+        \/\/ Check for proper placement of super()\/this() calls.\n+        chk.checkSuperInitCalls(tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":31,"deletions":74,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    \/** Is this an environment for a this(...) or super(...) call?\n+    \/** Are we in the 'prologue' part of a constructor, prior to an explicit this()\/super()?\n@@ -54,5 +54,1 @@\n-    boolean isSelfCall = false;\n-\n-    \/** are we analyzing the arguments for a constructor invocation?\n-     *\/\n-    boolean constructorArgs = false;\n+    boolean ctorPrologue = false;\n@@ -139,2 +135,1 @@\n-        info.isSelfCall = isSelfCall;\n-        info.constructorArgs = constructorArgs;\n+        info.ctorPrologue = ctorPrologue;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -362,9 +362,0 @@\n-    \/** Report an error that symbol cannot be referenced before super\n-     *  has been called.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param sym        The referenced symbol.\n-     *\/\n-    void earlyRefError(DiagnosticPosition pos, Symbol sym) {\n-        log.error(pos, Errors.CantRefBeforeCtorCalled(sym));\n-    }\n-\n@@ -3937,4 +3928,5 @@\n-            JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);\n-            if (app == null) continue;\n-            JCMethodDecl meth = (JCMethodDecl) l.head;\n-            if (TreeInfo.name(app.meth) == names._this) {\n+            if (!TreeInfo.isConstructor(l.head))\n+                continue;\n+            JCMethodDecl meth = (JCMethodDecl)l.head;\n+            JCMethodInvocation app = TreeInfo.findConstructorCall(meth);\n+            if (app != null && TreeInfo.name(app.meth) == names._this) {\n@@ -3973,0 +3965,122 @@\n+\/* *************************************************************************\n+ * Verify the proper placement of super()\/this() calls.\n+ *\n+ *    - super()\/this() may only appear in constructors\n+ *    - There must be at most one super()\/this() call per constructor\n+ *    - The super()\/this() call, if any, must be a top-level statement in the\n+ *      constructor, i.e., not nested inside any other statement or block\n+ *    - There must be no return statements prior to the super()\/this() call\n+ **************************************************************************\/\n+\n+    void checkSuperInitCalls(JCClassDecl tree) {\n+        new SuperThisChecker().check(tree);\n+    }\n+\n+    private class SuperThisChecker extends TreeScanner {\n+\n+        \/\/ Match this scan stack: 1=JCMethodDecl, 2=JCExpressionStatement, 3=JCMethodInvocation\n+        private static final int MATCH_SCAN_DEPTH = 3;\n+\n+        private boolean constructor;        \/\/ is this method a constructor?\n+        private boolean firstStatement;     \/\/ at the first statement in method?\n+        private JCReturn earlyReturn;       \/\/ first return prior to the super()\/init(), if any\n+        private Name initCall;              \/\/ whichever of \"super\" or \"init\" we've seen already\n+        private int scanDepth;              \/\/ current scan recursion depth in method body\n+\n+        public void check(JCClassDecl classDef) {\n+            scan(classDef.defs);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            Assert.check(!constructor);\n+            Assert.check(earlyReturn == null);\n+            Assert.check(initCall == null);\n+            Assert.check(scanDepth == 1);\n+\n+            \/\/ Initialize state for this method\n+            constructor = TreeInfo.isConstructor(tree);\n+            try {\n+\n+                \/\/ Scan method body\n+                if (tree.body != null) {\n+                    firstStatement = true;\n+                    for (List<JCStatement> l = tree.body.stats; l.nonEmpty(); l = l.tail) {\n+                        scan(l.head);\n+                        firstStatement = false;\n+                    }\n+                }\n+\n+                \/\/ Verify no 'return' seen prior to an explicit super()\/this() call\n+                if (constructor && earlyReturn != null && initCall != null)\n+                    log.error(earlyReturn.pos(), Errors.ReturnBeforeSuperclassInitialized);\n+            } finally {\n+                firstStatement = false;\n+                constructor = false;\n+                earlyReturn = null;\n+                initCall = null;\n+            }\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            scanDepth++;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                scanDepth--;\n+            }\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation apply) {\n+            do {\n+\n+                \/\/ Is this a super() or this() call?\n+                Name methodName = TreeInfo.name(apply.meth);\n+                if (methodName != names._super && methodName != names._this)\n+                    break;\n+\n+                \/\/ super()\/this() calls must only appear in a constructor\n+                if (!constructor) {\n+                    log.error(apply.pos(), Errors.CallMustOnlyAppearInCtor);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must be a top level statement\n+                if (scanDepth != MATCH_SCAN_DEPTH) {\n+                    log.error(apply.pos(), Errors.CtorCallsNotAllowedHere);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must not appear more than once\n+                if (initCall != null) {\n+                    log.error(apply.pos(), Errors.RedundantSuperclassInit);\n+                    break;\n+                }\n+\n+                \/\/ If super()\/this() isn't first, require \"statements before super()\" feature\n+                if (!firstStatement)\n+                    preview.checkSourceLevel(apply.pos(), Feature.SUPER_INIT);\n+\n+                \/\/ We found a legitimate super()\/this() call; remember it\n+                initCall = methodName;\n+            } while (false);\n+\n+            \/\/ Proceed\n+            super.visitApply(apply);\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            if (constructor && initCall == null && earlyReturn == null)\n+                earlyReturn = tree;             \/\/ we have seen a return but not (yet) a super()\/this()\n+            super.visitReturn(tree);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":127,"deletions":13,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -204,1 +204,0 @@\n-        localEnv.info.isSelfCall = false;\n@@ -257,1 +256,0 @@\n-        localEnv.info.isSelfCall = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -389,0 +390,7 @@\n+        \/** A class whose initializers we are scanning. Because initializer\n+         *  scans can be triggered out of sequence when visiting certain nodes\n+         *  (e.g., super()), we protect against infinite loops that could be\n+         *  triggered by incorrect code (e.g., super() inside initializer).\n+         *\/\n+        JCClassDecl initScanClass;\n+\n@@ -474,0 +482,18 @@\n+\n+        \/\/ Do something with all static or non-static field initializers and initialization blocks.\n+        \/\/ Note: This method also sends nested class definitions to the handler.\n+        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, Consumer<? super JCTree> handler) {\n+            if (classDef == initScanClass)          \/\/ avoid infinite loops\n+                return;\n+            JCClassDecl initScanClassPrev = initScanClass;\n+            initScanClass = classDef;\n+            try {\n+                for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs = defs.tail) {\n+                    JCTree def = defs.head;\n+                    if (!def.hasTag(METHODDEF) && ((TreeInfo.flags(def) & STATIC) != 0) == isStatic)\n+                        handler.accept(def);\n+                }\n+            } finally {\n+                initScanClass = initScanClassPrev;\n+            }\n+        }\n@@ -539,7 +565,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -548,7 +571,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, false, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -1365,34 +1385,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n-\n-                \/\/ add intersection of all throws clauses of initial constructors\n-                \/\/ to set of caught exceptions, unless class is anonymous.\n-                if (!anonymousClass) {\n-                    boolean firstConstructor = true;\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (TreeInfo.isInitialConstructor(l.head)) {\n-                            List<Type> mthrown =\n-                                ((JCMethodDecl) l.head).sym.type.getThrownTypes();\n-                            if (firstConstructor) {\n-                                caught = mthrown;\n-                                firstConstructor = false;\n-                            } else {\n-                                caught = chk.intersect(mthrown, caught);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                \/\/ process all the instance initializers\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n@@ -1453,1 +1443,1 @@\n-                if (TreeInfo.isInitialConstructor(tree))\n+                if (TreeInfo.hasConstructorCall(tree, names._super))\n@@ -1769,0 +1759,2 @@\n+\n+            \/\/ Mark as thrown the exceptions thrown by the method being invoked\n@@ -1771,0 +1763,8 @@\n+\n+            \/\/ After super(), scan initializers to uncover any exceptions they throw\n+            if (TreeInfo.name(tree.meth) == names._super) {\n+                forEachInitializer(classDef, false, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n+            }\n@@ -2113,1 +2113,1 @@\n-        private boolean isInitialConstructor = false;\n+        private boolean isConstructor;\n@@ -2117,1 +2117,1 @@\n-            if (!isInitialConstructor) {\n+            if (!isConstructor) {\n@@ -2364,7 +2364,4 @@\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n+                    forEachInitializer(tree, true, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n@@ -2394,9 +2391,0 @@\n-                    \/\/ process all the instance initializers\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n-\n@@ -2441,1 +2429,1 @@\n-                boolean lastInitialConstructor = isInitialConstructor;\n+                boolean isConstructorPrev = isConstructor;\n@@ -2443,1 +2431,1 @@\n-                    isInitialConstructor = TreeInfo.isInitialConstructor(tree);\n+                    isConstructor = TreeInfo.isConstructor(tree);\n@@ -2445,1 +2433,2 @@\n-                    if (!isInitialConstructor) {\n+                    \/\/ We only track field initialization inside constructors\n+                    if (!isConstructor) {\n@@ -2448,0 +2437,2 @@\n+\n+                    \/\/ Mark all method parameters as DA\n@@ -2463,1 +2454,1 @@\n-                    if (isInitialConstructor) {\n+                    if (isConstructor) {\n@@ -2505,1 +2496,1 @@\n-                    isInitialConstructor = lastInitialConstructor;\n+                    isConstructor = isConstructorPrev;\n@@ -2521,1 +2512,1 @@\n-                if (inMethod && isInitialConstructor) {\n+                if (inMethod && isConstructor) {\n@@ -2977,0 +2968,22 @@\n+\n+            \/\/ Handle superclass constructor invocations\n+            if (isConstructor) {\n+\n+                \/\/ If super(): at this point all initialization blocks will execute\n+                Name name = TreeInfo.name(tree.meth);\n+                if (name == names._super) {\n+                    forEachInitializer(classDef, false, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n+                }\n+\n+                \/\/ If this(): at this point all final uninitialized fields will get initialized\n+                else if (name == names._this) {\n+                    for (int address = firstadr; address < nextadr; address++) {\n+                        VarSymbol sym = vardecls[address].sym;\n+                        if (isFinalUninitializedField(sym) && !sym.isStatic())\n+                            letInit(tree.pos(), sym);\n+                    }\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":86,"deletions":73,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -1850,1 +1850,1 @@\n-                chk.earlyRefError(pos, c);\n+                log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n@@ -1890,1 +1890,0 @@\n-            Assert.error();\n@@ -1902,1 +1901,0 @@\n-                    Assert.error();\n@@ -2342,2 +2340,2 @@\n-        \/\/ If this$n was accessed, add the field definition and\n-        \/\/ update initial constructors to initialize it\n+        \/\/ If this$n was accessed, add the field definition and prepend\n+        \/\/ initializer code to any super() invocation to initialize it\n@@ -2348,5 +2346,7 @@\n-           for (JCTree def : tree.defs) {\n-                if (TreeInfo.isInitialConstructor(def)) {\n-                  JCMethodDecl mdef = (JCMethodDecl) def;\n-                  mdef.body.stats = mdef.body.stats.prepend(\n-                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+            for (JCTree def : tree.defs) {\n+                if (TreeInfo.isConstructor(def)) {\n+                    JCMethodDecl mdef = (JCMethodDecl)def;\n+                    if (TreeInfo.hasConstructorCall(mdef, names._super)) {\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        TreeInfo.mapSuperCalls(mdef.body, supercall -> make.Block(0, initializer.append(supercall)));\n+                    }\n@@ -2817,4 +2817,2 @@\n-            \/\/ If this is an initial constructor, i.e., it does not start with\n-            \/\/ this(...), insert initializers for this$n and proxies\n-            \/\/ before (pre-1.4, after) the call to superclass constructor.\n-            JCStatement selfCall = translate(tree.body.stats.head);\n+            \/\/ Determine whether this constructor has a super() invocation\n+            boolean invokesSuper = TreeInfo.hasConstructorCall(tree, names._super);\n@@ -2822,1 +2820,2 @@\n-            List<JCStatement> added = List.nil();\n+            \/\/ Create initializers for this$n and proxies\n+            ListBuffer<JCStatement> added = new ListBuffer<>();\n@@ -2829,1 +2828,1 @@\n-                    if (TreeInfo.isInitialConstructor(tree)) {\n+                    if (invokesSuper) {\n@@ -2843,0 +2842,9 @@\n+            \/\/ Recursively translate existing local statements\n+            tree.body.stats = translate(tree.body.stats);\n+\n+            \/\/ Prepend initializers in front of super() call\n+            if (added.nonEmpty()) {\n+                List<JCStatement> initializers = added.toList();\n+                TreeInfo.mapSuperCalls(tree.body, supercall -> make.Block(0, initializers.append(supercall)));\n+            }\n+\n@@ -2846,4 +2854,0 @@\n-            \/\/ recursively translate following local statements and\n-            \/\/ combine with this- or super-call\n-            List<JCStatement> stats = translate(tree.body.stats.tail);\n-            tree.body.stats = stats.prepend(selfCall).prependList(added);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1506,2 +1506,1 @@\n-                if (staticOnly &&\n-                        sym.kind == VAR &&\n+                if (sym.kind == VAR &&\n@@ -1509,4 +1508,7 @@\n-                        (sym.flags() & STATIC) == 0)\n-                    return new StaticError(sym);\n-                else\n-                    return sym;\n+                        (sym.flags() & STATIC) == 0) {\n+                    if (staticOnly)\n+                        return new StaticError(sym);\n+                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n+                        return new RefBeforeCtorCalledError(sym);\n+                }\n+                return sym;\n@@ -2009,5 +2011,9 @@\n-                    if (staticOnly &&\n-                        sym.kind == MTH &&\n-                        sym.owner.kind == TYP &&\n-                        (sym.flags() & STATIC) == 0) return new StaticError(sym);\n-                    else return sym;\n+                    if (sym.kind == MTH &&\n+                            sym.owner.kind == TYP &&\n+                            (sym.flags() & STATIC) == 0) {\n+                        if (staticOnly)\n+                            return new StaticError(sym);\n+                        if (env1.info.ctorPrologue && env1 == env)\n+                            return new RefBeforeCtorCalledError(sym);\n+                    }\n+                    return sym;\n@@ -3770,1 +3776,4 @@\n-                    if (staticOnly) sym = new StaticError(sym);\n+                    if (staticOnly)\n+                        sym = new StaticError(sym);\n+                    else if (env1.info.ctorPrologue)\n+                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3784,0 +3793,2 @@\n+                    if (env.info.ctorPrologue)\n+                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3885,2 +3896,2 @@\n-        if (env.info.isSelfCall && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(\"this\"));\n+        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n+            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n@@ -4591,1 +4602,5 @@\n-            super(STATICERR, sym, \"static error\");\n+            this(sym, \"static error\");\n+        }\n+\n+        StaticError(Symbol sym, String debugName) {\n+            super(STATICERR, sym, debugName);\n@@ -4610,0 +4625,26 @@\n+    \/**\n+     * Specialization of {@link InvalidSymbolError} for illegal\n+     * early accesses within a constructor prologue.\n+     *\/\n+    class RefBeforeCtorCalledError extends StaticError {\n+\n+        RefBeforeCtorCalledError(Symbol sym) {\n+            super(sym, \"prologue error\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                DiagnosticPosition pos,\n+                Symbol location,\n+                Type site,\n+                Name name,\n+                List<Type> argtypes,\n+                List<Type> typeargtypes) {\n+            Symbol errSym = ((sym.kind == TYP && sym.type.hasTag(CLASS))\n+                ? types.erasure(sym.type).tsym\n+                : sym);\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"cant.ref.before.ctor.called\", errSym);\n+        }\n+    }\n+\n@@ -4723,1 +4764,1 @@\n-            super(sym);\n+            super(sym, \"bad method ref error\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":57,"deletions":16,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -573,1 +573,0 @@\n-            localEnv.info.isSelfCall = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-    \/** Insert instance initializer code into initial constructor.\n+    \/** Insert instance initializer code into constructors prior to the super() call.\n@@ -551,31 +551,5 @@\n-        if (md.name == names.init && TreeInfo.isInitialConstructor(md)) {\n-            \/\/ We are seeing a constructor that does not call another\n-            \/\/ constructor of the same class.\n-            List<JCStatement> stats = md.body.stats;\n-            ListBuffer<JCStatement> newstats = new ListBuffer<>();\n-\n-            if (stats.nonEmpty()) {\n-                \/\/ Copy initializers of synthetic variables generated in\n-                \/\/ the translation of inner classes.\n-                while (TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Copy superclass constructor call\n-                newstats.append(stats.head);\n-                stats = stats.tail;\n-                \/\/ Copy remaining synthetic initializers.\n-                while (stats.nonEmpty() &&\n-                       TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Now insert the initializer code.\n-                newstats.appendList(initCode);\n-                \/\/ And copy all remaining statements.\n-                while (stats.nonEmpty()) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-            }\n-            md.body.stats = newstats.toList();\n+        if (TreeInfo.isConstructor(md) && TreeInfo.hasConstructorCall(md, names._super)) {\n+            \/\/ We are seeing a constructor that has a super() call.\n+            \/\/ Find the super() invocation and append the given initializer code.\n+            TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -236,3 +236,11 @@\n-# 0: name\n-compiler.err.call.must.be.first.stmt.in.ctor=\\\n-    call to {0} must be first statement in constructor\n+compiler.err.call.must.only.appear.in.ctor=\\\n+    explicit constructor invocation may only appear within a constructor body\n+\n+compiler.err.redundant.superclass.init=\\\n+    redundant explicit constructor invocation\n+\n+compiler.err.ctor.calls.not.allowed.here=\\\n+    explicit constructor invocation not allowed here\n+\n+compiler.err.return.before.superclass.initialized=\\\n+    ''return'' not allowed before explicit constructor invocation\n@@ -390,1 +398,1 @@\n-# 0: symbol or string\n+# 0: symbol or name\n@@ -3200,0 +3208,3 @@\n+compiler.misc.feature.super.init=\\\n+    statements before super()\n+\n@@ -3902,2 +3913,2 @@\n-compiler.err.first.statement.must.be.call.to.another.constructor=\\\n-    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n+compiler.err.non.canonical.constructor.invoke.another.constructor=\\\n+    constructor is not canonical, so it must invoke another constructor of class {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.function.Function;\n@@ -116,19 +117,0 @@\n-    \/** Is there a constructor invocation in the given list of trees?\n-     *\/\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names) {\n-        for (JCTree tree : trees) {\n-            if (tree.hasTag(EXEC)) {\n-                JCExpressionStatement stat = (JCExpressionStatement)tree;\n-                if (stat.expr.hasTag(APPLY)) {\n-                    JCMethodInvocation apply = (JCMethodInvocation)stat.expr;\n-                    Name methName = TreeInfo.name(apply.meth);\n-                    if (methName == names._this ||\n-                        methName == names._super) {\n-                        return methName;\n-                    }\n-                }\n-            }\n-        }\n-        return names.empty;\n-    }\n-\n@@ -173,12 +155,0 @@\n-    \/** Is this a call to this or super?\n-     *\/\n-    public static boolean isSelfCall(JCTree tree) {\n-        Name name = calledMethodName(tree);\n-        if (name != null) {\n-            Names names = name.table.names;\n-            return name==names._this || name==names._super;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -241,2 +211,15 @@\n-    \/** Is this a constructor whose first (non-synthetic) statement is not\n-     *  of the form this(...)?\n+    \/** Is the given method a constructor containing a super() or this() call?\n+      *\/\n+    public static boolean hasAnyConstructorCall(JCMethodDecl tree) {\n+        return hasConstructorCall(tree, null);\n+    }\n+\n+    \/** Is the given method a constructor containing a super() and\/or this() call?\n+      * The \"target\" is either names._this, names._super, or null for either\/both.\n+      *\/\n+    public static boolean hasConstructorCall(JCMethodDecl tree, Name target) {\n+        JCMethodInvocation app = findConstructorCall(tree);\n+        return app != null && (target == null || target == name(app.meth));\n+    }\n+\n+    \/** Find the first super() or init() call in the given constructor.\n@@ -244,5 +227,4 @@\n-    public static boolean isInitialConstructor(JCTree tree) {\n-        JCMethodInvocation app = firstConstructorCall(tree);\n-        if (app == null) return false;\n-        Name meth = name(app.meth);\n-        return meth == null || meth != meth.table.names._this;\n+    public static JCMethodInvocation findConstructorCall(JCMethodDecl md) {\n+        if (!TreeInfo.isConstructor(md) || md.body == null)\n+            return null;\n+        return new ConstructorCallFinder(md.name.table.names).find(md).head;\n@@ -251,16 +233,75 @@\n-    \/** Return the first call in a constructor definition. *\/\n-    public static JCMethodInvocation firstConstructorCall(JCTree tree) {\n-        if (!tree.hasTag(METHODDEF)) return null;\n-        JCMethodDecl md = (JCMethodDecl) tree;\n-        Names names = md.name.table.names;\n-        if (md.name != names.init) return null;\n-        if (md.body == null) return null;\n-        List<JCStatement> stats = md.body.stats;\n-        \/\/ Synthetic initializations can appear before the super call.\n-        while (stats.nonEmpty() && isSyntheticInit(stats.head))\n-            stats = stats.tail;\n-        if (stats.isEmpty()) return null;\n-        if (!stats.head.hasTag(EXEC)) return null;\n-        JCExpressionStatement exec = (JCExpressionStatement) stats.head;\n-        if (!exec.expr.hasTag(APPLY)) return null;\n-        return (JCMethodInvocation)exec.expr;\n+    \/** Finds all calls to this() and\/or super() in a given constructor.\n+     *  We can't assume they will be \"top level\" statements, because\n+     *  some synthetic calls to super() are added inside { } blocks.\n+     *  So we must recurse through the method's entire syntax tree.\n+     *\/\n+    private static class ConstructorCallFinder extends TreeScanner {\n+\n+        final ListBuffer<JCMethodInvocation> calls = new ListBuffer<>();\n+        final Names names;\n+\n+        ConstructorCallFinder(Names names) {\n+            this.names = names;\n+        }\n+\n+        List<JCMethodInvocation> find(JCMethodDecl meth) {\n+            scan(meth);\n+            return calls.toList();\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation invoke) {\n+            Name name = TreeInfo.name(invoke.meth);\n+            if ((name == names._this || name == names._super))\n+                calls.append(invoke);\n+            super.visitApply(invoke);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n+    \/** Finds super() invocations and translates them using the given mapping.\n+     *\/\n+    public static void mapSuperCalls(JCBlock block, Function<? super JCExpressionStatement, ? extends JCStatement> mapper) {\n+        block.stats = block.stats.map(new TreeInfo.SuperCallTranslator(mapper)::translate);\n+    }\n+\n+    \/** Finds all super() invocations and translates them somehow.\n+     *\/\n+    private static class SuperCallTranslator extends TreeTranslator {\n+\n+        final Function<? super JCExpressionStatement, ? extends JCStatement> translator;\n+\n+        \/** Constructor.\n+         *\n+         * @param translator translates super() invocations, returning replacement statement or null for no change\n+         *\/\n+        SuperCallTranslator(Function<? super JCExpressionStatement, ? extends JCStatement> translator) {\n+            this.translator = translator;\n+        }\n+\n+        \/\/ Because it returns void, anywhere super() can legally appear must be a location where a JCStatement\n+        \/\/ could also appear, so it's OK that we are replacing a JCExpressionStatement with a JCStatement here.\n+        @Override\n+        public void visitExec(JCExpressionStatement stat) {\n+            if (!TreeInfo.isSuperCall(stat) || (result = this.translator.apply(stat)) == null)\n+                super.visitExec(stat);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":95,"deletions":54,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n@@ -431,1 +432,3 @@\n-                                     .map(TreeInfo::firstConstructorCall)\n+                                     .filter(JCMethodDecl.class::isInstance)\n+                                     .map(JCMethodDecl.class::cast)\n+                                     .map(TreeInfo::findConstructorCall)\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ExpressionToTypeInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-AnonymousInSuperCallNegTest.java:23:49: compiler.err.cant.ref.before.ctor.called: x\n+AnonymousInSuperCallNegTest.java:23:49: compiler.err.no.encl.instance.of.type.in.scope: AnonymousInSuperCallNegTest.JavacBug\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousInSuperCallNegTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8194743\n+ * @summary Permit additional statements before this\/super in constructors\n+ * @compile\/fail\/ref=SuperInitFails.out -XDrawDiagnostics SuperInitFails.java\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+public class SuperInitFails extends AtomicReference<Object> implements Iterable<Object> {\n+\n+    private int x;\n+\n+\/\/\/ GOOD EXAMPLES\n+\n+    public SuperInitFails() {           \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(Object x) {\n+        this.x = x.hashCode();          \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(byte x) {\n+        super();                        \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(char x) {\n+        this((int)x);                   \/\/ this should be OK\n+    }\n+\n+\/\/\/ FAIL EXAMPLES\n+\n+    {\n+        this(1);                        \/\/ this should FAIL\n+    }\n+\n+    {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod1() {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod2() {\n+        this();                         \/\/ this should FAIL\n+    }\n+\n+    void normalMethod3() {\n+        Runnable r = () -> super();     \/\/ this should FAIL\n+    }\n+\n+    void normalMethod4() {\n+        Runnable r = () -> this();      \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(short x) {\n+        hashCode();                     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float x) {\n+        this.hashCode();                \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(int x) {\n+        super.hashCode();               \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(long x) {\n+        SuperInitFails.this.hashCode();      \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(double x) {\n+        SuperInitFails.super.hashCode();     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(byte[] x) {\n+        {\n+            super();                    \/\/ this should FAIL\n+        }\n+    }\n+\n+    public SuperInitFails(char[] x) {\n+        if (x.length == 0)\n+            return;                     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(short[] x) {\n+        this.x = x.length;              \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float[] x) {\n+        System.identityHashCode(this);  \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(int[] x) {\n+        this(this);                     \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(long[] x) {\n+        this(Object.this);              \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(double[] x) {\n+        Iterable.super.spliterator();   \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(byte[][] x) {\n+        super(new Object() {\n+            {\n+                super();                \/\/ this should FAIL\n+            }\n+        });\n+    }\n+\n+    public SuperInitFails(char[][] x) {\n+        new Inner1();                   \/\/ this should FAIL\n+        super();\n+    }\n+\n+    class Inner1 {\n+    }\n+\n+    record Record1(int value) {\n+        Record1(float x) {              \/\/ this should FAIL\n+        }\n+    }\n+\n+    record Record2(int value) {\n+        Record2(float x) {              \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    @Override\n+    public java.util.Iterator<Object> iterator() {\n+        return null;\n+    }\n+\n+    public SuperInitFails(short[][] x) {\n+        class Foo {\n+            Foo() {\n+                SuperInitFails.this.hashCode();\n+            }\n+        };\n+        new Foo();                      \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float[][] x) {\n+        Runnable r = () -> {\n+            super();                    \/\/ this should FAIL\n+        };\n+    }\n+\n+    public SuperInitFails(int[][] z) {\n+        super((Runnable)() -> x);       \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(long[][] z) {\n+        super(new Inner1());            \/\/ this should FAIL\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+SuperInitFails.java:57:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:62:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:67:9: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:72:23: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:77:23: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:94:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:99:33: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:104:14: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:108:20: compiler.err.not.encl.class: java.lang.Object\n+SuperInitFails.java:112:17: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:119:22: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:125:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:133:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n+SuperInitFails.java:138:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n+SuperInitFails.java:154:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:165:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:169:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:33:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:37:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:41:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:45:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:49:33: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:53:32: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:83:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:89:13: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:160:18: compiler.err.ctor.calls.not.allowed.here\n+- compiler.note.preview.filename: SuperInitFails.java, DEFAULT\n+- compiler.note.preview.recompile\n+26 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,480 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8194743\n+ * @summary Test valid placements of super()\/this() in constructors\n+ * @enablePreview\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class SuperInitGood {\n+\n+    SuperInitGood(Object obj) {\n+    }\n+\n+    SuperInitGood(int x) {\n+    }\n+\n+    \/\/ Default constructor provided by compiler\n+    static class Test0 {\n+    }\n+\n+    \/\/ No explicit calls to this()\/super()\n+    static class Test1 {\n+        Test1() {\n+        }\n+        Test1(int a) {\n+            this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Explicit calls to this()\/super()\n+    static class Test2<T> {\n+        static int i;\n+        Test2() {\n+            this(0);\n+        }\n+        Test2(int i) {\n+            Test2.i = i;\n+            super();\n+        }\n+        Test2(T obj) {\n+            this(java.util.Objects.hashCode(obj));\n+        }\n+        public T get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Explicit this()\/super() with stuff in front\n+    static class Test3 {\n+        int x;\n+        final int y;\n+        final int z;\n+\n+        Test3() {\n+            new Object().hashCode();\n+            new Object().hashCode();\n+            super();\n+            this.x = new Object().hashCode();\n+            this.y = new Object().hashCode() % 17;\n+            this.z = this.x + this.y;\n+        }\n+    }\n+\n+    \/\/ Reference within constructor to outer class that's also my superclass\n+    class Test5 extends SuperInitGood {\n+        Test5(Object obj) {\n+            if (obj == null)\n+                throw new IllegalArgumentException();\n+            super(SuperInitGood.this);      \/\/ NOT a 'this' reference\n+        }\n+    }\n+\n+    \/\/ Initialization blocks\n+    class Test6 {\n+        final long startTime;\n+        final int x;\n+        {\n+            this.x = 12;\n+        }\n+        Test6() {\n+            long now = System.nanoTime();\n+            long then = now + 1000000L;\n+            while (System.nanoTime() < then) {\n+                try {\n+                    Thread.sleep(1);\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    break;\n+                }\n+            }\n+            super();\n+            this.startTime = now;\n+        }\n+    }\n+\n+    \/\/ Mix up inner classes, proxies, and super() calls\n+    \/\/ Copied mostly from UnverifiableInitForNestedLocalClassTest.java\n+    public static void test7(final String arg) {\n+        final String inlined = \" inlined \";\n+        class LocalClass {\n+            String m() {\n+                return \"LocalClass \" + arg + inlined;\n+            }\n+\n+            class SubClass extends LocalClass {\n+                @Override\n+                String m() {\n+                    return \"SubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            class SubSubClass extends SubClass {\n+                @Override\n+                String m() {\n+                    return \"SubSubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            class AnotherLocal {\n+                class AnotherSub extends LocalClass {\n+                    AnotherSub() {\n+                    }\n+                    AnotherSub(int x) {\n+                        this((char)x);\n+                    }\n+                    AnotherSub(char y) {\n+                        super();\n+                    }\n+                    @Override\n+                    String m() {\n+                        return \"AnotherSub \" + arg + inlined;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Anonymous inner class\n+    public static void test8() {\n+        new Test2<Byte>(null) {\n+            @Override\n+            public Byte get() {\n+                return (byte)-1;\n+            }\n+        };\n+    }\n+\n+    \/\/ Qualified super() invocation\n+    public static class Test9 extends Test5 {\n+\n+        public Test9(SuperInitGood implicit, Object obj) {\n+            obj.hashCode();\n+            implicit.super(obj);\n+        }\n+    }\n+\n+    \/\/ Copied from WhichImplicitThis6\n+    public static class Test10 {\n+        private int i;\n+        public Test10(int i) {}\n+        public class Sub extends Test10 {\n+            public Sub() {\n+                super(i); \/\/ i is not inherited, so it is the enclosing i\n+            }\n+        }\n+    }\n+\n+    \/\/ Two constructors where only one invokes super()\n+    public static class Test11 {\n+        public Test11() {\n+        }\n+        public Test11(int x) {\n+            super();\n+        }\n+    }\n+\n+    \/\/ Nested version of the previous test\n+    public static class Test12 {\n+        Test12() {\n+            class Sub {\n+                public Sub() {\n+                }\n+                public Sub(int j) {\n+                    super();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested super()'s requiring initialization code appended\n+    public static class Test13 extends SuperInitGood {\n+        final int x = new Object().hashCode();\n+        Test13() {\n+            super(new Object() {\n+                public void foo() {\n+                    class Bar {\n+                        final int y = new Object().hashCode();\n+                        Bar() {\n+                            super();\n+                        }\n+                        Bar(int ignored) {\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Initializer in initializer block\n+    public static class Test14 {\n+        final int x;                \/\/ initialized in constructor\n+        final int y;                \/\/ initialized in initialization block\n+        final int z = 13;           \/\/ initialized with intializer value\n+        public Test14() {\n+            this(0);\n+        }\n+        public Test14(boolean z) {\n+            this.x = z ? 1 : 0;\n+        }\n+        public Test14(int x) {\n+            super();\n+            this.x = x;\n+        }\n+        {\n+            this.y = -1;\n+        }\n+    }\n+\n+    \/\/ Qualified super() invocation with superclass instance\n+    public static class Test15 {\n+\n+        final String name;\n+\n+        public Test15(String name) {\n+            this.name = name;\n+        }\n+\n+        public class Test15b extends Test15 {\n+\n+            public Test15b(String name) {\n+                super(name);\n+            }\n+\n+            public String getName() {\n+                return Test15.this.name;\n+            }\n+        }\n+    }\n+\n+    public static class Test15c extends Test15.Test15b {\n+        public Test15c(Test15 a, String name) {\n+            a.super(name);\n+        }\n+    }\n+\n+    \/\/ Mixing up outer instances, proxies, and initializers\n+    public static class Test16 {\n+\n+        final String x = String.valueOf(new Object().hashCode());\n+\n+        public void run() {\n+\n+            final String y = String.valueOf(new Object().hashCode());\n+\n+            class Sub {\n+\n+                final String z;\n+\n+                Sub(String z, int ignored) {\n+                    this(z, (float)ignored);\n+                }\n+\n+                Sub(String z, float ignored) {\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, byte ignored) {\n+                    super();\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, char ignored) {\n+                    this(z, (int)ignored);\n+                }\n+\n+                String x() {\n+                    return x;\n+                }\n+\n+                String y() {\n+                    return y;\n+                }\n+\n+                String z() {\n+                    return z;\n+                }\n+            }\n+\n+            final String z = String.valueOf(new Object().hashCode());\n+\n+            final Sub[] subs = new Sub[] {\n+                new Sub(z, 1),\n+                new Sub(z, -1),\n+                new Sub(z, (float)0),\n+                new Sub(z, (byte)0),\n+                new Sub(z, (char)0)\n+            };\n+\n+            for (int i = 0; i < subs.length; i++) {\n+                \/\/System.err.println(\"i = \" + i);\n+                final Sub sub = subs[i];\n+                final String subx = sub.x();\n+                final String suby = sub.y();\n+                final String subz = sub.z();\n+                if (!x.equals(subx))\n+                    throw new RuntimeException(\"x=\" + x + \" but sub[\" + i + \"].x()=\" + subx);\n+                if (!y.equals(suby))\n+                    throw new RuntimeException(\"y=\" + y + \" but sub[\" + i + \"].y()=\" + suby);\n+                if (!z.equals(subz))\n+                    throw new RuntimeException(\"z=\" + z + \" but sub[\" + i + \"].z()=\" + subz);\n+            }\n+        }\n+    }\n+\n+    \/\/ Records\n+    public class Test17 {\n+\n+        record Rectangle(float length, float width) { }\n+\n+        record StringHolder(String string) {\n+            StringHolder {\n+                java.util.Objects.requireNonNull(string);\n+            }\n+        }\n+\n+        record ValueHolder(int value) {\n+            ValueHolder(float x) {\n+                if (Float.isNaN(x))\n+                    throw new IllegalArgumentException();\n+                this((int)x);\n+            }\n+        }\n+    }\n+\n+    \/\/ Exceptions thrown by initializer block\n+    public static class Test18 extends AtomicReference<Object> {\n+\n+        {\n+            if ((this.get().hashCode() % 3) == 0)\n+                throw new MyException();\n+        }\n+\n+        public Test18(Object obj) throws MyException {\n+            super(obj);\n+        }\n+\n+        public Test18(boolean fail) throws MyException {\n+            Object obj;\n+            for (obj = new Object(); true; obj = new Object()) {\n+                if (((obj.hashCode() % 3) == 0) != fail)\n+                    continue;\n+                break;\n+            }\n+            this(obj);\n+        }\n+\n+        public static class MyException extends Exception {\n+        }\n+    }\n+\n+    \/\/ super()\/this() within outer try block but inside inner class\n+    public static class Test19 {\n+        public Test19(int x) {\n+            try {\n+                new Test1(x) {\n+                    @Override\n+                    public int hashCode() {\n+                        return x ^ super.hashCode();\n+                    }\n+                };\n+            } catch (StackOverflowError e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ local class declared before super(), but not used until after super()\n+    public static class Test20 {\n+        public Test20() {\n+            class Foo {\n+                Foo() {\n+                    Test20.this.hashCode();\n+                }\n+            }\n+            super();\n+            new Foo();\n+        }\n+    }\n+\n+    \/\/ local class inside super() parameter list\n+    public static class Test21 extends AtomicReference<Object> {\n+        private int x;\n+        public Test21() {\n+            super(switch (\"foo\".hashCode()) {\n+                default -> {\n+                    class Nested {{ System.out.println(x); }}       \/\/ class is NOT instantiated - OK\n+                    yield \"bar\";\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Test0();\n+        new Test1();\n+        new Test1(7);\n+        new Test2<Byte>();\n+        new Test2<>(args);\n+        new Test3();\n+        new SuperInitGood(3).new Test5(3);\n+        new SuperInitGood(3).new Test6();\n+        SuperInitGood.test7(\"foo\");\n+        SuperInitGood.test8();\n+        new Test9(new SuperInitGood(5), \"abc\");\n+        new Test10(7);\n+        new Test11(9);\n+        new Test12();\n+        new Test13();\n+        Test14 t14 = new Test14();\n+        assert t14.x == 0 && t14.y == -1 && t14.z == 13;\n+        t14 = new Test14(7);\n+        assert t14.x == 7 && t14.y == -1 && t14.z == 13;\n+        new Test15c(new Test15(\"foo\"), \"bar\");\n+        new Test16().run();\n+        new Test17.StringHolder(\"foo\");\n+        try {\n+            new Test17.StringHolder(null);\n+            throw new Error();\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(true);\n+            assert false : \"expected exception\";\n+        } catch (Test18.MyException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(false);\n+        } catch (Test18.MyException e) {\n+            assert false : \"unexpected exception: \" + e;\n+        }\n+        new Test19(123);\n+        new Test20();\n+        new Test21();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":480,"deletions":0,"binary":false,"changes":480,"status":"added"},{"patch":"@@ -144,1 +144,0 @@\n-compiler.warn.preview.feature.use                       # preview feature support: not generated currently\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.call.must.be.first.stmt.in.ctor\n-\n-class CallMustBeFirst {\n-    CallMustBeFirst() {\n-        int i = 0;\n-        super();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallMustBeFirst.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -24,5 +24,5 @@\n- \/**\n-  * A no-op Java agent.\n-  *\/\n-public class JavaAgent {\n-    public static void agentmain(String args) {\n+\/\/ key: compiler.err.call.must.only.appear.in.ctor\n+\n+class CallOnlyInConstructor {\n+    void foo() {\n+        super();\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/jdk\/sun\/tools\/jcmd\/JavaAgent.java","status":"copied"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.ctor.calls.not.allowed.here\n+\n+class CallsNotAllowedHere {\n+    public CallsNotAllowedHere() {\n+        {\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallsNotAllowedHere.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.super.init\n+ \/\/ key: compiler.warn.preview.feature.use\n+ \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FeatureStatementsBeforeSuper {\n+    FeatureStatementsBeforeSuper() {\n+        System.out.println();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureStatementsBeforeSuper.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.first.statement.must.be.call.to.another.constructor\n+\/\/ key: compiler.err.non.canonical.constructor.invoke.another.constructor\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FirstInvocationMustBeAnotherConstructor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.redundant.superclass.init\n+\n+class RedundantSuperclassInit {\n+    RedundantSuperclassInit() {\n+        super();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RedundantSuperclassInit.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.return.before.superclass.initialized\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class ReturnBeforeSuperclassInit {\n+    ReturnBeforeSuperclassInit(boolean maybe) {\n+        if (maybe)\n+            return;\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -406,2 +406,2 @@\n-        \/\/ first invocation should be one to the canonical\n-        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+        \/\/ constructor is not canonical, so it must only invoke another constructor\n+        assertFail(\"compiler.err.non.canonical.constructor.invoke.another.constructor\",\n@@ -410,1 +410,1 @@\n-        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+        assertFail(\"compiler.err.non.canonical.constructor.invoke.another.constructor\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}