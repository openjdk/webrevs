{"files":[{"patch":"@@ -2064,0 +2064,5 @@\n+size_t G1CollectedHeap::soft_max_capacity() const {\n+  return clamp(align_up(SoftMaxHeapSize, HeapAlignment), MinHeapSize,\n+               max_capacity());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1203,0 +1203,3 @@\n+  \/\/ Print the soft maximum heap capacity.\n+  size_t soft_max_capacity() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-  if (_g1h->capacity() <= _g1h->max_capacity() \/ 2) {\n-    threshold *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n+  if (_g1h->capacity() <= _g1h->soft_max_capacity() \/ 2) {\n+    threshold *= (double)_g1h->capacity() \/ (double)(_g1h->soft_max_capacity() \/ 2);\n@@ -94,0 +94,1 @@\n+  size_t soft_max_capacity = _g1h->soft_max_capacity();\n@@ -95,1 +96,1 @@\n-  if (_g1h->capacity() == _g1h->max_capacity()) {\n+  if (_g1h->capacity() >= soft_max_capacity) {\n@@ -126,1 +127,0 @@\n-    size_t reserved_bytes = _g1h->max_capacity();\n@@ -128,1 +128,1 @@\n-    size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n+    size_t uncommitted_bytes = soft_max_capacity - committed_bytes;\n@@ -246,1 +246,2 @@\n-  \/\/ Should not be greater than the heap max size. No need to adjust\n+  size_t soft_max_capacity = _g1h->soft_max_capacity();\n+  \/\/ Should not be greater than the soft max capacity. No need to adjust\n@@ -249,5 +250,4 @@\n-  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n-  \/\/ Should not be less than the heap min size. No need to adjust it\n-  \/\/ with respect to the heap max size as it's an upper bound (i.e.,\n-  \/\/ we'll try to make the capacity smaller than it, not greater).\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n+  minimum_desired_capacity = MIN2(minimum_desired_capacity, soft_max_capacity);\n+  \/\/ Should not be less than the heap min size, and should not exceed\n+  \/\/ the soft max capacity.\n+  maximum_desired_capacity = clamp(maximum_desired_capacity, MinHeapSize, soft_max_capacity);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -53,0 +53,6 @@\n+size_t G1IHOPControl::default_conc_mark_start_threshold() {\n+  guarantee(_target_occupancy > 0, \"Target occupancy must have been initialized.\");\n+  size_t actual_target_occupancy = MIN2(G1CollectedHeap::heap()->soft_max_capacity(), _target_occupancy);\n+  return (size_t) (_initial_ihop_percent * actual_target_occupancy \/ 100.0);\n+}\n+\n@@ -112,1 +118,1 @@\n-    G1CollectedHeap::heap()->max_capacity() * (100.0 - safe_total_heap_percentage) \/ 100.0,\n+    G1CollectedHeap::heap()->soft_max_capacity() * (100.0 - safe_total_heap_percentage) \/ 100.0,\n@@ -145,1 +151,1 @@\n-    return (size_t)(_initial_ihop_percent * _target_occupancy \/ 100.0);\n+    return default_conc_mark_start_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,4 @@\n+\n+  \/\/ Default non-young occupancy at which concurrent marking should start.\n+  size_t default_conc_mark_start_threshold();\n+\n@@ -95,2 +99,1 @@\n-    guarantee(_target_occupancy > 0, \"Target occupancy must have been initialized.\");\n-    return (size_t) (_initial_ihop_percent * _target_occupancy \/ 100.0);\n+    return default_conc_mark_start_threshold();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}