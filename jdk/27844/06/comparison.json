{"files":[{"patch":"@@ -35,1 +35,1 @@\n-  dis address [ length ]  <font color=\"red\">disassemble (x86) specified number of instructions from given address<\/font>\n+  dis address [ length ]  <font color=\"red\">disassemble (requires hsdis) specified number of instructions from given address<\/font>\n","filename":"src\/jdk.hotspot.agent\/doc\/clhsdb.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- <li> native disassembly (x86 only) and nmethod disassembly with annotations for safepoint details.\n+ <li> native disassembly (requires hsdis) and nmethod disassembly with annotations for safepoint details.\n","filename":"src\/jdk.hotspot.agent\/doc\/hsdb.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,8 +43,0 @@\n-#if defined(i386) && !defined(i586)\n-#define i586 1\n-#endif\n-\n-#ifdef i586\n-#include \"sun_jvm_hotspot_debugger_x86_X86ThreadContext.h\"\n-#endif\n-\n@@ -414,1 +406,1 @@\n-#if defined(i586) || defined(amd64) || defined(ppc64) || defined(ppc64le) || defined(aarch64) || defined(riscv64)\n+#if defined(amd64) || defined(ppc64) || defined(ppc64le) || defined(aarch64) || defined(riscv64)\n@@ -436,3 +428,0 @@\n-#ifdef i586\n-#define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG\n-#endif\n@@ -459,21 +448,0 @@\n-#ifdef i586\n-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##reg\n-\n-  regs[REG_INDEX(GS)]  = (uintptr_t) gregs.xgs;\n-  regs[REG_INDEX(FS)]  = (uintptr_t) gregs.xfs;\n-  regs[REG_INDEX(ES)]  = (uintptr_t) gregs.xes;\n-  regs[REG_INDEX(DS)]  = (uintptr_t) gregs.xds;\n-  regs[REG_INDEX(EDI)] = (uintptr_t) gregs.edi;\n-  regs[REG_INDEX(ESI)] = (uintptr_t) gregs.esi;\n-  regs[REG_INDEX(FP)] = (uintptr_t) gregs.ebp;\n-  regs[REG_INDEX(SP)] = (uintptr_t) gregs.esp;\n-  regs[REG_INDEX(EBX)] = (uintptr_t) gregs.ebx;\n-  regs[REG_INDEX(EDX)] = (uintptr_t) gregs.edx;\n-  regs[REG_INDEX(ECX)] = (uintptr_t) gregs.ecx;\n-  regs[REG_INDEX(EAX)] = (uintptr_t) gregs.eax;\n-  regs[REG_INDEX(PC)] = (uintptr_t) gregs.eip;\n-  regs[REG_INDEX(CS)]  = (uintptr_t) gregs.xcs;\n-  regs[REG_INDEX(SS)]  = (uintptr_t) gregs.xss;\n-\n-#endif \/* i586 *\/\n-\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.cpp","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -203,12 +203,0 @@\n-#ifdef i386\n-      \/\/ print the regset\n-      print_debug(\"\\teax = 0x%x\\n\", newthr->regs.eax);\n-      print_debug(\"\\tebx = 0x%x\\n\", newthr->regs.ebx);\n-      print_debug(\"\\tecx = 0x%x\\n\", newthr->regs.ecx);\n-      print_debug(\"\\tedx = 0x%x\\n\", newthr->regs.edx);\n-      print_debug(\"\\tesp = 0x%x\\n\", newthr->regs.esp);\n-      print_debug(\"\\tebp = 0x%x\\n\", newthr->regs.ebp);\n-      print_debug(\"\\tesi = 0x%x\\n\", newthr->regs.esi);\n-      print_debug(\"\\tedi = 0x%x\\n\", newthr->regs.edi);\n-      print_debug(\"\\teip = 0x%x\\n\", newthr->regs.eip);\n-#endif\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -817,12 +817,0 @@\n-#if defined(i586) || defined(i386)\n-      \/\/ print the regset\n-      print_debug(\"\\teax = 0x%x\\n\", newthr->regs.r_eax);\n-      print_debug(\"\\tebx = 0x%x\\n\", newthr->regs.r_ebx);\n-      print_debug(\"\\tecx = 0x%x\\n\", newthr->regs.r_ecx);\n-      print_debug(\"\\tedx = 0x%x\\n\", newthr->regs.r_edx);\n-      print_debug(\"\\tesp = 0x%x\\n\", newthr->regs.r_esp);\n-      print_debug(\"\\tebp = 0x%x\\n\", newthr->regs.r_ebp);\n-      print_debug(\"\\tesi = 0x%x\\n\", newthr->regs.r_esi);\n-      print_debug(\"\\tedi = 0x%x\\n\", newthr->regs.r_edi);\n-      print_debug(\"\\teip = 0x%x\\n\", newthr->regs.r_eip);\n-#endif\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/ps_core.c","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-              \/\/ For C2, which has null frame pointers on x86\/amd64\/aarch64\n+              \/\/ For C2, which has null frame pointers on amd64\/aarch64\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.jvm.hotspot.debugger.MachineDescriptionIntelX86;\n@@ -525,3 +524,1 @@\n-        if (cpu.equals(\"x86\")) {\n-            machDesc = new MachineDescriptionIntelX86();\n-        } else if (cpu.equals(\"amd64\")) {\n+        if (cpu.equals(\"amd64\")) {\n@@ -532,1 +529,1 @@\n-            throw new DebuggerException(\"Win32 supported under x86, amd64 and aarch64 only\");\n+            throw new DebuggerException(\"Win32 supported under amd64 and aarch64 only\");\n@@ -557,3 +554,1 @@\n-        if (cpu.equals(\"x86\")) {\n-            machDesc = new MachineDescriptionIntelX86();\n-        } else if (cpu.equals(\"amd64\")) {\n+        if (cpu.equals(\"amd64\")) {\n@@ -595,3 +590,1 @@\n-        if (cpu.equals(\"x86\")) {\n-            machDesc = new MachineDescriptionIntelX86();\n-        } else if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n+        if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n@@ -600,1 +593,1 @@\n-            throw new DebuggerException(\"BSD only supported on x86\/x86_64. Current arch: \" + cpu);\n+            throw new DebuggerException(\"BSD only supported on x86_64. Current arch: \" + cpu);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-      the local system). Typical return value is \"x86\"; see\n+      the local system). Typical return value is \"amd64\"; see\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/Debugger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger;\n-\n-public class MachineDescriptionIntelX86 extends MachineDescriptionTwosComplement implements MachineDescription {\n-  public long getAddressSize() {\n-    return 4;\n-  }\n-\n-  public boolean isBigEndian() {\n-    return false;\n-  }\n-\n-  public boolean supports32bitAlignmentOf64bitTypes() {\n-    return true;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/MachineDescriptionIntelX86.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.jvm.hotspot.debugger.x86.*;\n@@ -35,1 +34,0 @@\n-import sun.jvm.hotspot.debugger.bsd.x86.*;\n@@ -89,8 +87,1 @@\n-    if (cpu.equals(\"x86\")) {\n-       X86ThreadContext context = (X86ThreadContext) thread.getContext();\n-       Address ebp = context.getRegisterAsAddress(X86ThreadContext.EBP);\n-       if (ebp == null) return null;\n-       Address pc  = context.getRegisterAsAddress(X86ThreadContext.EIP);\n-       if (pc == null) return null;\n-       return new BsdX86CFrame(dbg, ebp, pc);\n-    } else if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n+    if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdCDebugger.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import sun.jvm.hotspot.debugger.bsd.x86.*;\n@@ -35,3 +34,1 @@\n-      if (cpu.equals(\"x86\")) {\n-         return new BsdX86ThreadContext(dbg);\n-      } else if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n+      if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdThreadContextFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.bsd.*;\n-import sun.jvm.hotspot.debugger.cdbg.*;\n-import sun.jvm.hotspot.debugger.cdbg.basic.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-\n-public final class BsdX86CFrame extends BasicCFrame {\n-   \/\/ package\/class internals only\n-   public BsdX86CFrame(BsdDebugger dbg, Address ebp, Address pc) {\n-      super(dbg.getCDebugger());\n-      this.ebp = ebp;\n-      this.pc = pc;\n-      this.dbg = dbg;\n-   }\n-\n-   \/\/ override base class impl to avoid ELF parsing\n-   public ClosestSymbol closestSymbolToPC() {\n-      \/\/ try native lookup in debugger.\n-      return dbg.lookup(dbg.getAddressValue(pc()));\n-   }\n-\n-   public Address pc() {\n-      return pc;\n-   }\n-\n-   public Address localVariableBase() {\n-      return ebp;\n-   }\n-\n-   public CFrame sender(ThreadProxy thread) {\n-      X86ThreadContext context = (X86ThreadContext) thread.getContext();\n-      Address esp = context.getRegisterAsAddress(X86ThreadContext.ESP);\n-\n-      if ( (ebp == null) || ebp.lessThan(esp) ) {\n-        return null;\n-      }\n-\n-      Address nextEBP = ebp.getAddressAt( 0 * ADDRESS_SIZE);\n-      if (nextEBP == null) {\n-        return null;\n-      }\n-      Address nextPC  = ebp.getAddressAt( 1 * ADDRESS_SIZE);\n-      if (nextPC == null) {\n-        return null;\n-      }\n-      return new BsdX86CFrame(dbg, nextEBP, nextPC);\n-   }\n-\n-   private static final int ADDRESS_SIZE = 4;\n-   private Address pc;\n-   private Address ebp;\n-   private BsdDebugger dbg;\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/x86\/BsdX86CFrame.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.bsd.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.debugger.bsd.*;\n-\n-public class BsdX86ThreadContext extends X86ThreadContext {\n-  private BsdDebugger debugger;\n-\n-  public BsdX86ThreadContext(BsdDebugger debugger) {\n-    super();\n-    this.debugger = debugger;\n-  }\n-\n-  public void setRegisterAsAddress(int index, Address value) {\n-    setRegister(index, debugger.getAddressValue(value));\n-  }\n-\n-  public Address getRegisterAsAddress(int index) {\n-    return debugger.newAddress(getRegister(index));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/x86\/BsdX86ThreadContext.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -62,1 +62,1 @@\n-      base-of-frame pointer (EBP on x86, FP\/I6 on SPARC). *\/\n+      base-of-frame pointer (RBP on amd64, FP\/I6 on SPARC). *\/\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/cdbg\/CFrame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.jvm.hotspot.debugger.x86.*;\n@@ -38,1 +37,0 @@\n-import sun.jvm.hotspot.debugger.linux.x86.*;\n@@ -84,8 +82,1 @@\n-    if (cpu.equals(\"x86\")) {\n-       X86ThreadContext context = (X86ThreadContext) thread.getContext();\n-       Address ebp = context.getRegisterAsAddress(X86ThreadContext.EBP);\n-       if (ebp == null) return null;\n-       Address pc  = context.getRegisterAsAddress(X86ThreadContext.EIP);\n-       if (pc == null) return null;\n-       return new LinuxX86CFrame(dbg, ebp, pc);\n-    } else if (cpu.equals(\"amd64\")) {\n+    if (cpu.equals(\"amd64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxCDebugger.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import sun.jvm.hotspot.debugger.linux.x86.*;\n@@ -36,3 +35,1 @@\n-      if (cpu.equals(\"x86\")) {\n-         return new LinuxX86ThreadContext(dbg);\n-      } else if (cpu.equals(\"amd64\")) {\n+      if (cpu.equals(\"amd64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxThreadContextFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.linux.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.linux.*;\n-import sun.jvm.hotspot.debugger.cdbg.*;\n-import sun.jvm.hotspot.debugger.cdbg.basic.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-\n-public final class LinuxX86CFrame extends BasicCFrame {\n-   \/\/ package\/class internals only\n-   public LinuxX86CFrame(LinuxDebugger dbg, Address ebp, Address pc) {\n-      super(dbg.getCDebugger());\n-      this.ebp = ebp;\n-      this.pc = pc;\n-      this.dbg = dbg;\n-   }\n-\n-   \/\/ override base class impl to avoid ELF parsing\n-   public ClosestSymbol closestSymbolToPC() {\n-      \/\/ try native lookup in debugger.\n-      return dbg.lookup(dbg.getAddressValue(pc()));\n-   }\n-\n-   public Address pc() {\n-      return pc;\n-   }\n-\n-   public Address localVariableBase() {\n-      return ebp;\n-   }\n-\n-   public CFrame sender(ThreadProxy thread) {\n-      X86ThreadContext context = (X86ThreadContext) thread.getContext();\n-      \/*\n-       * Native code fills in the stack pointer register value using index\n-       * X86ThreadContext.SP.\n-       * See file LinuxDebuggerLocal.c macro REG_INDEX(reg).\n-       *\n-       * Be sure to use SP, or UESP which is aliased to SP in Java code,\n-       * for the frame pointer validity check.\n-       *\/\n-      Address esp = context.getRegisterAsAddress(X86ThreadContext.SP);\n-\n-      if ( (ebp == null) || ebp.lessThan(esp) ) {\n-        return null;\n-      }\n-\n-      \/\/ Check alignment of ebp\n-      if ( dbg.getAddressValue(ebp) % ADDRESS_SIZE != 0) {\n-        return null;\n-      }\n-\n-      Address nextEBP = ebp.getAddressAt( 0 * ADDRESS_SIZE);\n-      if (nextEBP == null || nextEBP.lessThanOrEqual(ebp)) {\n-        return null;\n-      }\n-      Address nextPC  = ebp.getAddressAt( 1 * ADDRESS_SIZE);\n-      if (nextPC == null) {\n-        return null;\n-      }\n-      return new LinuxX86CFrame(dbg, nextEBP, nextPC);\n-   }\n-\n-   private static final int ADDRESS_SIZE = 4;\n-   private Address pc;\n-   private Address ebp;\n-   private LinuxDebugger dbg;\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/x86\/LinuxX86CFrame.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.linux.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.debugger.linux.*;\n-\n-public class LinuxX86ThreadContext extends X86ThreadContext {\n-  private LinuxDebugger debugger;\n-\n-  public LinuxX86ThreadContext(LinuxDebugger debugger) {\n-    super();\n-    this.debugger = debugger;\n-  }\n-\n-  public void setRegisterAsAddress(int index, Address value) {\n-    setRegister(index, debugger.getAddressValue(value));\n-  }\n-\n-  public Address getRegisterAsAddress(int index) {\n-    return debugger.newAddress(getRegister(index));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/x86\/LinuxX86ThreadContext.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.jvm.hotspot.debugger.remote.x86.*;\n@@ -58,3 +57,1 @@\n-      if (cpu.equals(\"x86\")) {\n-        threadFactory = new RemoteX86ThreadFactory(this);\n-      } else if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n+      if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/RemoteDebuggerClient.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.remote.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.debugger.remote.*;\n-import sun.jvm.hotspot.utilities.*;\n-\n-public class RemoteX86Thread extends RemoteThread  {\n-  public RemoteX86Thread(RemoteDebuggerClient debugger, Address addr) {\n-     super(debugger, addr);\n-  }\n-\n-  public RemoteX86Thread(RemoteDebuggerClient debugger, long id) {\n-     super(debugger, id);\n-  }\n-\n-  public ThreadContext getContext() throws IllegalThreadStateException {\n-    RemoteX86ThreadContext context = new RemoteX86ThreadContext(debugger);\n-    long[] regs = (addr != null)? debugger.getThreadIntegerRegisterSet(addr) :\n-                                  debugger.getThreadIntegerRegisterSet(id);\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(regs.length == X86ThreadContext.NPRGREG, \"size of register set must match\");\n-    }\n-    for (int i = 0; i < regs.length; i++) {\n-      context.setRegister(i, regs[i]);\n-    }\n-    return context;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/x86\/RemoteX86Thread.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.remote.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.debugger.remote.*;\n-\n-public class RemoteX86ThreadContext extends X86ThreadContext {\n-  private RemoteDebuggerClient debugger;\n-\n-  public RemoteX86ThreadContext(RemoteDebuggerClient debugger) {\n-    super();\n-    this.debugger = debugger;\n-  }\n-\n-  \/** This can't be implemented in this class since we would have to\n-      tie the implementation to, for example, the debugging system *\/\n-  public void setRegisterAsAddress(int index, Address value) {\n-    setRegister(index, debugger.getAddressValue(value));\n-  }\n-\n-  \/** This can't be implemented in this class since we would have to\n-      tie the implementation to, for example, the debugging system *\/\n-  public Address getRegisterAsAddress(int index) {\n-    return debugger.newAddress(getRegister(index));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/x86\/RemoteX86ThreadContext.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.remote.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.remote.*;\n-\n-public class RemoteX86ThreadFactory implements RemoteThreadFactory {\n-  private RemoteDebuggerClient debugger;\n-\n-  public RemoteX86ThreadFactory(RemoteDebuggerClient debugger) {\n-    this.debugger = debugger;\n-  }\n-\n-  public ThreadProxy createThreadWrapper(Address threadIdentifierAddr) {\n-    return new RemoteX86Thread(debugger, threadIdentifierAddr);\n-  }\n-\n-  public ThreadProxy createThreadWrapper(long id) {\n-    return new RemoteX86Thread(debugger, id);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/x86\/RemoteX86ThreadFactory.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.win32.coff;\n-\n-public interface DebugVC50X86RegisterEnums {\n-  \/** 8-bit registers *\/\n-  public static final int NONE = 0;\n-  public static final int AL = 1;\n-  public static final int CL = 2;\n-  public static final int DL = 3;\n-  public static final int BL = 4;\n-  public static final int AH = 5;\n-  public static final int CH = 6;\n-  public static final int DH = 7;\n-  public static final int BH = 8;\n-\n-  \/** 16-bit registers *\/\n-  public static final int AX = 9;\n-  public static final int CX = 10;\n-  public static final int DX = 11;\n-  public static final int BX = 12;\n-  public static final int SP = 13;\n-  public static final int BP = 14;\n-  public static final int SI = 15;\n-  public static final int DI = 16;\n-\n-  \/** 32-bit registers *\/\n-  public static final int EAX = 17;\n-  public static final int ECX = 18;\n-  public static final int EDX = 19;\n-  public static final int EBX = 20;\n-  public static final int ESP = 21;\n-  public static final int EBP = 22;\n-  public static final int ESI = 23;\n-  public static final int EDI = 24;\n-\n-  \/** Segment registers *\/\n-  public static final int ES = 25;\n-  public static final int CS = 26;\n-  public static final int SS = 27;\n-  public static final int DS = 28;\n-  public static final int FS = 29;\n-  public static final int GS = 30;\n-\n-  \/** Special cases *\/\n-  public static final int IP = 31;\n-  public static final int FLAGS = 32;\n-  public static final int EIP = 33;\n-  public static final int EFLAGS = 34;\n-\n-  \/** PCODE Registers *\/\n-  public static final int TEMP = 40;\n-  public static final int TEMPH = 41;\n-  public static final int QUOTE = 42;\n-\n-  \/** System Registers *\/\n-  public static final int CR0 = 80;\n-  public static final int CR1 = 81;\n-  public static final int CR2 = 82;\n-  public static final int CR3 = 83;\n-  public static final int DR0 = 90;\n-  public static final int DR1 = 91;\n-  public static final int DR2 = 92;\n-  public static final int DR3 = 93;\n-  public static final int DR4 = 94;\n-  public static final int DR5 = 95;\n-  public static final int DR6 = 96;\n-  public static final int DR7 = 97;\n-\n-  \/** Register extensions for 80x87 *\/\n-  public static final int ST0 = 128;\n-  public static final int ST1 = 129;\n-  public static final int ST2 = 130;\n-  public static final int ST3 = 131;\n-  public static final int ST4 = 132;\n-  public static final int ST5 = 133;\n-  public static final int ST6 = 134;\n-  public static final int ST7 = 135;\n-  public static final int CONTROL = 136;\n-  public static final int STATUS = 137;\n-  public static final int TAG = 138;\n-  public static final int FPIP = 139;\n-  public static final int FPCS = 140;\n-  public static final int FPDO = 141;\n-  public static final int FPDS = 142;\n-  public static final int ISEM = 143;\n-  public static final int FPEIP = 144;\n-  public static final int FPEDO = 145;\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/win32\/coff\/DebugVC50X86RegisterEnums.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -54,3 +54,2 @@\n-  \/\/ the same order as in the DbxDebugger for Solaris\/x86 or amd64; that is,\n-  \/\/ the indices match those in debugger\/x86\/X86ThreadContext.java or\n-  \/\/ debugger\/amd64\/AMD64ThreadContext.java.\n+  \/\/ the same order as in the DbxDebugger for Solaris\/amd64; that is,\n+  \/\/ the indices match those in debugger\/amd64\/AMD64ThreadContext.java.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebugger.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -526,3 +526,1 @@\n-      if (cpu.equals(\"x86\")) {\n-          searchList.add(DTFWHome + \" (x86)\");\n-      } else if (cpu.equals(\"amd64\")) {\n+      if (cpu.equals(\"amd64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.debugger.x86;\n-\n-import java.lang.annotation.Native;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.cdbg.*;\n-\n-\/** Specifies the thread context on x86 platforms; only a sub-portion\n-    of the context is guaranteed to be present on all operating\n-    systems. *\/\n-\n-public abstract class X86ThreadContext implements ThreadContext {\n-  \/\/ Taken from \/usr\/include\/ia32\/sys\/reg.h on Solaris\/x86\n-\n-  \/\/ NOTE: the indices for the various registers must be maintained as\n-  \/\/ listed across various operating systems. However, only a small\n-  \/\/ subset of the registers' values are guaranteed to be present (and\n-  \/\/ must be present for the SA's stack walking to work): EAX, EBX,\n-  \/\/ ECX, EDX, ESI, EDI, EBP, ESP, and EIP.\n-\n-  \/\/ One instance of the Native annotation is enough to trigger header generation\n-  \/\/ for this file.\n-  @Native\n-  public static final int GS = 0;\n-  public static final int FS = 1;\n-  public static final int ES = 2;\n-  public static final int DS = 3;\n-  public static final int EDI = 4;\n-  public static final int ESI = 5;\n-  public static final int EBP = 6;\n-  public static final int ESP = 7;\n-  public static final int EBX = 8;\n-  public static final int EDX = 9;\n-  public static final int ECX = 10;\n-  public static final int EAX = 11;\n-  public static final int TRAPNO = 12;\n-  public static final int ERR = 13;\n-  public static final int EIP = 14;\n-  public static final int CS = 15;\n-  public static final int EFL = 16;\n-  public static final int UESP = 17;\n-  public static final int SS = 18;\n-  \/\/ Additional state (not in reg.h) for debug registers\n-  public static final int DR0 = 19;\n-  public static final int DR1 = 20;\n-  public static final int DR2 = 21;\n-  public static final int DR3 = 22;\n-  public static final int DR6 = 23;\n-  public static final int DR7 = 24;\n-\n-\n-  public static final int PC = EIP;\n-  public static final int FP = EBP;\n-  public static final int SP = UESP;\n-  public static final int PS = EFL;\n-  public static final int R0 = EAX;\n-  public static final int R1 = EDX;\n-\n-  public static final int NPRGREG = 25;\n-\n-  private static final String[] regNames = {\n-    \"GS\",     \"FS\",    \"ES\",    \"DS\",\n-    \"EDI\",    \"ESI\",   \"EBP\",   \"ESP\",\n-    \"EBX\",    \"EDX\",   \"ECX\",   \"EAX\",\n-    \"TRAPNO\", \"ERR\",   \"EIP\",   \"CS\",\n-    \"EFLAGS\", \"UESP\",  \"SS\",\n-    \"DR0\",    \"DR1\",   \"DR2\",   \"DR3\",\n-    \"DR6\",    \"DR7\"\n-  };\n-\n-  \/\/ Ought to be int on x86 but we're stuck\n-  private long[] data;\n-\n-  public X86ThreadContext() {\n-    data = new long[NPRGREG];\n-  }\n-\n-  public int getNumRegisters() {\n-    return NPRGREG;\n-  }\n-\n-  public String getRegisterName(int index) {\n-    return regNames[index];\n-  }\n-\n-  public void setRegister(int index, long value) {\n-    data[index] = value;\n-  }\n-\n-  public long getRegister(int index) {\n-    return data[index];\n-  }\n-\n-  public CFrame getTopFrame(Debugger dbg) {\n-    return null;\n-  }\n-\n-  \/** This can't be implemented in this class since we would have to\n-      tie the implementation to, for example, the debugging system *\/\n-  public abstract void setRegisterAsAddress(int index, Address value);\n-\n-  \/** This can't be implemented in this class since we would have to\n-      tie the implementation to, for example, the debugging system *\/\n-  public abstract Address getRegisterAsAddress(int index);\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/x86\/X86ThreadContext.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -44,1 +44,1 @@\n-  \/\/ FIXME: must figure out whether word swapping is necessary on x86\n+  \/\/ FIXME: must figure out whether word swapping is necessary on amd64\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/StackValueCollection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.jvm.hotspot.runtime.linux_x86.LinuxX86JavaThreadPDAccess;\n@@ -38,1 +37,0 @@\n-import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;\n@@ -104,3 +102,1 @@\n-            if (cpu.equals(\"x86\")) {\n-                access = new LinuxX86JavaThreadPDAccess();\n-            } else if (cpu.equals(\"amd64\")) {\n+            if (cpu.equals(\"amd64\")) {\n@@ -126,3 +122,1 @@\n-            if (cpu.equals(\"x86\")) {\n-                access = new BsdX86JavaThreadPDAccess();\n-            } else if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n+            if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -884,1 +884,1 @@\n-      JavaThread.currentFrameGuess() on x86. *\/\n+      JavaThread.currentFrameGuess() on amd64. *\/\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import sun.jvm.hotspot.runtime.x86.*;\n+import sun.jvm.hotspot.runtime.amd64.*;\n@@ -70,1 +70,1 @@\n-    X86Frame f = new X86Frame(sp, fp, pc);\n+    AMD64Frame f = new AMD64Frame(sp, fp, pc);\n@@ -266,1 +266,1 @@\n-            Frame frame = new X86Frame(curSP, null, pc);\n+            Frame frame = new AMD64Frame(curSP, null, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/amd64\/AMD64CurrentFrameGuess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,572 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime.amd64;\n+\n+import java.util.*;\n+import sun.jvm.hotspot.code.*;\n+import sun.jvm.hotspot.compiler.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.oops.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+\/** Specialization of and implementation of abstract methods of the\n+    Frame class for the x86_64 family of CPUs. *\/\n+\n+public class AMD64Frame extends Frame {\n+  private static final boolean DEBUG;\n+  static {\n+    DEBUG = System.getProperty(\"sun.jvm.hotspot.runtime.amd64.AMD64Frame.DEBUG\") != null;\n+  }\n+\n+  \/\/ All frames\n+  private static final int LINK_OFFSET                =  0;\n+  private static final int RETURN_ADDR_OFFSET         =  1;\n+  private static final int SENDER_SP_OFFSET           =  2;\n+\n+  \/\/ Interpreter frames\n+  private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -1;\n+  private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;\n+  private static final int INTERPRETER_FRAME_METHOD_OFFSET    = INTERPRETER_FRAME_LAST_SP_OFFSET - 1;\n+  private static       int INTERPRETER_FRAME_MIRROR_OFFSET;\n+  private static       int INTERPRETER_FRAME_MDX_OFFSET;         \/\/ Non-core builds only\n+  private static       int INTERPRETER_FRAME_CACHE_OFFSET;\n+  private static       int INTERPRETER_FRAME_LOCALS_OFFSET;\n+  private static       int INTERPRETER_FRAME_BCX_OFFSET;\n+  private static       int INTERPRETER_FRAME_INITIAL_SP_OFFSET;\n+  private static       int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET;\n+  private static       int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET;\n+\n+  \/\/ Entry frames\n+  private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET;\n+\n+  private static VMReg rbp;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    INTERPRETER_FRAME_MIRROR_OFFSET               = INTERPRETER_FRAME_METHOD_OFFSET - 1;\n+    INTERPRETER_FRAME_MDX_OFFSET                  = INTERPRETER_FRAME_MIRROR_OFFSET - 1;\n+    INTERPRETER_FRAME_CACHE_OFFSET                = INTERPRETER_FRAME_MDX_OFFSET - 1;\n+    INTERPRETER_FRAME_LOCALS_OFFSET               = INTERPRETER_FRAME_CACHE_OFFSET - 1;\n+    INTERPRETER_FRAME_BCX_OFFSET                  = INTERPRETER_FRAME_LOCALS_OFFSET - 1;\n+    INTERPRETER_FRAME_INITIAL_SP_OFFSET           = INTERPRETER_FRAME_BCX_OFFSET - 1;\n+    INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;\n+    INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;\n+\n+    ENTRY_FRAME_CALL_WRAPPER_OFFSET = db.lookupIntConstant(\"frame::entry_frame_call_wrapper_offset\");\n+    if (VM.getVM().getAddressSize() == 4) {\n+      rbp = new VMReg(5);\n+    } else {\n+      rbp = new VMReg(5 << 1);\n+    }\n+  }\n+\n+\n+  \/\/ an additional field beyond sp and pc:\n+  Address raw_fp; \/\/ frame pointer\n+  private Address raw_unextendedSP;\n+  private Address live_bcp;\n+\n+  private AMD64Frame() {\n+  }\n+\n+  private void initFrame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {\n+    this.raw_sp = raw_sp;\n+    this.raw_fp = raw_fp;\n+    if (raw_unextendedSp == null) {\n+        this.raw_unextendedSP = raw_sp;\n+    } else {\n+        this.raw_unextendedSP = raw_unextendedSp;\n+    }\n+    if (pc == null) {\n+        this.pc = raw_sp.getAddressAt(-1 * VM.getVM().getAddressSize());\n+    } else {\n+        this.pc = pc;\n+    }\n+    this.live_bcp = live_bcp;\n+\n+    \/\/ Frame must be fully constructed before this call\n+    adjustForDeopt();\n+  }\n+\n+\n+  public AMD64Frame(Address raw_sp, Address raw_fp, Address pc) {\n+    initFrame(raw_sp, raw_fp, pc, null, null);\n+\n+    if (DEBUG) {\n+      System.out.println(\"AMD64Frame(sp, fp, pc): \" + this);\n+      dumpStack();\n+    }\n+  }\n+\n+  public AMD64Frame(Address raw_sp, Address raw_fp) {\n+    initFrame(raw_sp, raw_fp, null, null, null);\n+\n+    if (DEBUG) {\n+      System.out.println(\"AMD64Frame(sp, fp): \" + this);\n+      dumpStack();\n+    }\n+  }\n+\n+  public AMD64Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {\n+    initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, null);\n+\n+    if (DEBUG) {\n+      System.out.println(\"AMD64Frame(sp, unextendedSP, fp, pc): \" + this);\n+      dumpStack();\n+    }\n+  }\n+\n+  public AMD64Frame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {\n+    initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, live_bcp);\n+\n+    if (DEBUG) {\n+      System.out.println(\"AMD64Frame(sp, fp, pc, unextendedSP, live_bcp): \" + this);\n+      dumpStack();\n+    }\n+  }\n+\n+  public Object clone() {\n+    AMD64Frame frame = new AMD64Frame();\n+    frame.raw_sp = raw_sp;\n+    frame.raw_unextendedSP = raw_unextendedSP;\n+    frame.raw_fp = raw_fp;\n+    frame.pc = pc;\n+    frame.deoptimized = deoptimized;\n+    frame.live_bcp = live_bcp;\n+    return frame;\n+  }\n+\n+  public boolean equals(Object arg) {\n+    if (arg == null) {\n+      return false;\n+    }\n+\n+    if (!(arg instanceof AMD64Frame)) {\n+      return false;\n+    }\n+\n+    AMD64Frame other = (AMD64Frame) arg;\n+\n+    return (AddressOps.equal(getSP(), other.getSP()) &&\n+            AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &&\n+            AddressOps.equal(getFP(), other.getFP()) &&\n+            AddressOps.equal(getPC(), other.getPC()));\n+  }\n+\n+  public int hashCode() {\n+    if (raw_sp == null) {\n+      return 0;\n+    }\n+\n+    return raw_sp.hashCode();\n+  }\n+\n+  public String toString() {\n+    return \"sp: \" + (getSP() == null? \"null\" : getSP().toString()) +\n+         \", unextendedSP: \" + (getUnextendedSP() == null? \"null\" : getUnextendedSP().toString()) +\n+         \", fp: \" + (getFP() == null? \"null\" : getFP().toString()) +\n+         \", pc: \" + (pc == null? \"null\" : pc.toString());\n+  }\n+\n+  \/\/ accessors for the instance variables\n+  public Address getFP() { return raw_fp; }\n+  public Address getSP() { return raw_sp; }\n+  public Address getID() { return raw_sp; }\n+\n+  \/\/ FIXME: not implemented yet (should be done for Solaris)\n+  public boolean isSignalHandlerFrameDbg() { return false; }\n+  public int     getSignalNumberDbg()      { return 0;     }\n+  public String  getSignalNameDbg()        { return null;  }\n+\n+  public boolean isInterpretedFrameValid() {\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(isInterpretedFrame(), \"Not an interpreted frame\");\n+    }\n+\n+    \/\/ These are reasonable sanity checks\n+    if (getFP() == null || getFP().andWithMask(0x3) != null) {\n+      return false;\n+    }\n+\n+    if (getSP() == null || getSP().andWithMask(0x3) != null) {\n+      return false;\n+    }\n+\n+    if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {\n+      return false;\n+    }\n+\n+    \/\/ These are hacks to keep us out of trouble.\n+    \/\/ The problem with these is that they mask other problems\n+    if (getFP().lessThanOrEqual(getSP())) {\n+      \/\/ this attempts to deal with unsigned comparison above\n+      return false;\n+    }\n+\n+    if (getFP().minus(getSP()) > 4096 * VM.getVM().getAddressSize()) {\n+      \/\/ stack frames shouldn't be large.\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  \/\/ FIXME: not applicable in current system\n+  \/\/  void    patch_pc(Thread* thread, address pc);\n+\n+  public Frame sender(RegisterMap regMap, CodeBlob cb) {\n+    AMD64RegisterMap map = (AMD64RegisterMap) regMap;\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    \/\/ Default is we done have to follow them. The sender_for_xxx will\n+    \/\/ update it accordingly\n+    map.setIncludeArgumentOops(false);\n+\n+    if (isEntryFrame())       return senderForEntryFrame(map);\n+    if (isInterpretedFrame()) return senderForInterpreterFrame(map);\n+\n+    if(cb == null) {\n+      cb = VM.getVM().getCodeCache().findBlob(getPC());\n+    } else {\n+      if (Assert.ASSERTS_ENABLED) {\n+        Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), \"Must be the same\");\n+      }\n+    }\n+\n+    if (cb != null) {\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n+    }\n+\n+    \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n+    \/\/ methods that exists in the core system.\n+    return new AMD64Frame(getSenderSP(), getLink(), getSenderPC());\n+  }\n+\n+  private Frame senderForEntryFrame(AMD64RegisterMap map) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForEntryFrame\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+    \/\/ Java frame called from C; skip all C frames and return top C\n+    \/\/ frame of that chunk as the sender\n+    AMD64JavaCallWrapper jcw = (AMD64JavaCallWrapper) getEntryFrameCallWrapper();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(!entryFrameIsFirst(), \"next Java fp must be non zero\");\n+      Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    AMD64Frame fr;\n+    if (jcw.getLastJavaPC() != null) {\n+      fr = new AMD64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());\n+    } else {\n+      fr = new AMD64Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n+  private Frame senderForUpcallStub(AMD64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    AMD64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new AMD64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new AMD64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n+  private Frame senderForInterpreterFrame(AMD64RegisterMap map) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForInterpreterFrame\");\n+    }\n+    Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);\n+    Address sp = addressOfStackSlot(SENDER_SP_OFFSET);\n+    \/\/ We do not need to update the callee-save register mapping because above\n+    \/\/ us is either another interpreter frame or a converter-frame, but never\n+    \/\/ directly a compiled frame.\n+    \/\/ 11\/24\/04 SFG. With the removal of adapter frames this is no longer true.\n+    \/\/ However c2 no longer uses callee save register for java calls so there\n+    \/\/ are no callee register to find.\n+\n+    if (map.getUpdateMap())\n+      updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));\n+\n+    return new AMD64Frame(sp, unextendedSP, getLink(), getSenderPC());\n+  }\n+\n+  private void updateMapWithSavedLink(RegisterMap map, Address savedFPAddr) {\n+    map.setLocation(rbp, savedFPAddr);\n+  }\n+\n+  private Frame senderForContinuationStub(AMD64RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new AMD64Frame(senderSP, senderFP, senderPC);\n+  }\n+\n+  private Frame senderForCompiledFrame(AMD64RegisterMap map, CodeBlob cb) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForCompiledFrame\");\n+    }\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    \/\/ frame owned by optimizing compiler\n+    if (Assert.ASSERTS_ENABLED) {\n+        Assert.that(cb.getFrameSize() > 0, \"must have non-zero frame size\");\n+    }\n+    Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());\n+\n+    \/\/ On Intel the return_address is always the word on the stack\n+    Address senderPC = senderSP.getAddressAt(-1 * VM.getVM().getAddressSize());\n+\n+    \/\/ This is the saved value of EBP which may or may not really be an FP.\n+    \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n+    Address savedFPAddr = senderSP.addOffsetTo(- SENDER_SP_OFFSET * VM.getVM().getAddressSize());\n+\n+    if (map.getUpdateMap()) {\n+      \/\/ Tell GC to use argument oopmaps for some runtime stubs that need it.\n+      \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n+      \/\/ outside of update_register_map.\n+      map.setIncludeArgumentOops(cb.callerMustGCArguments());\n+\n+      if (cb.getOopMaps() != null) {\n+        ImmutableOopMapSet.updateRegisterMap(this, cb, map, true);\n+      }\n+\n+      \/\/ Since the prolog does the save and restore of EBP there is no oopmap\n+      \/\/ for it so we must fill in its location as if there was an oopmap entry\n+      \/\/ since if our caller was compiled code there could be live jvm state in it.\n+      updateMapWithSavedLink(map, savedFPAddr);\n+    }\n+\n+    return new AMD64Frame(senderSP, savedFPAddr.getAddressAt(0), senderPC);\n+  }\n+\n+  protected boolean hasSenderPD() {\n+    \/\/ FIXME\n+    \/\/ Check for null ebp? Need to do some tests.\n+    return true;\n+  }\n+\n+  public long frameSize() {\n+    return (getSenderSP().minus(getSP()) \/ VM.getVM().getAddressSize());\n+  }\n+\n+  public Address getLink() {\n+    return addressOfStackSlot(LINK_OFFSET).getAddressAt(0);\n+  }\n+\n+  public Address getUnextendedSP() { return raw_unextendedSP; }\n+\n+  \/\/ Return address:\n+  public Address getSenderPCAddr() { return addressOfStackSlot(RETURN_ADDR_OFFSET); }\n+  public Address getSenderPC()     { return getSenderPCAddr().getAddressAt(0);      }\n+\n+  public Address getSenderSP()     { return addressOfStackSlot(SENDER_SP_OFFSET); }\n+\n+  public Address addressOfInterpreterFrameLocals() {\n+    long n = addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET).getCIntegerAt(0, VM.getVM().getAddressSize(), false);\n+    return getFP().addOffsetTo(n * VM.getVM().getAddressSize());\n+  }\n+\n+  private Address addressOfInterpreterFrameBCX() {\n+    return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);\n+  }\n+\n+  public Address getInterpreterFrameBCP() {\n+    \/\/ FIXME: this is not atomic with respect to GC and is unsuitable\n+    \/\/ for use in a non-debugging, or reflective, system. Need to\n+    \/\/ figure out how to express this.\n+\n+    Method method = getInterpreterFrameMethod();\n+    Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);\n+\n+    \/\/ If we are in the top level frame then the bcp may have been set for us. If so then let it\n+    \/\/ take priority. If we are in a top level interpreter frame, the bcp is live in R13 (on x86_64)\n+    \/\/ and not saved in the BCX stack slot.\n+    if (live_bcp != null) {\n+        \/\/ Only use live_bcp if it points within the Method's bytecodes. Sometimes R13 is used\n+        \/\/ for scratch purposes and is not a valid BCP. If it is not valid, then we stick with\n+        \/\/ the bcp stored in the frame, which R13 should have been flushed to.\n+        if (method.getConstMethod().isAddressInMethod(live_bcp)) {\n+            bcp = live_bcp;\n+        }\n+    }\n+\n+    return bcp;\n+  }\n+\n+  public int getInterpreterFrameBCI() {\n+    Address bcp = getInterpreterFrameBCP();\n+    Method method = getInterpreterFrameMethod();\n+    return bcpToBci(bcp, method);\n+  }\n+\n+  public Address addressOfInterpreterFrameMDX() {\n+    return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);\n+  }\n+\n+  \/\/ FIXME\n+  \/\/inline int frame::interpreter_frame_monitor_size() {\n+  \/\/  return BasicObjectLock::size();\n+  \/\/}\n+\n+  \/\/ expression stack\n+  \/\/ (the max_stack arguments are used by the GC; see class FrameClosure)\n+\n+  public Address addressOfInterpreterFrameExpressionStack() {\n+    Address monitorEnd = interpreterFrameMonitorEnd().address();\n+    return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());\n+  }\n+\n+  public int getInterpreterFrameExpressionStackDirection() { return -1; }\n+\n+  \/\/ top of expression stack\n+  public Address addressOfInterpreterFrameTOS() {\n+    return getSP();\n+  }\n+\n+  \/** Expression stack from top down *\/\n+  public Address addressOfInterpreterFrameTOSAt(int slot) {\n+    return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());\n+  }\n+\n+  public Address getInterpreterFrameSenderSP() {\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(isInterpretedFrame(), \"interpreted frame expected\");\n+    }\n+    return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);\n+  }\n+\n+  \/\/ Monitors\n+  public BasicObjectLock interpreterFrameMonitorBegin() {\n+    return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));\n+  }\n+\n+  public BasicObjectLock interpreterFrameMonitorEnd() {\n+    long n = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getCIntegerAt(0, VM.getVM().getAddressSize(), false);\n+    Address result = getFP().addOffsetTo(n * VM.getVM().getAddressSize());\n+    if (Assert.ASSERTS_ENABLED) {\n+      \/\/ make sure the pointer points inside the frame\n+      Assert.that(AddressOps.gt(getFP(), result), \"result must <  than frame pointer\");\n+      Assert.that(AddressOps.lte(getSP(), result), \"result must >= than stack pointer\");\n+    }\n+    return new BasicObjectLock(result);\n+  }\n+\n+  public int interpreterFrameMonitorSize() {\n+    return BasicObjectLock.size();\n+  }\n+\n+  \/\/ Method\n+  public Address addressOfInterpreterFrameMethod() {\n+    return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);\n+  }\n+\n+  \/\/ Constant pool cache\n+  public Address addressOfInterpreterFrameCPCache() {\n+    return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);\n+  }\n+\n+  \/\/ Entry frames\n+  public JavaCallWrapper getEntryFrameCallWrapper() {\n+    return new AMD64JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));\n+  }\n+\n+  protected Address addressOfSavedOopResult() {\n+    \/\/ offset is 2 for compiler2 and 3 for compiler1\n+    return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *\n+                               VM.getVM().getAddressSize());\n+  }\n+\n+  protected Address addressOfSavedReceiver() {\n+    return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());\n+  }\n+\n+  private void dumpStack() {\n+    if (getFP() != null) {\n+      for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());\n+           AddressOps.lte(addr, getFP().addOffsetTo(5 * VM.getVM().getAddressSize()));\n+           addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {\n+        System.out.println(addr + \": \" + addr.getAddressAt(0));\n+      }\n+    } else {\n+      for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());\n+           AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));\n+           addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {\n+        System.out.println(addr + \": \" + addr.getAddressAt(0));\n+      }\n+    }\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/amd64\/AMD64Frame.java","additions":572,"deletions":0,"binary":false,"changes":572,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2001, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime.amd64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+\n+public class AMD64RegisterMap extends RegisterMap {\n+\n+  \/** This is the only public constructor *\/\n+  public AMD64RegisterMap(JavaThread thread, boolean updateMap) {\n+    super(thread, updateMap);\n+  }\n+\n+  protected AMD64RegisterMap(RegisterMap map) {\n+    super(map);\n+  }\n+\n+  public Object clone() {\n+    AMD64RegisterMap retval = new AMD64RegisterMap(this);\n+    return retval;\n+  }\n+\n+  \/\/ no PD state to clear or copy:\n+  protected void clearPD() {}\n+  protected void initializePD() {}\n+  protected void initializeFromPD(RegisterMap map) {}\n+  protected Address getLocationPD(VMReg reg) { return null; }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/amd64\/AMD64RegisterMap.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -35,1 +35,0 @@\n-import sun.jvm.hotspot.runtime.x86.*;\n@@ -90,1 +89,1 @@\n-    return new X86Frame(thread.getLastJavaSP(), fp);\n+    return new AMD64Frame(thread.getLastJavaSP(), fp);\n@@ -94,1 +93,1 @@\n-    return new X86RegisterMap(thread, updateMap);\n+    return new AMD64RegisterMap(thread, updateMap);\n@@ -105,1 +104,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP());\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP());\n@@ -109,1 +108,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC(), null, bcp);\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC(), null, bcp);\n@@ -111,1 +110,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_amd64\/BsdAMD64JavaThreadPDAccess.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.bsd_x86;\n-\n-public class BsdSignals {\n-  private static String[] signalNames = {\n-    \"\",           \/* No signal 0 *\/\n-    \"SIGHUP\",     \/* hangup *\/\n-    \"SIGINT\",     \/* interrupt *\/\n-    \"SIGQUIT\",    \/* quit *\/\n-    \"SIGILL\",     \/* illegal instr. (not reset when caught) *\/\n-    \"SIGTRAP\",    \/* trace trap (not reset when caught) *\/\n-    \"SIGABRT\",    \/* abort() *\/\n-    \"SIGEMT\",     \/* EMT instruction *\/\n-    \"SIGFPE\",     \/* floating point exception *\/\n-    \"SIGKILL\",    \/* kill (cannot be caught or ignored) *\/\n-    \"SIGBUS\",     \/* bus error *\/\n-    \"SIGSEGV\",    \/* segmentation violation *\/\n-    \"SIGSYS\",     \/* non-existent system call invoked *\/\n-    \"SIGPIPE\",    \/* write on a pipe with no one to read it *\/\n-    \"SIGALRM\",    \/* alarm clock *\/\n-    \"SIGTERM\",    \/* software termination signal from kill *\/\n-    \"SIGURG\",     \/* urgent condition on IO channel *\/\n-    \"SIGSTOP\",    \/* sendable stop signal not from tty *\/\n-    \"SIGTSTP\",    \/* stop signal from tty *\/\n-    \"SIGCONT\",    \/* continue a stopped process *\/\n-    \"SIGCHLD\",    \/* to parent on child stop or exit *\/\n-    \"SIGTTIN\",    \/* to readers pgrp upon background tty read *\/\n-    \"SIGTTOU\",    \/* like TTIN if (tp->t_local&LTOSTOP) *\/\n-    \"SIGIO\",      \/* input\/output possible signal *\/\n-    \"SIGXCPU\",    \/* exceeded CPU time limit *\/\n-    \"SIGXFSZ\",    \/* exceeded file size limit *\/\n-    \"SIGVTALRM\",  \/* virtual time alarm *\/\n-    \"SIGPROF\",    \/* profiling time alarm *\/\n-    \"SIGWINCH\",   \/* window size changes *\/\n-    \"SIGINFO\",    \/* information request *\/\n-    \"SIGUSR1\",    \/* user defined signal 1 *\/\n-    \"SIGUSR2\"     \/* user defined signal 2 *\/\n-  };\n-\n-  public static String getSignalName(int sigNum) {\n-    if ((sigNum <= 0) || (sigNum >= signalNames.length)) {\n-      \/\/ Probably best to fail in a non-destructive way\n-      return \"<Error: Illegal signal number \" + sigNum + \">\";\n-    }\n-    return signalNames[sigNum];\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_x86\/BsdSignals.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.bsd_x86;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.runtime.x86.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class BsdX86JavaThreadPDAccess implements JavaThreadPDAccess {\n-  private static AddressField  lastJavaFPField;\n-  private static AddressField  osThreadField;\n-\n-  \/\/ Field from OSThread\n-  private static CIntegerField osThreadThreadIDField;\n-\n-  \/\/ This is currently unneeded but is being kept in case we change\n-  \/\/ the currentFrameGuess algorithm\n-  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"JavaThread\");\n-    osThreadField           = type.getAddressField(\"_osthread\");\n-\n-    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n-    lastJavaFPField         = anchorType.getAddressField(\"_last_Java_fp\");\n-\n-    Type osThreadType = db.lookupType(\"OSThread\");\n-    osThreadThreadIDField   = osThreadType.getCIntegerField(\"_thread_id\");\n-  }\n-\n-  public    Address getLastJavaFP(Address addr) {\n-    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n-  }\n-\n-  public    Address getLastJavaPC(Address addr) {\n-    return null;\n-  }\n-\n-  public    Address getBaseOfStackPointer(Address addr) {\n-    return null;\n-  }\n-\n-  public    Frame getLastFramePD(JavaThread thread, Address addr) {\n-    Address fp = thread.getLastJavaFP();\n-    if (fp == null) {\n-      return null; \/\/ no information\n-    }\n-    return new X86Frame(thread.getLastJavaSP(), fp);\n-  }\n-\n-  public    RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n-    return new X86RegisterMap(thread, updateMap);\n-  }\n-\n-  public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n-    ThreadProxy t = getThreadProxy(addr);\n-    X86ThreadContext context = (X86ThreadContext) t.getContext();\n-    X86CurrentFrameGuess guesser = new X86CurrentFrameGuess(context, thread);\n-    if (!guesser.run(GUESS_SCAN_RANGE)) {\n-      return null;\n-    }\n-    if (guesser.getPC() == null) {\n-      return new X86Frame(guesser.getSP(), guesser.getFP());\n-    } else {\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n-    }\n-  }\n-\n-  public    void printThreadIDOn(Address addr, PrintStream tty) {\n-    tty.print(getThreadProxy(addr));\n-  }\n-\n-  public    void printInfoOn(Address threadAddr, PrintStream tty) {\n-    tty.print(\"Thread id: \");\n-    printThreadIDOn(threadAddr, tty);\n-\/\/    tty.println(\"\\nPostJavaState: \" + getPostJavaState(threadAddr));\n-  }\n-\n-  public    Address getLastSP(Address addr) {\n-    ThreadProxy t = getThreadProxy(addr);\n-    X86ThreadContext context = (X86ThreadContext) t.getContext();\n-    return context.getRegisterAsAddress(X86ThreadContext.ESP);\n-  }\n-\n-  public    ThreadProxy getThreadProxy(Address addr) {\n-    \/\/ Addr is the address of the JavaThread.\n-    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n-    \/\/ separate \"OSThread\" class in this package)\n-    Address osThreadAddr = osThreadField.getValue(addr);\n-    \/\/ Get the address of the _thread_id from the OSThread\n-    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());\n-\n-    JVMDebugger debugger = VM.getVM().getDebugger();\n-    return debugger.getThreadForIdentifierAddress(threadIdAddr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_x86\/BsdX86JavaThreadPDAccess.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.jvm.hotspot.runtime.x86.*;\n@@ -86,1 +85,1 @@\n-    return new X86Frame(thread.getLastJavaSP(), fp);\n+    return new AMD64Frame(thread.getLastJavaSP(), fp);\n@@ -90,1 +89,1 @@\n-    return new X86RegisterMap(thread, updateMap);\n+    return new AMD64RegisterMap(thread, updateMap);\n@@ -101,1 +100,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP());\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP());\n@@ -105,1 +104,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC(), null, bcp);\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC(), null, bcp);\n@@ -107,1 +106,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/linux_amd64\/LinuxAMD64JavaThreadPDAccess.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.linux_x86;\n-\n-public class LinuxSignals {\n-  private static String[] signalNames = {\n-    \"\",           \/* No signal 0 *\/\n-    \"SIGHUP\",     \/* hangup *\/\n-    \"SIGINT\",     \/* interrupt (rubout) *\/\n-    \"SIGQUIT\",    \/* quit (ASCII FS) *\/\n-    \"SIGILL\",     \/* illegal instruction (not reset when caught) *\/\n-    \"SIGTRAP\",    \/* trace trap (not reset when caught) *\/\n-    \"SIGABRT\",    \/* used by abort, replace SIGIOT in the future *\/\n-    \"SIGIOT\",\n-    \"SIGBUS\",\n-    \"SIGFPE\",     \/* floating point exception *\/\n-    \"SIGKILL\",    \/* kill (cannot be caught or ignored) *\/\n-    \"SIGUSR1\",    \/* user defined signal 1 *\/\n-    \"SIGSEGV\",    \/* segmentation violation *\/\n-    \"SIGUSR2\",    \/* user defined signal 2 *\/\n-    \"SIGPIPE\",    \/* write on a pipe with no one to read it *\/\n-    \"SIGALRM\",    \/* alarm clock *\/\n-    \"SIGTERM\",    \/* software termination signal from kill *\/\n-    \"SIGSTKFLT\",\n-    \"SIGCHLD\",    \/* child status change alias *\/\n-    \"SIGCONT\",    \/* stopped process has been continued *\/\n-    \"SIGSTOP\",    \/* stop (cannot be caught or ignored) *\/\n-    \"SIGTSTP\",    \/* user stop requested from tty *\/\n-    \"SIGTTIN\",    \/* background tty read attempted *\/\n-    \"SIGTTOU\",    \/* background tty write attempted *\/\n-    \"SIGURG\",     \/* urgent socket condition *\/\n-    \"SIGXCPU\",    \/* exceeded cpu limit *\/\n-    \"SIGXFSZ\",    \/* exceeded file size limit *\/\n-    \"SIGVTALRM\",  \/* virtual timer expired *\/\n-    \"SIGPROF\",    \/* profiling timer expired *\/\n-    \"SIGWINCH\",   \/* window size change *\/\n-    \"SIGPOLL\",    \/* pollable event occurred *\/\n-    \"SIGPWR\",     \/* power-fail restart *\/\n-    \"SIGSYS\"\n-  };\n-\n-  public static String getSignalName(int sigNum) {\n-    if ((sigNum <= 0) || (sigNum >= signalNames.length)) {\n-      \/\/ Probably best to fail in a non-destructive way\n-      return \"<Error: Illegal signal number \" + sigNum + \">\";\n-    }\n-    return signalNames[sigNum];\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/linux_x86\/LinuxSignals.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.linux_x86;\n-\n-import java.io.*;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.runtime.x86.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class LinuxX86JavaThreadPDAccess implements JavaThreadPDAccess {\n-  private static AddressField  lastJavaFPField;\n-  private static AddressField  osThreadField;\n-\n-  \/\/ Field from OSThread\n-  private static CIntegerField osThreadThreadIDField;\n-\n-  \/\/ This is currently unneeded but is being kept in case we change\n-  \/\/ the currentFrameGuess algorithm\n-  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"JavaThread\");\n-    osThreadField           = type.getAddressField(\"_osthread\");\n-\n-    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n-    lastJavaFPField         = anchorType.getAddressField(\"_last_Java_fp\");\n-\n-    Type osThreadType = db.lookupType(\"OSThread\");\n-    osThreadThreadIDField   = osThreadType.getCIntegerField(\"_thread_id\");\n-  }\n-\n-  public    Address getLastJavaFP(Address addr) {\n-    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n-  }\n-\n-  public    Address getLastJavaPC(Address addr) {\n-    return null;\n-  }\n-\n-  public    Address getBaseOfStackPointer(Address addr) {\n-    return null;\n-  }\n-\n-  public    Frame getLastFramePD(JavaThread thread, Address addr) {\n-    Address fp = thread.getLastJavaFP();\n-    if (fp == null) {\n-      return null; \/\/ no information\n-    }\n-    return new X86Frame(thread.getLastJavaSP(), fp);\n-  }\n-\n-  public    RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n-    return new X86RegisterMap(thread, updateMap);\n-  }\n-\n-  public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n-    ThreadProxy t = getThreadProxy(addr);\n-    X86ThreadContext context = (X86ThreadContext) t.getContext();\n-    X86CurrentFrameGuess guesser = new X86CurrentFrameGuess(context, thread);\n-    if (!guesser.run(GUESS_SCAN_RANGE)) {\n-      return null;\n-    }\n-    if (guesser.getPC() == null) {\n-      return new X86Frame(guesser.getSP(), guesser.getFP());\n-    } else {\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n-    }\n-  }\n-\n-  public    void printThreadIDOn(Address addr, PrintStream tty) {\n-    tty.print(getThreadProxy(addr));\n-  }\n-\n-  public    void printInfoOn(Address threadAddr, PrintStream tty) {\n-    tty.print(\"Thread id: \");\n-    printThreadIDOn(threadAddr, tty);\n-\/\/    tty.println(\"\\nPostJavaState: \" + getPostJavaState(threadAddr));\n-  }\n-\n-  public    Address getLastSP(Address addr) {\n-    ThreadProxy t = getThreadProxy(addr);\n-    X86ThreadContext context = (X86ThreadContext) t.getContext();\n-    return context.getRegisterAsAddress(X86ThreadContext.SP);\n-  }\n-\n-  public    ThreadProxy getThreadProxy(Address addr) {\n-    \/\/ Addr is the address of the JavaThread.\n-    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n-    \/\/ separate \"OSThread\" class in this package)\n-    Address osThreadAddr = osThreadField.getValue(addr);\n-    \/\/ Get the address of the _thread_id from the OSThread\n-    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());\n-\n-    JVMDebugger debugger = VM.getVM().getDebugger();\n-    return debugger.getThreadForIdentifierAddress(threadIdAddr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/linux_x86\/LinuxX86JavaThreadPDAccess.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import sun.jvm.hotspot.runtime.x86.*;\n@@ -91,1 +90,1 @@\n-      return new X86Frame(thread.getLastJavaSP(), fp, pc);\n+      return new AMD64Frame(thread.getLastJavaSP(), fp, pc);\n@@ -93,1 +92,1 @@\n-      return new X86Frame(thread.getLastJavaSP(), fp);\n+      return new AMD64Frame(thread.getLastJavaSP(), fp);\n@@ -98,1 +97,1 @@\n-    return new X86RegisterMap(thread, updateMap);\n+    return new AMD64RegisterMap(thread, updateMap);\n@@ -109,1 +108,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP());\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP());\n@@ -113,1 +112,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC(), null, bcp);\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC(), null, bcp);\n@@ -115,1 +114,1 @@\n-      return new X86Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+      return new AMD64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/win32_amd64\/Win32AMD64JavaThreadPDAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,225 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.debugger.x86.*;\n-import sun.jvm.hotspot.code.*;\n-import sun.jvm.hotspot.interpreter.*;\n-import sun.jvm.hotspot.runtime.*;\n-\n-\/** <P> Should be able to be used on all x86 platforms we support\n-    (Win32, Solaris\/x86, and soon Linux) to implement JavaThread's\n-    \"currentFrameGuess()\" functionality. Input is an X86ThreadContext;\n-    output is SP, FP, and PC for an X86Frame. Instantiation of the\n-    X86Frame is left to the caller, since we may need to subclass\n-    X86Frame to support signal handler frames on Unix platforms. <\/P>\n-\n-    <P> Algorithm is to walk up the stack within a given range (say,\n-    512K at most) looking for a plausible PC and SP for a Java frame,\n-    also considering those coming in from the context. If we find a PC\n-    that belongs to the VM (i.e., in generated code like the\n-    interpreter or CodeCache) then we try to find an associated EBP.\n-    We repeat this until we either find a complete frame or run out of\n-    stack to look at. <\/P> *\/\n-\n-public class X86CurrentFrameGuess {\n-  private X86ThreadContext context;\n-  private JavaThread       thread;\n-  private Address          spFound;\n-  private Address          fpFound;\n-  private Address          pcFound;\n-\n-  private static final boolean DEBUG = System.getProperty(\"sun.jvm.hotspot.runtime.x86.X86Frame.DEBUG\")\n-                                       != null;\n-\n-  public X86CurrentFrameGuess(X86ThreadContext context,\n-                              JavaThread thread) {\n-    this.context = context;\n-    this.thread  = thread;\n-  }\n-\n-  \/** Returns false if not able to find a frame within a reasonable range. *\/\n-  public boolean run(long regionInBytesToSearch) {\n-    Address sp  = context.getRegisterAsAddress(X86ThreadContext.SP);\n-    Address pc  = context.getRegisterAsAddress(X86ThreadContext.PC);\n-    Address fp  = context.getRegisterAsAddress(X86ThreadContext.FP);\n-    if (sp == null) {\n-      \/\/ Bail out if no last java frame eithe\n-      if (thread.getLastJavaSP() != null) {\n-        setValues(thread.getLastJavaSP(), thread.getLastJavaFP(), null);\n-        return true;\n-      }\n-      \/\/ Bail out\n-      return false;\n-    }\n-    Address end = sp.addOffsetTo(regionInBytesToSearch);\n-    VM vm       = VM.getVM();\n-\n-    setValues(null, null, null); \/\/ Assume we're not going to find anything\n-\n-    if (vm.isJavaPCDbg(pc)) {\n-      if (vm.isClientCompiler()) {\n-        \/\/ If the topmost frame is a Java frame, we are (pretty much)\n-        \/\/ guaranteed to have a viable EBP. We should be more robust\n-        \/\/ than this (we have the potential for losing entire threads'\n-        \/\/ stack traces) but need to see how much work we really have\n-        \/\/ to do here. Searching the stack for an (SP, FP) pair is\n-        \/\/ hard since it's easy to misinterpret inter-frame stack\n-        \/\/ pointers as base-of-frame pointers; we also don't know the\n-        \/\/ sizes of C1 frames (not registered in the nmethod) so can't\n-        \/\/ derive them from ESP.\n-\n-        setValues(sp, fp, pc);\n-        return true;\n-      } else {\n-        if (vm.getInterpreter().contains(pc)) {\n-          if (DEBUG) {\n-            System.out.println(\"CurrentFrameGuess: choosing interpreter frame: sp = \" +\n-                               sp + \", fp = \" + fp + \", pc = \" + pc);\n-          }\n-          setValues(sp, fp, pc);\n-          return true;\n-        }\n-\n-        \/\/ For the server compiler, EBP is not guaranteed to be valid\n-        \/\/ for compiled code. In addition, an earlier attempt at a\n-        \/\/ non-searching algorithm (see below) failed because the\n-        \/\/ stack pointer from the thread context was pointing\n-        \/\/ (considerably) beyond the ostensible end of the stack, into\n-        \/\/ garbage; walking from the topmost frame back caused a crash.\n-        \/\/\n-        \/\/ This algorithm takes the current PC as a given and tries to\n-        \/\/ find the correct corresponding SP by walking up the stack\n-        \/\/ and repeatedly performing stackwalks (very inefficient).\n-        \/\/\n-        \/\/ FIXME: there is something wrong with stackwalking across\n-        \/\/ adapter frames...this is likely to be the root cause of the\n-        \/\/ failure with the simpler algorithm below.\n-\n-        for (long offset = 0;\n-             offset < regionInBytesToSearch;\n-             offset += vm.getAddressSize()) {\n-          try {\n-            Address curSP = sp.addOffsetTo(offset);\n-            Frame frame = new X86Frame(curSP, null, pc);\n-            RegisterMap map = thread.newRegisterMap(false);\n-            while (frame != null) {\n-              if (frame.isEntryFrame() && frame.entryFrameIsFirst()) {\n-                \/\/ We were able to traverse all the way to the\n-                \/\/ bottommost Java frame.\n-                \/\/ This sp looks good. Keep it.\n-                if (DEBUG) {\n-                  System.out.println(\"CurrentFrameGuess: Choosing sp = \" + curSP + \", pc = \" + pc);\n-                }\n-                setValues(curSP, null, pc);\n-                return true;\n-              }\n-              Frame oldFrame = frame;\n-              frame = frame.sender(map);\n-              if (frame.getSP().lessThanOrEqual(oldFrame.getSP())) {\n-                  \/\/ Frame points to itself or to a location in the wrong direction.\n-                  \/\/ Break the loop and move on to next offset.\n-                  if (DEBUG) {\n-                      System.out.println(\"X86CurrentFrameGuess.run: frame <= oldFrame: \" + frame);\n-                  }\n-                  break;\n-              }\n-            }\n-          } catch (Exception e) {\n-            if (DEBUG) {\n-              System.out.println(\"CurrentFrameGuess: Exception \" + e + \" at offset \" + offset);\n-            }\n-            \/\/ Bad SP. Try another.\n-          }\n-        }\n-\n-        \/\/ Were not able to find a plausible SP to go with this PC.\n-        \/\/ Bail out.\n-        return false;\n-\n-        \/*\n-        \/\/ Original algorithm which does not work because SP was\n-        \/\/ pointing beyond where it should have:\n-\n-        \/\/ For the server compiler, EBP is not guaranteed to be valid\n-        \/\/ for compiled code. We see whether the PC is in the\n-        \/\/ interpreter and take care of that, otherwise we run code\n-        \/\/ (unfortunately) duplicated from X86Frame.senderForCompiledFrame.\n-\n-        CodeCache cc = vm.getCodeCache();\n-        if (cc.contains(pc)) {\n-          CodeBlob cb = cc.findBlob(pc);\n-\n-          \/\/ See if we can derive a frame pointer from SP and PC\n-          \/\/ NOTE: This is the code duplicated from X86Frame\n-          Address saved_fp = null;\n-          int llink_offset = cb.getLinkOffset();\n-          if (llink_offset >= 0) {\n-            \/\/ Restore base-pointer, since next frame might be an interpreter frame.\n-            Address fp_addr = sp.addOffsetTo(VM.getVM().getAddressSize() * llink_offset);\n-            saved_fp = fp_addr.getAddressAt(0);\n-          }\n-\n-          setValues(sp, saved_fp, pc);\n-          return true;\n-        }\n-        *\/\n-      }\n-    } else {\n-      \/\/ If the current program counter was not known to us as a Java\n-      \/\/ PC, we currently assume that we are in the run-time system\n-      \/\/ and attempt to look to thread-local storage for saved ESP and\n-      \/\/ EBP. Note that if these are null (because we were, in fact,\n-      \/\/ in Java code, i.e., vtable stubs or similar, and the SA\n-      \/\/ didn't have enough insight into the target VM to understand\n-      \/\/ that) then we are going to lose the entire stack trace for\n-      \/\/ the thread, which is sub-optimal. FIXME.\n-\n-      if (DEBUG) {\n-        System.out.println(\"CurrentFrameGuess: choosing last Java frame: sp = \" +\n-                           thread.getLastJavaSP() + \", fp = \" + thread.getLastJavaFP());\n-      }\n-      if (thread.getLastJavaSP() == null) {\n-        return false; \/\/ No known Java frames on stack\n-      }\n-      setValues(thread.getLastJavaSP(), thread.getLastJavaFP(), null);\n-      return true;\n-    }\n-  }\n-\n-  public Address getSP() { return spFound; }\n-  public Address getFP() { return fpFound; }\n-  \/** May be null if getting values from thread-local storage; take\n-      care to call the correct X86Frame constructor to recover this if\n-      necessary *\/\n-  public Address getPC() { return pcFound; }\n-\n-  private void setValues(Address sp, Address fp, Address pc) {\n-    spFound = sp;\n-    fpFound = fp;\n-    pcFound = pc;\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86CurrentFrameGuess.java","additions":0,"deletions":225,"binary":false,"changes":225,"status":"deleted"},{"patch":"@@ -1,576 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.x86;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.code.*;\n-import sun.jvm.hotspot.compiler.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-\/** Specialization of and implementation of abstract methods of the\n-    Frame class for the x86 family of CPUs. *\/\n-\n-public class X86Frame extends Frame {\n-  private static final boolean DEBUG;\n-  static {\n-    DEBUG = System.getProperty(\"sun.jvm.hotspot.runtime.x86.X86Frame.DEBUG\") != null;\n-  }\n-\n-  \/\/ All frames\n-  private static final int LINK_OFFSET                =  0;\n-  private static final int RETURN_ADDR_OFFSET         =  1;\n-  private static final int SENDER_SP_OFFSET           =  2;\n-\n-  \/\/ Interpreter frames\n-  private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -1;\n-  private static final int INTERPRETER_FRAME_LAST_SP_OFFSET   = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;\n-  private static final int INTERPRETER_FRAME_METHOD_OFFSET    = INTERPRETER_FRAME_LAST_SP_OFFSET - 1;\n-  private static       int INTERPRETER_FRAME_MIRROR_OFFSET;\n-  private static       int INTERPRETER_FRAME_MDX_OFFSET;         \/\/ Non-core builds only\n-  private static       int INTERPRETER_FRAME_CACHE_OFFSET;\n-  private static       int INTERPRETER_FRAME_LOCALS_OFFSET;\n-  private static       int INTERPRETER_FRAME_BCX_OFFSET;\n-  private static       int INTERPRETER_FRAME_INITIAL_SP_OFFSET;\n-  private static       int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET;\n-  private static       int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET;\n-\n-  \/\/ Entry frames\n-  private static       int ENTRY_FRAME_CALL_WRAPPER_OFFSET;\n-\n-  private static VMReg rbp;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    INTERPRETER_FRAME_MIRROR_OFFSET               = INTERPRETER_FRAME_METHOD_OFFSET - 1;\n-    INTERPRETER_FRAME_MDX_OFFSET                  = INTERPRETER_FRAME_MIRROR_OFFSET - 1;\n-    INTERPRETER_FRAME_CACHE_OFFSET                = INTERPRETER_FRAME_MDX_OFFSET - 1;\n-    INTERPRETER_FRAME_LOCALS_OFFSET               = INTERPRETER_FRAME_CACHE_OFFSET - 1;\n-    INTERPRETER_FRAME_BCX_OFFSET                  = INTERPRETER_FRAME_LOCALS_OFFSET - 1;\n-    INTERPRETER_FRAME_INITIAL_SP_OFFSET           = INTERPRETER_FRAME_BCX_OFFSET - 1;\n-    INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET    = INTERPRETER_FRAME_INITIAL_SP_OFFSET;\n-    INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;\n-\n-    ENTRY_FRAME_CALL_WRAPPER_OFFSET = db.lookupIntConstant(\"frame::entry_frame_call_wrapper_offset\");\n-    if (VM.getVM().getAddressSize() == 4) {\n-      rbp = new VMReg(5);\n-    } else {\n-      rbp = new VMReg(5 << 1);\n-    }\n-  }\n-\n-\n-  \/\/ an additional field beyond sp and pc:\n-  Address raw_fp; \/\/ frame pointer\n-  private Address raw_unextendedSP;\n-  private Address live_bcp;\n-\n-  private X86Frame() {\n-  }\n-\n-  private void initFrame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {\n-    this.raw_sp = raw_sp;\n-    this.raw_fp = raw_fp;\n-    if (raw_unextendedSp == null) {\n-        this.raw_unextendedSP = raw_sp;\n-    } else {\n-        this.raw_unextendedSP = raw_unextendedSp;\n-    }\n-    if (pc == null) {\n-        this.pc = raw_sp.getAddressAt(-1 * VM.getVM().getAddressSize());\n-    } else {\n-        this.pc = pc;\n-    }\n-    this.live_bcp = live_bcp;\n-\n-    \/\/ Frame must be fully constructed before this call\n-    adjustForDeopt();\n-  }\n-\n-\n-  public X86Frame(Address raw_sp, Address raw_fp, Address pc) {\n-    initFrame(raw_sp, raw_fp, pc, null, null);\n-\n-    if (DEBUG) {\n-      System.out.println(\"X86Frame(sp, fp, pc): \" + this);\n-      dumpStack();\n-    }\n-  }\n-\n-  public X86Frame(Address raw_sp, Address raw_fp) {\n-    initFrame(raw_sp, raw_fp, null, null, null);\n-\n-    if (DEBUG) {\n-      System.out.println(\"X86Frame(sp, fp): \" + this);\n-      dumpStack();\n-    }\n-  }\n-\n-  public X86Frame(Address raw_sp, Address raw_unextendedSp, Address raw_fp, Address pc) {\n-    initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, null);\n-\n-    if (DEBUG) {\n-      System.out.println(\"X86Frame(sp, unextendedSP, fp, pc): \" + this);\n-      dumpStack();\n-    }\n-  }\n-\n-  public X86Frame(Address raw_sp, Address raw_fp, Address pc, Address raw_unextendedSp, Address live_bcp) {\n-    initFrame(raw_sp, raw_fp, pc, raw_unextendedSp, live_bcp);\n-\n-    if (DEBUG) {\n-      System.out.println(\"X86Frame(sp, fp, pc, unextendedSP, live_bcp): \" + this);\n-      dumpStack();\n-    }\n-  }\n-\n-  public Object clone() {\n-    X86Frame frame = new X86Frame();\n-    frame.raw_sp = raw_sp;\n-    frame.raw_unextendedSP = raw_unextendedSP;\n-    frame.raw_fp = raw_fp;\n-    frame.pc = pc;\n-    frame.deoptimized = deoptimized;\n-    frame.live_bcp = live_bcp;\n-    return frame;\n-  }\n-\n-  public boolean equals(Object arg) {\n-    if (arg == null) {\n-      return false;\n-    }\n-\n-    if (!(arg instanceof X86Frame)) {\n-      return false;\n-    }\n-\n-    X86Frame other = (X86Frame) arg;\n-\n-    return (AddressOps.equal(getSP(), other.getSP()) &&\n-            AddressOps.equal(getUnextendedSP(), other.getUnextendedSP()) &&\n-            AddressOps.equal(getFP(), other.getFP()) &&\n-            AddressOps.equal(getPC(), other.getPC()));\n-  }\n-\n-  public int hashCode() {\n-    if (raw_sp == null) {\n-      return 0;\n-    }\n-\n-    return raw_sp.hashCode();\n-  }\n-\n-  public String toString() {\n-    return \"sp: \" + (getSP() == null? \"null\" : getSP().toString()) +\n-         \", unextendedSP: \" + (getUnextendedSP() == null? \"null\" : getUnextendedSP().toString()) +\n-         \", fp: \" + (getFP() == null? \"null\" : getFP().toString()) +\n-         \", pc: \" + (pc == null? \"null\" : pc.toString());\n-  }\n-\n-  \/\/ accessors for the instance variables\n-  public Address getFP() { return raw_fp; }\n-  public Address getSP() { return raw_sp; }\n-  public Address getID() { return raw_sp; }\n-\n-  \/\/ FIXME: not implemented yet (should be done for Solaris\/X86)\n-  public boolean isSignalHandlerFrameDbg() { return false; }\n-  public int     getSignalNumberDbg()      { return 0;     }\n-  public String  getSignalNameDbg()        { return null;  }\n-\n-  public boolean isInterpretedFrameValid() {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(isInterpretedFrame(), \"Not an interpreted frame\");\n-    }\n-\n-    \/\/ These are reasonable sanity checks\n-    if (getFP() == null || getFP().andWithMask(0x3) != null) {\n-      return false;\n-    }\n-\n-    if (getSP() == null || getSP().andWithMask(0x3) != null) {\n-      return false;\n-    }\n-\n-    if (getFP().addOffsetTo(INTERPRETER_FRAME_INITIAL_SP_OFFSET * VM.getVM().getAddressSize()).lessThan(getSP())) {\n-      return false;\n-    }\n-\n-    \/\/ These are hacks to keep us out of trouble.\n-    \/\/ The problem with these is that they mask other problems\n-    if (getFP().lessThanOrEqual(getSP())) {\n-      \/\/ this attempts to deal with unsigned comparison above\n-      return false;\n-    }\n-\n-    if (getFP().minus(getSP()) > 4096 * VM.getVM().getAddressSize()) {\n-      \/\/ stack frames shouldn't be large.\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  \/\/ FIXME: not applicable in current system\n-  \/\/  void    patch_pc(Thread* thread, address pc);\n-\n-  public Frame sender(RegisterMap regMap, CodeBlob cb) {\n-    X86RegisterMap map = (X86RegisterMap) regMap;\n-\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(map != null, \"map must be set\");\n-    }\n-\n-    \/\/ Default is we done have to follow them. The sender_for_xxx will\n-    \/\/ update it accordingly\n-    map.setIncludeArgumentOops(false);\n-\n-    if (isEntryFrame())       return senderForEntryFrame(map);\n-    if (isInterpretedFrame()) return senderForInterpreterFrame(map);\n-\n-    if(cb == null) {\n-      cb = VM.getVM().getCodeCache().findBlob(getPC());\n-    } else {\n-      if (Assert.ASSERTS_ENABLED) {\n-        Assert.that(cb.equals(VM.getVM().getCodeCache().findBlob(getPC())), \"Must be the same\");\n-      }\n-    }\n-\n-    if (cb != null) {\n-      if (cb.isUpcallStub()) {\n-        return senderForUpcallStub(map, (UpcallStub)cb);\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n-        return senderForCompiledFrame(map, cb);\n-      }\n-    }\n-\n-    \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n-    \/\/ methods that exists in the core system.\n-    return new X86Frame(getSenderSP(), getLink(), getSenderPC());\n-  }\n-\n-  private Frame senderForEntryFrame(X86RegisterMap map) {\n-    if (DEBUG) {\n-      System.out.println(\"senderForEntryFrame\");\n-    }\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(map != null, \"map must be set\");\n-    }\n-    \/\/ Java frame called from C; skip all C frames and return top C\n-    \/\/ frame of that chunk as the sender\n-    X86JavaCallWrapper jcw = (X86JavaCallWrapper) getEntryFrameCallWrapper();\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(!entryFrameIsFirst(), \"next Java fp must be non zero\");\n-      Assert.that(jcw.getLastJavaSP().greaterThan(getSP()), \"must be above this frame on stack\");\n-    }\n-    X86Frame fr;\n-    if (jcw.getLastJavaPC() != null) {\n-      fr = new X86Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP(), jcw.getLastJavaPC());\n-    } else {\n-      fr = new X86Frame(jcw.getLastJavaSP(), jcw.getLastJavaFP());\n-    }\n-    map.clear();\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n-    }\n-    return fr;\n-  }\n-\n-  private Frame senderForUpcallStub(X86RegisterMap map, UpcallStub stub) {\n-    if (DEBUG) {\n-      System.out.println(\"senderForUpcallStub\");\n-    }\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(map != null, \"map must be set\");\n-    }\n-\n-    var lastJavaFP = stub.getLastJavaFP(this);\n-    var lastJavaSP = stub.getLastJavaSP(this);\n-    var lastJavaPC = stub.getLastJavaPC(this);\n-\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n-    }\n-    X86Frame fr;\n-    if (lastJavaPC != null) {\n-      fr = new X86Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n-    } else {\n-      fr = new X86Frame(lastJavaSP, lastJavaFP);\n-    }\n-    map.clear();\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n-    }\n-    return fr;\n-  }\n-\n-  private Frame senderForInterpreterFrame(X86RegisterMap map) {\n-    if (DEBUG) {\n-      System.out.println(\"senderForInterpreterFrame\");\n-    }\n-    Address unextendedSP = addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);\n-    Address sp = addressOfStackSlot(SENDER_SP_OFFSET);\n-    \/\/ We do not need to update the callee-save register mapping because above\n-    \/\/ us is either another interpreter frame or a converter-frame, but never\n-    \/\/ directly a compiled frame.\n-    \/\/ 11\/24\/04 SFG. With the removal of adapter frames this is no longer true.\n-    \/\/ However c2 no longer uses callee save register for java calls so there\n-    \/\/ are no callee register to find.\n-\n-    if (map.getUpdateMap())\n-      updateMapWithSavedLink(map, addressOfStackSlot(LINK_OFFSET));\n-\n-    return new X86Frame(sp, unextendedSP, getLink(), getSenderPC());\n-  }\n-\n-  private void updateMapWithSavedLink(RegisterMap map, Address savedFPAddr) {\n-    map.setLocation(rbp, savedFPAddr);\n-  }\n-\n-  private Frame senderForContinuationStub(X86RegisterMap map, CodeBlob cb) {\n-    var contEntry = map.getThread().getContEntry();\n-\n-    Address senderSP = contEntry.getEntrySP();\n-    Address senderPC = contEntry.getEntryPC();\n-    Address senderFP = contEntry.getEntryFP();\n-\n-    return new X86Frame(senderSP, senderFP, senderPC);\n-  }\n-\n-  private Frame senderForCompiledFrame(X86RegisterMap map, CodeBlob cb) {\n-    if (DEBUG) {\n-      System.out.println(\"senderForCompiledFrame\");\n-    }\n-\n-    \/\/\n-    \/\/ NOTE: some of this code is (unfortunately) duplicated in X86CurrentFrameGuess\n-    \/\/\n-\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(map != null, \"map must be set\");\n-    }\n-\n-    \/\/ frame owned by optimizing compiler\n-    if (Assert.ASSERTS_ENABLED) {\n-        Assert.that(cb.getFrameSize() > 0, \"must have non-zero frame size\");\n-    }\n-    Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());\n-\n-    \/\/ On Intel the return_address is always the word on the stack\n-    Address senderPC = senderSP.getAddressAt(-1 * VM.getVM().getAddressSize());\n-\n-    \/\/ This is the saved value of EBP which may or may not really be an FP.\n-    \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n-    Address savedFPAddr = senderSP.addOffsetTo(- SENDER_SP_OFFSET * VM.getVM().getAddressSize());\n-\n-    if (map.getUpdateMap()) {\n-      \/\/ Tell GC to use argument oopmaps for some runtime stubs that need it.\n-      \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n-      \/\/ outside of update_register_map.\n-      map.setIncludeArgumentOops(cb.callerMustGCArguments());\n-\n-      if (cb.getOopMaps() != null) {\n-        ImmutableOopMapSet.updateRegisterMap(this, cb, map, true);\n-      }\n-\n-      \/\/ Since the prolog does the save and restore of EBP there is no oopmap\n-      \/\/ for it so we must fill in its location as if there was an oopmap entry\n-      \/\/ since if our caller was compiled code there could be live jvm state in it.\n-      updateMapWithSavedLink(map, savedFPAddr);\n-    }\n-\n-    return new X86Frame(senderSP, savedFPAddr.getAddressAt(0), senderPC);\n-  }\n-\n-  protected boolean hasSenderPD() {\n-    \/\/ FIXME\n-    \/\/ Check for null ebp? Need to do some tests.\n-    return true;\n-  }\n-\n-  public long frameSize() {\n-    return (getSenderSP().minus(getSP()) \/ VM.getVM().getAddressSize());\n-  }\n-\n-  public Address getLink() {\n-    return addressOfStackSlot(LINK_OFFSET).getAddressAt(0);\n-  }\n-\n-  public Address getUnextendedSP() { return raw_unextendedSP; }\n-\n-  \/\/ Return address:\n-  public Address getSenderPCAddr() { return addressOfStackSlot(RETURN_ADDR_OFFSET); }\n-  public Address getSenderPC()     { return getSenderPCAddr().getAddressAt(0);      }\n-\n-  public Address getSenderSP()     { return addressOfStackSlot(SENDER_SP_OFFSET); }\n-\n-  public Address addressOfInterpreterFrameLocals() {\n-    long n = addressOfStackSlot(INTERPRETER_FRAME_LOCALS_OFFSET).getCIntegerAt(0, VM.getVM().getAddressSize(), false);\n-    return getFP().addOffsetTo(n * VM.getVM().getAddressSize());\n-  }\n-\n-  private Address addressOfInterpreterFrameBCX() {\n-    return addressOfStackSlot(INTERPRETER_FRAME_BCX_OFFSET);\n-  }\n-\n-  public Address getInterpreterFrameBCP() {\n-    \/\/ FIXME: this is not atomic with respect to GC and is unsuitable\n-    \/\/ for use in a non-debugging, or reflective, system. Need to\n-    \/\/ figure out how to express this.\n-\n-    Method method = getInterpreterFrameMethod();\n-    Address bcp = addressOfInterpreterFrameBCX().getAddressAt(0);\n-\n-    \/\/ If we are in the top level frame then the bcp may have been set for us. If so then let it\n-    \/\/ take priority. If we are in a top level interpreter frame, the bcp is live in R13 (on x86_64)\n-    \/\/ and not saved in the BCX stack slot.\n-    if (live_bcp != null) {\n-        \/\/ Only use live_bcp if it points within the Method's bytecodes. Sometimes R13 is used\n-        \/\/ for scratch purposes and is not a valid BCP. If it is not valid, then we stick with\n-        \/\/ the bcp stored in the frame, which R13 should have been flushed to.\n-        if (method.getConstMethod().isAddressInMethod(live_bcp)) {\n-            bcp = live_bcp;\n-        }\n-    }\n-\n-    return bcp;\n-  }\n-\n-  public int getInterpreterFrameBCI() {\n-    Address bcp = getInterpreterFrameBCP();\n-    Method method = getInterpreterFrameMethod();\n-    return bcpToBci(bcp, method);\n-  }\n-\n-  public Address addressOfInterpreterFrameMDX() {\n-    return addressOfStackSlot(INTERPRETER_FRAME_MDX_OFFSET);\n-  }\n-\n-  \/\/ FIXME\n-  \/\/inline int frame::interpreter_frame_monitor_size() {\n-  \/\/  return BasicObjectLock::size();\n-  \/\/}\n-\n-  \/\/ expression stack\n-  \/\/ (the max_stack arguments are used by the GC; see class FrameClosure)\n-\n-  public Address addressOfInterpreterFrameExpressionStack() {\n-    Address monitorEnd = interpreterFrameMonitorEnd().address();\n-    return monitorEnd.addOffsetTo(-1 * VM.getVM().getAddressSize());\n-  }\n-\n-  public int getInterpreterFrameExpressionStackDirection() { return -1; }\n-\n-  \/\/ top of expression stack\n-  public Address addressOfInterpreterFrameTOS() {\n-    return getSP();\n-  }\n-\n-  \/** Expression stack from top down *\/\n-  public Address addressOfInterpreterFrameTOSAt(int slot) {\n-    return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());\n-  }\n-\n-  public Address getInterpreterFrameSenderSP() {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that(isInterpretedFrame(), \"interpreted frame expected\");\n-    }\n-    return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);\n-  }\n-\n-  \/\/ Monitors\n-  public BasicObjectLock interpreterFrameMonitorBegin() {\n-    return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));\n-  }\n-\n-  public BasicObjectLock interpreterFrameMonitorEnd() {\n-    long n = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getCIntegerAt(0, VM.getVM().getAddressSize(), false);\n-    Address result = getFP().addOffsetTo(n * VM.getVM().getAddressSize());\n-    if (Assert.ASSERTS_ENABLED) {\n-      \/\/ make sure the pointer points inside the frame\n-      Assert.that(AddressOps.gt(getFP(), result), \"result must <  than frame pointer\");\n-      Assert.that(AddressOps.lte(getSP(), result), \"result must >= than stack pointer\");\n-    }\n-    return new BasicObjectLock(result);\n-  }\n-\n-  public int interpreterFrameMonitorSize() {\n-    return BasicObjectLock.size();\n-  }\n-\n-  \/\/ Method\n-  public Address addressOfInterpreterFrameMethod() {\n-    return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);\n-  }\n-\n-  \/\/ Constant pool cache\n-  public Address addressOfInterpreterFrameCPCache() {\n-    return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);\n-  }\n-\n-  \/\/ Entry frames\n-  public JavaCallWrapper getEntryFrameCallWrapper() {\n-    return new X86JavaCallWrapper(addressOfStackSlot(ENTRY_FRAME_CALL_WRAPPER_OFFSET).getAddressAt(0));\n-  }\n-\n-  protected Address addressOfSavedOopResult() {\n-    \/\/ offset is 2 for compiler2 and 3 for compiler1\n-    return getSP().addOffsetTo((VM.getVM().isClientCompiler() ? 2 : 3) *\n-                               VM.getVM().getAddressSize());\n-  }\n-\n-  protected Address addressOfSavedReceiver() {\n-    return getSP().addOffsetTo(-4 * VM.getVM().getAddressSize());\n-  }\n-\n-  private void dumpStack() {\n-    if (getFP() != null) {\n-      for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());\n-           AddressOps.lte(addr, getFP().addOffsetTo(5 * VM.getVM().getAddressSize()));\n-           addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {\n-        System.out.println(addr + \": \" + addr.getAddressAt(0));\n-      }\n-    } else {\n-      for (Address addr = getSP().addOffsetTo(-5 * VM.getVM().getAddressSize());\n-           AddressOps.lte(addr, getSP().addOffsetTo(20 * VM.getVM().getAddressSize()));\n-           addr = addr.addOffsetTo(VM.getVM().getAddressSize())) {\n-        System.out.println(addr + \": \" + addr.getAddressAt(0));\n-      }\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":0,"deletions":576,"binary":false,"changes":576,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.x86;\n-\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class X86JavaCallWrapper extends JavaCallWrapper {\n-  private static AddressField lastJavaFPField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"JavaFrameAnchor\");\n-\n-    lastJavaFPField  = type.getAddressField(\"_last_Java_fp\");\n-  }\n-\n-  public X86JavaCallWrapper(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Address getLastJavaFP() {\n-    return lastJavaFPField.getValue(addr.addOffsetTo(anchorField.getOffset()));\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86JavaCallWrapper.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.runtime.x86;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-\n-public class X86RegisterMap extends RegisterMap {\n-\n-  \/** This is the only public constructor *\/\n-  public X86RegisterMap(JavaThread thread, boolean updateMap) {\n-    super(thread, updateMap);\n-  }\n-\n-  protected X86RegisterMap(RegisterMap map) {\n-    super(map);\n-  }\n-\n-  public Object clone() {\n-    X86RegisterMap retval = new X86RegisterMap(this);\n-    return retval;\n-  }\n-\n-  \/\/ no PD state to clear or copy:\n-  protected void clearPD() {}\n-  protected void initializePD() {}\n-  protected void initializeFromPD(RegisterMap map) {}\n-  protected Address getLocationPD(VMReg reg) { return null; }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86RegisterMap.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -629,1 +629,1 @@\n-    DummyDebugger debugger = new DummyDebugger(new MachineDescriptionIntelX86());\n+    DummyDebugger debugger = new DummyDebugger(new MachineDescriptionAMD64());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/AnnotatedMemoryPanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        new String[] {\"i386\", \"x86\", \"x86_64\", \"amd64\", \"ppc64\", \"ppc64le\", \"aarch64\", \"riscv64\"};\n+        new String[] {\"x86_64\", \"amd64\", \"ppc64\", \"ppc64le\", \"aarch64\", \"riscv64\"};\n@@ -63,2 +63,2 @@\n-  \/* Returns \"x86\" for x86 based platforms and x86_64 for 64bit x86\n-     based platform. Otherwise returns the value of os.arch. If the\n+  \/* Returns \"amd64\" for x86_64 based platforms.\n+     Otherwise returns the value of os.arch. If the\n@@ -77,3 +77,0 @@\n-    if (cpu.equals(\"i386\"))\n-      return \"x86\";\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PlatformInfo.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}