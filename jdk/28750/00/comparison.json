{"files":[{"patch":"@@ -401,1 +401,14 @@\n-        n = sendto(fd, sendbuf, plen, 0, &sa->sa, sizeof(struct sockaddr_in));\n+        while (1) {\n+            n = sendto(fd, sendbuf, plen, 0, &sa->sa, sizeof(struct sockaddr_in));\n+            if (n < 0 && errno == EINTR) {\n+                struct timeval now = {0, 0};\n+                gettimeofday(&now, NULL);\n+                if (timerMillisExpired(&tv, &now, timeout)) {\n+                    NET_ThrowNew(env, errno, \"Can't send ICMP packet\");\n+                    close(fd);\n+                    return JNI_FALSE;\n+                }\n+                continue;\n+            }\n+            break;\n+        }\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -607,1 +607,14 @@\n-        n = sendto(fd, sendbuf, plen, 0, &sa->sa, sizeof(struct sockaddr_in6));\n+        while (1) {\n+            n = sendto(fd, sendbuf, plen, 0, &sa->sa, sizeof(struct sockaddr_in6));\n+            if (n < 0 && errno == EINTR) {\n+                struct timeval now = {0, 0};\n+                gettimeofday(&now, NULL);\n+                if (timerMillisExpired(&tv, &now, timeout)) {\n+                    NET_ThrowNew(env, errno, \"Can't send ICMP packet\");\n+                    close(fd);\n+                    return JNI_FALSE;\n+                }\n+                continue;\n+            }\n+            break;\n+        }\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -79,3 +79,0 @@\n-    case EINTR:\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\", msg);\n-        break;\n@@ -652,0 +649,30 @@\n+\n+#define ONE_MILLION 1000000\n+\n+\/**\n+ * Return 0 (not expired) if the start timeval plus timeout\n+ * is past end timeval\n+ * Return 1 (expired) if end is after start plus timeout\n+ *\/\n+JNIEXPORT int JNICALL\n+timerMillisExpired(struct timeval *start, struct timeval *end, int timeMillis) {\n+    int timeoutSec = timeMillis \/ 1000;\n+    int timeoutUsec = (timeMillis % 1000) * 1000;\n+    struct timeval tv0 = *start;\n+    struct timeval tv1 = *end;\n+    tv0.tv_sec += timeoutSec;\n+    tv0.tv_usec += timeoutUsec;\n+    if (tv0.tv_usec >= ONE_MILLION) {\n+        tv0.tv_sec ++;\n+        tv0.tv_usec -= ONE_MILLION;\n+    }\n+    \/* Now check if tv1 is past tv0 *\/\n+    if (tv0.tv_sec < tv1.tv_sec) {\n+        return 1; \/* expired *\/\n+    } else if (tv0.tv_sec == tv1.tv_sec) {\n+        if (tv0.tv_usec < tv1.tv_usec) {\n+            return 1; \/* expired *\/\n+        }\n+    }\n+    return 0; \/* not expired *\/\n+}\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <sys\/time.h>\n@@ -83,0 +84,7 @@\n+\/**\n+ * Return 1 if the end timeval is past\n+ * start timeval plus timeout milliseconds.\n+ * Return 0 otherwise.\n+ *\/\n+extern int timerMillisExpired(struct timeval *start, struct timeval *end, int timeMillis);\n+\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.*;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8370655\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TimerCompare\n+ * @summary Check EINTR handling InetAddress implementation and NET_ThrowNew\n+ *\/\n+\n+\/**\n+ * This only exercises the new timerMillisExpired() function added to net_util_md.c\n+ *\/\n+public class TimerCompare {\n+\n+    private static SegmentAllocator autoAllocator =\n+            (byteSize, byteAlignment) -> Arena.ofAuto().allocate(byteSize, byteAlignment);\n+\n+    @DataProvider(name = \"testArgs\")\n+    private static Object[][] targs() {\n+        return new Object[][] {\n+                \/\/ timeout is added to start timeval. If end timeval lies before this\n+                \/\/ time then timer should be expired. If after it, timer should not be.\n+                \/\/\n+                \/\/  start timeval       end timeval\n+                \/\/ s_sec,   s_usec,   e_sec,    e_usec,   timeout(ms),    expired(int)\n+                  {10,      0,        10,       110,      1000,           0},\n+                  {1,       0,        1,        3000,     1,              1},\n+                  {1,       900000,   2,        300,      200,            0},\n+                  {1,       900000,   2,        200000,   101,            1},\n+                  {1,       900000,   2,        200000,   301,            0},\n+                  {1,       900000,   2,        200000,   199,            1}\n+        };\n+    }\n+\n+    static int count = 1;\n+\n+    @Test(dataProvider = \"testArgs\")\n+    public static void test(long s_sec, int s_usec, long e_sec, int e_usec,\n+                            int timeout_ms, int expect) {\n+        System.out.println(\"Iteration: \" + count++);\n+        MemorySegment start = timeval.allocate(autoAllocator);\n+        timeval.tv_sec(start, s_sec);\n+        timeval.tv_usec(start, s_usec);\n+\n+        MemorySegment end = timeval.allocate(autoAllocator);\n+        timeval.tv_sec(end, e_sec);\n+        timeval.tv_usec(end, e_usec);\n+\n+        int result = timetest_h.timerMillisExpired(start, end, timeout_ms);\n+        Assert.assertEquals(result, expect);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/native\/TimerCompare.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+public class timetest_h$shared {\n+\n+    timetest_h$shared() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+    public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+    public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+\n+    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n+\n+    static void traceDowncall(String name, Object... args) {\n+         String traceArgs = Arrays.stream(args)\n+                       .map(Object::toString)\n+                       .collect(Collectors.joining(\", \"));\n+         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/native\/timetest_h$shared.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+import java.io.IOException;\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+public class timetest_h extends timetest_h$shared {\n+\n+    timetest_h() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n+\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(\n+        System.mapLibraryName(\"net\"), LIBRARY_ARENA);\n+\n+    \/\/static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup();\n+            \/\/.or(Linker.nativeLinker().defaultLookup());\n+\n+    private static class timerMillisExpired {\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n+            timetest_h.C_INT,\n+            timetest_h.C_POINTER,\n+            timetest_h.C_POINTER,\n+            timetest_h.C_INT\n+        );\n+\n+        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"timerMillisExpired\");\n+\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+    }\n+\n+    \/**\n+     * Function descriptor for:\n+     * {@snippet lang=c :\n+     * extern int timerMillisExpired(struct timeval *start, struct timeval *end, int timeMillis)\n+     * }\n+     *\/\n+    public static FunctionDescriptor timerMillisExpired$descriptor() {\n+        return timerMillisExpired.DESC;\n+    }\n+\n+    \/**\n+     * Downcall method handle for:\n+     * {@snippet lang=c :\n+     * extern int timerMillisExpired(struct timeval *start, struct timeval *end, int timeMillis)\n+     * }\n+     *\/\n+    public static MethodHandle timerMillisExpired$handle() {\n+        return timerMillisExpired.HANDLE;\n+    }\n+\n+    \/**\n+     * Address for:\n+     * {@snippet lang=c :\n+     * extern int timerMillisExpired(struct timeval *start, struct timeval *end, int timeMillis)\n+     * }\n+     *\/\n+    public static MemorySegment timerMillisExpired$address() {\n+        return timerMillisExpired.ADDR;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * extern int timerMillisExpired(struct timeval *start, struct timeval *end, int timeMillis)\n+     * }\n+     *\/\n+    public static int timerMillisExpired(MemorySegment start, MemorySegment end, int timeMillis) {\n+        var mh$ = timerMillisExpired.HANDLE;\n+        try {\n+            if (TRACE_DOWNCALLS) {\n+                traceDowncall(\"timerMillisExpired\", start, end, timeMillis);\n+            }\n+            return (int)mh$.invokeExact(start, end, timeMillis);\n+        } catch (Error | RuntimeException ex) {\n+           throw ex;\n+        } catch (Throwable ex$) {\n+           throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/native\/timetest_h.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct timeval {\n+ *     long tv_sec;\n+ *     int tv_usec;\n+ * }\n+ * }\n+ *\/\n+public class timeval {\n+\n+    timeval() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        timetest_h.C_LONG.withName(\"tv_sec\"),\n+        timetest_h.C_INT.withName(\"tv_usec\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"timeval\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfLong tv_sec$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"tv_sec\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * long tv_sec\n+     * }\n+     *\/\n+    public static final OfLong tv_sec$layout() {\n+        return tv_sec$LAYOUT;\n+    }\n+\n+    private static final long tv_sec$OFFSET = $LAYOUT.byteOffset(groupElement(\"tv_sec\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * long tv_sec\n+     * }\n+     *\/\n+    public static final long tv_sec$offset() {\n+        return tv_sec$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * long tv_sec\n+     * }\n+     *\/\n+    public static long tv_sec(MemorySegment struct) {\n+        return struct.get(tv_sec$LAYOUT, tv_sec$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * long tv_sec\n+     * }\n+     *\/\n+    public static void tv_sec(MemorySegment struct, long fieldValue) {\n+        struct.set(tv_sec$LAYOUT, tv_sec$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tv_usec$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tv_usec\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tv_usec\n+     * }\n+     *\/\n+    public static final OfInt tv_usec$layout() {\n+        return tv_usec$LAYOUT;\n+    }\n+\n+    private static final long tv_usec$OFFSET = $LAYOUT.byteOffset(groupElement(\"tv_usec\"));\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tv_usec\n+     * }\n+     *\/\n+    public static final long tv_usec$offset() {\n+        return tv_usec$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tv_usec\n+     * }\n+     *\/\n+    public static int tv_usec(MemorySegment struct) {\n+        return struct.get(tv_usec$LAYOUT, tv_usec$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tv_usec\n+     * }\n+     *\/\n+    public static void tv_usec(MemorySegment struct, int fieldValue) {\n+        struct.set(tv_usec$LAYOUT, tv_usec$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/native\/timeval.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"}]}