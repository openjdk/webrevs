{"files":[{"patch":"@@ -357,24 +357,0 @@\n-\n-AsyncLogWriter::BufferUpdater::BufferUpdater(size_t newsize) {\n-  ConsumerLocker clocker;\n-  auto p = AsyncLogWriter::_instance;\n-\n-  _buf1 = p->_buffer;\n-  _buf2 = p->_buffer_staging;\n-  p->_buffer = new Buffer(newsize);\n-  p->_buffer_staging = new Buffer(newsize);\n-}\n-\n-AsyncLogWriter::BufferUpdater::~BufferUpdater() {\n-  AsyncLogWriter::flush();\n-  auto p = AsyncLogWriter::_instance;\n-\n-  {\n-    ConsumerLocker clocker;\n-\n-    delete p->_buffer;\n-    delete p->_buffer_staging;\n-    p->_buffer = _buf1;\n-    p->_buffer_staging = _buf2;\n-  }\n-}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -202,10 +202,0 @@\n-  \/\/ for testing-only\n-  class BufferUpdater {\n-    Buffer* _buf1;\n-    Buffer* _buf2;\n-\n-   public:\n-    BufferUpdater(size_t newsize);\n-    ~BufferUpdater();\n-  };\n-\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,3 +72,0 @@\n-  \/\/ Caveat: BufferUpdater is not MT-safe. We use it only for testing.\n-  \/\/ We would observe missing loglines if we interleaved buffers.\n-  \/\/ Emit all logs between constructor and destructor of BufferUpdater.\n@@ -76,1 +73,3 @@\n-    const size_t sz = 2000;\n+    const size_t sz = AsyncLogBufferSize \/ 2;\n+    const char* str = \"a lot of log...\";\n+    const size_t str_size = strlen(str);\n@@ -78,2 +77,0 @@\n-    \/\/ shrink async buffer.\n-    AsyncLogWriter::BufferUpdater saver(1024);\n@@ -84,2 +81,2 @@\n-    for (size_t i = 0; i < sz; ++i) {\n-      lm.debug(\"a lot of log...\");\n+    for (size_t i = 0; i < (sz \/ str_size); ++i) {\n+      lm.debug(\"%s\", str);\n@@ -87,0 +84,4 @@\n+    lm.debug(\"%s\", str);\n+    lm.debug(\"%s\", str);\n+    lm.debug(\"%s\", str);\n+    lm.debug(\"%s\", str);\n@@ -247,1 +248,3 @@\n-  if (AsyncLogWriter::instance() == nullptr) {\n+  if (AsyncLogWriter::instance() == nullptr) return;\n+  if (LogConfiguration::async_mode() != LogConfiguration::AsyncMode::Drop) {\n+    FAIL() << \"This test must be run in drop mode if async UL is activated\";\n@@ -253,1 +256,20 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  bool messages_dropped = file_contains_substring(TestLogFileName, \"messages dropped due to async logging\");\n+  if (!messages_dropped) {\n+    stringStream content;\n+    FILE* fp = os::fopen(TestLogFileName, \"r\");\n+    assert(fp != nullptr, \"error opening file %s: %s\", TestLogFileName, os::strerror(errno));\n+    {\n+      ResourceMark rm;\n+      char* line = read_line(fp);\n+      while (line != nullptr) {\n+        ResourceMark rm;\n+        content.print_raw(line);\n+        line = read_line(fp);\n+      }\n+    }\n+\n+    \/\/ The thread is null and deattached.\n+    \/\/ That means that UL degrades to synchronous logging for this thread, which means that no messages can be dropped.\n+    EXPECT_NE(nullptr, Thread::current_or_null()) << \"Thread was null\";\n+    EXPECT_TRUE(messages_dropped) << \"Log file content:\\n\" << content.freeze();\n+  }\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n- * @run main\/native GTestWrapper --gtest_filter=AsyncLogTest* -Xlog:async\n- * @run main\/native GTestWrapper --gtest_filter=Log*Test* -Xlog:async\n+ * @run main\/native GTestWrapper --gtest_filter=AsyncLogTest* -Xlog:async -XX:AsyncLogBufferSize=100K\n+ * @run main\/native GTestWrapper --gtest_filter=Log*Test* -Xlog:async -XX:AsyncLogBufferSize=100K\n","filename":"test\/hotspot\/jtreg\/gtest\/AsyncLogGtest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}