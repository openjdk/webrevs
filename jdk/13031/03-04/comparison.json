{"files":[{"patch":"@@ -1315,4 +1315,2 @@\n-                    if (newWeekOfYear == 1 && (isInvalidWeek1())) {\n-                        if (amount > 0) {\n-                            newWeekOfYear++;\n-                        }\n+                    if (newWeekOfYear == 1 && isInvalidWeek1() && amount > 0) {\n+                        newWeekOfYear++;\n@@ -3004,11 +3002,3 @@\n-        \/\/ If the week is minimum, check if the DAY_OF_WEEK does not exist\n-        return isMinWeek(daysInFirstWeek) &&\n-                dayNotInMinWeek(internalGet(DAY_OF_WEEK), jan1Dow, getFirstDayOfWeek() - 1);\n-    }\n-\n-    \/**\n-     * Determines if the specified amount of days can make up\n-     * a valid minimum week.\n-     *\/\n-    private boolean isMinWeek (int days) {\n-        return days >= getMinimalDaysInFirstWeek();\n+        \/\/ If the week is a valid minimum, check if the DAY_OF_WEEK does not exist\n+        return daysInFirstWeek >= getMinimalDaysInFirstWeek() &&\n+                !dayInMinWeek(internalGet(DAY_OF_WEEK), jan1Dow, getFirstDayOfWeek() - 1);\n@@ -3019,1 +3009,1 @@\n-     * For example, dayNotInMinWeek(4, 6, 3) returns false since Wednesday\n+     * For example, dayInMinWeek(4, 6, 3) returns false since Wednesday\n@@ -3023,1 +3013,3 @@\n-    private boolean dayNotInMinWeek (int day, int startDay, int endDay) {\n+    private boolean dayInMinWeek (int day, int startDay, int endDay) {\n+        endDay = endDay == 0\n+                ? 7 : endDay;\n@@ -3025,3 +3017,3 @@\n-            \/\/ dayNotInMinWeek(2, 3, 6), check that 2 is\n-            \/\/ not between 3 4 5 6\n-            return !(day >= startDay && day <= endDay);\n+            \/\/ dayInMinWeek(6, 3, 5), check that 6 is\n+            \/\/ between 3 4 5\n+            return (day >= startDay && day <= endDay);\n@@ -3029,3 +3021,3 @@\n-            \/\/ dayNotInMinWeek(4, 6, 3), check that 4 is\n-            \/\/ not between 6 7 1 2 3\n-            return !(day >= startDay || day <= endDay);\n+            \/\/ dayInMinWeek(4, 6, 3), check that 4 is\n+            \/\/ between 6 7 1 2 3\n+            return (day >= startDay || day <= endDay);\n","filename":"src\/java.base\/share\/classes\/java\/util\/GregorianCalendar.java","additions":15,"deletions":23,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8225641\n+ * @summary Test the behavior of GregorianCalendar.roll(WEEK_OF_YEAR)\n+ * when the last week is rolled into the first week of the same year\n+ * @run junit RollFromLastToFirstWeek\n+ *\/\n+\n+\n+import java.util.*;\n+import java.util.stream.Stream;\n+import static java.util.Calendar.*;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+\/**\n+ * Test to validate the behavior of GregorianCalendar.roll(WEEK_OF_YEAR, +1)\n+ * when rolling from the last week of a year into the first week of the same year.\n+ * This only test the implementation of the Gregorian Calendar roll.\n+ *\n+ * Rolling from the last week of a year into the first week of the same year\n+ * could cause a WEEK_OF_YEAR with a non-existent DAY_OF_WEEK combination.\n+ * The associated fix ensures that a final check is made, so that the first\n+ * week is incremented to prevent this.\n+ *\/\n+public class RollFromLastToFirstWeek {\n+    static Calendar.Builder GREGORIAN_BUILDER = new Builder()\n+            .setCalendarType(\"gregory\");\n+\n+    @ParameterizedTest\n+    @MethodSource(\"rollUpCalProvider\")\n+    public void rollUpTest(Calendar calendar, String[] validDates){\n+        if (calendar instanceof GregorianCalendar) {\n+            testRoll(calendar, validDates);\n+        } else {\n+            fail(String.format(\"Calendar is not Gregorian: %s\", calendar));\n+        }\n+    }\n+\n+    private void testRoll(Calendar calendar, String[] validDates) {\n+        String originalDate = longDateString(calendar);\n+        calendar.roll(Calendar.WEEK_OF_YEAR, 1);\n+        String rolledDate = longDateString(calendar);\n+        if (!Arrays.asList(validDates).contains(rolledDate)) {\n+            fail(String.format(\"\"\"\n+            {$$$ Failed: Rolled: \"%s\" by 1 week, where the first day of the week\n+            is: %s with a minimum week length of: %s and was expecting one of: \"%s\", but got: \"%s\"},\n+            \"\"\", originalDate, calendar.getFirstDayOfWeek(),\n+                    calendar.getMinimalDaysInFirstWeek(), Arrays.toString(validDates), rolledDate));\n+        } else {\n+            System.out.printf(\"\"\"\n+            {$$$ Passed: Rolled: \"%s\" by 1 week where the first day of the week\n+            is: %s with a minimum week length of: %s and successfully got: \"%s\"},\n+            \"\"\", originalDate, calendar.getFirstDayOfWeek(),\n+                    calendar.getMinimalDaysInFirstWeek(), rolledDate);\n+        }\n+    }\n+\n+    \/\/ This implicitly tests the Iso8601 calendar as\n+    \/\/ MinWeek = 4 and FirstDayOfWeek = Monday is included in the provider\n+    private static Stream<Arguments> rollUpCalProvider() {\n+        ArrayList<Arguments> calList = new ArrayList<Arguments>();\n+        \/\/ Week 1, Week 2 are all potential dates to roll into\n+        \/\/ Depends on first day of week \/ min days in week\n+        String[][] validDates = {\n+                {\"Wednesday, 2 January 2019\", \"Wednesday, 9 January 2019\"},\n+                {\"Thursday, 3 January 2019\" , \"Thursday, 10 January 2019\"},\n+                {\"Friday, 4 January 2019\"   , \"Friday, 11 January 2019\"},\n+                {\"Saturday, 5 January 2019\" , \"Saturday, 12 January 2019\"},\n+                {\"Sunday, 6 January 2019\"   , \"Sunday, 13 January 2019\"},\n+                {\"Monday, 7 January 2019\"   , \"Monday, 14 January 2019\"},\n+                {\"Tuesday, 1 January 2019\"  , \"Tuesday, 8 January 2019\"}\n+        };\n+        int date = 0;\n+        \/\/ Test all days at the end of the year that roll into week 1\n+        for (int dayOfMonth = 25; dayOfMonth <= 31; dayOfMonth++) {\n+            for (int weekLength = 1; weekLength <= 7; weekLength++) {\n+                \/\/ Sunday .. Monday -> Saturday\n+                for (int firstDay = SUNDAY; firstDay <= SATURDAY; firstDay++) {\n+                    calList.add(Arguments.of(buildCalendar(firstDay, weekLength,\n+                                    dayOfMonth, DECEMBER, 2019), validDates[date]));\n+                }\n+            }\n+            date++;\n+        }\n+        return calList.stream();\n+    }\n+\n+    private static Calendar buildCalendar(int firstDayOfWeek,\n+                                          int minimumWeekLength, int dayOfMonth,\n+                                          int month, int year) {\n+        return GREGORIAN_BUILDER\n+                .setWeekDefinition(firstDayOfWeek, minimumWeekLength)\n+                .setDate(year, month, dayOfMonth)\n+                .build();\n+    }\n+\n+    private static String longDateString(Calendar calendar) {\n+        return String.format(\"%s, %s %s %s\",\n+                calendar.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.ENGLISH),\n+                calendar.get(Calendar.DAY_OF_MONTH),\n+                calendar.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.ENGLISH),\n+                calendar.get(YEAR));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/RollFromLastToFirstWeek.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8225641\n- * @summary Test the behavior of Calendar.roll(WEEK_OF_YEAR) when the last week\n- * is rolled up into a minimal week 1 of the same year\n- * @run junit RollToMinWeek\n- *\/\n-\n-\n-import java.util.*;\n-import java.util.stream.Stream;\n-import static java.util.Calendar.*;\n-import static org.junit.jupiter.api.Assertions.fail;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import org.junit.jupiter.params.provider.Arguments;\n-\n-\/**\n- * Test to validate the behavior of Calendar.roll(WEEK_OF_YEAR, +1)\n- * when rolling into a minimal week 1 from the max week. WEEK_OF_YEAR can\n- * not be rolled to a week with a non-existent DAY_OF_WEEK. This only\n- * test the implementation of the Gregorian Calendar roll\n- *\/\n-public class RollToMinWeek {\n-    @ParameterizedTest\n-    @MethodSource(\"rollUpCalProvider\")\n-    public void rollUpTest(Calendar calendar, String[] validDates){\n-        if (calendar instanceof GregorianCalendar) {\n-            testRoll(calendar, validDates, +1);\n-        } else {\n-            fail(String.format(\"Calendar is not Gregorian: %s\", calendar));\n-        }\n-    }\n-\n-    private void testRoll(Calendar calendar, String[] validDates, int amount) {\n-        String originalDate = longDateString(calendar);\n-        calendar.roll(Calendar.WEEK_OF_YEAR, amount);\n-        String rolledDate = longDateString(calendar);\n-        if (!Arrays.asList(validDates).contains(rolledDate)) {\n-            fail(String.format(\"\"\"\n-            {$$$ Failed: Rolled: \"%s\" by %s week, where the first day of the week\n-            is: %s with a minimum week length of: %s and was expecting one of: \"%s\", but got: \"%s\"},\n-            \"\"\", originalDate, amount, calendar.getFirstDayOfWeek(),\n-                    calendar.getMinimalDaysInFirstWeek(), Arrays.toString(validDates), rolledDate));\n-        } else {\n-            System.out.printf(\"\"\"\n-            {$$$ Passed: Rolled: \"%s\" by %s week where the first day of the week\n-            is: %s with a minimum week length of: %s and successfully got: \"%s\"},\n-            \"\"\", originalDate, amount, calendar.getFirstDayOfWeek(),\n-                    calendar.getMinimalDaysInFirstWeek(), rolledDate);\n-        }\n-    }\n-\n-    \/\/ This implicitly tests the Iso8601 calendar as\n-    \/\/ MinWeek = 4 and FirstDayOfWeek = Monday is included in the provider\n-    private static Stream<Arguments> rollUpCalProvider() {\n-        ArrayList<Arguments> calList = new ArrayList<Arguments>();\n-        \/\/ Week 1, Week 2 are all potential dates to roll into\n-        \/\/ Depends on first day of week \/ min days in week\n-        String[][] validDates = {\n-                {\"Wednesday, 2 January 2019\", \"Wednesday, 9 January 2019\"},\n-                {\"Thursday, 3 January 2019\" , \"Thursday, 10 January 2019\"},\n-                {\"Friday, 4 January 2019\"   , \"Friday, 11 January 2019\"},\n-                {\"Saturday, 5 January 2019\" , \"Saturday, 12 January 2019\"},\n-                {\"Sunday, 6 January 2019\"   , \"Sunday, 13 January 2019\"},\n-                {\"Monday, 7 January 2019\"   , \"Monday, 14 January 2019\"},\n-                {\"Tuesday, 1 January 2019\"  , \"Tuesday, 8 January 2019\"}\n-        };\n-        int date = 0;\n-        \/\/ Test all days at the end of the year that roll into week 1\n-        for (int dayOfMonth = 25; dayOfMonth <= 31; dayOfMonth++) {\n-            for (int weekLength = 1; weekLength <= 7; weekLength++) {\n-                for (int firstDay = 1; firstDay <= 7; firstDay++) {\n-                    calList.add(Arguments.of(buildCalendar(\"gregory\", firstDay, weekLength,\n-                                    dayOfMonth, 11, 2019), validDates[date]));\n-                }\n-            }\n-            date++;\n-        }\n-        return calList.stream();\n-    }\n-\n-    private static Calendar buildCalendar(String type, int firstDayOfWeek,\n-                                 int minimumWeekLength, int dayOfMonth,\n-                                 int month, int year) {\n-        Calendar.Builder calBuilder = new Builder();\n-        calBuilder.setCalendarType(type);\n-        calBuilder.setWeekDefinition(firstDayOfWeek, minimumWeekLength);\n-        calBuilder.setDate(year, month, dayOfMonth);\n-        return calBuilder.build();\n-    }\n-\n-    private static String longDateString(Calendar calendar) {\n-        return String.format(\"%s, %s %s %s\",\n-                calendar.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.ENGLISH),\n-                calendar.get(Calendar.DAY_OF_MONTH),\n-                calendar.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.ENGLISH),\n-                calendar.get(YEAR));\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Calendar\/RollToMinWeek.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"}]}