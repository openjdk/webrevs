{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1310,1 +1310,11 @@\n-                    set(field, getRolledValue(woy, amount, min, max));\n+                    int newWeekOfYear = getRolledValue(woy, amount, min, max);\n+                    \/\/ Final check to ensure that the first week has the\n+                    \/\/ current DAY_OF_WEEK. Only make a check for\n+                    \/\/ rolling up into week 1, as the existing checks\n+                    \/\/ sufficiently handle rolling down into week 1.\n+                    if (newWeekOfYear == 1 && (isInvalidWeek1())) {\n+                        if (amount > 0) {\n+                            newWeekOfYear++;\n+                        }\n+                    }\n+                    set(field, newWeekOfYear);\n@@ -2975,0 +2985,50 @@\n+    \/**\n+     * {@return {@code true} if the first week of the current year is minimum\n+     * and the {@code DAY_OF_WEEK} does not exist in that week}\n+     *\n+     * This method is used to check the validity of a {@code WEEK_OF_YEAR} and\n+     * {@code DAY_OF_WEEK} combo when WEEK_OF_YEAR is rolled to a value of 1.\n+     * This prevents other methods from calling complete() with an invalid combo.\n+     *\/\n+    private boolean isInvalidWeek1() {\n+        \/\/ Calculate the DAY_OF_WEEK for Jan 1 of the current YEAR\n+        long jan1Fd =  gcal.getFixedDate(internalGet(YEAR), 1, 1, null);\n+        int jan1Dow = BaseCalendar.getDayOfWeekFromFixedDate(jan1Fd);\n+        int daysInFirstWeek;\n+        if (getFirstDayOfWeek() <= jan1Dow) {\n+            \/\/ Add wrap around days\n+            daysInFirstWeek = (7 - jan1Dow) + getFirstDayOfWeek();\n+        } else {\n+            daysInFirstWeek = getFirstDayOfWeek() - jan1Dow;\n+        }\n+        \/\/ If the week is minimum, check if the DAY_OF_WEEK does not exist\n+        return isMinWeek(daysInFirstWeek) &&\n+                dayNotInMinWeek(internalGet(DAY_OF_WEEK), jan1Dow, getFirstDayOfWeek() - 1);\n+    }\n+\n+    \/**\n+     * Determines if the specified amount of days can make up\n+     * a valid minimum week.\n+     *\/\n+    private boolean isMinWeek (int days) {\n+        return days >= getMinimalDaysInFirstWeek();\n+    }\n+\n+    \/**\n+     * Determines if the specified day exists in the minimum week.\n+     * For example, dayNotInMinWeek(4, 6, 3) returns false since Wednesday\n+     * is not between the minimum week given by [Friday, Saturday,\n+     * Sunday, Monday, Tuesday].\n+     *\/\n+    private boolean dayNotInMinWeek (int day, int startDay, int endDay) {\n+        if (endDay >= startDay) {\n+            \/\/ dayNotInMinWeek(2, 3, 6), check that 2 is\n+            \/\/ not between 3 4 5 6\n+            return !(day >= startDay && day <= endDay);\n+        } else {\n+            \/\/ dayNotInMinWeek(4, 6, 3), check that 4 is\n+            \/\/ not between 6 7 1 2 3\n+            return !(day >= startDay || day <= endDay);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/GregorianCalendar.java","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8225641\n+ * @summary Test the behavior of Calendar.roll(WEEK_OF_YEAR) when the last week\n+ * is rolled up into a minimal week 1 of the same year\n+ * @run junit RollToMinWeek\n+ *\/\n+\n+\n+import java.util.*;\n+import java.util.stream.Stream;\n+import static java.util.Calendar.*;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+\/**\n+ * Test to validate the behavior of Calendar.roll(WEEK_OF_YEAR, +1)\n+ * when rolling into a minimal week 1 from the max week. WEEK_OF_YEAR can\n+ * not be rolled to a week with a non-existent DAY_OF_WEEK. This only\n+ * test the implementation of the Gregorian Calendar roll\n+ *\/\n+public class RollToMinWeek {\n+    @ParameterizedTest\n+    @MethodSource(\"rollUpCalProvider\")\n+    public void rollUpTest(Calendar calendar, String[] validDates){\n+        if (calendar instanceof GregorianCalendar) {\n+            testRoll(calendar, validDates, +1);\n+        } else {\n+            fail(String.format(\"Calendar is not Gregorian: %s\", calendar));\n+        }\n+    }\n+\n+    private void testRoll(Calendar calendar, String[] validDates, int amount) {\n+        String originalDate = longDateString(calendar);\n+        calendar.roll(Calendar.WEEK_OF_YEAR, amount);\n+        String rolledDate = longDateString(calendar);\n+        if (!Arrays.asList(validDates).contains(rolledDate)) {\n+            fail(String.format(\"\"\"\n+            {$$$ Failed: Rolled: \"%s\" by %s week, where the first day of the week\n+            is: %s with a minimum week length of: %s and was expecting one of: \"%s\", but got: \"%s\"},\n+            \"\"\", originalDate, amount, calendar.getFirstDayOfWeek(),\n+                    calendar.getMinimalDaysInFirstWeek(), Arrays.toString(validDates), rolledDate));\n+        } else {\n+            System.out.printf(\"\"\"\n+            {$$$ Passed: Rolled: \"%s\" by %s week where the first day of the week\n+            is: %s with a minimum week length of: %s and successfully got: \"%s\"},\n+            \"\"\", originalDate, amount, calendar.getFirstDayOfWeek(),\n+                    calendar.getMinimalDaysInFirstWeek(), rolledDate);\n+        }\n+    }\n+\n+    \/\/ This implicitly tests the Iso8601 calendar as\n+    \/\/ MinWeek = 4 and FirstDayOfWeek = Monday is included in the provider\n+    private static Stream<Arguments> rollUpCalProvider() {\n+        ArrayList<Arguments> calList = new ArrayList<Arguments>();\n+        \/\/ Week 1, Week 2 are all potential dates to roll into\n+        \/\/ Depends on first day of week \/ min days in week\n+        String[][] validDates = {\n+                {\"Wednesday, 2 January 2019\", \"Wednesday, 9 January 2019\"},\n+                {\"Thursday, 3 January 2019\" , \"Thursday, 10 January 2019\"},\n+                {\"Friday, 4 January 2019\"   , \"Friday, 11 January 2019\"},\n+                {\"Saturday, 5 January 2019\" , \"Saturday, 12 January 2019\"},\n+                {\"Sunday, 6 January 2019\"   , \"Sunday, 13 January 2019\"},\n+                {\"Monday, 7 January 2019\"   , \"Monday, 14 January 2019\"},\n+                {\"Tuesday, 1 January 2019\"  , \"Tuesday, 8 January 2019\"}\n+        };\n+        int date = 0;\n+        \/\/ Test all days at the end of the year that roll into week 1\n+        for (int dayOfMonth = 25; dayOfMonth <= 31; dayOfMonth++) {\n+            for (int weekLength = 1; weekLength <= 7; weekLength++) {\n+                for (int firstDay = 1; firstDay <= 7; firstDay++) {\n+                    calList.add(Arguments.of(buildCalendar(\"gregory\", firstDay, weekLength,\n+                                    dayOfMonth, 11, 2019), validDates[date]));\n+                }\n+            }\n+            date++;\n+        }\n+        return calList.stream();\n+    }\n+\n+    private static Calendar buildCalendar(String type, int firstDayOfWeek,\n+                                 int minimumWeekLength, int dayOfMonth,\n+                                 int month, int year) {\n+        Calendar.Builder calBuilder = new Builder();\n+        calBuilder.setCalendarType(type);\n+        calBuilder.setWeekDefinition(firstDayOfWeek, minimumWeekLength);\n+        calBuilder.setDate(year, month, dayOfMonth);\n+        return calBuilder.build();\n+    }\n+\n+    private static String longDateString(Calendar calendar) {\n+        return String.format(\"%s, %s %s %s\",\n+                calendar.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.ENGLISH),\n+                calendar.get(Calendar.DAY_OF_MONTH),\n+                calendar.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.ENGLISH),\n+                calendar.get(YEAR));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/RollToMinWeek.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}