{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1310,1 +1310,9 @@\n-                    set(field, getRolledValue(woy, amount, min, max));\n+                    int newWeekOfYear = getRolledValue(woy, amount, min, max);\n+                    \/\/ Final check to ensure that the first week has the\n+                    \/\/ current DAY_OF_WEEK. Only make a check for\n+                    \/\/ rolling up into week 1, as the existing checks\n+                    \/\/ sufficiently handle rolling down into week 1.\n+                    if (newWeekOfYear == 1 && isInvalidWeek1() && amount > 0) {\n+                        newWeekOfYear++;\n+                    }\n+                    set(field, newWeekOfYear);\n@@ -2975,0 +2983,44 @@\n+    \/**\n+     * {@return {@code true} if the first week of the current year is minimum\n+     * and the {@code DAY_OF_WEEK} does not exist in that week}\n+     *\n+     * This method is used to check the validity of a {@code WEEK_OF_YEAR} and\n+     * {@code DAY_OF_WEEK} combo when WEEK_OF_YEAR is rolled to a value of 1.\n+     * This prevents other methods from calling complete() with an invalid combo.\n+     *\/\n+    private boolean isInvalidWeek1() {\n+        \/\/ Calculate the DAY_OF_WEEK for Jan 1 of the current YEAR\n+        long jan1Fd =  gcal.getFixedDate(internalGet(YEAR), 1, 1, null);\n+        int jan1Dow = BaseCalendar.getDayOfWeekFromFixedDate(jan1Fd);\n+        int daysInFirstWeek;\n+        if (getFirstDayOfWeek() <= jan1Dow) {\n+            \/\/ Add wrap around days\n+            daysInFirstWeek = (7 - jan1Dow) + getFirstDayOfWeek();\n+        } else {\n+            daysInFirstWeek = getFirstDayOfWeek() - jan1Dow;\n+        }\n+        \/\/ If the week is a valid minimum, check if the DAY_OF_WEEK does not exist\n+        return daysInFirstWeek >= getMinimalDaysInFirstWeek() &&\n+                !dayInMinWeek(internalGet(DAY_OF_WEEK), jan1Dow, getFirstDayOfWeek() - 1);\n+    }\n+\n+    \/**\n+     * Determines if the specified day exists in the minimum week.\n+     * For example, dayInMinWeek(4, 6, 3) returns false since Wednesday\n+     * is not between the minimum week given by [Friday, Saturday,\n+     * Sunday, Monday, Tuesday].\n+     *\/\n+    private boolean dayInMinWeek (int day, int startDay, int endDay) {\n+        endDay = endDay == 0\n+                ? 7 : endDay;\n+        if (endDay >= startDay) {\n+            \/\/ dayInMinWeek(6, 3, 5), check that 6 is\n+            \/\/ between 3 4 5\n+            return (day >= startDay && day <= endDay);\n+        } else {\n+            \/\/ dayInMinWeek(4, 6, 3), check that 4 is\n+            \/\/ between 6 7 1 2 3\n+            return (day >= startDay || day <= endDay);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/GregorianCalendar.java","additions":54,"deletions":2,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8225641\n+ * @summary Test the behavior of GregorianCalendar.roll(WEEK_OF_YEAR)\n+ * when the last week is rolled into the first week of the same year\n+ * @run junit RollFromLastToFirstWeek\n+ *\/\n+\n+\n+import java.util.*;\n+import java.util.stream.Stream;\n+import static java.util.Calendar.*;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+\/**\n+ * Test to validate the behavior of GregorianCalendar.roll(WEEK_OF_YEAR, +1)\n+ * when rolling from the last week of a year into the first week of the same year.\n+ * This only test the implementation of the Gregorian Calendar roll.\n+ *\n+ * Rolling from the last week of a year into the first week of the same year\n+ * could cause a WEEK_OF_YEAR with a non-existent DAY_OF_WEEK combination.\n+ * The associated fix ensures that a final check is made, so that the first\n+ * week is incremented to prevent this.\n+ *\/\n+public class RollFromLastToFirstWeek {\n+    static Calendar.Builder GREGORIAN_BUILDER = new Builder()\n+            .setCalendarType(\"gregory\");\n+\n+    @ParameterizedTest\n+    @MethodSource(\"rollUpCalProvider\")\n+    public void rollUpTest(Calendar calendar, String[] validDates){\n+        if (calendar instanceof GregorianCalendar) {\n+            testRoll(calendar, validDates);\n+        } else {\n+            fail(String.format(\"Calendar is not Gregorian: %s\", calendar));\n+        }\n+    }\n+\n+    private void testRoll(Calendar calendar, String[] validDates) {\n+        String originalDate = longDateString(calendar);\n+        calendar.roll(Calendar.WEEK_OF_YEAR, 1);\n+        String rolledDate = longDateString(calendar);\n+        if (!Arrays.asList(validDates).contains(rolledDate)) {\n+            fail(String.format(\"\"\"\n+            {$$$ Failed: Rolled: \"%s\" by 1 week, where the first day of the week\n+            is: %s with a minimum week length of: %s and was expecting one of: \"%s\", but got: \"%s\"},\n+            \"\"\", originalDate, calendar.getFirstDayOfWeek(),\n+                    calendar.getMinimalDaysInFirstWeek(), Arrays.toString(validDates), rolledDate));\n+        } else {\n+            System.out.printf(\"\"\"\n+            {$$$ Passed: Rolled: \"%s\" by 1 week where the first day of the week\n+            is: %s with a minimum week length of: %s and successfully got: \"%s\"},\n+            \"\"\", originalDate, calendar.getFirstDayOfWeek(),\n+                    calendar.getMinimalDaysInFirstWeek(), rolledDate);\n+        }\n+    }\n+\n+    \/\/ This implicitly tests the Iso8601 calendar as\n+    \/\/ MinWeek = 4 and FirstDayOfWeek = Monday is included in the provider\n+    private static Stream<Arguments> rollUpCalProvider() {\n+        ArrayList<Arguments> calList = new ArrayList<Arguments>();\n+        \/\/ Week 1, Week 2 are all potential dates to roll into\n+        \/\/ Depends on first day of week \/ min days in week\n+        String[][] validDates = {\n+                {\"Wednesday, 2 January 2019\", \"Wednesday, 9 January 2019\"},\n+                {\"Thursday, 3 January 2019\" , \"Thursday, 10 January 2019\"},\n+                {\"Friday, 4 January 2019\"   , \"Friday, 11 January 2019\"},\n+                {\"Saturday, 5 January 2019\" , \"Saturday, 12 January 2019\"},\n+                {\"Sunday, 6 January 2019\"   , \"Sunday, 13 January 2019\"},\n+                {\"Monday, 7 January 2019\"   , \"Monday, 14 January 2019\"},\n+                {\"Tuesday, 1 January 2019\"  , \"Tuesday, 8 January 2019\"}\n+        };\n+        int date = 0;\n+        \/\/ Test all days at the end of the year that roll into week 1\n+        for (int dayOfMonth = 25; dayOfMonth <= 31; dayOfMonth++) {\n+            for (int weekLength = 1; weekLength <= 7; weekLength++) {\n+                \/\/ Sunday .. Monday -> Saturday\n+                for (int firstDay = SUNDAY; firstDay <= SATURDAY; firstDay++) {\n+                    calList.add(Arguments.of(buildCalendar(firstDay, weekLength,\n+                                    dayOfMonth, DECEMBER, 2019), validDates[date]));\n+                }\n+            }\n+            date++;\n+        }\n+        return calList.stream();\n+    }\n+\n+    private static Calendar buildCalendar(int firstDayOfWeek,\n+                                          int minimumWeekLength, int dayOfMonth,\n+                                          int month, int year) {\n+        return GREGORIAN_BUILDER\n+                .setWeekDefinition(firstDayOfWeek, minimumWeekLength)\n+                .setDate(year, month, dayOfMonth)\n+                .build();\n+    }\n+\n+    private static String longDateString(Calendar calendar) {\n+        return String.format(\"%s, %s %s %s\",\n+                calendar.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.LONG, Locale.ENGLISH),\n+                calendar.get(Calendar.DAY_OF_MONTH),\n+                calendar.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.ENGLISH),\n+                calendar.get(YEAR));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/RollFromLastToFirstWeek.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}