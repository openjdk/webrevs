{"files":[{"patch":"@@ -353,5 +353,0 @@\n-  \/\/ If a GC uses a stack watermark barrier, the stack processing is lazy, concurrent,\n-  \/\/ incremental and cooperative. In order for that to work well, mechanisms that stop\n-  \/\/ another thread might want to ensure its roots are in a sane state.\n-  virtual bool uses_stack_watermark_barrier() const { return false; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -2305,0 +2306,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -542,5 +542,0 @@\n-\/\/ ---------- Concurrent Stack Processing support\n-\/\/\n-public:\n-  bool uses_stack_watermark_barrier() const override { return true; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -218,4 +219,0 @@\n-bool XCollectedHeap::uses_stack_watermark_barrier() const {\n-  return true;\n-}\n-\n@@ -280,0 +277,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/x\/xCollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-  bool uses_stack_watermark_barrier() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/x\/xCollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -243,4 +244,0 @@\n-bool ZCollectedHeap::uses_stack_watermark_barrier() const {\n-  return true;\n-}\n-\n@@ -341,0 +338,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,2 +91,0 @@\n-  bool uses_stack_watermark_barrier() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -513,1 +513,0 @@\n-  bool _do_lazy_roots;\n@@ -534,3 +533,1 @@\n-    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS),\n-    _do_lazy_roots(!VMThread::vm_operation()->skip_thread_oop_barriers() &&\n-                   Universe::heap()->uses_stack_watermark_barrier()) {}\n+    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS) {}\n@@ -541,4 +538,0 @@\n-    if (_do_lazy_roots) {\n-      workers++;\n-    }\n-\n@@ -549,14 +542,0 @@\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING)) {\n-      if (_do_lazy_roots) {\n-        Tracer t(\"lazy partial thread root processing\");\n-        class LazyRootClosure : public ThreadClosure {\n-        public:\n-          void do_thread(Thread* thread) {\n-            StackWatermarkSet::start_processing(JavaThread::cast(thread), StackWatermarkKind::gc);\n-          }\n-        };\n-        LazyRootClosure cl;\n-        Threads::java_threads_do(&cl);\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-    SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -161,0 +164,10 @@\n+\n+void StackWatermarkSet::safepoint_synchronize_begin() {\n+  if (VMThread::vm_operation()->skip_thread_oop_barriers()) {\n+    return;\n+  }\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n+    StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+\n+  \/\/ We are synchronizing a safepoint, so we might want to ensure processing has at least\n+  \/\/ started, as safepoint operations sometimes assume that is the case\n+  static void safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}