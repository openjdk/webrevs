{"files":[{"patch":"@@ -46,1 +46,0 @@\n-  _node_info(arena(), _vloop.estimated_body_length(), 0, SWNodeInfo::initial), \/\/ info needed per node\n@@ -456,5 +455,2 @@\n-  \/\/ Ensure extra info is allocated.\n-  initialize_node_info();\n-\n-  \/\/ Attempt vectorization\n-  find_adjacent_refs();\n+  \/\/ Find \"seed\" pairs.\n+  find_adjacent_memop_pairs();\n@@ -494,16 +490,11 @@\n-\/\/------------------------------find_adjacent_refs---------------------------\n-\/\/ Find the adjacent memory references and create pack pairs for them.\n-\/\/ We can find adjacent memory references by comparing their relative\n-\/\/ alignment. Whether the final vectors can be aligned is determined later\n-\/\/ once all vectors are extended and combined.\n-void SuperWord::find_adjacent_refs() {\n-  \/\/ Get list of memory operations\n-  Node_List memops;\n-  for (int i = 0; i < body().length(); i++) {\n-    Node* n = body().at(i);\n-    if (n->is_Mem() && !n->is_LoadStore() && in_bb(n) &&\n-        is_java_primitive(n->as_Mem()->memory_type())) {\n-      int align = memory_alignment(n->as_Mem(), 0);\n-      if (align != bottom_align) {\n-        memops.push(n);\n-      }\n+void SuperWord::find_adjacent_memop_pairs() {\n+  ResourceMark rm;\n+  GrowableArray<const VPointer*> vpointers;\n+\n+  \/\/ Collect all valid VPointers.\n+  for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    const VPointer& p = vpointer(mem);\n+    if (p.valid() &&\n+        !mem->is_LoadStore() &&\n+        is_java_primitive(mem->memory_type())) {\n+      vpointers.append(&p);\n@@ -511,1 +502,8 @@\n-  }\n+  });\n+\n+  \/\/ Sort the VPointers. This does 2 things:\n+  \/\/  - Separate the VPointer into groups (e.g. all LoadI of the same base and invar). We only need to find adjacent memops inside\n+  \/\/    the group. This decreases the work.\n+  \/\/  - Sort by offset inside the VPointers. This decreases the work needed to determine adjacent memops inside a group.\n+  vpointers.sort(VPointer::cmp_for_sort);\n+\n@@ -514,1 +512,1 @@\n-    tty->print_cr(\"\\nfind_adjacent_refs found %d memops\", memops.size());\n+    tty->print_cr(\"\\nSuperWord::find_adjacent_memop_pairs:\");\n@@ -518,38 +516,10 @@\n-  int max_idx;\n-\n-  while (memops.size() != 0) {\n-    \/\/ Find a memory reference to align to.\n-    MemNode* mem_ref = find_align_to_ref(memops, max_idx);\n-    if (mem_ref == nullptr) break;\n-    int iv_adjustment = get_iv_adjustment(mem_ref);\n-\n-    const VPointer& align_to_ref_p = vpointer(mem_ref);\n-    \/\/ Set alignment relative to \"align_to_ref\" for all related memory operations.\n-    for (int i = memops.size() - 1; i >= 0; i--) {\n-      MemNode* s = memops.at(i)->as_Mem();\n-      if (isomorphic(s, mem_ref) &&\n-           (!_do_vector_loop || same_origin_idx(s, mem_ref))) {\n-        const VPointer& p2 = vpointer(s);\n-        if (p2.comparable(align_to_ref_p)) {\n-          int align = memory_alignment(s, iv_adjustment);\n-          set_alignment(s, align);\n-        }\n-      }\n-    }\n-\n-    \/\/ Create initial pack pairs of memory operations for which alignment was set.\n-    for (uint i = 0; i < memops.size(); i++) {\n-      Node* s1 = memops.at(i);\n-      int align = alignment(s1);\n-      if (align == top_align) continue;\n-      for (uint j = 0; j < memops.size(); j++) {\n-        Node* s2 = memops.at(j);\n-        if (alignment(s2) == top_align) continue;\n-        if (s1 != s2 && are_adjacent_refs(s1, s2)) {\n-          if (stmts_can_pack(s1, s2, align)) {\n-            if (!_do_vector_loop || same_origin_idx(s1, s2)) {\n-              _pairset.add_pair(s1, s2);\n-            }\n-          }\n-        }\n-      }\n+  \/\/ For each group, find the adjacent memops:\n+  int group_start = 0;\n+  while (group_start < vpointers.length()) {\n+    int group_end = group_start + 1;\n+    while (group_end < vpointers.length() &&\n+           VPointer::cmp_for_sort_by_group(\n+             vpointers.adr_at(group_start),\n+             vpointers.adr_at(group_end)\n+           ) == 0) {\n+      group_end++;\n@@ -557,9 +527,3 @@\n-\n-    \/\/ Remove used mem nodes.\n-    for (int i = memops.size() - 1; i >= 0; i--) {\n-      MemNode* m = memops.at(i)->as_Mem();\n-      if (alignment(m) != top_align) {\n-        memops.remove(i);\n-      }\n-    }\n-  } \/\/ while (memops.size() != 0)\n+    find_adjacent_memop_pairs_in_group(vpointers, group_start, group_end);\n+    group_start = group_end;\n+  }\n@@ -569,1 +533,1 @@\n-    tty->print_cr(\"\\nAfter Superword::find_adjacent_refs\");\n+    tty->print_cr(\"\\nAfter Superword::find_adjacent_memop_pairs\");\n@@ -575,76 +539,2 @@\n-\/\/------------------------------find_align_to_ref---------------------------\n-\/\/ Find a memory reference to align the loop induction variable to.\n-\/\/ Looks first at stores then at loads, looking for a memory reference\n-\/\/ with the largest number of references similar to it.\n-MemNode* SuperWord::find_align_to_ref(Node_List &memops, int &idx) {\n-  GrowableArray<int> cmp_ct(arena(), memops.size(), memops.size(), 0);\n-\n-  \/\/ Count number of comparable memory ops\n-  for (uint i = 0; i < memops.size(); i++) {\n-    MemNode* s1 = memops.at(i)->as_Mem();\n-    const VPointer& p1 = vpointer(s1);\n-    for (uint j = i+1; j < memops.size(); j++) {\n-      MemNode* s2 = memops.at(j)->as_Mem();\n-      if (isomorphic(s1, s2)) {\n-        const VPointer& p2 = vpointer(s2);\n-        if (p1.comparable(p2)) {\n-          (*cmp_ct.adr_at(i))++;\n-          (*cmp_ct.adr_at(j))++;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Find Store (or Load) with the greatest number of \"comparable\" references,\n-  \/\/ biggest vector size, smallest data size and smallest iv offset.\n-  int max_ct        = 0;\n-  int max_vw        = 0;\n-  int max_idx       = -1;\n-  int min_size      = max_jint;\n-  int min_iv_offset = max_jint;\n-  for (uint j = 0; j < memops.size(); j++) {\n-    MemNode* s = memops.at(j)->as_Mem();\n-    if (s->is_Store()) {\n-      int vw = vector_width_in_bytes(s);\n-      assert(vw > 1, \"sanity\");\n-      const VPointer& p = vpointer(s);\n-      if ( cmp_ct.at(j) >  max_ct ||\n-          (cmp_ct.at(j) == max_ct &&\n-            ( vw >  max_vw ||\n-             (vw == max_vw &&\n-              ( data_size(s) <  min_size ||\n-               (data_size(s) == min_size &&\n-                p.offset_in_bytes() < min_iv_offset)))))) {\n-        max_ct = cmp_ct.at(j);\n-        max_vw = vw;\n-        max_idx = j;\n-        min_size = data_size(s);\n-        min_iv_offset = p.offset_in_bytes();\n-      }\n-    }\n-  }\n-  \/\/ If no stores, look at loads\n-  if (max_ct == 0) {\n-    for (uint j = 0; j < memops.size(); j++) {\n-      MemNode* s = memops.at(j)->as_Mem();\n-      if (s->is_Load()) {\n-        int vw = vector_width_in_bytes(s);\n-        assert(vw > 1, \"sanity\");\n-        const VPointer& p = vpointer(s);\n-        if ( cmp_ct.at(j) >  max_ct ||\n-            (cmp_ct.at(j) == max_ct &&\n-              ( vw >  max_vw ||\n-               (vw == max_vw &&\n-                ( data_size(s) <  min_size ||\n-                 (data_size(s) == min_size &&\n-                  p.offset_in_bytes() < min_iv_offset)))))) {\n-          max_ct = cmp_ct.at(j);\n-          max_vw = vw;\n-          max_idx = j;\n-          min_size = data_size(s);\n-          min_iv_offset = p.offset_in_bytes();\n-        }\n-      }\n-    }\n-  }\n-\n+\/\/ Find adjacent memops for a single group, e.g. for all LoadI of the same base, invar, etc.\n+void SuperWord::find_adjacent_memop_pairs_in_group(const GrowableArray<const VPointer*> &vpointers, const int group_start, int group_end) {\n@@ -652,5 +542,6 @@\n-  if (is_trace_superword_verbose()) {\n-    tty->print_cr(\"\\nVector memops after find_align_to_ref\");\n-    for (uint i = 0; i < memops.size(); i++) {\n-      MemNode* s = memops.at(i)->as_Mem();\n-      s->dump();\n+  if (is_trace_superword_adjacent_memops()) {\n+    tty->print_cr(\" group:\");\n+    for (int i = group_start; i < group_end; i++) {\n+      const VPointer* p = vpointers.at(i);\n+      tty->print(\"  \");\n+      p->print();\n@@ -661,12 +552,2 @@\n-  idx = max_idx;\n-  if (max_ct > 0) {\n-#ifndef PRODUCT\n-    if (is_trace_superword_adjacent_memops()) {\n-      tty->print(\"SuperWord::find_align_to_ref: \");\n-      memops.at(max_idx)->as_Mem()->dump();\n-    }\n-#endif\n-    return memops.at(max_idx)->as_Mem();\n-  }\n-  return nullptr;\n-}\n+  MemNode* first = vpointers.at(group_start)->mem();\n+  int element_size = data_size(first);\n@@ -674,4 +555,4 @@\n-\/\/---------------------------get_vw_bytes_special------------------------\n-int SuperWord::get_vw_bytes_special(MemNode* s) {\n-  \/\/ Get the vector width in bytes.\n-  int vw = vector_width_in_bytes(s);\n+  \/\/ For each ref in group: find others that can be paired:\n+  for (int i = group_start; i < group_end; i++) {\n+    const VPointer* p1 = vpointers.at(i);\n+    MemNode* mem1 = p1->mem();\n@@ -679,14 +560,6 @@\n-  \/\/ Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.\n-  BasicType btype = velt_basic_type(s);\n-  if (type2aelembytes(btype) == 2) {\n-    bool should_combine_adjacent = true;\n-    for (DUIterator_Fast imax, i = s->fast_outs(imax); i < imax; i++) {\n-      Node* user = s->fast_out(i);\n-      if (!VectorNode::is_muladds2i(user)) {\n-        should_combine_adjacent = false;\n-      }\n-    }\n-    if (should_combine_adjacent) {\n-      vw = MIN2(Matcher::max_vector_size_auto_vectorization(btype)*type2aelembytes(btype), vw * 2);\n-    }\n-  }\n+    bool found = false;\n+    \/\/ For each ref in group with larger or equal offset:\n+    for (int j = i + 1; j < group_end; j++) {\n+      const VPointer* p2 = vpointers.at(j);\n+      MemNode* mem2 = p2->mem();\n+      assert(mem1 != mem2, \"look only at pair of different memops\");\n@@ -694,5 +567,6 @@\n-  \/\/ Check for special case where there is a type conversion between different data size.\n-  int vectsize = max_vector_size_in_def_use_chain(s);\n-  if (vectsize < Matcher::max_vector_size_auto_vectorization(btype)) {\n-    vw = MIN2(vectsize * type2aelembytes(btype), vw);\n-  }\n+      \/\/ Check for correct distance.\n+      assert(data_size(mem1) == element_size, \"all nodes in group must have the same element size\");\n+      assert(data_size(mem2) == element_size, \"all nodes in group must have the same element size\");\n+      assert(p1->offset_in_bytes() <= p2->offset_in_bytes(), \"must be sorted by offset\");\n+      if (p1->offset_in_bytes() + element_size > p2->offset_in_bytes()) { continue; }\n+      if (p1->offset_in_bytes() + element_size < p2->offset_in_bytes()) { break; }\n@@ -700,2 +574,2 @@\n-  return vw;\n-}\n+      \/\/ Only allow nodes from same origin idx to be packed (see CompileCommand Option Vectorize)\n+      if (_do_vector_loop && !same_origin_idx(mem1, mem2)) { continue; }\n@@ -703,21 +577,1 @@\n-\/\/---------------------------get_iv_adjustment---------------------------\n-\/\/ Calculate loop's iv adjustment for this memory ops.\n-int SuperWord::get_iv_adjustment(MemNode* mem_ref) {\n-  const VPointer& align_to_ref_p = vpointer(mem_ref);\n-  int offset = align_to_ref_p.offset_in_bytes();\n-  int scale  = align_to_ref_p.scale_in_bytes();\n-  int elt_size = align_to_ref_p.memory_size();\n-  int vw       = get_vw_bytes_special(mem_ref);\n-  assert(vw > 1, \"sanity\");\n-  int iv_adjustment;\n-  if (scale != 0) {\n-    int stride_sign = (scale * iv_stride()) > 0 ? 1 : -1;\n-    \/\/ At least one iteration is executed in pre-loop by default. As result\n-    \/\/ several iterations are needed to align memory operations in main-loop even\n-    \/\/ if offset is 0.\n-    int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));\n-    iv_adjustment = iv_adjustment_in_bytes\/elt_size;\n-  } else {\n-    \/\/ This memory op is not dependent on iv (scale == 0)\n-    iv_adjustment = 0;\n-  }\n+      if (!can_pack_into_pair(mem1, mem2)) { continue; }\n@@ -726,5 +580,11 @@\n-  if (is_trace_superword_alignment()) {\n-    tty->print(\"SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: \",\n-      mem_ref->_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);\n-    mem_ref->dump();\n-  }\n+      if (is_trace_superword_adjacent_memops()) {\n+        if (found) {\n+          tty->print_cr(\" WARNING: multiple pairs with the same node. Ignored pairing:\");\n+        } else {\n+          tty->print_cr(\" pair:\");\n+        }\n+        tty->print(\"  \");\n+        p1->print();\n+        tty->print(\"  \");\n+        p2->print();\n+      }\n@@ -732,1 +592,6 @@\n-  return iv_adjustment;\n+\n+      if (!found) {\n+        _pairset.add_pair(mem1, mem2);\n+      }\n+    }\n+  }\n@@ -812,4 +677,2 @@\n-\/\/------------------------------stmts_can_pack---------------------------\n-\/\/ Can s1 and s2 be in a pack with s1 immediately preceding s2 and\n-\/\/ s1 aligned at \"align\"\n-bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {\n+\/\/ Check if two nodes can be packed into a pair.\n+bool SuperWord::can_pack_into_pair(Node* s1, Node* s2) {\n@@ -834,7 +697,1 @@\n-          int s1_align = alignment(s1);\n-          int s2_align = alignment(s2);\n-          if (s1_align == top_align || s1_align == align) {\n-            if (s2_align == top_align || s2_align == align + data_size(s1)) {\n-              return true;\n-            }\n-          }\n+          return true;\n@@ -1016,10 +873,0 @@\n-\/\/------------------------------set_alignment---------------------------\n-void SuperWord::set_alignment(Node* s1, Node* s2, int align) {\n-  set_alignment(s1, align);\n-  if (align == top_align || align == bottom_align) {\n-    set_alignment(s2, align);\n-  } else {\n-    set_alignment(s2, align + data_size(s1));\n-  }\n-}\n-\n@@ -1061,16 +908,0 @@\n-\/\/------------------------------adjust_alignment_for_type_conversion---------------------------------\n-\/\/ Adjust the target alignment if conversion between different data size exists in def-use nodes.\n-int SuperWord::adjust_alignment_for_type_conversion(Node* s, Node* t, int align) {\n-  \/\/ Do not use superword for non-primitives\n-  BasicType bt1 = velt_basic_type(s);\n-  BasicType bt2 = velt_basic_type(t);\n-  if (!is_java_primitive(bt1) || !is_java_primitive(bt2)) {\n-    return align;\n-  }\n-  if (longer_type_for_conversion(s) != T_ILLEGAL ||\n-      longer_type_for_conversion(t) != T_ILLEGAL) {\n-    align = align \/ data_size(s) * data_size(t);\n-  }\n-  return align;\n-}\n-\n@@ -1080,1 +911,0 @@\n-  assert(alignment(s1) + data_size(s1) == alignment(s2), \"just checking\");\n@@ -1084,6 +914,0 @@\n-#ifndef PRODUCT\n-  if (is_trace_superword_alignment()) {\n-    tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_def: s1 %d, align %d\",\n-                  s1->_idx, alignment(s1));\n-  }\n-#endif\n@@ -1094,1 +918,0 @@\n-    int align = alignment(s1);\n@@ -1101,2 +924,1 @@\n-    align = adjust_alignment_for_type_conversion(s1, t1, align);\n-    if (stmts_can_pack(t1, t2, align)) {\n+    if (can_pack_into_pair(t1, t2)) {\n@@ -1105,7 +927,0 @@\n-#ifndef PRODUCT\n-        if (is_trace_superword_alignment()) {\n-          tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_def: set_alignment(%d, %d, %d)\",\n-                        t1->_idx, t2->_idx, align);\n-        }\n-#endif\n-        set_alignment(t1, t2, align);\n@@ -1125,1 +940,0 @@\n-  assert(alignment(s1) + data_size(s1) == alignment(s2), \"just checking\");\n@@ -1129,7 +943,0 @@\n-  int align = alignment(s1);\n-#ifndef PRODUCT\n-  if (is_trace_superword_alignment()) {\n-    tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_use: s1 %d, align %d\",\n-                  s1->_idx, align);\n-  }\n-#endif\n@@ -1153,3 +960,1 @@\n-      int adjusted_align = alignment(s1);\n-      adjusted_align = adjust_alignment_for_type_conversion(s1, t1, adjusted_align);\n-      if (stmts_can_pack(t1, t2, adjusted_align)) {\n+      if (can_pack_into_pair(t1, t2)) {\n@@ -1161,1 +966,0 @@\n-          align = adjusted_align;\n@@ -1168,7 +972,0 @@\n-#ifndef PRODUCT\n-    if (is_trace_superword_alignment()) {\n-      tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_use: set_alignment(%d, %d, %d)\",\n-                    u1->_idx, u2->_idx, align);\n-    }\n-#endif\n-    set_alignment(u1, u2, align);\n@@ -1817,0 +1614,5 @@\n+\/\/ Java API for Long.bitCount\/numberOfLeadingZeros\/numberOfTrailingZeros\n+\/\/ returns int type, but Vector API for them returns long type. To unify\n+\/\/ the implementation in backend, superword splits the vector implementation\n+\/\/ for Java API into an execution node with long type plus another node\n+\/\/ converting long to int.\n@@ -2951,1 +2753,11 @@\n-  if (is_marked_reduction(use)) return true;\n+\n+  \/\/ Reduction: first input is internal connection.\n+  if (is_marked_reduction(use) && u_idx == 1) {\n+#ifdef ASSERT\n+      for (uint i = 1; i < u_pk->size(); i++) {\n+        assert(u_pk->at(i-1) == u_pk->at(i)->in(1), \"internal connection\");\n+      }\n+#endif\n+    return true;\n+  }\n+\n@@ -2978,0 +2790,4 @@\n+  if (!is_velt_basic_type_compatible_use_def(use, u_idx)) {\n+    return false;\n+  }\n+\n@@ -2979,2 +2795,1 @@\n-    \/\/ MulAddS2I takes shorts and produces ints - hence the special checks\n-    \/\/ on alignment and size.\n+    \/\/ MulAddS2I takes shorts and produces ints.\n@@ -2984,7 +2799,0 @@\n-    for (uint i = 0; i < MIN2(d_pk->size(), u_pk->size()); i++) {\n-      Node* ui = u_pk->at(i);\n-      Node* di = d_pk->at(i);\n-      if (alignment(ui) != alignment(di) * 2) {\n-        return false;\n-      }\n-    }\n@@ -2994,1 +2802,1 @@\n-  if (u_pk->size() != d_pk->size())\n+  if (u_pk->size() != d_pk->size()) {\n@@ -2996,16 +2804,0 @@\n-\n-  if (longer_type_for_conversion(use) != T_ILLEGAL) {\n-    \/\/ These opcodes take a type of a kind of size and produce a type of\n-    \/\/ another size - hence the special checks on alignment and size.\n-    for (uint i = 0; i < u_pk->size(); i++) {\n-      Node* ui = u_pk->at(i);\n-      Node* di = d_pk->at(i);\n-      if (ui->in(u_idx) != di) {\n-        return false;\n-      }\n-      if (alignment(ui) \/ type2aelembytes(velt_basic_type(ui)) !=\n-          alignment(di) \/ type2aelembytes(velt_basic_type(di))) {\n-        return false;\n-      }\n-    }\n-    return true;\n@@ -3017,1 +2809,1 @@\n-    if (ui->in(u_idx) != di || alignment(ui) != alignment(di))\n+    if (ui->in(u_idx) != di) {\n@@ -3019,0 +2811,1 @@\n+    }\n@@ -3023,0 +2816,30 @@\n+bool SuperWord::is_velt_basic_type_compatible_use_def(Node* use, int idx) const {\n+  Node* def = use->in(idx);\n+  assert(in_bb(def) && in_bb(use), \"both use and def are in loop\");\n+\n+  \/\/ Conversions are trivially compatible.\n+  if (VectorNode::is_convert_opcode(use->Opcode())) {\n+    return true;\n+  }\n+\n+  BasicType use_bt = velt_basic_type(use);\n+  BasicType def_bt = velt_basic_type(def);\n+\n+  assert(is_java_primitive(use_bt), \"sanity %s\", type2name(use_bt));\n+  assert(is_java_primitive(def_bt), \"sanity %s\", type2name(def_bt));\n+\n+  \/\/ Nodes like Long.bitCount: expect long input, and int output.\n+  if (requires_long_to_int_conversion(use->Opcode())) {\n+    return type2aelembytes(def_bt) == 8 &&\n+           type2aelembytes(use_bt) == 4;\n+  }\n+\n+  \/\/ MulAddS2I: expect short input, and int output.\n+  if (VectorNode::is_muladds2i(use)) {\n+    return type2aelembytes(def_bt) == 2 &&\n+           type2aelembytes(use_bt) == 4;\n+  }\n+\n+  return type2aelembytes(use_bt) == type2aelembytes(def_bt);\n+}\n+\n@@ -3153,6 +2976,0 @@\n-\/\/ Initialize per node info\n-void SuperWord::initialize_node_info() {\n-  Node* last = body().at(body().length() - 1);\n-  grow_node_info(bb_idx(last));\n-}\n-\n@@ -3180,28 +2997,0 @@\n-int SuperWord::max_vector_size_in_def_use_chain(Node* n) {\n-  BasicType bt = velt_basic_type(n);\n-  BasicType vt = bt;\n-\n-  \/\/ find the longest type among def nodes.\n-  uint start, end;\n-  VectorNode::vector_operands(n, &start, &end);\n-  for (uint i = start; i < end; ++i) {\n-    Node* input = n->in(i);\n-    if (!in_bb(input)) continue;\n-    BasicType newt = longer_type_for_conversion(input);\n-    vt = (newt == T_ILLEGAL) ? vt : newt;\n-  }\n-\n-  \/\/ find the longest type among use nodes.\n-  for (uint i = 0; i < n->outcnt(); ++i) {\n-    Node* output = n->raw_out(i);\n-    if (!in_bb(output)) continue;\n-    BasicType newt = longer_type_for_conversion(output);\n-    vt = (newt == T_ILLEGAL) ? vt : newt;\n-  }\n-\n-  int max = Matcher::max_vector_size_auto_vectorization(vt);\n-  \/\/ If now there is no vectors for the longest type, the nodes with the longest\n-  \/\/ type in the def-use chain are not packed in SuperWord::stmts_can_pack.\n-  return max < 2 ? Matcher::max_vector_size_auto_vectorization(bt) : max;\n-}\n-\n@@ -3311,30 +3100,0 @@\n-\/\/------------------------------memory_alignment---------------------------\n-\/\/ Alignment within a vector memory reference\n-int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {\n-#ifndef PRODUCT\n-  if (is_trace_superword_alignment()) {\n-    tty->print(\"SuperWord::memory_alignment within a vector memory reference for %d:  \", s->_idx); s->dump();\n-  }\n-#endif\n-  const VPointer& p = vpointer(s);\n-  if (!p.valid()) {\n-    NOT_PRODUCT(if(is_trace_superword_alignment()) tty->print_cr(\"SuperWord::memory_alignment: VPointer p invalid, return bottom_align\");)\n-    return bottom_align;\n-  }\n-  int vw = get_vw_bytes_special(s);\n-  if (vw < 2) {\n-    NOT_PRODUCT(if(is_trace_superword_alignment()) tty->print_cr(\"SuperWord::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n-    return bottom_align; \/\/ No vectors for this type\n-  }\n-  int offset  = p.offset_in_bytes();\n-  offset     += iv_adjust*p.memory_size();\n-  int off_rem = offset % vw;\n-  int off_mod = off_rem >= 0 ? off_rem : off_rem + vw;\n-#ifndef PRODUCT\n-  if (is_trace_superword_alignment()) {\n-    tty->print_cr(\"SuperWord::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n-  }\n-#endif\n-  return off_mod;\n-}\n-\n@@ -3797,4 +3556,0 @@\n-\/\/ ========================= SWNodeInfo =====================\n-\n-const SWNodeInfo SWNodeInfo::initial;\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":141,"deletions":386,"binary":false,"changes":527,"status":"modified"},{"patch":"@@ -387,12 +387,0 @@\n-\/\/ ========================= SuperWord =====================\n-\n-\/\/ -----------------------------SWNodeInfo---------------------------------\n-\/\/ Per node info needed by SuperWord\n-class SWNodeInfo {\n- public:\n-  int         _alignment; \/\/ memory alignment for a node\n-\n-  SWNodeInfo() : _alignment(-1) {}\n-  static const SWNodeInfo initial;\n-};\n-\n@@ -410,3 +398,0 @@\n-  enum consts { top_align = -1, bottom_align = -666 };\n-\n-  GrowableArray<SWNodeInfo> _node_info;  \/\/ Info needed per node\n@@ -464,0 +449,5 @@\n+  template<typename Callback>\n+  void for_each_mem(Callback callback) const {\n+    return _vloop_analyzer.body().for_each_mem(callback);\n+  }\n+\n@@ -509,5 +499,0 @@\n-  bool is_trace_superword_alignment() const {\n-    \/\/ Too verbose for TraceSuperWord\n-    return _vloop.vtrace().is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n-  }\n-\n@@ -534,5 +519,0 @@\n-  bool is_trace_superword_verbose() const {\n-    \/\/ Too verbose for TraceSuperWord\n-    return _vloop.vtrace().is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n-  }\n-\n@@ -542,1 +522,0 @@\n-           _vloop.vtrace().is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n@@ -552,1 +531,1 @@\n-           is_trace_superword_verbose();\n+           _vloop.vtrace().is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n@@ -569,5 +548,0 @@\n-  int get_vw_bytes_special(MemNode* s);\n-\n-  \/\/ Ensure node_info contains element \"i\"\n-  void grow_node_info(int i) { if (i >= _node_info.length()) _node_info.at_put_grow(i, SWNodeInfo::initial); }\n-\n@@ -577,6 +551,0 @@\n-  \/\/ memory alignment for a node\n-  int alignment(Node* n) const               { return _node_info.adr_at(bb_idx(n))->_alignment; }\n-  void set_alignment(Node* n, int a)         { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)->_alignment = a; }\n-\n-  \/\/ is pack good for converting into one vector node replacing bunches of Cmp, Bool, CMov nodes.\n-  static bool requires_long_to_int_conversion(int opc);\n@@ -585,0 +553,1 @@\n+\n@@ -591,9 +560,7 @@\n-  \/\/ Find the adjacent memory references and create pack pairs for them.\n-  void find_adjacent_refs();\n-  \/\/ Find a memory reference to align the loop induction variable to.\n-  MemNode* find_align_to_ref(Node_List &memops, int &idx);\n-  \/\/ Calculate loop's iv adjustment for this memory ops.\n-  int get_iv_adjustment(MemNode* mem);\n-\n-  \/\/ Can s1 and s2 be in a pack with s1 immediately preceding s2 and  s1 aligned at \"align\"\n-  bool stmts_can_pack(Node* s1, Node* s2, int align);\n+\n+  \/\/ Find the \"seed\" pairs. These are pairs that we strongly suspect would lead to vectorization.\n+  void find_adjacent_memop_pairs();\n+  void find_adjacent_memop_pairs_in_group(const GrowableArray<const VPointer*> &vpointers, const int group_start, int group_end);\n+\n+  \/\/ Various methods to check if we can pack two nodes.\n+  bool can_pack_into_pair(Node* s1, Node* s2);\n@@ -609,2 +576,0 @@\n-  void set_alignment(Node* s1, Node* s2, int align);\n-  int adjust_alignment_for_type_conversion(Node* s, Node* t, int align);\n@@ -664,2 +629,0 @@\n-  \/\/ Initialize per node info\n-  void initialize_node_info();\n@@ -668,2 +631,4 @@\n-  \/\/ Find the longest type in def-use chain for packed nodes, and then compute the max vector size.\n-  int max_vector_size_in_def_use_chain(Node* n);\n+\n+  static bool requires_long_to_int_conversion(int opc);\n+\n+  bool is_velt_basic_type_compatible_use_def(Node* use, int idx) const;\n@@ -672,2 +637,1 @@\n-  \/\/ Alignment within a vector memory reference\n-  int memory_alignment(MemNode* s, int iv_adjust);\n+\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":19,"deletions":55,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-  flags(SW_ALIGNMENT,         \"Trace SuperWord alignment analysis\") \\\n-  flags(SW_ADJACENT_MEMOPS,   \"Trace SuperWord::find_adjacent_refs\") \\\n+  flags(SW_ADJACENT_MEMOPS,   \"Trace SuperWord::find_adjacent_memop_pairs\") \\\n@@ -118,1 +117,0 @@\n-        _tags.at_put(SW_ALIGNMENT, set_bit);\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+  _body.for_each_mem([&] (MemNode* const mem, int bb_idx) {\n@@ -413,1 +413,1 @@\n-VPointer::VPointer(const MemNode* mem, const VLoop& vloop,\n+VPointer::VPointer(MemNode* const mem, const VLoop& vloop,\n@@ -810,0 +810,34 @@\n+\/\/ To be in the same group, two VPointers must be the same,\n+\/\/ except for the offset.\n+int VPointer::cmp_for_sort_by_group(const VPointer** p1, const VPointer** p2) {\n+  const VPointer* a = *p1;\n+  const VPointer* b = *p2;\n+\n+  int cmp_base = a->base()->_idx - b->base()->_idx;\n+  if (cmp_base != 0) { return cmp_base; }\n+\n+  int cmp_opcode = a->mem()->Opcode() - b->mem()->Opcode();\n+  if (cmp_opcode != 0) { return cmp_opcode; }\n+\n+  int cmp_scale = a->scale_in_bytes() - b->scale_in_bytes();\n+  if (cmp_scale != 0) { return cmp_scale; }\n+\n+  int cmp_invar = (a->invar() == nullptr ? 0 : a->invar()->_idx) -\n+                  (b->invar() == nullptr ? 0 : b->invar()->_idx);\n+  return cmp_invar;\n+}\n+\n+\/\/ We compare by group, then by offset, and finally by node idx.\n+int VPointer::cmp_for_sort(const VPointer** p1, const VPointer** p2) {\n+  int cmp_group = cmp_for_sort_by_group(p1, p2);\n+  if (cmp_group != 0) { return cmp_group; }\n+\n+  const VPointer* a = *p1;\n+  const VPointer* b = *p2;\n+\n+  int cmp_offset = a->offset_in_bytes() - b->offset_in_bytes();\n+  if (cmp_offset != 0) { return cmp_offset; }\n+\n+  return a->mem()->_idx - b->mem()->_idx;\n+}\n+\n@@ -814,0 +848,6 @@\n+\n+  if (!valid()) {\n+    tty->print_cr(\"invalid]\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-  const MemNode*  _mem;      \/\/ My memory reference node\n+  MemNode* const  _mem;      \/\/ My memory reference node\n@@ -714,1 +714,1 @@\n-  VPointer(const MemNode* mem, const VLoop& vloop) :\n+  VPointer(MemNode* const mem, const VLoop& vloop) :\n@@ -716,1 +716,1 @@\n-  VPointer(const MemNode* mem, const VLoop& vloop, Node_Stack* nstack) :\n+  VPointer(MemNode* const mem, const VLoop& vloop, Node_Stack* nstack) :\n@@ -719,1 +719,1 @@\n-  VPointer(const MemNode* mem, const VLoop& vloop,\n+  VPointer(MemNode* const mem, const VLoop& vloop,\n@@ -732,1 +732,1 @@\n-  const MemNode* mem()     const { return _mem; }\n+  MemNode* mem()           const { return _mem; }\n@@ -784,0 +784,5 @@\n+  \/\/ We need to be able to sort the VPointer to efficiently group the\n+  \/\/ memops into groups, and to find adjacent memops.\n+  static int cmp_for_sort_by_group(const VPointer** p1, const VPointer** p2);\n+  static int cmp_for_sort(const VPointer** p1, const VPointer** p2);\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * @test\n+ * @bug 8325155\n+ * @summary Test some cases that vectorize after the removal of the alignment boundaries code.\n+ *          Now, we instead check if use-def connections have compatible type size.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestCompatibleUseDefTypeSize\n+ *\/\n+\n+public class TestCompatibleUseDefTypeSize {\n+    static int RANGE = 1024*8;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB;\n+    byte[] bB;\n+    short[] aS;\n+    short[] bS;\n+    char[] aC;\n+    char[] bC;\n+    int[] aI;\n+    int[] bI;\n+    long[] aL;\n+    long[] bL;\n+    float[] aF;\n+    float[] bF;\n+    double[] aD;\n+    double[] bD;\n+\n+    \/\/ List of tests\n+    Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String,Object[]> golds = new HashMap<String,Object[]>();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    public TestCompatibleUseDefTypeSize() {\n+        \/\/ Generate input once\n+        aB = generateB();\n+        bB = generateB();\n+        aS = generateS();\n+        bS = generateS();\n+        aC = generateC();\n+        bC = generateC();\n+        aI = generateI();\n+        bI = generateI();\n+        aL = generateL();\n+        bL = generateL();\n+        aF = generateF();\n+        bF = generateF();\n+        aD = generateD();\n+        bD = generateD();\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"test0\",       () -> { return test0(aB.clone(), bC.clone()); });\n+        tests.put(\"test1\",       () -> { return test1(aB.clone(), bC.clone()); });\n+        tests.put(\"test2\",       () -> { return test2(aB.clone(), bC.clone()); });\n+        tests.put(\"test3\",       () -> { return test3(aI.clone(), bI.clone()); });\n+        tests.put(\"test4\",       () -> { return test4(aI.clone(), bI.clone()); });\n+        tests.put(\"test5\",       () -> { return test5(aI.clone(), bF.clone()); });\n+        tests.put(\"test6\",       () -> { return test6(aI.clone(), bF.clone()); });\n+        tests.put(\"test7\",       () -> { return test7(aI.clone(), bF.clone()); });\n+        tests.put(\"test8\",       () -> { return test8(aL.clone(), bD.clone()); });\n+        tests.put(\"test9\",       () -> { return test9(aL.clone(), bD.clone()); });\n+        tests.put(\"test10\",      () -> { return test10(aL.clone(), bD.clone()); });\n+        tests.put(\"test11\",      () -> { return test11(aC.clone()); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test0\",\n+                 \"test1\",\n+                 \"test2\",\n+                 \"test3\",\n+                 \"test4\",\n+                 \"test5\",\n+                 \"test6\",\n+                 \"test7\",\n+                 \"test8\",\n+                 \"test9\",\n+                 \"test10\",\n+                 \"test11\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static char[] generateC() {\n+        char[] a = new char[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (char)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static float[] generateF() {\n+        float[] a = new float[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.intBitsToFloat(RANDOM.nextInt());\n+        }\n+        return a;\n+    }\n+\n+    static double[] generateD() {\n+        double[] a = new double[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.longBitsToDouble(RANDOM.nextLong());\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == char.class) {\n+                verifyC(name, i, (char[])g, (char[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else if (c == float.class) {\n+                verifyF(name, i, (float[])g, (float[])r);\n+            } else if (c == double.class) {\n+                verifyD(name, i, (double[])g, (double[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyC(String name, int i, char[] g, char[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyF(String name, int i, float[] g, float[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (Float.floatToIntBits(g[j]) != Float.floatToIntBits(r[j])) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyD(String name, int i, double[] g, double[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (Double.doubleToLongBits(g[j]) != Double.doubleToLongBits(r[j])) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ \"inflate\"  method: 1 byte -> 2 byte.\n+    \/\/ Java scalar code has no explicit conversion.\n+    \/\/ Vector code would need a conversion. We may add this in the future.\n+    static Object[] test0(byte[] src, char[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (char)(src[i] & 0xff);\n+        }\n+        return new Object[]{ src, dst };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ \"inflate\"  method: 1 byte -> 2 byte.\n+    \/\/ Java scalar code has no explicit conversion.\n+    \/\/ Vector code would need a conversion. We may add this in the future.\n+    static Object[] test1(byte[] src, char[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = (char)(src[i]);\n+        }\n+        return new Object[]{ src, dst };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ \"deflate\"  method: 2 byte -> 1 byte.\n+    \/\/ Java scalar code has no explicit conversion.\n+    \/\/ Vector code would need a conversion. We may add this in the future.\n+    static Object[] test2(byte[] src, char[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            src[i] = (byte)(dst[i]);\n+        }\n+        return new Object[]{ src, dst };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Used to not vectorize because of \"alignment boundaries\".\n+    \/\/ Assume 64 byte vector width:\n+    \/\/ a[i+0:i+15] and a[i+1:i+16], each are 4 * 16 = 64 byte.\n+    \/\/ The alignment boundary is every 64 byte, so one of the two vectors gets cut up.\n+    static Object[] test3(int[] a, int[] b) {\n+        for (int i = 0; i < a.length-1; i++) {\n+            a[i] = (int)(b[i] + a[i+1]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ same as test3, but hand-unrolled\n+    static Object[] test4(int[] a, int[] b) {\n+        for (int i = 0; i < a.length-2; i+=2) {\n+            a[i+0] = (int)(b[i+0] + a[i+1]);\n+            a[i+1] = (int)(b[i+1] + a[i+2]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In theory, one would expect this to be a simple 4byte -> 4byte conversion.\n+    \/\/ But there is a CmpF and CMove here because we check for isNaN. Plus a MoveF2I.\n+    \/\/\n+    \/\/ Would be nice to vectorize: Missing support for CmpF, CMove and MoveF2I.\n+    static Object[] test5(int[] a, float[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.floatToIntBits(b[i]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Missing support for MoveF2I\n+    static Object[] test6(int[] a, float[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.floatToRawIntBits(b[i]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Missing support for MoveI2F\n+    static Object[] test7(int[] a, float[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = Float.intBitsToFloat(a[i]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Missing support for Needs CmpD, CMove and MoveD2L\n+    static Object[] test8(long[] a, double[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.doubleToLongBits(b[i]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Missing support for MoveD2L\n+    static Object[] test9(long[] a, double[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.doubleToRawLongBits(b[i]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Missing support for MoveL2D\n+    static Object[] test10(long[] a, double[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = Double.longBitsToDouble(a[i]);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    \/\/ MaxI reduction is with char type, but the MaxI char vector is not implemented.\n+    static Object[] test11(char[] a) {\n+        char m = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            m = (char)Math.max(m, a[i]);\n+            a[i] = 0;\n+        }\n+        return new Object[]{ a, new char[] { m } };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -393,1 +393,1 @@\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n@@ -395,1 +395,1 @@\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n@@ -408,2 +408,0 @@\n-    \/\/ The 4-pack does not vectorize. This is a technical limitation that\n-    \/\/ we can hopefully soon remove. Load and store offsets are different.\n@@ -431,1 +429,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"= 0\",\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n@@ -433,1 +431,1 @@\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n@@ -447,2 +445,0 @@\n-    \/\/ The 2-pack does not vectorize. This is a technical limitation that\n-    \/\/ we can hopefully soon remove. Load and store offsets are different.\n@@ -471,1 +467,1 @@\n-                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n@@ -473,1 +469,1 @@\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n@@ -486,2 +482,0 @@\n-    \/\/ The 4-pack does not vectorize. This is a technical limitation that\n-    \/\/ we can hopefully soon remove. Load and store offsets are different.\n@@ -509,1 +503,1 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"= 0\",\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n@@ -511,1 +505,1 @@\n-                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n@@ -525,2 +519,0 @@\n-    \/\/ The 2-pack does not vectorize. This is a technical limitation that\n-    \/\/ we can hopefully soon remove. Load and store offsets are different.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"}]}