{"files":[{"patch":"@@ -2149,4 +2149,5 @@\n-        \/** In a basic for() loop body, this bitmap contains variables that are reassigned\n-         *  in the body of the loop (where \"reassigned\" means \"assigned when not DU\").\n-         *  Basic for() loop iteration variables that are NOT reassigned have their\n-         *  FOR_LOOP_BODY_MAY_CAPTURE flags set.\n+        \/** In a basic for() loop body, during the first (FlowKind.NORMAL) run, this contains\n+         *  any loop variables that have NOT yet been reassigned (where \"reassigned\" means\n+         *  \"assigned when not DU\"). Note this can also contain variables from outer containing\n+         *  for() loop bodies. After a for() loop body has been scanned, the loop variables\n+         *  that were never reassigned are awarded the FOR_LOOP_BODY_MAY_CAPTURE flag.\n@@ -2154,1 +2155,1 @@\n-        Bits reassignedInForLoopBody;\n+        final Bits notReassigned;\n@@ -2192,0 +2193,1 @@\n+            notReassigned = new Bits();\n@@ -2242,3 +2244,3 @@\n-                \/\/ In basic for() loop bodies, we keep track of which variables get reassigned\n-                if (reassignedInForLoopBody != null && !uninits.isMember(sym.adr))\n-                    reassignedInForLoopBody.incl(sym.adr);\n+                \/\/ In basic for() loop bodies, we notice when loop variables get reassigned\n+                if (notReassigned.isMember(sym.adr) && !uninits.isMember(sym.adr))\n+                    notReassigned.excl(sym.adr);\n@@ -2729,3 +2731,5 @@\n-                final Bits reassignedInForLoopBodyPrev = reassignedInForLoopBody;\n-                reassignedInForLoopBody = new Bits();\n-                try {\n+                if (flowKind.isFinal()) {\n+                    scan(tree.body);\n+                } else {\n+                    \/\/ on the first pass only, check for reassignments of loop variables\n+                    notReassigned.inclRange(forLoopVarMin, forLoopVarMax);\n@@ -2734,1 +2738,1 @@\n-                        if (!reassignedInForLoopBody.isMember(adr))\n+                        if (notReassigned.isMember(adr))\n@@ -2737,2 +2741,1 @@\n-                } finally {\n-                    reassignedInForLoopBody = reassignedInForLoopBodyPrev;\n+                    notReassigned.excludeFrom(forLoopVarMin);\n@@ -3311,2 +3314,2 @@\n-        \/\/ Variables that may be captured by classes and lambdas even if not final or effectively final.\n-        final HashSet<VarSymbol> capturable = new HashSet<>();\n+        \/\/ Variables that may be captured even if not final or effectively final\n+        final Bits capturable = new Bits();\n@@ -3328,1 +3331,1 @@\n-                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0 && (!capturable.contains(sym))) {\n+                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0 && (!capturable.isMember(sym.adr))) {\n@@ -3484,2 +3487,2 @@\n-            \/\/ Collect the for() loop iteration variables with the FOR_LOOP_BODY_MAY_CAPTURE flag\n-            HashSet<VarSymbol> capturableForLoopVars = null;\n+            \/\/ Identify loop variables with FOR_LOOP_BODY_MAY_CAPTURE and then recurse on body\n+            final Bits newCapturable = new Bits();\n@@ -3487,1 +3490,1 @@\n-                capturableForLoopVars = tree.init.stream()\n+                tree.init.stream()\n@@ -3492,13 +3495,2 @@\n-                  .collect(Collectors.toCollection(HashSet::new));\n-                if (capturableForLoopVars.isEmpty())\n-                    capturableForLoopVars = null;\n-            }\n-\n-            \/\/ Merge with previous and then scan the body\n-            if (capturableForLoopVars != null)\n-                capturable.addAll(capturableForLoopVars);\n-            try {\n-                scan(tree.body);\n-            } finally {\n-                if (capturableForLoopVars != null)\n-                    capturable.removeAll(capturableForLoopVars);\n+                  .mapToInt(sym -> sym.adr)\n+                  .forEach(newCapturable::incl);\n@@ -3506,0 +3498,3 @@\n+            capturable.orSet(newCapturable);\n+            scan(tree.body);\n+            capturable.diffSet(newCapturable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -62,0 +62,21 @@\n+    \/\/ An extra level of nesting doesn't make it OK\n+    {\n+        for (int i = 0; true; ) {\n+            for (int j = 0; j < 3; j++) {\n+                i = 42;\n+                Runnable r = () -> System.out.println(i);               \/\/ error: ...must be final or effectively final\n+            }\n+            break;\n+        }\n+    }\n+\n+    \/\/ An extra level of nesting doesn't make it OK\n+    {\n+        for (int i = 0; true; ) {\n+            for (int j = 0; j < ++i; j++) {\n+                Runnable r = () -> System.out.println(i);               \/\/ error: ...must be final or effectively final\n+            }\n+            break;\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalInvalidTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7,1 +7,3 @@\n-6 errors\n+ForLoopVarsEffectivelyFinalInvalidTest.java:67:55: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:77:55: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+8 errors\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalInvalidTest.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}