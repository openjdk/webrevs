{"files":[{"patch":"@@ -200,0 +200,7 @@\n+    \/**\n+     * Flag marking a basic for() loop iteration variable (i.e., a variable declared\n+     * in the init section of the loop) that is allowed to be captured by a nested\n+     * class or lambda even when the variable is neither final nor effectively final.\n+     *\/\n+    public static final long FOR_LOOP_BODY_MAY_CAPTURE = 1L<<32;\n+\n@@ -521,0 +528,1 @@\n+        FOR_LOOP_BODY_MAY_CAPTURE(Flags.FOR_LOOP_BODY_MAY_CAPTURE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2149,0 +2149,7 @@\n+        \/** In a basic for() loop body, this bitmap contains variables that are reassigned\n+         *  in the body of the loop (where \"reassigned\" means \"assigned when not DU\").\n+         *  Basic for() loop iteration variables that are NOT reassigned have their\n+         *  FOR_LOOP_BODY_MAY_CAPTURE flags set.\n+         *\/\n+        Bits reassignedInForLoopBody;\n+\n@@ -2234,0 +2241,5 @@\n+\n+                \/\/ In basic for() loop bodies, we keep track of which variables get reassigned\n+                if (reassignedInForLoopBody != null && !uninits.isMember(sym.adr))\n+                    reassignedInForLoopBody.incl(sym.adr);\n+\n@@ -2693,0 +2705,1 @@\n+            int forLoopVarMin = nextadr;\n@@ -2694,0 +2707,1 @@\n+            int forLoopVarMax = nextadr;\n@@ -2715,1 +2729,11 @@\n-                scan(tree.body);\n+                final Bits reassignedInForLoopBodyPrev = reassignedInForLoopBody;\n+                reassignedInForLoopBody = new Bits();\n+                try {\n+                    scan(tree.body);\n+                    for (int adr = forLoopVarMin; adr < forLoopVarMax; adr++) {\n+                        if (!reassignedInForLoopBody.isMember(adr))\n+                            vardecls[adr].sym.flags_field |= FOR_LOOP_BODY_MAY_CAPTURE;\n+                    }\n+                } finally {\n+                    reassignedInForLoopBody = reassignedInForLoopBodyPrev;\n+                }\n@@ -3287,0 +3311,3 @@\n+        \/\/ Variables that may be captured by classes and lambdas even if not final or effectively final.\n+        final HashSet<VarSymbol> capturable = new HashSet<>();\n+\n@@ -3301,1 +3328,1 @@\n-                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0) {\n+                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0 && (!capturable.contains(sym))) {\n@@ -3449,0 +3476,32 @@\n+        @Override\n+        public void visitForLoop(JCForLoop tree) {\n+\n+            \/\/ Recurse on initialization, condition, and step\n+            scan(tree.init);\n+            scan(tree.cond);\n+            scan(tree.step);\n+\n+            \/\/ Collect the for() loop iteration variables with the FOR_LOOP_BODY_MAY_CAPTURE flag\n+            HashSet<VarSymbol> capturableForLoopVars = null;\n+            if (tree.init != null) {\n+                capturableForLoopVars = tree.init.stream()\n+                  .filter(stmt -> stmt.hasTag(VARDEF))\n+                  .map(JCVariableDecl.class::cast)\n+                  .map(vardef -> vardef.sym)\n+                  .filter(sym -> (sym.flags_field & FOR_LOOP_BODY_MAY_CAPTURE) != 0)\n+                  .collect(Collectors.toCollection(HashSet::new));\n+                if (capturableForLoopVars.isEmpty())\n+                    capturableForLoopVars = null;\n+            }\n+\n+            \/\/ Merge with previous and then scan the body\n+            if (capturableForLoopVars != null)\n+                capturable.addAll(capturableForLoopVars);\n+            try {\n+                scan(tree.body);\n+            } finally {\n+                if (capturableForLoopVars != null)\n+                    capturable.removeAll(capturableForLoopVars);\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8338711\n+ * @summary Check for invalid cases relating to for() loop variables being effectively final in the body\n+ * @compile\/fail\/ref=ForLoopVarsEffectivelyFinalInvalidTest.out -XDrawDiagnostics ForLoopVarsEffectivelyFinalInvalidTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class ForLoopVarsEffectivelyFinalInvalidTest {\n+\n+    \/\/ If the variable is mutated in the BODY, it loses its effectively final status in the BODY\n+    {\n+        for (int i = 0; i < 3; ) {\n+            i++;\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ error: ...must be final or effectively final\n+        }\n+    }\n+\n+    \/\/ If the variable is mutated in the INIT, it loses its effectively final status in the INIT\n+    {\n+        for (int i = 0, j = i++ + ((IntSupplier)() -> f(i)).getAsInt(); \/\/ error: ...must be final or effectively final\n+            i < 3; ) {\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ ok\n+        }\n+    }\n+\n+    \/\/ If the variable is mutated in the CONDITION, it loses its effectively final status in the CONDITION\n+    {\n+        for (int i = 0;\n+          i++ + ((IntSupplier)() -> f(i)).getAsInt() < 3; ) {           \/\/ error: ...must be final or effectively final\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ ok\n+        }\n+    }\n+\n+    \/\/ If the variable is mutated in the STEP, it loses its effectively final status in the STEP\n+    {\n+        for (int i = 0;\n+          i < 3;\n+          i += ((IntSupplier)() -> f(i)).getAsInt()) {                  \/\/ error: ...must be final or effectively final\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ ok\n+        }\n+    }\n+\n+    \/\/ An extra level of nesting doesn't make it OK\n+    {\n+        for (int i = 0; i < 3; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                ((IntSupplier)() -> f(i)).getAsInt();                   \/\/ error: ...must be final or effectively final\n+            }\n+            i++;\n+        }\n+    }\n+\n+    \/\/ If the variable is never initialized, it can't be captured\n+    {\n+        for (int i; \"\".hashCode() == 0; ) {\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ error: variable i might not have been initialized\n+        }\n+    }\n+\n+    int f(int i) {\n+        return i * i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalInvalidTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+ForLoopVarsEffectivelyFinalInvalidTest.java:58:35: compiler.err.var.might.not.have.been.initialized: i\n+ForLoopVarsEffectivelyFinalInvalidTest.java:16:35: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:22:57: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:31:39: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:40:38: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:49:39: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalInvalidTest.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8338711\n+ * @summary Check for valid cases relating to for() loop variables being effectively final in the body\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class ForLoopVarsEffectivelyFinalValidTest {\n+\n+    \/\/ Test: a loop variable modified in INIT can be captured by a lambda in BODY\n+    public static int test1() {\n+        int total = 0;\n+        for (int i = 1, j = ++i; i <= 3; i++) {\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: a loop variable modified in CONDITION can be captured by a lambda BODY\n+    public static int test2() {\n+        int total = 0;\n+        for (int i = 1; i++ <= 3; ) {\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: a loop variable modified in STEP can be captured by a lambda BODY\n+    public static int test3() {\n+        int total = 0;\n+        for (int i = 1; i <= 3; i++) {\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: complicated nesting doesn't confuse the analysis logic\n+    public static int test4() {\n+        int total = 0;\n+        for (int i = 1; i <= 3; i++) {\n+            IntSupplier s = () -> {\n+                int total2 = 0;\n+                for (int i2 = i; i2 <= 3; i2++) {\n+                    IntSupplier s2 = () -> i + i2;\n+                    total2 += s2.getAsInt();\n+                }\n+                return total2;\n+            };\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: complicated nesting doesn't confuse the analysis logic\n+    public static int test5() {\n+        int total = 0;\n+        for (int i = 1; i <= 3; i++) {\n+            for (int j = 1; j <= 3; j++) {\n+                IntSupplier s = () -> i + j;\n+                total += s.getAsInt();\n+            }\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: the variable's assigment may happen in the body\n+    public static int test6() {\n+        int total = 0;\n+        int j = 0;\n+        for (int i; j < 3; ) {\n+            i = ++j;\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    public static void main(String[] args) {\n+        verify(test1(), 5);\n+        verify(test2(), 9);\n+        verify(test3(), 6);\n+        verify(test4(), 24);\n+        verify(test5(), 36);\n+        verify(test6(), 6);\n+    }\n+\n+    public static void verify(int actual, int expected) {\n+        if (actual != expected)\n+            throw new AssertionError(String.format(\"expected %d but got %d\", expected, actual));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalValidTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}