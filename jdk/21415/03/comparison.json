{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,0 +200,7 @@\n+    \/**\n+     * Flag marking a basic for() loop iteration variable (i.e., a variable declared\n+     * in the init section of the loop) that is allowed to be captured by a nested\n+     * class or lambda even when the variable is neither final nor effectively final.\n+     *\/\n+    public static final long FOR_LOOP_BODY_MAY_CAPTURE = 1L<<32;\n+\n@@ -521,0 +528,1 @@\n+        FOR_LOOP_BODY_MAY_CAPTURE(Flags.FOR_LOOP_BODY_MAY_CAPTURE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2149,0 +2149,8 @@\n+        \/** In a basic for() loop body, during the first (FlowKind.NORMAL) run, this contains\n+         *  any loop variables that have NOT yet been reassigned (where \"reassigned\" means\n+         *  \"assigned when not DU\"). Note this can also contain variables from outer containing\n+         *  for() loop bodies. After a for() loop body has been scanned, the loop variables\n+         *  that were never reassigned are awarded the FOR_LOOP_BODY_MAY_CAPTURE flag.\n+         *\/\n+        final Bits notReassigned;\n+\n@@ -2185,0 +2193,1 @@\n+            notReassigned = new Bits();\n@@ -2234,0 +2243,5 @@\n+\n+                \/\/ In basic for() loop bodies, we notice when loop variables get reassigned\n+                if (notReassigned.isMember(sym.adr) && !uninits.isMember(sym.adr))\n+                    notReassigned.excl(sym.adr);\n+\n@@ -2693,0 +2707,1 @@\n+            int forLoopVarMin = nextadr;\n@@ -2694,0 +2709,1 @@\n+            int forLoopVarMax = nextadr;\n@@ -2715,1 +2731,12 @@\n-                scan(tree.body);\n+                if (flowKind.isFinal()) {\n+                    scan(tree.body);\n+                } else {\n+                    \/\/ on the first pass only, check for reassignments of loop variables\n+                    notReassigned.inclRange(forLoopVarMin, forLoopVarMax);\n+                    scan(tree.body);\n+                    for (int adr = forLoopVarMin; adr < forLoopVarMax; adr++) {\n+                        if (notReassigned.isMember(adr))\n+                            vardecls[adr].sym.flags_field |= FOR_LOOP_BODY_MAY_CAPTURE;\n+                    }\n+                    notReassigned.excludeFrom(forLoopVarMin);\n+                }\n@@ -3287,0 +3314,3 @@\n+        \/\/ Variables that may be captured even if not final or effectively final\n+        final Bits capturable = new Bits();\n+\n@@ -3301,1 +3331,1 @@\n-                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0) {\n+                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0 && (!capturable.isMember(sym.adr))) {\n@@ -3441,1 +3471,3 @@\n-                    if (var != null && (var.flags() & (FINAL | EFFECTIVELY_FINAL)) == 0) {\n+                    if (var != null\n+                            && (var.flags() & (FINAL | EFFECTIVELY_FINAL)) == 0\n+                            && (!(var instanceof VarSymbol sym && capturable.isMember(sym.adr)))) {\n@@ -3449,0 +3481,24 @@\n+        @Override\n+        public void visitForLoop(JCForLoop tree) {\n+\n+            \/\/ Recurse on initialization, condition, and step\n+            scan(tree.init);\n+            scan(tree.cond);\n+            scan(tree.step);\n+\n+            \/\/ Identify loop variables with FOR_LOOP_BODY_MAY_CAPTURE and then recurse on body\n+            final Bits newCapturable = new Bits();\n+            if (tree.init != null) {\n+                tree.init.stream()\n+                  .filter(stmt -> stmt.hasTag(VARDEF))\n+                  .map(JCVariableDecl.class::cast)\n+                  .map(vardef -> vardef.sym)\n+                  .filter(sym -> (sym.flags_field & FOR_LOOP_BODY_MAY_CAPTURE) != 0)\n+                  .mapToInt(sym -> sym.adr)\n+                  .forEach(newCapturable::incl);\n+            }\n+            capturable.orSet(newCapturable);\n+            scan(tree.body);\n+            capturable.diffSet(newCapturable);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8338711\n+ * @summary Check for invalid cases relating to for() loop variables being effectively final in the body\n+ * @compile\/fail\/ref=ForLoopVarsEffectivelyFinalInvalidTest.out -XDrawDiagnostics ForLoopVarsEffectivelyFinalInvalidTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+public class ForLoopVarsEffectivelyFinalInvalidTest {\n+\n+    \/\/ If the variable is mutated in the BODY, it loses its effectively final status in the BODY\n+    {\n+        for (int i = 0; i < 3; ) {\n+            i++;\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ error: ...must be final or effectively final\n+        }\n+    }\n+\n+    \/\/ If the variable is mutated in the INIT, it loses its effectively final status in the INIT\n+    {\n+        for (int i = 0, j = i++ + ((IntSupplier)() -> f(i)).getAsInt(); \/\/ error: ...must be final or effectively final\n+            i < 3; ) {\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ ok\n+        }\n+    }\n+\n+    \/\/ If the variable is mutated in the CONDITION, it loses its effectively final status in the CONDITION\n+    {\n+        for (int i = 0;\n+          i++ + ((IntSupplier)() -> f(i)).getAsInt() < 3; ) {           \/\/ error: ...must be final or effectively final\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ ok\n+        }\n+    }\n+\n+    \/\/ If the variable is mutated in the STEP, it loses its effectively final status in the STEP\n+    {\n+        for (int i = 0;\n+          i < 3;\n+          i += ((IntSupplier)() -> f(i)).getAsInt()) {                  \/\/ error: ...must be final or effectively final\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ ok\n+        }\n+    }\n+\n+    \/\/ An extra level of nesting doesn't make it OK\n+    {\n+        for (int i = 0; i < 3; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                ((IntSupplier)() -> f(i)).getAsInt();                   \/\/ error: ...must be final or effectively final\n+            }\n+            i++;\n+        }\n+    }\n+\n+    \/\/ If the variable is never initialized, it can't be captured\n+    {\n+        for (int i; \"\".hashCode() == 0; ) {\n+            ((IntSupplier)() -> f(i)).getAsInt();                       \/\/ error: variable i might not have been initialized\n+        }\n+    }\n+\n+    \/\/ An extra level of nesting doesn't make it OK\n+    {\n+        for (int i = 0; true; ) {\n+            for (int j = 0; j < 3; j++) {\n+                i = 42;\n+                Runnable r = () -> System.out.println(i);               \/\/ error: ...must be final or effectively final\n+            }\n+            break;\n+        }\n+    }\n+\n+    \/\/ An extra level of nesting doesn't make it OK\n+    {\n+        for (int i = 0; true; ) {\n+            for (int j = 0; j < ++i; j++) {\n+                Runnable r = () -> System.out.println(i);               \/\/ error: ...must be final or effectively final\n+            }\n+            break;\n+        }\n+    }\n+\n+    int f(int i) {\n+        return i * i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalInvalidTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+ForLoopVarsEffectivelyFinalInvalidTest.java:58:35: compiler.err.var.might.not.have.been.initialized: i\n+ForLoopVarsEffectivelyFinalInvalidTest.java:16:35: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:22:57: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:31:39: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:40:38: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:49:39: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:67:55: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+ForLoopVarsEffectivelyFinalInvalidTest.java:77:55: compiler.err.cant.ref.non.effectively.final.var: i, (compiler.misc.lambda)\n+8 errors\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalInvalidTest.out","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8338711\n+ * @summary Check for valid cases relating to for() loop variables being effectively final in the body\n+ *\/\n+\n+import java.io.*;\n+import java.util.function.*;\n+\n+public class ForLoopVarsEffectivelyFinalValidTest {\n+\n+    \/\/ Test: a loop variable modified in INIT can be captured by a lambda in BODY\n+    public static int test1() {\n+        int total = 0;\n+        for (int i = 1, j = ++i; i <= 3; i++) {\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: a loop variable modified in CONDITION can be captured by a lambda BODY\n+    public static int test2() {\n+        int total = 0;\n+        for (int i = 1; i++ <= 3; ) {\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: a loop variable modified in STEP can be captured by a lambda BODY\n+    public static int test3() {\n+        int total = 0;\n+        for (int i = 1; i <= 3; i++) {\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: complicated nesting doesn't confuse the analysis logic\n+    public static int test4() {\n+        int total = 0;\n+        for (int i = 1; i <= 3; i++) {\n+            IntSupplier s = () -> {\n+                int total2 = 0;\n+                for (int i2 = i; i2 <= 3; i2++) {\n+                    IntSupplier s2 = () -> i + i2;\n+                    total2 += s2.getAsInt();\n+                }\n+                return total2;\n+            };\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: complicated nesting doesn't confuse the analysis logic\n+    public static int test5() {\n+        int total = 0;\n+        for (int i = 1; i <= 3; i++) {\n+            for (int j = 1; j <= 3; j++) {\n+                IntSupplier s = () -> i + j;\n+                total += s.getAsInt();\n+            }\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: the variable's assigment may happen in the body\n+    public static int test6() {\n+        int total = 0;\n+        int j = 0;\n+        for (int i; j < 3; ) {\n+            i = ++j;\n+            IntSupplier s = () -> i;\n+            total += s.getAsInt();\n+        }\n+        return total;\n+    }\n+\n+    \/\/ Test: effectively final in the loop works with try-with-resources statements\n+    public static void test7() throws IOException {\n+        final InputStream input1 = new ByteArrayInputStream(new byte[0]);\n+        final InputStream input2 = new ByteArrayInputStream(new byte[0]);\n+        for (InputStream input = input1; true; input = input2) {\n+            try (input) {\n+                \/\/ nothing\n+            }\n+            if (input == input2)\n+                break;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        verify(test1(), 5);\n+        verify(test2(), 9);\n+        verify(test3(), 6);\n+        verify(test4(), 24);\n+        verify(test5(), 36);\n+        verify(test6(), 6);\n+        test7();\n+    }\n+\n+    public static void verify(int actual, int expected) {\n+        if (actual != expected)\n+            throw new AssertionError(String.format(\"expected %d but got %d\", expected, actual));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/forLoopVarsEffectivelyFinal\/ForLoopVarsEffectivelyFinalValidTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"}]}