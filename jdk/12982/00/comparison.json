{"files":[{"patch":"@@ -125,2 +125,0 @@\n-        execThreadGroup = new ThreadGroup(\"JShell process local execution\");\n-\n@@ -132,3 +130,14 @@\n-        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n-            if (e instanceof InvocationTargetException) {\n-                if (e.getCause() instanceof ThreadDeath) {\n+        execThreadGroup = new ThreadGroup(\"JShell process local execution\") {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                if (e instanceof InvocationTargetException) {\n+                    if (e.getCause() instanceof ThreadDeath) {\n+                        stopped.set(true);\n+                    } else {\n+                        iteEx.set((InvocationTargetException) e);\n+                    }\n+                } else if (e instanceof IllegalAccessException) {\n+                    iaeEx.set((IllegalAccessException) e);\n+                } else if (e instanceof NoSuchMethodException) {\n+                    nmeEx.set((NoSuchMethodException) e);\n+                } else if (e instanceof ThreadDeath) {\n@@ -136,2 +145,0 @@\n-                } else {\n-                    iteEx.set((InvocationTargetException) e);\n@@ -139,6 +146,0 @@\n-            } else if (e instanceof IllegalAccessException) {\n-                iaeEx.set((IllegalAccessException) e);\n-            } else if (e instanceof NoSuchMethodException) {\n-                nmeEx.set((NoSuchMethodException) e);\n-            } else if (e instanceof ThreadDeath) {\n-                stopped.set(true);\n@@ -146,1 +147,1 @@\n-        });\n+        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299934\n+ * @summary Test LocalExecutionControl\n+ * @run junit LocalExecutionControlExceptionTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import jdk.jshell.EvalException;\n+import jdk.jshell.JShell;\n+import jdk.jshell.execution.LocalExecutionControlProvider;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+\n+public class LocalExecutionControlExceptionTest {\n+\n+    @Test\n+    @ExtendWith(NoUncaughtExceptionHandleInterceptor.class)\n+    public void testUncaughtExceptions() throws InterruptedException {\n+        List<Throwable> excs = new ArrayList<>();\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        Thread.setDefaultUncaughtExceptionHandler((t, ex) -> excs.add(ex));\n+        try (var jshell = JShell.builder()\n+                                .err(new PrintStream(out))\n+                                .out(new PrintStream(out))\n+                                .executionEngine(new LocalExecutionControlProvider(), Map.of())\n+                                .build()) {\n+            {\n+                var events = jshell.eval(\"throw new java.io.IOException();\");\n+                Assertions.assertEquals(1, events.size());\n+                Assertions.assertNotNull(events.get(0).exception());\n+                Assertions.assertTrue(events.get(0).exception() instanceof EvalException);\n+                Assertions.assertEquals(\"java.io.IOException\",\n+                                        ((EvalException) events.get(0).exception()).getExceptionClassName());\n+                Assertions.assertEquals(0, excs.size());\n+                Assertions.assertEquals(0, out.size());\n+            }\n+            {\n+                var events = jshell.eval(\"throw new IllegalAccessException();\");\n+                Assertions.assertEquals(1, events.size());\n+                Assertions.assertNotNull(events.get(0).exception());\n+                Assertions.assertTrue(events.get(0).exception() instanceof EvalException);\n+                Assertions.assertEquals(\"java.lang.IllegalAccessException\",\n+                                        ((EvalException) events.get(0).exception()).getExceptionClassName());\n+                Assertions.assertEquals(0, excs.size());\n+                Assertions.assertEquals(0, out.size());\n+            }\n+            jshell.eval(\"\"\"\n+                        <T extends Throwable> T t2(Throwable t) throws T {\n+                            throw (T) t;\n+                        }\n+                        \"\"\");\n+            jshell.eval(\"\"\"\n+                        void t(Throwable t) {\n+                            throw t2(t);\n+                        }\n+                        \"\"\");\n+            {\n+                var events = jshell.eval(\"\"\"\n+                                         {\n+                                             var t = new Thread(() -> t(new java.io.IOException()));\n+                                             t.start();\n+                                             t.join();\n+                                         }\n+                                         \"\"\");\n+                Assertions.assertEquals(1, events.size());\n+                Assertions.assertNull(events.get(0).exception());\n+                Assertions.assertEquals(0, excs.size());\n+                Assertions.assertEquals(0, out.size());\n+            }\n+            {\n+                var events = jshell.eval(\"\"\"\n+                                         {\n+                                             var t = new Thread(() -> t(new IllegalAccessException()));\n+                                             t.start();\n+                                             t.join();\n+                                         }\n+                                         \"\"\");\n+                Assertions.assertEquals(1, events.size());\n+                Assertions.assertNull(events.get(0).exception());\n+                Assertions.assertEquals(0, excs.size());\n+                Assertions.assertEquals(0, out.size());\n+            }\n+            Thread outsideOfJShell = new Thread(() -> {\n+                t(new IOException());\n+            });\n+            outsideOfJShell.start();\n+            outsideOfJShell.join();\n+            Assertions.assertEquals(1, excs.size());\n+        }\n+    }\n+\n+    void t(Throwable t) {\n+        throw t2(t);\n+    }\n+\n+    <T extends Throwable> T t2(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n+    public static final class NoUncaughtExceptionHandleInterceptor implements InvocationInterceptor {\n+        public void interceptTestMethod(Invocation<Void> invocation,\n+                                        ReflectiveInvocationContext<Method> invocationContext,\n+                                        ExtensionContext extensionContext) throws Throwable {\n+            Throwable[] exc = new Throwable[1];\n+            \/\/the tests normally run in a ThreadGroup which handles uncaught exception\n+            \/\/run in a ThreadGroup which does not handle the uncaught exceptions, and let them\n+            \/\/pass to the default uncaught handler for the test:\n+            var thread = new Thread(Thread.currentThread().getThreadGroup().getParent(), \"test-group\") {\n+                public void run() {\n+                    try {\n+                        invocation.proceed();\n+                    } catch (Throwable ex) {\n+                        exc[0] = ex;\n+                    }\n+                }\n+            };\n+            thread.start();\n+            thread.join();\n+            if (exc[0] != null) {\n+                throw exc[0];\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/LocalExecutionControlExceptionTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"}]}