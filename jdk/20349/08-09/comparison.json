{"files":[{"patch":"@@ -3533,5 +3533,2 @@\n-         * is not a method, for example if the lambda is used to initialize\n-         * a field, then if the field is:\n-         *\n-         * - an instance field, we use the first constructor.\n-         * - a static field, we create a fake clinit method.\n+         * is not a method (e.g. if the lambda occurs in a field initializer), then\n+         * a synthetic method symbol owner is created.\n@@ -3543,1 +3540,3 @@\n-                \/\/field initializer\n+                \/\/ If the lambda is nested in a field initializer, we need to create a fake init method.\n+                \/\/ Uniqueness of this symbol is not important (as e.g. annotations will be added on the\n+                \/\/ init symbol's owner).\n@@ -3545,22 +3544,5 @@\n-                Symbol newScopeOwner = env.info.scope.owner;\n-                \/* if the field isn't static, then we can get the first constructor\n-                 * and use it as the owner of the environment. This is what\n-                 * LTM code is doing to look for type annotations so we are fine.\n-                 *\/\n-                if ((owner.flags() & STATIC) == 0) {\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n-                        newScopeOwner = s;\n-                        break;\n-                    }\n-                } else {\n-                    \/\/ If the field is static then we need to create a fake clinit method.\n-                    \/\/ Uniqueness of this symbol is not important (as e.g. annotations will be added on the\n-                    \/\/ init symbol's owner).\n-                    Type clinitType = new MethodType(List.nil(),\n-                            syms.voidType, List.nil(), syms.methodClass);\n-                    MethodSymbol clinit = new MethodSymbol(BLOCK | STATIC | SYNTHETIC | PRIVATE,\n-                            names.clinit, clinitType, enclClass);\n-                    clinit.params = List.nil();\n-                    newScopeOwner = clinit;\n-                }\n-                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));\n+                Name initName = owner.isStatic() ? names.clinit : names.init;\n+                MethodSymbol initSym = new MethodSymbol(BLOCK | (owner.isStatic() ? STATIC : 0) | SYNTHETIC | PRIVATE,\n+                        initName, initBlockType, enclClass);\n+                initSym.params = List.nil();\n+                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(initSym)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":28,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-                enclosingMethod = \"<init>\",\n@@ -328,1 +327,0 @@\n-                    enclosingMethod = \"<init>\",\n@@ -462,1 +460,0 @@\n-                    enclosingMethod = \"<init>\",\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/EnclosingMethod\/EnclosingMethodTest.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}