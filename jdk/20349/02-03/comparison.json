{"files":[{"patch":"@@ -1422,0 +1422,1 @@\n+            Type fakeOwnerType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);\n@@ -1424,1 +1425,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, fakeOwnerType,\n@@ -3575,1 +3576,1 @@\n-                        clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,\n+                        clinit = new MethodSymbol(BLOCK | STATIC | SYNTHETIC | PRIVATE,\n@@ -3939,0 +3940,1 @@\n+            fExpr.owner = env.info.scope.owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -91,0 +92,1 @@\n+import static com.sun.tools.javac.code.Flags.BLOCK;\n@@ -136,2 +138,2 @@\n-    \/** the lambda expression owner *\/\n-    private CaptureSiteInfo captureSiteInfo;\n+    \/** the variable whose initializer is pending *\/\n+    private VarSymbol pendingVar;\n@@ -202,39 +204,0 @@\n-    \/**\n-     * This record is used to store information on where a functional expression is captured.\n-     * This is useful both to forward type annotations to the synthetic lambda method,\n-     * and to compute the name of the synthetic lambda method (which depends\n-     * on _where_ the lambda capture occurs).\n-     *\/\n-    record CaptureSiteInfo(Symbol owner, boolean inStaticInit, VarSymbol pendingVar) {\n-\n-        static CaptureSiteInfo ofClass(JCClassDecl tree) {\n-            return new CaptureSiteInfo(tree.sym, false, null);\n-        }\n-\n-        CaptureSiteInfo withMethod(JCMethodDecl tree) {\n-            return new CaptureSiteInfo(tree.sym, false, null);\n-        }\n-\n-        CaptureSiteInfo withVar(JCVariableDecl tree) {\n-            return (tree.sym.owner.kind == TYP) ?\n-                    new CaptureSiteInfo(tree.sym, tree.sym.isStatic(), tree.sym) :\n-                    new CaptureSiteInfo(owner, inStaticInit, tree.sym);\n-        }\n-\n-        CaptureSiteInfo withBlock(JCBlock tree) {\n-            return new CaptureSiteInfo(owner, inStaticInit || tree.isStatic(), null);\n-        }\n-\n-        \/**\n-         * @return Name of the enclosing method to be folded into synthetic\n-         * method name\n-         *\/\n-        String enclosingMethodName() {\n-            return switch (owner.kind) {\n-                case MTH -> owner.isConstructor() ? \"new\" : owner.name.toString();\n-                case VAR, TYP -> inStaticInit ? \"static\" : \"new\";\n-                default -> throw new IllegalStateException(\"Unexpected owner: \" + owner.kind);\n-            };\n-        }\n-    }\n-\n@@ -341,1 +304,1 @@\n-        CaptureSiteInfo prevCaptureSiteInfo = captureSiteInfo;\n+        VarSymbol prevPendingVar = pendingVar;\n@@ -346,1 +309,1 @@\n-            captureSiteInfo = CaptureSiteInfo.ofClass(tree);\n+            pendingVar = null;\n@@ -371,1 +334,1 @@\n-            captureSiteInfo = prevCaptureSiteInfo;\n+            pendingVar = prevPendingVar;\n@@ -404,4 +367,9 @@\n-            apportionTypeAnnotations(tree,\n-                    owner::getInitTypeAttributes,\n-                    owner::setInitTypeAttributes,\n-                    sym::appendUniqueTypeAttributes);\n+            final long ownerFlags = owner.flags();\n+            if ((ownerFlags & Flags.BLOCK) != 0) {\n+                ClassSymbol cs = (ClassSymbol) owner.owner;\n+                boolean isStaticInit = (ownerFlags & Flags.STATIC) != 0;\n+                apportionTypeAnnotations(tree,\n+                        isStaticInit ? cs::getClassInitTypeAttributes : cs::getInitTypeAttributes,\n+                        isStaticInit ? cs::setClassInitTypeAttributes : cs::setInitTypeAttributes,\n+                        sym::appendUniqueTypeAttributes);\n+            }\n@@ -409,4 +377,6 @@\n-            apportionTypeAnnotations(tree,\n-                    owner::getClassInitTypeAttributes,\n-                    owner::setClassInitTypeAttributes,\n-                    sym::appendUniqueTypeAttributes);\n+            if (pendingVar != null && pendingVar.getKind() == ElementKind.FIELD) {\n+                apportionTypeAnnotations(tree,\n+                        pendingVar::getRawTypeAttributes,\n+                        pendingVar::setTypeAttributes,\n+                        sym::appendUniqueTypeAttributes);\n+            }\n@@ -599,1 +569,1 @@\n-        CaptureSiteInfo prevCaptureSiteInfo = captureSiteInfo;\n+        VarSymbol prevPendingVar = pendingVar;\n@@ -601,1 +571,1 @@\n-            captureSiteInfo = prevCaptureSiteInfo.withVar(tree);\n+            pendingVar = tree.sym;\n@@ -610,1 +580,1 @@\n-            captureSiteInfo = prevCaptureSiteInfo;\n+            pendingVar = prevPendingVar;\n@@ -614,21 +584,9 @@\n-    @Override\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        CaptureSiteInfo prevCaptureSiteInfo = captureSiteInfo;\n-        try {\n-            captureSiteInfo = prevCaptureSiteInfo.withMethod(tree);\n-            super.visitMethodDef(tree);\n-        } finally {\n-            captureSiteInfo = prevCaptureSiteInfo;\n-        }\n-    }\n-\n-    @Override\n-    public void visitBlock(JCBlock tree) {\n-        CaptureSiteInfo prevCaptureSiteInfo = captureSiteInfo;\n-        try {\n-            captureSiteInfo = prevCaptureSiteInfo.withBlock(tree);\n-            super.visitBlock(tree);\n-        } finally {\n-            captureSiteInfo = prevCaptureSiteInfo;\n-        }\n-    }\n+\/\/    @Override\n+\/\/    public void visitBlock(JCBlock tree) {\n+\/\/        VarSymbol prevPendingVar = pendingVar;\n+\/\/        try {\n+\/\/            super.visitBlock(tree);\n+\/\/        } finally {\n+\/\/            pendingVar = prevPendingVar;\n+\/\/        }\n+\/\/    }\n@@ -1024,1 +982,1 @@\n-            this.owner = captureSiteInfo.owner;\n+            this.owner = tree.owner;\n@@ -1155,2 +1113,2 @@\n-            if (captureSiteInfo.pendingVar != null) {\n-                buf.append(captureSiteInfo.pendingVar.flatName());\n+            if (pendingVar != null) {\n+                buf.append(pendingVar.flatName());\n@@ -1180,1 +1138,1 @@\n-            buf.append(captureSiteInfo.enclosingMethodName());\n+            buf.append(syntheticMethodNameComponent(owner));\n@@ -1186,0 +1144,16 @@\n+        \/**\n+         * @return Method name in a form that can be folded into a\n+         * component of a synthetic method name\n+         *\/\n+        String syntheticMethodNameComponent(Symbol owner) {\n+            long ownerFlags = owner.flags();\n+            if ((ownerFlags & BLOCK) != 0) {\n+                return (ownerFlags & STATIC) != 0 ?\n+                        \"static\" : \"new\";\n+            } else if (owner.isConstructor()) {\n+                return \"new\";\n+            } else {\n+                return owner.name.toString();\n+            }\n+        }\n+\n@@ -1196,1 +1170,1 @@\n-            buf.append(captureSiteInfo.enclosingMethodName());\n+            buf.append(syntheticMethodNameComponent(owner));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":55,"deletions":81,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -682,0 +682,1 @@\n+                slam.owner = tree.owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            (c.owner.type == null \/\/ local to init block\n+            ((c.owner.flags() & BLOCK) != 0 \/\/ local to init block\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -810,0 +810,2 @@\n+        \/** The owner of this functional expression. *\/\n+        public Symbol owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -385,1 +385,0 @@\n-                    enclosingMethod = \"<clinit>\",\n@@ -520,1 +519,0 @@\n-                    enclosingMethod = \"<clinit>\",\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/EnclosingMethod\/EnclosingMethodTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}