{"files":[{"patch":"@@ -288,1 +288,6 @@\n-    public static final long LAMBDA_METHOD = 1L<<49;\n+    public static final long LAMBDA_METHOD = 1L<<49; \/\/MethodSymbols only\n+\n+    \/**\n+     * Flag that marks a synthetic local capture field in a local\/anon class\n+     *\/\n+    public static final long LOCAL_CAPTURE_FIELD = 1L<<49; \/\/VarSymbols only\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+        initBlockType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);\n@@ -631,0 +632,1 @@\n+    final MethodType initBlockType;\n@@ -1424,1 +1426,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, initBlockType,\n@@ -3527,14 +3529,0 @@\n-        \/* Map to hold 'fake' clinit methods. If a lambda is used to initialize a\n-         * static field and that lambda has type annotations, these annotations will\n-         * also be stored at these fake clinit methods.\n-         *\n-         * LambdaToMethod also use fake clinit methods so they can be reused.\n-         * Also as LTM is a phase subsequent to attribution, the methods from\n-         * clinits can be safely removed by LTM to save memory.\n-         *\/\n-        private Map<ClassSymbol, MethodSymbol> clinits = new HashMap<>();\n-\n-        public MethodSymbol removeClinit(ClassSymbol sym) {\n-            return clinits.remove(sym);\n-        }\n-\n@@ -3545,5 +3533,2 @@\n-         * is not a method, for example if the lambda is used to initialize\n-         * a field, then if the field is:\n-         *\n-         * - an instance field, we use the first constructor.\n-         * - a static field, we create a fake clinit method.\n+         * is not a method (e.g. if the lambda occurs in a field initializer), then\n+         * a synthetic method symbol owner is created.\n@@ -3555,1 +3540,3 @@\n-                \/\/field initializer\n+                \/\/ If the lambda is nested in a field initializer, we need to create a fake init method.\n+                \/\/ Uniqueness of this symbol is not important (as e.g. annotations will be added on the\n+                \/\/ init symbol's owner).\n@@ -3557,26 +3544,5 @@\n-                Symbol newScopeOwner = env.info.scope.owner;\n-                \/* if the field isn't static, then we can get the first constructor\n-                 * and use it as the owner of the environment. This is what\n-                 * LTM code is doing to look for type annotations so we are fine.\n-                 *\/\n-                if ((owner.flags() & STATIC) == 0) {\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n-                        newScopeOwner = s;\n-                        break;\n-                    }\n-                } else {\n-                    \/* if the field is static then we need to create a fake clinit\n-                     * method, this method can later be reused by LTM.\n-                     *\/\n-                    MethodSymbol clinit = clinits.get(enclClass);\n-                    if (clinit == null) {\n-                        Type clinitType = new MethodType(List.nil(),\n-                                syms.voidType, List.nil(), syms.methodClass);\n-                        clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,\n-                                names.clinit, clinitType, enclClass);\n-                        clinit.params = List.nil();\n-                        clinits.put(enclClass, clinit);\n-                    }\n-                    newScopeOwner = clinit;\n-                }\n-                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));\n+                Name initName = owner.isStatic() ? names.clinit : names.init;\n+                MethodSymbol initSym = new MethodSymbol(BLOCK | (owner.isStatic() ? STATIC : 0) | SYNTHETIC | PRIVATE,\n+                        initName, initBlockType, enclClass);\n+                initSym.params = List.nil();\n+                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(initSym)));\n@@ -3939,0 +3905,1 @@\n+            fExpr.owner = env.info.scope.owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":14,"deletions":47,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.List;\n+\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n+\n+\/**\n+ * A visitor which collects the set of local variables \"captured\" by a given tree.\n+ *\/\n+public class CaptureScanner extends TreeScanner {\n+\n+    \/**\n+     * The tree under analysis.\n+     *\/\n+    private final JCTree tree;\n+\n+    \/**\n+     * The set of local variable declarations encountered in the tree under analysis.\n+     *\/\n+    private final Set<Symbol.VarSymbol> seenVars = new HashSet<>();\n+\n+    \/**\n+     * The list of owner's variables accessed from within the local class,\n+     * without any duplicates.\n+     *\/\n+    private final Set<VarSymbol> fvs = new LinkedHashSet<>();\n+\n+    public CaptureScanner(JCTree ownerTree) {\n+        this.tree = ownerTree;\n+    }\n+\n+    @Override\n+    public void visitIdent(JCTree.JCIdent tree) {\n+        Symbol sym = tree.sym;\n+        if (sym.kind == VAR && sym.owner.kind == MTH) {\n+            Symbol.VarSymbol vsym = (Symbol.VarSymbol) sym;\n+            if (vsym.getConstValue() == null && !seenVars.contains(vsym)) {\n+                addFreeVar(vsym);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Add free variable to fvs list unless it is already there.\n+     *\/\n+    protected void addFreeVar(Symbol.VarSymbol v) {\n+        fvs.add(v);\n+    }\n+\n+    @Override\n+    public void visitVarDef(JCTree.JCVariableDecl tree) {\n+        if (tree.sym.owner.kind == MTH) {\n+            seenVars.add(tree.sym);\n+        }\n+        super.visitVarDef(tree);\n+    }\n+\n+    \/**\n+     * Obtains the list of captured local variables in the tree under analysis.\n+     *\/\n+    List<Symbol.VarSymbol> analyzeCaptures() {\n+        scan(tree);\n+        return List.from(fvs);\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CaptureScanner.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -28,10 +28,0 @@\n-import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n-import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;\n-import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n-import com.sun.tools.javac.tree.*;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n@@ -39,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -42,0 +33,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n@@ -48,1 +40,5 @@\n-import com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.*;\n+import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n+import com.sun.tools.javac.main.Option;\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -50,1 +46,29 @@\n-import com.sun.tools.javac.util.*;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCAnnotation;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCBreak;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCStatement;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.DiagnosticSource;\n+import com.sun.tools.javac.util.InvalidUtfException;\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -52,0 +76,6 @@\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n@@ -53,1 +83,2 @@\n-import java.util.EnumMap;\n+import javax.lang.model.element.ElementKind;\n+import java.lang.invoke.LambdaMetafactory;\n@@ -56,1 +87,0 @@\n-import java.util.LinkedHashMap;\n@@ -58,1 +88,0 @@\n-import java.util.Optional;\n@@ -63,9 +92,17 @@\n-import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;\n-import static com.sun.tools.javac.code.Flags.*;\n-import static com.sun.tools.javac.code.Kinds.Kind.*;\n-import static com.sun.tools.javac.code.TypeTag.*;\n-import static com.sun.tools.javac.tree.JCTree.Tag.*;\n-\n-import javax.lang.model.element.ElementKind;\n-\n-import com.sun.tools.javac.main.Option;\n+import static com.sun.tools.javac.code.Flags.ABSTRACT;\n+import static com.sun.tools.javac.code.Flags.BLOCK;\n+import static com.sun.tools.javac.code.Flags.DEFAULT;\n+import static com.sun.tools.javac.code.Flags.FINAL;\n+import static com.sun.tools.javac.code.Flags.INTERFACE;\n+import static com.sun.tools.javac.code.Flags.LAMBDA_METHOD;\n+import static com.sun.tools.javac.code.Flags.LOCAL_CAPTURE_FIELD;\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.PRIVATE;\n+import static com.sun.tools.javac.code.Flags.STATIC;\n+import static com.sun.tools.javac.code.Flags.STRICTFP;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n+import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.VOID;\n@@ -83,8 +120,8 @@\n-    private Attr attr;\n-    private JCDiagnostic.Factory diags;\n-    private Log log;\n-    private Lower lower;\n-    private Names names;\n-    private Symtab syms;\n-    private Resolve rs;\n-    private Operators operators;\n+    private final Attr attr;\n+    private final JCDiagnostic.Factory diags;\n+    private final Log log;\n+    private final Lower lower;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Resolve rs;\n+    private final Operators operators;\n@@ -92,2 +129,2 @@\n-    private Types types;\n-    private TransTypes transTypes;\n+    private final Types types;\n+    private final TransTypes transTypes;\n@@ -96,9 +133,0 @@\n-    \/** the analyzer scanner *\/\n-    private LambdaAnalyzerPreprocessor analyzer;\n-\n-    \/** map from lambda trees to translation contexts *\/\n-    private Map<JCTree, TranslationContext<?>> contextMap;\n-\n-    \/** current translation context (visitor argument) *\/\n-    private TranslationContext<?> context;\n-\n@@ -108,0 +136,6 @@\n+    \/** translation context of the current lambda expression *\/\n+    private LambdaTranslationContext lambdaContext;\n+\n+    \/** the variable whose initializer is pending *\/\n+    private VarSymbol pendingVar;\n+\n@@ -124,1 +158,1 @@\n-    public static final int FLAG_SERIALIZABLE = 1 << 0;\n+    public static final int FLAG_SERIALIZABLE = LambdaMetafactory.FLAG_SERIALIZABLE;\n@@ -127,1 +161,1 @@\n-    public static final int FLAG_MARKERS = 1 << 1;\n+    public static final int FLAG_MARKERS = LambdaMetafactory.FLAG_MARKERS;\n@@ -130,1 +164,1 @@\n-    public static final int FLAG_BRIDGES = 1 << 2;\n+    public static final int FLAG_BRIDGES = LambdaMetafactory.FLAG_BRIDGES;\n@@ -154,1 +188,0 @@\n-        analyzer = new LambdaAnalyzerPreprocessor();\n@@ -160,2 +193,2 @@\n-            options.isUnset(Option.G_CUSTOM) ||\n-            options.isSet(Option.G_CUSTOM, \"lines\");\n+                options.isUnset(Option.G_CUSTOM) ||\n+                        options.isSet(Option.G_CUSTOM, \"lines\");\n@@ -163,3 +196,3 @@\n-            options.isUnset(Option.G_CUSTOM)\n-            ? options.isSet(Option.G)\n-            : options.isSet(Option.G_CUSTOM, \"vars\");\n+                options.isUnset(Option.G_CUSTOM)\n+                        ? options.isSet(Option.G)\n+                        : options.isSet(Option.G_CUSTOM, \"vars\");\n@@ -183,1 +216,0 @@\n-\n@@ -206,1 +238,1 @@\n-        private ListBuffer<JCTree> appendedMethodList;\n+        private ListBuffer<JCTree> appendedMethodList = new ListBuffer<>();\n@@ -208,1 +240,1 @@\n-        private Map<DedupedLambda, DedupedLambda> dedupedLambdas;\n+        private final Map<DedupedLambda, DedupedLambda> dedupedLambdas = new HashMap<>();\n@@ -210,1 +242,1 @@\n-        private Map<Object, DynamicMethodSymbol> dynMethSyms = new HashMap<>();\n+        private final Map<Object, DynamicMethodSymbol> dynMethSyms = new HashMap<>();\n@@ -215,1 +247,1 @@\n-        private final Map<String, ListBuffer<JCStatement>> deserializeCases;\n+        private final Map<String, ListBuffer<JCStatement>> deserializeCases = new HashMap<>();\n@@ -217,1 +249,1 @@\n-       \/**\n+        \/**\n@@ -229,0 +261,2 @@\n+        private final Map<String, Integer> syntheticNames = new HashMap<>();\n+\n@@ -231,3 +265,0 @@\n-            appendedMethodList = new ListBuffer<>();\n-            dedupedLambdas = new HashMap<>();\n-            deserializeCases = new HashMap<>();\n@@ -244,8 +275,0 @@\n-    }\n-\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"translate methods\">\n-    @Override\n-    public <T extends JCTree> T translate(T tree) {\n-        TranslationContext<?> newContext = contextMap.get(tree);\n-        return translate(tree, newContext != null ? newContext : context);\n-    }\n@@ -253,15 +276,8 @@\n-    <T extends JCTree> T translate(T tree, TranslationContext<?> newContext) {\n-        TranslationContext<?> prevContext = context;\n-        try {\n-            context = newContext;\n-            return super.translate(tree);\n-        }\n-        finally {\n-            context = prevContext;\n-        }\n-    }\n-\n-    <T extends JCTree> List<T> translate(List<T> trees, TranslationContext<?> newContext) {\n-        ListBuffer<T> buf = new ListBuffer<>();\n-        for (T tree : trees) {\n-            buf.append(translate(tree, newContext));\n+        int syntheticNameIndex(StringBuilder buf, int start) {\n+            String temp = buf.toString();\n+            Integer count = syntheticNames.get(temp);\n+            if (count == null) {\n+                count = start;\n+            }\n+            syntheticNames.put(temp, count + 1);\n+            return count;\n@@ -269,1 +285,0 @@\n-        return buf.toList();\n@@ -272,0 +287,1 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"visitor methods\">\n@@ -275,3 +291,0 @@\n-        this.context = null;\n-        this.contextMap = new HashMap<>();\n-        cdef = analyzer.analyzeAndPreprocessClass((JCClassDecl) cdef);\n@@ -280,1 +293,0 @@\n-    \/\/ <\/editor-fold>\n@@ -282,1 +294,0 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"visitor methods\">\n@@ -287,1 +298,0 @@\n-     * @param tree\n@@ -292,0 +302,3 @@\n+        DiagnosticSource prevSource = log.currentSource();\n+        LambdaTranslationContext prevLambdaContext = lambdaContext;\n+        VarSymbol prevPendingVar = pendingVar;\n@@ -294,0 +307,3 @@\n+            log.useSource(tree.sym.sourcefile);\n+            lambdaContext = null;\n+            pendingVar = null;\n@@ -295,0 +311,3 @@\n+            if (prevLambdaContext != null) {\n+                tree.sym.owner = prevLambdaContext.translatedSym;\n+            }\n@@ -299,1 +318,1 @@\n-                    kInfo.addMethod(makeDeserializeMethod(tree.sym));\n+                    kInfo.addMethod(makeDeserializeMethod());\n@@ -313,0 +332,3 @@\n+            log.useSource(prevSource.getFile());\n+            lambdaContext = prevLambdaContext;\n+            pendingVar = prevPendingVar;\n@@ -320,1 +342,0 @@\n-     * @param tree\n@@ -324,1 +345,1 @@\n-        LambdaTranslationContext localContext = (LambdaTranslationContext)context;\n+        LambdaTranslationContext localContext = new LambdaTranslationContext(tree);\n@@ -335,1 +356,1 @@\n-            Symbol owner = localContext.owner;\n+            Symbol owner = tree.owner;\n@@ -341,4 +362,4 @@\n-\n-            boolean init;\n-            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n-                owner = owner.owner;\n+            final long ownerFlags = owner.flags();\n+            if ((ownerFlags & Flags.BLOCK) != 0) {\n+                ClassSymbol cs = (ClassSymbol) owner.owner;\n+                boolean isStaticInit = (ownerFlags & Flags.STATIC) != 0;\n@@ -346,2 +367,2 @@\n-                        init ? owner::getInitTypeAttributes : owner::getClassInitTypeAttributes,\n-                        init ? owner::setInitTypeAttributes : owner::setClassInitTypeAttributes,\n+                        isStaticInit ? cs::getClassInitTypeAttributes : cs::getInitTypeAttributes,\n+                        isStaticInit ? cs::setClassInitTypeAttributes : cs::setInitTypeAttributes,\n@@ -350,2 +371,2 @@\n-            if (localContext.self != null && localContext.self.getKind() == ElementKind.FIELD) {\n-                owner = localContext.self;\n+\n+            if (pendingVar != null && pendingVar.getKind() == ElementKind.FIELD) {\n@@ -353,2 +374,2 @@\n-                        owner::getRawTypeAttributes,\n-                        owner::setTypeAttributes,\n+                        pendingVar::getRawTypeAttributes,\n+                        pendingVar::setTypeAttributes,\n@@ -366,2 +387,2 @@\n-                    List.nil() :\n-                    make.Types(lambdaType.getThrownTypes()),\n+                        List.nil() :\n+                        make.Types(lambdaType.getThrownTypes()),\n@@ -373,22 +394,0 @@\n-        \/\/translate lambda body\n-        \/\/As the lambda body is translated, all references to lambda locals,\n-        \/\/captured variables, enclosing members are adjusted accordingly\n-        \/\/to refer to the static method parameters (rather than i.e. accessing\n-        \/\/captured members directly).\n-        lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));\n-\n-        boolean dedupe = false;\n-        if (deduplicateLambdas && !debugLinesOrVars && !localContext.isSerializable()) {\n-            DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);\n-            DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);\n-            if (existing != null) {\n-                sym = existing.symbol;\n-                dedupe = true;\n-                if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));\n-            }\n-        }\n-        if (!dedupe) {\n-            \/\/Add the method to the list of methods to be added to this class.\n-            kInfo.addMethod(lambdaDecl);\n-        }\n-\n@@ -411,1 +410,1 @@\n-                    localContext.owner.enclClass()));\n+                    tree.owner.enclClass()));\n@@ -415,5 +414,3 @@\n-        for (Symbol fv : localContext.getSymbolMap(CAPTURED_VAR).keySet()) {\n-            if (fv != localContext.self) {\n-                JCExpression captured_local = make.Ident(fv).setType(fv.type);\n-                syntheticInits.append(captured_local);\n-            }\n+        for (Symbol fv : localContext.capturedVars) {\n+            JCExpression captured_local = make.Ident(fv).setType(fv.type);\n+            syntheticInits.append(captured_local);\n@@ -423,1 +420,29 @@\n-        List<JCExpression> indy_args = translate(syntheticInits.toList(), localContext.prev);\n+        List<JCExpression> indy_args = translate(syntheticInits.toList());\n+\n+        LambdaTranslationContext prevLambdaContext = lambdaContext;\n+        try {\n+            lambdaContext = localContext;\n+            \/\/translate lambda body\n+            \/\/As the lambda body is translated, all references to lambda locals,\n+            \/\/captured variables, enclosing members are adjusted accordingly\n+            \/\/to refer to the static method parameters (rather than i.e. accessing\n+            \/\/captured members directly).\n+            lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));\n+        } finally {\n+            lambdaContext = prevLambdaContext;\n+        }\n+\n+        boolean dedupe = false;\n+        if (deduplicateLambdas && !debugLinesOrVars && !isSerializable(tree)) {\n+            DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);\n+            DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);\n+            if (existing != null) {\n+                sym = existing.symbol;\n+                dedupe = true;\n+                if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));\n+            }\n+        }\n+        if (!dedupe) {\n+            \/\/Add the method to the list of methods to be added to this class.\n+            kInfo.addMethod(lambdaDecl);\n+        }\n@@ -426,1 +451,1 @@\n-        result = makeMetafactoryIndyCall(context, sym.asHandle(), indy_args);\n+        result = makeMetafactoryIndyCall(tree, sym.asHandle(), localContext.translatedSym, indy_args);\n@@ -430,19 +455,14 @@\n-        \/\/ Reassign type annotations from the source that should really belong to the lambda\n-        private void apportionTypeAnnotations(JCLambda tree,\n-                                              Supplier<List<Attribute.TypeCompound>> source,\n-                                              Consumer<List<Attribute.TypeCompound>> owner,\n-                                              Consumer<List<Attribute.TypeCompound>> lambda) {\n-\n-            ListBuffer<Attribute.TypeCompound> ownerTypeAnnos = new ListBuffer<>();\n-            ListBuffer<Attribute.TypeCompound> lambdaTypeAnnos = new ListBuffer<>();\n-\n-            for (Attribute.TypeCompound tc : source.get()) {\n-                if (tc.position.onLambda == tree) {\n-                    lambdaTypeAnnos.append(tc);\n-                } else {\n-                    ownerTypeAnnos.append(tc);\n-                }\n-            }\n-            if (lambdaTypeAnnos.nonEmpty()) {\n-                owner.accept(ownerTypeAnnos.toList());\n-                lambda.accept(lambdaTypeAnnos.toList());\n+    \/\/ Reassign type annotations from the source that should really belong to the lambda\n+    private void apportionTypeAnnotations(JCLambda tree,\n+                                          Supplier<List<Attribute.TypeCompound>> source,\n+                                          Consumer<List<Attribute.TypeCompound>> owner,\n+                                          Consumer<List<Attribute.TypeCompound>> lambda) {\n+\n+        ListBuffer<Attribute.TypeCompound> ownerTypeAnnos = new ListBuffer<>();\n+        ListBuffer<Attribute.TypeCompound> lambdaTypeAnnos = new ListBuffer<>();\n+\n+        for (Attribute.TypeCompound tc : source.get()) {\n+            if (tc.position.onLambda == tree) {\n+                lambdaTypeAnnos.append(tc);\n+            } else {\n+                ownerTypeAnnos.append(tc);\n@@ -451,0 +471,5 @@\n+        if (lambdaTypeAnnos.nonEmpty()) {\n+            owner.accept(ownerTypeAnnos.toList());\n+            lambda.accept(lambdaTypeAnnos.toList());\n+        }\n+    }\n@@ -463,1 +488,0 @@\n-     * @param tree\n@@ -467,2 +491,0 @@\n-        ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;\n-\n@@ -474,29 +496,16 @@\n-        JCExpression init;\n-        switch(tree.kind) {\n-\n-            case IMPLICIT_INNER:    \/** Inner :: new *\/\n-            case SUPER:             \/** super :: instMethod *\/\n-                init = makeThis(\n-                    localContext.owner.enclClass().asType(),\n-                    localContext.owner.enclClass());\n-                break;\n-\n-            case BOUND:             \/** Expr :: instMethod *\/\n-                init = transTypes.coerce(attrEnv, tree.getQualifierExpression(),\n-                    types.erasure(tree.sym.owner.type));\n-                init = attr.makeNullCheck(init);\n-                break;\n-\n-            case UNBOUND:           \/** Type :: instMethod *\/\n-            case STATIC:            \/** Type :: staticMethod *\/\n-            case TOPLEVEL:          \/** Top level :: new *\/\n-            case ARRAY_CTOR:        \/** ArrayType :: new *\/\n-                init = null;\n-                break;\n-\n-            default:\n-                throw new InternalError(\"Should not have an invalid kind\");\n-        }\n-\n-        List<JCExpression> indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);\n-\n+        JCExpression init = switch (tree.kind) {\n+            case IMPLICIT_INNER,    \/* Inner :: new *\/\n+                 SUPER ->           \/* super :: instMethod *\/\n+                    makeThis(tree.owner.enclClass().asType(), tree.owner.enclClass());\n+            case BOUND ->           \/* Expr :: instMethod *\/\n+                    attr.makeNullCheck(transTypes.coerce(attrEnv, tree.getQualifierExpression(),\n+                            types.erasure(tree.sym.owner.type)));\n+            case UNBOUND,           \/* Type :: instMethod *\/\n+                 STATIC,            \/* Type :: staticMethod *\/\n+                 TOPLEVEL,          \/* Top level :: new *\/\n+                 ARRAY_CTOR ->      \/* ArrayType :: new *\/\n+                    null;\n+        };\n+\n+        List<JCExpression> indy_args = (init == null) ?\n+                List.nil() : translate(List.of(init));\n@@ -505,1 +514,1 @@\n-        result = makeMetafactoryIndyCall(localContext, refSym.asHandle(), indy_args);\n+        result = makeMetafactoryIndyCall(tree, refSym.asHandle(), refSym, indy_args);\n@@ -510,1 +519,0 @@\n-     * @param tree\n@@ -514,1 +522,1 @@\n-        if (context == null || !analyzer.lambdaIdentSymbolFilter(tree.sym)) {\n+        if (lambdaContext == null) {\n@@ -520,2 +528,0 @@\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n@@ -538,7 +544,12 @@\n-        LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;\n-        if (context != null && lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {\n-            tree.init = translate(tree.init);\n-            tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);\n-            result = tree;\n-        } else {\n-            super.visitVarDef(tree);\n+        VarSymbol prevPendingVar = pendingVar;\n+        try {\n+            pendingVar = tree.sym;\n+            if (lambdaContext != null) {\n+                tree.sym = lambdaContext.addLocal(tree.sym);\n+                tree.init = translate(tree.init);\n+                result = tree;\n+            } else {\n+                super.visitVarDef(tree);\n+            }\n+        } finally {\n+            pendingVar = prevPendingVar;\n@@ -612,1 +623,1 @@\n-                    VarSymbol loc = makeSyntheticVar(0, names.fromString(\"$loc\"), tree.expr.type, lambdaMethodDecl.sym);\n+                    VarSymbol loc = new VarSymbol(SYNTHETIC, names.fromString(\"$loc\"), tree.expr.type, lambdaMethodDecl.sym);\n@@ -631,1 +642,1 @@\n-    private JCMethodDecl makeDeserializeMethod(Symbol kSym) {\n+    private JCMethodDecl makeDeserializeMethod() {\n@@ -647,2 +658,2 @@\n-                    syms.illegalArgumentExceptionType,\n-                    List.of(make.Literal(\"Invalid lambda deserialization\"))))));\n+                        syms.illegalArgumentExceptionType,\n+                        List.of(make.Literal(\"Invalid lambda deserialization\"))))));\n@@ -650,7 +661,7 @@\n-                        names.deserializeLambda,\n-                        make.QualIdent(kInfo.deserMethodSym.getReturnType().tsym),\n-                        List.nil(),\n-                        List.of(make.VarDef(kInfo.deserParamSym, null)),\n-                        List.nil(),\n-                        body,\n-                        null);\n+                names.deserializeLambda,\n+                make.QualIdent(kInfo.deserMethodSym.getReturnType().tsym),\n+                List.nil(),\n+                List.of(make.VarDef(kInfo.deserParamSym, null)),\n+                List.nil(),\n+                body,\n+                null);\n@@ -670,1 +681,1 @@\n-            null, make.QualIdent(ctype.tsym), args, null);\n+                null, make.QualIdent(ctype.tsym), args, null);\n@@ -683,1 +694,1 @@\n-     }\n+    }\n@@ -714,6 +725,6 @@\n-                    kindTest,\n-                    \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n-                    \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n-                    \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n-                    \"getImplClass\", implClass),\n-                    \"getImplMethodSignature\", implMethodSignature),\n+                                                        kindTest,\n+                                                        \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n+                                                \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n+                                        \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n+                                \"getImplClass\", implClass),\n+                        \"getImplMethodSignature\", implMethodSignature),\n@@ -721,4 +732,4 @@\n-                    pos,\n-                    syms.lambdaMetafactory,\n-                    names.altMetafactory,\n-                    staticArgs, indyType, serArgs.toList(), samSym.name)),\n+                        pos,\n+                        syms.lambdaMetafactory,\n+                        names.altMetafactory,\n+                        staticArgs, indyType, serArgs.toList(), samSym.name)),\n@@ -745,2 +756,2 @@\n-        JCBinary testExpr = make.Binary(JCTree.Tag.EQ, arg1, arg2);\n-        testExpr.operator = operators.resolveBinary(testExpr, JCTree.Tag.EQ, argType, argType);\n+        JCBinary testExpr = make.Binary(Tag.EQ, arg1, arg2);\n+        testExpr.operator = operators.resolveBinary(testExpr, Tag.EQ, argType, argType);\n@@ -759,2 +770,2 @@\n-        JCBinary compound = make.Binary(JCTree.Tag.AND, prev, eqtest);\n-        compound.operator = operators.resolveBinary(compound, JCTree.Tag.AND, syms.booleanType, syms.booleanType);\n+        JCBinary compound = make.Binary(Tag.AND, prev, eqtest);\n+        compound.operator = operators.resolveBinary(compound, Tag.AND, syms.booleanType, syms.booleanType);\n@@ -773,3 +784,3 @@\n-                    List.nil(),\n-                    make.Select(make.Ident(kInfo.deserParamSym).setType(syms.serializedLambdaType), getsym).setType(getmt),\n-                    args).setType(type);\n+                List.nil(),\n+                make.Select(make.Ident(kInfo.deserParamSym).setType(syms.serializedLambdaType), getsym).setType(getmt),\n+                args).setType(type);\n@@ -785,9 +796,0 @@\n-    \/**\n-     * Create new synthetic variable with given flags, name, type, owner\n-     *\/\n-    private VarSymbol makeSyntheticVar(long flags, Name name, Type type, Symbol owner) {\n-        return new VarSymbol(flags | SYNTHETIC, name, type, owner);\n-    }\n-\n-    \/\/ <\/editor-fold>\n-\n@@ -797,3 +799,3 @@\n-                        type.getReturnType(),\n-                        type.getThrownTypes(),\n-                        syms.methodClass);\n+                type.getReturnType(),\n+                type.getThrownTypes(),\n+                syms.methodClass);\n@@ -805,3 +807,3 @@\n-    private JCExpression makeMetafactoryIndyCall(TranslationContext<?> context,\n-            MethodHandleSymbol refSym, List<JCExpression> indy_args) {\n-        JCFunctionalExpression tree = context.tree;\n+    private JCExpression makeMetafactoryIndyCall(JCFunctionalExpression tree,\n+                                                 MethodHandleSymbol refSym, MethodSymbol nonDedupedRefSym,\n+                                                 List<JCExpression> indy_args) {\n@@ -827,1 +829,8 @@\n-        Name metafactoryName = context.needsAltMetafactory() ?\n+        List<Symbol> bridges = bridges(tree);\n+        boolean isSerializable = isSerializable(tree);\n+        boolean needsAltMetafactory = tree.target.isIntersection() ||\n+                isSerializable || bridges.length() > 1;\n+\n+        dumpStats(tree, needsAltMetafactory, nonDedupedRefSym);\n+\n+        Name metafactoryName = needsAltMetafactory ?\n@@ -830,1 +839,1 @@\n-        if (context.needsAltMetafactory()) {\n+        if (needsAltMetafactory) {\n@@ -838,2 +847,2 @@\n-                    t.tsym != tree.type.tsym &&\n-                    t.tsym != syms.objectType.tsym) {\n+                        t.tsym != tree.type.tsym &&\n+                        t.tsym != syms.objectType.tsym) {\n@@ -843,1 +852,1 @@\n-            int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;\n+            int flags = isSerializable ? FLAG_SERIALIZABLE : 0;\n@@ -845,1 +854,1 @@\n-            boolean hasBridges = context.bridges.nonEmpty();\n+            boolean hasBridges = bridges.nonEmpty();\n@@ -858,2 +867,2 @@\n-                staticArgs = staticArgs.append(LoadableConstant.Int(context.bridges.length() - 1));\n-                for (Symbol s : context.bridges) {\n+                staticArgs = staticArgs.append(LoadableConstant.Int(bridges.length() - 1));\n+                for (Symbol s : bridges) {\n@@ -866,1 +875,1 @@\n-            if (context.isSerializable()) {\n+            if (isSerializable) {\n@@ -892,2 +901,2 @@\n-                syms.stringType,\n-                syms.methodTypeType).appendList(staticArgs.map(types::constantType));\n+                    syms.stringType,\n+                    syms.methodTypeType).appendList(staticArgs.map(types::constantType));\n@@ -900,4 +909,4 @@\n-                                            syms.noSymbol,\n-                                            bsm.asHandle(),\n-                                            indyType,\n-                                            staticArgs.toArray(new LoadableConstant[staticArgs.length()]));\n+                            syms.noSymbol,\n+                            bsm.asHandle(),\n+                            indyType,\n+                            staticArgs.toArray(new LoadableConstant[staticArgs.length()]));\n@@ -918,11 +927,5 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Lambda\/reference analyzer\">\n-    \/**\n-     * This visitor collects information about translation of a lambda expression.\n-     * More specifically, it keeps track of the enclosing contexts and captured locals\n-     * accessed by the lambda being translated (as well as other useful info).\n-     * It also translates away problems for LambdaToMethod.\n-     *\/\n-    class LambdaAnalyzerPreprocessor extends TreeTranslator {\n-\n-        \/** the frame stack - used to reconstruct translation info about enclosing scopes *\/\n-        private List<Frame> frameStack;\n+    List<Symbol> bridges(JCFunctionalExpression tree) {\n+        ClassSymbol csym =\n+                types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);\n+        return types.functionalInterfaceBridges(csym);\n+    }\n@@ -930,5 +933,7 @@\n-        \/**\n-         * keep the count of lambda expression (used to generate unambiguous\n-         * names)\n-         *\/\n-        private int lambdaCount = 0;\n+    \/** does this functional expression require serialization support? *\/\n+    boolean isSerializable(JCFunctionalExpression tree) {\n+        if (forceSerializable) {\n+            return true;\n+        }\n+        return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n+    }\n@@ -936,15 +941,7 @@\n-        \/**\n-         * keep the count of lambda expression defined in given context (used to\n-         * generate unambiguous names for serializable lambdas)\n-         *\/\n-        private class SyntheticMethodNameCounter {\n-            private Map<String, Integer> map = new HashMap<>();\n-            int getIndex(StringBuilder buf) {\n-                String temp = buf.toString();\n-                Integer count = map.get(temp);\n-                if (count == null) {\n-                    count = 0;\n-                }\n-                ++count;\n-                map.put(temp, count);\n-                return count;\n+    void dumpStats(JCFunctionalExpression tree, boolean needsAltMetafactory, Symbol sym) {\n+        if (dumpLambdaToMethodStats) {\n+            if (tree instanceof JCLambda lambda) {\n+                log.note(tree, diags.noteKey(lambda.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\",\n+                        needsAltMetafactory, sym));\n+            } else if (tree instanceof JCMemberReference) {\n+                log.note(tree, Notes.MrefStat(needsAltMetafactory, null));\n@@ -953,2 +950,1 @@\n-        private SyntheticMethodNameCounter syntheticMethodNameCounts =\n-                new SyntheticMethodNameCounter();\n+    }\n@@ -956,1 +952,6 @@\n-        private Map<Symbol, JCClassDecl> localClassDefs;\n+    \/**\n+     * This class retains all the useful information about a lambda expression,\n+     * and acts as a translation map that is used by the main translation routines\n+     * in order to adjust references to captured locals\/members, etc.\n+     *\/\n+    class LambdaTranslationContext {\n@@ -958,5 +959,2 @@\n-        \/**\n-         * maps for fake clinit symbols to be used as owners of lambda occurring in\n-         * a static var init context\n-         *\/\n-        private Map<ClassSymbol, Symbol> clinits = new HashMap<>();\n+        \/** the underlying (untranslated) tree *\/\n+        final JCFunctionalExpression tree;\n@@ -964,5 +962,2 @@\n-        private JCClassDecl analyzeAndPreprocessClass(JCClassDecl tree) {\n-            frameStack = List.nil();\n-            localClassDefs = new HashMap<>();\n-            return translate(tree);\n-        }\n+        \/** a translation map from source symbols to translated symbols *\/\n+        final Map<VarSymbol, VarSymbol> lambdaProxies = new HashMap<>();\n@@ -970,13 +965,2 @@\n-        @Override\n-        public void visitBlock(JCBlock tree) {\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                if (frameStack.nonEmpty() && frameStack.head.tree.hasTag(CLASSDEF)) {\n-                    frameStack = frameStack.prepend(new Frame(tree));\n-                }\n-                super.visitBlock(tree);\n-            }\n-            finally {\n-                frameStack = prevStack;\n-            }\n-        }\n+        \/** the list of symbols captured by this lambda expression *\/\n+        final List<VarSymbol> capturedVars;\n@@ -984,30 +968,2 @@\n-        @Override\n-        public void visitClassDef(JCClassDecl tree) {\n-            List<Frame> prevStack = frameStack;\n-            int prevLambdaCount = lambdaCount;\n-            SyntheticMethodNameCounter prevSyntheticMethodNameCounts =\n-                    syntheticMethodNameCounts;\n-            Map<ClassSymbol, Symbol> prevClinits = clinits;\n-            DiagnosticSource prevSource = log.currentSource();\n-            try {\n-                log.useSource(tree.sym.sourcefile);\n-                lambdaCount = 0;\n-                syntheticMethodNameCounts = new SyntheticMethodNameCounter();\n-                prevClinits = new HashMap<>();\n-                if (tree.sym.owner.kind == MTH) {\n-                    localClassDefs.put(tree.sym, tree);\n-                }\n-                if (directlyEnclosingLambda() != null) {\n-                    tree.sym.owner = owner();\n-                }\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                super.visitClassDef(tree);\n-            }\n-            finally {\n-                log.useSource(prevSource.getFile());\n-                frameStack = prevStack;\n-                lambdaCount = prevLambdaCount;\n-                syntheticMethodNameCounts = prevSyntheticMethodNameCounts;\n-                clinits = prevClinits;\n-            }\n-        }\n+        \/** the synthetic symbol for the method hoisting the translated lambda *\/\n+        final MethodSymbol translatedSym;\n@@ -1015,33 +971,13 @@\n-        @Override\n-        public void visitIdent(JCIdent tree) {\n-            if (context() != null && lambdaIdentSymbolFilter(tree.sym)) {\n-                if (tree.sym.kind == VAR &&\n-                        tree.sym.owner.kind == MTH &&\n-                        tree.type.constValue() == null) {\n-                    TranslationContext<?> localContext = context();\n-                    while (localContext != null) {\n-                        if (localContext.tree.getTag() == LAMBDA) {\n-                            JCTree block = capturedDecl(localContext.depth, tree.sym);\n-                            if (block == null) break;\n-                            ((LambdaTranslationContext)localContext)\n-                                    .addSymbol(tree.sym, CAPTURED_VAR);\n-                        }\n-                        localContext = localContext.prev;\n-                    }\n-                } else if (tree.sym.owner.kind == TYP) {\n-                    TranslationContext<?> localContext = context();\n-                    while (localContext != null  && !localContext.owner.isStatic()) {\n-                        if (localContext.tree.hasTag(LAMBDA)) {\n-                            JCTree block = capturedDecl(localContext.depth, tree.sym);\n-                            if (block == null) break;\n-                            switch (block.getTag()) {\n-                                case CLASSDEF:\n-                                    JCClassDecl cdecl = (JCClassDecl)block;\n-                                    ((LambdaTranslationContext)localContext)\n-                                            .addSymbol(cdecl.sym, CAPTURED_THIS);\n-                                    break;\n-                                default:\n-                                    Assert.error(\"bad block kind\");\n-                            }\n-                        }\n-                        localContext = localContext.prev;\n+        \/** the list of parameter declarations of the translated lambda method *\/\n+        final List<JCVariableDecl> syntheticParams;\n+\n+        LambdaTranslationContext(JCLambda tree) {\n+            this.tree = tree;\n+            \/\/ This symbol will be filled-in in complete\n+            Symbol owner = tree.owner;\n+            if (owner.kind == MTH) {\n+                final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);\n+                this.translatedSym = new MethodSymbol(0, null, null, owner.enclClass()) {\n+                    @Override\n+                    public MethodSymbol originalEnclosingMethod() {\n+                        return originalOwner;\n@@ -1049,1 +985,3 @@\n-                }\n+                };\n+            } else {\n+                this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());\n@@ -1051,24 +989,8 @@\n-            super.visitIdent(tree);\n-        }\n-\n-        @Override\n-        public void visitLambda(JCLambda tree) {\n-            analyzeLambda(tree, tree.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\");\n-        }\n-\n-        private LambdaTranslationContext analyzeLambda(JCLambda tree, String statKey) {\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                LambdaTranslationContext context = new LambdaTranslationContext(tree);\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                for (JCVariableDecl param : tree.params) {\n-                    context.addSymbol(param.sym, PARAM);\n-                    frameStack.head.addLocal(param.sym);\n-                }\n-                contextMap.put(tree, context);\n-                super.visitLambda(tree);\n-                context.complete();\n-                if (dumpLambdaToMethodStats) {\n-                    log.note(tree, diags.noteKey(statKey, context.needsAltMetafactory(), context.translatedSym));\n-                }\n-                return context;\n+            ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+            ListBuffer<VarSymbol> parameterSymbols = new ListBuffer<>();\n+            LambdaCaptureScanner captureScanner = new LambdaCaptureScanner(tree);\n+            capturedVars = captureScanner.analyzeCaptures();\n+            for (VarSymbol captured : capturedVars) {\n+                VarSymbol trans = addSymbol(captured, LambdaSymbolKind.CAPTURED_VAR);\n+                params.append(make.VarDef(trans, null));\n+                parameterSymbols.add(trans);\n@@ -1076,2 +998,4 @@\n-            finally {\n-                frameStack = prevStack;\n+            for (JCVariableDecl param : tree.params) {\n+                VarSymbol trans = addSymbol(param.sym, LambdaSymbolKind.PARAM);\n+                params.append(make.VarDef(trans, null));\n+                parameterSymbols.add(trans);\n@@ -1079,0 +1003,3 @@\n+            syntheticParams = params.toList();\n+            completeLambdaMethodSymbol(owner, captureScanner.capturesThis);\n+            translatedSym.params = parameterSymbols.toList();\n@@ -1081,10 +1008,27 @@\n-        @Override\n-        public void visitMethodDef(JCMethodDecl tree) {\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                super.visitMethodDef(tree);\n-            }\n-            finally {\n-                frameStack = prevStack;\n-            }\n+        void completeLambdaMethodSymbol(Symbol owner, boolean thisReferenced) {\n+            boolean inInterface = owner.enclClass().isInterface();\n+\n+            \/\/ Compute and set the lambda name\n+            Name name = isSerializable(tree)\n+                    ? serializedLambdaName(owner)\n+                    : lambdaName(owner);\n+\n+            \/\/prepend synthetic args to translated lambda method signature\n+            Type type = types.createMethodTypeWithParameters(\n+                    generatedLambdaSig(),\n+                    TreeInfo.types(syntheticParams));\n+\n+            \/\/ If instance access isn't needed, make it static.\n+            \/\/ Interface instance methods must be default methods.\n+            \/\/ Lambda methods are private synthetic.\n+            \/\/ Inherit ACC_STRICT from the enclosing method, or, for clinit,\n+            \/\/ from the class.\n+            long flags = SYNTHETIC | LAMBDA_METHOD |\n+                    owner.flags_field & STRICTFP |\n+                    owner.owner.flags_field & STRICTFP |\n+                    PRIVATE |\n+                    (thisReferenced? (inInterface? DEFAULT : 0) : STATIC);\n+\n+            translatedSym.type = type;\n+            translatedSym.name = name;\n+            translatedSym.flags_field = flags;\n@@ -1094,8 +1038,2 @@\n-         * Method references to local class constructors, may, if the local\n-         * class references local variables, have implicit constructor\n-         * parameters added in Lower; As a result, the invokedynamic bootstrap\n-         * information added in the LambdaToMethod pass will have the wrong\n-         * signature. Hooks between Lower and LambdaToMethod have been added to\n-         * handle normal \"new\" in this case. This visitor converts potentially\n-         * affected method references into a lambda containing a normal\n-         * expression.\n+         * For a serializable lambda, generate a disambiguating string\n+         * which maximizes stability across deserialization.\n@@ -1103,1 +1041,1 @@\n-         * @param tree\n+         * @return String to differentiate synthetic lambda method names\n@@ -1105,7 +1043,14 @@\n-        @Override\n-        public void visitReference(JCMemberReference tree) {\n-            ReferenceTranslationContext rcontext = new ReferenceTranslationContext(tree);\n-            contextMap.put(tree, rcontext);\n-            super.visitReference(tree);\n-            if (dumpLambdaToMethodStats) {\n-                log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n+        private String serializedLambdaDisambiguation(Symbol owner) {\n+            StringBuilder buf = new StringBuilder();\n+            \/\/ Append the enclosing method signature to differentiate\n+            \/\/ overloaded enclosing methods.  For lambdas enclosed in\n+            \/\/ lambdas, the generated lambda method will not have type yet,\n+            \/\/ but the enclosing method's name will have been generated\n+            \/\/ with this same method, so it will be unique and never be\n+            \/\/ overloaded.\n+            Assert.check(\n+                    owner.type != null ||\n+                            lambdaContext != null);\n+            if (owner.type != null) {\n+                buf.append(typeSig(owner.type, true));\n+                buf.append(\":\");\n@@ -1113,1 +1058,0 @@\n-        }\n@@ -1115,19 +1059,3 @@\n-        @Override\n-        public void visitSelect(JCFieldAccess tree) {\n-            if (context() != null && tree.sym.kind == VAR &&\n-                        (tree.sym.name == names._this ||\n-                         tree.sym.name == names._super)) {\n-                \/\/ A select of this or super means, if we are in a lambda,\n-                \/\/ we much have an instance context\n-                TranslationContext<?> localContext = context();\n-                while (localContext != null  && !localContext.owner.isStatic()) {\n-                    if (localContext.tree.hasTag(LAMBDA)) {\n-                        JCClassDecl clazz = (JCClassDecl)capturedDecl(localContext.depth, tree.sym);\n-                        if (clazz == null) break;\n-                        ((LambdaTranslationContext)localContext).addSymbol(clazz.sym, CAPTURED_THIS);\n-                    }\n-                    localContext = localContext.prev;\n-                }\n-            }\n-            super.visitSelect(tree);\n-        }\n+            \/\/ Add target type info\n+            buf.append(types.findDescriptorSymbol(tree.type.tsym).owner.flatName());\n+            buf.append(\" \");\n@@ -1135,17 +1063,4 @@\n-        @Override\n-        public void visitVarDef(JCVariableDecl tree) {\n-            TranslationContext<?> context = context();\n-            if (context != null && context instanceof LambdaTranslationContext lambdaContext) {\n-                for (Frame frame : frameStack) {\n-                    if (frame.tree.hasTag(VARDEF)) {\n-                        \/\/skip variable frames inside a lambda:\n-                        continue;\n-                    } else if (frame.tree.hasTag(LAMBDA)) {\n-                        lambdaContext.addSymbol(tree.sym, LOCAL_VAR);\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                \/\/ Check for type variables (including as type arguments).\n-                \/\/ If they occur within class nested in a lambda, mark for erasure\n-                Type type = tree.sym.asType();\n+            \/\/ Add variable assigned to\n+            if (pendingVar != null) {\n+                buf.append(pendingVar.flatName());\n+                buf.append(\"=\");\n@@ -1153,5 +1068,7 @@\n-\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                if (tree.sym.owner.kind == MTH) {\n-                    frameStack.head.addLocal(tree.sym);\n+            \/\/add captured locals info: type, name, order\n+            for (Symbol fv : capturedVars) {\n+                if (fv != owner) {\n+                    buf.append(typeSig(fv.type, true));\n+                    buf.append(\" \");\n+                    buf.append(fv.flatName());\n+                    buf.append(\",\");\n@@ -1159,5 +1076,0 @@\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                super.visitVarDef(tree);\n-            }\n-            finally {\n-                frameStack = prevStack;\n@@ -1165,0 +1077,2 @@\n+\n+            return buf.toString();\n@@ -1168,2 +1082,3 @@\n-         * Return a valid owner given the current declaration stack\n-         * (required to skip synthetic lambda symbols)\n+         * For a non-serializable lambda, generate a simple method.\n+         *\n+         * @return Name to use for the synthetic lambda method name\n@@ -1171,2 +1086,7 @@\n-        private Symbol owner() {\n-            return owner(false);\n+        private Name lambdaName(Symbol owner) {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(names.lambda);\n+            buf.append(syntheticMethodNameComponent(owner));\n+            buf.append(\"$\");\n+            buf.append(kInfo.syntheticNameIndex(buf, 0));\n+            return names.fromString(buf.toString());\n@@ -1175,61 +1095,11 @@\n-        @SuppressWarnings(\"fallthrough\")\n-        private Symbol owner(boolean skipLambda) {\n-            List<Frame> frameStack2 = frameStack;\n-            while (frameStack2.nonEmpty()) {\n-                switch (frameStack2.head.tree.getTag()) {\n-                    case VARDEF:\n-                        if (((JCVariableDecl)frameStack2.head.tree).sym.isDirectlyOrIndirectlyLocal()) {\n-                            frameStack2 = frameStack2.tail;\n-                            break;\n-                        }\n-                        JCClassDecl cdecl = (JCClassDecl)frameStack2.tail.head.tree;\n-                        return initSym(cdecl.sym,\n-                                ((JCVariableDecl)frameStack2.head.tree).sym.flags() & STATIC);\n-                    case BLOCK:\n-                        JCClassDecl cdecl2 = (JCClassDecl)frameStack2.tail.head.tree;\n-                        return initSym(cdecl2.sym,\n-                                ((JCBlock)frameStack2.head.tree).flags & STATIC);\n-                    case CLASSDEF:\n-                        return ((JCClassDecl)frameStack2.head.tree).sym;\n-                    case METHODDEF:\n-                        return ((JCMethodDecl)frameStack2.head.tree).sym;\n-                    case LAMBDA:\n-                        if (!skipLambda)\n-                            return ((LambdaTranslationContext)contextMap\n-                                    .get(frameStack2.head.tree)).translatedSym;\n-                    default:\n-                        frameStack2 = frameStack2.tail;\n-                }\n-            }\n-            Assert.error();\n-            return null;\n-        }\n-\n-        private Symbol initSym(ClassSymbol csym, long flags) {\n-            boolean isStatic = (flags & STATIC) != 0;\n-            if (isStatic) {\n-                \/* static clinits are generated in Gen, so we need to use a fake\n-                 * one. Attr creates a fake clinit method while attributing\n-                 * lambda expressions used as initializers of static fields, so\n-                 * let's use that one.\n-                 *\/\n-                MethodSymbol clinit = attr.removeClinit(csym);\n-                if (clinit != null) {\n-                    clinits.put(csym, clinit);\n-                    return clinit;\n-                }\n-\n-                \/* if no clinit is found at Attr, then let's try at clinits.\n-                 *\/\n-                clinit = (MethodSymbol)clinits.get(csym);\n-                if (clinit == null) {\n-                    \/* no luck, let's create a new one\n-                     *\/\n-                    clinit = makePrivateSyntheticMethod(STATIC,\n-                            names.clinit,\n-                            new MethodType(List.nil(), syms.voidType,\n-                                List.nil(), syms.methodClass),\n-                            csym);\n-                    clinits.put(csym, clinit);\n-                }\n-                return clinit;\n+        \/**\n+         * @return Method name in a form that can be folded into a\n+         * component of a synthetic method name\n+         *\/\n+        String syntheticMethodNameComponent(Symbol owner) {\n+            long ownerFlags = owner.flags();\n+            if ((ownerFlags & BLOCK) != 0) {\n+                return (ownerFlags & STATIC) != 0 ?\n+                        \"static\" : \"new\";\n+            } else if (owner.isConstructor()) {\n+                return \"new\";\n@@ -1237,4 +1107,1 @@\n-                \/\/get the first constructor and treat it as the instance init sym\n-                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n-                    return s;\n-                }\n+                return owner.name.toString();\n@@ -1242,44 +1109,0 @@\n-            Assert.error(\"init not found\");\n-            return null;\n-        }\n-\n-        private JCTree directlyEnclosingLambda() {\n-            if (frameStack.isEmpty()) {\n-                return null;\n-            }\n-            List<Frame> frameStack2 = frameStack;\n-            while (frameStack2.nonEmpty()) {\n-                switch (frameStack2.head.tree.getTag()) {\n-                    case CLASSDEF:\n-                    case METHODDEF:\n-                        return null;\n-                    case LAMBDA:\n-                        return frameStack2.head.tree;\n-                    default:\n-                        frameStack2 = frameStack2.tail;\n-                }\n-            }\n-            Assert.error();\n-            return null;\n-        }\n-\n-        private boolean inClassWithinLambda() {\n-            if (frameStack.isEmpty()) {\n-                return false;\n-            }\n-            List<Frame> frameStack2 = frameStack;\n-            boolean classFound = false;\n-            while (frameStack2.nonEmpty()) {\n-                switch (frameStack2.head.tree.getTag()) {\n-                    case LAMBDA:\n-                        return classFound;\n-                    case CLASSDEF:\n-                        classFound = true;\n-                        frameStack2 = frameStack2.tail;\n-                        break;\n-                    default:\n-                        frameStack2 = frameStack2.tail;\n-                }\n-            }\n-            \/\/ No lambda\n-            return false;\n@@ -1289,3 +1112,4 @@\n-         * Return the declaration corresponding to a symbol in the enclosing\n-         * scope; the depth parameter is used to filter out symbols defined\n-         * in nested scopes (which do not need to undergo capture).\n+         * For a serializable lambda, generate a method name which maximizes\n+         * name stability across deserialization.\n+         *\n+         * @return Name to use for the synthetic lambda method name\n@@ -1293,41 +1117,17 @@\n-        private JCTree capturedDecl(int depth, Symbol sym) {\n-            Assert.check(sym.kind != TYP);\n-            int currentDepth = frameStack.size() - 1;\n-            for (Frame block : frameStack) {\n-                switch (block.tree.getTag()) {\n-                    case CLASSDEF:\n-                        ClassSymbol clazz = ((JCClassDecl)block.tree).sym;\n-                        if (clazz.isSubClass(sym.enclClass(), types)) {\n-                            return currentDepth > depth ? null : block.tree;\n-                        }\n-                        break;\n-                    case VARDEF:\n-                        if ((((JCVariableDecl)block.tree).sym == sym &&\n-                                sym.owner.kind == MTH) || \/\/only locals are captured\n-                            (block.locals != null && block.locals.contains(sym))) {\n-                            return currentDepth > depth ? null : block.tree;\n-                        }\n-                        break;\n-                    case BLOCK:\n-                    case METHODDEF:\n-                    case LAMBDA:\n-                        if (block.locals != null && block.locals.contains(sym)) {\n-                            return currentDepth > depth ? null : block.tree;\n-                        }\n-                        break;\n-                    default:\n-                        Assert.error(\"bad decl kind \" + block.tree.getTag());\n-                }\n-                currentDepth--;\n-            }\n-            return null;\n-        }\n-\n-        private TranslationContext<?> context() {\n-            for (Frame frame : frameStack) {\n-                TranslationContext<?> context = contextMap.get(frame.tree);\n-                if (context != null) {\n-                    return context;\n-                }\n-            }\n-            return null;\n+        private Name serializedLambdaName(Symbol owner) {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(names.lambda);\n+            \/\/ Append the name of the method enclosing the lambda.\n+            buf.append(syntheticMethodNameComponent(owner));\n+            buf.append('$');\n+            \/\/ Append a hash of the disambiguating string : enclosing method\n+            \/\/ signature, etc.\n+            String disam = serializedLambdaDisambiguation(owner);\n+            buf.append(Integer.toHexString(disam.hashCode()));\n+            buf.append('$');\n+            \/\/ The above appended name components may not be unique, append\n+            \/\/ a count based on the above name components.\n+            buf.append(kInfo.syntheticNameIndex(buf, 1));\n+            String result = buf.toString();\n+            \/\/System.err.printf(\"serializedLambdaName: %s -- %s\\n\", result, disam);\n+            return names.fromString(result);\n@@ -1337,2 +1137,2 @@\n-         *  This is used to filter out those identifiers that needs to be adjusted\n-         *  when translating away lambda expressions\n+         * Translate a symbol of a given kind into something suitable for the\n+         * synthetic lambda body\n@@ -1340,12 +1140,29 @@\n-        private boolean lambdaIdentSymbolFilter(Symbol sym) {\n-            return (sym.kind == VAR || sym.kind == MTH)\n-                    && !sym.isStatic()\n-                    && sym.name != names.init;\n-        }\n-\n-        private class Frame {\n-            final JCTree tree;\n-            List<Symbol> locals;\n-\n-            public Frame(JCTree tree) {\n-                this.tree = tree;\n+        VarSymbol translate(final VarSymbol sym, LambdaSymbolKind skind) {\n+            VarSymbol ret;\n+            boolean propagateAnnos = true;\n+            switch (skind) {\n+                case CAPTURED_VAR:\n+                    Name name = (sym.flags() & LOCAL_CAPTURE_FIELD) != 0 ?\n+                            sym.baseSymbol().name : sym.name;\n+                    ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym);\n+                    propagateAnnos = false;\n+                    break;\n+                case LOCAL_VAR:\n+                    ret = new VarSymbol(sym.flags() & FINAL, sym.name, sym.type, translatedSym);\n+                    ret.pos = sym.pos;\n+                    \/\/ If sym.data == ElementKind.EXCEPTION_PARAMETER,\n+                    \/\/ set ret.data = ElementKind.EXCEPTION_PARAMETER too.\n+                    \/\/ Because method com.sun.tools.javac.jvm.Code.fillExceptionParameterPositions and\n+                    \/\/ com.sun.tools.javac.jvm.Code.fillLocalVarPosition would use it.\n+                    \/\/ See JDK-8257740 for more information.\n+                    if (sym.isExceptionParameter()) {\n+                        ret.setData(ElementKind.EXCEPTION_PARAMETER);\n+                    }\n+                    break;\n+                case PARAM:\n+                    ret = new VarSymbol((sym.flags() & FINAL) | PARAMETER, sym.name, types.erasure(sym.type), translatedSym);\n+                    ret.pos = sym.pos;\n+                    break;\n+                default:\n+                    Assert.error(skind.name());\n+                    throw new AssertionError();\n@@ -1353,6 +1170,3 @@\n-\n-            void addLocal(Symbol sym) {\n-                if (locals == null) {\n-                    locals = List.nil();\n-                }\n-                locals = locals.prepend(sym);\n+            if (ret != sym && propagateAnnos) {\n+                ret.setDeclarationAttributes(sym.getRawAttributes());\n+                ret.setTypeAttributes(sym.getRawTypeAttributes());\n@@ -1360,0 +1174,1 @@\n+            return ret;\n@@ -1362,37 +1177,3 @@\n-        \/**\n-         * This class is used to store important information regarding translation of\n-         * lambda expression\/method references (see subclasses).\n-         *\/\n-        abstract class TranslationContext<T extends JCFunctionalExpression> {\n-\n-            \/** the underlying (untranslated) tree *\/\n-            final T tree;\n-\n-            \/** points to the adjusted enclosing scope in which this lambda\/mref expression occurs *\/\n-            final Symbol owner;\n-\n-            \/** the depth of this lambda expression in the frame stack *\/\n-            final int depth;\n-\n-            \/** the enclosing translation context (set for nested lambdas\/mref) *\/\n-            final TranslationContext<?> prev;\n-\n-            \/** list of methods to be bridged by the meta-factory *\/\n-            final List<Symbol> bridges;\n-\n-            TranslationContext(T tree) {\n-                this.tree = tree;\n-                this.owner = owner(true);\n-                this.depth = frameStack.size() - 1;\n-                this.prev = context();\n-                ClassSymbol csym =\n-                        types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);\n-                this.bridges = types.functionalInterfaceBridges(csym);\n-            }\n-\n-            \/** does this functional expression need to be created using alternate metafactory? *\/\n-            boolean needsAltMetafactory() {\n-                return tree.target.isIntersection() ||\n-                        isSerializable() ||\n-                        bridges.length() > 1;\n-            }\n+        VarSymbol addLocal(VarSymbol sym) {\n+            return addSymbol(sym, LambdaSymbolKind.LOCAL_VAR);\n+        }\n@@ -1400,7 +1181,3 @@\n-            \/** does this functional expression require serialization support? *\/\n-            boolean isSerializable() {\n-                if (forceSerializable) {\n-                    return true;\n-                }\n-                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n-            }\n+        private VarSymbol addSymbol(VarSymbol sym, LambdaSymbolKind skind) {\n+            return lambdaProxies.computeIfAbsent(sym, s -> translate(s, skind));\n+        }\n@@ -1408,7 +1185,6 @@\n-            \/**\n-             * @return Name of the enclosing method to be folded into synthetic\n-             * method name\n-             *\/\n-            String enclosingMethodName() {\n-                return syntheticMethodNameComponent(owner.name);\n-            }\n+        JCTree translate(JCIdent lambdaIdent) {\n+            Symbol tSym = lambdaProxies.get(lambdaIdent.sym);\n+            return tSym != null ?\n+                    make.Ident(tSym).setType(lambdaIdent.type) :\n+                    null;\n+        }\n@@ -1416,16 +1192,2 @@\n-            \/**\n-             * @return Method name in a form that can be folded into a\n-             * component of a synthetic method name\n-             *\/\n-            String syntheticMethodNameComponent(Name name) {\n-                if (name == null) {\n-                    return \"null\";\n-                }\n-                String methodName = name.toString();\n-                if (methodName.equals(\"<clinit>\")) {\n-                    methodName = \"static\";\n-                } else if (methodName.equals(\"<init>\")) {\n-                    methodName = \"new\";\n-                }\n-                return methodName;\n-            }\n+        Type generatedLambdaSig() {\n+            return types.erasure(tree.getDescriptorType(types));\n@@ -1435,4 +1197,2 @@\n-         * This class retains all the useful information about a lambda expression;\n-         * the contents of this class are filled by the LambdaAnalyzer visitor,\n-         * and the used by the main translation routines in order to adjust references\n-         * to captured locals\/members, etc.\n+         * Compute the set of local variables captured by this lambda expression.\n+         * Also determines whether this lambda expression captures the enclosing 'this'.\n@@ -1440,94 +1200,3 @@\n-        class LambdaTranslationContext extends TranslationContext<JCLambda> {\n-\n-            \/** variable in the enclosing context to which this lambda is assigned *\/\n-            final Symbol self;\n-\n-            \/** variable in the enclosing context to which this lambda is assigned *\/\n-            final Symbol assignedTo;\n-\n-            Map<LambdaSymbolKind, Map<Symbol, Symbol>> translatedSymbols;\n-\n-            \/** the synthetic symbol for the method hoisting the translated lambda *\/\n-            MethodSymbol translatedSym;\n-\n-            List<JCVariableDecl> syntheticParams;\n-\n-            LambdaTranslationContext(JCLambda tree) {\n-                super(tree);\n-                Frame frame = frameStack.head;\n-                switch (frame.tree.getTag()) {\n-                    case VARDEF:\n-                        assignedTo = self = ((JCVariableDecl) frame.tree).sym;\n-                        break;\n-                    case ASSIGN:\n-                        self = null;\n-                        assignedTo = TreeInfo.symbol(((JCAssign) frame.tree).getVariable());\n-                        break;\n-                    default:\n-                        assignedTo = self = null;\n-                        break;\n-                 }\n-\n-                \/\/ This symbol will be filled-in in complete\n-                if (owner.kind == MTH) {\n-                    final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);\n-                    this.translatedSym = new MethodSymbol(SYNTHETIC | PRIVATE, null, null, owner.enclClass()) {\n-                        @Override\n-                        public MethodSymbol originalEnclosingMethod() {\n-                            return originalOwner;\n-                        }\n-                    };\n-                } else {\n-                    this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());\n-                }\n-                translatedSymbols = new EnumMap<>(LambdaSymbolKind.class);\n-\n-                translatedSymbols.put(PARAM, new LinkedHashMap<>());\n-                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<>());\n-                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<>());\n-                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<>());\n-            }\n-\n-             \/**\n-             * For a serializable lambda, generate a disambiguating string\n-             * which maximizes stability across deserialization.\n-             *\n-             * @return String to differentiate synthetic lambda method names\n-             *\/\n-            private String serializedLambdaDisambiguation() {\n-                StringBuilder buf = new StringBuilder();\n-                \/\/ Append the enclosing method signature to differentiate\n-                \/\/ overloaded enclosing methods.  For lambdas enclosed in\n-                \/\/ lambdas, the generated lambda method will not have type yet,\n-                \/\/ but the enclosing method's name will have been generated\n-                \/\/ with this same method, so it will be unique and never be\n-                \/\/ overloaded.\n-                Assert.check(\n-                        owner.type != null ||\n-                        directlyEnclosingLambda() != null);\n-                if (owner.type != null) {\n-                    buf.append(typeSig(owner.type, true));\n-                    buf.append(\":\");\n-                }\n-\n-                \/\/ Add target type info\n-                buf.append(types.findDescriptorSymbol(tree.type.tsym).owner.flatName());\n-                buf.append(\" \");\n-\n-                \/\/ Add variable assigned to\n-                if (assignedTo != null) {\n-                    buf.append(assignedTo.flatName());\n-                    buf.append(\"=\");\n-                }\n-                \/\/add captured locals info: type, name, order\n-                for (Symbol fv : getSymbolMap(CAPTURED_VAR).keySet()) {\n-                    if (fv != self) {\n-                        buf.append(typeSig(fv.type, true));\n-                        buf.append(\" \");\n-                        buf.append(fv.flatName());\n-                        buf.append(\",\");\n-                    }\n-                }\n-\n-                return buf.toString();\n-            }\n+        class LambdaCaptureScanner extends CaptureScanner {\n+            boolean capturesThis;\n+            Set<ClassSymbol> seenClasses = new HashSet<>();\n@@ -1535,7 +1204,2 @@\n-            \/**\n-             * For a non-serializable lambda, generate a simple method.\n-             *\n-             * @return Name to use for the synthetic lambda method name\n-             *\/\n-            private Name lambdaName() {\n-                return names.lambda.append(names.fromString(enclosingMethodName() + \"$\" + lambdaCount++));\n+            LambdaCaptureScanner(JCLambda ownerTree) {\n+                super(ownerTree);\n@@ -1544,92 +1208,4 @@\n-            \/**\n-             * For a serializable lambda, generate a method name which maximizes\n-             * name stability across deserialization.\n-             *\n-             * @return Name to use for the synthetic lambda method name\n-             *\/\n-            private Name serializedLambdaName() {\n-                StringBuilder buf = new StringBuilder();\n-                buf.append(names.lambda);\n-                \/\/ Append the name of the method enclosing the lambda.\n-                buf.append(enclosingMethodName());\n-                buf.append('$');\n-                \/\/ Append a hash of the disambiguating string : enclosing method\n-                \/\/ signature, etc.\n-                String disam = serializedLambdaDisambiguation();\n-                buf.append(Integer.toHexString(disam.hashCode()));\n-                buf.append('$');\n-                \/\/ The above appended name components may not be unique, append\n-                \/\/ a count based on the above name components.\n-                buf.append(syntheticMethodNameCounts.getIndex(buf));\n-                String result = buf.toString();\n-                \/\/System.err.printf(\"serializedLambdaName: %s -- %s\\n\", result, disam);\n-                return names.fromString(result);\n-            }\n-\n-            \/**\n-             * Translate a symbol of a given kind into something suitable for the\n-             * synthetic lambda body\n-             *\/\n-            Symbol translate(final Symbol sym, LambdaSymbolKind skind) {\n-                Symbol ret;\n-                switch (skind) {\n-                    case CAPTURED_THIS:\n-                        ret = sym;  \/\/ self represented\n-                        break;\n-                    case CAPTURED_VAR:\n-                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original captured symbol\n-                                return sym;\n-                            }\n-                        };\n-                        break;\n-                    case LOCAL_VAR:\n-                        ret = new VarSymbol(sym.flags() & FINAL, sym.name, sym.type, translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original symbol\n-                                return sym;\n-                            }\n-                        };\n-                        ((VarSymbol) ret).pos = ((VarSymbol) sym).pos;\n-                        \/\/ If sym.data == ElementKind.EXCEPTION_PARAMETER,\n-                        \/\/ set ret.data = ElementKind.EXCEPTION_PARAMETER too.\n-                        \/\/ Because method com.sun.tools.javac.jvm.Code.fillExceptionParameterPositions and\n-                        \/\/ com.sun.tools.javac.jvm.Code.fillLocalVarPosition would use it.\n-                        \/\/ See JDK-8257740 for more information.\n-                        if (((VarSymbol) sym).isExceptionParameter()) {\n-                            ((VarSymbol) ret).setData(ElementKind.EXCEPTION_PARAMETER);\n-                        }\n-                        break;\n-                    case PARAM:\n-                        ret = new VarSymbol((sym.flags() & FINAL) | PARAMETER, sym.name, types.erasure(sym.type), translatedSym);\n-                        ((VarSymbol) ret).pos = ((VarSymbol) sym).pos;\n-                        \/\/ Set ret.data. Same as case LOCAL_VAR above.\n-                        if (((VarSymbol) sym).isExceptionParameter()) {\n-                            ((VarSymbol) ret).setData(ElementKind.EXCEPTION_PARAMETER);\n-                        }\n-                        break;\n-                    default:\n-                        Assert.error(skind.name());\n-                        throw new AssertionError();\n-                }\n-                if (ret != sym && skind.propagateAnnotations()) {\n-                    ret.setDeclarationAttributes(sym.getRawAttributes());\n-                    ret.setTypeAttributes(sym.getRawTypeAttributes());\n-                }\n-                return ret;\n-            }\n-\n-            void addSymbol(Symbol sym, LambdaSymbolKind skind) {\n-                Map<Symbol, Symbol> transMap = getSymbolMap(skind);\n-                if (!transMap.containsKey(sym)) {\n-                    transMap.put(sym, translate(sym, skind));\n-                }\n-            }\n-\n-            Map<Symbol, Symbol> getSymbolMap(LambdaSymbolKind skind) {\n-                Map<Symbol, Symbol> m = translatedSymbols.get(skind);\n-                Assert.checkNonNull(m);\n-                return m;\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                seenClasses.add(tree.sym);\n+                super.visitClassDef(tree);\n@@ -1638,11 +1214,12 @@\n-            JCTree translate(JCIdent lambdaIdent) {\n-                for (LambdaSymbolKind kind : LambdaSymbolKind.values()) {\n-                    Map<Symbol, Symbol> m = getSymbolMap(kind);\n-                    switch(kind) {\n-                        default:\n-                            if (m.containsKey(lambdaIdent.sym)) {\n-                                Symbol tSym = m.get(lambdaIdent.sym);\n-                                JCTree t = make.Ident(tSym).setType(lambdaIdent.type);\n-                                return t;\n-                            }\n-                            break;\n+            @Override\n+            public void visitIdent(JCIdent tree) {\n+                if (!tree.sym.isStatic() &&\n+                        tree.sym.owner.kind == TYP &&\n+                        (tree.sym.kind == VAR || tree.sym.kind == MTH) &&\n+                        !seenClasses.contains(tree.sym.owner)) {\n+                    if ((tree.sym.flags() & LOCAL_CAPTURE_FIELD) != 0) {\n+                        \/\/ a local, captured by Lower - re-capture!\n+                        addFreeVar((VarSymbol) tree.sym);\n+                    } else {\n+                        \/\/ a reference to an enclosing field or method, we need to capture 'this'\n+                        capturesThis = true;\n@@ -1650,0 +1227,3 @@\n+                } else {\n+                    \/\/ might be a local capture\n+                    super.visitIdent(tree);\n@@ -1651,1 +1231,0 @@\n-                return null;\n@@ -1654,40 +1233,7 @@\n-            \/**\n-             * The translatedSym is not complete\/accurate until the analysis is\n-             * finished.  Once the analysis is finished, the translatedSym is\n-             * \"completed\" -- updated with type information, access modifiers,\n-             * and full parameter list.\n-             *\/\n-            void complete() {\n-                if (syntheticParams != null) {\n-                    return;\n-                }\n-                boolean inInterface = translatedSym.owner.isInterface();\n-                boolean thisReferenced = !getSymbolMap(CAPTURED_THIS).isEmpty();\n-\n-                \/\/ If instance access isn't needed, make it static.\n-                \/\/ Interface instance methods must be default methods.\n-                \/\/ Lambda methods are private synthetic.\n-                \/\/ Inherit ACC_STRICT from the enclosing method, or, for clinit,\n-                \/\/ from the class.\n-                translatedSym.flags_field = SYNTHETIC | LAMBDA_METHOD |\n-                        owner.flags_field & STRICTFP |\n-                        owner.owner.flags_field & STRICTFP |\n-                        PRIVATE |\n-                        (thisReferenced? (inInterface? DEFAULT : 0) : STATIC);\n-\n-                \/\/compute synthetic params\n-                ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-                ListBuffer<VarSymbol> parameterSymbols = new ListBuffer<>();\n-\n-                \/\/ The signature of the method is augmented with the following\n-                \/\/ synthetic parameters:\n-                \/\/\n-                \/\/ 1) reference to enclosing contexts captured by the lambda expression\n-                \/\/ 2) enclosing locals captured by the lambda expression\n-                for (Symbol thisSym : getSymbolMap(CAPTURED_VAR).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n-                }\n-                for (Symbol thisSym : getSymbolMap(PARAM).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                if (tree.sym.kind == VAR &&\n+                        (tree.sym.name == names._this ||\n+                                tree.sym.name == names._super) &&\n+                        !seenClasses.contains(tree.sym.type.tsym)) {\n+                    capturesThis = true;\n@@ -1695,13 +1241,1 @@\n-                syntheticParams = params.toList();\n-\n-                translatedSym.params = parameterSymbols.toList();\n-\n-                \/\/ Compute and set the lambda name\n-                translatedSym.name = isSerializable()\n-                        ? serializedLambdaName()\n-                        : lambdaName();\n-\n-                \/\/prepend synthetic args to translated lambda method signature\n-                translatedSym.type = types.createMethodTypeWithParameters(\n-                        generatedLambdaSig(),\n-                        TreeInfo.types(syntheticParams));\n+                super.visitSelect(tree);\n@@ -1710,2 +1244,3 @@\n-            Type generatedLambdaSig() {\n-                return types.erasure(tree.getDescriptorType(types));\n+            @Override\n+            public void visitAnnotation(JCAnnotation tree) {\n+                \/\/ do nothing (annotation values look like captured instance fields)\n@@ -1715,2 +1250,3 @@\n-        \/**\n-         * Simple subclass modelling the translation context of a method reference.\n+        \/*\n+         * These keys provide mappings for various translated lambda symbols\n+         * and the prevailing order must be maintained.\n@@ -1718,27 +1254,4 @@\n-        final class ReferenceTranslationContext extends TranslationContext<JCMemberReference> {\n-\n-            ReferenceTranslationContext(JCMemberReference tree) {\n-                super(tree);\n-            }\n-        }\n-    }\n-    \/\/ <\/editor-fold>\n-\n-    \/*\n-     * These keys provide mappings for various translated lambda symbols\n-     * and the prevailing order must be maintained.\n-     *\/\n-    enum LambdaSymbolKind {\n-        PARAM,          \/\/ original to translated lambda parameters\n-        LOCAL_VAR,      \/\/ original to translated lambda locals\n-        CAPTURED_VAR,   \/\/ variables in enclosing scope to translated synthetic parameters\n-        CAPTURED_THIS;  \/\/ class symbols to translated synthetic parameters (for captured member access)\n-\n-        boolean propagateAnnotations() {\n-            switch (this) {\n-                case CAPTURED_VAR:\n-                case CAPTURED_THIS:\n-                    return false;\n-                default:\n-                    return true;\n-           }\n+        enum LambdaSymbolKind {\n+            PARAM,          \/\/ original to translated lambda parameters\n+            LOCAL_VAR,      \/\/ original to translated lambda locals\n+            CAPTURED_VAR;   \/\/ variables in enclosing scope to translated synthetic parameters\n@@ -1794,1 +1307,1 @@\n-         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation()}.\n+         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation(Symbol)}}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":531,"deletions":1018,"binary":false,"changes":1549,"status":"modified"},{"patch":"@@ -270,4 +270,1 @@\n-     *  from a local class. There is only one case; all other cases simply\n-     *  traverse down the tree. This class doesn't deal with the specific\n-     *  of Lower - it's an abstract visitor that is meant to be reused in\n-     *  order to share the local variable capture logic.\n+     *  from a local class.\n@@ -275,1 +272,1 @@\n-    abstract class BasicFreeVarCollector extends TreeScanner {\n+    class FreeVarCollector extends CaptureScanner {\n@@ -277,4 +274,3 @@\n-        \/** Add all free variables of class c to fvs list\n-         *  unless they are already there.\n-         *\/\n-        abstract void addFreeVars(ClassSymbol c);\n+        FreeVarCollector(JCTree ownerTree) {\n+            super(ownerTree);\n+        }\n@@ -282,5 +278,7 @@\n-        \/** If tree refers to a variable in owner of local class, add it to\n-         *  free variables list.\n-         *\/\n-        public void visitIdent(JCIdent tree) {\n-            visitSymbol(tree.sym);\n+        void addFreeVars(ClassSymbol c) {\n+            List<VarSymbol> fvs = freevarCache.get(c);\n+            if (fvs != null) {\n+                for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {\n+                    addFreeVar(l.head);\n+                }\n+            }\n@@ -288,2 +286,0 @@\n-        \/\/ where\n-        abstract void visitSymbol(Symbol _sym);\n@@ -309,78 +305,0 @@\n-\n-        @Override\n-        public void visitYield(JCYield tree) {\n-            scan(tree.value);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Lower-specific subclass of {@code BasicFreeVarCollector}.\n-     *\/\n-    class FreeVarCollector extends BasicFreeVarCollector {\n-\n-        \/** The owner of the local class.\n-         *\/\n-        Symbol owner;\n-\n-        \/** The local class.\n-         *\/\n-        ClassSymbol clazz;\n-\n-        \/** The list of owner's variables accessed from within the local class,\n-         *  without any duplicates.\n-         *\/\n-        List<VarSymbol> fvs;\n-\n-        FreeVarCollector(ClassSymbol clazz) {\n-            this.clazz = clazz;\n-            this.owner = clazz.owner;\n-            this.fvs = List.nil();\n-        }\n-\n-        \/** Add free variable to fvs list unless it is already there.\n-         *\/\n-        private void addFreeVar(VarSymbol v) {\n-            for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail)\n-                if (l.head == v) return;\n-            fvs = fvs.prepend(v);\n-        }\n-\n-        @Override\n-        void addFreeVars(ClassSymbol c) {\n-            List<VarSymbol> fvs = freevarCache.get(c);\n-            if (fvs != null) {\n-                for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {\n-                    addFreeVar(l.head);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        void visitSymbol(Symbol _sym) {\n-            Symbol sym = _sym;\n-            if (sym.kind == VAR || sym.kind == MTH) {\n-                if (sym != null && sym.owner != owner)\n-                    sym = proxies.get(sym);\n-                if (sym != null && sym.owner == owner) {\n-                    VarSymbol v = (VarSymbol)sym;\n-                    if (v.getConstValue() == null) {\n-                        addFreeVar(v);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {\n-        if (!c.isDirectlyOrIndirectlyLocal()) {\n-            return null;\n-        }\n-        Symbol currentOwner = c.owner;\n-        while (currentOwner.owner.kind.matches(KindSelector.TYP) && currentOwner.isDirectlyOrIndirectlyLocal()) {\n-            currentOwner = currentOwner.owner;\n-        }\n-        if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) && c.isSubClass(currentOwner, types)) {\n-            return (ClassSymbol)currentOwner;\n-        }\n-        return null;\n@@ -398,16 +316,4 @@\n-        if (c.owner.kind.matches(KindSelector.VAL_MTH) && !c.isStatic()) {\n-            FreeVarCollector collector = new FreeVarCollector(c);\n-            collector.scan(classDef(c));\n-            fvs = collector.fvs;\n-            freevarCache.put(c, fvs);\n-            return fvs;\n-        } else {\n-            ClassSymbol owner = ownerToCopyFreeVarsFrom(c);\n-            if (owner != null) {\n-                fvs = freevarCache.get(owner);\n-                freevarCache.put(c, fvs);\n-                return fvs;\n-            } else {\n-                return List.nil();\n-            }\n-        }\n+        FreeVarCollector collector = new FreeVarCollector(classDef(c));\n+        fvs = collector.analyzeCaptures().reverse();\n+        freevarCache.put(c, fvs);\n+        return fvs;\n@@ -1504,1 +1410,1 @@\n-        return freevarDefs(pos, freevars, owner, 0);\n+        return freevarDefs(pos, freevars, owner, LOCAL_CAPTURE_FIELD);\n@@ -1520,1 +1426,6 @@\n-                flags, proxyName, v.erasure(types), owner);\n+                flags, proxyName, v.erasure(types), owner) {\n+                @Override\n+                public Symbol baseSymbol() {\n+                    return v;\n+                }\n+            };\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":23,"deletions":112,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -682,0 +682,1 @@\n+                slam.owner = tree.owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            (c.owner.type == null \/\/ local to init block\n+            ((c.owner.flags() & BLOCK) != 0 \/\/ local to init block\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -810,0 +810,2 @@\n+        \/** The owner of this functional expression. *\/\n+        public Symbol owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,0 @@\n-        scan(tree.body);\n@@ -278,0 +277,1 @@\n+        scan(tree.body);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n@@ -81,1 +81,1 @@\n-                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n@@ -85,1 +85,1 @@\n-                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\"));\n@@ -89,1 +89,1 @@\n-                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$14\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$0\", \"run\", \"enter0\", \"enter\"));\n@@ -93,1 +93,1 @@\n-                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n@@ -97,1 +97,1 @@\n-                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, cont.isDone() ? List.of() : Arrays.asList(\"yield0\", \"yield\", \"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"yield0\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n@@ -122,1 +122,1 @@\n-                        assertEquals(frames.subList(0, 18), Arrays.asList(\"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\", \"run\", \"test1\"));\n+                        assertEquals(frames.subList(0, 18), Arrays.asList(\"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\", \"run\", \"test1\"));\n@@ -126,1 +126,1 @@\n-                        assertEquals(frames, Arrays.asList(\"lambda$bar$14\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, Arrays.asList(\"lambda$bar$0\", \"run\", \"enter0\", \"enter\"));\n@@ -130,1 +130,1 @@\n-                        assertEquals(frames, Arrays.asList(\"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, Arrays.asList(\"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\"));\n@@ -134,1 +134,1 @@\n-                        assertEquals(frames, Arrays.asList(\"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n+                        assertEquals(frames, Arrays.asList(\"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\"));\n@@ -138,1 +138,1 @@\n-                        assertEquals(frames.subList(0, 18), Arrays.asList(\"lambda$bar$14\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$8\", \"run\", \"enter0\", \"enter\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\", \"run\", \"test1\"));\n+                        assertEquals(frames.subList(0, 18), Arrays.asList(\"lambda$bar$0\", \"run\", \"enter0\", \"enter\", \"run\", \"bar\", \"lambda$foo$0\", \"run\", \"enter0\", \"enter\", \"run\", \"foo\", \"lambda$test1$0\", \"run\", \"enter0\", \"enter\", \"run\", \"test1\"));\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Scoped.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4,2 +4,2 @@\n-LambdaTest.lambda$static$1(arg0)\/*synthetic*\/\n-LambdaTest.lambda$static$0(arg0, arg1)\/*synthetic*\/\n+LambdaTest.lambda$static$0(arg0)\/*synthetic*\/\n+LambdaTest.lambda$static$1(arg0, arg1)\/*synthetic*\/\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LambdaTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-LocalClassTest$1CapturingLocal$1.<init>(final this$0\/*implicit*\/, final val$val$i\/*synthetic*\/)\n+LocalClassTest$1CapturingLocal$1.<init>(final this$0\/*implicit*\/, final val$i\/*synthetic*\/)\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LocalClassTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-                \"Foo.class\").toUri()), \"lambda$variablesInLambdas$1\", lambdaWithVarsExpectedLNT);\n+                \"Foo.class\").toUri()), \"lambda$variablesInLambdas$0\", lambdaWithVarsExpectedLNT);\n@@ -143,1 +143,1 @@\n-                \"Foo.class\").toUri()), \"lambda$variablesInLambdas$2\", lambdaVoid2VoidExpectedLNT);\n+                \"Foo.class\").toUri()), \"lambda$variablesInLambdas$1\", lambdaVoid2VoidExpectedLNT);\n@@ -147,1 +147,1 @@\n-                \"Foo.class\").toUri()), \"lambda$variablesInLambdas$3\", lambdaBridgeExpectedLNT);\n+                \"Foo.class\").toUri()), \"lambda$variablesInLambdas$2\", lambdaBridgeExpectedLNT);\n","filename":"test\/langtools\/tools\/javac\/T8019486\/WrongLNTForLambdaTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-                enclosingMethod = \"<init>\",\n@@ -328,1 +327,0 @@\n-                    enclosingMethod = \"<init>\",\n@@ -385,1 +383,0 @@\n-                    enclosingMethod = \"<clinit>\",\n@@ -463,1 +460,0 @@\n-                    enclosingMethod = \"<init>\",\n@@ -520,1 +516,0 @@\n-                    enclosingMethod = \"<clinit>\",\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/EnclosingMethod\/EnclosingMethodTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336492\n+ * @summary Regression in lambda serialization\n+ *\/\n+\n+public class CaptureVarOrder {\n+    static Object m(String s, int i, Object o) {\n+        return new Object() {\n+            final byte B = 0;\n+            void g() { System.out.println(s + i + B + o); }\n+        };\n+    }\n+\n+    static Runnable r(String s, int i, Object o) {\n+        final byte B = 0;\n+        return () -> System.out.println(s + i + B + o);\n+    }\n+\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        CaptureVarOrder.class.getDeclaredMethod(\"lambda$r$0\", String.class, int.class, Object.class);\n+        m(\"\", 1, null).getClass().getDeclaredConstructor(String.class, int.class, Object.class);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/CaptureVarOrder.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336492\n+ * @summary Regression in lambda serialization\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.function.*;\n+\n+public class SerializedLambdaInLocalClass {\n+\n+    public static void main(String[] args) {\n+        SerializedLambdaInLocalClass s = new SerializedLambdaInLocalClass();\n+        s.test(s::f_lambda_in_anon);\n+        s.test(s::f_lambda_in_local);\n+        s.test(s::f_lambda_in_lambda);\n+    }\n+\n+    void test(IntFunction<Supplier<F>> fSupplier) {\n+        try {\n+            F f = fSupplier.apply(42).get();\n+            var baos = new ByteArrayOutputStream();\n+            \/\/ write\n+            try (var oos = new ObjectOutputStream(baos)) {\n+                oos.writeObject(f);\n+            }\n+            byte[] bytes = baos.toByteArray();\n+            var bais = new ByteArrayInputStream(bytes);\n+            \/\/ read\n+            try (var ois = new ObjectInputStream(bais)) {\n+                F f2 = (F)ois.readObject();\n+                if (f2.getValue() != f.getValue()) {\n+                    throw new AssertionError(String.format(\"Found: %d, expected %d\", f2.getValue(), f.getValue()));\n+                }\n+            }\n+        } catch (IOException | ClassNotFoundException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    interface F extends Serializable {\n+        int getValue();\n+    }\n+\n+    Supplier<F> f_lambda_in_anon(int x) {\n+        return new Supplier<F>() {\n+            @Override\n+            public F get() {\n+                return () -> x;\n+            }\n+        };\n+    }\n+\n+    Supplier<F> f_lambda_in_local(int x) {\n+        class FSupplier implements Supplier<F> {\n+            @Override\n+            public F get() {\n+                return () -> x;\n+            }\n+        }\n+        return new FSupplier();\n+    }\n+\n+    Supplier<F> f_lambda_in_lambda(int x) {\n+        return () -> () -> x;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializedLambdaInLocalClass.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}