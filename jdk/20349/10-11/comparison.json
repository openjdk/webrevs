{"files":[{"patch":"@@ -84,0 +84,1 @@\n+import java.lang.invoke.LambdaMetafactory;\n@@ -119,8 +120,8 @@\n-    private Attr attr;\n-    private JCDiagnostic.Factory diags;\n-    private Log log;\n-    private Lower lower;\n-    private Names names;\n-    private Symtab syms;\n-    private Resolve rs;\n-    private Operators operators;\n+    private final Attr attr;\n+    private final JCDiagnostic.Factory diags;\n+    private final Log log;\n+    private final Lower lower;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Resolve rs;\n+    private final Operators operators;\n@@ -128,2 +129,2 @@\n-    private Types types;\n-    private TransTypes transTypes;\n+    private final Types types;\n+    private final TransTypes transTypes;\n@@ -157,1 +158,1 @@\n-    public static final int FLAG_SERIALIZABLE = 1 << 0;\n+    public static final int FLAG_SERIALIZABLE = LambdaMetafactory.FLAG_SERIALIZABLE;\n@@ -160,1 +161,1 @@\n-    public static final int FLAG_MARKERS = 1 << 1;\n+    public static final int FLAG_MARKERS = LambdaMetafactory.FLAG_MARKERS;\n@@ -163,1 +164,1 @@\n-    public static final int FLAG_BRIDGES = 1 << 2;\n+    public static final int FLAG_BRIDGES = LambdaMetafactory.FLAG_BRIDGES;\n@@ -297,1 +298,0 @@\n-     * @param tree\n@@ -318,1 +318,1 @@\n-                    kInfo.addMethod(makeDeserializeMethod(tree.sym));\n+                    kInfo.addMethod(makeDeserializeMethod());\n@@ -342,1 +342,0 @@\n-     * @param tree\n@@ -489,1 +488,0 @@\n-     * @param tree\n@@ -498,26 +496,13 @@\n-        JCExpression init;\n-        switch(tree.kind) {\n-\n-            case IMPLICIT_INNER:    \/** Inner :: new *\/\n-            case SUPER:             \/** super :: instMethod *\/\n-                init = makeThis(\n-                        tree.owner.enclClass().asType(),\n-                        tree.owner.enclClass());\n-                break;\n-\n-            case BOUND:             \/** Expr :: instMethod *\/\n-                init = transTypes.coerce(attrEnv, tree.getQualifierExpression(),\n-                        types.erasure(tree.sym.owner.type));\n-                init = attr.makeNullCheck(init);\n-                break;\n-\n-            case UNBOUND:           \/** Type :: instMethod *\/\n-            case STATIC:            \/** Type :: staticMethod *\/\n-            case TOPLEVEL:          \/** Top level :: new *\/\n-            case ARRAY_CTOR:        \/** ArrayType :: new *\/\n-                init = null;\n-                break;\n-\n-            default:\n-                throw new InternalError(\"Should not have an invalid kind\");\n-        }\n+        JCExpression init = switch (tree.kind) {\n+            case IMPLICIT_INNER,    \/* Inner :: new *\/\n+                 SUPER ->           \/* super :: instMethod *\/\n+                    makeThis(tree.owner.enclClass().asType(), tree.owner.enclClass());\n+            case BOUND ->           \/* Expr :: instMethod *\/\n+                    attr.makeNullCheck(transTypes.coerce(attrEnv, tree.getQualifierExpression(),\n+                            types.erasure(tree.sym.owner.type)));\n+            case UNBOUND,           \/* Type :: instMethod *\/\n+                 STATIC,            \/* Type :: staticMethod *\/\n+                 TOPLEVEL,          \/* Top level :: new *\/\n+                 ARRAY_CTOR ->      \/* ArrayType :: new *\/\n+                    null;\n+        };\n@@ -525,1 +510,2 @@\n-        List<JCExpression> indy_args = init==null? List.nil() : translate(List.of(init));\n+        List<JCExpression> indy_args = (init == null) ?\n+                List.nil() : translate(List.of(init));\n@@ -533,1 +519,0 @@\n-     * @param tree\n@@ -638,1 +623,1 @@\n-                    VarSymbol loc = makeSyntheticVar(0, names.fromString(\"$loc\"), tree.expr.type, lambdaMethodDecl.sym);\n+                    VarSymbol loc = new VarSymbol(SYNTHETIC, names.fromString(\"$loc\"), tree.expr.type, lambdaMethodDecl.sym);\n@@ -657,1 +642,1 @@\n-    private JCMethodDecl makeDeserializeMethod(Symbol kSym) {\n+    private JCMethodDecl makeDeserializeMethod() {\n@@ -811,7 +796,0 @@\n-    \/**\n-     * Create new synthetic variable with given flags, name, type, owner\n-     *\/\n-    private VarSymbol makeSyntheticVar(long flags, Name name, Type type, Symbol owner) {\n-        return new VarSymbol(flags | SYNTHETIC, name, type, owner);\n-    }\n-\n@@ -1329,1 +1307,1 @@\n-         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation()}.\n+         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation(Symbol)}}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":33,"deletions":55,"binary":false,"changes":88,"status":"modified"}]}