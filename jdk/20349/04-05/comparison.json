{"files":[{"patch":"@@ -312,1 +312,1 @@\n-                tree.sym.owner = prevLambdaContext.owner;\n+                tree.sym.owner = prevLambdaContext.translatedSym;\n@@ -361,1 +361,1 @@\n-            Symbol owner = localContext.owner;\n+            Symbol owner = tree.owner;\n@@ -415,1 +415,1 @@\n-                    localContext.owner.enclClass()));\n+                    tree.owner.enclClass()));\n@@ -497,1 +497,1 @@\n-        ReferenceTranslationContext localContext = new ReferenceTranslationContext(tree);\n+        TranslationContext localContext = new TranslationContext(tree);\n@@ -513,2 +513,2 @@\n-                        localContext.owner.enclClass().asType(),\n-                        localContext.owner.enclClass());\n+                        tree.owner.enclClass().asType(),\n+                        tree.owner.enclClass());\n@@ -841,1 +841,1 @@\n-    private JCExpression makeMetafactoryIndyCall(TranslationContext<?> context,\n+    private JCExpression makeMetafactoryIndyCall(TranslationContext context,\n@@ -958,1 +958,1 @@\n-     * lambda expression\/method references (see subclasses).\n+     * all functional expressions. For lambdas, see subclass.\n@@ -960,1 +960,1 @@\n-    abstract class TranslationContext<T extends JCFunctionalExpression> {\n+    class TranslationContext {\n@@ -963,1 +963,1 @@\n-        final T tree;\n+        final JCFunctionalExpression tree;\n@@ -968,3 +968,1 @@\n-        final Symbol owner;\n-\n-        TranslationContext(T tree) {\n+        TranslationContext(JCFunctionalExpression tree) {\n@@ -972,1 +970,0 @@\n-            this.owner = tree.owner;\n@@ -1000,1 +997,1 @@\n-    class LambdaTranslationContext extends TranslationContext<JCLambda> {\n+    class LambdaTranslationContext extends TranslationContext {\n@@ -1017,0 +1014,1 @@\n+            Symbol owner = tree.owner;\n@@ -1043,1 +1041,1 @@\n-            completeLambdaMethodSymbol(captureScanner.capturesThis);\n+            completeLambdaMethodSymbol(owner, captureScanner.capturesThis);\n@@ -1047,1 +1045,1 @@\n-        void completeLambdaMethodSymbol(boolean thisReferenced) {\n+        void completeLambdaMethodSymbol(Symbol owner, boolean thisReferenced) {\n@@ -1052,2 +1050,2 @@\n-                    ? serializedLambdaName()\n-                    : lambdaName();\n+                    ? serializedLambdaName(owner)\n+                    : lambdaName(owner);\n@@ -1082,1 +1080,1 @@\n-        private String serializedLambdaDisambiguation() {\n+        private String serializedLambdaDisambiguation(Symbol owner) {\n@@ -1125,1 +1123,1 @@\n-        private Name lambdaName() {\n+        private Name lambdaName(Symbol owner) {\n@@ -1156,1 +1154,1 @@\n-        private Name serializedLambdaName() {\n+        private Name serializedLambdaName(Symbol owner) {\n@@ -1164,1 +1162,1 @@\n-            String disam = serializedLambdaDisambiguation();\n+            String disam = serializedLambdaDisambiguation(owner);\n@@ -1181,0 +1179,1 @@\n+            boolean propagateAnnos = true;\n@@ -1186,0 +1185,1 @@\n+                    propagateAnnos = false;\n@@ -1211,1 +1211,1 @@\n-            if (ret != sym && skind.propagateAnnotations()) {\n+            if (ret != sym && propagateAnnos) {\n@@ -1287,10 +1287,0 @@\n-\n-    \/**\n-     * Simple subclass modelling the translation context of a method reference.\n-     *\/\n-    final class ReferenceTranslationContext extends TranslationContext<JCMemberReference> {\n-\n-        ReferenceTranslationContext(JCMemberReference tree) {\n-            super(tree);\n-        }\n-    }\n@@ -1307,9 +1297,0 @@\n-\n-        boolean propagateAnnotations() {\n-            switch (this) {\n-                case CAPTURED_VAR:\n-                    return false;\n-                default:\n-                    return true;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":24,"deletions":43,"binary":false,"changes":67,"status":"modified"}]}