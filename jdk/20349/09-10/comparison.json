{"files":[{"patch":"@@ -347,4 +347,0 @@\n-        if (dumpLambdaToMethodStats) {\n-            log.note(tree, diags.noteKey(tree.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\",\n-                    localContext.needsAltMetafactory(), localContext.translatedSym));\n-        }\n@@ -441,1 +437,1 @@\n-        if (deduplicateLambdas && !debugLinesOrVars && !localContext.isSerializable()) {\n+        if (deduplicateLambdas && !debugLinesOrVars && !isSerializable(tree)) {\n@@ -456,1 +452,1 @@\n-        result = makeMetafactoryIndyCall(localContext, sym.asHandle(), indy_args);\n+        result = makeMetafactoryIndyCall(tree, sym.asHandle(), localContext.translatedSym, indy_args);\n@@ -497,5 +493,0 @@\n-        TranslationContext localContext = new TranslationContext(tree);\n-        if (dumpLambdaToMethodStats) {\n-            log.note(tree, Notes.MrefStat(localContext.needsAltMetafactory(), null));\n-        }\n-\n@@ -536,1 +527,0 @@\n-\n@@ -538,1 +528,1 @@\n-        result = makeMetafactoryIndyCall(localContext, refSym.asHandle(), indy_args);\n+        result = makeMetafactoryIndyCall(tree, refSym.asHandle(), refSym, indy_args);\n@@ -828,2 +818,0 @@\n-    \/\/ <\/editor-fold>\n-\n@@ -841,3 +829,3 @@\n-    private JCExpression makeMetafactoryIndyCall(TranslationContext context,\n-                                                 MethodHandleSymbol refSym, List<JCExpression> indy_args) {\n-        JCFunctionalExpression tree = context.tree;\n+    private JCExpression makeMetafactoryIndyCall(JCFunctionalExpression tree,\n+                                                 MethodHandleSymbol refSym, MethodSymbol nonDedupedRefSym,\n+                                                 List<JCExpression> indy_args) {\n@@ -863,1 +851,8 @@\n-        Name metafactoryName = context.needsAltMetafactory() ?\n+        List<Symbol> bridges = bridges(tree);\n+        boolean isSerializable = isSerializable(tree);\n+        boolean needsAltMetafactory = tree.target.isIntersection() ||\n+                isSerializable || bridges.length() > 1;\n+\n+        dumpStats(tree, needsAltMetafactory, nonDedupedRefSym);\n+\n+        Name metafactoryName = needsAltMetafactory ?\n@@ -866,1 +861,1 @@\n-        if (context.needsAltMetafactory()) {\n+        if (needsAltMetafactory) {\n@@ -879,1 +874,1 @@\n-            int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;\n+            int flags = isSerializable ? FLAG_SERIALIZABLE : 0;\n@@ -881,1 +876,1 @@\n-            boolean hasBridges = context.bridges.nonEmpty();\n+            boolean hasBridges = bridges.nonEmpty();\n@@ -894,2 +889,2 @@\n-                staticArgs = staticArgs.append(LoadableConstant.Int(context.bridges.length() - 1));\n-                for (Symbol s : context.bridges) {\n+                staticArgs = staticArgs.append(LoadableConstant.Int(bridges.length() - 1));\n+                for (Symbol s : bridges) {\n@@ -902,1 +897,1 @@\n-            if (context.isSerializable()) {\n+            if (isSerializable) {\n@@ -954,20 +949,5 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Lambda\/reference analyzer\">\n-\n-    \/**\n-     * This class is used to store important information regarding translation of\n-     * all functional expressions. For lambdas, see subclass.\n-     *\/\n-    class TranslationContext {\n-\n-        \/** the underlying (untranslated) tree *\/\n-        final JCFunctionalExpression tree;\n-\n-        \/** list of methods to be bridged by the meta-factory *\/\n-        final List<Symbol> bridges;\n-\n-        TranslationContext(JCFunctionalExpression tree) {\n-            this.tree = tree;\n-            ClassSymbol csym =\n-                    types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);\n-            this.bridges = types.functionalInterfaceBridges(csym);\n-        }\n+    List<Symbol> bridges(JCFunctionalExpression tree) {\n+        ClassSymbol csym =\n+                types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);\n+        return types.functionalInterfaceBridges(csym);\n+    }\n@@ -975,5 +955,4 @@\n-        \/** does this functional expression need to be created using alternate metafactory? *\/\n-        boolean needsAltMetafactory() {\n-            return tree.target.isIntersection() ||\n-                    isSerializable() ||\n-                    bridges.length() > 1;\n+    \/** does this functional expression require serialization support? *\/\n+    boolean isSerializable(JCFunctionalExpression tree) {\n+        if (forceSerializable) {\n+            return true;\n@@ -981,0 +960,2 @@\n+        return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n+    }\n@@ -982,4 +963,7 @@\n-        \/** does this functional expression require serialization support? *\/\n-        boolean isSerializable() {\n-            if (forceSerializable) {\n-                return true;\n+    void dumpStats(JCFunctionalExpression tree, boolean needsAltMetafactory, Symbol sym) {\n+        if (dumpLambdaToMethodStats) {\n+            if (tree instanceof JCLambda lambda) {\n+                log.note(tree, diags.noteKey(lambda.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\",\n+                        needsAltMetafactory, sym));\n+            } else if (tree instanceof JCMemberReference) {\n+                log.note(tree, Notes.MrefStat(needsAltMetafactory, null));\n@@ -987,1 +971,0 @@\n-            return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n@@ -992,4 +975,3 @@\n-     * This class retains all the useful information about a lambda expression;\n-     * the contents of this class are filled by the LambdaAnalyzer visitor,\n-     * and the used by the main translation routines in order to adjust references\n-     * to captured locals\/members, etc.\n+     * This class retains all the useful information about a lambda expression,\n+     * and acts as a translation map that is used by the main translation routines\n+     * in order to adjust references to captured locals\/members, etc.\n@@ -997,1 +979,4 @@\n-    class LambdaTranslationContext extends TranslationContext {\n+    class LambdaTranslationContext {\n+\n+        \/** the underlying (untranslated) tree *\/\n+        final JCFunctionalExpression tree;\n@@ -1012,1 +997,1 @@\n-            super(tree);\n+            this.tree = tree;\n@@ -1049,1 +1034,1 @@\n-            Name name = isSerializable()\n+            Name name = isSerializable(tree)\n@@ -1286,2 +1271,0 @@\n-    }\n-    \/\/ <\/editor-fold>\n@@ -1289,8 +1272,9 @@\n-    \/*\n-     * These keys provide mappings for various translated lambda symbols\n-     * and the prevailing order must be maintained.\n-     *\/\n-    enum LambdaSymbolKind {\n-        PARAM,          \/\/ original to translated lambda parameters\n-        LOCAL_VAR,      \/\/ original to translated lambda locals\n-        CAPTURED_VAR;   \/\/ variables in enclosing scope to translated synthetic parameters\n+        \/*\n+         * These keys provide mappings for various translated lambda symbols\n+         * and the prevailing order must be maintained.\n+         *\/\n+        enum LambdaSymbolKind {\n+            PARAM,          \/\/ original to translated lambda parameters\n+            LOCAL_VAR,      \/\/ original to translated lambda locals\n+            CAPTURED_VAR;   \/\/ variables in enclosing scope to translated synthetic parameters\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":56,"deletions":72,"binary":false,"changes":128,"status":"modified"}]}