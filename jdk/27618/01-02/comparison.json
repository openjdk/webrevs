{"files":[{"patch":"@@ -83,0 +83,1 @@\n+  constexpr bool operator!=(intn_t o) const { return !(*this == o); }\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/intn_t.hpp\"\n@@ -30,0 +29,2 @@\n+#include \"utilities\/intn_t.hpp\"\n+#include \"utilities\/rbTree.hpp\"\n@@ -33,1 +34,0 @@\n-#include <unordered_set>\n@@ -217,0 +217,1 @@\n+\/\/ Implementations of TypeIntMirror methods for testing purposes\n@@ -250,11 +251,2 @@\n-template <class S, class U>\n-class std::hash<TypeIntMirror<S, U>> {\n-public:\n-  size_t operator()(const TypeIntMirror<S, U>& t) const noexcept {\n-    return (julong(juint(U(t._lo))) << 40) | (julong(juint(U(t._hi))) << 32) |\n-           (julong(juint(t._ulo)) << 24) | (julong(juint(t._ulo)) << 16) |\n-           (julong(juint(t._bits._zeros)) << 8) | julong(juint(t._bits._ones));\n-  }\n-};\n-\n-\n+\/\/ The number of TypeIntMirror instances for integral types with a few bits. These values are\n+\/\/ calculated once and written down for usage in constexpr contexts.\n@@ -266,0 +258,1 @@\n+    \/\/ 1 bit\n@@ -268,0 +261,1 @@\n+    \/\/ 2 bits\n@@ -270,0 +264,1 @@\n+    \/\/ 3 bits\n@@ -272,0 +267,1 @@\n+    \/\/ 4 bits\n@@ -273,0 +269,2 @@\n+    \/\/ For more than 4 bits, the number of instances is too large and it is not realistic to\n+    \/\/ compute all of them.\n@@ -282,2 +280,28 @@\n-  std::unordered_set<CTP> collector;\n-  collector.reserve(all_instances_size<CTP>());\n+  class CTPComparator {\n+  public:\n+    static RBTreeOrdering cmp(const CTP& x, const RBNode<CTP, int>* node) {\n+      \/\/ Quick helper for the tediousness below\n+      auto f = [](auto x, auto y) {\n+        return x < y ? RBTreeOrdering::LT : RBTreeOrdering::GT;\n+      };\n+\n+      const CTP& y = node->key();\n+      if (x._lo != y._lo) {\n+        return f(x._lo, y._lo);\n+      } else if (x._hi != y._hi) {\n+        return f(x._hi, y._hi);\n+      } else if (x._ulo != y._ulo) {\n+        return f(x._ulo, y._ulo);\n+      } else if (x._uhi != y._uhi) {\n+        return f(x._uhi, y._uhi);\n+      } else if (x._bits._zeros != y._bits._zeros) {\n+        return f(x._bits._zeros, y._bits._zeros);\n+      } else if (x._bits._ones != y._bits._ones) {\n+        return f(x._bits._ones, y._bits._ones);\n+      } else {\n+        return RBTreeOrdering::EQ;\n+      }\n+    }\n+  };\n+\n+  RBTreeCHeap<CTP, int, CTPComparator, MemTag::mtCompiler> collector;\n@@ -297,1 +321,1 @@\n-              collector.insert(CTP{ct._srange._lo, ct._srange._hi, ct._urange._lo, ct._urange._hi, ct._bits});\n+              collector.upsert(CTP{ct._srange._lo, ct._srange._hi, ct._urange._lo, ct._urange._hi, ct._bits}, 0);\n@@ -308,2 +332,2 @@\n-  for (const CTP& t : collector) {\n-    res[idx] = t;\n+  collector.visit_in_order([&](RBNode<CTP, int>* node) {\n+    res[idx] = node->key();\n@@ -311,1 +335,2 @@\n-  }\n+    return true;\n+  });\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"}]}