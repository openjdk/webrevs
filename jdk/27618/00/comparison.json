{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"opto\/utilities\/xor.hpp\"\n@@ -841,29 +841,2 @@\n-const Type *OrINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ If both args are bool, can figure out better types\n-  if ( r0 == TypeInt::BOOL ) {\n-    if ( r1 == TypeInt::ONE) {\n-      return TypeInt::ONE;\n-    } else if ( r1 == TypeInt::BOOL ) {\n-      return TypeInt::BOOL;\n-    }\n-  } else if ( r0 == TypeInt::ONE ) {\n-    if ( r1 == TypeInt::BOOL ) {\n-      return TypeInt::ONE;\n-    }\n-  }\n-\n-  \/\/ If either input is all ones, the output is all ones.\n-  \/\/ x | ~0 == ~0 <==> x | -1 == -1\n-  if (r0 == TypeInt::MINUS_1 || r1 == TypeInt::MINUS_1) {\n-    return TypeInt::MINUS_1;\n-  }\n-\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeInt::INT;        \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just OR them bits.\n-  return TypeInt::make( r0->get_con() | r1->get_con() );\n+const Type* OrINode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_or(t1->is_int(), t2->is_int());\n@@ -917,16 +890,2 @@\n-const Type *OrLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ If either input is all ones, the output is all ones.\n-  \/\/ x | ~0 == ~0 <==> x | -1 == -1\n-  if (r0 == TypeLong::MINUS_1 || r1 == TypeLong::MINUS_1) {\n-    return TypeLong::MINUS_1;\n-  }\n-\n-  \/\/ If either input is not a constant, just return all integers.\n-  if( !r0->is_con() || !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ Any integer, but still no symbols.\n-\n-  \/\/ Otherwise just OR them bits.\n-  return TypeLong::make( r0->get_con() | r1->get_con() );\n+const Type* OrLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_or(t1->is_long(), t2->is_long());\n@@ -1019,18 +978,2 @@\n-const Type *XorINode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  if (r0->is_con() && r1->is_con()) {\n-    \/\/ compute constant result\n-    return TypeInt::make(r0->get_con() ^ r1->get_con());\n-  }\n-\n-  \/\/ At least one of the arguments is not constant\n-\n-  if (r0->_lo >= 0 && r1->_lo >= 0) {\n-      \/\/ Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n-      jint upper_bound = xor_upper_bound_for_ranges<jint, juint>(r0->_hi, r1->_hi);\n-      return TypeInt::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n-  }\n-\n-  return TypeInt::INT;\n+const Type* XorINode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_xor(t1->is_int(), t2->is_int());\n@@ -1041,18 +984,2 @@\n-const Type *XorLNode::add_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  if (r0->is_con() && r1->is_con()) {\n-    \/\/ compute constant result\n-    return TypeLong::make(r0->get_con() ^ r1->get_con());\n-  }\n-\n-  \/\/ At least one of the arguments is not constant\n-\n-  if (r0->_lo >= 0 && r1->_lo >= 0) {\n-      \/\/ Combine [r0->_lo, r0->_hi] ^ [r0->_lo, r1->_hi] -> [0, upper_bound]\n-      julong upper_bound = xor_upper_bound_for_ranges<jlong, julong>(r0->_hi, r1->_hi);\n-      return TypeLong::make(0, upper_bound, MAX2(r0->_widen, r1->_widen));\n-  }\n-\n-  return TypeLong::LONG;\n+const Type* XorLNode::add_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_xor(t1->is_long(), t2->is_long());\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":9,"deletions":82,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/rangeinference.hpp\"\n@@ -631,63 +632,0 @@\n-template<typename IntegerType>\n-static const IntegerType* and_value(const IntegerType* r0, const IntegerType* r1) {\n-  typedef typename IntegerType::NativeType NativeType;\n-  static_assert(std::is_signed<NativeType>::value, \"Native type of IntegerType must be signed!\");\n-\n-  int widen = MAX2(r0->_widen, r1->_widen);\n-\n-  \/\/ If both types are constants, we can calculate a constant result.\n-  if (r0->is_con() && r1->is_con()) {\n-    return IntegerType::make(r0->get_con() & r1->get_con());\n-  }\n-\n-  \/\/ If both ranges are positive, the result will range from 0 up to the hi value of the smaller range. The minimum\n-  \/\/ of the two constrains the upper bound because any higher value in the other range will see all zeroes, so it will be masked out.\n-  if (r0->_lo >= 0 && r1->_lo >= 0) {\n-    return IntegerType::make(0, MIN2(r0->_hi, r1->_hi), widen);\n-  }\n-\n-  \/\/ If only one range is positive, the result will range from 0 up to that range's maximum value.\n-  \/\/ For the operation 'x & C' where C is a positive constant, the result will be in the range [0..C]. With that observation,\n-  \/\/ we can say that for any integer c such that 0 <= c <= C will also be in the range [0..C]. Therefore, 'x & [c..C]'\n-  \/\/ where c >= 0 will be in the range [0..C].\n-  if (r0->_lo >= 0) {\n-    return IntegerType::make(0, r0->_hi, widen);\n-  }\n-\n-  if (r1->_lo >= 0) {\n-    return IntegerType::make(0, r1->_hi, widen);\n-  }\n-\n-  \/\/ At this point, all positive ranges will have already been handled, so the only remaining cases will be negative ranges\n-  \/\/ and constants.\n-\n-  assert(r0->_lo < 0 && r1->_lo < 0, \"positive ranges should already be handled!\");\n-\n-  \/\/ As two's complement means that both numbers will start with leading 1s, the lower bound of both ranges will contain\n-  \/\/ the common leading 1s of both minimum values. In order to count them with count_leading_zeros, the bits are inverted.\n-  NativeType sel_val = ~MIN2(r0->_lo, r1->_lo);\n-\n-  NativeType min;\n-  if (sel_val == 0) {\n-    \/\/ Since count_leading_zeros is undefined at 0, we short-circuit the condition where both ranges have a minimum of -1.\n-    min = -1;\n-  } else {\n-    \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n-    int shift_bits = count_leading_zeros(sel_val) - 1;\n-    min = std::numeric_limits<NativeType>::min() >> shift_bits;\n-  }\n-\n-  NativeType max;\n-  if (r0->_hi < 0 && r1->_hi < 0) {\n-    \/\/ If both ranges are negative, then the same optimization as both positive ranges will apply, and the smaller hi\n-    \/\/ value will mask off any bits set by higher values.\n-    max = MIN2(r0->_hi, r1->_hi);\n-  } else {\n-    \/\/ In the case of ranges that cross zero, negative values can cause the higher order bits to be set, so the maximum\n-    \/\/ positive value can be as high as the larger hi value.\n-    max = MAX2(r0->_hi, r1->_hi);\n-  }\n-\n-  return IntegerType::make(min, max, widen);\n-}\n-\n@@ -700,5 +638,2 @@\n-const Type *AndINode::mul_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeInt* r0 = t0->is_int();\n-  const TypeInt* r1 = t1->is_int();\n-\n-  return and_value<TypeInt>(r0, r1);\n+const Type* AndINode::mul_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_and(t1->is_int(), t2->is_int());\n@@ -833,5 +768,2 @@\n-const Type *AndLNode::mul_ring( const Type *t0, const Type *t1 ) const {\n-  const TypeLong* r0 = t0->is_long();\n-  const TypeLong* r1 = t1->is_long();\n-\n-  return and_value<TypeLong>(r0, r1);\n+const Type* AndLNode::mul_ring(const Type* t1, const Type* t2) const {\n+  return RangeInference::infer_and(t1->is_long(), t2->is_long());\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":5,"deletions":73,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/tuple.hpp\"\n","filename":"src\/hotspot\/share\/opto\/rangeinference.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -30,0 +31,1 @@\n+#include <limits>\n@@ -96,13 +98,0 @@\n-private:\n-  friend class TypeInt;\n-  friend class TypeLong;\n-\n-  template <class T1, class T2>\n-  friend void test_canonicalize_constraints_exhaustive();\n-\n-  template <class T1, class T2>\n-  friend void test_canonicalize_constraints_simple();\n-\n-  template <class T1, class T2>\n-  friend void test_canonicalize_constraints_random();\n-\n@@ -162,2 +151,2 @@\n-  template <class CT>\n-  static bool int_type_is_equal(const CT* t1, const CT* t2) {\n+  template <class CTP>\n+  static bool int_type_is_equal(const CTP t1, const CTP t2) {\n@@ -169,2 +158,3 @@\n-  template <class CT>\n-  static bool int_type_is_subset(const CT* super, const CT* sub) {\n+  template <class CTP>\n+  static bool int_type_is_subset(const CTP super, const CTP sub) {\n+    using U = decltype(super->_ulo);\n@@ -176,1 +166,1 @@\n-           (super->_bits._zeros &~ sub->_bits._zeros) == 0 && (super->_bits._ones &~ sub->_bits._ones) == 0;\n+           (super->_bits._zeros &~ sub->_bits._zeros) == U(0) && (super->_bits._ones &~ sub->_bits._ones) == U(0);\n@@ -199,0 +189,198 @@\n+\/\/ A TypeIntMirror is structurally similar to a TypeInt or a TypeLong but it decouples the range\n+\/\/ inference from the Type infrastructure of the compiler. It also allows more flexibility with the\n+\/\/ bit width of the integer type. As a result, it is more efficient to use for intermediate steps\n+\/\/ of inference, as well as more flexible to perform testing on different integer types.\n+template <class S, class U>\n+class TypeIntMirror {\n+public:\n+  S _lo;\n+  S _hi;\n+  U _ulo;\n+  U _uhi;\n+  KnownBits<U> _bits;\n+  int _widen = 0; \/\/ dummy field to mimic the same field in TypeInt, useful in testing\n+\n+  static TypeIntMirror make(const TypeIntPrototype<S, U>& t, int widen) {\n+    auto canonicalized_t = t.canonicalize_constraints();\n+    assert(!canonicalized_t.empty(), \"must not be empty\");\n+    return TypeIntMirror{canonicalized_t._data._srange._lo, canonicalized_t._data._srange._hi,\n+                         canonicalized_t._data._urange._lo, canonicalized_t._data._urange._hi,\n+                         canonicalized_t._data._bits};\n+  }\n+\n+  \/\/ These allow TypeIntMirror to mimick the behaviors of TypeInt* and TypeLong*, so they can be\n+  \/\/ passed into RangeInference methods. These are only used in testing, so they are implemented in\n+  \/\/ the test file.\n+  const TypeIntMirror* operator->() const;\n+  TypeIntMirror meet(const TypeIntMirror& o) const;\n+  bool contains(U u) const;\n+  bool contains(const TypeIntMirror& o) const;\n+  bool operator==(const TypeIntMirror& o) const;\n+\n+  template <class T>\n+  TypeIntMirror cast() const;\n+};\n+\n+\/\/ This class contains methods for inferring the Type of the result of several arithmetic\n+\/\/ operations from those of the corresponding inputs. For example, given a, b such that the Type of\n+\/\/ a is [0, 1] and the Type of b is [-1, 3], then the Type of the sum a + b is [-1, 4].\n+\/\/ The methods in this class receive one or more template parameters which are often TypeInt* or\n+\/\/ TypeLong*, or they can be TypeIntMirror which behave similar to TypeInt* and TypeLong* during\n+\/\/ testing. This allows us to verify the correctness of the implementation without coupling with\n+\/\/ the hotspot compiler allocation infrastructure.\n+class RangeInference {\n+private:\n+  \/\/ If CTP is a pointer, get the underlying type. For the test helper classes, using the struct\n+  \/\/ directly allows straightfoward equality comparison.\n+  template <class CTP>\n+  using CT = std::remove_const_t<std::conditional_t<std::is_pointer_v<CTP>, std::remove_pointer_t<CTP>, CTP>>;\n+\n+  \/\/ The type of CT::_lo, should be jint for TypeInt* and jlong for TypeLong*\n+  template <class CTP>\n+  using S = std::remove_const_t<decltype(CT<CTP>::_lo)>;\n+\n+  \/\/ The type of CT::_ulo, should be juint for TypeInt* and julong for TypeLong*\n+  template <class CTP>\n+  using U = std::remove_const_t<decltype(CT<CTP>::_ulo)>;\n+\n+  \/\/ A TypeInt consists of 1 or 2 simple intervals, each of which will lie either in the interval\n+  \/\/ [0, max_signed] or [min_signed, -1]. It is more optimal to analyze each simple interval\n+  \/\/ separately when doing inference. For example, consider a, b whose Types are both [-2, 2]. By\n+  \/\/ analyzing the interval [-2, -1] and [0, 2] separately, we can easily see that the result of\n+  \/\/ a & b must also be in the interval [-2, 2]. This is much harder if we want to work with the\n+  \/\/ whole value range at the same time.\n+  \/\/ This class offers a convenient way to traverse all the simple interval of a TypeInt.\n+  template <class CTP>\n+  class SimpleIntervalIterable {\n+  private:\n+    TypeIntMirror<S<CTP>, U<CTP>> _first_interval;\n+    TypeIntMirror<S<CTP>, U<CTP>> _second_interval;\n+    int _interval_num;\n+\n+  public:\n+    SimpleIntervalIterable(CTP t) {\n+      if (U<CTP>(t->_lo) <= U<CTP>(t->_hi)) {\n+        _interval_num = 1;\n+        _first_interval = TypeIntMirror<S<CTP>, U<CTP>>{t->_lo, t->_hi, t->_ulo, t->_uhi, t->_bits};\n+      } else {\n+        _interval_num = 2;\n+        _first_interval = TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{t->_lo, S<CTP>(t->_uhi)}, {U<CTP>(t->_lo), t->_uhi}, t->_bits}, 0);\n+        _second_interval = TypeIntMirror<S<CTP>, U<CTP>>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{S<CTP>(t->_ulo), t->_hi}, {t->_ulo, U<CTP>(t->_hi)}, t->_bits}, 0);\n+      }\n+    }\n+\n+    class Iterator {\n+    private:\n+      const SimpleIntervalIterable& _iterable;\n+      int _current_interval;\n+\n+      Iterator(const SimpleIntervalIterable& iterable) : _iterable(iterable), _current_interval(0) {}\n+\n+      friend class SimpleIntervalIterable;\n+    public:\n+      const TypeIntMirror<S<CTP>, U<CTP>>& operator*() const {\n+        assert(_current_interval < _iterable._interval_num, \"out of bounds, %d - %d\", _current_interval, _iterable._interval_num);\n+        if (_current_interval == 0) {\n+          return _iterable._first_interval;\n+        } else {\n+          return _iterable._second_interval;\n+        }\n+      }\n+\n+      Iterator& operator++() {\n+        assert(_current_interval < _iterable._interval_num, \"out of bounds, %d - %d\", _current_interval, _iterable._interval_num);\n+        _current_interval++;\n+        return *this;\n+      }\n+\n+      Iterator operator++(int) {\n+        assert(_current_interval < _iterable._interval_num, \"out of bounds, %d - %d\", _current_interval, _iterable._interval_num);\n+        Iterator res(*this);\n+        _current_interval++;\n+        return res;\n+      }\n+\n+      bool operator!=(const Iterator& o) const {\n+        assert(&_iterable == &o._iterable, \"not on the same iterable\");\n+        return _current_interval != o._current_interval;\n+      }\n+    };\n+\n+    Iterator begin() const {\n+      return Iterator(*this);\n+    }\n+\n+    Iterator end() const {\n+      Iterator res(*this);\n+      res._current_interval = _interval_num;\n+      return res;\n+    }\n+  };\n+\n+  \/\/ Infer a result given the input types of a binary operation\n+  template <class CTP, class Inference>\n+  static CTP infer_binary(CTP t1, CTP t2, Inference infer) {\n+    CTP res;\n+    bool init = false;\n+\n+    SimpleIntervalIterable<CTP> t1_simple_intervals(t1);\n+    SimpleIntervalIterable<CTP> t2_simple_intervals(t2);\n+\n+    for (auto& st1 : t1_simple_intervals) {\n+      for (auto& st2 : t2_simple_intervals) {\n+        CTP current = infer(st1, st2);\n+\n+        if (init) {\n+          res = res->meet(current)->template cast<CT<CTP>>();\n+        } else {\n+          init = true;\n+          res = current;\n+        }\n+      }\n+    }\n+\n+    assert(init, \"must be initialized\");\n+    return res;\n+  }\n+\n+public:\n+  template <class CTP>\n+  static CTP infer_and(CTP t1, CTP t2) {\n+    return infer_binary(t1, t2, [&](const TypeIntMirror<S<CTP>, U<CTP>>& st1, const TypeIntMirror<S<CTP>, U<CTP>>& st2) {\n+      S<CTP> lo = std::numeric_limits<S<CTP>>::min();\n+      S<CTP> hi = std::numeric_limits<S<CTP>>::max();\n+      U<CTP> ulo = std::numeric_limits<U<CTP>>::min();\n+      U<CTP> uhi = MIN2(st1._uhi, st2._uhi);\n+      U<CTP> zeros = st1._bits._zeros | st2._bits._zeros;\n+      U<CTP> ones = st1._bits._ones & st2._bits._ones;\n+      return CT<CTP>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, MAX2(t1->_widen, t2->_widen));\n+    });\n+  }\n+\n+  template <class CTP>\n+  static CTP infer_or(CTP t1, CTP t2) {\n+    return infer_binary(t1, t2, [&](const TypeIntMirror<S<CTP>, U<CTP>>& st1, const TypeIntMirror<S<CTP>, U<CTP>>& st2) {\n+      S<CTP> lo = std::numeric_limits<S<CTP>>::min();\n+      S<CTP> hi = std::numeric_limits<S<CTP>>::max();\n+      U<CTP> ulo = MAX2(st1._ulo, st2._ulo);\n+      U<CTP> uhi = std::numeric_limits<U<CTP>>::max();\n+      U<CTP> zeros = st1._bits._zeros & st2._bits._zeros;\n+      U<CTP> ones = st1._bits._ones | st2._bits._ones;\n+      return CT<CTP>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, MAX2(t1->_widen, t2->_widen));\n+    });\n+  }\n+\n+  template <class CTP>\n+  static CTP infer_xor(CTP t1, CTP t2) {\n+    return infer_binary(t1, t2, [&](const TypeIntMirror<S<CTP>, U<CTP>>& st1, const TypeIntMirror<S<CTP>, U<CTP>>& st2) {\n+      S<CTP> lo = std::numeric_limits<S<CTP>>::min();\n+      S<CTP> hi = std::numeric_limits<S<CTP>>::max();\n+      U<CTP> ulo = std::numeric_limits<U<CTP>>::min();\n+      U<CTP> uhi = std::numeric_limits<U<CTP>>::max();\n+      U<CTP> zeros = (st1._bits._zeros & st2._bits._zeros) | (st1._bits._ones & st2._bits._ones);\n+      U<CTP> ones = (st1._bits._zeros & st2._bits._ones) | (st1._bits._ones & st2._bits._zeros);\n+      return CT<CTP>::make(TypeIntPrototype<S<CTP>, U<CTP>>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, MAX2(t1->_widen, t2->_widen));\n+    });\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":206,"deletions":18,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -801,0 +801,1 @@\n+  static const TypeInt* make(const TypeIntPrototype<jint, juint>& t, int widen) { return make_or_top(t, widen)->is_int(); }\n@@ -882,0 +883,1 @@\n+  static const TypeLong* make(const TypeIntPrototype<jlong, julong>& t, int widen) { return make_or_top(t, widen)->is_long(); }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-#ifndef SHARE_OPTO_UTILITIES_XOR_HPP\n-#define SHARE_OPTO_UTILITIES_XOR_HPP\n-\n-#include \"utilities\/powerOfTwo.hpp\"\n-\/\/ Code separated into its own header to allow access from GTEST\n-\n-\/\/ Given 2 non-negative values in the ranges [0, hi_0] and [0, hi_1], respectively. The bitwise\n-\/\/ xor of these values should also be non-negative. This method calculates an upper bound.\n-\n-\/\/ S and U type parameters correspond to the signed and unsigned\n-\/\/ variants of an integer to operate on.\n-template<class S, class U>\n-static S xor_upper_bound_for_ranges(const S hi_0, const S hi_1) {\n-    static_assert(S(-1) < S(0), \"S must be signed\");\n-    static_assert(U(-1) > U(0), \"U must be unsigned\");\n-\n-    assert(hi_0 >= 0, \"must be non-negative\");\n-    assert(hi_1 >= 0, \"must be non-negative\");\n-\n-    \/\/ x ^ y cannot have any bit set that is higher than both the highest bits set in x and y\n-    \/\/ x cannot have any bit set that is higher than the highest bit set in hi_0\n-    \/\/ y cannot have any bit set that is higher than the highest bit set in hi_1\n-\n-    \/\/ We want to find a value that has all 1 bits everywhere up to and including\n-    \/\/ the highest bits set in hi_0 as well as hi_1. For this, we can take the next\n-    \/\/ power of 2 strictly greater than both hi values and subtract 1 from it.\n-\n-    \/\/ Example 1:\n-    \/\/ hi_0 = 5 (0b0101)       hi_1=1 (0b0001)\n-    \/\/    (5|1)+1       = 0b0110\n-    \/\/    round_up_pow2 = 0b1000\n-    \/\/    -1            = 0b0111 = max\n-\n-    \/\/ Example 2 - this demonstrates need for the +1:\n-    \/\/ hi_0 =  4 (0b0100)        hi_1=4 (0b0100)\n-    \/\/    (4|4)+1       = 0b0101\n-    \/\/    round_up_pow2 = 0b1000\n-    \/\/    -1            = 0b0111 = max\n-    \/\/ Without the +1, round_up_pow2 would be 0b0100, resulting in 0b0011 as max\n-\n-    \/\/ Note: cast to unsigned happens before +1 to avoid signed overflow, and\n-    \/\/ round_up is safe because high bit is unset (0 <= lo <= hi)\n-\n-    return round_up_power_of_2(U(hi_0 | hi_1) + 1) - 1;\n-}\n-\n-#endif \/\/ SHARE_OPTO_UTILITIES_XOR_HPP\n","filename":"src\/hotspot\/share\/opto\/utilities\/xor.hpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -30,0 +30,4 @@\n+#include <array>\n+#include <limits>\n+#include <type_traits>\n+#include <unordered_set>\n@@ -32,5 +36,2 @@\n-static U uniform_random();\n-\n-template <>\n-juint uniform_random<juint>() {\n-  return os::random();\n+static U uniform_random() {\n+  return U(juint(os::random()));\n@@ -204,1 +205,1 @@\n-TEST_VM(opto, canonicalize_constraints) {\n+TEST(opto, canonicalize_constraints) {\n@@ -215,0 +216,382 @@\n+\n+template <class S, class U>\n+const TypeIntMirror<S, U>* TypeIntMirror<S, U>::operator->() const {\n+  return this;\n+}\n+\n+template <class S, class U>\n+TypeIntMirror<S, U> TypeIntMirror<S, U>::meet(const TypeIntMirror& o) const {\n+  return make(TypeIntPrototype<S, U>{{MIN2(_lo, o._lo), MAX2(_hi, o._hi)},\n+                                     {MIN2(_ulo, o._ulo), MAX2(_uhi, o._uhi)},\n+                                     {_bits._zeros & o._bits._zeros, _bits._ones & o._bits._ones}}, 0);\n+}\n+\n+template <class S, class U>\n+bool TypeIntMirror<S, U>::contains(U u) const {\n+  S s = S(u);\n+  return s >= _lo && s <= _hi && u >= _ulo && u <= _uhi && _bits.is_satisfied_by(u);\n+}\n+\n+template <class S, class U>\n+bool TypeIntMirror<S, U>::contains(const TypeIntMirror& o) const {\n+  return TypeIntHelper::int_type_is_subset(*this, o);\n+}\n+\n+template <class S, class U>\n+bool TypeIntMirror<S, U>::operator==(const TypeIntMirror& o) const {\n+  return TypeIntHelper::int_type_is_equal(*this, o);\n+}\n+\n+template <class S, class U>\n+template <class T>\n+TypeIntMirror<S, U> TypeIntMirror<S, U>::cast() const {\n+  static_assert(std::is_same_v<T, TypeIntMirror>);\n+  return *this;\n+}\n+\n+template <class S, class U>\n+class std::hash<TypeIntMirror<S, U>> {\n+public:\n+  size_t operator()(const TypeIntMirror<S, U>& t) const noexcept {\n+    return (julong(juint(U(t._lo))) << 40) | (julong(juint(U(t._hi))) << 32) |\n+           (julong(juint(t._ulo)) << 24) | (julong(juint(t._ulo)) << 16) |\n+           (julong(juint(t._bits._zeros)) << 8) | julong(juint(t._bits._ones));\n+  }\n+};\n+\n+\n+template <class CTP>\n+static constexpr size_t all_instances_size() {\n+  using U = decltype(CTP::_ulo);\n+  constexpr juint max_unsigned = juint(std::numeric_limits<U>::max());\n+  if constexpr (max_unsigned == 1U) {\n+    return 3;\n+  } else if constexpr (max_unsigned == 3U) {\n+    return 15;\n+  } else if constexpr (max_unsigned == 7U) {\n+    return 134;\n+  } else {\n+    static_assert(max_unsigned == 15U);\n+    return 1732;\n+  }\n+}\n+\n+template <class CTP>\n+static std::array<CTP, all_instances_size<CTP>()> compute_all_instances() {\n+  using S = decltype(CTP::_lo);\n+  using U = decltype(CTP::_ulo);\n+\n+  std::unordered_set<CTP> collector;\n+  collector.reserve(all_instances_size<CTP>());\n+  for (jint lo = jint(std::numeric_limits<S>::min()); lo <= jint(std::numeric_limits<S>::max()); lo++) {\n+    for (jint hi = lo; hi <= jint(std::numeric_limits<S>::max()); hi++) {\n+      for (juint ulo = 0; ulo <= juint(std::numeric_limits<U>::max()); ulo++) {\n+        for (juint uhi = ulo; uhi <= juint(std::numeric_limits<U>::max()); uhi++) {\n+          for (juint zeros = 0; zeros <= juint(std::numeric_limits<U>::max()); zeros++) {\n+            for (juint ones = 0; ones <= juint(std::numeric_limits<U>::max()); ones++) {\n+              TypeIntPrototype<S, U> t{{S(lo), S(hi)}, {U(ulo), U(uhi)}, {U(zeros), U(ones)}};\n+              auto canonicalized_t = t.canonicalize_constraints();\n+              if (canonicalized_t.empty()) {\n+                continue;\n+              }\n+\n+              TypeIntPrototype<S, U> ct = canonicalized_t._data;\n+              collector.insert(CTP{ct._srange._lo, ct._srange._hi, ct._urange._lo, ct._urange._hi, ct._bits});\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  assert(collector.size() == all_instances_size<CTP>(), \"unexpected size of all_instance, expected %d, actual %d\", jint(all_instances_size<CTP>()), jint(collector.size()));\n+  std::array<CTP, all_instances_size<CTP>()> res;\n+  size_t idx = 0;\n+  for (const CTP& t : collector) {\n+    res[idx] = t;\n+    idx++;\n+  }\n+  return res;\n+}\n+\n+template <class CTP>\n+static const std::array<CTP, all_instances_size<CTP>()>& all_instances() {\n+  static std::array<CTP, all_instances_size<CTP>()> res = compute_all_instances<CTP>();\n+  return res;\n+}\n+\n+\/\/ Check the correctness, that is, if v1 is an element of input1, v2 is an element of input2, then\n+\/\/ op(v1, v2) must be an element of infer(input1, input2). This version does the check exhaustively\n+\/\/ on all elements of input1 and input2.\n+template <class InputType, class Operation, class Inference>\n+static void test_binary_instance_correctness_exhaustive(Operation op, Inference infer, const InputType& input1, const InputType& input2) {\n+  using S = std::remove_const_t<decltype(input1->_lo)>;\n+  using U = std::remove_const_t<decltype(input1->_ulo)>;\n+  InputType result = infer(input1, input2);\n+\n+  for (juint v1 = juint(std::numeric_limits<U>::min()); v1 <= juint(std::numeric_limits<U>::max()); v1++) {\n+    if (!input1.contains(U(v1))) {\n+      continue;\n+    }\n+\n+    for (juint v2 = juint(std::numeric_limits<U>::min()); v2 <= juint(std::numeric_limits<U>::max()); v2++) {\n+      if (!input2.contains(U(v2))) {\n+        continue;\n+      }\n+\n+      U r = op(U(v1), U(v2));\n+      ASSERT_TRUE(result.contains(r));\n+    }\n+  }\n+}\n+\n+\/\/ Check the correctness, that is, if v1 is an element of input1, v2 is an element of input2, then\n+\/\/ op(v1, v2) must be an element of infer(input1, input2). This version does the check randomly on\n+\/\/ a number of elements in input1 and input2.\n+template <class InputType, class Operation, class Inference>\n+static void test_binary_instance_correctness_samples(Operation op, Inference infer, const InputType& input1, const InputType& input2) {\n+  using U = std::remove_const_t<decltype(input1->_ulo)>;\n+  auto result = infer(input1, input2);\n+\n+  constexpr size_t sample_count = 6;\n+  U input1_samples[sample_count] {U(input1._lo), U(input1._hi), input1._ulo, input1._uhi, input1._ulo, input1._ulo};\n+  U input2_samples[sample_count] {U(input2._lo), U(input2._hi), input2._ulo, input2._uhi, input2._ulo, input2._ulo};\n+\n+  auto random_sample = [](U* samples, const InputType& input) {\n+    constexpr size_t max_tries = 100;\n+    constexpr size_t start_random_idx = 4;\n+    for (size_t tries = 0, idx = start_random_idx; tries < max_tries && idx < sample_count; tries++) {\n+      U n = uniform_random<U>();\n+      if (input.contains(n)) {\n+        samples[idx] = n;\n+        idx++;\n+      }\n+    }\n+  };\n+  random_sample(input1_samples, input1);\n+  random_sample(input2_samples, input2);\n+\n+  for (size_t i = 0; i < sample_count; i++) {\n+    for (size_t j = 0; j < sample_count; j++) {\n+      U r = op(input1_samples[i], input2_samples[j]);\n+      ASSERT_TRUE(result.contains(r));\n+    }\n+  }\n+}\n+\n+\/\/ Check the monotonicity, that is, if input1 is a subset of super1, input2 is a subset of super2,\n+\/\/ then infer(input1, input2) must be a subset of infer(super1, super2). This version does the\n+\/\/ check exhaustively on all supersets of input1 and input2.\n+template <class InputType, class Inference>\n+static void test_binary_instance_monotonicity_exhaustive(Inference infer, const InputType& input1, const InputType& input2) {\n+  InputType result = infer(input1, input2);\n+\n+  for (const InputType& super1 : all_instances<InputType>()) {\n+    if (!super1.contains(input1) || super1 == input1) {\n+      continue;\n+    }\n+\n+    for (const InputType& super2 : all_instances<InputType>()) {\n+      if (!super2.contains(input2) || super2 == input2) {\n+        continue;\n+      }\n+\n+      ASSERT_TRUE(infer(input1, super2).contains(result));\n+      ASSERT_TRUE(infer(super1, input2).contains(result));\n+      ASSERT_TRUE(infer(super1, super2).contains(result));\n+    }\n+  }\n+}\n+\n+\/\/ Check the monotonicity, that is, if input1 is a subset of super1, input2 is a subset of super2,\n+\/\/ then infer(input1, input2) must be a subset of infer(super1, super2). This version does the\n+\/\/ check randomly on a number of supersets of input1 and input2.\n+template <class InputType, class Inference>\n+static void test_binary_instance_monotonicity_samples(Inference infer, const InputType& input1, const InputType& input2) {\n+  using S = std::remove_const_t<decltype(input1->_lo)>;\n+  using U = std::remove_const_t<decltype(input1->_ulo)>;\n+  auto result = infer(input1, input2);\n+\n+  \/\/ The set that is a superset of all other sets\n+  InputType universe = InputType{std::numeric_limits<S>::min(), std::numeric_limits<S>::max(), U(0), U(-1), {U(0), U(0)}};\n+  ASSERT_TRUE(infer(universe, input2).contains(result));\n+  ASSERT_TRUE(infer(input1, universe).contains(result));\n+  ASSERT_TRUE(infer(universe, universe).contains(result));\n+\n+  auto random_superset = [](const InputType& input) {\n+    S lo = MIN2(input->_lo, S(uniform_random<U>()));\n+    S hi = MAX2(input->_hi, S(uniform_random<U>()));\n+    U ulo = MIN2(input->_ulo, uniform_random<U>());\n+    U uhi = MAX2(input->_uhi, uniform_random<U>());\n+    U zeros = input->_bits._zeros & uniform_random<U>();\n+    U ones = input->_bits._ones & uniform_random<U>();\n+    InputType super = InputType::make(TypeIntPrototype<S, U>{{lo, hi}, {ulo, uhi}, {zeros, ones}}, 0);\n+    assert(super.contains(input), \"impossible\");\n+    return super;\n+  };\n+\n+  InputType super1 = random_superset(input1);\n+  InputType super2 = random_superset(input2);\n+  ASSERT_TRUE(infer(super1, input2).contains(result));\n+  ASSERT_TRUE(infer(input1, super2).contains(result));\n+  ASSERT_TRUE(infer(super1, super2).contains(result));\n+}\n+\n+\/\/ Verify the correctness and monotonicity of an inference function by exhautively analyzing all\n+\/\/ instances of InputType\n+template <class InputType, class Operation, class Inference>\n+static void test_binary_exhaustive(Operation op, Inference infer) {\n+  for (const InputType& input1 : all_instances<InputType>()) {\n+    for (const InputType& input2 : all_instances<InputType>()) {\n+      test_binary_instance_correctness_exhaustive(op, infer, input1, input2);\n+      if (all_instances<InputType>().size() < 100) {\n+        \/\/ This effectively covers the cases up to uintn_t<2>\n+        test_binary_instance_monotonicity_exhaustive(infer, input1, input2);\n+      } else {\n+        \/\/ This effectively covers the cases of uintn_t<3>\n+        test_binary_instance_monotonicity_samples(infer, input1, input2);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Verify the correctness and monotonicity of an inference function by randomly sampling instances\n+\/\/ of InputType\n+template <class InputType, class Operation, class Inference>\n+static void test_binary_random(Operation op, Inference infer) {\n+  using S = std::remove_const_t<decltype(InputType::_lo)>;\n+  using U = std::remove_const_t<decltype(InputType::_ulo)>;\n+\n+  constexpr size_t sample_count = 100;\n+  InputType samples[sample_count];\n+\n+  \/\/ Fill with {0}\n+  for (size_t i = 0; i < sample_count; i++) {\n+    samples[i] = InputType::make(TypeIntPrototype<S, U>{{S(0), S(0)}, {U(0), U(0)}, {U(0), U(0)}}, 0);\n+  }\n+\n+  \/\/ {1}\n+  samples[1] = InputType::make(TypeIntPrototype<S, U>{{S(1), S(1)}, {U(1), U(1)}, {U(0), U(0)}}, 0);\n+  \/\/ {-1}\n+  samples[2] = InputType::make(TypeIntPrototype<S, U>{{S(-1), S(-1)}, {U(-1), U(-1)}, {U(0), U(0)}}, 0);\n+  \/\/ {0, 1}\n+  samples[3] = InputType::make(TypeIntPrototype<S, U>{{S(0), S(1)}, {U(0), U(1)}, {U(0), U(0)}}, 0);\n+  \/\/ {-1, 0, 1}\n+  samples[4] = InputType::make(TypeIntPrototype<S, U>{{S(-1), S(1)}, {U(0), U(-1)}, {U(0), U(0)}}, 0);\n+  \/\/ {-1, 1}\n+  samples[5] = InputType::make(TypeIntPrototype<S, U>{{S(-1), S(1)}, {U(1), U(-1)}, {U(0), U(0)}}, 0);\n+  \/\/ {0, 1, 2}\n+  samples[6] = InputType::make(TypeIntPrototype<S, U>{{S(0), S(2)}, {U(0), U(2)}, {U(0), U(0)}}, 0);\n+  \/\/ {0, 2}\n+  samples[7] = InputType::make(TypeIntPrototype<S, U>{{S(0), S(2)}, {U(0), U(2)}, {U(1), U(0)}}, 0);\n+  \/\/ [min_signed, max_signed]\n+  samples[8] = InputType::make(TypeIntPrototype<S, U>{{std::numeric_limits<S>::min(), std::numeric_limits<S>::max()}, {U(0), U(-1)}, {U(0), U(0)}}, 0);\n+  \/\/ [0, max_signed]\n+  samples[9] = InputType::make(TypeIntPrototype<S, U>{{0, std::numeric_limits<S>::max()}, {U(0), U(-1)}, {U(0), U(0)}}, 0);\n+  \/\/ [min_signed, 0)\n+  samples[10] = InputType::make(TypeIntPrototype<S, U>{{std::numeric_limits<S>::min(), -1}, {U(0), U(-1)}, {U(0), U(0)}}, 0);\n+\n+  constexpr size_t max_tries = 1000;\n+  constexpr size_t start_random_idx = 11;\n+  for (size_t tries = 0, idx = start_random_idx; tries < max_tries && idx < sample_count; tries++) {\n+    \/\/ Try to have lo < hi\n+    S signed_bound1 = S(uniform_random<U>());\n+    S signed_bound2 = S(uniform_random<U>());\n+    S lo = MIN2(signed_bound1, signed_bound2);\n+    S hi = MAX2(signed_bound1, signed_bound2);\n+\n+    \/\/ Try to have ulo < uhi\n+    U unsigned_bound1 = uniform_random<U>();\n+    U unsigned_bound2 = uniform_random<U>();\n+    U ulo = MIN2(unsigned_bound1, unsigned_bound2);\n+    U uhi = MAX2(unsigned_bound1, unsigned_bound2);\n+\n+    \/\/ Try to have (zeros & ones) == 0\n+    U zeros = uniform_random<U>();\n+    U ones = uniform_random<U>();\n+    U common = zeros & ones;\n+    zeros ^= common;\n+    ones ^= common;\n+\n+    TypeIntPrototype<S, U> t{{lo, hi}, {ulo, uhi}, {zeros, ones}};\n+    auto canonicalized_t = t.canonicalize_constraints();\n+    if (canonicalized_t.empty()) {\n+      continue;\n+    }\n+\n+    samples[idx] = TypeIntMirror<S, U>{canonicalized_t._data._srange._lo, canonicalized_t._data._srange._hi,\n+                                       canonicalized_t._data._urange._lo, canonicalized_t._data._urange._hi,\n+                                       canonicalized_t._data._bits};\n+    idx++;\n+  }\n+\n+  for (size_t i = 0; i < sample_count; i++) {\n+    for (size_t j = 0; j < sample_count; j++) {\n+      test_binary_instance_correctness_samples(op, infer, samples[i], samples[j]);\n+      test_binary_instance_monotonicity_samples(infer, samples[i], samples[j]);\n+    }\n+  }\n+}\n+\n+template <template <class U> class Operation, template <class CTP> class Inference>\n+static void test_binary() {\n+  test_binary_exhaustive<TypeIntMirror<intn_t<1>, uintn_t<1>>>(Operation<uintn_t<1>>(), Inference<TypeIntMirror<intn_t<1>, uintn_t<1>>>());\n+  test_binary_exhaustive<TypeIntMirror<intn_t<2>, uintn_t<2>>>(Operation<uintn_t<2>>(), Inference<TypeIntMirror<intn_t<2>, uintn_t<2>>>());\n+  test_binary_exhaustive<TypeIntMirror<intn_t<3>, uintn_t<3>>>(Operation<uintn_t<3>>(), Inference<TypeIntMirror<intn_t<3>, uintn_t<3>>>());\n+  test_binary_random<TypeIntMirror<jint, juint>>(Operation<juint>(), Inference<TypeIntMirror<jint, juint>>());\n+  test_binary_random<TypeIntMirror<jlong, julong>>(Operation<julong>(), Inference<TypeIntMirror<jlong, julong>>());\n+}\n+\n+template <class U>\n+class OpAnd {\n+public:\n+  U operator()(U v1, U v2) const {\n+    return v1 & v2;\n+  }\n+};\n+\n+template <class CTP>\n+class InferAnd {\n+public:\n+  CTP operator()(CTP t1, CTP t2) const {\n+    return RangeInference::infer_and(t1, t2);\n+  }\n+};\n+\n+template <class U>\n+class OpOr {\n+public:\n+  U operator()(U v1, U v2) const {\n+    return v1 | v2;\n+  }\n+};\n+\n+template <class CTP>\n+class InferOr {\n+public:\n+  CTP operator()(CTP t1, CTP t2) const {\n+    return RangeInference::infer_or(t1, t2);\n+  }\n+};\n+\n+template <class U>\n+class OpXor {\n+public:\n+  U operator()(U v1, U v2) const {\n+    return v1 ^ v2;\n+  }\n+};\n+\n+template <class CTP>\n+class InferXor {\n+public:\n+  CTP operator()(CTP t1, CTP t2) const {\n+    return RangeInference::infer_xor(t1, t2);\n+  }\n+};\n+\n+TEST(opto, range_inference) {\n+  test_binary<OpAnd, InferAnd>();\n+  test_binary<OpOr, InferOr>();\n+  test_binary<OpXor, InferXor>();\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":389,"deletions":6,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"unittest.hpp\"\n-#include \"opto\/utilities\/xor.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\" \/\/ For jint, juint\n-\n-jint test_calc_max(const jint hi_0, const jint hi_1) {\n-  return xor_upper_bound_for_ranges<jint, juint>(hi_0, hi_1);\n-}\n-\n-jlong test_calc_max(const jlong hi_0, const jlong hi_1) {\n-  return xor_upper_bound_for_ranges<jlong, julong>(hi_0, hi_1);\n-}\n-\n-template <class S>\n-void test_xor_bounds(S hi_0, S hi_1, S val_0, S val_1) {\n-  ASSERT_GE(hi_0, 0);\n-  ASSERT_GE(hi_1, 0);\n-\n-  \/\/ Skip out-of-bounds values for convenience\n-  if (val_0 > hi_0 || val_0 < S(0) || val_1 > hi_1 || val_1 < S(0)) {\n-    return;\n-  }\n-\n-  S v = val_0 ^ val_1;\n-  S max = test_calc_max(hi_0, hi_1);\n-  EXPECT_LE(v, max);\n-}\n-\n-template <class S>\n-void test_sample_values(S hi_0, S hi_1) {\n-  for (S i = 0; i <= 3; i++) {\n-    for (S j = 0; j <= 3; j++) {\n-      \/\/ Some bit combinations near the low and high ends of the range\n-      test_xor_bounds(hi_0, hi_1, i, j);\n-      test_xor_bounds(hi_0, hi_1, hi_0 - i, hi_1 - j);\n-    }\n-  }\n-}\n-\n-template <class S>\n-void test_in_ranges(S lo, S hi){\n-  ASSERT_GE(lo, 0);\n-  ASSERT_LE(lo, hi);\n-\n-  for (S hi_0 = lo; hi_0 <= hi; hi_0++) {\n-    for (S hi_1 = hi_0; hi_1 <=hi; hi_1++) {\n-      test_sample_values(hi_0, hi_1);\n-    }\n-  }\n-}\n-\n-template <class S>\n-void test_exhaustive(S limit) {\n-  for (S hi_0 = 0; hi_0 <= limit; hi_0++) {\n-    for (S hi_1 = hi_0; hi_1 <= limit; hi_1++) {\n-      for (S val_0 = 0; val_0 <= hi_0; val_0++) {\n-        for (S val_1 = val_0; val_1 <= hi_1; val_1++) {\n-          test_xor_bounds(hi_0, hi_1, val_0, val_1);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-template <class S>\n-void exec_tests() {\n-  S top_bit = max_power_of_2<S>();\n-  S prev_bit = top_bit >> 1;\n-\n-  test_exhaustive<S>(15);\n-\n-  test_in_ranges<S>(top_bit - 1, top_bit);\n-  test_in_ranges<S>(prev_bit - 1, prev_bit);\n-}\n-\n-TEST_VM(opto, xor_max) {\n-  exec_tests<jint>();\n-  exec_tests<jlong>();\n-}\n","filename":"test\/hotspot\/gtest\/opto\/test_xor_node.cpp","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"}]}