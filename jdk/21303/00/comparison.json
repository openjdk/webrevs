{"files":[{"patch":"@@ -1468,6 +1468,9 @@\n-      if (!ik->equals(canonical_holder) || tj->offset() != offset) {\n-        if( is_known_inst ) {\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, nullptr, offset, to->instance_id());\n-        } else {\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, nullptr, offset);\n-        }\n+      assert(tj->offset() == offset, \"not change to offset expected\");\n+      bool xk = to->klass_is_exact();\n+      int instance_id = to->instance_id();\n+\n+      if (xk && ik->equals(canonical_holder)) {\n+        assert(tj == TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, offset, instance_id), \"exact type should be canonical type\");\n+      } else {\n+        assert(xk || !is_known_inst, \"Known instance should be exact type\");\n+        tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, is_known_inst, nullptr, offset, instance_id);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1559,0 +1559,1 @@\n+  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n@@ -1588,0 +1589,1 @@\n+  assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2957,1 +2957,0 @@\n-    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n@@ -2960,2 +2959,2 @@\n-    access_store_at(nullptr, jt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-    access_store_at(nullptr, vt_addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n@@ -3323,1 +3322,3 @@\n-  Node* threadObj_epoch_raw = access_load_at(threadObj, threadObj_epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* threadObj_epoch_raw = access_load_at(threadObj, threadObj_epoch_offset,\n+                                             _gvn.type(threadObj_epoch_offset)->isa_ptr(),\n+                                             TypeInt::CHAR, T_CHAR,\n@@ -3342,1 +3343,2 @@\n-  Node* vthread_epoch_raw = access_load_at(vthread, vthread_epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* vthread_epoch_raw = access_load_at(vthread, vthread_epoch_offset, _gvn.type(vthread_epoch_offset)->is_ptr(),\n+                                           TypeInt::CHAR, T_CHAR,\n@@ -3588,1 +3590,1 @@\n-  Node* epoch_raw = access_load_at(thread, epoch_offset, TypeRawPtr::BOTTOM, TypeInt::CHAR, T_CHAR,\n+  Node* epoch_raw = access_load_at(thread, epoch_offset, _gvn.type(epoch_offset)->is_ptr(), TypeInt::CHAR, T_CHAR,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8340214\n+ * @summary C2 compilation asserts with \"no node with a side effect\" in PhaseIdealLoop::try_sink_out_of_loop\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestBadMemSliceWithInterfaces\n+ *\n+ *\/\n+\n+public class TestBadMemSliceWithInterfaces {\n+    public static void main(String[] args) {\n+        B b = new B();\n+        C c = new C();\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(b, c, true);\n+            test1(b, c, false);\n+            b.field = 0;\n+            c.field = 0;\n+            int res = test2(b, c, true);\n+            if (res != 42) {\n+                throw new RuntimeException(\"incorrect result \" + res);\n+            }\n+            res = test2(b, c, false);\n+            if (res != 42) {\n+                throw new RuntimeException(\"incorrect result \" + res);\n+            }\n+        }\n+    }\n+\n+    private static void test1(B b, C c, boolean flag) {\n+        A a;\n+        if (flag) {\n+           a = b;\n+        } else {\n+            a = c;\n+        }\n+        for (int i = 0; i < 1000; i++) {\n+            a.field = 42;\n+        }\n+    }\n+\n+    private static int test2(B b, C c, boolean flag) {\n+        A a;\n+        if (flag) {\n+           a = b;\n+        } else {\n+            a = c;\n+        }\n+        int v = 0;\n+        for (int i = 0; i < 2; i++) {\n+            v += a.field;\n+            a.field = 42;\n+        }\n+        return v;\n+    }\n+\n+    interface I {\n+        void m();\n+    }\n+\n+    static class A {\n+        int field;\n+    }\n+\n+    static class B extends A implements I {\n+        @Override\n+        public void m() {\n+\n+        }\n+    }\n+\n+    static class C extends A implements I {\n+        @Override\n+        public void m() {\n+\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestBadMemSliceWithInterfaces.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}