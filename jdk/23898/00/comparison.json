{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @ignore this test does not work any more as the TLS spec changes the\n- *         behaviors of close_notify.\n+ * @comment this test does not work in TLSv1.3 as the spec changes the\n+ *          behaviors of close_notify.\n@@ -35,1 +35,4 @@\n- * @run main\/othervm NonAutoClose\n+ * @library \/test\/lib\n+ * @run main\/othervm NonAutoClose TLSv1\n+ * @run main\/othervm NonAutoClose TLSv1.1\n+ * @run main\/othervm NonAutoClose TLSv1.2\n@@ -40,0 +43,1 @@\n+import java.net.InetAddress;\n@@ -42,0 +46,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -43,2 +49,0 @@\n-import java.security.cert.X509Certificate;\n-import java.security.cert.CertificateException;\n@@ -46,0 +50,1 @@\n+import jdk.test.lib.security.SecurityUtils;\n@@ -48,12 +53,0 @@\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n-\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    private static boolean separateServerThread = true;\n@@ -68,1 +61,0 @@\n-    private final static char[] cpasswd = \"passphrase\".toCharArray();\n@@ -73,1 +65,1 @@\n-    volatile static boolean serverReady = false;\n+    private static final CountDownLatch SERVER_READY = new CountDownLatch(1);\n@@ -79,2 +71,1 @@\n-    private final static boolean VERBOSE = true;\n-    private final static int NUM_ITERATIONS  = 10;\n+    private final static int NUM_ITERATIONS = 10;\n@@ -86,13 +77,1 @@\n-    \/*\n-     * If the client or server is doing some kind of object creation\n-     * that the other side depends on, and that thread prematurely\n-     * exits, you may experience a hang.  The test harness will\n-     * terminate all hung threads after its timeout has expired,\n-     * currently 3 minutes by default, but you might try to be\n-     * smart about it....\n-     *\/\n-\n-    void expectValue(int got, int expected, String msg) throws IOException {\n-        if (VERBOSE) {\n-            System.err.println(msg + \": read (\" + got + \")\");\n-        }\n+    private void expectValue(int got, int expected, String msg) throws IOException {\n@@ -108,3 +87,0 @@\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n@@ -112,9 +88,2 @@\n-\n-     void doServerSide() throws Exception {\n-        if (VERBOSE) {\n-            System.err.println(\"Starting server\");\n-        }\n-\n-        \/*\n-         * Setup the SSL stuff\n-         *\/\n+    private void doServerSide() throws Exception {\n+        System.out.println(\"Starting server\");\n@@ -122,3 +91,1 @@\n-             (SSLSocketFactory) SSLSocketFactory.getDefault();\n-\n-        ServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n+                (SSLSocketFactory) SSLSocketFactory.getDefault();\n@@ -126,1 +93,2 @@\n-        SERVER_PORT = serverSocket.getLocalPort();\n+        try (ServerSocket serverSocket = new ServerSocket(SERVER_PORT)) {\n+            SERVER_PORT = serverSocket.getLocalPort();\n@@ -128,4 +96,5 @@\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n+            \/*\n+             * Signal Client, we're ready for his connect.\n+             *\/\n+            System.out.println(\"Signal server ready\");\n+            SERVER_READY.countDown();\n@@ -133,3 +102,3 @@\n-        Socket plainSocket = serverSocket.accept();\n-        InputStream is = plainSocket.getInputStream();\n-        OutputStream os = plainSocket.getOutputStream();\n+            try (Socket plainSocket = serverSocket.accept();\n+                 InputStream is = plainSocket.getInputStream();\n+                 OutputStream os = plainSocket.getOutputStream()) {\n@@ -137,1 +106,1 @@\n-        expectValue(is.read(), PLAIN_CLIENT_VAL, \"Server\");\n+                expectValue(is.read(), PLAIN_CLIENT_VAL, \"Server\");\n@@ -139,2 +108,2 @@\n-        os.write(PLAIN_SERVER_VAL);\n-        os.flush();\n+                os.write(PLAIN_SERVER_VAL);\n+                os.flush();\n@@ -142,5 +111,5 @@\n-        for (int i = 1; i <= NUM_ITERATIONS; i++) {\n-            if (VERBOSE) {\n-                System.err.println(\"=================================\");\n-                System.err.println(\"Server Iteration #\" + i);\n-            }\n+                for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                    if (DEBUG) {\n+                        System.out.println(\"=================================\");\n+                        System.out.println(\"Server Iteration #\" + i);\n+                    }\n@@ -148,2 +117,3 @@\n-            SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n-                SERVER_NAME, plainSocket.getPort(), false);\n+                    try (SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n+                            plainSocket.getInetAddress().getHostName(),\n+                            plainSocket.getPort(), false)) {\n@@ -151,3 +121,4 @@\n-            ssls.setUseClientMode(false);\n-            InputStream sslis = ssls.getInputStream();\n-            OutputStream sslos = ssls.getOutputStream();\n+                        ssls.setEnabledProtocols(new String[]{protocol});\n+                        ssls.setUseClientMode(false);\n+                        try (InputStream sslis = ssls.getInputStream();\n+                             OutputStream sslos = ssls.getOutputStream()) {\n@@ -155,1 +126,1 @@\n-            expectValue(sslis.read(), TLS_CLIENT_VAL, \"Server\");\n+                            expectValue(sslis.read(), TLS_CLIENT_VAL, \"Server\");\n@@ -157,2 +128,5 @@\n-            sslos.write(TLS_SERVER_VAL);\n-            sslos.flush();\n+                            sslos.write(TLS_SERVER_VAL);\n+                            sslos.flush();\n+                        }\n+                    }\n+                }\n@@ -160,3 +134,1 @@\n-            sslis.close();\n-            sslos.close();\n-            ssls.close();\n+                expectValue(is.read(), PLAIN_CLIENT_VAL, \"Server\");\n@@ -164,2 +136,2 @@\n-            if (VERBOSE) {\n-                System.err.println(\"TLS socket is closed\");\n+                os.write(PLAIN_SERVER_VAL);\n+                os.flush();\n@@ -168,13 +140,0 @@\n-\n-        expectValue(is.read(), PLAIN_CLIENT_VAL, \"Server\");\n-\n-        os.write(PLAIN_SERVER_VAL);\n-        os.flush();\n-\n-        is.close();\n-        os.close();\n-        plainSocket.close();\n-\n-        if (VERBOSE) {\n-            System.err.println(\"Server plain socket is closed\");\n-        }\n@@ -185,3 +144,0 @@\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n@@ -193,6 +149,3 @@\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        if (VERBOSE) {\n-            System.err.println(\"Starting client\");\n+        System.out.println(\"Waiting for server ready\");\n+        if (!SERVER_READY.await(5, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"Server is not ready within 5 seconds.\");\n@@ -201,3 +154,0 @@\n-        \/*\n-         * Setup the SSL stuff\n-         *\/\n@@ -205,5 +155,1 @@\n-             (SSLSocketFactory) SSLSocketFactory.getDefault();\n-\n-        Socket plainSocket = new Socket(SERVER_NAME, SERVER_PORT);\n-        InputStream is = plainSocket.getInputStream();\n-        OutputStream os = plainSocket.getOutputStream();\n+                (SSLSocketFactory) SSLSocketFactory.getDefault();\n@@ -211,2 +157,3 @@\n-        os.write(PLAIN_CLIENT_VAL);\n-        os.flush();\n+        try (Socket plainSocket = new Socket(InetAddress.getLocalHost(), SERVER_PORT);\n+             InputStream is = plainSocket.getInputStream();\n+             OutputStream os = plainSocket.getOutputStream()) {\n@@ -214,1 +161,2 @@\n-        expectValue(is.read(), PLAIN_SERVER_VAL, \"Client\");\n+            os.write(PLAIN_CLIENT_VAL);\n+            os.flush();\n@@ -216,5 +164,1 @@\n-        for (int i = 1; i <= NUM_ITERATIONS; i++) {\n-            if (VERBOSE) {\n-                System.err.println(\"===================================\");\n-                System.err.println(\"Client Iteration #\" + i);\n-              }\n+            expectValue(is.read(), PLAIN_SERVER_VAL, \"Client\");\n@@ -222,10 +166,10 @@\n-            SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n-               SERVER_NAME, plainSocket.getPort(), false);\n-\n-            ssls.setUseClientMode(true);\n-\n-            InputStream sslis = ssls.getInputStream();\n-            OutputStream sslos = ssls.getOutputStream();\n-\n-            sslos.write(TLS_CLIENT_VAL);\n-            sslos.flush();\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                if (DEBUG) {\n+                    System.out.println(\"===================================\");\n+                    System.out.println(\"Client Iteration #\" + i);\n+                }\n+                try (SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n+                        plainSocket.getInetAddress().getHostName(),\n+                        plainSocket.getPort(), false);\n+                     InputStream sslis = ssls.getInputStream();\n+                     OutputStream sslos = ssls.getOutputStream()) {\n@@ -233,1 +177,1 @@\n-            expectValue(sslis.read(), TLS_SERVER_VAL, \"Client\");\n+                    ssls.setUseClientMode(true);\n@@ -235,3 +179,2 @@\n-            sslis.close();\n-            sslos.close();\n-            ssls.close();\n+                    sslos.write(TLS_CLIENT_VAL);\n+                    sslos.flush();\n@@ -239,2 +182,2 @@\n-            if (VERBOSE) {\n-                System.err.println(\"Client TLS socket is closed\");\n+                    expectValue(sslis.read(), TLS_SERVER_VAL, \"Client\");\n+                }\n@@ -242,6 +185,0 @@\n-        }\n-\n-        os.write(PLAIN_CLIENT_VAL);\n-        os.flush();\n-\n-        expectValue(is.read(), PLAIN_SERVER_VAL, \"Client\");\n@@ -249,6 +186,3 @@\n-        is.close();\n-        os.close();\n-        plainSocket.close();\n-\n-        if (VERBOSE) {\n-            System.err.println(\"Client plain socket is closed\");\n+            os.write(PLAIN_CLIENT_VAL);\n+            os.flush();\n+            expectValue(is.read(), PLAIN_SERVER_VAL, \"Client\");\n@@ -264,3 +198,0 @@\n-    private final static String SERVER_NAME = \"localhost\";\n-\n-    private volatile Exception serverException = null;\n@@ -270,2 +201,2 @@\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + keyStoreFile;\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n+                    \"\/\" + keyStoreFile;\n@@ -273,3 +204,2 @@\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + trustStoreFile;\n-\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n+                    \"\/\" + trustStoreFile;\n@@ -277,1 +207,0 @@\n-   \/\/ Used for running test standalone\n@@ -279,0 +208,4 @@\n+        String protocol = args[0];\n+        if (\"TLSv1\".equals(protocol) || \"TLSv1.1\".equals(protocol)) {\n+            SecurityUtils.removeFromDisabledTlsAlgs(protocol);\n+        }\n@@ -290,1 +223,1 @@\n-        new NonAutoClose();\n+        new NonAutoClose(protocol);\n@@ -294,1 +227,1 @@\n-    private Thread serverThread = null;\n+    private final String protocol;\n@@ -301,8 +234,4 @@\n-    NonAutoClose() throws Exception {\n-        if (separateServerThread) {\n-            startServer(true);\n-            startClient(false);\n-        } else {\n-            startClient(true);\n-            startServer(false);\n-        }\n+    NonAutoClose(String protocol) throws Exception {\n+        this.protocol = protocol;\n+        startClient();\n+        doServerSide();\n@@ -313,5 +242,1 @@\n-        if (separateServerThread) {\n-            serverThread.join();\n-        } else {\n-            clientThread.join();\n-        }\n+        clientThread.join();\n@@ -319,11 +244,0 @@\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         *\n-         * If the main thread excepted, that propagates back\n-         * immediately.  If the other thread threw an exception, we\n-         * should report back.\n-         *\/\n-        if (serverException != null) {\n-            System.err.print(\"Server Exception:\");\n-            throw serverException;\n-        }\n@@ -336,43 +250,13 @@\n-    private void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            doServerSide();\n-        }\n-    }\n-\n-    private void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            doClientSide();\n-        }\n+    private void startClient() {\n+        clientThread = new Thread(() -> {\n+            try {\n+                doClientSide();\n+            } catch (Exception e) {\n+                \/*\n+                 * Our client thread just died.\n+                 *\/\n+                System.err.println(\"Client died...\");\n+                clientException = e;\n+            }\n+        });\n+        clientThread.start();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/NonAutoClose.java","additions":107,"deletions":223,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @ignore this test does not grant to work.  The handshake may have completed\n- *        when getSession() return.  Please update or remove this test case.\n+ * @library \/test\/lib\n@@ -34,1 +33,4 @@\n- * @run main\/othervm SetClientMode\n+ * @run main\/othervm SetClientMode TLSv1\n+ * @run main\/othervm SetClientMode TLSv1.1\n+ * @run main\/othervm SetClientMode TLSv1.2\n+ * @run main\/othervm SetClientMode TLSv1.3\n@@ -50,1 +52,0 @@\n-import java.io.*;\n@@ -53,0 +54,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -54,2 +57,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n+import jdk.test.lib.security.SecurityUtils;\n@@ -58,2 +60,2 @@\n-    private static String[] algorithms = {\"TLS\", \"SSL\", \"SSLv3\", \"TLS\"};\n-    volatile int serverPort = 0;\n+    private volatile int serverPort = 0;\n+    private static final CountDownLatch HANDSHAKE_COMPLETE = new CountDownLatch(1);\n@@ -64,9 +66,4 @@\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n-\n-    public SetClientMode() {\n-        \/\/ trivial constructor\n-    }\n+    private final static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n+    private final static String keyStoreFile = \"keystore\";\n+    private final static String trustStoreFile = \"truststore\";\n+    private final static String passwd = \"passphrase\";\n@@ -75,0 +72,5 @@\n+        String protocol = args[0];\n+\n+        if (\"TLSv1\".equals(protocol) || \"TLSv1.1\".equals(protocol)) {\n+            SecurityUtils.removeFromDisabledTlsAlgs(protocol);\n+        }\n@@ -87,7 +89,1 @@\n-        new SetClientMode().run();\n-    }\n-\n-    public void run() throws Exception {\n-        for (int i = 0; i < algorithms.length; i++) {\n-            testCombo( algorithms[i] );\n-        }\n+        new SetClientMode().run(protocol);\n@@ -96,3 +92,1 @@\n-    public void testCombo(String algorithm) throws Exception {\n-        Exception modeException = null ;\n-\n+    public void run(String protocol) throws Exception {\n@@ -101,41 +95,39 @@\n-            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();\n-        SSLServerSocket serverSocket =\n-            (SSLServerSocket)ssf.createServerSocket(serverPort);\n-        serverPort = serverSocket.getLocalPort();\n-\n-        \/\/ Create a client socket\n-        SSLSocketFactory sf = (SSLSocketFactory)SSLSocketFactory.getDefault();\n-        SSLSocket clientSocket = (SSLSocket)sf.createSocket(\n-                                InetAddress.getLocalHost(),\n-                                serverPort );\n-\n-        \/\/ Create a client which will use the SSLSocket to talk to the server\n-        SocketClient client = new SocketClient(clientSocket);\n-\n-        \/\/ Start the client and then accept any connection\n-        client.start();\n-\n-        SSLSocket connectedSocket = (SSLSocket)serverSocket.accept();\n-\n-        \/\/ force handshaking to complete\n-        connectedSocket.getSession();\n-\n-        try {\n-            \/\/ Now try invoking setClientMode() on one\n-            \/\/ or the other of our two sockets. We expect\n-            \/\/ to see an IllegalArgumentException because\n-            \/\/ handshaking has begun.\n-            clientSocket.setUseClientMode(false);\n-\n-            modeException = new Exception(\"no IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n-            System.out.println(\"succeeded, we can't set the client mode\");\n-        } catch (Exception e) {\n-            modeException = e;\n-        } finally {\n-            \/\/ Shut down.\n-            connectedSocket.close();\n-            serverSocket.close();\n-\n-            if (modeException != null) {\n-                throw modeException;\n+            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n+\n+        try (SSLServerSocket serverSocket =\n+                (SSLServerSocket) ssf.createServerSocket(serverPort)) {\n+            serverSocket.setEnabledProtocols(new String[]{ protocol });\n+            serverPort = serverSocket.getLocalPort();\n+\n+            \/\/ Create a client socket\n+            SSLSocketFactory sf = (SSLSocketFactory) SSLSocketFactory.getDefault();\n+\n+            try (SSLSocket clientSocket = (SSLSocket) sf.createSocket(\n+                    InetAddress.getLocalHost(),\n+                    serverPort)) {\n+\n+                \/\/ Create a client which will use the SSLSocket to talk to the server\n+                Client client = new Client(clientSocket);\n+\n+                \/\/ Start the client and then accept any connection\n+                client.start();\n+\n+                SSLSocket connectedSocket = (SSLSocket) serverSocket.accept();\n+\n+                \/\/ force handshaking to complete\n+                connectedSocket.getSession();\n+\n+                if (!HANDSHAKE_COMPLETE.await(5, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\"Handshake didn't complete within 5 seconds.\");\n+                }\n+\n+                try {\n+                    \/\/ Now try invoking setClientMode() on the client socket.\n+                    \/\/ We expect to see an IllegalArgumentException because\n+                    \/\/ handshaking has begun.\n+                    clientSocket.setUseClientMode(false);\n+\n+                    throw new RuntimeException(\"no IllegalArgumentException\");\n+                } catch (IllegalArgumentException iae) {\n+                    System.out.println(\"succeeded, we can't set the client mode\");\n+                }\n@@ -144,2 +136,0 @@\n-\n-        return;\n@@ -150,4 +140,2 @@\n-    class SocketClient extends Thread {\n-        SSLSocket clientsideSocket;\n-        Exception clientException = null;\n-        boolean done = false;\n+    static class Client extends Thread {\n+        private final SSLSocket socket;\n@@ -155,2 +143,2 @@\n-        public SocketClient( SSLSocket s ) {\n-            clientsideSocket = s;\n+        public Client(SSLSocket s) {\n+            socket = s;\n@@ -161,7 +149,3 @@\n-                clientsideSocket.startHandshake();\n-\n-                \/\/ If we were to invoke setUseClientMode()\n-                \/\/ here, the expected exception will happen.\n-                \/\/clientsideSocket.getSession();\n-                \/\/clientsideSocket.setUseClientMode( false );\n-            } catch ( Exception e ) {\n+                socket.startHandshake();\n+                HANDSHAKE_COMPLETE.countDown();\n+            } catch (Exception e) {\n@@ -169,8 +153,0 @@\n-                clientException = e;\n-            } finally {\n-                done = true;\n-                try {\n-                    clientsideSocket.close();\n-                } catch ( IOException e ) {\n-                    \/\/ eat it\n-                }\n@@ -178,9 +154,0 @@\n-            return;\n-        }\n-\n-        boolean isDone() {\n-            return done;\n-        }\n-\n-        Exception getException() {\n-            return clientException;\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SetClientMode.java","additions":68,"deletions":101,"binary":false,"changes":169,"status":"modified"}]}