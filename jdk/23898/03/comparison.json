{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @ignore this test does not work any more as the TLS spec changes the\n- *         behaviors of close_notify.\n+ * @comment this test does not work in TLSv1.3 as the spec changes the\n+ *          behaviors of close_notify.\n@@ -35,1 +35,4 @@\n- * @run main\/othervm NonAutoClose\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n+ * @run main\/othervm NonAutoClose TLSv1\n+ * @run main\/othervm NonAutoClose TLSv1.1\n+ * @run main\/othervm NonAutoClose TLSv1.2\n@@ -40,0 +43,1 @@\n+import java.net.InetAddress;\n@@ -42,0 +46,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -43,2 +48,0 @@\n-import java.security.cert.X509Certificate;\n-import java.security.cert.CertificateException;\n@@ -46,0 +49,1 @@\n+import jdk.test.lib.security.SecurityUtils;\n@@ -47,6 +51,1 @@\n-public class NonAutoClose {\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n+import static jdk.test.lib.Asserts.assertEquals;\n@@ -54,15 +53,1 @@\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    private static boolean separateServerThread = true;\n-\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    private final static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private final static String keyStoreFile = \"keystore\";\n-    private final static String trustStoreFile = \"truststore\";\n-    private final static String passwd = \"passphrase\";\n-    private final static char[] cpasswd = \"passphrase\".toCharArray();\n+public class NonAutoClose extends SSLContextTemplate {\n@@ -73,1 +58,1 @@\n-    volatile static boolean serverReady = false;\n+    private static final CountDownLatch SERVER_READY = new CountDownLatch(1);\n@@ -78,3 +63,2 @@\n-    private final static boolean DEBUG = false;\n-    private final static boolean VERBOSE = true;\n-    private final static int NUM_ITERATIONS  = 10;\n+    private final static boolean DEBUG = Boolean.getBoolean(\"test.debug\");\n+    private final static int NUM_ITERATIONS = 10;\n@@ -86,20 +70,0 @@\n-    \/*\n-     * If the client or server is doing some kind of object creation\n-     * that the other side depends on, and that thread prematurely\n-     * exits, you may experience a hang.  The test harness will\n-     * terminate all hung threads after its timeout has expired,\n-     * currently 3 minutes by default, but you might try to be\n-     * smart about it....\n-     *\/\n-\n-    void expectValue(int got, int expected, String msg) throws IOException {\n-        if (VERBOSE) {\n-            System.err.println(msg + \": read (\" + got + \")\");\n-        }\n-        if (got != expected) {\n-            throw new IOException(msg + \": read (\" + got\n-                + \") but expecting(\" + expected + \")\");\n-        }\n-    }\n-\n-\n@@ -108,3 +72,0 @@\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n@@ -112,0 +73,3 @@\n+    private void doServerSide() throws Exception {\n+        System.out.println(\"Starting server\");\n+        SSLSocketFactory sslsf = createServerSSLContext().getSocketFactory();\n@@ -113,4 +77,2 @@\n-     void doServerSide() throws Exception {\n-        if (VERBOSE) {\n-            System.err.println(\"Starting server\");\n-        }\n+        try (ServerSocket serverSocket = new ServerSocket(SERVER_PORT)) {\n+            SERVER_PORT = serverSocket.getLocalPort();\n@@ -118,5 +80,5 @@\n-        \/*\n-         * Setup the SSL stuff\n-         *\/\n-        SSLSocketFactory sslsf =\n-             (SSLSocketFactory) SSLSocketFactory.getDefault();\n+            \/*\n+             * Signal Client, we're ready for his connect.\n+             *\/\n+            System.out.println(\"Signal server ready\");\n+            SERVER_READY.countDown();\n@@ -124,1 +86,3 @@\n-        ServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n+            try (Socket plainSocket = serverSocket.accept();\n+                 InputStream is = plainSocket.getInputStream();\n+                 OutputStream os = plainSocket.getOutputStream()) {\n@@ -126,1 +90,1 @@\n-        SERVER_PORT = serverSocket.getLocalPort();\n+                assertEquals(PLAIN_CLIENT_VAL, is.read());\n@@ -128,4 +92,2 @@\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n+                os.write(PLAIN_SERVER_VAL);\n+                os.flush();\n@@ -133,14 +95,5 @@\n-        Socket plainSocket = serverSocket.accept();\n-        InputStream is = plainSocket.getInputStream();\n-        OutputStream os = plainSocket.getOutputStream();\n-\n-        expectValue(is.read(), PLAIN_CLIENT_VAL, \"Server\");\n-\n-        os.write(PLAIN_SERVER_VAL);\n-        os.flush();\n-\n-        for (int i = 1; i <= NUM_ITERATIONS; i++) {\n-            if (VERBOSE) {\n-                System.err.println(\"=================================\");\n-                System.err.println(\"Server Iteration #\" + i);\n-            }\n+                for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                    if (DEBUG) {\n+                        System.out.println(\"=================================\");\n+                        System.out.println(\"Server Iteration #\" + i);\n+                    }\n@@ -148,2 +101,3 @@\n-            SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n-                SERVER_NAME, plainSocket.getPort(), false);\n+                    try (SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n+                            plainSocket.getInetAddress().getHostName(),\n+                            plainSocket.getPort(), false)) {\n@@ -151,3 +105,4 @@\n-            ssls.setUseClientMode(false);\n-            InputStream sslis = ssls.getInputStream();\n-            OutputStream sslos = ssls.getOutputStream();\n+                        ssls.setEnabledProtocols(new String[]{protocol});\n+                        ssls.setUseClientMode(false);\n+                        try (InputStream sslis = ssls.getInputStream();\n+                             OutputStream sslos = ssls.getOutputStream()) {\n@@ -155,1 +110,1 @@\n-            expectValue(sslis.read(), TLS_CLIENT_VAL, \"Server\");\n+                            assertEquals(TLS_CLIENT_VAL, sslis.read());\n@@ -157,2 +112,5 @@\n-            sslos.write(TLS_SERVER_VAL);\n-            sslos.flush();\n+                            sslos.write(TLS_SERVER_VAL);\n+                            sslos.flush();\n+                        }\n+                    }\n+                }\n@@ -160,3 +118,1 @@\n-            sslis.close();\n-            sslos.close();\n-            ssls.close();\n+                assertEquals(PLAIN_CLIENT_VAL, is.read());\n@@ -164,2 +120,2 @@\n-            if (VERBOSE) {\n-                System.err.println(\"TLS socket is closed\");\n+                os.write(PLAIN_SERVER_VAL);\n+                os.flush();\n@@ -168,13 +124,0 @@\n-\n-        expectValue(is.read(), PLAIN_CLIENT_VAL, \"Server\");\n-\n-        os.write(PLAIN_SERVER_VAL);\n-        os.flush();\n-\n-        is.close();\n-        os.close();\n-        plainSocket.close();\n-\n-        if (VERBOSE) {\n-            System.err.println(\"Server plain socket is closed\");\n-        }\n@@ -185,3 +128,0 @@\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n@@ -193,20 +133,2 @@\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        if (VERBOSE) {\n-            System.err.println(\"Starting client\");\n-        }\n-\n-        \/*\n-         * Setup the SSL stuff\n-         *\/\n-        SSLSocketFactory sslsf =\n-             (SSLSocketFactory) SSLSocketFactory.getDefault();\n-\n-        Socket plainSocket = new Socket(SERVER_NAME, SERVER_PORT);\n-        InputStream is = plainSocket.getInputStream();\n-        OutputStream os = plainSocket.getOutputStream();\n-\n-        os.write(PLAIN_CLIENT_VAL);\n-        os.flush();\n+        System.out.println(\"Waiting for server ready\");\n+        SERVER_READY.await();\n@@ -214,1 +136,1 @@\n-        expectValue(is.read(), PLAIN_SERVER_VAL, \"Client\");\n+        SSLSocketFactory sslsf = createClientSSLContext().getSocketFactory();\n@@ -216,5 +138,3 @@\n-        for (int i = 1; i <= NUM_ITERATIONS; i++) {\n-            if (VERBOSE) {\n-                System.err.println(\"===================================\");\n-                System.err.println(\"Client Iteration #\" + i);\n-              }\n+        try (Socket plainSocket = new Socket(InetAddress.getLocalHost(), SERVER_PORT);\n+             InputStream is = plainSocket.getInputStream();\n+             OutputStream os = plainSocket.getOutputStream()) {\n@@ -222,2 +142,2 @@\n-            SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n-               SERVER_NAME, plainSocket.getPort(), false);\n+            os.write(PLAIN_CLIENT_VAL);\n+            os.flush();\n@@ -225,1 +145,1 @@\n-            ssls.setUseClientMode(true);\n+            assertEquals(PLAIN_SERVER_VAL, is.read());\n@@ -227,5 +147,10 @@\n-            InputStream sslis = ssls.getInputStream();\n-            OutputStream sslos = ssls.getOutputStream();\n-\n-            sslos.write(TLS_CLIENT_VAL);\n-            sslos.flush();\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                if (DEBUG) {\n+                    System.out.println(\"===================================\");\n+                    System.out.println(\"Client Iteration #\" + i);\n+                }\n+                try (SSLSocket ssls = (SSLSocket) sslsf.createSocket(plainSocket,\n+                        plainSocket.getInetAddress().getHostName(),\n+                        plainSocket.getPort(), false);\n+                     InputStream sslis = ssls.getInputStream();\n+                     OutputStream sslos = ssls.getOutputStream()) {\n@@ -233,1 +158,1 @@\n-            expectValue(sslis.read(), TLS_SERVER_VAL, \"Client\");\n+                    ssls.setUseClientMode(true);\n@@ -235,3 +160,2 @@\n-            sslis.close();\n-            sslos.close();\n-            ssls.close();\n+                    sslos.write(TLS_CLIENT_VAL);\n+                    sslos.flush();\n@@ -239,2 +163,2 @@\n-            if (VERBOSE) {\n-                System.err.println(\"Client TLS socket is closed\");\n+                    assertEquals(TLS_SERVER_VAL, sslis.read());\n+                }\n@@ -242,1 +166,0 @@\n-        }\n@@ -244,11 +167,3 @@\n-        os.write(PLAIN_CLIENT_VAL);\n-        os.flush();\n-\n-        expectValue(is.read(), PLAIN_SERVER_VAL, \"Client\");\n-\n-        is.close();\n-        os.close();\n-        plainSocket.close();\n-\n-        if (VERBOSE) {\n-            System.err.println(\"Client plain socket is closed\");\n+            os.write(PLAIN_CLIENT_VAL);\n+            os.flush();\n+            assertEquals(PLAIN_SERVER_VAL, is.read());\n@@ -264,3 +179,0 @@\n-    private final static String SERVER_NAME = \"localhost\";\n-\n-    private volatile Exception serverException = null;\n@@ -269,9 +181,0 @@\n-    private final static String keyFilename =\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + keyStoreFile;\n-    private final static String trustFilename =\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + trustStoreFile;\n-\n-\n-   \/\/ Used for running test standalone\n@@ -279,4 +182,4 @@\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n+        String protocol = args[0];\n+        if (\"TLSv1\".equals(protocol) || \"TLSv1.1\".equals(protocol)) {\n+            SecurityUtils.removeFromDisabledTlsAlgs(protocol);\n+        }\n@@ -290,1 +193,1 @@\n-        new NonAutoClose();\n+        new NonAutoClose(protocol);\n@@ -294,1 +197,1 @@\n-    private Thread serverThread = null;\n+    private final String protocol;\n@@ -301,8 +204,4 @@\n-    NonAutoClose() throws Exception {\n-        if (separateServerThread) {\n-            startServer(true);\n-            startClient(false);\n-        } else {\n-            startClient(true);\n-            startServer(false);\n-        }\n+    NonAutoClose(String protocol) throws Exception {\n+        this.protocol = protocol;\n+        startClient();\n+        doServerSide();\n@@ -313,5 +212,1 @@\n-        if (separateServerThread) {\n-            serverThread.join();\n-        } else {\n-            clientThread.join();\n-        }\n+        clientThread.join();\n@@ -319,11 +214,0 @@\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         *\n-         * If the main thread excepted, that propagates back\n-         * immediately.  If the other thread threw an exception, we\n-         * should report back.\n-         *\/\n-        if (serverException != null) {\n-            System.err.print(\"Server Exception:\");\n-            throw serverException;\n-        }\n@@ -336,43 +220,13 @@\n-    private void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            doServerSide();\n-        }\n-    }\n-\n-    private void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            doClientSide();\n-        }\n+    private void startClient() {\n+        clientThread = new Thread(() -> {\n+            try {\n+                doClientSide();\n+            } catch (Exception e) {\n+                \/*\n+                 * Our client thread just died.\n+                 *\/\n+                System.err.println(\"Client died...\");\n+                clientException = e;\n+            }\n+        });\n+        clientThread.start();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/NonAutoClose.java","additions":103,"deletions":249,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @ignore this test does not grant to work.  The handshake may have completed\n- *        when getSession() return.  Please update or remove this test case.\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -34,1 +33,4 @@\n- * @run main\/othervm SetClientMode\n+ * @run main\/othervm SetClientMode TLSv1\n+ * @run main\/othervm SetClientMode TLSv1.1\n+ * @run main\/othervm SetClientMode TLSv1.2\n+ * @run main\/othervm SetClientMode TLSv1.3\n@@ -50,1 +52,0 @@\n-import java.io.*;\n@@ -53,0 +54,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -54,2 +56,1 @@\n-import java.security.*;\n-import java.security.cert.*;\n+import jdk.test.lib.security.SecurityUtils;\n@@ -57,3 +58,1 @@\n-public class SetClientMode {\n-    private static String[] algorithms = {\"TLS\", \"SSL\", \"SSLv3\", \"TLS\"};\n-    volatile int serverPort = 0;\n+import static jdk.test.lib.Asserts.assertThrows;\n@@ -61,12 +60,3 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n-\n-    public SetClientMode() {\n-        \/\/ trivial constructor\n-    }\n+public class SetClientMode extends SSLContextTemplate {\n+    private volatile int serverPort = 0;\n+    private static final CountDownLatch HANDSHAKE_COMPLETE = new CountDownLatch(1);\n@@ -75,14 +65,1 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n-        new SetClientMode().run();\n-    }\n+        String protocol = args[0];\n@@ -90,3 +67,2 @@\n-    public void run() throws Exception {\n-        for (int i = 0; i < algorithms.length; i++) {\n-            testCombo( algorithms[i] );\n+        if (\"TLSv1\".equals(protocol) || \"TLSv1.1\".equals(protocol)) {\n+            SecurityUtils.removeFromDisabledTlsAlgs(protocol);\n@@ -94,1 +70,0 @@\n-    }\n@@ -96,2 +71,2 @@\n-    public void testCombo(String algorithm) throws Exception {\n-        Exception modeException = null ;\n+        new SetClientMode().run(protocol);\n+    }\n@@ -99,0 +74,1 @@\n+    public void run(String protocol) throws Exception {\n@@ -100,42 +76,32 @@\n-        SSLServerSocketFactory ssf =\n-            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();\n-        SSLServerSocket serverSocket =\n-            (SSLServerSocket)ssf.createServerSocket(serverPort);\n-        serverPort = serverSocket.getLocalPort();\n-\n-        \/\/ Create a client socket\n-        SSLSocketFactory sf = (SSLSocketFactory)SSLSocketFactory.getDefault();\n-        SSLSocket clientSocket = (SSLSocket)sf.createSocket(\n-                                InetAddress.getLocalHost(),\n-                                serverPort );\n-\n-        \/\/ Create a client which will use the SSLSocket to talk to the server\n-        SocketClient client = new SocketClient(clientSocket);\n-\n-        \/\/ Start the client and then accept any connection\n-        client.start();\n-\n-        SSLSocket connectedSocket = (SSLSocket)serverSocket.accept();\n-\n-        \/\/ force handshaking to complete\n-        connectedSocket.getSession();\n-\n-        try {\n-            \/\/ Now try invoking setClientMode() on one\n-            \/\/ or the other of our two sockets. We expect\n-            \/\/ to see an IllegalArgumentException because\n-            \/\/ handshaking has begun.\n-            clientSocket.setUseClientMode(false);\n-\n-            modeException = new Exception(\"no IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n-            System.out.println(\"succeeded, we can't set the client mode\");\n-        } catch (Exception e) {\n-            modeException = e;\n-        } finally {\n-            \/\/ Shut down.\n-            connectedSocket.close();\n-            serverSocket.close();\n-\n-            if (modeException != null) {\n-                throw modeException;\n+        SSLServerSocketFactory ssf = createServerSSLContext().getServerSocketFactory();\n+\n+        try (SSLServerSocket serverSocket =\n+                (SSLServerSocket) ssf.createServerSocket(serverPort)) {\n+            serverSocket.setEnabledProtocols(new String[]{ protocol });\n+            serverPort = serverSocket.getLocalPort();\n+\n+            \/\/ Create a client socket\n+            SSLSocketFactory sf = createClientSSLContext().getSocketFactory();\n+\n+            try (SSLSocket clientSocket = (SSLSocket) sf.createSocket(\n+                    InetAddress.getLocalHost(),\n+                    serverPort)) {\n+\n+                \/\/ Create a client which will use the SSLSocket to talk to the server\n+                Client client = new Client(clientSocket);\n+\n+                \/\/ Start the client and then accept any connection\n+                client.start();\n+\n+                SSLSocket connectedSocket = (SSLSocket) serverSocket.accept();\n+\n+                \/\/ force handshaking to complete\n+                connectedSocket.getSession();\n+\n+                HANDSHAKE_COMPLETE.await();\n+\n+                \/\/ Now try invoking setClientMode() on the client socket.\n+                \/\/ We expect to see an IllegalArgumentException because\n+                \/\/ handshaking has begun.\n+                assertThrows(IllegalArgumentException.class,\n+                        () -> clientSocket.setUseClientMode(false));\n@@ -144,2 +110,0 @@\n-\n-        return;\n@@ -150,4 +114,2 @@\n-    class SocketClient extends Thread {\n-        SSLSocket clientsideSocket;\n-        Exception clientException = null;\n-        boolean done = false;\n+    static class Client extends Thread {\n+        private final SSLSocket socket;\n@@ -155,2 +117,2 @@\n-        public SocketClient( SSLSocket s ) {\n-            clientsideSocket = s;\n+        public Client(SSLSocket s) {\n+            socket = s;\n@@ -161,7 +123,3 @@\n-                clientsideSocket.startHandshake();\n-\n-                \/\/ If we were to invoke setUseClientMode()\n-                \/\/ here, the expected exception will happen.\n-                \/\/clientsideSocket.getSession();\n-                \/\/clientsideSocket.setUseClientMode( false );\n-            } catch ( Exception e ) {\n+                socket.startHandshake();\n+                HANDSHAKE_COMPLETE.countDown();\n+            } catch (Exception e) {\n@@ -169,8 +127,0 @@\n-                clientException = e;\n-            } finally {\n-                done = true;\n-                try {\n-                    clientsideSocket.close();\n-                } catch ( IOException e ) {\n-                    \/\/ eat it\n-                }\n@@ -178,9 +128,0 @@\n-            return;\n-        }\n-\n-        boolean isDone() {\n-            return done;\n-        }\n-\n-        Exception getException() {\n-            return clientException;\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SetClientMode.java","additions":57,"deletions":116,"binary":false,"changes":173,"status":"modified"}]}