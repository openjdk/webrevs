{"files":[{"patch":"@@ -2446,16 +2446,0 @@\n-  enc_class Push_ModD_encoding(regD src0, regD src1) %{\n-    __ subptr(rsp, 8);\n-    __ movdbl(Address(rsp, 0), $src1$$XMMRegister);\n-    __ fld_d(Address(rsp, 0));\n-    __ movdbl(Address(rsp, 0), $src0$$XMMRegister);\n-    __ fld_d(Address(rsp, 0));\n-  %}\n-\n-  enc_class Push_ModF_encoding(regF src0, regF src1) %{\n-    __ subptr(rsp, 4);\n-    __ movflt(Address(rsp, 0), $src1$$XMMRegister);\n-    __ fld_s(Address(rsp, 0));\n-    __ movflt(Address(rsp, 0), $src0$$XMMRegister);\n-    __ fld_s(Address(rsp, 0));\n-  %}\n-\n@@ -2493,14 +2477,0 @@\n-  enc_class Push_Result_Mod_DPR( regDPR src) %{\n-    if ($src$$reg != FPR1L_enc) {\n-      \/\/ fincstp\n-      emit_opcode (masm, 0xD9);\n-      emit_opcode (masm, 0xF7);\n-      \/\/ FXCH FPR1 with src\n-      emit_opcode(masm, 0xD9);\n-      emit_d8(masm, 0xC8-1+$src$$reg );\n-      \/\/ fdecstp\n-      emit_opcode (masm, 0xD9);\n-      emit_opcode (masm, 0xF6);\n-    }\n-  %}\n-\n@@ -2518,22 +2488,0 @@\n-  enc_class emitModDPR() %{\n-    \/\/ fprem must be iterative\n-    \/\/ :: loop\n-    \/\/ fprem\n-    emit_opcode( masm, 0xD9 );\n-    emit_opcode( masm, 0xF8 );\n-    \/\/ wait\n-    emit_opcode( masm, 0x9b );\n-    \/\/ fnstsw ax\n-    emit_opcode( masm, 0xDF );\n-    emit_opcode( masm, 0xE0 );\n-    \/\/ sahf\n-    emit_opcode( masm, 0x9E );\n-    \/\/ jp  ::loop\n-    emit_opcode( masm, 0x0F );\n-    emit_opcode( masm, 0x8A );\n-    emit_opcode( masm, 0xF4 );\n-    emit_opcode( masm, 0xFF );\n-    emit_opcode( masm, 0xFF );\n-    emit_opcode( masm, 0xFF );\n-  %}\n-\n@@ -9804,39 +9752,0 @@\n-instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{\n-  predicate(UseSSE<=1);\n-  match(Set dst (ModD dst src));\n-  effect(KILL rax, KILL cr); \/\/ emitModDPR() uses EAX and EFLAGS\n-\n-  format %{ \"DMOD   $dst,$src\" %}\n-  ins_cost(250);\n-  ins_encode(Push_Reg_Mod_DPR(dst, src),\n-              emitModDPR(),\n-              Push_Result_Mod_DPR(src),\n-              Pop_Reg_DPR(dst));\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{\n-  predicate(UseSSE>=2);\n-  match(Set dst (ModD src0 src1));\n-  effect(KILL rax, KILL cr);\n-\n-  format %{ \"SUB    ESP,8\\t # DMOD\\n\"\n-          \"\\tMOVSD  [ESP+0],$src1\\n\"\n-          \"\\tFLD_D  [ESP+0]\\n\"\n-          \"\\tMOVSD  [ESP+0],$src0\\n\"\n-          \"\\tFLD_D  [ESP+0]\\n\"\n-     \"loop:\\tFPREM\\n\"\n-          \"\\tFWAIT\\n\"\n-          \"\\tFNSTSW AX\\n\"\n-          \"\\tSAHF\\n\"\n-          \"\\tJP     loop\\n\"\n-          \"\\tFSTP_D [ESP+0]\\n\"\n-          \"\\tMOVSD  $dst,[ESP+0]\\n\"\n-          \"\\tADD    ESP,8\\n\"\n-          \"\\tFSTP   ST0\\t # Restore FPU Stack\"\n-    %}\n-  ins_cost(250);\n-  ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -10448,53 +10357,0 @@\n-\/\/ Spill to obtain 24-bit precision\n-instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{\n-  predicate( UseSSE==0 && Compile::current()->select_24_bit_instr());\n-  match(Set dst (ModF src1 src2));\n-  effect(KILL rax, KILL cr); \/\/ emitModDPR() uses EAX and EFLAGS\n-\n-  format %{ \"FMOD   $dst,$src1,$src2\" %}\n-  ins_encode( Push_Reg_Mod_DPR(src1, src2),\n-              emitModDPR(),\n-              Push_Result_Mod_DPR(src2),\n-              Pop_Mem_FPR(dst));\n-  ins_pipe( pipe_slow );\n-%}\n-\/\/\n-\/\/ This instruction does not round to 24-bits\n-instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{\n-  predicate( UseSSE==0 && !Compile::current()->select_24_bit_instr());\n-  match(Set dst (ModF dst src));\n-  effect(KILL rax, KILL cr); \/\/ emitModDPR() uses EAX and EFLAGS\n-\n-  format %{ \"FMOD   $dst,$src\" %}\n-  ins_encode(Push_Reg_Mod_DPR(dst, src),\n-              emitModDPR(),\n-              Push_Result_Mod_DPR(src),\n-              Pop_Reg_FPR(dst));\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{\n-  predicate(UseSSE>=1);\n-  match(Set dst (ModF src0 src1));\n-  effect(KILL rax, KILL cr);\n-  format %{ \"SUB    ESP,4\\t # FMOD\\n\"\n-          \"\\tMOVSS  [ESP+0],$src1\\n\"\n-          \"\\tFLD_S  [ESP+0]\\n\"\n-          \"\\tMOVSS  [ESP+0],$src0\\n\"\n-          \"\\tFLD_S  [ESP+0]\\n\"\n-     \"loop:\\tFPREM\\n\"\n-          \"\\tFWAIT\\n\"\n-          \"\\tFNSTSW AX\\n\"\n-          \"\\tSAHF\\n\"\n-          \"\\tJP     loop\\n\"\n-          \"\\tFSTP_S [ESP+0]\\n\"\n-          \"\\tMOVSS  $dst,[ESP+0]\\n\"\n-          \"\\tADD    ESP,4\\n\"\n-          \"\\tFSTP   ST0\\t # Restore FPU Stack\"\n-    %}\n-  ins_cost(250);\n-  ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":144,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -721,1 +721,3 @@\n-  if (phase->type(in(0)) == Type::TOP)  return Type::TOP;\n+  if (in(0) == nullptr || phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -45,0 +46,17 @@\n+ModFloatingNode::ModFloatingNode(Compile* C, const TypeFunc* tf, const char* name) : CallLeafNode(tf, nullptr, name, TypeRawPtr::BOTTOM) {\n+  add_flag(Flag_is_macro);\n+  C->add_macro_node(this);\n+}\n+\n+ModDNode::ModDNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::Math_DD_D_Type(), \"drem\") {\n+  init_req(TypeFunc::Parms + 0, a);\n+  init_req(TypeFunc::Parms + 1, C->top());\n+  init_req(TypeFunc::Parms + 2, b);\n+  init_req(TypeFunc::Parms + 3, C->top());\n+}\n+\n+ModFNode::ModFNode(Compile* C, Node* a, Node* b) : ModFloatingNode(C, OptoRuntime::modf_Type(), \"frem\") {\n+  init_req(TypeFunc::Parms + 0, a);\n+  init_req(TypeFunc::Parms + 1, b);\n+}\n+\n@@ -1380,0 +1398,3 @@\n+Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  return unsigned_mod_ideal<TypeLong, julong>(phase, can_reshape, this);\n+}\n@@ -1381,8 +1402,3 @@\n-\/\/=============================================================================\n-\/\/------------------------------Value------------------------------------------\n-const Type* ModFNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+const Type* UModLNode::Value(PhaseGVN* phase) const {\n+  return unsigned_mod_value<TypeLong, julong, jlong>(phase, this);\n+}\n@@ -1390,5 +1406,11 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+Node* ModFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!can_reshape) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(dividend());\n+  const Type* t2 = phase->type(divisor());\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return phase->C->top();\n+  }\n@@ -1398,1 +1420,1 @@\n-    return Type::FLOAT;         \/\/ note: x%x can be either NaN or 0\n+    return nullptr; \/\/ note: x%x can be either NaN or 0\n@@ -1403,2 +1425,2 @@\n-  jint  x1 = jint_cast(f1);     \/\/ note:  *(int*)&f1, not just (int)f1\n-  jint  x2 = jint_cast(f2);\n+  jint x1 = jint_cast(f1); \/\/ note:  *(int*)&f1, not just (int)f1\n+  jint x2 = jint_cast(f2);\n@@ -1407,2 +1429,6 @@\n-  if (g_isnan(f1))    return t1;\n-  if (g_isnan(f2))    return t2;\n+  if (g_isnan(f1)) {\n+    return replace_with_con(phase, t1);\n+  }\n+  if (g_isnan(f2)) {\n+    return replace_with_con(phase, t2);\n+  }\n@@ -1411,2 +1437,3 @@\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint)\n-    return Type::FLOAT;\n+  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint) {\n+    return nullptr;\n+  }\n@@ -1421,7 +1448,1 @@\n-  return TypeF::make(jfloat_cast(xr));\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Idealize---------------------------------------\n-Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  return unsigned_mod_ideal<TypeLong, julong>(phase, can_reshape, this);\n+  return replace_with_con(phase, TypeF::make(jfloat_cast(xr)));\n@@ -1430,3 +1451,4 @@\n-const Type* UModLNode::Value(PhaseGVN* phase) const {\n-  return unsigned_mod_value<TypeLong, julong, jlong>(phase, this);\n-}\n+Node* ModDNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (!can_reshape) {\n+    return nullptr;\n+  }\n@@ -1434,3 +1456,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Value------------------------------------------\n-const Type* ModDNode::Value(PhaseGVN* phase) const {\n@@ -1438,10 +1457,5 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n+  const Type* t1 = phase->type(dividend());\n+  const Type* t2 = phase->type(divisor());\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return nullptr;\n+  }\n@@ -1451,1 +1465,1 @@\n-    return Type::DOUBLE;        \/\/ note: x%x can be either NaN or 0\n+    return nullptr; \/\/ note: x%x can be either NaN or 0\n@@ -1456,2 +1470,2 @@\n-  jlong  x1 = jlong_cast(f1);   \/\/ note:  *(long*)&f1, not just (long)f1\n-  jlong  x2 = jlong_cast(f2);\n+  jlong x1 = jlong_cast(f1); \/\/ note:  *(long*)&f1, not just (long)f1\n+  jlong x2 = jlong_cast(f2);\n@@ -1460,2 +1474,6 @@\n-  if (g_isnan(f1))    return t1;\n-  if (g_isnan(f2))    return t2;\n+  if (g_isnan(f1)) {\n+    return replace_with_con(phase, t1);\n+  }\n+  if (g_isnan(f2)) {\n+    return replace_with_con(phase, t2);\n+  }\n@@ -1464,2 +1482,3 @@\n-  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong)\n-    return Type::DOUBLE;\n+  if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong) {\n+    return nullptr;\n+  }\n@@ -1474,1 +1493,30 @@\n-  return TypeD::make(jdouble_cast(xr));\n+  return replace_with_con(phase, TypeD::make(jdouble_cast(xr)));\n+}\n+\n+Node* ModFloatingNode::replace_with_con(PhaseGVN* phase, const Type* con) {\n+  Compile* C = phase->C;\n+  Node* con_node = phase->makecon(con);\n+  CallProjections projs;\n+  extract_projections(&projs, false, false);\n+  C->gvn_replace_by(projs.fallthrough_proj, in(TypeFunc::Control));\n+  if (projs.fallthrough_catchproj != nullptr) {\n+    C->gvn_replace_by(projs.fallthrough_catchproj, in(TypeFunc::Control));\n+  }\n+  if (projs.fallthrough_memproj != nullptr) {\n+    C->gvn_replace_by(projs.fallthrough_memproj, in(TypeFunc::Memory));\n+  }\n+  if (projs.catchall_memproj != nullptr) {\n+    C->gvn_replace_by(projs.catchall_memproj, C->top());\n+  }\n+  if (projs.fallthrough_ioproj != nullptr) {\n+    C->gvn_replace_by(projs.fallthrough_ioproj, in(TypeFunc::I_O));\n+  }\n+  assert(projs.catchall_ioproj == nullptr, \"no exceptions from floating mod\");\n+  assert(projs.catchall_catchproj == nullptr, \"no exceptions from floating mod\");\n+  if (projs.resproj != nullptr) {\n+    C->gvn_replace_by(projs.resproj, con_node);\n+  }\n+  C->gvn_replace_by(this, C->top());\n+  C->remove_macro_node(this);\n+  disconnect_inputs(C);\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":99,"deletions":51,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/callnode.hpp\"\n@@ -143,1 +144,9 @@\n-\/\/------------------------------ModFNode---------------------------------------\n+\/\/ Base class for float and double modulus\n+class ModFloatingNode : public CallLeafNode {\n+protected:\n+  Node* replace_with_con(PhaseGVN* phase, const Type* con);\n+\n+public:\n+  ModFloatingNode(Compile* C, const TypeFunc* tf, const char *name);\n+};\n+\n@@ -145,1 +154,5 @@\n-class ModFNode : public Node {\n+class ModFNode : public ModFloatingNode {\n+private:\n+  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n+  Node* divisor() const { return in(TypeFunc::Parms + 1); }\n+\n@@ -147,1 +160,1 @@\n-  ModFNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  ModFNode(Compile* C, Node* a, Node* b);\n@@ -149,2 +162,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n@@ -152,0 +163,2 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -154,1 +167,0 @@\n-\/\/------------------------------ModDNode---------------------------------------\n@@ -156,1 +168,5 @@\n-class ModDNode : public Node {\n+class ModDNode : public ModFloatingNode {\n+private:\n+  Node* dividend() const { return in(TypeFunc::Parms + 0); }\n+  Node* divisor() const { return in(TypeFunc::Parms + 2); }\n+\n@@ -158,1 +174,1 @@\n-  ModDNode( Node *c, Node *in1, Node *in2 ) : Node(c, in1, in2) {}\n+  ModDNode(Compile* C, Node* a, Node* b);\n@@ -160,2 +176,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n@@ -163,0 +177,2 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -6434,2 +6434,0 @@\n-    case Op_ModF:\n-    case Op_ModD:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2224,1 +2224,1 @@\n-  CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),\n+  CallNode* call = make_slow_call(lock, OptoRuntime::complete_monitor_enter_Type(),\n@@ -2433,0 +2433,2 @@\n+               n->Opcode() == Op_ModD ||\n+               n->Opcode() == Op_ModF ||\n@@ -2584,1 +2586,24 @@\n-      assert(false, \"unknown node type in macro list\");\n+      switch (n->Opcode()) {\n+      case Op_ModD:\n+      case Op_ModF: {\n+        bool is_drem = n->Opcode() == Op_ModD;\n+        CallNode* mod_macro = n->as_Call();\n+        CallNode* call = new CallLeafNode(mod_macro->tf(),\n+                                          is_drem ? CAST_FROM_FN_PTR(address, SharedRuntime::drem)\n+                                                  : CAST_FROM_FN_PTR(address, SharedRuntime::frem),\n+                                          is_drem ? \"drem\" : \"frem\", TypeRawPtr::BOTTOM);\n+        call->init_req(TypeFunc::Control, mod_macro->in(TypeFunc::Control));\n+        call->init_req(TypeFunc::I_O, mod_macro->in(TypeFunc::I_O));\n+        call->init_req(TypeFunc::Memory, mod_macro->in(TypeFunc::Memory));\n+        call->init_req(TypeFunc::ReturnAdr, mod_macro->in(TypeFunc::ReturnAdr));\n+        call->init_req(TypeFunc::FramePtr, mod_macro->in(TypeFunc::FramePtr));\n+        for (unsigned int i = 0; i < mod_macro->tf()->domain()->cnt() - TypeFunc::Parms; i++) {\n+          call->init_req(TypeFunc::Parms + i, mod_macro->in(TypeFunc::Parms + i));\n+        }\n+        _igvn.replace_node(mod_macro, call);\n+        transform_later(call);\n+        break;\n+      }\n+      default:\n+        assert(false, \"unknown node type in macro list\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -533,2 +533,1 @@\n-  void modf();\n-  void modd();\n+  Node* floating_point_mod(Node* a, Node* b, BasicType type);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1099,27 +1099,10 @@\n-void Parse::modf() {\n-  Node *f2 = pop();\n-  Node *f1 = pop();\n-  Node* c = make_runtime_call(RC_LEAF, OptoRuntime::modf_Type(),\n-                              CAST_FROM_FN_PTR(address, SharedRuntime::frem),\n-                              \"frem\", nullptr, \/\/no memory effects\n-                              f1, f2);\n-  Node* res = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));\n-\n-  push(res);\n-}\n-\n-void Parse::modd() {\n-  Node *d2 = pop_pair();\n-  Node *d1 = pop_pair();\n-  Node* c = make_runtime_call(RC_LEAF, OptoRuntime::Math_DD_D_Type(),\n-                              CAST_FROM_FN_PTR(address, SharedRuntime::drem),\n-                              \"drem\", nullptr, \/\/no memory effects\n-                              d1, top(), d2, top());\n-  Node* res_d   = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 0));\n-\n-#ifdef ASSERT\n-  Node* res_top = _gvn.transform(new ProjNode(c, TypeFunc::Parms + 1));\n-  assert(res_top == top(), \"second value must be top\");\n-#endif\n-\n-  push_pair(res_d);\n+Node* Parse::floating_point_mod(Node* a, Node* b, BasicType type) {\n+  assert(type == BasicType::T_FLOAT || type == BasicType::T_DOUBLE, \"only float and double are floating points\");\n+  CallNode* mod = type == BasicType::T_DOUBLE ? static_cast<CallNode*>(new ModDNode(C, a, b)) : new ModFNode(C, a, b);\n+\n+  Node* prev_mem = set_predefined_input_for_runtime_call(mod);\n+  mod = _gvn.transform(mod)->as_Call();\n+  set_predefined_output_for_runtime_call(mod, prev_mem, TypeRawPtr::BOTTOM);\n+  Node* result = _gvn.transform(new ProjNode(mod, TypeFunc::Parms + 0));\n+  record_for_igvn(mod);\n+  return result;\n@@ -2306,12 +2289,4 @@\n-    if (Matcher::has_match_rule(Op_ModF)) {\n-      \/\/ Generate a ModF node.\n-      b = pop();\n-      a = pop();\n-      c = _gvn.transform( new ModFNode(nullptr,a,b) );\n-      d = precision_rounding(c);\n-      push( d );\n-    }\n-    else {\n-      \/\/ Generate a call.\n-      modf();\n-    }\n+    \/\/ Generate a ModF node.\n+    b = pop();\n+    a = pop();\n+    push(floating_point_mod(a, b, BasicType::T_FLOAT));\n@@ -2439,14 +2414,4 @@\n-    if (Matcher::has_match_rule(Op_ModD)) {\n-      \/\/ Generate a ModD node.\n-      b = pop_pair();\n-      a = pop_pair();\n-      \/\/ a % b\n-\n-      c = _gvn.transform( new ModDNode(nullptr,a,b) );\n-      d = dprecision_rounding(c);\n-      push_pair( d );\n-    }\n-    else {\n-      \/\/ Generate a call.\n-      modd();\n-    }\n+    \/\/ Generate a ModD node.\n+    b = pop_pair();\n+    a = pop_pair();\n+    push_pair(floating_point_mod(a, b, BasicType::T_DOUBLE));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":18,"deletions":53,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UDivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ModDNodeTests\n+ *\/\n+public class ModDNodeTests {\n+    public static final double q = Utils.getRandomInstance().nextDouble() * 100.0d;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"notConstant\", \"veryNotConstant\"})\n+    public void runMethod() {\n+        Asserts.assertEQ(constant(), q % 72.0d % 30.0d);\n+        Asserts.assertEQ(alsoConstant(), q % 31.432d);\n+        Asserts.assertTrue(Double.isNaN(nanLeftConstant()));\n+        Asserts.assertTrue(Double.isNaN(nanRightConstant()));\n+        Asserts.assertEQ(notConstant(37.5d), 37.5d % 32.0d);\n+        Asserts.assertEQ(veryNotConstant(531.25d, 14.5d), 531.25d % 32.0d % 14.5d);\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_D, \"1\"})\n+    public double constant() {\n+        \/\/ All constants available during parsing\n+        return q % 72.0d % 30.0d;\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_D, \"1\"})\n+    public double alsoConstant() {\n+        \/\/ Make sure value is only available after second loop opts round\n+        double val = 0;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = q;\n+            }\n+        }\n+        return val % 31.432d;\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_D, \"1\"})\n+    public double nanLeftConstant() {\n+        \/\/ Make sure value is only available after second loop opts round\n+        double val = 134.18d;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = Double.NaN;\n+            }\n+        }\n+        return 56.234d % (val % 31.432d);\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"drem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_D, \"1\"})\n+    public double nanRightConstant() {\n+        \/\/ Make sure value is only available after second loop opts round\n+        double val = 134.18d;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = Double.NaN;\n+            }\n+        }\n+        return 56.234d % (31.432d % val);\n+    }\n+\n+    @Test\n+    @IR(counts = {\"drem\", \"1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_D, \"1\"})\n+    public double notConstant(double x) {\n+        return x % 32.0d;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"drem\", \"2\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_D, \"1\"})\n+    public double veryNotConstant(double x, double y) {\n+        return x % 32.0d % y;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModDNodeTests.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8332268\n+ * @summary Test that Ideal transformations of UDivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.ModFNodeTests\n+ *\/\n+public class ModFNodeTests {\n+    public static final float q = Utils.getRandomInstance().nextFloat() * 100.0f;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"notConstant\", \"veryNotConstant\"})\n+    public void runMethod() {\n+        Asserts.assertEQ(constant(), q % 72.0f % 30.0f);\n+        Asserts.assertEQ(alsoConstant(), q % 31.432f);\n+        Asserts.assertTrue(Float.isNaN(nanLeftConstant()));\n+        Asserts.assertTrue(Float.isNaN(nanRightConstant()));\n+        Asserts.assertEQ(notConstant(37.5f), 37.5f % 32.0f);\n+        Asserts.assertEQ(veryNotConstant(531.25f, 14.5f), 531.25f % 32.0f % 14.5f);\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_F, \"1\"})\n+    public float constant() {\n+        \/\/ All constants available during parsing\n+        return q % 72.0f % 30.0f;\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_F, \"1\"})\n+    public float alsoConstant() {\n+        \/\/ Make sure value is only available after second loop opts round\n+        float val = 0;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = q;\n+            }\n+        }\n+        return val % 31.432f;\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_F, \"1\"})\n+    public float nanLeftConstant() {\n+        \/\/ Make sure value is only available after second loop opts round\n+        float val = 134.18f;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = Float.NaN;\n+            }\n+        }\n+        return 56.234f % (val % 31.432f);\n+    }\n+\n+    @Test\n+    @IR(failOn = {\"frem\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_F, \"1\"})\n+    public float nanRightConstant() {\n+        \/\/ Make sure value is only available after second loop opts round\n+        float val = 134.18f;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = Float.NaN;\n+            }\n+        }\n+        return 56.234f % (31.432f % val);\n+    }\n+\n+    @Test\n+    @IR(counts = {\"frem\", \"1\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_F, \"1\"})\n+    public float notConstant(float x) {\n+        return x % 32.0f;\n+    }\n+\n+    @Test\n+    @IR(counts = {\"frem\", \"2\"}, phase = CompilePhase.BEFORE_MATCHING)\n+    @IR(counts = {IRNode.CON_F, \"1\"})\n+    public float veryNotConstant(float x, float y) {\n+        return x % 32.0f % y;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ModFNodeTests.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -551,0 +551,10 @@\n+    public static final String CON_D = PREFIX + \"CON_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_D, \"ConD\");\n+    }\n+\n+    public static final String CON_F = PREFIX + \"CON_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CON_F, \"ConF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}