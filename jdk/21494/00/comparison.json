{"files":[{"patch":"@@ -2654,0 +2654,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  Label flag_correct;\n+  beq(flag, flag_correct);\n+  stop(\"compiler_fast_lock_object: Flag != EQ\");\n+#endif\n@@ -2655,0 +2661,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  bne(flag, flag_correct);\n+  stop(\"compiler_fast_lock_object: Flag != NE\");\n+  bind(flag_correct);\n+#endif\n@@ -2704,6 +2716,0 @@\n-  ld(temp,             in_bytes(ObjectMonitor::owner_offset()), current_header);\n-\n-  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n-  \/\/ This is handled like owner thread mismatches: We take the slow path.\n-  cmpd(flag, temp, R16_thread);\n-  bne(flag, failure);\n@@ -2712,1 +2718,0 @@\n-\n@@ -2715,0 +2720,2 @@\n+\n+  \/\/ Recursive unlock\n@@ -2755,0 +2762,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  Label flag_correct;\n+  beq(flag, flag_correct);\n+  stop(\"compiler_fast_unlock_object: Flag != EQ\");\n+#endif\n@@ -2756,0 +2769,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  bne(flag, flag_correct);\n+  stop(\"compiler_fast_unlock_object: Flag != NE\");\n+  bind(flag_correct);\n+#endif\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"}]}