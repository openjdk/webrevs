{"files":[{"patch":"@@ -7083,0 +7083,93 @@\n+\n+\/\/ ----------------------------------------------------------------------\n+\/\/ We are using bitwise ternary logic insturction VPTERNLOG which can\n+\/\/ absorb complex binary expressions involving 3 boolean variables.\n+\/\/\n+\/\/ For copySign we set the truth table value as 0xE4.\n+\/\/ First column of truth table represents magnitude, second column\n+\/\/ represents sign operand while the third column is a conditional\n+\/\/ operand with fixed value of 0x7FFFFFFF.\n+\/\/\n+\/\/ Whenever condition bit is 1 corresponding magnitude bit gets selected\n+\/\/ else corresponding sign bit is picked.\n+\/\/ Our condition mask is such that apart for sign bit i.e. MSB bit all\n+\/\/ other bits are set to 1, this ensures that all the bits of result\n+\/\/ apart from MSB bit are copied from magnitude operand while sign bit\n+\/\/ is borrowed from sign operand.\n+\/\/\n+\/\/ Magnitude Sign Condition Result\n+\/\/ 0          0       0       0\n+\/\/ 0          0       1       0\n+\/\/ 0          1       0       1\n+\/\/ 0          1       1       0\n+\/\/ 1          0       0       0\n+\/\/ 1          0       1       1\n+\/\/ 1          1       0       1\n+\/\/ 1          1       1       1\n+\/\/\n+\/\/ ----------------------------------------------------------------------\n+\n+void C2_MacroAssembler::vector_copy_sign_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src,\n+                                              XMMRegister xtmp, int vlen_enc) {\n+  assert(is_floating_point_type(elem_bt), \"\");\n+  vpternlogq(xtmp, 0xFF, xtmp, xtmp, vlen_enc);\n+  if (elem_bt == T_FLOAT) {\n+    vpsrld(xtmp, xtmp, 1, vlen_enc);\n+    vpternlogd(dst, 0xE4, src, xtmp, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_DOUBLE, \"\");\n+    vpsrlq(xtmp, xtmp, 1, vlen_enc);\n+    vpternlogq(dst, 0xE4, src, xtmp, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vandpsd(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  if (elem_bt == T_FLOAT) {\n+    vandps(dst, src1, src2, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_DOUBLE, \"\");\n+    vandpd(dst, src1, src2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpslldq_imm(BasicType elem_bt, XMMRegister dst, XMMRegister src, int shift, int vlen_enc) {\n+  int elem_sz = type2aelembytes(elem_bt);\n+  if (elem_sz == 2) {\n+    vpsllw(dst, src, shift, vlen_enc);\n+  } else if (elem_sz == 4) {\n+    vpslld(dst, src, shift, vlen_enc);\n+  } else if (elem_sz == 8) {\n+    vpsllq(dst, src, shift, vlen_enc);\n+  } else {\n+    fatal(\"Unsupported lane size %s\", type2name(elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vpsrldq_imm(BasicType elem_bt, XMMRegister dst, XMMRegister src, int shift, int vlen_enc) {\n+  int elem_sz = type2aelembytes(elem_bt);\n+  if (elem_sz == 2) {\n+    vpsrlw(dst, src, shift, vlen_enc);\n+  } else if (elem_sz == 4) {\n+    vpsrld(dst, src, shift, vlen_enc);\n+  } else if (elem_sz == 8) {\n+    vpsrlq(dst, src, shift, vlen_enc);\n+  } else {\n+    fatal(\"Unsupported lane size %s\", type2name(elem_bt));\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_copy_sign_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp, int vlen_enc) {\n+  int sign_mask_shift = elem_bt == T_DOUBLE ? 63 : 31;\n+  \/\/ set all double lanes of temporary vector to 0xFFFFFFFF\n+  vcmpps(xtmp, xtmp, xtmp, Assembler::EQ_UQ, vlen_enc);\n+  \/\/ compute mask for magnitude bits i.e. 0x7FFFFFFFF\n+  vpsrldq_imm(elem_bt, xtmp, xtmp, 1, vlen_enc);\n+  \/\/ extract magnitude bits from destination lanes.\n+  vandpsd(elem_bt, dst, dst, xtmp, vlen_enc);\n+  \/\/ compute mask for sign bit i.e. 0x80000000\n+  vpslldq_imm(elem_bt, xtmp, xtmp, sign_mask_shift, vlen_enc);\n+  \/\/ extract sign bit from source lanes.\n+  vandpsd(elem_bt, xtmp, xtmp, src, vlen_enc);\n+  \/\/ merge extracted sign with magnitude bits.\n+  vpor(dst, dst, xtmp, vlen_enc);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -586,0 +586,9 @@\n+  void vandpsd(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vpsrldq_imm(BasicType elem_bt, XMMRegister dst, XMMRegister src, int shift, int vlen_enc);\n+\n+  void vpslldq_imm(BasicType elem_bt, XMMRegister dst, XMMRegister src, int shift, int vlen_enc);\n+\n+  void vector_copy_sign_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp, int vlen_enc);\n+\n+  void vector_copy_sign_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp, int vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1616,0 +1616,1 @@\n+      break;\n@@ -1770,0 +1771,6 @@\n+    case Op_CopySignVD:\n+    case Op_CopySignVF:\n+      if (UseAVX < 1 || !is_LP64)  {\n+        return false;\n+      }\n+      break;\n@@ -6710,28 +6717,0 @@\n-\/\/ ----------------------------------------------------------------------\n-\/\/ We are using bitwise ternary logic insturction VPTERNLOG which can\n-\/\/ absorb complex binary expressions involving 3 boolean variables.\n-\/\/\n-\/\/ For copySign we set the truth table value as 0xE4.\n-\/\/ First column of truth table represents magnitude, second column\n-\/\/ represents sign operand while the third column is a conditional\n-\/\/ operand with fixed value of 0x7FFFFFFF.\n-\/\/\n-\/\/ Whenever condition bit is 1 corresponding magnitude bit gets selected\n-\/\/ else corresponding sign bit is picked.\n-\/\/ Our condition mask is such that apart for sign bit i.e. MSB bit all\n-\/\/ other bits are set to 1, this ensures that all the bits of result\n-\/\/ apart from MSB bit are copied from magnitude operand while sign bit\n-\/\/ is borrowed from sign operand.\n-\/\/\n-\/\/ Magnitude Sign Condition Result\n-\/\/ 0          0       0       0\n-\/\/ 0          0       1       0\n-\/\/ 0          1       0       1\n-\/\/ 0          1       1       0\n-\/\/ 1          0       0       0\n-\/\/ 1          0       1       1\n-\/\/ 1          1       0       1\n-\/\/ 1          1       1       1\n-\/\/\n-\/\/ ----------------------------------------------------------------------\n-\n@@ -6745,3 +6724,1 @@\n-    __ vpternlogd($xtmp$$XMMRegister, 0xFF, $xtmp$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n-    __ vpsrld($xtmp$$XMMRegister, $xtmp$$XMMRegister, 1, Assembler::AVX_128bit);\n-    __ vpternlogd($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n+    __ vector_copy_sign_evex(T_FLOAT, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -6759,3 +6736,1 @@\n-    __ vpternlogq($xtmp$$XMMRegister, 0xFF, $xtmp$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n-    __ vpsrlq($xtmp$$XMMRegister, $xtmp$$XMMRegister, 1, Assembler::AVX_128bit);\n-    __ vpternlogq($dst$$XMMRegister, 0xE4, $src$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n+    __ vector_copy_sign_evex(T_DOUBLE, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -6768,1 +6743,1 @@\n-instruct copySignF_reg_avx(regF dst, regF src, regF xtmp1, regF xtmp2) %{\n+instruct copySignF_reg_avx(regF dst, regF src, regF xtmp) %{\n@@ -6771,2 +6746,2 @@\n-  effect(TEMP_DEF dst,TEMP xtmp1, TEMP xtmp2);\n-  format %{ \"CopySignF $dst, $src\\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  effect(TEMP_DEF dst,TEMP xtmp);\n+  format %{ \"CopySignF $dst, $src\\t! using $xtmp as TEMP\" %}\n@@ -6774,6 +6749,1 @@\n-    __ vpcmpeqd($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, $xtmp1$$XMMRegister, Assembler::AVX_128bit);\n-    __ vpsrld($xtmp2$$XMMRegister, $xtmp1$$XMMRegister, 1, Assembler::AVX_128bit);\n-    __ vpxor($xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp1$$XMMRegister, Assembler::AVX_128bit);\n-    __ vandps($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, $src$$XMMRegister, Assembler::AVX_128bit);\n-    __ vandps($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n-    __ vpor($dst$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, Assembler::AVX_128bit);\n+    __ vector_copy_sign_avx(T_FLOAT, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -6784,1 +6754,1 @@\n-instruct copySignD_imm_avx(regD dst, regD src, regD xtmp1, regD xtmp2, immD zero) %{\n+instruct copySignD_imm_avx(regD dst, regD src, regD xtmp, immD zero) %{\n@@ -6788,9 +6758,21 @@\n-  effect(TEMP_DEF dst,TEMP xtmp1, TEMP xtmp2);\n-  format %{ \"CopySignD  $dst, $src\\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n-  ins_encode %{\n-    __ vpcmpeqq($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, $xtmp1$$XMMRegister, Assembler::AVX_128bit);\n-    __ vpsrlq($xtmp2$$XMMRegister, $xtmp1$$XMMRegister, 1, Assembler::AVX_128bit);\n-    __ vpxor($xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp1$$XMMRegister, Assembler::AVX_128bit);\n-    __ vandpd($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, $src$$XMMRegister, Assembler::AVX_128bit);\n-    __ vandpd($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n-    __ vpor($dst$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, Assembler::AVX_128bit);\n+  effect(TEMP_DEF dst,TEMP xtmp);\n+  format %{ \"CopySignD  $dst, $src\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    __ vector_copy_sign_avx(T_DOUBLE, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct copySignV_reg(vec dst, vec src, vec xtmp) %{\n+  match(Set dst (CopySignVF dst src));\n+  match(Set dst (CopySignVD dst src));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_copysign $dst, $src\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(this) == 64) {\n+      __ vector_copy_sign_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n+    } else {\n+      __ vector_copy_sign_avx(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":35,"deletions":53,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -4367,1 +4367,1 @@\n-    \"MaskAll\", \"AndVMask\", \"OrVMask\", \"XorVMask\", \"VectorMaskCast\",\n+    \"MaskAll\", \"AndVMask\", \"OrVMask\", \"XorVMask\", \"VectorMaskCast\", \"CopySignVF\", \"CopySignVD\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,0 +339,2 @@\n+macro(CopySignVF)\n+macro(CopySignVD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,0 +159,3 @@\n+  } else if (opc == Op_CopySignD) {\n+    assert(p0->req() == 4, \"CopySignD should have 3 operands\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, pack_size);\n@@ -167,0 +170,1 @@\n+           opc == Op_CopySignF ||\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,0 +269,4 @@\n+  case Op_CopySignF:\n+    return Op_CopySignVF;\n+  case Op_CopySignD:\n+    return Op_CopySignVD;\n@@ -723,0 +727,3 @@\n+  case Op_CopySignVF: return new CopySignVFNode(n1, n2, vt);\n+  case Op_CopySignVD: return new CopySignVDNode(n1, n2, vt);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2018,0 +2018,16 @@\n+class CopySignVFNode : public VectorNode {\n+public:\n+  CopySignVFNode(Node* in1, Node* in2, const TypeVect* vt)\n+  : VectorNode(in1, in2, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class CopySignVDNode : public VectorNode {\n+public:\n+  CopySignVDNode(Node* in1, Node* in2, const TypeVect* vt)\n+  : VectorNode(in1, in2, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    @IR(counts = {IRNode.COPYSIGN_F, \" >0 \"}, applyIfCPUFeature = { \"avx\", \"true\"})\n+    @IR(counts = {IRNode.COPYSIGN_F, \" >0 \", IRNode.COPYSIGN_VF, \" >0 \"}, applyIfCPUFeature = { \"avx\", \"true\"})\n@@ -126,1 +126,1 @@\n-    @IR(counts = {IRNode.COPYSIGN_D, \" >0 \"}, applyIfCPUFeature = { \"avx\", \"true\"})\n+    @IR(counts = {IRNode.COPYSIGN_D, \" >0 \", IRNode.COPYSIGN_VD, \" >0 \"}, applyIfCPUFeature = { \"avx\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestCopySignIntrinsic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1604,0 +1604,10 @@\n+    public static final String COPYSIGN_VD = VECTOR_PREFIX + \"COPYSIGN_VD\" + POSTFIX;\n+    static {\n+        vectorNode(COPYSIGN_VD, \"CopySignVD\", TYPE_DOUBLE);\n+    }\n+\n+    public static final String COPYSIGN_VF = VECTOR_PREFIX + \"COPYSIGN_VF\" + POSTFIX;\n+    static {\n+        vectorNode(COPYSIGN_VF, \"CopySignVF\", TYPE_FLOAT);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}