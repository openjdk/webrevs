{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,0 +261,4 @@\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n+  return Aix::available_memory(value);\n+}\n+\n@@ -265,0 +269,4 @@\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n+  return Aix::available_memory(value);\n+}\n+\n@@ -276,0 +284,4 @@\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -285,0 +297,4 @@\n+  return Machine::free_swap_space(value);\n+}\n+\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n@@ -297,0 +313,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return Aix::physical_memory();\n+}\n+\n@@ -2267,0 +2287,4 @@\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,4 @@\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n+  return Bsd::available_memory(value);\n+}\n+\n@@ -144,0 +148,4 @@\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n+  return Bsd::available_memory(value);\n+}\n+\n@@ -184,0 +192,4 @@\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -198,0 +210,4 @@\n+  return Machine::free_swap_space(value);\n+}\n+\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n@@ -215,0 +231,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return Bsd::physical_memory();\n+}\n+\n@@ -2192,0 +2212,4 @@\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -634,4 +634,1 @@\n-bool CgroupSubsystem::active_processor_count(int& value) {\n-  int cpu_count;\n-  int result = -1;\n-\n+bool CgroupSubsystem::active_processor_count(double& value) {\n@@ -641,2 +638,2 @@\n-  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n-  CachedMetric* cpu_limit = contrl->metrics_cache();\n+  CachingCgroupController<CgroupCpuController, double>* contrl = cpu_controller();\n+  CachedMetric<double>* cpu_limit = contrl->metrics_cache();\n@@ -644,2 +641,2 @@\n-    value = (int)cpu_limit->value();\n-    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", value);\n+    value = cpu_limit->value();\n+    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %.2f\", value);\n@@ -649,1 +646,2 @@\n-  cpu_count = os::Linux::active_processor_count();\n+  int cpu_count = os::Linux::active_processor_count();\n+  double result = -1;\n@@ -674,2 +672,2 @@\n-  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n-  CachedMetric* memory_limit = contrl->metrics_cache();\n+  CachingCgroupController<CgroupMemoryController, physical_memory_size_type>* contrl = memory_controller();\n+  CachedMetric<physical_memory_size_type>* memory_limit = contrl->metrics_cache();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,1 @@\n+template <typename MetricType>\n@@ -186,1 +187,1 @@\n-    volatile physical_memory_size_type _metric;\n+    volatile MetricType _metric;\n@@ -196,2 +197,2 @@\n-    physical_memory_size_type value() { return _metric; }\n-    void set_value(physical_memory_size_type value, jlong timeout) {\n+    MetricType value() { return _metric; }\n+    void set_value(MetricType value, jlong timeout) {\n@@ -208,1 +209,1 @@\n-template <class T>\n+template <class T, typename MetricType>\n@@ -212,1 +213,1 @@\n-    CachedMetric* _metrics_cache;\n+    CachedMetric<MetricType>* _metrics_cache;\n@@ -217,1 +218,1 @@\n-      _metrics_cache = new CachedMetric();\n+      _metrics_cache = new CachedMetric<MetricType>();\n@@ -220,1 +221,1 @@\n-    CachedMetric* metrics_cache() { return _metrics_cache; }\n+    CachedMetric<MetricType>* metrics_cache() { return _metrics_cache; }\n@@ -280,1 +281,1 @@\n-    bool active_processor_count(int& value);\n+    bool active_processor_count(double& value);\n@@ -289,2 +290,2 @@\n-    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n-    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+    virtual CachingCgroupController<CgroupMemoryController, physical_memory_size_type>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController, double>* cpu_controller() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,1 @@\n-bool CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int upper_bound, int& value) {\n+bool CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int upper_bound, double& value) {\n@@ -30,1 +31,0 @@\n-  int limit_count = upper_bound;\n@@ -40,1 +40,1 @@\n-  int result = upper_bound;\n+  double result = upper_bound;\n@@ -42,3 +42,4 @@\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  if (quota > 0 && period > 0) { \/\/ Use quotas\n+    double cpu_quota = static_cast<double>(quota) \/ period;\n+    log_trace(os, container)(\"CPU Quota based on quota\/period: %.2f\", cpu_quota);\n+    result = MIN2(result, cpu_quota);\n@@ -47,7 +48,1 @@\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(upper_bound, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %.2f\", result);\n@@ -76,1 +71,1 @@\n-int CgroupUtil::get_updated_cpu_limit(CgroupCpuController* cpu,\n+double CgroupUtil::get_updated_cpu_limit(CgroupCpuController* cpu,\n@@ -80,1 +75,1 @@\n-  int cpu_limit_val = -1;\n+  double cpu_limit_val = -1;\n@@ -175,1 +170,1 @@\n-  int cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n+  double cpus = get_updated_cpu_limit(cpu, lowest_limit, host_cpus);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +35,1 @@\n-    static bool processor_count(CgroupCpuController* cpu, int upper_bound, int& value);\n+    static bool processor_count(CgroupCpuController* cpu, int upper_bound, double& value);\n@@ -45,3 +46,1 @@\n-    static int get_updated_cpu_limit(CgroupCpuController* c,\n-                                     int lowest,\n-                                     int upper_bound);\n+    static double get_updated_cpu_limit(CgroupCpuController* c, int lowest, int upper_bound);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,2 +331,2 @@\n-  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n-  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController, physical_memory_size_type>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController, double>(cpu);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,2 +217,2 @@\n-    CachingCgroupController<CgroupMemoryController>* memory_controller() override { return _memory; }\n-    CachingCgroupController<CgroupCpuController>* cpu_controller() override { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController, physical_memory_size_type>* memory_controller() override { return _memory; }\n+    CachingCgroupController<CgroupCpuController, double>* cpu_controller() override { return _cpu; }\n@@ -223,1 +223,1 @@\n-    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController, physical_memory_size_type>* _memory = nullptr;\n@@ -225,1 +225,1 @@\n-    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController, double>* _cpu = nullptr;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,2 +159,2 @@\n-  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n-  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController, physical_memory_size_type>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController, double>(cpu);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,2 +155,2 @@\n-    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n-    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController, physical_memory_size_type>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController, double>* _cpu = nullptr;\n@@ -178,2 +178,2 @@\n-    CachingCgroupController<CgroupMemoryController>* memory_controller() override { return _memory; }\n-    CachingCgroupController<CgroupCpuController>* cpu_controller() override { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController, physical_memory_size_type>* memory_controller() override { return _memory; }\n+    CachingCgroupController<CgroupCpuController, double>* cpu_controller() override { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,2 @@\n-    int host_cpus = os::Linux::active_processor_count();\n-    int cpus = host_cpus;\n+    double host_cpus = os::Linux::active_processor_count();\n+    double cpus = host_cpus;\n@@ -130,2 +130,1 @@\n-bool OSContainer::available_swap_in_bytes(physical_memory_size_type host_free_swap,\n-                                          physical_memory_size_type& value) {\n+bool OSContainer::available_swap_in_bytes(physical_memory_size_type& value) {\n@@ -182,2 +181,1 @@\n-                            \" container_mem_limit=%s, host_free_swap: \" PHYS_MEM_TYPE_FORMAT,\n-                            mem_swap_buf, mem_limit_buf, host_free_swap);\n+                            \" container_mem_limit=%s\", mem_swap_buf, mem_limit_buf);\n@@ -255,1 +253,1 @@\n-bool OSContainer::active_processor_count(int& value) {\n+bool OSContainer::active_processor_count(double& value) {\n@@ -294,0 +292,1 @@\n+template<> struct metric_fmt<double> { static constexpr const char* fmt = \"%.2f\"; };\n@@ -299,0 +298,1 @@\n+template void OSContainer::print_container_metric<double>(outputStream*, const char*, double, const char*);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,1 @@\n-  static bool available_swap_in_bytes(physical_memory_size_type host_free_swap,\n-                                      physical_memory_size_type& value);\n+  static bool available_swap_in_bytes(physical_memory_size_type& value);\n@@ -87,1 +86,1 @@\n-  static bool active_processor_count(int& value);\n+  static bool active_processor_count(double& value);\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -214,0 +214,35 @@\n+bool os::is_containerized() {\n+  return OSContainer::is_containerized();\n+}\n+\n+bool os::Container::memory_limit(physical_memory_size_type& value) {\n+  physical_memory_size_type result = 0;\n+  if (OSContainer::memory_limit_in_bytes(result) && result != value_unlimited) {\n+    value = result;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool os::Container::memory_soft_limit(physical_memory_size_type& value) {\n+  physical_memory_size_type result = 0;\n+  if (OSContainer::memory_soft_limit_in_bytes(result) && result != 0 && result != value_unlimited) {\n+    value = result;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool os::Container::memory_throttle_limit(physical_memory_size_type& value) {\n+  physical_memory_size_type result = 0;\n+  if (OSContainer::memory_throttle_limit_in_bytes(result) && result != value_unlimited) {\n+    value = result;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool os::Container::used_memory(physical_memory_size_type& value) {\n+  return OSContainer::memory_usage_in_bytes(value);\n+}\n+\n@@ -215,1 +250,1 @@\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_bytes(value)) {\n+  if (is_containerized() && Container::available_memory(value)) {\n@@ -220,0 +255,4 @@\n+  return Machine::available_memory(value);\n+}\n+\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n@@ -223,0 +262,4 @@\n+bool os::Container::available_memory(physical_memory_size_type& value) {\n+  return OSContainer::available_memory_in_bytes(value);\n+}\n+\n@@ -254,1 +297,1 @@\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_bytes(value)) {\n+  if (is_containerized() && Container::available_memory(value)) {\n@@ -259,0 +302,4 @@\n+  return Machine::free_memory(value);\n+}\n+\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n@@ -277,12 +324,7 @@\n-  if (OSContainer::is_containerized()) {\n-    physical_memory_size_type mem_swap_limit = value_unlimited;\n-    physical_memory_size_type memory_limit = value_unlimited;\n-    if (OSContainer::memory_and_swap_limit_in_bytes(mem_swap_limit) &&\n-        OSContainer::memory_limit_in_bytes(memory_limit)) {\n-      if (memory_limit != value_unlimited && mem_swap_limit != value_unlimited &&\n-          mem_swap_limit >= memory_limit \/* ensure swap is >= 0 *\/) {\n-        value = mem_swap_limit - memory_limit;\n-        return true;\n-      }\n-    }\n-  } \/\/ fallback to the host swap space if the container returned unlimited\n+  if (is_containerized() && Container::total_swap_space(value)) {\n+    return true;\n+  } \/\/ fallback to the host swap space if the container value fails\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -292,0 +334,14 @@\n+bool os::Container::total_swap_space(physical_memory_size_type& value) {\n+  physical_memory_size_type mem_swap_limit = value_unlimited;\n+  physical_memory_size_type memory_limit = value_unlimited;\n+  if (OSContainer::memory_and_swap_limit_in_bytes(mem_swap_limit) &&\n+      OSContainer::memory_limit_in_bytes(memory_limit)) {\n+    if (memory_limit != value_unlimited && mem_swap_limit != value_unlimited &&\n+        mem_swap_limit >= memory_limit \/* ensure swap is >= 0 *\/) {\n+      value = mem_swap_limit - memory_limit;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -312,2 +368,2 @@\n-  if (OSContainer::is_containerized()) {\n-    if (OSContainer::available_swap_in_bytes(host_free_swap_val, value)) {\n+  if (is_containerized()) {\n+    if (Container::free_swap_space(value)) {\n@@ -320,0 +376,1 @@\n+\n@@ -324,0 +381,8 @@\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n+  return host_free_swap_f(value);\n+}\n+\n+bool os::Container::free_swap_space(physical_memory_size_type& value) {\n+  return OSContainer::available_swap_in_bytes(value);\n+}\n+\n@@ -325,1 +390,1 @@\n-  if (OSContainer::is_containerized()) {\n+  if (is_containerized()) {\n@@ -327,1 +392,1 @@\n-    if (OSContainer::memory_limit_in_bytes(mem_limit) && mem_limit != value_unlimited) {\n+    if (Container::memory_limit(mem_limit) && mem_limit != value_unlimited) {\n@@ -333,1 +398,1 @@\n-  physical_memory_size_type phys_mem = Linux::physical_memory();\n+  physical_memory_size_type phys_mem = Machine::physical_memory();\n@@ -338,0 +403,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return Linux::physical_memory();\n+}\n+\n@@ -2442,2 +2511,2 @@\n-  int i = -1;\n-  bool supported = OSContainer::active_processor_count(i);\n+  double cpus = -1;\n+  bool supported = OSContainer::active_processor_count(cpus);\n@@ -2445,1 +2514,1 @@\n-    assert(i > 0, \"must be\");\n+    assert(cpus > 0, \"must be\");\n@@ -2449,1 +2518,1 @@\n-      OSContainer::print_container_metric(st, \"active_processor_count\", i);\n+      OSContainer::print_container_metric(st, \"active_processor_count\", cpus);\n@@ -2456,0 +2525,1 @@\n+  int i = -1;\n@@ -4740,6 +4810,9 @@\n-  int active_cpus = -1;\n-  if (OSContainer::is_containerized() && OSContainer::active_processor_count(active_cpus)) {\n-    log_trace(os)(\"active_processor_count: determined by OSContainer: %d\",\n-                   active_cpus);\n-  } else {\n-    active_cpus = os::Linux::active_processor_count();\n+  if (is_containerized()) {\n+    double cpu_quota;\n+    if (Container::processor_count(cpu_quota)) {\n+      int active_cpus = ceilf(cpu_quota); \/\/ Round fractional CPU quota up.\n+      assert(active_cpus <= Machine::active_processor_count(), \"must be\");\n+      log_trace(os)(\"active_processor_count: determined by OSContainer: %d\",\n+                     active_cpus);\n+      return active_cpus;\n+    }\n@@ -4748,1 +4821,9 @@\n-  return active_cpus;\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n+  return os::Linux::active_processor_count();\n+}\n+\n+bool os::Container::processor_count(double& value) {\n+  return OSContainer::active_processor_count(value);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":111,"deletions":30,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -842,0 +842,4 @@\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n+  return win32::available_memory(value);\n+}\n+\n@@ -846,0 +850,4 @@\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n+  return win32::available_memory(value);\n+}\n+\n@@ -861,1 +869,5 @@\n-bool os::total_swap_space(physical_memory_size_type& value) {\n+bool os::total_swap_space(physical_memory_size_type& value)  {\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -875,0 +887,4 @@\n+  return Machine::free_swap_space(value);\n+}\n+\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n@@ -891,0 +907,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return win32::physical_memory();\n+}\n+\n@@ -914,0 +934,4 @@\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,4 +69,0 @@\n-#ifdef LINUX\n-#include \"os_linux.hpp\"\n-#include \"osContainer_linux.hpp\"\n-#endif\n@@ -404,5 +400,1 @@\n-#ifdef LINUX\n-  return OSContainer::is_containerized();\n-#else\n-  return false;\n-#endif\n+  return os::is_containerized();\n@@ -412,7 +404,1 @@\n-#ifdef LINUX\n-  \/\/ We want the host memory, not the container limit.\n-  \/\/ os::physical_memory() would return the container limit.\n-  return static_cast<jlong>(os::Linux::physical_memory());\n-#else\n-  return static_cast<jlong>(os::physical_memory());\n-#endif\n+  return static_cast<jlong>(os::Machine::physical_memory());\n@@ -422,6 +408,0 @@\n-#ifdef LINUX\n-  \/\/ We want the host swap memory, not the container value.\n-  physical_memory_size_type host_swap = 0;\n-  (void)os::Linux::host_swap(host_swap); \/\/ Discard return value and treat as no swap\n-  return static_cast<jlong>(host_swap);\n-#else\n@@ -430,1 +410,1 @@\n-  (void)os::total_swap_space(total_swap_space);\n+  (void)os::Machine::total_swap_space(total_swap_space);\n@@ -432,1 +412,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,3 +118,0 @@\n-#ifdef LINUX\n-#include \"osContainer_linux.hpp\"\n-#endif\n@@ -503,2 +500,1 @@\n-#ifdef LINUX\n-  if (OSContainer::is_containerized()) {\n+  if (os::is_containerized()) {\n@@ -507,1 +503,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -2585,2 +2584,1 @@\n-  LINUX_ONLY(return OSContainer::is_containerized();)\n-  return false;\n+  return os::is_containerized();\n@@ -2591,2 +2589,1 @@\n-  LINUX_ONLY(return static_cast<jlong>(os::Linux::physical_memory());)\n-  return static_cast<jlong>(os::physical_memory());\n+  return static_cast<jlong>(os::Machine::physical_memory());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,4 +84,0 @@\n-#ifdef LINUX\n-#include \"osContainer_linux.hpp\"\n-#endif\n-\n@@ -2208,3 +2204,2 @@\n-#ifdef LINUX\n-  if (OSContainer::is_containerized()) {\n-    return OSContainer::memory_usage_in_bytes(value);\n+  if (is_containerized()) {\n+    return Container::used_memory(value);\n@@ -2212,1 +2207,5 @@\n-#endif\n+\n+  return Machine::used_memory(value);\n+}\n+\n+bool os::Machine::used_memory(physical_memory_size_type& value) {\n@@ -2221,0 +2220,38 @@\n+#ifndef LINUX\n+bool os::is_containerized() {\n+  return false;\n+}\n+\n+bool os::Container::processor_count(double& value) {\n+  return false;\n+}\n+\n+bool os::Container::available_memory(physical_memory_size_type& value) {\n+  return false;\n+}\n+\n+bool os::Container::used_memory(physical_memory_size_type& value) {\n+  return false;\n+}\n+\n+bool os::Container::total_swap_space(physical_memory_size_type& value) {\n+  return false;\n+}\n+\n+bool os::Container::free_swap_space(physical_memory_size_type& value) {\n+  return false;\n+}\n+\n+bool os::Container::memory_limit(physical_memory_size_type& value) {\n+  return false;\n+}\n+\n+bool os::Container::memory_soft_limit(physical_memory_size_type& value) {\n+  return false;\n+}\n+\n+bool os::Container::memory_throttle_limit(physical_memory_size_type& value) {\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,0 +345,46 @@\n+  \/\/ On platforms with container support (currently only Linux) we combine machine values with\n+  \/\/ potential container values in os:: methods, abstracting which value is actually used.\n+  \/\/ The os::Machine and os::Container classes and containing methods are used to get machine\n+  \/\/ and container values (when available) separately.\n+  static bool is_containerized();\n+\n+  \/\/ The os::Machine class reports system resource metrics from the perspective of the operating\n+  \/\/ system, without considering container-imposed limits. The values returned by these methods\n+  \/\/ reflect the resources visible to the process as reported by the OS, and may already be\n+  \/\/ affected by mechanisms such as virtualization, hypervisor limits, or process affinity,\n+  \/\/ but do NOT consider further restrictions imposed by container runtimes (e.g., cgroups)\n+  class Machine : AllStatic {\n+  public:\n+    static int active_processor_count();\n+\n+    [[nodiscard]] static bool available_memory(physical_memory_size_type& value);\n+    [[nodiscard]] static bool used_memory(physical_memory_size_type& value);\n+    [[nodiscard]] static bool free_memory(physical_memory_size_type& value);\n+\n+    [[nodiscard]] static bool total_swap_space(physical_memory_size_type& value);\n+    [[nodiscard]] static bool free_swap_space(physical_memory_size_type& value);\n+\n+    static physical_memory_size_type physical_memory();\n+  };\n+\n+  \/\/ The os::Container class reports resource limits as imposed by a supported container runtime\n+  \/\/ (currently only cgroup-based Linux runtimes). If the process is running inside a\n+  \/\/ containerized environment, methods from this class report the effective limits imposed\n+  \/\/ by the container, which may be more restrictive than what os::Machine reports.\n+  \/\/ Methods return true and set the out-parameter if a limit is found,\n+  \/\/ or false if no limit exists or it cannot be determined.\n+  class Container : AllStatic {\n+  public:\n+    [[nodiscard]] static bool processor_count(double& value); \/\/ Returns the core-equivalent CPU quota\n+\n+    [[nodiscard]] static bool available_memory(physical_memory_size_type& value);\n+    [[nodiscard]] static bool used_memory(physical_memory_size_type& value);\n+\n+    [[nodiscard]] static bool total_swap_space(physical_memory_size_type& value);\n+    [[nodiscard]] static bool free_swap_space(physical_memory_size_type& value);\n+\n+    [[nodiscard]] static bool memory_limit(physical_memory_size_type& value);\n+    [[nodiscard]] static bool memory_soft_limit(physical_memory_size_type& value);\n+    [[nodiscard]] static bool memory_throttle_limit(physical_memory_size_type& value);\n+  };\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,3 +146,3 @@\n-    private static int adjustExpectedAPCForAvailableCPUs(int expectedAPC) {\n-        if (expectedAPC > availableCPUs) {\n-            expectedAPC = availableCPUs;\n+    private static double adjustExpectedAPCForAvailableCPUs(double expectedAPC) {\n+        if (expectedAPC > (double)availableCPUs) {\n+            expectedAPC = (double)availableCPUs;\n@@ -161,1 +161,1 @@\n-        int expectedAPC = (int) Math.ceil((float) quota \/ (float) period);\n+        double expectedAPC = (double) quota \/ (double) period;\n@@ -181,1 +181,1 @@\n-                                     int expectedAPC) throws Exception {\n+                                     double expectedAPC) throws Exception {\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}