{"files":[{"patch":"@@ -261,0 +261,4 @@\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n+  return Aix::available_memory(value);\n+}\n+\n@@ -265,0 +269,4 @@\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n+  return Aix::available_memory(value);\n+}\n+\n@@ -276,0 +284,4 @@\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -285,0 +297,4 @@\n+  return Machine::free_swap_space(value);\n+}\n+\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n@@ -297,0 +313,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return Aix::physical_memory();\n+}\n+\n@@ -2262,0 +2282,4 @@\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -140,0 +140,4 @@\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n+  return Bsd::available_memory(value);\n+}\n+\n@@ -144,0 +148,4 @@\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n+  return Bsd::available_memory(value);\n+}\n+\n@@ -184,0 +192,4 @@\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -198,0 +210,4 @@\n+  return Machine::free_swap_space(value);\n+}\n+\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n@@ -215,0 +231,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return Bsd::physical_memory();\n+}\n+\n@@ -2103,0 +2123,4 @@\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -635,5 +635,1 @@\n-int CgroupSubsystem::active_processor_count() {\n-  int quota_count = 0;\n-  int cpu_count;\n-  int result;\n-\n+double CgroupSubsystem::active_processor_count() {\n@@ -643,2 +639,2 @@\n-  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n-  CachedMetric* cpu_limit = contrl->metrics_cache();\n+  CachingCgroupController<CgroupCpuController, double>* contrl = cpu_controller();\n+  CachedMetric<double>* cpu_limit = contrl->metrics_cache();\n@@ -646,2 +642,2 @@\n-    int val = (int)cpu_limit->value();\n-    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n+    double val = cpu_limit->value();\n+    log_trace(os, container)(\"CgroupSubsystem::active_processor_count (cached): %.2f\", val);\n@@ -651,2 +647,2 @@\n-  cpu_count = os::Linux::active_processor_count();\n-  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n+  int cpu_count = os::Linux::active_processor_count();\n+  double result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -669,2 +665,2 @@\n-  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n-  CachedMetric* memory_limit = contrl->metrics_cache();\n+  CachingCgroupController<CgroupMemoryController, jlong>* contrl = memory_controller();\n+  CachedMetric<jlong>* memory_limit = contrl->metrics_cache();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+template <typename MetricType>\n@@ -178,1 +179,1 @@\n-    volatile jlong _metric;\n+    volatile MetricType _metric;\n@@ -188,2 +189,2 @@\n-    jlong value() { return _metric; }\n-    void set_value(jlong value, jlong timeout) {\n+    MetricType value() { return _metric; }\n+    void set_value(MetricType value, jlong timeout) {\n@@ -200,1 +201,1 @@\n-template <class T>\n+template <class T, typename MetricType>\n@@ -204,1 +205,1 @@\n-    CachedMetric* _metrics_cache;\n+    CachedMetric<MetricType>* _metrics_cache;\n@@ -209,1 +210,1 @@\n-      _metrics_cache = new CachedMetric();\n+      _metrics_cache = new CachedMetric<MetricType>();\n@@ -212,1 +213,1 @@\n-    CachedMetric* metrics_cache() { return _metrics_cache; }\n+    CachedMetric<MetricType>* metrics_cache() { return _metrics_cache; }\n@@ -266,1 +267,1 @@\n-    int active_processor_count();\n+    double active_processor_count();\n@@ -275,2 +276,2 @@\n-    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n-    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+    virtual CachingCgroupController<CgroupMemoryController, jlong>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController, double>* cpu_controller() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+double CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n@@ -30,1 +30,0 @@\n-  int limit_count = host_cpus;\n@@ -33,2 +32,1 @@\n-  int quota_count = 0;\n-  int result = 0;\n+  double result = static_cast<double>(host_cpus);\n@@ -36,3 +34,4 @@\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  if (quota > 0 && period > 0) { \/\/ Use quotas\n+    double cpu_quota = static_cast<double>(quota) \/ period;\n+    log_trace(os, container)(\"CPU Quota based on quota\/period: %.2f\", cpu_quota);\n+    result = MIN2(result, cpu_quota);\n@@ -41,7 +40,1 @@\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(host_cpus, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %.2f\", result);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    static double processor_count(CgroupCpuController* cpu, int host_cpus);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n-  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController, jlong>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController, double>(cpu);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,2 +197,2 @@\n-    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n-    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController, jlong>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController, double>* cpu_controller() { return _cpu; }\n@@ -203,1 +203,1 @@\n-    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController, jlong>* _memory = nullptr;\n@@ -205,1 +205,1 @@\n-    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController, double>* _cpu = nullptr;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n-  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController, jlong>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController, double>(cpu);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,2 +148,2 @@\n-    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n-    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController, jlong>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController, double>* _cpu = nullptr;\n@@ -171,2 +171,2 @@\n-    CachingCgroupController<CgroupMemoryController>* memory_controller() override { return _memory; }\n-    CachingCgroupController<CgroupCpuController>* cpu_controller() override { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController, jlong>* memory_controller() override { return _memory; }\n+    CachingCgroupController<CgroupCpuController, double>* cpu_controller() override { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                                os::Linux::active_processor_count() != active_processor_count();\n+                                os::Linux::active_processor_count() != ceilf(active_processor_count());\n@@ -125,1 +125,1 @@\n-  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  julong phys_mem = static_cast<julong>(os::Machine::physical_memory());\n@@ -190,1 +190,1 @@\n-int OSContainer::active_processor_count() {\n+double OSContainer::active_processor_count() {\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static int active_processor_count();\n+  static double active_processor_count();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,0 +216,47 @@\n+bool os::is_containerized() {\n+  return OSContainer::is_containerized();\n+}\n+\n+bool os::Container::memory_limit(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  jlong mem_limit = OSContainer::memory_limit_in_bytes();\n+  if (mem_limit <= 0) {\n+    return false;\n+  }\n+\n+  value = static_cast<physical_memory_size_type>(mem_limit);\n+  return true;\n+}\n+bool os::Container::memory_soft_limit(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  jlong mem_limit = OSContainer::memory_soft_limit_in_bytes();\n+  if (mem_limit <= 0) {\n+    return false;\n+  }\n+\n+  value = static_cast<physical_memory_size_type>(mem_limit);\n+  return true;\n+}\n+\n+bool os::Container::memory_throttle_limit(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  jlong mem_limit = OSContainer::memory_throttle_limit_in_bytes();\n+  if (mem_limit <= 0) {\n+    return false;\n+  }\n+\n+  value = static_cast<physical_memory_size_type>(mem_limit);\n+  return true;\n+}\n+\n+bool os::Container::used_memory(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  jlong mem_usage = OSContainer::memory_usage_in_bytes();\n+  if (mem_usage <= 0) {\n+    return false;\n+  }\n+\n+  value = static_cast<physical_memory_size_type>(mem_usage);\n+  return true;\n+}\n+\n@@ -217,4 +264,2 @@\n-  julong avail_mem = 0;\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(avail_mem)) {\n-    log_trace(os)(\"available container memory: \" JULONG_FORMAT, avail_mem);\n-    value = static_cast<physical_memory_size_type>(avail_mem);\n+  if (is_containerized() && Container::available_memory(value)) {\n+    log_trace(os)(\"available container memory: \" PHYS_MEM_TYPE_FORMAT, value);\n@@ -224,0 +269,4 @@\n+  return Machine::available_memory(value);\n+}\n+\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n@@ -227,0 +276,10 @@\n+bool os::Container::available_memory(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  julong avail_mem = 0;\n+  if (OSContainer::available_memory_in_container(avail_mem)) {\n+    value = static_cast<physical_memory_size_type>(avail_mem);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -254,4 +313,2 @@\n-  julong free_mem = 0;\n-  if (OSContainer::is_containerized() && OSContainer::available_memory_in_container(free_mem)) {\n-    log_trace(os)(\"free container memory: \" JULONG_FORMAT, free_mem);\n-    value = static_cast<physical_memory_size_type>(free_mem);\n+  if (is_containerized() && Container::available_memory(value)) {\n+    log_trace(os)(\"free container memory: \" PHYS_MEM_TYPE_FORMAT, value);\n@@ -261,0 +318,4 @@\n+  return Machine::free_memory(value);\n+}\n+\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n@@ -279,8 +340,7 @@\n-  if (OSContainer::is_containerized()) {\n-    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n-    if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n-      value = static_cast<physical_memory_size_type>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n-      return true;\n-    }\n-  } \/\/ fallback to the host swap space if the container did return the unbound value of -1\n+  if (is_containerized() && Container::total_swap_space(value)) {\n+    return true;\n+  } \/\/ fallback to the host swap space if the container value fails\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -297,0 +357,11 @@\n+bool os::Container::total_swap_space(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n+  jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n+  if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n+    value = static_cast<physical_memory_size_type>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -316,20 +387,10 @@\n-  physical_memory_size_type host_free_swap_val = MIN2(total_swap_space, host_free_swap);\n-  if (OSContainer::is_containerized()) {\n-    jlong mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n-    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n-    if (mem_swap_limit >= 0 && mem_limit >= 0) {\n-      jlong delta_limit = mem_swap_limit - mem_limit;\n-      if (delta_limit <= 0) {\n-        value = 0;\n-        return true;\n-      }\n-      jlong mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n-      jlong mem_usage = OSContainer::memory_usage_in_bytes();\n-      if (mem_swap_usage > 0 && mem_usage > 0) {\n-        jlong delta_usage = mem_swap_usage - mem_usage;\n-        if (delta_usage >= 0) {\n-          jlong free_swap = delta_limit - delta_usage;\n-          value = free_swap >= 0 ? static_cast<physical_memory_size_type>(free_swap) : 0;\n-          return true;\n-        }\n-      }\n+  size_t host_free_swap_val = MIN2(total_swap_space, host_free_swap);\n+  if (is_containerized()) {\n+    if (Container::free_swap_space(value)) {\n+      return true;\n+    } else {\n+      \/\/ unlimited or not supported. Fall through to return host value\n+      log_trace(os,container)(\"os::free_swap_space: container_swap_limit=\" JLONG_FORMAT\n+                              \" container_mem_limit=\" PHYS_MEM_TYPE_FORMAT \" returning host value: %zu\",\n+                              OSContainer::memory_and_swap_limit_in_bytes(), OSContainer::memory_limit_in_bytes(),\n+                              host_free_swap_val);\n@@ -337,4 +398,0 @@\n-    \/\/ unlimited or not supported. Fall through to return host value\n-    log_trace(os,container)(\"os::free_swap_space: container_swap_limit=\" JLONG_FORMAT\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" PHYS_MEM_TYPE_FORMAT,\n-                            mem_swap_limit, mem_limit, host_free_swap_val);\n@@ -342,0 +399,1 @@\n+\n@@ -346,0 +404,28 @@\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n+  return host_free_swap_f(value);\n+}\n+\n+bool os::Container::free_swap_space(physical_memory_size_type& value) {\n+  assert(is_containerized(), \"must be running containerized\");\n+  jlong mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n+  jlong mem_limit = OSContainer::memory_limit_in_bytes();\n+  if (mem_swap_limit >= 0 && mem_limit >= 0) {\n+    jlong delta_limit = mem_swap_limit - mem_limit;\n+    if (delta_limit <= 0) {\n+      value = 0;\n+      return true;\n+    }\n+    jlong mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n+    jlong mem_usage = OSContainer::memory_usage_in_bytes();\n+    if (mem_swap_usage > 0 && mem_usage > 0) {\n+      jlong delta_usage = mem_swap_usage - mem_usage;\n+      if (delta_usage >= 0) {\n+        jlong free_swap = delta_limit - delta_usage;\n+        value = free_swap >= 0 ? static_cast<size_t>(free_swap) : 0;\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -347,5 +433,5 @@\n-  if (OSContainer::is_containerized()) {\n-    jlong mem_limit;\n-    if ((mem_limit = OSContainer::memory_limit_in_bytes()) > 0) {\n-      log_trace(os)(\"total container memory: \" JLONG_FORMAT, mem_limit);\n-      return static_cast<physical_memory_size_type>(mem_limit);\n+  if (is_containerized()) {\n+    physical_memory_size_type mem_limit;\n+    if (Container::memory_limit(mem_limit)) {\n+      log_trace(os)(\"total container memory: \" PHYS_MEM_TYPE_FORMAT, mem_limit);\n+      return mem_limit;\n@@ -355,1 +441,1 @@\n-  physical_memory_size_type phys_mem = Linux::physical_memory();\n+  physical_memory_size_type phys_mem = Machine::physical_memory();\n@@ -360,0 +446,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return Linux::physical_memory();\n+}\n+\n@@ -4663,3 +4753,4 @@\n-  int active_cpus;\n-  if (OSContainer::is_containerized()) {\n-    active_cpus = OSContainer::active_processor_count();\n+  if (is_containerized()) {\n+    double cpu_quota = Container::processor_count();\n+    int active_cpus = ceilf(cpu_quota); \/\/ Round fractional CPU quota up.\n+    assert(active_cpus <= Machine::active_processor_count(), \"must be\");\n@@ -4668,2 +4759,1 @@\n-  } else {\n-    active_cpus = os::Linux::active_processor_count();\n+    return active_cpus;\n@@ -4672,1 +4762,10 @@\n-  return active_cpus;\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n+  return os::Linux::active_processor_count();\n+}\n+\n+double os::Container::processor_count() {\n+  assert(is_containerized(), \"must be running containerized\");\n+  return OSContainer::active_processor_count();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":151,"deletions":52,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -841,0 +841,4 @@\n+bool os::Machine::available_memory(physical_memory_size_type& value) {\n+  return win32::available_memory(value);\n+}\n+\n@@ -845,0 +849,4 @@\n+bool os::Machine::free_memory(physical_memory_size_type& value) {\n+  return win32::available_memory(value);\n+}\n+\n@@ -860,1 +868,5 @@\n-bool os::total_swap_space(physical_memory_size_type& value) {\n+bool os::total_swap_space(physical_memory_size_type& value)  {\n+  return Machine::total_swap_space(value);\n+}\n+\n+bool os::Machine::total_swap_space(physical_memory_size_type& value) {\n@@ -874,0 +886,4 @@\n+  return Machine::free_swap_space(value);\n+}\n+\n+bool os::Machine::free_swap_space(physical_memory_size_type& value) {\n@@ -890,0 +906,4 @@\n+physical_memory_size_type os::Machine::physical_memory() {\n+  return win32::physical_memory();\n+}\n+\n@@ -913,0 +933,4 @@\n+  return Machine::active_processor_count();\n+}\n+\n+int os::Machine::active_processor_count() {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -69,4 +69,0 @@\n-#ifdef LINUX\n-#include \"os_linux.hpp\"\n-#include \"osContainer_linux.hpp\"\n-#endif\n@@ -404,5 +400,1 @@\n-#ifdef LINUX\n-  return OSContainer::is_containerized();\n-#else\n-  return false;\n-#endif\n+  return os::is_containerized();\n@@ -412,7 +404,1 @@\n-#ifdef LINUX\n-  \/\/ We want the host memory, not the container limit.\n-  \/\/ os::physical_memory() would return the container limit.\n-  return static_cast<jlong>(os::Linux::physical_memory());\n-#else\n-  return static_cast<jlong>(os::physical_memory());\n-#endif\n+  return static_cast<jlong>(os::Machine::physical_memory());\n@@ -422,4 +408,0 @@\n-#ifdef LINUX\n-  \/\/ We want the host swap memory, not the container value.\n-  return os::Linux::host_swap();\n-#else\n@@ -428,1 +410,1 @@\n-  (void)os::total_swap_space(total_swap_space);\n+  (void)os::Machine::total_swap_space(total_swap_space);\n@@ -430,1 +412,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-#ifdef LINUX\n-#include \"osContainer_linux.hpp\"\n-#endif\n@@ -489,2 +486,1 @@\n-#ifdef LINUX\n-  if (OSContainer::is_containerized()) {\n+  if (os::is_containerized()) {\n@@ -493,1 +489,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -2573,2 +2572,1 @@\n-  LINUX_ONLY(return OSContainer::is_containerized();)\n-  return false;\n+  return os::is_containerized();\n@@ -2579,2 +2577,1 @@\n-  LINUX_ONLY(return static_cast<jlong>(os::Linux::physical_memory());)\n-  return static_cast<jlong>(os::physical_memory());\n+  return static_cast<jlong>(os::Machine::physical_memory());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,4 +84,0 @@\n-#ifdef LINUX\n-#include \"osContainer_linux.hpp\"\n-#endif\n-\n@@ -2208,9 +2204,2 @@\n-#ifdef LINUX\n-  if (OSContainer::is_containerized()) {\n-    jlong mem_usage = OSContainer::memory_usage_in_bytes();\n-    if (mem_usage > 0) {\n-      value = static_cast<physical_memory_size_type>(mem_usage);\n-      return true;\n-    } else {\n-      return false;\n-    }\n+  if (is_containerized()) {\n+    return Container::used_memory(value);\n@@ -2218,1 +2207,5 @@\n-#endif\n+\n+  return Machine::used_memory(value);\n+}\n+\n+bool os::Machine::used_memory(physical_memory_size_type& value) {\n@@ -2227,0 +2220,46 @@\n+#ifndef LINUX\n+bool os::is_containerized() {\n+  return false;\n+}\n+\n+double os::Container::processor_count() {\n+  ShouldNotReachHere();\n+  return 0.0;\n+}\n+\n+bool os::Container::available_memory(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+bool os::Container::used_memory(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+bool os::Container::total_swap_space(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+bool os::Container::free_swap_space(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+bool os::Container::memory_limit(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+bool os::Container::memory_soft_limit(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+bool os::Container::memory_throttle_limit(physical_memory_size_type& value) {\n+  ShouldNotReachHere();\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":53,"deletions":14,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/allStatic.hpp\"\n@@ -345,0 +346,45 @@\n+  \/\/ On platforms with container support (currently only Linux) we combine machine values with\n+  \/\/ potential container values in os:: methods, abstracting which value is actually used.\n+  \/\/ The os::Machine and os::Container classes and containing methods are used to get machine\n+  \/\/ and container values (when available) separately.\n+  static bool is_containerized();\n+\n+  \/\/ The os::Machine class reports system resource metrics from the perspective of the operating\n+  \/\/ system, without considering container-imposed limits. The values returned by these methods\n+  \/\/ reflect the resources visible to the process as reported by the OS, and may already be\n+  \/\/ affected by mechanisms such as virtualization, hypervisor limits, or process affinity,\n+  \/\/ but do NOT consider further restrictions imposed by container runtimes (e.g., cgroups)\n+  class Machine : AllStatic {\n+  public:\n+    static int active_processor_count();\n+\n+    [[nodiscard]] static bool available_memory(physical_memory_size_type& value);\n+    [[nodiscard]] static bool used_memory(physical_memory_size_type& value);\n+    [[nodiscard]] static bool free_memory(physical_memory_size_type& value);\n+\n+    [[nodiscard]] static bool total_swap_space(physical_memory_size_type& value);\n+    [[nodiscard]] static bool free_swap_space(physical_memory_size_type& value);\n+\n+    static physical_memory_size_type physical_memory();\n+  };\n+\n+  \/\/ The os::Container class reports resource limits as imposed by a supported container runtime\n+  \/\/ (currently only cgroup-based Linux runtimes). If the process is running inside a\n+  \/\/ containerized environment, methods from this class report the effective limits imposed\n+  \/\/ by the container, which may be more restrictive than what os::Machine reports.\n+  \/\/ These methods are not safe to use unless `os::is_containerized()` is true.\n+  class Container : AllStatic {\n+  public:\n+    static double processor_count(); \/\/ Returns the core-equivalent CPU quota\n+\n+    [[nodiscard]] static bool available_memory(physical_memory_size_type& value);\n+    [[nodiscard]] static bool used_memory(physical_memory_size_type& value);\n+\n+    [[nodiscard]] static bool total_swap_space(physical_memory_size_type& value);\n+    [[nodiscard]] static bool free_swap_space(physical_memory_size_type& value);\n+\n+    [[nodiscard]] static bool memory_limit(physical_memory_size_type& value);\n+    [[nodiscard]] static bool memory_soft_limit(physical_memory_size_type& value);\n+    [[nodiscard]] static bool memory_throttle_limit(physical_memory_size_type& value);\n+  };\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -149,3 +149,3 @@\n-    private static int adjustExpectedAPCForAvailableCPUs(int expectedAPC) {\n-        if (expectedAPC > availableCPUs) {\n-            expectedAPC = availableCPUs;\n+    private static double adjustExpectedAPCForAvailableCPUs(double expectedAPC) {\n+        if (expectedAPC > (double)availableCPUs) {\n+            expectedAPC = (double)availableCPUs;\n@@ -164,1 +164,1 @@\n-        int expectedAPC = (int) Math.ceil((float) quota \/ (float) period);\n+        double expectedAPC = (double) quota \/ (double) period;\n@@ -184,1 +184,1 @@\n-                                     int expectedAPC) throws Exception {\n+                                     double expectedAPC) throws Exception {\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}