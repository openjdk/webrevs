{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"precompiled.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"runtime\/globals.hpp\"\n@@ -42,5 +41,0 @@\n-  CgroupV1MemoryController* memory = nullptr;\n-  CgroupV1Controller* cpuset = nullptr;\n-  CgroupV1Controller* cpu = nullptr;\n-  CgroupV1Controller* cpuacct = nullptr;\n-  CgroupV1Controller* pids = nullptr;\n@@ -68,1 +62,0 @@\n-    cleanup(cg_infos);\n@@ -99,22 +92,19 @@\n-  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n-    CgroupInfo info = cg_infos[i];\n-    if (info._data_complete) { \/\/ pids controller might have incomplete data\n-      if (strcmp(info._name, \"memory\") == 0) {\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n-        memory->set_subsystem_path(info._cgroup_path);\n-      } else if (strcmp(info._name, \"cpuset\") == 0) {\n-        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-        cpuset->set_subsystem_path(info._cgroup_path);\n-      } else if (strcmp(info._name, \"cpu\") == 0) {\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-        cpu->set_subsystem_path(info._cgroup_path);\n-      } else if (strcmp(info._name, \"cpuacct\") == 0) {\n-        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-        cpuacct->set_subsystem_path(info._cgroup_path);\n-      } else if (strcmp(info._name, \"pids\") == 0) {\n-        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-        pids->set_subsystem_path(info._cgroup_path);\n-      }\n-    } else {\n-      log_debug(os, container)(\"CgroupInfo for %s not complete\", cg_controller_name[i]);\n-    }\n+  \/\/ The following are required to exist, determine_type will fail and return false otherwise.\n+  CgroupV1MemoryController* memory = new CgroupV1MemoryController(cg_infos[MEMORY_IDX]._root_mount_path,\n+                                                                  cg_infos[MEMORY_IDX]._mount_path,\n+                                                                  cg_infos[MEMORY_IDX]._cgroup_path);\n+  CgroupV1Controller* cpuset = new CgroupV1Controller(cg_infos[CPUSET_IDX]._root_mount_path,\n+                                                      cg_infos[CPUSET_IDX]._mount_path,\n+                                                      cg_infos[CPUSET_IDX]._cgroup_path);\n+  CgroupV1Controller* cpu = new CgroupV1Controller(cg_infos[CPU_IDX]._root_mount_path,\n+                                                   cg_infos[CPU_IDX]._mount_path,\n+                                                   cg_infos[CPU_IDX]._cgroup_path);\n+  CgroupV1Controller* cpuacct = new CgroupV1Controller(cg_infos[CPUACCT_IDX]._root_mount_path,\n+                                                       cg_infos[CPUACCT_IDX]._mount_path,\n+                                                       cg_infos[CPUACCT_IDX]._cgroup_path);\n+  CgroupV1Controller* pids = nullptr;\n+\n+  if (cg_infos[PIDS_IDX]._data_complete) {\n+    pids = new CgroupV1Controller(cg_infos[PIDS_IDX]._root_mount_path, cg_infos[PIDS_IDX]._mount_path, cg_infos[PIDS_IDX]._cgroup_path);\n+  } else {\n+    log_debug(os, container)(\"CgroupInfo for %s not complete\", cg_controller_name[PIDS_IDX]);\n@@ -122,1 +112,1 @@\n-  cleanup(cg_infos);\n+\n@@ -192,0 +182,1 @@\n+    CG_INFO index = CG_INFO_INVALID;\n@@ -193,3 +184,1 @@\n-      cg_infos[MEMORY_IDX]._name = os::strdup(name);\n-      cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;\n-      cg_infos[MEMORY_IDX]._enabled = (enabled == 1);\n+      index = MEMORY_IDX;\n@@ -197,3 +186,1 @@\n-      cg_infos[CPUSET_IDX]._name = os::strdup(name);\n-      cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;\n-      cg_infos[CPUSET_IDX]._enabled = (enabled == 1);\n+      index = CPUSET_IDX;\n@@ -201,3 +188,1 @@\n-      cg_infos[CPU_IDX]._name = os::strdup(name);\n-      cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;\n-      cg_infos[CPU_IDX]._enabled = (enabled == 1);\n+      index = CPU_IDX;\n@@ -205,3 +190,1 @@\n-      cg_infos[CPUACCT_IDX]._name = os::strdup(name);\n-      cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;\n-      cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);\n+      index = CPUACCT_IDX;\n@@ -210,3 +193,6 @@\n-      cg_infos[PIDS_IDX]._name = os::strdup(name);\n-      cg_infos[PIDS_IDX]._hierarchy_id = hierarchy_id;\n-      cg_infos[PIDS_IDX]._enabled = (enabled == 1);\n+      index = PIDS_IDX;\n+    }\n+    if (index != CG_INFO_INVALID) {\n+      cg_infos[index]._name = os::strdup(name);\n+      cg_infos[index]._hierarchy_id = hierarchy_id;\n+      cg_infos[index]._enabled = (enabled == 1);\n@@ -219,6 +205,3 @@\n-  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n-    \/\/ pids controller is optional. All other controllers are required\n-    if (i != PIDS_IDX) {\n-      is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n-      all_required_controllers_enabled = all_required_controllers_enabled && cg_infos[i]._enabled;\n-    }\n+  for (int i = 0; i < CG_INFO_REQUIRED_END; i++) {\n+    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+    all_required_controllers_enabled = all_required_controllers_enabled && cg_infos[i]._enabled;\n@@ -233,1 +216,0 @@\n-    cleanup(cg_infos);\n@@ -248,1 +230,0 @@\n-    cleanup(cg_infos);\n@@ -309,1 +290,0 @@\n-      cleanup(cg_infos);\n@@ -356,0 +336,1 @@\n+        CG_INFO index = CG_INFO_INVALID;\n@@ -357,3 +338,1 @@\n-          any_cgroup_mounts_found = true;\n-          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot);\n-          cg_infos[MEMORY_IDX]._data_complete = true;\n+          index = MEMORY_IDX;\n@@ -361,3 +340,1 @@\n-          any_cgroup_mounts_found = true;\n-          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot);\n-          cg_infos[CPUSET_IDX]._data_complete = true;\n+          index = CPUSET_IDX;\n@@ -365,3 +342,1 @@\n-          any_cgroup_mounts_found = true;\n-          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot);\n-          cg_infos[CPU_IDX]._data_complete = true;\n+          index = CPU_IDX;\n@@ -369,3 +344,1 @@\n-          any_cgroup_mounts_found = true;\n-          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot);\n-          cg_infos[CPUACCT_IDX]._data_complete = true;\n+          index = CPUACCT_IDX;\n@@ -373,0 +346,3 @@\n+          index = PIDS_IDX;\n+        }\n+        if (index != CG_INFO_INVALID) {\n@@ -374,2 +350,2 @@\n-          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot);\n-          cg_infos[PIDS_IDX]._data_complete = true;\n+          set_controller_paths(cg_infos, index, token, tmpmount, tmproot);\n+          cg_infos[index]._data_complete = true;\n@@ -386,1 +362,0 @@\n-    cleanup(cg_infos);\n@@ -394,1 +369,0 @@\n-      cleanup(cg_infos);\n@@ -406,23 +380,7 @@\n-  if (!cg_infos[MEMORY_IDX]._data_complete) {\n-    log_debug(os, container)(\"Required cgroup v1 memory subsystem not found\");\n-    cleanup(cg_infos);\n-    *flags = INVALID_CGROUPS_V1;\n-    return false;\n-  }\n-  if (!cg_infos[CPUSET_IDX]._data_complete) {\n-    log_debug(os, container)(\"Required cgroup v1 cpuset subsystem not found\");\n-    cleanup(cg_infos);\n-    *flags = INVALID_CGROUPS_V1;\n-    return false;\n-  }\n-  if (!cg_infos[CPU_IDX]._data_complete) {\n-    log_debug(os, container)(\"Required cgroup v1 cpu subsystem not found\");\n-    cleanup(cg_infos);\n-    *flags = INVALID_CGROUPS_V1;\n-    return false;\n-  }\n-  if (!cg_infos[CPUACCT_IDX]._data_complete) {\n-    log_debug(os, container)(\"Required cgroup v1 cpuacct subsystem not found\");\n-    cleanup(cg_infos);\n-    *flags = INVALID_CGROUPS_V1;\n-    return false;\n+  for (int i = CG_INFO_START; i < CG_INFO_REQUIRED_END; i++) {\n+    if (!cg_infos[i]._data_complete) {\n+      log_debug(os, container)(\"Required cgroup v1 subsystem controller %s not found\",\n+                               cg_controller_name[i]);\n+      *flags = INVALID_CGROUPS_V1;\n+      return false;\n+    }\n@@ -439,10 +397,0 @@\n-void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {\n-  assert(cg_infos != nullptr, \"Invariant\");\n-  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n-    os::free(cg_infos[i]._name);\n-    os::free(cg_infos[i]._cgroup_path);\n-    os::free(cg_infos[i]._root_mount_path);\n-    os::free(cg_infos[i]._mount_path);\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":53,"deletions":105,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,6 +65,11 @@\n-#define CG_INFO_LENGTH 5\n-#define CPUSET_IDX     0\n-#define CPU_IDX        1\n-#define CPUACCT_IDX    2\n-#define MEMORY_IDX     3\n-#define PIDS_IDX       4\n+enum CG_INFO {\n+  CG_INFO_INVALID = -1,\n+  CG_INFO_START = 0,\n+  CPUSET_IDX = 0,\n+  CPU_IDX,\n+  CPUACCT_IDX,\n+  MEMORY_IDX,\n+  PIDS_IDX, \/\/ pids is not required\n+  CG_INFO_REQUIRED_END = PIDS_IDX,\n+  CG_INFO_LENGTH = PIDS_IDX + 1\n+};\n@@ -105,1 +110,1 @@\n-class CgroupController: public CHeapObj<mtInternal> {\n+class CgroupController : public CHeapObj<mtInternal> {\n@@ -252,0 +257,6 @@\n+    ~CgroupInfo() {\n+      os::free(_name);\n+      os::free(_cgroup_path);\n+      os::free(_root_mount_path);\n+      os::free(_mount_path);\n+    }\n@@ -285,1 +296,0 @@\n-    static void cleanup(CgroupInfo* cg_infos);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"precompiled.hpp\"\n@@ -26,2 +27,0 @@\n-#include <math.h>\n-#include <errno.h>\n@@ -31,1 +30,0 @@\n-#include \"runtime\/globals.hpp\"\n@@ -84,1 +82,0 @@\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,5 +44,1 @@\n-    CgroupV1Controller(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = nullptr;\n-    }\n+    void set_subsystem_path(char *cgroup_path);\n@@ -50,2 +46,7 @@\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n+    CgroupV1Controller(char* root, char* mountpoint, char* cgroup_path)\n+      : _root(os::strdup(root)),\n+        _mount_point(os::strdup(mountpoint)),\n+        _path(nullptr) {\n+        set_subsystem_path(cgroup_path);\n+      }\n+      char *subsystem_path() { return _path; }\n@@ -55,5 +56,0 @@\n-\n-  public:\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n-  private:\n@@ -66,0 +62,1 @@\n+    void set_subsystem_path(char *cgroup_path);\n@@ -68,2 +65,5 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n+    bool is_hierarchical() { return _uses_mem_hierarchy; }\n+    CgroupV1MemoryController(char* root, char* mountpoint, char* cgroup_path)\n+    : CgroupV1Controller(root, mountpoint, cgroup_path),\n+      _uses_mem_hierarchy(false) {\n+      set_subsystem_path(cgroup_path);\n@@ -71,1 +71,0 @@\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -439,2 +439,2 @@\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+                                                       (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}