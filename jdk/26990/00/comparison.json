{"files":[{"patch":"@@ -325,1 +325,1 @@\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+        FloatingDecimal.BinaryToASCIIBuffer fdConverter =\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -29,1 +30,0 @@\n-import java.math.BigInteger;\n@@ -31,1 +31,0 @@\n-\/\/@ model import org.jmlspecs.models.JMLMath;\n@@ -34,1 +33,1 @@\n- * A simple big integer package specifically for floating point base conversion.\n+ * A simple big integer class specifically for floating point base conversion.\n@@ -36,32 +35,1 @@\n-public \/*@ spec_bigint_math @*\/ class FDBigInteger {\n-\n-    \/\/\n-    \/\/ This class contains many comments that start with \"\/*@\" mark.\n-    \/\/ They are behavourial specification in\n-    \/\/ the Java Modelling Language (JML):\n-    \/\/ http:\/\/www.eecs.ucf.edu\/~leavens\/JML\/\/index.shtml\n-    \/\/\n-\n-    \/*@\n-    @ public pure model static \\bigint UNSIGNED(int v) {\n-    @     return v >= 0 ? v : v + (((\\bigint)1) << 32);\n-    @ }\n-    @\n-    @ public pure model static \\bigint UNSIGNED(long v) {\n-    @     return v >= 0 ? v : v + (((\\bigint)1) << 64);\n-    @ }\n-    @\n-    @ public pure model static \\bigint AP(int[] data, int len) {\n-    @     return (\\sum int i; 0 <= 0 && i < len; UNSIGNED(data[i]) << (i*32));\n-    @ }\n-    @\n-    @ public pure model static \\bigint pow52(int p5, int p2) {\n-    @     ghost \\bigint v = 1;\n-    @     for (int i = 0; i < p5; i++) v *= 5;\n-    @     return v << p2;\n-    @ }\n-    @\n-    @ public pure model static \\bigint pow10(int p10) {\n-    @     return pow52(p10, p10);\n-    @ }\n-    @*\/\n+final class FDBigInteger {\n@@ -73,1 +41,1 @@\n-    \/\/ Maximum size of cache of powers of 5 as FDBigIntegers.\n+    \/\/ Size of full cache of powers of 5 as FDBigIntegers.\n@@ -77,4 +45,1 @@\n-    private static final FDBigInteger POW_5_CACHE[];\n-\n-    \/\/ Zero as an FDBigInteger.\n-    public static final FDBigInteger ZERO;\n+    private static final FDBigInteger[] POW_5_CACHE;\n@@ -93,25 +58,26 @@\n-                    5L * 5,\n-                    5L * 5 * 5,\n-                    5L * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n+                    25L,\n+                    25L * 5,\n+                    25L * 25,\n+                    25L * 25 * 5,\n+                    25L * 25 * 25,\n+                    25L * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 5,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25,\n+                    25L * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 25 * 5,  \/\/ 5^27\n@@ -119,0 +85,1 @@\n+\n@@ -122,12 +89,12 @@\n-                    5 * 5,\n-                    5 * 5 * 5,\n-                    5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n+                    25,\n+                    25 * 5,\n+                    25 * 25,\n+                    25 * 25 * 5,\n+                    25 * 25 * 25,\n+                    25 * 25 * 25 * 5,\n+                    25 * 25 * 25 * 25,\n+                    25 * 25 * 25 * 25 * 5,\n+                    25 * 25 * 25 * 25 * 25,\n+                    25 * 25 * 25 * 25 * 25 * 5,\n+                    25 * 25 * 25 * 25 * 25 * 25,\n+                    25 * 25 * 25 * 25 * 25 * 25 * 5,  \/\/ 5^13\n@@ -135,0 +102,1 @@\n+\n@@ -137,5 +105,2 @@\n-            while (i < small5pow.length) {\n-                FDBigInteger pow5 = new FDBigInteger(new int[] { small5pow[i] }, 0);\n-                pow5.makeImmutable();\n-                pow5cache[i] = pow5;\n-                i++;\n+            for (; i < long5pow.length; ++i) {\n+                pow5cache[i] = new FDBigInteger(long5pow[i]).makeImmutable();\n@@ -144,4 +109,2 @@\n-            while (i < MAX_FIVE_POW) {\n-                pow5cache[i] = prev = prev.mult(5);\n-                prev.makeImmutable();\n-                i++;\n+            for (; i < MAX_FIVE_POW; ++i) {\n+                pow5cache[i] = prev = prev.mult(5).makeImmutable();\n@@ -149,3 +112,9 @@\n-            FDBigInteger zero = new FDBigInteger(new int[0], 0);\n-            zero.makeImmutable();\n-            archivedCaches = caches = new Object[] {small5pow, long5pow, pow5cache, zero};\n+\n+            \/* Here prev is 5^(MAX_FIVE_POW-1). *\/\n+            FDBigInteger[] largePow5cache =\n+                    new FDBigInteger[(2 - DoubleToDecimal.Q_MIN) - MAX_FIVE_POW + 1];\n+            largePow5cache[2 * (MAX_FIVE_POW - 1) - MAX_FIVE_POW] =\n+                    prev = prev.mult(prev).makeImmutable();\n+            largePow5cache[3 * (MAX_FIVE_POW - 1) - MAX_FIVE_POW] =\n+                    pow5cache[MAX_FIVE_POW - 1].mult(prev).makeImmutable();\n+            archivedCaches = caches = new Object[] {small5pow, long5pow, pow5cache, largePow5cache};\n@@ -153,4 +122,4 @@\n-        SMALL_5_POW = (int[])caches[0];\n-        LONG_5_POW = (long[])caches[1];\n-        POW_5_CACHE = (FDBigInteger[])caches[2];\n-        ZERO = (FDBigInteger)caches[3];\n+        SMALL_5_POW = (int[]) caches[0];\n+        LONG_5_POW = (long[]) caches[1];\n+        POW_5_CACHE = (FDBigInteger[]) caches[2];\n+        LARGE_POW_5_CACHE = (FDBigInteger[]) caches[3];\n@@ -160,1 +129,1 @@\n-    private static final long LONG_MASK = 0xffffffffL;\n+    private static final long LONG_MASK = 0xffff_ffffL;\n@@ -162,3 +131,1 @@\n-    \/\/@ spec_public non_null;\n-    private int data[];  \/\/ value: data[0] is least significant\n-    \/\/@ spec_public;\n+    private int[] data;  \/\/ value: data[0] is least significant\n@@ -166,1 +133,0 @@\n-    \/\/@ spec_public;\n@@ -169,1 +135,0 @@\n-    \/\/@ spec_public;\n@@ -172,10 +137,0 @@\n-    \/*@\n-     @ public invariant 0 <= nWords && nWords <= data.length && offset >= 0;\n-     @ public invariant nWords == 0 ==> offset == 0;\n-     @ public invariant nWords > 0 ==> data[nWords - 1] != 0;\n-     @ public invariant (\\forall int i; nWords <= i && i < data.length; data[i] == 0);\n-     @ public pure model \\bigint value() {\n-     @     return AP(data, nWords) << (offset*32);\n-     @ }\n-     @*\/\n-\n@@ -183,5 +138,5 @@\n-     * Constructs an <code>FDBigInteger<\/code> from data and padding. The\n-     * <code>data<\/code> parameter has the least significant <code>int<\/code> at\n-     * the zeroth index. The <code>offset<\/code> parameter gives the number of\n-     * zero <code>int<\/code>s to be inferred below the least significant element\n-     * of <code>data<\/code>.\n+     * Constructs an {@link FDBigInteger} from data and padding. The\n+     * {@code data} parameter has the least significant {@code int} at\n+     * the zeroth index. The {@code offset} parameter gives the number of\n+     * zero {@code int}s to be inferred below the least significant element\n+     * of {@code data}.\n@@ -189,3 +144,3 @@\n-     * @param data An array containing all non-zero <code>int<\/code>s of the value.\n-     * @param offset An offset indicating the number of zero <code>int<\/code>s to pad\n-     * below the least significant element of <code>data<\/code>.\n+     * @param data An array containing all non-zero {@code int}s of the value.\n+     * @param offset An offset indicating the number of zero {@code int}s to pad\n+     * below the least significant element of {@code data}.\n@@ -193,5 +148,0 @@\n-    \/*@\n-     @ requires data != null && offset >= 0;\n-     @ ensures this.value() == \\old(AP(data, data.length) << (offset*32));\n-     @ ensures this.data == \\old(data);\n-     @*\/\n@@ -206,1 +156,1 @@\n-     * Constructs an <code>FDBigInteger<\/code> from a starting value and some\n+     * Constructs an {@link FDBigInteger} from a starting value and some\n@@ -211,2 +161,2 @@\n-     * @param kDigits The initial index into <code>digits<\/code>.\n-     * @param nDigits The final index into <code>digits<\/code>.\n+     * @param i The initial index into {@code digits}.\n+     * @param nDigits The final index into {@code digits}.\n@@ -214,10 +164,4 @@\n-    \/*@\n-     @ requires digits != null;\n-     @ requires 0 <= kDigits && kDigits <= nDigits && nDigits <= digits.length;\n-     @ requires (\\forall int i; 0 <= i && i < nDigits; '0' <= digits[i] && digits[i] <= '9');\n-     @ ensures this.value() == \\old(lValue * pow10(nDigits - kDigits) + (\\sum int i; kDigits <= i && i < nDigits; (digits[i] - '0') * pow10(nDigits - i - 1)));\n-     @*\/\n-    public FDBigInteger(long lValue, byte[] digits, int kDigits, int nDigits) {\n-        int n = Math.max((nDigits + 8) \/ 9, 2);        \/\/ estimate size needed.\n-        data = new int[n];      \/\/ allocate enough space\n-        data[0] = (int) lValue;    \/\/ starting value\n+    public FDBigInteger(long lValue, byte[] digits, int i, int nDigits) {\n+        int n = (nDigits + 8) \/ 9;  \/\/ estimate size needed: ⌈nDigits \/ 9⌉\n+        data = new int[Math.max(n, 2)];\n+        data[0] = (int) lValue;  \/\/ starting value\n@@ -227,3 +171,1 @@\n-        int i = kDigits;\n-        int limit = nDigits - 5;       \/\/ slurp digits 5 at a time.\n-        int v;\n+        int limit = nDigits - 9;\n@@ -231,2 +173,2 @@\n-            int ilim = i + 5;\n-            v = (int) digits[i++] - (int) '0';\n+            int v = 0;\n+            int ilim = i + 9;\n@@ -234,1 +176,1 @@\n-                v = 10 * v + (int) digits[i++] - (int) '0';\n+                v = 10 * v + digits[i++] - '0';\n@@ -236,1 +178,1 @@\n-            multAddMe(100000, v); \/\/ ... where 100000 is 10^5.\n+            multAdd(1_000_000_000, v);  \/\/ 10^9\n@@ -238,8 +180,7 @@\n-        int factor = 1;\n-        v = 0;\n-        while (i < nDigits) {\n-            v = 10 * v + (int) digits[i++] - (int) '0';\n-            factor *= 10;\n-        }\n-        if (factor != 1) {\n-            multAddMe(factor, v);\n+        if (i < nDigits) {\n+            int factor = (int) MathUtils.pow10(nDigits - i);\n+            int v = 0;\n+            while (i < nDigits) {\n+                v = 10 * v + digits[i++] - '0';\n+            }\n+            multAdd(factor, v);\n@@ -250,0 +191,4 @@\n+    public FDBigInteger(long v) {\n+        this(new int[] {(int) v, (int) (v >>> 32)}, 0);\n+    }\n+\n@@ -251,2 +196,2 @@\n-     * Returns an <code>FDBigInteger<\/code> with the numerical value\n-     * <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>.\n+     * Returns an {@link FDBigInteger} with the numerical value\n+     * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>.\n@@ -254,3 +199,3 @@\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n-     * @return <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>\n+     * @param e5 The exponent of the power-of-five factor.\n+     * @param e2 The exponent of the power-of-two factor.\n+     * @return 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>\n@@ -258,26 +203,3 @@\n-    \/*@\n-     @ requires p5 >= 0 && p2 >= 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(pow52(p5, p2));\n-     @*\/\n-    public static FDBigInteger valueOfPow52(int p5, int p2) {\n-        if (p5 != 0) {\n-            if (p2 == 0) {\n-                return big5pow(p5);\n-            } else if (p5 < SMALL_5_POW.length) {\n-                int pow5 = SMALL_5_POW[p5];\n-                int wordcount = p2 >> 5;\n-                int bitcount = p2 & 0x1f;\n-                if (bitcount == 0) {\n-                    return new FDBigInteger(new int[]{pow5}, wordcount);\n-                } else {\n-                    return new FDBigInteger(new int[]{\n-                            pow5 << bitcount,\n-                            pow5 >>> (32 - bitcount)\n-                    }, wordcount);\n-                }\n-            } else {\n-                return big5pow(p5).leftShift(p2);\n-            }\n-        } else {\n-            return valueOfPow2(p2);\n+    public static FDBigInteger valueOfPow52(int e5, int e2) {\n+        if (e5 == 0) {\n+            return valueOfPow2(e2);\n@@ -285,0 +207,16 @@\n+        if (e2 == 0) {\n+            return pow5(e5);\n+        }\n+        if (e5 >= SMALL_5_POW.length) {\n+            return pow5(e5).leftShift(e2);\n+        }\n+        int pow5 = SMALL_5_POW[e5];\n+        int offset = e2 >> 5;\n+        int bitcount = e2 & 0x1f;\n+        if (bitcount == 0) {\n+            return new FDBigInteger(new int[] {pow5}, offset);\n+        }\n+        return new FDBigInteger(new int[] {\n+                pow5 << bitcount,\n+                pow5 >>> -bitcount\n+            }, offset);\n@@ -288,2 +226,2 @@\n-     * Returns an <code>FDBigInteger<\/code> with the numerical value\n-     * <code>value * 5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>.\n+     * Returns an {@link FDBigInteger} with the numerical value:\n+     * value * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>.\n@@ -292,3 +230,3 @@\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n-     * @return <code>value * 5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>\n+     * @param e5 The exponent of the power-of-five factor.\n+     * @param e2 The exponent of the power-of-two factor.\n+     * @return value * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>\n@@ -296,8 +234,1 @@\n-    \/*@\n-     @ requires p5 >= 0 && p2 >= 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(UNSIGNED(value) * pow52(p5, p2));\n-     @*\/\n-    public static FDBigInteger valueOfMulPow52(long value, int p5, int p2) {\n-        assert p5 >= 0 : p5;\n-        assert p2 >= 0 : p2;\n+    public static FDBigInteger valueOfMulPow52(long value, int e5, int e2) {\n@@ -306,5 +237,5 @@\n-        int wordcount = p2 >> 5;\n-        int bitcount = p2 & 0x1f;\n-        if (p5 != 0) {\n-            if (p5 < SMALL_5_POW.length) {\n-                long pow5 = SMALL_5_POW[p5] & LONG_MASK;\n+        int offset = e2 >> 5;\n+        int bitcount = e2 & 0x1f;\n+        if (e5 != 0) {\n+            if (e5 < SMALL_5_POW.length) {\n+                long pow5 = SMALL_5_POW[e5] & LONG_MASK;\n@@ -317,21 +248,8 @@\n-                if (bitcount == 0) {\n-                    return new FDBigInteger(new int[]{v0, v1, v2}, wordcount);\n-                } else {\n-                    return new FDBigInteger(new int[]{\n-                            v0 << bitcount,\n-                            (v1 << bitcount) | (v0 >>> (32 - bitcount)),\n-                            (v2 << bitcount) | (v1 >>> (32 - bitcount)),\n-                            v2 >>> (32 - bitcount)\n-                    }, wordcount);\n-                }\n-            } else {\n-                FDBigInteger pow5 = big5pow(p5);\n-                int[] r;\n-                if (v1 == 0) {\n-                    r = new int[pow5.nWords + 1 + ((p2 != 0) ? 1 : 0)];\n-                    mult(pow5.data, pow5.nWords, v0, r);\n-                } else {\n-                    r = new int[pow5.nWords + 2 + ((p2 != 0) ? 1 : 0)];\n-                    mult(pow5.data, pow5.nWords, v0, v1, r);\n-                }\n-                return (new FDBigInteger(r, pow5.offset)).leftShift(p2);\n+                return bitcount == 0\n+                        ? new FDBigInteger(new int[] {v0, v1, v2}, offset)\n+                        : new FDBigInteger(new int[] {\n+                                v0 << bitcount,\n+                                (v1 << bitcount) | (v0 >>> -bitcount),\n+                                (v2 << bitcount) | (v1 >>> -bitcount),\n+                                v2 >>> -bitcount\n+                            }, offset);\n@@ -339,3 +257,5 @@\n-        } else if (p2 != 0) {\n-            if (bitcount == 0) {\n-                return new FDBigInteger(new int[]{v0, v1}, wordcount);\n+            FDBigInteger pow5 = pow5(e5);\n+            int[] r;\n+            if (v1 == 0) {\n+                r = new int[pow5.nWords + 1 + ((e2 != 0) ? 1 : 0)];\n+                mult(pow5.data, pow5.nWords, v0, r);\n@@ -343,5 +263,2 @@\n-                return new FDBigInteger(new int[]{\n-                         v0 << bitcount,\n-                        (v1 << bitcount) | (v0 >>> (32 - bitcount)),\n-                        v1 >>> (32 - bitcount)\n-                }, wordcount);\n+                r = new int[pow5.nWords + 2 + ((e2 != 0) ? 1 : 0)];\n+                mult(pow5.data, pow5.nWords, v0, v1, r);\n@@ -349,0 +266,10 @@\n+            return (new FDBigInteger(r, 0)).leftShift(e2);\n+        }\n+        if (e2 != 0) {\n+            return bitcount == 0\n+                    ? new FDBigInteger(new int[] {v0, v1}, offset)\n+                    : new FDBigInteger(new int[] {\n+                            v0 << bitcount,\n+                            (v1 << bitcount) | (v0 >>> -bitcount),\n+                            v1 >>> -bitcount\n+                        }, offset);\n@@ -350,1 +277,1 @@\n-        return new FDBigInteger(new int[]{v0, v1}, 0);\n+        return new FDBigInteger(new int[] {v0, v1}, 0);\n@@ -354,2 +281,2 @@\n-     * Returns an <code>FDBigInteger<\/code> with the numerical value\n-     * <code>2<sup>p2<\/sup><\/code>.\n+     * Returns an {@link FDBigInteger} with the numerical value\n+     * 2<sup>{@code e}<\/sup>.\n@@ -357,2 +284,2 @@\n-     * @param p2 The exponent of 2.\n-     * @return <code>2<sup>p2<\/sup><\/code>\n+     * @param e The exponent of 2.\n+     * @return 2<sup>{@code e}<\/sup>\n@@ -360,9 +287,2 @@\n-    \/*@\n-     @ requires p2 >= 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == pow52(0, p2);\n-     @*\/\n-    private static FDBigInteger valueOfPow2(int p2) {\n-        int wordcount = p2 >> 5;\n-        int bitcount = p2 & 0x1f;\n-        return new FDBigInteger(new int[]{1 << bitcount}, wordcount);\n+    private static FDBigInteger valueOfPow2(int e) {\n+        return new FDBigInteger(new int[] {1 << (e & 0x1f)}, e >> 5);\n@@ -372,1 +292,1 @@\n-     * Removes all leading zeros from this <code>FDBigInteger<\/code> adjusting\n+     * Removes all leading zeros from this {@link FDBigInteger} adjusting\n@@ -375,18 +295,6 @@\n-    \/*@\n-     @ requires data != null;\n-     @ requires 0 <= nWords && nWords <= data.length && offset >= 0;\n-     @ requires nWords == 0 ==> offset == 0;\n-     @ ensures nWords == 0 ==> offset == 0;\n-     @ ensures nWords > 0 ==> data[nWords - 1] != 0;\n-     @*\/\n-    private \/*@ helper @*\/ void trimLeadingZeros() {\n-        int i = nWords;\n-        if (i > 0 && (data[--i] == 0)) {\n-            \/\/for (; i > 0 && data[i - 1] == 0; i--) ;\n-            while(i > 0 && data[i - 1] == 0) {\n-                i--;\n-            }\n-            this.nWords = i;\n-            if (i == 0) { \/\/ all words are zero\n-                this.offset = 0;\n-            }\n+    private void trimLeadingZeros() {\n+        int i = nWords - 1;\n+        for (; i >= 0 && data[i] == 0; --i);  \/\/ empty body\n+        nWords = i + 1;\n+        if (i < 0) {\n+            offset = 0;\n@@ -397,1 +305,1 @@\n-     * Retrieves the normalization bias of the <code>FDBigIntger<\/code>. The\n+     * Retrieves the normalization bias of the {@link FDBigInteger}. The\n@@ -405,4 +313,1 @@\n-    \/*@\n-     @ requires this.value() > 0;\n-     @*\/\n-    public \/*@ pure @*\/ int getNormalizationBias() {\n+    public int getNormalizationBias() {\n@@ -416,1 +321,0 @@\n-    \/\/ TODO: Why is anticount param needed if it is always 32 - bitcount?\n@@ -424,1 +328,0 @@\n-     * @param anticount The left anti-shift, e.g., <code>32-bitcount<\/code>.\n@@ -427,7 +330,1 @@\n-    \/*@\n-     @ requires 0 < bitcount && bitcount < 32 && anticount == 32 - bitcount;\n-     @ requires src.length >= idx && result.length > idx;\n-     @ assignable result[*];\n-     @ ensures AP(result, \\old(idx + 1)) == \\old((AP(src, idx) + UNSIGNED(prev) << (idx*32)) << bitcount);\n-     @*\/\n-    private static void leftShift(int[] src, int idx, int result[], int bitcount, int anticount, int prev){\n+    private static void leftShift(int[] src, int idx, int[] result, int bitcount, int prev) {\n@@ -435,1 +332,1 @@\n-            int v = (prev << bitcount);\n+            int v = prev << bitcount;\n@@ -437,1 +334,1 @@\n-            v |= (prev >>> anticount);\n+            v |= prev >>> -bitcount;\n@@ -445,3 +342,3 @@\n-     * Shifts this <code>FDBigInteger<\/code> to the left. The shift is performed\n-     * in-place unless the <code>FDBigInteger<\/code> is immutable in which case\n-     * a new instance of <code>FDBigInteger<\/code> is returned.\n+     * Shifts this {@link FDBigInteger} to the left. The shift is performed\n+     * in-place unless the {@link FDBigInteger} is immutable in which case\n+     * a new instance of {@link FDBigInteger} is returned.\n@@ -450,1 +347,1 @@\n-     * @return The shifted <code>FDBigInteger<\/code>.\n+     * @return The shifted {@link FDBigInteger}.\n@@ -452,18 +349,0 @@\n-    \/*@\n-     @ requires this.value() == 0 || shift == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && shift > 0 && this.isImmutable;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() << shift);\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && shift > 0 && this.isImmutable;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() << shift);\n-     @*\/\n@@ -476,1 +355,1 @@\n-        if (this.isImmutable) {\n+        if (isImmutable) {\n@@ -479,0 +358,30 @@\n+            }\n+            int idx = nWords - 1;\n+            int prev = data[idx];\n+            int hi = prev >>> -bitcount;\n+            int[] result;\n+            if (hi != 0) {\n+                result = new int[nWords + 1];\n+                result[nWords] = hi;\n+            } else {\n+                result = new int[nWords];\n+            }\n+            leftShift(data, idx, result, bitcount, prev);\n+            return new FDBigInteger(result, offset + wordcount);\n+        }\n+        if (bitcount != 0) {\n+            if (data[0] << bitcount == 0) {\n+                int idx = 0;\n+                int prev = data[idx];\n+                for (; idx < nWords - 1; idx++) {\n+                    int v = prev >>> -bitcount;\n+                    prev = data[idx + 1];\n+                    v |= prev << bitcount;\n+                    data[idx] = v;\n+                }\n+                int v = prev >>> -bitcount;\n+                data[idx] = v;\n+                if (v == 0) {\n+                    nWords--;\n+                }\n+                offset++;\n@@ -480,1 +389,0 @@\n-                int anticount = 32 - bitcount;\n@@ -483,2 +391,3 @@\n-                int hi = prev >>> anticount;\n-                int[] result;\n+                int hi = prev >>> -bitcount;\n+                int[] result = data;\n+                int[] src = data;\n@@ -486,24 +395,2 @@\n-                    result = new int[nWords + 1];\n-                    result[nWords] = hi;\n-                } else {\n-                    result = new int[nWords];\n-                }\n-                leftShift(data,idx,result,bitcount,anticount,prev);\n-                return new FDBigInteger(result, offset + wordcount);\n-            }\n-        } else {\n-            if (bitcount != 0) {\n-                int anticount = 32 - bitcount;\n-                if ((data[0] << bitcount) == 0) {\n-                    int idx = 0;\n-                    int prev = data[idx];\n-                    for (; idx < nWords - 1; idx++) {\n-                        int v = (prev >>> anticount);\n-                        prev = data[idx + 1];\n-                        v |= (prev << bitcount);\n-                        data[idx] = v;\n-                    }\n-                    int v = prev >>> anticount;\n-                    data[idx] = v;\n-                    if(v==0) {\n-                        nWords--;\n+                    if (nWords == data.length) {\n+                        data = result = new int[nWords + 1];\n@@ -511,14 +398,1 @@\n-                    offset++;\n-                } else {\n-                    int idx = nWords - 1;\n-                    int prev = data[idx];\n-                    int hi = prev >>> anticount;\n-                    int[] result = data;\n-                    int[] src = data;\n-                    if (hi != 0) {\n-                        if(nWords == data.length) {\n-                            data = result = new int[nWords + 1];\n-                        }\n-                        result[nWords++] = hi;\n-                    }\n-                    leftShift(src,idx,result,bitcount,anticount,prev);\n+                    result[nWords++] = hi;\n@@ -526,0 +400,1 @@\n+                leftShift(src, idx, result, bitcount, prev);\n@@ -527,2 +402,0 @@\n-            offset += wordcount;\n-            return this;\n@@ -530,0 +403,2 @@\n+        offset += wordcount;\n+        return this;\n@@ -533,1 +408,1 @@\n-     * Returns the number of <code>int<\/code>s this <code>FDBigInteger<\/code> represents.\n+     * Returns the number of {@code int}s this {@link FDBigInteger} represents.\n@@ -535,1 +410,1 @@\n-     * @return Number of <code>int<\/code>s required to represent this <code>FDBigInteger<\/code>.\n+     * @return Number of {@code int}s required to represent this {@link FDBigInteger}.\n@@ -537,10 +412,1 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ ensures \\result == 0;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0;\n-     @ ensures ((\\bigint)1) << (\\result - 1) <= this.value() && this.value() <= ((\\bigint)1) << \\result;\n-     @*\/\n-    private \/*@ pure @*\/ int size() {\n+    private int size() {\n@@ -550,0 +416,8 @@\n+    \/**\n+     * Returns whether this {@link FDBigInteger} is zero.\n+     *\n+     * @return {@code this} is zero.\n+     *\/\n+    public boolean isZero() {\n+        return nWords == 0;\n+    }\n@@ -564,2 +438,2 @@\n-     * @param S The divisor of this <code>FDBigInteger<\/code>.\n-     * @return <code>q = (int)(this \/ S)<\/code>.\n+     * @param S The divisor of this {@link FDBigInteger}.\n+     * @return {@code q = (int)(this \/ S)}.\n@@ -567,9 +441,0 @@\n-    \/*@\n-     @ requires !this.isImmutable;\n-     @ requires this.size() <= S.size();\n-     @ requires this.data.length + this.offset >= S.size();\n-     @ requires S.value() >= ((\\bigint)1) << (S.size()*32 - 4);\n-     @ assignable this.nWords, this.offset, this.data, this.data[*];\n-     @ ensures \\result == \\old(this.value() \/ S.value());\n-     @ ensures this.value() == \\old(10 * (this.value() % S.value()));\n-     @*\/\n@@ -600,1 +465,1 @@\n-        long diff = multDiffMe(q, S);\n+        long diff = multSub(q, S);\n@@ -642,3 +507,3 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by 10. The operation will be\n-     * performed in place unless the <code>FDBigInteger<\/code> is immutable in\n-     * which case a new <code>FDBigInteger<\/code> will be returned.\n+     * Multiplies this {@link FDBigInteger} by 10. The operation will be\n+     * performed in place unless the {@link FDBigInteger} is immutable in\n+     * which case a new {@link FDBigInteger} will be returned.\n@@ -646,1 +511,1 @@\n-     * @return The <code>FDBigInteger<\/code> multiplied by 10.\n+     * @return The {@link FDBigInteger} multiplied by 10.\n@@ -648,18 +513,0 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && this.isImmutable;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * 10);\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && !this.isImmutable;\n-     @ assignable this.nWords, this.data, this.data[*];\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() * 10);\n-     @*\/\n@@ -694,3 +541,3 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by\n-     * <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>. The operation will be\n-     * performed in place if possible, otherwise a new <code>FDBigInteger<\/code>\n+     * Multiplies this {@link FDBigInteger} by\n+     * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>. The operation will be\n+     * performed in place if possible, otherwise a new {@link FDBigInteger}\n@@ -699,2 +546,2 @@\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n+     * @param e5 The exponent of the power-of-five factor.\n+     * @param e2 The exponent of the power-of-two factor.\n@@ -703,20 +550,2 @@\n-    \/*@\n-     @ requires this.value() == 0 || p5 == 0 && p2 == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && (p5 > 0 && p2 >= 0 || p5 == 0 && p2 > 0 && this.isImmutable);\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * pow52(p5, p2));\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && p5 == 0 && p2 > 0 && !this.isImmutable;\n-     @ assignable this.nWords, this.data, this.data[*];\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() * pow52(p5, p2));\n-     @*\/\n-    public FDBigInteger multByPow52(int p5, int p2) {\n-        if (this.nWords == 0) {\n+    public FDBigInteger multByPow52(int e5, int e2) {\n+        if (nWords == 0) {\n@@ -726,1 +555,1 @@\n-        if (p5 != 0) {\n+        if (e5 != 0) {\n@@ -728,5 +557,8 @@\n-            int extraSize = (p2 != 0) ? 1 : 0;\n-            if (p5 < SMALL_5_POW.length) {\n-                r = new int[this.nWords + 1 + extraSize];\n-                mult(this.data, this.nWords, SMALL_5_POW[p5], r);\n-                res = new FDBigInteger(r, this.offset);\n+            int extraSize = e2 != 0 ? 1 : 0;  \/\/ accounts for e2 % 32 shift bits\n+            if (e5 < SMALL_5_POW.length) {\n+                r = new int[nWords + 1 + extraSize];\n+                mult(data, nWords, SMALL_5_POW[e5], r);\n+            } else if (e5 < LONG_5_POW.length) {\n+                long pow5 = LONG_5_POW[e5];\n+                r = new int[nWords + 2 + extraSize];\n+                mult(data, nWords, (int) pow5, (int) (pow5 >>> 32), r);\n@@ -734,4 +566,3 @@\n-                FDBigInteger pow5 = big5pow(p5);\n-                r = new int[this.nWords + pow5.size() + extraSize];\n-                mult(this.data, this.nWords, pow5.data, pow5.nWords, r);\n-                res = new FDBigInteger(r, this.offset + pow5.offset);\n+                FDBigInteger pow5 = pow5(e5);\n+                r = new int[nWords + pow5.nWords + extraSize];\n+                mult(data, nWords, pow5.data, pow5.nWords, r);\n@@ -739,0 +570,1 @@\n+            res = new FDBigInteger(r, offset);\n@@ -740,1 +572,1 @@\n-        return res.leftShift(p2);\n+        return res.leftShift(e2);\n@@ -747,1 +579,1 @@\n-     * @param s1Len The number of elements of <code>s1<\/code> to use.\n+     * @param s1Len The number of elements of {@code s1} to use.\n@@ -749,1 +581,1 @@\n-     * @param s2Len The number of elements of <code>s2<\/code> to use.\n+     * @param s2Len The number of elements of {@code s2} to use.\n@@ -752,6 +584,0 @@\n-    \/*@\n-     @ requires s1 != dst && s2 != dst;\n-     @ requires s1.length >= s1Len && s2.length >= s2Len && dst.length >= s1Len + s2Len;\n-     @ assignable dst[0 .. s1Len + s2Len - 1];\n-     @ ensures AP(dst, s1Len + s2Len) == \\old(AP(s1, s1Len) * AP(s2, s2Len));\n-     @*\/\n@@ -759,0 +585,5 @@\n+        if (s1Len > s2Len) {\n+            \/* Swap ensures that inner loop is longest. *\/\n+            int l = s1Len; s1Len = s2Len; s2Len = l;\n+            int[] s = s1; s1 = s2; s2 = s;\n+        }\n@@ -771,152 +602,0 @@\n-    \/**\n-     * Subtracts the supplied <code>FDBigInteger<\/code> subtrahend from this\n-     * <code>FDBigInteger<\/code>. Assert that the result is positive.\n-     * If the subtrahend is immutable, store the result in this(minuend).\n-     * If this(minuend) is immutable a new <code>FDBigInteger<\/code> is created.\n-     *\n-     * @param subtrahend The <code>FDBigInteger<\/code> to be subtracted.\n-     * @return This <code>FDBigInteger<\/code> less the subtrahend.\n-     *\/\n-    \/*@\n-     @ requires this.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @\n-     @  also\n-     @\n-     @ requires !subtrahend.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable this.nWords, this.offset, this.data, this.data[*];\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @*\/\n-    public FDBigInteger leftInplaceSub(FDBigInteger subtrahend) {\n-        assert this.size() >= subtrahend.size() : \"result should be positive\";\n-        FDBigInteger minuend;\n-        if (this.isImmutable) {\n-            minuend = new FDBigInteger(this.data.clone(), this.offset);\n-        } else {\n-            minuend = this;\n-        }\n-        int offsetDiff = subtrahend.offset - minuend.offset;\n-        int[] sData = subtrahend.data;\n-        int[] mData = minuend.data;\n-        int subLen = subtrahend.nWords;\n-        int minLen = minuend.nWords;\n-        if (offsetDiff < 0) {\n-            \/\/ need to expand minuend\n-            int rLen = minLen - offsetDiff;\n-            if (rLen < mData.length) {\n-                System.arraycopy(mData, 0, mData, -offsetDiff, minLen);\n-                Arrays.fill(mData, 0, -offsetDiff, 0);\n-            } else {\n-                int[] r = new int[rLen];\n-                System.arraycopy(mData, 0, r, -offsetDiff, minLen);\n-                minuend.data = mData = r;\n-            }\n-            minuend.offset = subtrahend.offset;\n-            minuend.nWords = minLen = rLen;\n-            offsetDiff = 0;\n-        }\n-        long borrow = 0L;\n-        int mIndex = offsetDiff;\n-        for (int sIndex = 0; sIndex < subLen && mIndex < minLen; sIndex++, mIndex++) {\n-            long diff = (mData[mIndex] & LONG_MASK) - (sData[sIndex] & LONG_MASK) + borrow;\n-            mData[mIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        for (; borrow != 0 && mIndex < minLen; mIndex++) {\n-            long diff = (mData[mIndex] & LONG_MASK) + borrow;\n-            mData[mIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        assert borrow == 0L : borrow; \/\/ borrow out of subtract,\n-        \/\/ result should be positive\n-        minuend.trimLeadingZeros();\n-        return minuend;\n-    }\n-\n-    \/**\n-     * Subtracts the supplied <code>FDBigInteger<\/code> subtrahend from this\n-     * <code>FDBigInteger<\/code>. Assert that the result is positive.\n-     * If the this(minuend) is immutable, store the result in subtrahend.\n-     * If subtrahend is immutable a new <code>FDBigInteger<\/code> is created.\n-     *\n-     * @param subtrahend The <code>FDBigInteger<\/code> to be subtracted.\n-     * @return This <code>FDBigInteger<\/code> less the subtrahend.\n-     *\/\n-    \/*@\n-     @ requires subtrahend.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @\n-     @  also\n-     @\n-     @ requires !subtrahend.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable subtrahend.nWords, subtrahend.offset, subtrahend.data, subtrahend.data[*];\n-     @ ensures \\result == subtrahend;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @*\/\n-    public FDBigInteger rightInplaceSub(FDBigInteger subtrahend) {\n-        assert this.size() >= subtrahend.size() : \"result should be positive\";\n-        FDBigInteger minuend = this;\n-        if (subtrahend.isImmutable) {\n-            subtrahend = new FDBigInteger(subtrahend.data.clone(), subtrahend.offset);\n-        }\n-        int offsetDiff = minuend.offset - subtrahend.offset;\n-        int[] sData = subtrahend.data;\n-        int[] mData = minuend.data;\n-        int subLen = subtrahend.nWords;\n-        int minLen = minuend.nWords;\n-        if (offsetDiff < 0) {\n-            int rLen = minLen;\n-            if (rLen < sData.length) {\n-                System.arraycopy(sData, 0, sData, -offsetDiff, subLen);\n-                Arrays.fill(sData, 0, -offsetDiff, 0);\n-            } else {\n-                int[] r = new int[rLen];\n-                System.arraycopy(sData, 0, r, -offsetDiff, subLen);\n-                subtrahend.data = sData = r;\n-            }\n-            subtrahend.offset = minuend.offset;\n-            subLen -= offsetDiff;\n-            offsetDiff = 0;\n-        } else {\n-            int rLen = minLen + offsetDiff;\n-            if (rLen >= sData.length) {\n-                subtrahend.data = sData = Arrays.copyOf(sData, rLen);\n-            }\n-        }\n-        \/\/@ assert minuend == this && minuend.value() == \\old(this.value());\n-        \/\/@ assert mData == minuend.data && minLen == minuend.nWords;\n-        \/\/@ assert subtrahend.offset + subtrahend.data.length >= minuend.size();\n-        \/\/@ assert sData == subtrahend.data;\n-        \/\/@ assert AP(subtrahend.data, subtrahend.data.length) << subtrahend.offset == \\old(subtrahend.value());\n-        \/\/@ assert subtrahend.offset == Math.min(\\old(this.offset), minuend.offset);\n-        \/\/@ assert offsetDiff == minuend.offset - subtrahend.offset;\n-        \/\/@ assert 0 <= offsetDiff && offsetDiff + minLen <= sData.length;\n-        int sIndex = 0;\n-        long borrow = 0L;\n-        for (; sIndex < offsetDiff; sIndex++) {\n-            long diff = 0L - (sData[sIndex] & LONG_MASK) + borrow;\n-            sData[sIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        \/\/@ assert sIndex == offsetDiff;\n-        for (int mIndex = 0; mIndex < minLen; sIndex++, mIndex++) {\n-            \/\/@ assert sIndex == offsetDiff + mIndex;\n-            long diff = (mData[mIndex] & LONG_MASK) - (sData[sIndex] & LONG_MASK) + borrow;\n-            sData[sIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        assert borrow == 0L : borrow; \/\/ borrow out of subtract,\n-        \/\/ result should be positive\n-        subtrahend.nWords = sIndex;\n-        subtrahend.trimLeadingZeros();\n-        return subtrahend;\n-\n-    }\n-\n@@ -931,5 +610,1 @@\n-    \/*@\n-     @ requires 0 <= from && from <= a.length;\n-     @ ensures \\result == (AP(a, from) == 0 ? 0 : 1);\n-     @*\/\n-    private \/*@ pure @*\/ static int checkZeroTail(int[] a, int from) {\n+    private static int checkZeroTail(int[] a, int from) {\n@@ -945,1 +620,1 @@\n-     * Compares the parameter with this <code>FDBigInteger<\/code>. Returns an\n+     * Compares the parameter with this {@link FDBigInteger}. Returns an\n@@ -953,1 +628,1 @@\n-     * @param other The <code>FDBigInteger<\/code> to compare.\n+     * @param other The {@link FDBigInteger} to compare.\n@@ -957,4 +632,1 @@\n-    \/*@\n-     @ ensures \\result == (this.value() < other.value() ? -1 : this.value() > other.value() ? +1 : 0);\n-     @*\/\n-    public \/*@ pure @*\/ int cmp(FDBigInteger other) {\n+    public int cmp(FDBigInteger other) {\n@@ -971,4 +643,3 @@\n-            int a = data[--aLen];\n-            int b = other.data[--bLen];\n-            if (a != b) {\n-                return ((a & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;\n+            int cmp = Integer.compareUnsigned(data[--aLen], other.data[--bLen]);\n+            if (cmp != 0) {\n+                return cmp;\n@@ -987,39 +658,1 @@\n-     * Compares this <code>FDBigInteger<\/code> with\n-     * <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>.\n-     * Returns an integer accordingly as:\n-     * <pre>{@code\n-     * > 0: this > other\n-     *   0: this == other\n-     * < 0: this < other\n-     * }<\/pre>\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n-     * @return A negative value, zero, or a positive value according to the\n-     * result of the comparison.\n-     *\/\n-    \/*@\n-     @ requires p5 >= 0 && p2 >= 0;\n-     @ ensures \\result == (this.value() < pow52(p5, p2) ? -1 : this.value() >  pow52(p5, p2) ? +1 : 0);\n-     @*\/\n-    public \/*@ pure @*\/ int cmpPow52(int p5, int p2) {\n-        if (p5 == 0) {\n-            int wordcount = p2 >> 5;\n-            int bitcount = p2 & 0x1f;\n-            int size = this.nWords + this.offset;\n-            if (size > wordcount + 1) {\n-                return 1;\n-            } else if (size < wordcount + 1) {\n-                return -1;\n-            }\n-            int a = this.data[this.nWords -1];\n-            int b = 1 << bitcount;\n-            if (a != b) {\n-                return ( (a & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;\n-            }\n-            return checkZeroTail(this.data, this.nWords - 1);\n-        }\n-        return this.cmp(big5pow(p5).leftShift(p2));\n-    }\n-\n-    \/**\n-     * Compares this <code>FDBigInteger<\/code> with <code>x + y<\/code>. Returns a\n+     * Compares this {@link FDBigInteger} with {@code x + y}. Returns a\n@@ -1036,4 +669,1 @@\n-    \/*@\n-     @ ensures \\result == (this.value() < x.value() + y.value() ? -1 : this.value() > x.value() + y.value() ? +1 : 0);\n-     @*\/\n-    public \/*@ pure @*\/ int addAndCmp(FDBigInteger x, FDBigInteger y) {\n+    public int addAndCmp(FDBigInteger x, FDBigInteger y) {\n@@ -1107,1 +737,3 @@\n-     * Makes this <code>FDBigInteger<\/code> immutable.\n+     * Makes this {@link FDBigInteger} immutable.\n+     *\n+     * @return {@code this}\n@@ -1109,6 +741,3 @@\n-    \/*@\n-     @ assignable this.isImmutable;\n-     @ ensures this.isImmutable;\n-     @*\/\n-    public void makeImmutable() {\n-        this.isImmutable = true;\n+    public FDBigInteger makeImmutable() {\n+        isImmutable = true;\n+        return this;\n@@ -1118,1 +747,1 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by an integer.\n+     * Multiplies this {@link FDBigInteger} by an integer.\n@@ -1120,2 +749,2 @@\n-     * @param i The factor by which to multiply this <code>FDBigInteger<\/code>.\n-     * @return This <code>FDBigInteger<\/code> multiplied by an integer.\n+     * @param v The factor by which to multiply this {@link FDBigInteger}.\n+     * @return This {@link FDBigInteger} multiplied by an integer.\n@@ -1123,13 +752,2 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() != 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * UNSIGNED(i));\n-     @*\/\n-    private FDBigInteger mult(int i) {\n-        if (this.nWords == 0) {\n+    public FDBigInteger mult(int v) {\n+        if (nWords == 0 || v == 0) {\n@@ -1139,1 +757,1 @@\n-        mult(data, nWords, i, r);\n+        mult(data, nWords, v, r);\n@@ -1144,1 +762,1 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by another <code>FDBigInteger<\/code>.\n+     * Multiplies this {@link FDBigInteger} by another {@link FDBigInteger}.\n@@ -1146,2 +764,2 @@\n-     * @param other The <code>FDBigInteger<\/code> factor by which to multiply.\n-     * @return The product of this and the parameter <code>FDBigInteger<\/code>s.\n+     * @param other The {@link FDBigInteger} factor by which to multiply.\n+     * @return The product of this and the parameter {@link FDBigInteger}s.\n@@ -1149,17 +767,0 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() != 0 && other.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == other;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() != 0 && other.value() != 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * other.value());\n-     @*\/\n@@ -1167,12 +768,0 @@\n-        if (this.nWords == 0) {\n-            return this;\n-        }\n-        if (this.size() == 1) {\n-            return other.mult(data[0]);\n-        }\n-        if (other.nWords == 0) {\n-            return other;\n-        }\n-        if (other.size() == 1) {\n-            return this.mult(other.data[0]);\n-        }\n@@ -1180,2 +769,2 @@\n-        mult(this.data, this.nWords, other.data, other.nWords, r);\n-        return new FDBigInteger(r, this.offset + other.offset);\n+        mult(data, nWords, other.data, other.nWords, r);\n+        return new FDBigInteger(r, offset + other.offset);\n@@ -1185,1 +774,1 @@\n-     * Adds another <code>FDBigInteger<\/code> to this <code>FDBigInteger<\/code>.\n+     * Adds another {@link FDBigInteger} to this {@link FDBigInteger}.\n@@ -1187,2 +776,2 @@\n-     * @param other The <code>FDBigInteger<\/code> to add.\n-     * @return The sum of the <code>FDBigInteger<\/code>s.\n+     * @param other The {@link FDBigInteger} to add.\n+     * @return The sum of the {@link FDBigInteger}s.\n@@ -1190,4 +779,0 @@\n-    \/*@\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() + other.value());\n-     @*\/\n@@ -1230,1 +815,1 @@\n-     * Multiplies a <code>FDBigInteger<\/code> by an int and adds another int. The\n+     * Multiplies a {@link FDBigInteger} by an int and adds another int. The\n@@ -1232,4 +817,1 @@\n-     * from\n-     * <code>\n-     * FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits)\n-     * <\/code>.\n+     * from {@link FDBigInteger(long,char[],int,int)}.\n@@ -1237,1 +819,1 @@\n-     * @param iv The factor by which to multiply this <code>FDBigInteger<\/code>.\n+     * @param iv The factor by which to multiply this {@link FDBigInteger}.\n@@ -1239,1 +821,1 @@\n-     * <code>FDBigInteger<\/code> and <code>iv<\/code>.\n+     * {@link FDBigInteger} and {@code iv}.\n@@ -1241,6 +823,1 @@\n-    \/*@\n-     @ requires this.value()*UNSIGNED(iv) + UNSIGNED(addend) < ((\\bigint)1) << ((this.data.length + this.offset)*32);\n-     @ assignable this.data[*];\n-     @ ensures this.value() == \\old(this.value()*UNSIGNED(iv) + UNSIGNED(addend));\n-     @*\/\n-    private \/*@ helper @*\/ void multAddMe(int iv, int addend) {\n+    private void multAdd(int iv, int addend) {\n@@ -1258,1 +835,1 @@\n-            data[nWords++] = (int) p; \/\/ will fail noisily if illegal!\n+            data[nWords++] = (int) p;\n@@ -1262,6 +839,0 @@\n-    \/\/\n-    \/\/ original doc:\n-    \/\/\n-    \/\/ do this -=q*S\n-    \/\/ returns borrow\n-    \/\/\n@@ -1269,2 +840,1 @@\n-     * Multiplies the parameters and subtracts them from this\n-     * <code>FDBigInteger<\/code>.\n+     * Multiplies the parameters and subtracts them from this {@link FDBigInteger}.\n@@ -1273,2 +843,2 @@\n-     * @param S The <code>FDBigInteger<\/code> parameter.\n-     * @return <code>this - q*S<\/code>.\n+     * @param S The {@link FDBigInteger} parameter.\n+     * @return {@code this - q*S}.\n@@ -1276,27 +846,1 @@\n-    \/*@\n-     @ ensures nWords == 0 ==> offset == 0;\n-     @ ensures nWords > 0 ==> data[nWords - 1] != 0;\n-     @*\/\n-    \/*@\n-     @ requires 0 < q && q <= (1L << 31);\n-     @ requires data != null;\n-     @ requires 0 <= nWords && nWords <= data.length && offset >= 0;\n-     @ requires !this.isImmutable;\n-     @ requires this.size() == S.size();\n-     @ requires this != S;\n-     @ assignable this.nWords, this.offset, this.data, this.data[*];\n-     @ ensures -q <= \\result && \\result <= 0;\n-     @ ensures this.size() == \\old(this.size());\n-     @ ensures this.value() + (\\result << (this.size()*32)) == \\old(this.value() - q*S.value());\n-     @ ensures this.offset == \\old(Math.min(this.offset, S.offset));\n-     @ ensures \\old(this.offset <= S.offset) ==> this.nWords == \\old(this.nWords);\n-     @ ensures \\old(this.offset <= S.offset) ==> this.offset == \\old(this.offset);\n-     @ ensures \\old(this.offset <= S.offset) ==> this.data == \\old(this.data);\n-     @\n-     @  also\n-     @\n-     @ requires q == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == 0;\n-     @*\/\n-    private \/*@ helper @*\/ long multDiffMe(long q, FDBigInteger S) {\n+    private long multSub(long q, FDBigInteger S) {\n@@ -1340,1 +884,0 @@\n-\n@@ -1346,1 +889,1 @@\n-     * @param srcLen The number of elements of <code>src<\/code> to use.\n+     * @param srcLen The number of elements of {@code src} to use.\n@@ -1350,6 +893,0 @@\n-    \/*@\n-     @ requires src.length >= srcLen && dst.length >= srcLen;\n-     @ assignable dst[0 .. srcLen - 1];\n-     @ ensures 0 <= \\result && \\result < 10;\n-     @ ensures AP(dst, srcLen) + (\\result << (srcLen*32)) == \\old(AP(src, srcLen) * 10);\n-     @*\/\n@@ -1368,1 +905,1 @@\n-     * The constant factor is an <code>int<\/code>.\n+     * The constant factor is an {@code int}.\n@@ -1371,1 +908,1 @@\n-     * @param srcLen The number of elements of <code>src<\/code> to use.\n+     * @param srcLen The number of elements of {@code src} to use.\n@@ -1375,5 +912,0 @@\n-    \/*@\n-     @ requires src.length >= srcLen && dst.length >= srcLen + 1;\n-     @ assignable dst[0 .. srcLen];\n-     @ ensures AP(dst, srcLen + 1) == \\old(AP(src, srcLen) * UNSIGNED(value));\n-     @*\/\n@@ -1381,1 +913,1 @@\n-        long val = value & LONG_MASK;\n+        long v = value & LONG_MASK;\n@@ -1383,2 +915,3 @@\n-        for (int i = 0; i < srcLen; i++) {\n-            long product = (src[i] & LONG_MASK) * val + carry;\n+        int i = 0;\n+        for (; i < srcLen; i++) {\n+            long product = v * (src[i] & LONG_MASK) + carry;\n@@ -1388,1 +921,1 @@\n-        dst[srcLen] = (int) carry;\n+        dst[i] = (int) carry;\n@@ -1393,1 +926,1 @@\n-     * The constant factor is a long represent as two <code>int<\/code>s.\n+     * The constant factor is a long represent as two {@code int}s.\n@@ -1396,1 +929,1 @@\n-     * @param srcLen The number of elements of <code>src<\/code> to use.\n+     * @param srcLen The number of elements of {@code src} to use.\n@@ -1401,6 +934,0 @@\n-    \/*@\n-     @ requires src != dst;\n-     @ requires src.length >= srcLen && dst.length >= srcLen + 2;\n-     @ assignable dst[0 .. srcLen + 1];\n-     @ ensures AP(dst, srcLen + 2) == \\old(AP(src, srcLen) * (UNSIGNED(v0) + (UNSIGNED(v1) << 32)));\n-     @*\/\n@@ -1410,1 +937,2 @@\n-        for (int j = 0; j < srcLen; j++) {\n+        int j = 0;\n+        for (; j < srcLen; j++) {\n@@ -1415,1 +943,2 @@\n-        dst[srcLen] = (int) carry;\n+        dst[j] = (int) carry;\n+\n@@ -1418,3 +947,4 @@\n-        for (int j = 0; j < srcLen; j++) {\n-            long product = (dst[j + 1] & LONG_MASK) + v * (src[j] & LONG_MASK) + carry;\n-            dst[j + 1] = (int) product;\n+        j = 1;\n+        for (; j <= srcLen; j++) {\n+            long product = (dst[j] & LONG_MASK) + v * (src[j - 1] & LONG_MASK) + carry;\n+            dst[j] = (int) product;\n@@ -1423,1 +953,1 @@\n-        dst[srcLen + 1] = (int) carry;\n+        dst[j] = (int) carry;\n@@ -1426,3 +956,5 @@\n-    \/\/ Fails assertion for negative exponent.\n-    \/**\n-     * Computes <code>5<\/code> raised to a given power.\n+    \/*\n+     * Lookup table of powers of 5 starting with 5^MAX_FIVE_POW.\n+     * The size just serves for the conversions.\n+     * It is filled lazily, except for the entries with exponent\n+     * 2 (MAX_FIVE_POW - 1) and 3 (MAX_FIVE_POW - 1).\n@@ -1430,2 +962,1 @@\n-     * @param p The exponent of 5.\n-     * @return <code>5<sup>p<\/sup><\/code>.\n+     * Access must be synchronized for thread-safety.\n@@ -1433,7 +964,1 @@\n-    private static FDBigInteger big5pow(int p) {\n-        assert p >= 0 : p; \/\/ negative power of 5\n-        if (p < MAX_FIVE_POW) {\n-            return POW_5_CACHE[p];\n-        }\n-        return big5powRec(p);\n-    }\n+    private static final FDBigInteger[] LARGE_POW_5_CACHE;\n@@ -1441,1 +966,0 @@\n-    \/\/ slow path\n@@ -1443,1 +967,1 @@\n-     * Computes <code>5<\/code> raised to a given power.\n+     * Computes 5<sup>{@code e}<\/sup>.\n@@ -1445,2 +969,3 @@\n-     * @param p The exponent of 5.\n-     * @return <code>5<sup>p<\/sup><\/code>.\n+     * @param e The exponent of 5.\n+     * @return 5<sup>{@code e}<\/sup>.\n+     * @throws IllegalArgumentException if e > 2 - DoubleToDecimal.Q_MIN = 1076\n@@ -1448,3 +973,3 @@\n-    private static FDBigInteger big5powRec(int p) {\n-        if (p < MAX_FIVE_POW) {\n-            return POW_5_CACHE[p];\n+    private static FDBigInteger pow5(int e) {\n+        if (e < MAX_FIVE_POW) {\n+            return POW_5_CACHE[e];\n@@ -1452,14 +977,14 @@\n-        \/\/ construct the value.\n-        \/\/ recursively.\n-        int q, r;\n-        \/\/ in order to compute 5^p,\n-        \/\/ compute its square root, 5^(p\/2) and square.\n-        \/\/ or, let q = p \/ 2, r = p -q, then\n-        \/\/ 5^p = 5^(q+r) = 5^q * 5^r\n-        q = p >> 1;\n-        r = p - q;\n-        FDBigInteger bigq = big5powRec(q);\n-        if (r < SMALL_5_POW.length) {\n-            return bigq.mult(SMALL_5_POW[r]);\n-        } else {\n-            return bigq.mult(big5powRec(r));\n+        if (e > 2 - DoubleToDecimal.Q_MIN) {\n+            throw new IllegalArgumentException(\"exponent too large: \" + e);\n+        }\n+        synchronized (LARGE_POW_5_CACHE) {\n+            FDBigInteger p5 = LARGE_POW_5_CACHE[e - MAX_FIVE_POW];\n+            if (p5 == null) {\n+                int ep = (e - 1) - (e - 1) % (MAX_FIVE_POW - 1);\n+                p5 = (ep < MAX_FIVE_POW\n+                        ? POW_5_CACHE[ep]\n+                        : LARGE_POW_5_CACHE[ep - MAX_FIVE_POW])\n+                        .mult(POW_5_CACHE[e - ep]);\n+                LARGE_POW_5_CACHE[e - MAX_FIVE_POW] = p5.makeImmutable();\n+            }\n+            return p5;\n@@ -1471,1 +996,1 @@\n-     * Converts this <code>FDBigInteger<\/code> to a hexadecimal string.\n+     * Converts this {@link FDBigInteger} to a hexadecimal string.\n@@ -1475,2 +1000,3 @@\n-    public String toHexString(){\n-        if(nWords ==0) {\n+    @Override\n+    public String toString() {\n+        if (nWords == 0) {\n@@ -1479,10 +1005,6 @@\n-        StringBuilder sb = new StringBuilder((nWords +offset)*8);\n-        for(int i= nWords -1; i>=0; i--) {\n-            String subStr = Integer.toHexString(data[i]);\n-            for(int j = subStr.length(); j<8; j++) {\n-                sb.append('0');\n-            }\n-            sb.append(subStr);\n-        }\n-        for(int i=offset; i>0; i--) {\n-            sb.append(\"00000000\");\n+        StringBuilder sb = new StringBuilder(8 * (size()));\n+        int i = nWords - 1;\n+        sb.append(Integer.toHexString(data[i--]));\n+        while (i >= 0) {\n+            String subStr = Integer.toHexString(data[i--]);\n+            sb.repeat('0', 8 - subStr.length()).append(subStr);\n@@ -1490,1 +1012,1 @@\n-        return sb.toString();\n+        return sb.repeat('0', 8 * offset).toString();\n@@ -1495,1 +1017,2 @@\n-     * Converts this <code>FDBigInteger<\/code> to a <code>BigInteger<\/code>.\n+     * Converts this {@link FDBigInteger} to a {@code byte[]} suitable\n+     * for use with {@link java.math.BigInteger#BigInteger(byte[])}.\n@@ -1497,1 +1020,1 @@\n-     * @return The <code>BigInteger<\/code> representation.\n+     * @return The {@code byte[]} representation.\n@@ -1499,3 +1022,8 @@\n-    public BigInteger toBigInteger() {\n-        byte[] magnitude = new byte[nWords * 4 + 1];\n-        for (int i = 0; i < nWords; i++) {\n+    \/*\n+     * A toBigInteger() method would be more convenient, but it would introduce\n+     * a dependency on java.math, which is not desirable in such a basic layer\n+     * like this one used in components as java.lang, javac, and others.\n+     *\/\n+    public byte[] toByteArray() {\n+        byte[] magnitude = new byte[4 * size() + 1];  \/\/ +1 for the \"sign\" byte\n+        for (int i = 0, j = magnitude.length - 4 * offset; i < nWords; i += 1, j -= 4) {\n@@ -1503,4 +1031,4 @@\n-            magnitude[magnitude.length - 4 * i - 1] = (byte) w;\n-            magnitude[magnitude.length - 4 * i - 2] = (byte) (w >> 8);\n-            magnitude[magnitude.length - 4 * i - 3] = (byte) (w >> 16);\n-            magnitude[magnitude.length - 4 * i - 4] = (byte) (w >> 24);\n+            magnitude[j - 1] = (byte) w;\n+            magnitude[j - 2] = (byte) (w >> 8);\n+            magnitude[j - 3] = (byte) (w >> 16);\n+            magnitude[j - 4] = (byte) (w >> 24);\n@@ -1508,1 +1036,1 @@\n-        return new BigInteger(magnitude).shiftLeft(offset * 32);\n+        return magnitude;\n@@ -1511,10 +1039,0 @@\n-    \/\/ for debugging ...\n-    \/**\n-     * Converts this <code>FDBigInteger<\/code> to a string.\n-     *\n-     * @return The string representation.\n-     *\/\n-    @Override\n-    public String toString(){\n-        return toBigInteger().toString();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FDBigInteger.java","additions":378,"deletions":860,"binary":false,"changes":1238,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import static jdk.internal.math.FDBigInteger.valueOfMulPow52;\n+import static jdk.internal.math.FDBigInteger.valueOfPow52;\n+\n@@ -33,2 +36,2 @@\n- * static convenience methods, although a <code>BinaryToASCIIConverter<\/code>\n- * instance may be obtained and reused.\n+ * static convenience methods, although a {@link BinaryToASCIIBuffer}\n+ * instance may be obtained.\n@@ -36,1 +39,1 @@\n-public class FloatingDecimal{\n+public final class FloatingDecimal {\n@@ -40,1 +43,0 @@\n-    \/\/ (There are more really boring constants at the end.)\n@@ -42,18 +44,7 @@\n-    static final int    EXP_SHIFT = DoubleConsts.SIGNIFICAND_WIDTH - 1;\n-    static final long   FRACT_HOB = ( 1L<<EXP_SHIFT ); \/\/ assumed High-Order bit\n-    static final long   EXP_ONE   = ((long)DoubleConsts.EXP_BIAS)<<EXP_SHIFT; \/\/ exponent of 1.0\n-    static final int    MAX_SMALL_BIN_EXP = 62;\n-    static final int    MIN_SMALL_BIN_EXP = -( 63 \/ 3 );\n-    static final int    MAX_DECIMAL_DIGITS = 15;\n-    static final int    MAX_DECIMAL_EXPONENT = 308;\n-    static final int    MIN_DECIMAL_EXPONENT = -324;\n-    static final int    MAX_NDIGITS = 1100;\n-\n-    static final int    SINGLE_EXP_SHIFT  =   FloatConsts.SIGNIFICAND_WIDTH - 1;\n-    static final int    SINGLE_FRACT_HOB  =   1<<SINGLE_EXP_SHIFT;\n-    static final int    SINGLE_MAX_DECIMAL_DIGITS = 7;\n-    static final int    SINGLE_MAX_DECIMAL_EXPONENT = 38;\n-    static final int    SINGLE_MIN_DECIMAL_EXPONENT = -45;\n-    static final int    SINGLE_MAX_NDIGITS = 200;\n-\n-    static final int    INT_DECIMAL_DIGITS = 9;\n+    private static final int    EXP_SHIFT = DoubleConsts.SIGNIFICAND_WIDTH - 1;\n+    private static final long   FRACT_HOB = 1L << EXP_SHIFT; \/\/ assumed High-Order bit\n+    private static final long   EXP_ONE   = (long) DoubleConsts.EXP_BIAS << EXP_SHIFT; \/\/ exponent of 1.0\n+    private static final int    MAX_SMALL_BIN_EXP = 62;\n+    private static final int    MIN_SMALL_BIN_EXP = -63 \/ 3;\n+    private static final int    MAX_DEC_DIGITS = 15;  \/\/ max{n : 10^n ≤ 2^P}\n+    private static final int    FLOG_10_MAX_LONG = 18;  \/\/ max{i : 10^i ≤ Long.MAX_VALUE}\n@@ -62,1 +53,1 @@\n-     * Converts a <code>String<\/code> to a double precision floating point value.\n+     * Converts a {@link String} to a double precision floating point value.\n@@ -64,1 +55,1 @@\n-     * @param s The <code>String<\/code> to convert.\n+     * @param s The {@link String} to convert.\n@@ -66,1 +57,1 @@\n-     * @throws NumberFormatException If the <code>String<\/code> does not\n+     * @throws NumberFormatException If the {@link String} does not\n@@ -70,1 +61,1 @@\n-        return readJavaFormatString(s, BINARY_64_IX).doubleValue();\n+        return readJavaFormatString(s, BINARY_64_IX);\n@@ -74,1 +65,1 @@\n-     * Converts a <code>String<\/code> to a single precision floating point value.\n+     * Converts a {@link String} to a single precision floating point value.\n@@ -76,1 +67,1 @@\n-     * @param s The <code>String<\/code> to convert.\n+     * @param s The {@link String} to convert.\n@@ -78,1 +69,1 @@\n-     * @throws NumberFormatException If the <code>String<\/code> does not\n+     * @throws NumberFormatException If the {@link String} does not\n@@ -82,1 +73,1 @@\n-        return readJavaFormatString(s, BINARY_32_IX).floatValue();\n+        return (float) readJavaFormatString(s, BINARY_32_IX);\n@@ -90,1 +81,1 @@\n-     * @param digits The digits of the significand.\n+     * @param d The digits of the significand.\n@@ -94,37 +85,2 @@\n-    public static double parseDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n-        return readDoubleSignlessDigits(decExp, digits, length).doubleValue();\n-    }\n-\n-    \/**\n-     * A converter which can process single or double precision floating point\n-     * values into an ASCII <code>String<\/code> representation.\n-     *\/\n-    public interface BinaryToASCIIConverter {\n-\n-        \/**\n-         * Retrieves the decimal exponent most closely corresponding to this value.\n-         * @return The decimal exponent.\n-         *\/\n-        int getDecimalExponent();\n-\n-        \/**\n-         * Retrieves the value as an array of digits.\n-         * @param digits The digit array.\n-         * @return The number of valid digits copied into the array.\n-         *\/\n-        int getDigits(byte[] digits);\n-\n-        \/**\n-         * Indicates whether the value was rounded up during the binary to ASCII\n-         * conversion.\n-         *\n-         * @return <code>true<\/code> if and only if the value was rounded up.\n-         *\/\n-        boolean digitsRoundedUp();\n-\n-        \/**\n-         * Indicates whether the binary to ASCII conversion was exact.\n-         *\n-         * @return <code>true<\/code> if any only if the conversion was exact.\n-         *\/\n-        boolean decimalDigitsExact();\n+    public static double parseDoubleSignlessDigits(int decExp, byte[] d, int length) {\n+        return new ASCIIToBinaryBuffer(false, decExp, d, length).doubleValue();\n@@ -136,2 +92,4 @@\n-    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new byte[]{'0'});\n-    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new byte[]{'0'});\n+    private static final BinaryToASCIIBuffer B2AC_POSITIVE_ZERO =\n+            new BinaryToASCIIBuffer(new byte[] {'0'});\n+    private static final BinaryToASCIIBuffer B2AC_NEGATIVE_ZERO =\n+            new BinaryToASCIIBuffer(new byte[] {'0'});\n@@ -139,5 +97,1 @@\n-    \/**\n-     * A buffered implementation of <code>BinaryToASCIIConverter<\/code>.\n-     *\/\n-    static class BinaryToASCIIBuffer implements BinaryToASCIIConverter {\n-        private boolean isNegative;\n+    public static final class BinaryToASCIIBuffer {\n@@ -164,1 +118,1 @@\n-         * <code>BinaryToASCIIBuffer<\/code> may be thread-local and reused\n+         * {@link BinaryToASCIIBuffer} may be thread-local and reused\n@@ -166,1 +120,1 @@\n-        BinaryToASCIIBuffer(){\n+        private BinaryToASCIIBuffer() {\n@@ -173,2 +127,1 @@\n-        BinaryToASCIIBuffer(boolean isNegative, byte[] digits){\n-            this.isNegative = isNegative;\n+        private BinaryToASCIIBuffer(byte[] digits){\n@@ -181,1 +134,0 @@\n-        @Override\n@@ -186,1 +138,0 @@\n-        @Override\n@@ -192,1 +143,0 @@\n-        @Override\n@@ -197,1 +147,0 @@\n-        @Override\n@@ -202,4 +151,0 @@\n-        private void setSign(boolean isNegative) {\n-            this.isNegative = isNegative;\n-        }\n-\n@@ -215,1 +160,1 @@\n-         *\n+         *<p>\n@@ -221,1 +166,2 @@\n-        private void developLongDigits( int decExponent, long lvalue, int insignificantDigits ){\n+        private void developLongDigits( long lvalue, int insignificantDigits ){\n+            int decExponent = 0;\n@@ -278,1 +224,1 @@\n-        private void dtoa( int binExp, long fractBits, int nSignificantBits, boolean isCompatibleFormat)\n+        private void dtoa( int binExp, long fractBits, int nSignificantBits)\n@@ -330,1 +276,1 @@\n-                        developLongDigits( 0, fractBits, insignificant );\n+                        developLongDigits( fractBits, insignificant );\n@@ -424,1 +370,1 @@\n-            int ndigit = 0;\n+            int ndigit;\n@@ -480,1 +426,1 @@\n-                    if ( !isCompatibleFormat ||decExp < -3 || decExp >= 8 ){\n+                    if (decExp < -3 || decExp >= 8){\n@@ -534,1 +480,1 @@\n-                    if ( !isCompatibleFormat || decExp < -3 || decExp >= 8 ){\n+                    if (decExp < -3 || decExp >= 8){\n@@ -564,1 +510,1 @@\n-                FDBigInteger Sval = FDBigInteger.valueOfPow52(S5, S2);\n+                FDBigInteger Sval = valueOfPow52(S5, S2);\n@@ -568,2 +514,2 @@\n-                FDBigInteger Bval = FDBigInteger.valueOfMulPow52(fractBits, B5, B2 + shiftBias);\n-                FDBigInteger Mval = FDBigInteger.valueOfPow52(M5 + 1, M2 + shiftBias + 1);\n+                FDBigInteger Bval = valueOfMulPow52(fractBits, B5, B2 + shiftBias);\n+                FDBigInteger Mval = valueOfPow52(M5 + 1, M2 + shiftBias + 1);\n@@ -571,1 +517,1 @@\n-                FDBigInteger tenSval = FDBigInteger.valueOfPow52(S5 + 1, S2 + shiftBias + 1); \/\/Sval.mult( 10 );\n+                FDBigInteger tenSval = valueOfPow52(S5 + 1, S2 + shiftBias + 1); \/\/Sval.mult( 10 );\n@@ -595,1 +541,1 @@\n-                if (!isCompatibleFormat || decExp < -3 || decExp >= 8 ){\n+                if (decExp < -3 || decExp >= 8){\n@@ -612,1 +558,1 @@\n-                exactDecimalConversion  = (Bval.cmp( FDBigInteger.ZERO ) == 0);\n+                exactDecimalConversion  = Bval.isZero();\n@@ -665,1 +611,1 @@\n-         *\n+         *<p>\n@@ -673,1 +619,1 @@\n-        static int estimateDecExp(long fractBits, int binExp) {\n+        private static int estimateDecExp(long fractBits, int binExp) {\n@@ -708,0 +654,1 @@\n+        @Stable\n@@ -714,1 +661,1 @@\n-            18, 18, 18, 19\n+            18, 18, 18, 19,\n@@ -718,0 +665,1 @@\n+        @Stable\n@@ -746,0 +694,1 @@\n+                63,\n@@ -751,6 +700,1 @@\n-            new ThreadLocal<BinaryToASCIIBuffer>() {\n-                @Override\n-                protected BinaryToASCIIBuffer initialValue() {\n-                    return new BinaryToASCIIBuffer();\n-                }\n-            };\n+            ThreadLocal.withInitial(BinaryToASCIIBuffer::new);\n@@ -762,15 +706,6 @@\n-    \/**\n-     * A converter which can process an ASCII <code>String<\/code> representation\n-     * of a single or double precision floating point value into a\n-     * <code>float<\/code> or a <code>double<\/code>.\n-     *\/\n-    interface ASCIIToBinaryConverter {\n-\n-        double doubleValue();\n-\n-        float floatValue();\n-\n-    }\n-\n-    \/**\n-     * A <code>ASCIIToBinaryConverter<\/code> container for a <code>double<\/code>.\n+    \/*\n+     * The mathematical value x of an instance is\n+     *      ±<0.d_1...d_n> 10^e\n+     * where d_i = d[i-1] - '0' (0 < i ≤ n) is the i-th digit.\n+     * It is assumed that d_1 > 0.\n+     * isNegative denotes the - sign.\n@@ -778,3 +713,1 @@\n-    static class PreparedASCIIToBinaryBuffer implements ASCIIToBinaryConverter {\n-        private final double doubleVal;\n-        private final float floatVal;\n+    private static final class ASCIIToBinaryBuffer {\n@@ -782,4 +715,4 @@\n-        public PreparedASCIIToBinaryBuffer(double doubleVal, float floatVal) {\n-            this.doubleVal = doubleVal;\n-            this.floatVal = floatVal;\n-        }\n+        private final boolean isNegative;\n+        private final int e;\n+        private final int n;\n+        private final byte[] d;\n@@ -787,3 +720,5 @@\n-        @Override\n-        public double doubleValue() {\n-            return doubleVal;\n+        private ASCIIToBinaryBuffer(boolean isNegative, int e, byte[] d, int n) {\n+            this.isNegative = isNegative;\n+            this.e = e;\n+            this.d = d;\n+            this.n = n;\n@@ -792,3 +727,7 @@\n-        @Override\n-        public float floatValue() {\n-            return floatVal;\n+        \/* Assumes n ≤ 19 and returns a decimal prefix of f as an unsigned long. *\/\n+        private long toLong(int n) {\n+            long f = 0;\n+            for (int i = 0; i < n; ++i) {\n+                f = 10 * f + (d[i] - '0');\n+            }\n+            return f;\n@@ -796,1 +735,0 @@\n-    }\n@@ -798,22 +736,9 @@\n-    static final ASCIIToBinaryConverter A2BC_POSITIVE_INFINITY = new PreparedASCIIToBinaryBuffer(Double.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);\n-    static final ASCIIToBinaryConverter A2BC_NEGATIVE_INFINITY = new PreparedASCIIToBinaryBuffer(Double.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\n-    static final ASCIIToBinaryConverter A2BC_NOT_A_NUMBER  = new PreparedASCIIToBinaryBuffer(Double.NaN, Float.NaN);\n-    static final ASCIIToBinaryConverter A2BC_POSITIVE_ZERO = new PreparedASCIIToBinaryBuffer(0.0d, 0.0f);\n-    static final ASCIIToBinaryConverter A2BC_NEGATIVE_ZERO = new PreparedASCIIToBinaryBuffer(-0.0d, -0.0f);\n-\n-    \/**\n-     * A buffered implementation of <code>ASCIIToBinaryConverter<\/code>.\n-     *\/\n-    static class ASCIIToBinaryBuffer implements ASCIIToBinaryConverter {\n-        final boolean isNegative;\n-        final int     decExponent;\n-        final byte[]  digits;\n-        int           nDigits;\n-\n-        ASCIIToBinaryBuffer( boolean negSign, int decExponent, byte[] digits, int n)\n-        {\n-            this.isNegative = negSign;\n-            this.decExponent = decExponent;\n-            this.digits = digits;\n-            this.nDigits = n;\n-        }\n+        private double doubleValue() {\n+            \/*\n+             * As described above, the magnitude of the mathematical value is\n+             *      x = <0.d_1...d_n> 10^e = <d_1...d_n> 10^(e-n) = f 10^ep\n+             * where f = <d_1...d_n> and ep = e - n are integers.\n+             *\n+             * Let r_e denote the roundTiesToEven rounding.\n+             * This method returns ±r_e(x).\n+             *\/\n@@ -821,19 +746,3 @@\n-        \/**\n-         * Takes a FloatingDecimal, which we presumably just scanned in,\n-         * and finds out what its value is, as a double.\n-         *\n-         * AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED\n-         * ROUNDING DIRECTION in case the result is really destined\n-         * for a single-precision float.\n-         *\/\n-        @Override\n-        public double doubleValue() {\n-            int kDigits = Math.min(nDigits, MAX_DECIMAL_DIGITS + 1);\n-            \/\/\n-            \/\/ convert the lead kDigits to a long integer.\n-            \/\/\n-            \/\/ (special performance hack: start to do it using int)\n-            int iValue = (int) digits[0] - (int) '0';\n-            int iDigits = Math.min(kDigits, INT_DECIMAL_DIGITS);\n-            for (int i = 1; i < iDigits; i++) {\n-                iValue = iValue * 10 + (int) digits[i] - (int) '0';\n+             \/* Filter out extremely small or extremely large x. *\/\n+            if (e <= DoubleToDecimal.E_THR_Z) {\n+                return signed(0.0);\n@@ -841,3 +750,2 @@\n-            long lValue = (long) iValue;\n-            for (int i = iDigits; i < kDigits; i++) {\n-                lValue = lValue * 10L + (long) ((int) digits[i] - (int) '0');\n+            if (e >= DoubleToDecimal.E_THR_I) {\n+                return signed(Double.POSITIVE_INFINITY);\n@@ -845,7 +753,0 @@\n-            double dValue = (double) lValue;\n-            int exp = decExponent - kDigits;\n-            \/\/\n-            \/\/ lValue now contains a long integer with the value of\n-            \/\/ the first kDigits digits of the number.\n-            \/\/ dValue contains the (double) of the same.\n-            \/\/\n@@ -853,50 +754,27 @@\n-            if (nDigits <= MAX_DECIMAL_DIGITS) {\n-                \/\/\n-                \/\/ possibly an easy case.\n-                \/\/ We know that the digits can be represented\n-                \/\/ exactly. And if the exponent isn't too outrageous,\n-                \/\/ the whole thing can be done with one operation,\n-                \/\/ thus one rounding error.\n-                \/\/ Note that all our constructors trim all leading and\n-                \/\/ trailing zeros, so simple values (including zero)\n-                \/\/ will always end up here\n-                \/\/\n-                if (exp == 0 || dValue == 0.0) {\n-                    return (isNegative) ? -dValue : dValue; \/\/ small floating integer\n-                }\n-                else if (exp >= 0) {\n-                    if (exp <= MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer with one operation,\n-                        \/\/ thus one roundoff.\n-                        \/\/\n-                        double rValue = dValue * SMALL_10_POW[exp];\n-                        return (isNegative) ? -rValue : rValue;\n-                    }\n-                    int slop = MAX_DECIMAL_DIGITS - kDigits;\n-                    if (exp <= MAX_SMALL_TEN + slop) {\n-                        \/\/\n-                        \/\/ We can multiply dValue by 10^(slop)\n-                        \/\/ and it is still \"small\" and exact.\n-                        \/\/ Then we can multiply by 10^(exp-slop)\n-                        \/\/ with one rounding.\n-                        \/\/\n-                        dValue *= SMALL_10_POW[slop];\n-                        double rValue = dValue * SMALL_10_POW[exp - slop];\n-                        return (isNegative) ? -rValue : rValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a positive exp.\n-                    \/\/\n-                } else {\n-                    if (exp >= -MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer in one division.\n-                        \/\/\n-                        double rValue = dValue \/ SMALL_10_POW[-exp];\n-                        return (isNegative) ? -rValue : rValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a negative exp.\n-                    \/\/\n-                }\n+            \/*\n+             * Attempt some fast paths before resorting to higher precision.\n+             * Here, let P = Double.PRECISION = 53.\n+             *\n+             * Below, fl is an unsigned long, thus we require n ≤ 19 because\n+             * 10^19 < 2^64 < 10^20.\n+             *\/\n+            int n = this.n;\n+            int ep = e - n;\n+            double v;\n+            int m = Math.min(n, MathUtils.N);\n+            long fl = toLong(m);  \/\/ unsigned\n+            if (n <= MathUtils.N && 0 <= ep && e <= MathUtils.N) {\n+                \/*\n+                 * Here, n ≤ 19, hence f = fl < 10^19.\n+                 * Since e = n + ep and 0 ≤ ep ∧ n + ep ≤ 19 we see that\n+                 * x = f 10^ep < 10^n 10^ep = 10^(n+ep) ≤ 10^19.\n+                 * Thus, x = fl 10^ep fits in an unsigned long as well.\n+                 * If its most significant bit is 0, the long is non-negative.\n+                 * Otherwise, fl ≥ 2^63, so there's room for P precision bits,\n+                 * +1 rounding bit, +1 sticky bit.\n+                 * In both cases, correct rounding is achieved as below.\n+                 * All integer x < 10^19 are covered here.\n+                 *\/\n+                fl *= MathUtils.pow10(ep);  \/\/ 0 ≤ ep < 19\n+                v = fl >= 0 ? fl : 2.0 * (fl >>> 1 | fl & 0b1);\n+                return signed(v);\n@@ -905,54 +783,17 @@\n-            \/\/\n-            \/\/ Harder cases:\n-            \/\/ The sum of digits plus exponent is greater than\n-            \/\/ what we think we can do with one error.\n-            \/\/\n-            \/\/ Start by approximating the right answer by,\n-            \/\/ naively, scaling by powers of 10.\n-            \/\/\n-            if (exp > 0) {\n-                if (decExponent > MAX_DECIMAL_EXPONENT + 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ Infinity. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue *= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 1; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= BIG_10_POW[j];\n-                        }\n-                    }\n-                    \/\/\n-                    \/\/ The reason for the weird exp > 1 condition\n-                    \/\/ in the above loop was so that the last multiply\n-                    \/\/ would get unrolled. We handle it here.\n-                    \/\/ It could overflow.\n-                    \/\/\n-                    double t = dValue * BIG_10_POW[j];\n-                    if (Double.isInfinite(t)) {\n-                        \/\/\n-                        \/\/ It did overflow.\n-                        \/\/ Look more closely at the result.\n-                        \/\/ If the exponent is just one too large,\n-                        \/\/ then use the maximum finite as our estimate\n-                        \/\/ value. Else call the result infinity\n-                        \/\/ and punt it.\n-                        \/\/ ( I presume this could happen because\n-                        \/\/ rounding forces the result here to be\n-                        \/\/ an ULP or two larger than\n-                        \/\/ Double.MAX_VALUE ).\n-                        \/\/\n-                        t = dValue \/ 2.0;\n-                        t *= BIG_10_POW[j];\n-                        if (Double.isInfinite(t)) {\n-                            return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n-                        }\n-                        t = Double.MAX_VALUE;\n-                    }\n-                    dValue = t;\n+            if (n <= FLOG_10_MAX_LONG && -MAX_SMALL_TEN <= ep) {\n+                v = fl;\n+                \/*\n+                 * Here, -22 ≤ ep.\n+                 * Further, fl < 10^18, so fl is an exact double iff\n+                 * (long) v == fl holds.\n+                 * If fl is not an exact double, resort to higher precision.\n+                 *\/\n+                boolean isExact = (long) v == fl;\n+                if (isExact && ep <= MAX_SMALL_TEN) {\n+                    \/*\n+                     * Here, -22 ≤ ep ≤ 22, so 10^|ep| is an exact double.\n+                     * The product or quotient below operate on exact doubles,\n+                     * so the result is correctly rounded.\n+                     *\/\n+                    v = ep >= 0 ? v * SMALL_10_POW[ep] : v \/ SMALL_10_POW[-ep];\n+                    return signed(v);\n@@ -960,45 +801,27 @@\n-            } else if (exp < 0) {\n-                exp = -exp;\n-                if (decExponent < MIN_DECIMAL_EXPONENT - 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ zero. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? -0.0 : 0.0;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue \/= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 1; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= TINY_10_POW[j];\n-                        }\n-                    }\n-                    \/\/\n-                    \/\/ The reason for the weird exp > 1 condition\n-                    \/\/ in the above loop was so that the last multiply\n-                    \/\/ would get unrolled. We handle it here.\n-                    \/\/ It could underflow.\n-                    \/\/\n-                    double t = dValue * TINY_10_POW[j];\n-                    if (t == 0.0) {\n-                        \/\/\n-                        \/\/ It did underflow.\n-                        \/\/ Look more closely at the result.\n-                        \/\/ If the exponent is just one too small,\n-                        \/\/ then use the minimum finite as our estimate\n-                        \/\/ value. Else call the result 0.0\n-                        \/\/ and punt it.\n-                        \/\/ ( I presume this could happen because\n-                        \/\/ rounding forces the result here to be\n-                        \/\/ an ULP or two less than\n-                        \/\/ Double.MIN_VALUE ).\n-                        \/\/\n-                        t = dValue * 2.0;\n-                        t *= TINY_10_POW[j];\n-                        if (t == 0.0) {\n-                            return (isNegative) ? -0.0 : 0.0;\n-                        }\n-                        t = Double.MIN_VALUE;\n+\n+                \/*\n+                 * Here, fl < 10^18 is not an exact double, or ep > 22.\n+                 * If fl is not an exact double, resort to higher precision.\n+                 *\/\n+                if (isExact) {  \/\/ v and fl are mathematically equal.\n+                    \/*\n+                     * Here, ep > 22.\n+                     * We have f = fl = v.\n+                     * Note that 2^P = 9007199254740992 has 16 digits.\n+                     * If f does not start with 9 let ef = 16 - n, otherwise\n+                     * let ef = 15 - n.\n+                     * If ef < 0 then resort to higher precision.\n+                     * Otherwise, if f does not start with 9 we have n ≤ 16,\n+                     * so f 10^ef < 9 10^(n-1) 10^ef = 9 10^15 < 2^P.\n+                     * If f starts with 9 we have n ≤ 15, hence f 10^ef <\n+                     * 10^n 10^ef = 10^15 < 2^P.\n+                     *\n+                     * Hence, when ef ≥ 0 and ep - ef ≤ 22 we know that\n+                     * fl 10^ep = (fl 10^ef) 10^(ep-ef), with fl, (fl 10^ef),\n+                     * and 10^(ep-ef) all exact doubles.\n+                     *\/\n+                    int ef = (d[0] < '9' ? MAX_DEC_DIGITS + 1 : MAX_DEC_DIGITS) - n;\n+                    if (ef >= 0 && ep - ef <= MAX_SMALL_TEN) {\n+                        \/* Rely on left-to-right evaluation. *\/\n+                        v = v * SMALL_10_POW[ef] * SMALL_10_POW[ep - ef];\n+                        return signed(v);\n@@ -1006,1 +829,0 @@\n-                    dValue = t;\n@@ -1010,10 +832,11 @@\n-            \/\/\n-            \/\/ dValue is now approximately the result.\n-            \/\/ The hard part is adjusting it, by comparison\n-            \/\/ with FDBigInteger arithmetic.\n-            \/\/ Formulate the EXACT big-number result as\n-            \/\/ bigD0 * 10^exp\n-            \/\/\n-            if (nDigits > MAX_NDIGITS) {\n-                nDigits = MAX_NDIGITS + 1;\n-                digits[MAX_NDIGITS] = '1';\n+            \/*\n+             * Here, the above fast paths have failed to return.\n+             * Force ll, lh in [10^(N-1), 10^N] to have more high order bits.\n+             *\/\n+            long ll = fl;  \/\/ unsigned\n+            long lh;  \/\/ unsigned\n+            if (n <= MathUtils.N) {  \/\/ ll = f\n+                ll *= MathUtils.pow10(MathUtils.N - n);\n+                lh = ll;\n+            } else {  \/\/ ll is an N digits long prefix of f\n+                lh = ll + 1;\n@@ -1021,114 +844,106 @@\n-            FDBigInteger bigD0 = new FDBigInteger(lValue, digits, kDigits, nDigits);\n-            exp = decExponent - nDigits;\n-\n-            long ieeeBits = Double.doubleToRawLongBits(dValue); \/\/ IEEE-754 bits of double candidate\n-            final int B5 = Math.max(0, -exp); \/\/ powers of 5 in bigB, value is not modified inside correctionLoop\n-            final int D5 = Math.max(0, exp); \/\/ powers of 5 in bigD, value is not modified inside correctionLoop\n-            bigD0 = bigD0.multByPow52(D5, 0);\n-            bigD0.makeImmutable();   \/\/ prevent bigD0 modification inside correctionLoop\n-            FDBigInteger bigD = null;\n-            int prevD2 = 0;\n-\n-            correctionLoop:\n-            while (true) {\n-                \/\/ here ieeeBits can't be NaN, Infinity or zero\n-                int binexp = (int) (ieeeBits >>> EXP_SHIFT);\n-                long bigBbits = ieeeBits & DoubleConsts.SIGNIF_BIT_MASK;\n-                if (binexp > 0) {\n-                    bigBbits |= FRACT_HOB;\n-                } else { \/\/ Normalize denormalized numbers.\n-                    assert bigBbits != 0L : bigBbits; \/\/ doubleToBigInt(0.0)\n-                    int leadingZeros = Long.numberOfLeadingZeros(bigBbits);\n-                    int shift = leadingZeros - (63 - EXP_SHIFT);\n-                    bigBbits <<= shift;\n-                    binexp = 1 - shift;\n-                }\n-                binexp -= DoubleConsts.EXP_BIAS;\n-                int lowOrderZeros = Long.numberOfTrailingZeros(bigBbits);\n-                bigBbits >>>= lowOrderZeros;\n-                final int bigIntExp = binexp - EXP_SHIFT + lowOrderZeros;\n-                final int bigIntNBits = EXP_SHIFT + 1 - lowOrderZeros;\n-\n-                \/\/\n-                \/\/ Scale bigD, bigB appropriately for\n-                \/\/ big-integer operations.\n-                \/\/ Naively, we multiply by powers of ten\n-                \/\/ and powers of two. What we actually do\n-                \/\/ is keep track of the powers of 5 and\n-                \/\/ powers of 2 we would use, then factor out\n-                \/\/ common divisors before doing the work.\n-                \/\/\n-                int B2 = B5; \/\/ powers of 2 in bigB\n-                int D2 = D5; \/\/ powers of 2 in bigD\n-                int Ulp2;   \/\/ powers of 2 in halfUlp.\n-                if (bigIntExp >= 0) {\n-                    B2 += bigIntExp;\n-                } else {\n-                    D2 -= bigIntExp;\n-                }\n-                Ulp2 = B2;\n-                \/\/ shift bigB and bigD left by a number s. t.\n-                \/\/ halfUlp is still an integer.\n-                int hulpbias;\n-                if (binexp <= -DoubleConsts.EXP_BIAS) {\n-                    \/\/ This is going to be a denormalized number\n-                    \/\/ (if not actually zero).\n-                    \/\/ half an ULP is at 2^-(DoubleConsts.EXP_BIAS+EXP_SHIFT+1)\n-                    hulpbias = binexp + lowOrderZeros + DoubleConsts.EXP_BIAS;\n-                } else {\n-                    hulpbias = 1 + lowOrderZeros;\n-                }\n-                B2 += hulpbias;\n-                D2 += hulpbias;\n-                \/\/ if there are common factors of 2, we might just as well\n-                \/\/ factor them out, as they add nothing useful.\n-                int common2 = Math.min(B2, Math.min(D2, Ulp2));\n-                B2 -= common2;\n-                D2 -= common2;\n-                Ulp2 -= common2;\n-                \/\/ do multiplications by powers of 5 and 2\n-                FDBigInteger bigB = FDBigInteger.valueOfMulPow52(bigBbits, B5, B2);\n-                if (bigD == null || prevD2 != D2) {\n-                    bigD = bigD0.leftShift(D2);\n-                    prevD2 = D2;\n-                }\n-                \/\/\n-                \/\/ to recap:\n-                \/\/ bigB is the scaled-big-int version of our floating-point\n-                \/\/ candidate.\n-                \/\/ bigD is the scaled-big-int version of the exact value\n-                \/\/ as we understand it.\n-                \/\/ halfUlp is 1\/2 an ulp of bigB, except for special cases\n-                \/\/ of exact powers of 2\n-                \/\/\n-                \/\/ the plan is to compare bigB with bigD, and if the difference\n-                \/\/ is less than halfUlp, then we're satisfied. Otherwise,\n-                \/\/ use the ratio of difference to halfUlp to calculate a fudge\n-                \/\/ factor to add to the floating value, then go 'round again.\n-                \/\/\n-                FDBigInteger diff;\n-                int cmpResult;\n-                boolean overvalue;\n-                if ((cmpResult = bigB.cmp(bigD)) > 0) {\n-                    overvalue = true; \/\/ our candidate is too big.\n-                    diff = bigB.leftInplaceSub(bigD); \/\/ bigB is not user further - reuse\n-                    if ((bigIntNBits == 1) && (bigIntExp > -DoubleConsts.EXP_BIAS + 1)) {\n-                        \/\/ candidate is a normalized exact power of 2 and\n-                        \/\/ is too big (larger than Double.MIN_NORMAL). We will be subtracting.\n-                        \/\/ For our purposes, ulp is the ulp of the\n-                        \/\/ next smaller range.\n-                        Ulp2 -= 1;\n-                        if (Ulp2 < 0) {\n-                            \/\/ rats. Cannot de-scale ulp this far.\n-                            \/\/ must scale diff in other direction.\n-                            Ulp2 = 0;\n-                            diff = diff.leftShift(1);\n-                        }\n-                    }\n-                } else if (cmpResult < 0) {\n-                    overvalue = false; \/\/ our candidate is too small.\n-                    diff = bigD.rightInplaceSub(bigB); \/\/ bigB is not user further - reuse\n-                } else {\n-                    \/\/ the candidate is exactly right!\n-                    \/\/ this happens with surprising frequency\n-                    break correctionLoop;\n+            int el = e - MathUtils.N;\n+            \/*\n+             * We now have\n+             *      x = f 10^ep\n+             *      ll 10^el ≤ x ≤ lh 10^el\n+             *      2^59 < 10^(N-1) ≤ ll ≤ lh ≤ 10^N < 2^64\n+             *\n+             * Rather than rounding x directly, which requires full precision\n+             * arithmetic, approximate x as follows.\n+             * Let integers g and r such that (see comments in MathUtils)\n+             *      (g - 1) 2^r ≤ 10^el < g 2^r\n+             * and split g into the lower 63 bits g0 and the higher bits g1:\n+             *      g = g1 2^63 + g0\n+             * where\n+             *      2^62 < g1 + 1 < 2^63, 0 < g0 < 2^63\n+             * We have\n+             *      g - 1 = g1 2^63 + g0 - 1 ≥ g1 2^63\n+             *      g = g1 2^63 + g0 < g1 2^63 + 2^63 = (g1 + 1) 2^63\n+             * Let\n+             *      nl = ll g1          nh = lh (g1 + 1)\n+             * These lead to\n+             *      nl 2^(r+63) ≤ x < nh 2^(r+63)\n+             * Let\n+             *      v = r_e(nl 2^(r+63))        vh = r_e(nh 2^(r+63))\n+             * If v = vh then r_e(x) = v.\n+             *\n+             * We also have\n+             *      2^121 = 2^59 2^62 < nl < nh < 2^64 2^63 = 2^127\n+             * Therefore, each of nl and nh fits in two longs.\n+             * Split them into the lower 64 bits and the higher bits.\n+             *      nl = nl1 2^64 + nl0     2^57 ≤ nl1 < 2^63\n+             *      nh = nh1 2^64 + nh0     2^57 ≤ nh1 < 2^63\n+             * Let bl and bh be the bitlength of nl1 and nh1, resp.\n+             * Both bl and bh lie in the interval [58, 63], and all of nl1, nh1,\n+             * nl, and nh are in the normal range of double.\n+             * As nl ≤ nh ≤ nl + 2 ll, and as ll < 2^64, then either bh = bl,\n+             * or more rarely bh = bl + 1.\n+             *\n+             * As mentioned above, if v = vh then r_e(x) = v.\n+             * Rather than rounding nl 2^(r+63), nh 2^(r+63) boundaries directly,\n+             * first round nl and nh to obtain doubles wl and wh, resp.\n+             *      wl = r_e(nl)        wh = r_e(nh)\n+             * Note that both wl and wh are normal doubles.\n+             *\n+             * Assume wl = wh.\n+             * There's a good chance that v = scalb(wl, r + 63) holds.\n+             * In fact, if x ≥ MIN_NORMAL then it can be (tediously) shown that\n+             * v = scalb(wl, r + 63) holds, even when v overflows.\n+             * If x < MIN_NORMAL, and since wl is normal and v ≤ MIN_NORMAL,\n+             * the precision might be lowered, so scalb(wl, r + 63) might incur\n+             * two rounding errors and could slightly differ from v.\n+             *\n+             * It is costly to precisely determine whether x ≥ MIN_NORMAL.\n+             * However, bl + r > MIN_EXPONENT - 127 implies x ≥ MIN_NORMAL,\n+             * and bh + r ≤ MIN_EXPONENT - 127 entails x < MIN_NORMAL.\n+             * Finally, when bl + r ≤ MIN_EXPONENT - 127 < bh + r we see that\n+             * bl + r = MIN_EXPONENT - 127 and bh = bl + 1 must hold.\n+             *\n+             * As noted, nh ≤ nl + 2 ll.\n+             * This means\n+             *      nh1 ≤ nh 2^(-64) ≤ (nl + 2 ll) 2^(-64) < (nl1 + 1) + 2\n+             * and thus\n+             *      nh1 ≤ nl1 + 2\n+             *\/\n+            int rp = MathUtils.flog2pow10(el) + 2;  \/\/ r + 127\n+            long g1 = MathUtils.g1(el);\n+            long nl1 = Math.unsignedMultiplyHigh(ll, g1);\n+            long nl0 = ll * g1;\n+            long nh1 = Math.unsignedMultiplyHigh(lh, g1 + 1);\n+            long nh0 = lh * (g1 + 1);\n+            int bl = Long.SIZE - Long.numberOfLeadingZeros(nl1);\n+            if (bl + rp > Double.MIN_EXPONENT) {  \/\/ implies x is normal\n+                \/*\n+                 * To round nl we need its most significant P bits, the rounding\n+                 * bit immediately to the right, and an indication (sticky bit)\n+                 * of whether there are \"1\" bits following the rounding bit.\n+                 * The sticky bit can be placed anywhere after the rounding bit.\n+                 * Since bl ≥ 58, the P = 53 bits, the rounding bit, and space\n+                 * for the sticky bit are all located in nl1.\n+                 *\n+                 * When nl0 = 0, the indication of whether there are \"1\" bits\n+                 * to the right of the rounding bit is already contained in nl1.\n+                 * Rounding nl to wl is the same as rounding nl1 to ul and then\n+                 * multiplying this by 2^64.\n+                 * that is, given wl = r_e(nl), ul = r_e(nl1), we get\n+                 * wl = scalb(ul, 64).\n+                 * The same holds for nh, wh, nh1, and uh.\n+                 * So, if ul = uh then wl = wh, thus v = scalb(ul, r + 127).\n+                 *\n+                 * When nl1 ≠ 0, there are indeed \"1\" bits to the right of the\n+                 * rounding bit.\n+                 * We force the rightmost bit of nl1 to 1, obtaining nl1'.\n+                 * Then, again, rounding nl to wl is the same as rounding nl1'\n+                 * to ul and multiplying this by 2^64.\n+                 * Analogously for nh, wh, nh1, and uh.\n+                 * Again, if ul = uh then wl = wh, thus v = scalb(ul, r + 127).\n+                 *\n+                 * Since nh1 ≤ nl1 + 2, then either uh = ul or uh = nextUp(ul).\n+                 * This means that when ul ≠ uh then\n+                 *      v ≤ r_e(x) ≤ nextUp(v)\n+                 *\/\n+                double ul = nl1 | (nl0 != 0 ? 1 : 0);\n+                double uh = nh1 | (nh0 != 0 ? 1 : 0);\n+                v = Math.scalb(ul, rp);\n+                if (ul == uh) {\n+                    return signed(v);\n@@ -1136,10 +951,27 @@\n-                cmpResult = diff.cmpPow52(B5, Ulp2);\n-                if ((cmpResult) < 0) {\n-                    \/\/ difference is small.\n-                    \/\/ this is close enough\n-                    break correctionLoop;\n-                } else if (cmpResult == 0) {\n-                    \/\/ difference is exactly half an ULP\n-                    \/\/ round to some other value maybe, then finish\n-                    if ((ieeeBits & 1) != 0) { \/\/ half ties to even\n-                        ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n+            } else {\n+                int bh = Long.SIZE - Long.numberOfLeadingZeros(nh1);\n+                if (bh + rp <= Double.MIN_EXPONENT) {  \/\/ implies x is subnormal\n+                    \/*\n+                     * We need to reduce the precision to avoid double rounding\n+                     * issues.\n+                     * Shifting to the right while keeping room for the rounding\n+                     * and the sticky bit is one way to go.\n+                     * Other than that, the reasoning is similar to the above case.\n+                     *\/\n+                    int sh = DoubleToDecimal.Q_MIN - rp;  \/\/ shift distance\n+                    long sbMask = -1L >>> 1 - sh;\n+\n+                    long nl1p = nl1 >>> sh;\n+                    long rb = nl1 >>> sh - 1;\n+                    long sb = (nl1 & sbMask | nl0) != 0 ? 1 : 0;\n+                    long corr = rb & (sb | nl1p) & 0b1;\n+                    double ul = nl1p + corr;\n+\n+                    long nh1p = nh1 >>> sh;\n+                    rb = nh1 >>> sh - 1;\n+                    sb = (nh1 & sbMask | nh0) != 0 ? 1 : 0;\n+                    corr = rb & (sb | nh1p) & 0b1;\n+                    double uh = nh1p + corr;\n+                    v = Math.scalb(ul, rp + sh);\n+                    if (ul == uh) {\n+                        return signed(v);\n@@ -1147,1 +979,0 @@\n-                    break correctionLoop;\n@@ -1149,9 +980,10 @@\n-                    \/\/ difference is non-trivial.\n-                    \/\/ could scale addend by ratio of difference to\n-                    \/\/ halfUlp here, if we bothered to compute that difference.\n-                    \/\/ Most of the time ( I hope ) it is about 1 anyway.\n-                    ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n-                    if (ieeeBits == 0 || ieeeBits == DoubleConsts.EXP_BIT_MASK) { \/\/ 0.0 or Double.POSITIVE_INFINITY\n-                        break correctionLoop; \/\/ oops. Fell off end of range.\n-                    }\n-                    continue; \/\/ try again.\n+                    \/*\n+                     * Here, bl + r ≤ MIN_EXPONENT - 127 < bh + r.\n+                     * As mentioned before, this means bh = bl + 1 and\n+                     * rp = MIN_EXPONENT - bl.\n+                     * As nh1 ≤ nl1 + 2, nl1 ≥ 2^57, bh = bl + 1 happens only if\n+                     * the most significant P + 2 bits in nl1 are all \"1\" bits,\n+                     * so wl = r_e(nl) = r_e(nh) = wh = 2^(bl+64), and\n+                     * thus v = vh = 2^(bl+127) = 2^MIN_EXPONENT = MIN_NORMAL.\n+                     *\/\n+                    return signed(Double.MIN_NORMAL);\n@@ -1159,4 +991,0 @@\n-\n-            }\n-            if (isNegative) {\n-                ieeeBits |= DoubleConsts.SIGN_BIT_MASK;\n@@ -1164,2 +992,0 @@\n-            return Double.longBitsToDouble(ieeeBits);\n-        }\n@@ -1167,26 +993,17 @@\n-        \/**\n-         * Takes a FloatingDecimal, which we presumably just scanned in,\n-         * and finds out what its value is, as a float.\n-         * This is distinct from doubleValue() to avoid the extremely\n-         * unlikely case of a double rounding error, wherein the conversion\n-         * to double has one rounding error, and the conversion of that double\n-         * to a float has another rounding error, IN THE WRONG DIRECTION,\n-         * ( because of the preference to a zero low-order bit ).\n-         *\/\n-        @Override\n-        public float floatValue() {\n-            int kDigits = Math.min(nDigits, SINGLE_MAX_DECIMAL_DIGITS + 1);\n-            \/\/\n-            \/\/ convert the lead kDigits to an integer.\n-            \/\/\n-            int iValue = (int) digits[0] - (int) '0';\n-            for (int i = 1; i < kDigits; i++) {\n-                iValue = iValue * 10 + (int) digits[i] - (int) '0';\n-            }\n-            float fValue = (float) iValue;\n-            int exp = decExponent - kDigits;\n-            \/\/\n-            \/\/ iValue now contains an integer with the value of\n-            \/\/ the first kDigits digits of the number.\n-            \/\/ fValue contains the (float) of the same.\n-            \/\/\n+            \/*\n+             * Measurements show that the failure rate of the above fast paths\n+             * on the outcomes of Double.toString() on uniformly distributed\n+             * double bit patterns is around 0.04%.\n+             *\n+             * Here, v ≤ r_e(x) ≤ nextUp(v), with v = c 2^q (c, q are as in\n+             * IEEE-754 2019).\n+             *\n+             * Let vr = v + ulp(v)\/2 = (c + 1\/2) 2^q, the number halfway between\n+             * v and nextUp(v).\n+             * With cr = (2 c + 1), qr = q - 1 we get vr = cr 2^qr.\n+             *\/\n+            long bits = Double.doubleToRawLongBits(v);\n+            int be = (int) ((bits & DoubleConsts.EXP_BIT_MASK) >>> DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+            int qr = be - (DoubleConsts.EXP_BIAS + DoubleConsts.SIGNIFICAND_WIDTH - 1)\n+                    - (be != 0 ? 1 : 0);\n+            long cr = 2 * (bits & DoubleConsts.SIGNIF_BIT_MASK | (be != 0 ? DoubleToDecimal.C_MIN : 0)) + 1;\n@@ -1194,68 +1011,20 @@\n-            if (nDigits <= SINGLE_MAX_DECIMAL_DIGITS) {\n-                \/\/\n-                \/\/ possibly an easy case.\n-                \/\/ We know that the digits can be represented\n-                \/\/ exactly. And if the exponent isn't too outrageous,\n-                \/\/ the whole thing can be done with one operation,\n-                \/\/ thus one rounding error.\n-                \/\/ Note that all our constructors trim all leading and\n-                \/\/ trailing zeros, so simple values (including zero)\n-                \/\/ will always end up here.\n-                \/\/\n-                if (exp == 0 || fValue == 0.0f) {\n-                    return (isNegative) ? -fValue : fValue; \/\/ small floating integer\n-                } else if (exp >= 0) {\n-                    if (exp <= SINGLE_MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer with one operation,\n-                        \/\/ thus one roundoff.\n-                        \/\/\n-                        fValue *= SINGLE_SMALL_10_POW[exp];\n-                        return (isNegative) ? -fValue : fValue;\n-                    }\n-                    int slop = SINGLE_MAX_DECIMAL_DIGITS - kDigits;\n-                    if (exp <= SINGLE_MAX_SMALL_TEN + slop) {\n-                        \/\/\n-                        \/\/ We can multiply fValue by 10^(slop)\n-                        \/\/ and it is still \"small\" and exact.\n-                        \/\/ Then we can multiply by 10^(exp-slop)\n-                        \/\/ with one rounding.\n-                        \/\/\n-                        fValue *= SINGLE_SMALL_10_POW[slop];\n-                        fValue *= SINGLE_SMALL_10_POW[exp - slop];\n-                        return (isNegative) ? -fValue : fValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a positive exp.\n-                    \/\/\n-                } else {\n-                    if (exp >= -SINGLE_MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer in one division.\n-                        \/\/\n-                        fValue \/= SINGLE_SMALL_10_POW[-exp];\n-                        return (isNegative) ? -fValue : fValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a negative exp.\n-                    \/\/\n-                }\n-            } else if ((decExponent >= nDigits) && (nDigits + decExponent <= MAX_DECIMAL_DIGITS)) {\n-                \/\/\n-                \/\/ In double-precision, this is an exact floating integer.\n-                \/\/ So we can compute to double, then shorten to float\n-                \/\/ with one round, and get the right answer.\n-                \/\/\n-                \/\/ First, finish accumulating digits.\n-                \/\/ Then convert that integer to a double, multiply\n-                \/\/ by the appropriate power of ten, and convert to float.\n-                \/\/\n-                long lValue = (long) iValue;\n-                for (int i = kDigits; i < nDigits; i++) {\n-                    lValue = lValue * 10L + (long) ((int) digits[i] - (int) '0');\n-                }\n-                double dValue = (double) lValue;\n-                exp = decExponent - nDigits;\n-                dValue *= SMALL_10_POW[exp];\n-                fValue = (float) dValue;\n-                return (isNegative) ? -fValue : fValue;\n+            \/*\n+             * The test vr ⋚ x is equivalent to cr 2^qr ⋚ f 10^ep.\n+             * This is in turn equivalent to one of 4 cases, where all exponents\n+             * are non-negative:\n+             *      ep ≥ 0 ∧ ep ≥ qr:                     cr ⋚ f 5^ep 2^(ep-qr)\n+             *      ep ≥ 0 ∧ ep < qr:           cr 2^(qr-ep) ⋚ f 5^ep\n+             *      ep < 0 ∧ ep ≥ qr:             cr 5^(-ep) ⋚ f 2^(ep-qr)\n+             *      ep < 0 ∧ ep < qr:   cr 5^(-ep) 2^(qr-ep) ⋚ f\n+             *\/\n+            FDBigInteger lhs = valueOfMulPow52(cr, Math.max(-ep, 0), Math.max(qr - ep, 0));\n+            FDBigInteger rhs = new FDBigInteger(fl, d, m, n)\n+                    .multByPow52(Math.max(ep, 0), Math.max(ep - qr, 0));\n+            int cmp = lhs.cmp(rhs);\n+            v = Double.longBitsToDouble(cmp < 0\n+                    ? bits + 1\n+                    : cmp > 0\n+                    ? bits\n+                    : bits + (bits & 0b1));\n+            return signed(v);\n+        }\n@@ -1263,0 +1032,8 @@\n+        private double signed(double v) {\n+            return isNegative ? -v : v;\n+        }\n+\n+        private float floatValue() {\n+            \/* For details not covered here, see comments in doubleValue(). *\/\n+            if (e <= E_THR_Z[BINARY_32_IX]) {\n+                return signed(0.0f);\n@@ -1264,49 +1041,2 @@\n-            \/\/\n-            \/\/ Harder cases:\n-            \/\/ The sum of digits plus exponent is greater than\n-            \/\/ what we think we can do with one error.\n-            \/\/\n-            \/\/ Start by approximating the right answer by,\n-            \/\/ naively, scaling by powers of 10.\n-            \/\/ Scaling uses doubles to avoid overflow\/underflow.\n-            \/\/\n-            double dValue = fValue;\n-            if (exp > 0) {\n-                if (decExponent > SINGLE_MAX_DECIMAL_EXPONENT + 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ Infinity. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue *= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 0; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= BIG_10_POW[j];\n-                        }\n-                    }\n-                }\n-            } else if (exp < 0) {\n-                exp = -exp;\n-                if (decExponent < SINGLE_MIN_DECIMAL_EXPONENT - 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ zero. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? -0.0f : 0.0f;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue \/= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 0; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= TINY_10_POW[j];\n-                        }\n-                    }\n-                }\n+            if (e >= E_THR_I[BINARY_32_IX]) {\n+                return signed(Float.POSITIVE_INFINITY);\n@@ -1314,12 +1044,9 @@\n-            fValue = Math.clamp((float) dValue, Float.MIN_VALUE, Float.MAX_VALUE);\n-\n-            \/\/\n-            \/\/ fValue is now approximately the result.\n-            \/\/ The hard part is adjusting it, by comparison\n-            \/\/ with FDBigInteger arithmetic.\n-            \/\/ Formulate the EXACT big-number result as\n-            \/\/ bigD0 * 10^exp\n-            \/\/\n-            if (nDigits > SINGLE_MAX_NDIGITS) {\n-                nDigits = SINGLE_MAX_NDIGITS + 1;\n-                digits[SINGLE_MAX_NDIGITS] = '1';\n+            int n = this.n;\n+            int ep = e - n;\n+            float v;\n+            int m = Math.min(n, MathUtils.N);\n+            long fl = toLong(m);\n+            if (n <= MathUtils.N && 0 <= ep && e <= MathUtils.N) {\n+                fl *= MathUtils.pow10(ep);  \/\/ 0 ≤ ep < 19\n+                v = fl >= 0 ? fl : 2.0f * (fl >>> 1 | fl & 0b1);\n+                return signed(v);\n@@ -1327,24 +1054,6 @@\n-            FDBigInteger bigD0 = new FDBigInteger(iValue, digits, kDigits, nDigits);\n-            exp = decExponent - nDigits;\n-\n-            int ieeeBits = Float.floatToRawIntBits(fValue); \/\/ IEEE-754 bits of float candidate\n-            final int B5 = Math.max(0, -exp); \/\/ powers of 5 in bigB, value is not modified inside correctionLoop\n-            final int D5 = Math.max(0, exp); \/\/ powers of 5 in bigD, value is not modified inside correctionLoop\n-            bigD0 = bigD0.multByPow52(D5, 0);\n-            bigD0.makeImmutable();   \/\/ prevent bigD0 modification inside correctionLoop\n-            FDBigInteger bigD = null;\n-            int prevD2 = 0;\n-\n-            correctionLoop:\n-            while (true) {\n-                \/\/ here ieeeBits can't be NaN, Infinity or zero\n-                int binexp = ieeeBits >>> SINGLE_EXP_SHIFT;\n-                int bigBbits = ieeeBits & FloatConsts.SIGNIF_BIT_MASK;\n-                if (binexp > 0) {\n-                    bigBbits |= SINGLE_FRACT_HOB;\n-                } else { \/\/ Normalize denormalized numbers.\n-                    assert bigBbits != 0 : bigBbits; \/\/ floatToBigInt(0.0)\n-                    int leadingZeros = Integer.numberOfLeadingZeros(bigBbits);\n-                    int shift = leadingZeros - (31 - SINGLE_EXP_SHIFT);\n-                    bigBbits <<= shift;\n-                    binexp = 1 - shift;\n+            if (n <= FLOG_10_MAX_LONG && -SINGLE_MAX_SMALL_TEN <= ep) {\n+                v = fl;\n+                boolean isExact = (long) v == fl;\n+                if (isExact && ep <= SINGLE_MAX_SMALL_TEN) {\n+                    v = ep >= 0 ? v * SINGLE_SMALL_10_POW[ep] : v \/ SINGLE_SMALL_10_POW[-ep];\n+                    return signed(v);\n@@ -1352,89 +1061,28 @@\n-                binexp -= FloatConsts.EXP_BIAS;\n-                int lowOrderZeros = Integer.numberOfTrailingZeros(bigBbits);\n-                bigBbits >>>= lowOrderZeros;\n-                final int bigIntExp = binexp - SINGLE_EXP_SHIFT + lowOrderZeros;\n-                final int bigIntNBits = SINGLE_EXP_SHIFT + 1 - lowOrderZeros;\n-\n-                \/\/\n-                \/\/ Scale bigD, bigB appropriately for\n-                \/\/ big-integer operations.\n-                \/\/ Naively, we multiply by powers of ten\n-                \/\/ and powers of two. What we actually do\n-                \/\/ is keep track of the powers of 5 and\n-                \/\/ powers of 2 we would use, then factor out\n-                \/\/ common divisors before doing the work.\n-                \/\/\n-                int B2 = B5; \/\/ powers of 2 in bigB\n-                int D2 = D5; \/\/ powers of 2 in bigD\n-                int Ulp2;   \/\/ powers of 2 in halfUlp.\n-                if (bigIntExp >= 0) {\n-                    B2 += bigIntExp;\n-                } else {\n-                    D2 -= bigIntExp;\n-                }\n-                Ulp2 = B2;\n-                \/\/ shift bigB and bigD left by a number s. t.\n-                \/\/ halfUlp is still an integer.\n-                int hulpbias;\n-                if (binexp <= -FloatConsts.EXP_BIAS) {\n-                    \/\/ This is going to be a denormalized number\n-                    \/\/ (if not actually zero).\n-                    \/\/ half an ULP is at 2^-(FloatConsts.EXP_BIAS+SINGLE_EXP_SHIFT+1)\n-                    hulpbias = binexp + lowOrderZeros + FloatConsts.EXP_BIAS;\n-                } else {\n-                    hulpbias = 1 + lowOrderZeros;\n-                }\n-                B2 += hulpbias;\n-                D2 += hulpbias;\n-                \/\/ if there are common factors of 2, we might just as well\n-                \/\/ factor them out, as they add nothing useful.\n-                int common2 = Math.min(B2, Math.min(D2, Ulp2));\n-                B2 -= common2;\n-                D2 -= common2;\n-                Ulp2 -= common2;\n-                \/\/ do multiplications by powers of 5 and 2\n-                FDBigInteger bigB = FDBigInteger.valueOfMulPow52(bigBbits, B5, B2);\n-                if (bigD == null || prevD2 != D2) {\n-                    bigD = bigD0.leftShift(D2);\n-                    prevD2 = D2;\n-                }\n-                \/\/\n-                \/\/ to recap:\n-                \/\/ bigB is the scaled-big-int version of our floating-point\n-                \/\/ candidate.\n-                \/\/ bigD is the scaled-big-int version of the exact value\n-                \/\/ as we understand it.\n-                \/\/ halfUlp is 1\/2 an ulp of bigB, except for special cases\n-                \/\/ of exact powers of 2\n-                \/\/\n-                \/\/ the plan is to compare bigB with bigD, and if the difference\n-                \/\/ is less than halfUlp, then we're satisfied. Otherwise,\n-                \/\/ use the ratio of difference to halfUlp to calculate a fudge\n-                \/\/ factor to add to the floating value, then go 'round again.\n-                \/\/\n-                FDBigInteger diff;\n-                int cmpResult;\n-                boolean overvalue;\n-                if ((cmpResult = bigB.cmp(bigD)) > 0) {\n-                    overvalue = true; \/\/ our candidate is too big.\n-                    diff = bigB.leftInplaceSub(bigD); \/\/ bigB is not user further - reuse\n-                    if ((bigIntNBits == 1) && (bigIntExp > -FloatConsts.EXP_BIAS + 1)) {\n-                        \/\/ candidate is a normalized exact power of 2 and\n-                        \/\/ is too big (larger than Float.MIN_NORMAL). We will be subtracting.\n-                        \/\/ For our purposes, ulp is the ulp of the\n-                        \/\/ next smaller range.\n-                        Ulp2 -= 1;\n-                        if (Ulp2 < 0) {\n-                            \/\/ rats. Cannot de-scale ulp this far.\n-                            \/\/ must scale diff in other direction.\n-                            Ulp2 = 0;\n-                            diff = diff.leftShift(1);\n-                        }\n-                    }\n-                } else if (cmpResult < 0) {\n-                    overvalue = false; \/\/ our candidate is too small.\n-                    diff = bigD.rightInplaceSub(bigB); \/\/ bigB is not user further - reuse\n-                } else {\n-                    \/\/ the candidate is exactly right!\n-                    \/\/ this happens with surprising frequency\n-                    break correctionLoop;\n+                \/*\n+                 * The similar case in doubleValue() where fl is exact and\n+                 * ep is somewhat larger than MAX_SMALL_TEN is already covered\n+                 * above for float.\n+                 *\/\n+            }\n+            long ll = fl;\n+            long lh;\n+            if (n <= MathUtils.N) {\n+                ll *= MathUtils.pow10(MathUtils.N - n);\n+                lh = ll;\n+            } else {\n+                lh = ll + 1;\n+            }\n+            int el = e - MathUtils.N;\n+            int rp = MathUtils.flog2pow10(el) + 2;\n+            long g1 = MathUtils.g1(el);\n+            long nl1 = Math.unsignedMultiplyHigh(ll, g1);\n+            long nl0 = ll * g1;\n+            long nh1 = Math.unsignedMultiplyHigh(lh, g1 + 1);\n+            long nh0 = lh * (g1 + 1);\n+            int bl = Long.SIZE - Long.numberOfLeadingZeros(nl1);\n+            if (bl + rp > Float.MIN_EXPONENT) {\n+                float ul = nl1 | (nl0 != 0 ? 1 : 0);\n+                float uh = nh1 | (nh0 != 0 ? 1 : 0);\n+                v = Math.scalb(ul, rp);\n+                if (ul == uh) {\n+                    return signed(v);\n@@ -1442,10 +1090,20 @@\n-                cmpResult = diff.cmpPow52(B5, Ulp2);\n-                if ((cmpResult) < 0) {\n-                    \/\/ difference is small.\n-                    \/\/ this is close enough\n-                    break correctionLoop;\n-                } else if (cmpResult == 0) {\n-                    \/\/ difference is exactly half an ULP\n-                    \/\/ round to some other value maybe, then finish\n-                    if ((ieeeBits & 1) != 0) { \/\/ half ties to even\n-                        ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n+            } else {\n+                int bh = Long.SIZE - Long.numberOfLeadingZeros(nh1);\n+                if (bh + rp <= Float.MIN_EXPONENT) {\n+                    int sh = FloatToDecimal.Q_MIN - rp;\n+                    long sbMask = -1L >>> 1 - sh;\n+\n+                    long nl1p = nl1 >>> sh;\n+                    long rb = nl1 >>> sh - 1;\n+                    long sb = (nl1 & sbMask | nl0) != 0 ? 1 : 0;\n+                    long corr = rb & (sb | nl1p) & 0b1;\n+                    float ul = nl1p + corr;\n+\n+                    long nh1p = nh1 >>> sh;\n+                    rb = nh1 >>> sh - 1;\n+                    sb = (nh1 & sbMask | nh0) != 0 ? 1 : 0;\n+                    corr = rb & (sb | nh1p) & 0b1;\n+                    float uh = nh1p + corr;\n+                    v = Math.scalb(ul, rp + sh);\n+                    if (ul == uh) {\n+                        return signed(v);\n@@ -1453,1 +1111,0 @@\n-                    break correctionLoop;\n@@ -1455,9 +1112,1 @@\n-                    \/\/ difference is non-trivial.\n-                    \/\/ could scale addend by ratio of difference to\n-                    \/\/ halfUlp here, if we bothered to compute that difference.\n-                    \/\/ Most of the time ( I hope ) it is about 1 anyway.\n-                    ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n-                    if (ieeeBits == 0 || ieeeBits == FloatConsts.EXP_BIT_MASK) { \/\/ 0.0 or Float.POSITIVE_INFINITY\n-                        break correctionLoop; \/\/ oops. Fell off end of range.\n-                    }\n-                    continue; \/\/ try again.\n+                    return signed(Float.MIN_NORMAL);\n@@ -1465,1 +1114,0 @@\n-\n@@ -1467,4 +1115,15 @@\n-            if (isNegative) {\n-                ieeeBits |= FloatConsts.SIGN_BIT_MASK;\n-            }\n-            return Float.intBitsToFloat(ieeeBits);\n+            int bits = Float.floatToRawIntBits(v);\n+            int be = (bits & FloatConsts.EXP_BIT_MASK) >>> FloatConsts.SIGNIFICAND_WIDTH - 1;\n+            int qr = be - (FloatConsts.EXP_BIAS + FloatConsts.SIGNIFICAND_WIDTH - 1)\n+                    - (be != 0 ? 1 : 0);\n+            int cr = 2 * (bits & FloatConsts.SIGNIF_BIT_MASK | (be != 0 ? FloatToDecimal.C_MIN : 0)) + 1;\n+            FDBigInteger lhs = valueOfMulPow52(cr, Math.max(-ep, 0), Math.max(qr - ep, 0));\n+            FDBigInteger rhs = new FDBigInteger(fl, d, m, n)\n+                    .multByPow52(Math.max(ep, 0), Math.max(ep - qr, 0));\n+            int cmp = lhs.cmp(rhs);\n+            v = Float.intBitsToFloat(cmp < 0\n+                    ? bits + 1\n+                    : cmp > 0\n+                    ? bits\n+                    : bits + (bits & 0b1));\n+            return signed(v);\n@@ -1473,0 +1132,3 @@\n+        private float signed(float v) {\n+            return isNegative ? -v : v;\n+        }\n@@ -1474,4 +1136,2 @@\n-        \/**\n-         * All the positive powers of 10 that can be\n-         * represented exactly in double\/float.\n-         *\/\n+        \/* All the powers of 10 that can be represented exactly in double. *\/\n+        @Stable\n@@ -1479,6 +1139,3 @@\n-            1.0e0,\n-            1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5,\n-            1.0e6, 1.0e7, 1.0e8, 1.0e9, 1.0e10,\n-            1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15,\n-            1.0e16, 1.0e17, 1.0e18, 1.0e19, 1.0e20,\n-            1.0e21, 1.0e22\n+                1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n+                1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n+                1e20, 1e21, 1e22,\n@@ -1487,0 +1144,2 @@\n+        \/* All the powers of 10 that can be represented exactly in float. *\/\n+        @Stable\n@@ -1488,3 +1147,2 @@\n-            1.0e0f,\n-            1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,\n-            1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f\n+                1e0f, 1e1f, 1e2f, 1e3f, 1e4f, 1e5f, 1e6f, 1e7f, 1e8f, 1e9f,\n+                1e10f,\n@@ -1493,7 +1151,2 @@\n-        private static final double[] BIG_10_POW = {\n-            1e16, 1e32, 1e64, 1e128, 1e256 };\n-        private static final double[] TINY_10_POW = {\n-            1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };\n-\n-        private static final int MAX_SMALL_TEN = SMALL_10_POW.length-1;\n-        private static final int SINGLE_MAX_SMALL_TEN = SINGLE_SMALL_10_POW.length-1;\n+        private static final int MAX_SMALL_TEN = SMALL_10_POW.length - 1;\n+        private static final int SINGLE_MAX_SMALL_TEN = SINGLE_SMALL_10_POW.length - 1;\n@@ -1511,1 +1164,1 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+    public static BinaryToASCIIBuffer getBinaryToASCIIConverter(double d, boolean compat) {\n@@ -1513,1 +1166,1 @@\n-                ? getCompatBinaryToASCIIConverter(d, true)\n+                ? getCompatBinaryToASCIIConverter(d)\n@@ -1517,1 +1170,1 @@\n-    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+    private static BinaryToASCIIBuffer getBinaryToASCIIConverter(double d) {\n@@ -1544,1 +1197,1 @@\n-    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIBuffer getCompatBinaryToASCIIConverter(double d) {\n@@ -1578,1 +1231,0 @@\n-        buf.setSign(isNegative);\n@@ -1580,1 +1232,1 @@\n-        buf.dtoa(binExp, fractBits, nSignificantBits, isCompatibleFormat);\n+        buf.dtoa(binExp, fractBits, nSignificantBits);\n@@ -1584,10 +1236,0 @@\n-    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n-\n-        \/\/ Prevent an extreme negative exponent from causing overflow issues in doubleValue().\n-        \/\/ Large positive values are handled within doubleValue();\n-        if (decExp < MIN_DECIMAL_EXPONENT) {\n-            return A2BC_POSITIVE_ZERO;\n-        }\n-        return new ASCIIToBinaryBuffer(false, decExp, digits, length);\n-    }\n-\n@@ -1600,1 +1242,1 @@\n-     *          is one of 16, 32, 64\n+     *           is one of 16, 32, 64\n@@ -1602,1 +1244,1 @@\n-     * @throws NullPointerException if the input is null\n+     * @throws NullPointerException  if the input is null\n@@ -1605,1 +1247,1 @@\n-    static ASCIIToBinaryConverter readJavaFormatString(String in, int ix) {\n+    private static double readJavaFormatString(String in, int ix) {\n@@ -1627,0 +1269,1 @@\n+         * but is much shorter in common cases.\n@@ -1650,1 +1293,1 @@\n-                return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+                return ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n@@ -1654,1 +1297,1 @@\n-                return A2BC_NOT_A_NUMBER;  \/\/ ignore sign\n+                return Double.NaN;  \/\/ ignore sign\n@@ -1733,1 +1376,1 @@\n-            return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+            return ssign != '-' ? 0.0 : -0.0;\n@@ -1788,1 +1431,1 @@\n-            } else if (lz < pt) {  \/\/ lz < pt <= tnz\n+            } else if (lz < pt) {  \/\/ lz < pt ≤ tnz\n@@ -1800,2 +1443,2 @@\n-         * Integer f = <f_1 ... f_n> consists of the n decimal or hexadecimal\n-         * digits found in part [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n+         * Integer f = <d_1 ... d_n> consists of the n decimal or hexadecimal\n+         * digits found in part [lz, tnz) of the input, and d_1 > 0, d_n > 0.\n@@ -1827,1 +1470,1 @@\n-             * Let x = c 2^ep, so 2^(ep+bl-1) <= x < 2^(ep+bl)\n+             * Let x = c 2^ep, so 2^(ep+bl-1) ≤ x < 2^(ep+bl)\n@@ -1832,1 +1475,1 @@\n-                return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+                return ssign != '-' ? 0.0 : -0.0;\n@@ -1834,2 +1477,2 @@\n-            if (ep > QE_MAX[ix] - bl) {\n-                return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+            if (ep > QP_MAX[ix] - bl) {\n+                return ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n@@ -1839,1 +1482,1 @@\n-            if (q >= QE_MIN[ix] - bl) {\n+            if (q >= QP_MIN[ix] - bl) {\n@@ -1863,4 +1506,2 @@\n-                case BINARY_32_IX ->\n-                    new PreparedASCIIToBinaryBuffer(Double.NaN, buildFloat(ssign, q, c));\n-                case BINARY_64_IX ->\n-                    new PreparedASCIIToBinaryBuffer(buildDouble(ssign, q, c), Float.NaN);\n+                case BINARY_32_IX -> buildFloat(ssign, q, c);\n+                case BINARY_64_IX -> buildDouble(ssign, q, c);\n@@ -1876,3 +1517,3 @@\n-         *      x = 0.d_1 ... d_n 10^e, 10^(e-1) <= x < 10^e\n-         * If e <= E_THR_Z then x rounds to zero.\n-         * Similarly, if e >= E_THR_I then x rounds to infinity.\n+         *      x = 0.d_1 ... d_n 10^e, 10^(e-1) ≤ x < 10^e\n+         * If e ≤ E_THR_Z then x rounds to zero.\n+         * Similarly, if e ≥ E_THR_I then x rounds to infinity.\n@@ -1883,2 +1524,2 @@\n-        if (e == E_THR_Z[ix]) {  \/\/ true e <= E_THR_Z\n-            return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+        if (e == E_THR_Z[ix]) {  \/\/ the true mathematical e ≤ E_THR_Z\n+            return ssign != '-' ? 0.0 : -0.0;\n@@ -1886,2 +1527,2 @@\n-        if (e == E_THR_I[ix]) {  \/\/ true e >= E_THR_I\n-            return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+        if (e == E_THR_I[ix]) {  \/\/ the true mathematical e ≥ E_THR_I\n+            return ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n@@ -1894,1 +1535,1 @@\n-         *      q >= Q_MIN\n+         *      q ≥ Q_MIN\n@@ -1896,1 +1537,1 @@\n-         *      either  2^(P-1) <= beta < 2^P\n+         *      either  2^(P-1) ≤ beta < 2^P\n@@ -1907,1 +1548,1 @@\n-         *      ql <= q <= qh, and qh - ql <= 4\n+         *      ql ≤ q ≤ qh, and qh - ql ≤ 4\n@@ -1912,1 +1553,1 @@\n-         *      c 2^q, c integer, 2^(P-1) <= c < 2^P (normal values)\n+         *      c 2^q, c integer, 2^(P-1) ≤ c < 2^P (normal values)\n@@ -1915,1 +1556,1 @@\n-         *      c 2^q, c integer, 0 <= c < 2^(P-1) (subnormal values and zero)\n+         *      c 2^q, c integer, 0 ≤ c < 2^(P-1) (subnormal values and zero)\n@@ -1930,1 +1571,1 @@\n-         * If n > e we pass the digits d_1...d_e 3 (3 is as good as any other\n+         * If n > e we pass the digits <d_1...d_e 8> (8 is as good as any other\n@@ -1932,1 +1573,1 @@\n-         * If n <= e we pass all the digits d_1...d_n (no sticky digit,\n+         * If n ≤ e we pass all the digits <d_1...d_n> (no sticky digit,\n@@ -1935,1 +1576,1 @@\n-         * Now assume qh <= 0, so q <= 0.\n+         * Now assume qh ≤ 0, so q ≤ 0.\n@@ -1946,2 +1587,2 @@\n-         * digits of f, sticky 3, and e.\n-         * Otherwise, n <= e + 1 - ql.\n+         * digits of f, sticky 8 (the \"most even\" digit), and e.\n+         * Otherwise, n ≤ e + 1 - ql.\n@@ -1950,1 +1591,1 @@\n-         * Otherwise, ql <= 0 < qh, so -4 < q <= 4.\n+         * Otherwise, ql ≤ 0 < qh, so -4 < q ≤ 4.\n@@ -1954,1 +1595,0 @@\n-        \/\/ TODO insert logic for small n: 9 for float, 18 for double\n@@ -1957,1 +1597,1 @@\n-        byte[] digits = new byte[Math.min(n, np)];\n+        byte[] d = new byte[Math.min(n, np)];\n@@ -1959,2 +1599,2 @@\n-            copyDigits(in, digits, np - 1, lz);\n-            digits[np - 1] = '3';  \/\/ append any non-zero sticky digit\n+            copyDigits(in, d, np - 1, lz);\n+            d[np - 1] = '8';  \/\/ append the \"most even\" non-zero sticky digit\n@@ -1962,1 +1602,1 @@\n-            copyDigits(in, digits, n, lz);\n+            copyDigits(in, d, n, lz);\n@@ -1964,1 +1604,8 @@\n-        return new ASCIIToBinaryBuffer(ssign == '-', e, digits, digits.length);\n+        \/* For now throw on BINARY_16_IX, until Float16 is integrated in java.base. *\/\n+        return switch (ix) {\n+            case BINARY_32_IX ->\n+                    new ASCIIToBinaryBuffer(ssign == '-', e, d, d.length).floatValue();\n+            case BINARY_64_IX ->\n+                    new ASCIIToBinaryBuffer(ssign == '-', e, d, d.length).doubleValue();\n+            default -> throw new AssertionError(\"unexpected\");\n+        };\n@@ -1991,1 +1638,1 @@\n-    private static void copyDigits(String in, byte[] digits, int len, int i) {\n+    private static void copyDigits(String in, byte[] d, int len, int i) {\n@@ -1996,1 +1643,1 @@\n-                digits[j++] = (byte) ch;\n+                d[j++] = (byte) ch;\n@@ -2001,1 +1648,1 @@\n-    \/* Arithmetically \"appends the dec digit\" ch to v >= 0, clamping at 10^10. *\/\n+    \/* Arithmetically \"appends the dec digit\" ch to v ≥ 0, clamping at 10^10. *\/\n@@ -2070,2 +1717,2 @@\n-     *      Q_MIN <= q <= Q_MAX\n-     *      either      2^(P-1) <= c < 2^P                  (normal)\n+     *      Q_MIN ≤ q ≤ Q_MAX\n+     *      either      2^(P-1) ≤ c < 2^P                   (normal)\n@@ -2073,1 +1720,1 @@\n-     *      c = b_1...b_P  (b_i in [0, 2))\n+     *      c = <b_1...b_P>  (b_i in [0, 2)),   b_1 > 0 iff normal\n@@ -2076,3 +1723,3 @@\n-     *      m 2^ep\n-     * where integer qe and real f meet\n-     *      qe = q + P\n+     *      m 2^qp\n+     * where integer qp and real m meet\n+     *      qp = q + P\n@@ -2081,2 +1728,2 @@\n-     *      QE_MIN = Q_MIN + P, QE_MAX = Q_MAX + P,\n-     *      2^(-1) <= m < 1     (normal)\n+     *      QP_MIN = Q_MIN + P, QP_MAX = Q_MAX + P,\n+     *      2^(-1) ≤ m < 1      (normal)\n@@ -2084,1 +1731,1 @@\n-     *      m = 0.b_1...b_P\n+     *      m = <0.b_1...b_P>\n@@ -2094,2 +1741,2 @@\n-\/\/    private static final int BINARY_128_IX = 3;\n-\/\/    private static final int BINARY_256_IX = 4;\n+    \/\/ private static final int BINARY_128_IX = 3;\n+    \/\/ private static final int BINARY_256_IX = 4;\n@@ -2099,3 +1746,3 @@\n-            11,\n-            FloatToDecimal.P,\n-            DoubleToDecimal.P,\n+            11,  \/\/ 11\n+            FloatToDecimal.P,  \/\/ 24\n+            DoubleToDecimal.P,  \/\/ 53\n@@ -2106,10 +1753,0 @@\n-    @Stable\n-    private static final int[] W = {\n-            5,\n-            FloatToDecimal.W,\n-            DoubleToDecimal.W,\n-\/\/            (1 << 4 + BINARY_128_IX) - P[BINARY_128_IX],\n-\/\/            (1 << 4 + BINARY_256_IX) - P[BINARY_256_IX],\n-    };\n-\n-    \/* Minimum exponent in the m 2^e representation. *\/\n@@ -2119,5 +1756,5 @@\n-            -24,  \/\/ Float16ToDecimal.Q_MIN,\n-            FloatToDecimal.Q_MIN,\n-            DoubleToDecimal.Q_MIN,\n-\/\/            QE_MIN[BINARY_128_IX] - (P[BINARY_128_IX] - 1),\n-\/\/            QE_MIN[BINARY_256_IX] - (P[BINARY_256_IX] - 1),\n+            -24,  \/\/ Float16ToDecimal.Q_MIN,  \/\/ -24\n+            FloatToDecimal.Q_MIN,  \/\/ -149\n+            DoubleToDecimal.Q_MIN,  \/\/ -1_074\n+            \/\/ -16_494,\n+            \/\/ -262_378,\n@@ -2126,0 +1763,1 @@\n+    \/* Minimum exponent in the m 2^qp representation. *\/\n@@ -2127,6 +1765,6 @@\n-    private static final int[] QE_MIN = {\n-            Q_MIN[BINARY_16_IX] + P[BINARY_16_IX],\n-            FloatToDecimal.Q_MIN + FloatToDecimal.P,\n-            DoubleToDecimal.Q_MIN + DoubleToDecimal.P,\n-\/\/            Q_MIN[BINARY_128_IX] + P[BINARY_128_IX],\n-\/\/            Q_MIN[BINARY_256_IX] + P[BINARY_256_IX],\n+    private static final int[] QP_MIN = {\n+            Q_MIN[BINARY_16_IX] + P[BINARY_16_IX],  \/\/ -13\n+            Q_MIN[BINARY_32_IX] + P[BINARY_32_IX],  \/\/ -125\n+            Q_MIN[BINARY_64_IX] + P[BINARY_64_IX],  \/\/ -1_021\n+            \/\/ Q_MIN[BINARY_128_IX] + P[BINARY_128_IX],  \/\/ -16_381\n+            \/\/ Q_MIN[BINARY_256_IX] + P[BINARY_256_IX],  \/\/ -262_141\n@@ -2135,1 +1773,1 @@\n-    \/* Maximum exponent in the m 2^e representation. *\/\n+    \/* Maximum exponent in the m 2^qp representation. *\/\n@@ -2137,6 +1775,6 @@\n-    private static final int[] QE_MAX = {\n-            3 - QE_MIN[BINARY_16_IX],\n-            FloatToDecimal.Q_MAX + FloatToDecimal.P,\n-            DoubleToDecimal.Q_MAX + DoubleToDecimal.P,\n-\/\/            3 - QE_MIN[BINARY_128_IX],\n-\/\/            3 - QE_MIN[BINARY_256_IX],\n+    private static final int[] QP_MAX = {\n+            3 - QP_MIN[BINARY_16_IX],  \/\/ 16\n+            3 - QP_MIN[BINARY_32_IX],  \/\/ 128\n+            3 - QP_MIN[BINARY_64_IX],  \/\/ 1_024\n+            \/\/ 3 - QP_MIN[BINARY_128_IX],  \/\/ 16_384\n+            \/\/ 3 - QP_MIN[BINARY_256_IX],  \/\/ 262_144\n@@ -2145,0 +1783,8 @@\n+    \/*\n+     * For each binary floating-point format, let\n+     *      THR_Z = ulp(0.0) \/ 2 = MIN_VALUE \/ 2\n+     * THR_Z is the zero threshold.\n+     * Real x rounds to 0 by roundTiesToEven iff |x| ≤ THR_Z.\n+     *\n+     * E_THR_Z = max{e : 10^e ≤ THR_Z}.\n+     *\/\n@@ -2147,3 +1793,3 @@\n-            -8,\n-            FloatToDecimal.E_THR_Z,\n-            DoubleToDecimal.E_THR_Z,\n+            -8,  \/\/ -8\n+            FloatToDecimal.E_THR_Z,  \/\/ -46\n+            DoubleToDecimal.E_THR_Z,  \/\/ -324\n@@ -2154,0 +1800,8 @@\n+    \/*\n+     * For each binary floating-point format, let\n+     *      THR_I = MAX_VALUE + ulp(MAX_VALUE) \/ 2\n+     * THR_I is the infinity threshold.\n+     * Real x rounds to infinity by roundTiesToEven iff |x| ≥ THR_I.\n+     *\n+     * E_THR_I = min{e : THR_I ≤ 10^(e-1)}.\n+     *\/\n@@ -2156,3 +1810,3 @@\n-            6,\n-            FloatToDecimal.E_THR_I,\n-            DoubleToDecimal.E_THR_I,\n+            6,  \/\/ 6\n+            FloatToDecimal.E_THR_I,  \/\/ 40\n+            DoubleToDecimal.E_THR_I,  \/\/ 310\n@@ -2169,5 +1823,5 @@\n-            P[BINARY_16_IX] \/ 4 + 2,\n-            P[BINARY_32_IX] \/ 4 + 2,\n-            P[BINARY_64_IX] \/ 4 + 2,\n-\/\/            P[BINARY_128_IX] \/ 4 + 2,\n-\/\/            P[BINARY_256_IX] \/ 4 + 2,\n+            P[BINARY_16_IX] \/ 4 + 2,  \/\/ 4\n+            P[BINARY_32_IX] \/ 4 + 2,  \/\/ 8\n+            P[BINARY_64_IX] \/ 4 + 2,  \/\/ 15\n+            \/\/ P[BINARY_128_IX] \/ 4 + 2,  \/\/ 30\n+            \/\/ P[BINARY_256_IX] \/ 4 + 2,  \/\/ 61\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":570,"deletions":916,"binary":false,"changes":1486,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-     * N = max{n : 10^n - 1 <= 2^Long.SIZE - 1}\n+     * N = max{n : 10^n - 1 ≤ 2^Long.SIZE - 1}\n@@ -55,1 +55,1 @@\n-     *      2^125 <= beta < 2^126.\n+     *      2^125 ≤ beta < 2^126.\n@@ -60,1 +60,1 @@\n-     *      (g - 1) 2^r <= 10^e < g 2^r\n+     *      (g - 1) 2^r ≤ 10^e < g 2^r\n@@ -64,1 +64,1 @@\n-     * For e with GE_MIN <= e <= GE_MAX, the values g1 and g0 are available\n+     * For e with GE_MIN ≤ e ≤ GE_MAX, the values g1 and g0 are available\n@@ -76,1 +76,1 @@\n-     * Let x = f 10^ep, where integers f and ep meet 10^(n-1) <= f < 10^n\n+     * Let x = f 10^ep, where integers f and ep meet 10^(n-1) ≤ f < 10^n\n@@ -80,2 +80,2 @@\n-     * The decimal->double fast paths assume n <= N.\n-     * Thus, E_THR_Z - (N - 1) <= ep <= E_THR_I - 2, which means that\n+     * The decimal->double fast paths assume n ≤ N.\n+     * Thus, E_THR_Z - (N - 1) ≤ ep ≤ E_THR_I - 2, which means that\n@@ -87,0 +87,10 @@\n+     *\n+     * For the record, while the definition of g allows the case g = 2^126,\n+     * the maximal g1 in the lookup table is 0x7FDD_E7F4_CA72_E30FL (e = -146),\n+     * the minimal g1 is 0x4000_0000_0000_0000L (for e = 0),\n+     * and the minimal g0 is 1.\n+     * Hence, as easily verified, we always have\n+     *      2^62 < g1 + 1 < 2^31 (2^32 - 1) < 2^63\n+     *      2^125 < g = g1 2^63 + g0 < (g1 + 1) 2^63 < 2^94 (2^32 - 1) < 2^126\n+     * We will assume these bounds observed by glancing at the lookup table,\n+     * and use them liberally when so needed.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,1 @@\n-import java.math.BigInteger;\n-import java.nio.charset.StandardCharsets;\n-import jdk.internal.math.FDBigInteger;\n+import jdk.internal.math.FDBigIntegerChecker;\n@@ -28,1 +26,1 @@\n-\/**\n+\/*\n@@ -33,1 +31,3 @@\n- * @author Dmitry Nadezhin\n+ * @library java.base\n+ * @build java.base\/jdk.internal.math.*\n+ * @run main TestFDBigInteger\n@@ -37,384 +37,0 @@\n-    private static final int MAX_P5 = 413;\n-    private static final int MAX_P2 = 65;\n-    private static final long LONG_SIGN_MASK = (1L << 63);\n-    private static final BigInteger FIVE = BigInteger.valueOf(5);\n-    private static final FDBigInteger MUTABLE_ZERO = FDBigInteger.valueOfPow52(0, 0).leftInplaceSub(FDBigInteger.valueOfPow52(0, 0));\n-    private static final FDBigInteger IMMUTABLE_ZERO = FDBigInteger.valueOfPow52(0, 0).leftInplaceSub(FDBigInteger.valueOfPow52(0, 0));\n-    private static final FDBigInteger IMMUTABLE_MILLION = genMillion1();\n-    private static final FDBigInteger IMMUTABLE_BILLION = genBillion1();\n-    private static final FDBigInteger IMMUTABLE_TEN18 = genTen18();\n-\n-    static {\n-        IMMUTABLE_ZERO.makeImmutable();\n-        IMMUTABLE_MILLION.makeImmutable();\n-        IMMUTABLE_BILLION.makeImmutable();\n-        IMMUTABLE_TEN18.makeImmutable();\n-    }\n-\n-    private static FDBigInteger mutable(String hex, int offset) {\n-        byte[] chars = new BigInteger(hex, 16).toString().getBytes(StandardCharsets.US_ASCII);\n-        return new FDBigInteger(0, chars, 0, chars.length).multByPow52(0, offset * 32);\n-    }\n-\n-    private static FDBigInteger immutable(String hex, int offset) {\n-        FDBigInteger fd = mutable(hex, offset);\n-        fd.makeImmutable();\n-        return fd;\n-    }\n-\n-    private static BigInteger biPow52(int p5, int p2) {\n-        return FIVE.pow(p5).shiftLeft(p2);\n-    }\n-\n-    \/\/ data.length == 1, nWords == 1, offset == 0\n-    private static FDBigInteger genMillion1() {\n-        return FDBigInteger.valueOfPow52(6, 0).leftShift(6);\n-    }\n-\n-    \/\/ data.length == 2, nWords == 1, offset == 0\n-    private static FDBigInteger genMillion2() {\n-        return FDBigInteger.valueOfMulPow52(1000000L, 0, 0);\n-    }\n-\n-    \/\/ data.length == 1, nWords == 1, offset == 0\n-    private static FDBigInteger genBillion1() {\n-        return FDBigInteger.valueOfPow52(9, 0).leftShift(9);\n-    }\n-\n-    \/\/ data.length == 2, nWords == 2, offset == 0\n-    private static FDBigInteger genTen18() {\n-        return FDBigInteger.valueOfPow52(18, 0).leftShift(18);\n-    }\n-\n-    private static void check(BigInteger expected, FDBigInteger actual, String message) throws Exception {\n-        if (!expected.equals(actual.toBigInteger())) {\n-            throw new Exception(message + \" result \" + actual.toHexString() + \" expected \" + expected.toString(16));\n-        }\n-    }\n-\n-    private static void testValueOfPow52(int p5, int p2) throws Exception {\n-        check(biPow52(p5, p2), FDBigInteger.valueOfPow52(p5, p2),\n-                \"valueOfPow52(\" + p5 + \",\" + p2 + \")\");\n-    }\n-\n-    private static void testValueOfPow52() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-                testValueOfPow52(p5, p2);\n-            }\n-        }\n-    }\n-\n-    private static void testValueOfMulPow52(long value, int p5, int p2) throws Exception {\n-        BigInteger bi = BigInteger.valueOf(value & ~LONG_SIGN_MASK);\n-        if (value < 0) {\n-            bi = bi.setBit(63);\n-        }\n-        check(biPow52(p5, p2).multiply(bi), FDBigInteger.valueOfMulPow52(value, p5, p2),\n-                \"valueOfMulPow52(\" + Long.toHexString(value) + \".\" + p5 + \",\" + p2 + \")\");\n-    }\n-\n-    private static void testValueOfMulPow52(long value, int p5) throws Exception {\n-        testValueOfMulPow52(value, p5, 0);\n-        testValueOfMulPow52(value, p5, 1);\n-        testValueOfMulPow52(value, p5, 30);\n-        testValueOfMulPow52(value, p5, 31);\n-        testValueOfMulPow52(value, p5, 33);\n-        testValueOfMulPow52(value, p5, 63);\n-    }\n-\n-    private static void testValueOfMulPow52() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            testValueOfMulPow52(0xFFFFFFFFL, p5);\n-            testValueOfMulPow52(0x123456789AL, p5);\n-            testValueOfMulPow52(0x7FFFFFFFFFFFFFFFL, p5);\n-            testValueOfMulPow52(0xFFFFFFFFFFF54321L, p5);\n-        }\n-    }\n-\n-    private static void testLeftShift(FDBigInteger t, int shift, boolean isImmutable) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        FDBigInteger r = t.leftShift(shift);\n-        if ((bt.signum() == 0 || shift == 0 || !isImmutable) && r != t) {\n-            throw new Exception(\"leftShift doesn't reuse its argument\");\n-        }\n-        if (isImmutable) {\n-            check(bt, t, \"leftShift corrupts its argument\");\n-        }\n-        check(bt.shiftLeft(shift), r, \"leftShift returns wrong result\");\n-    }\n-\n-    private static void testLeftShift() throws Exception {\n-        testLeftShift(IMMUTABLE_ZERO, 0, true);\n-        testLeftShift(IMMUTABLE_ZERO, 10, true);\n-        testLeftShift(MUTABLE_ZERO, 0, false);\n-        testLeftShift(MUTABLE_ZERO, 10, false);\n-\n-        testLeftShift(IMMUTABLE_MILLION, 0, true);\n-        testLeftShift(IMMUTABLE_MILLION, 1, true);\n-        testLeftShift(IMMUTABLE_MILLION, 12, true);\n-        testLeftShift(IMMUTABLE_MILLION, 13, true);\n-        testLeftShift(IMMUTABLE_MILLION, 32, true);\n-        testLeftShift(IMMUTABLE_MILLION, 33, true);\n-        testLeftShift(IMMUTABLE_MILLION, 44, true);\n-        testLeftShift(IMMUTABLE_MILLION, 45, true);\n-\n-        testLeftShift(genMillion1(), 0, false);\n-        testLeftShift(genMillion1(), 1, false);\n-        testLeftShift(genMillion1(), 12, false);\n-        testLeftShift(genMillion1(), 13, false);\n-        testLeftShift(genMillion1(), 25, false);\n-        testLeftShift(genMillion1(), 26, false);\n-        testLeftShift(genMillion1(), 32, false);\n-        testLeftShift(genMillion1(), 33, false);\n-        testLeftShift(genMillion1(), 44, false);\n-        testLeftShift(genMillion1(), 45, false);\n-\n-        testLeftShift(genMillion2(), 0, false);\n-        testLeftShift(genMillion2(), 1, false);\n-        testLeftShift(genMillion2(), 12, false);\n-        testLeftShift(genMillion2(), 13, false);\n-        testLeftShift(genMillion2(), 25, false);\n-        testLeftShift(genMillion2(), 26, false);\n-        testLeftShift(genMillion2(), 32, false);\n-        testLeftShift(genMillion2(), 33, false);\n-        testLeftShift(genMillion2(), 44, false);\n-        testLeftShift(genMillion2(), 45, false);\n-    }\n-\n-    private static void testQuoRemIteration(FDBigInteger t, FDBigInteger s) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bs = s.toBigInteger();\n-        int q = t.quoRemIteration(s);\n-        BigInteger[] qr = bt.divideAndRemainder(bs);\n-        if (!BigInteger.valueOf(q).equals(qr[0])) {\n-            throw new Exception(\"quoRemIteration returns incorrect quo\");\n-        }\n-        check(qr[1].multiply(BigInteger.TEN), t, \"quoRemIteration returns incorrect rem\");\n-    }\n-\n-    private static void testQuoRemIteration() throws Exception {\n-        \/\/ IMMUTABLE_TEN18 == 0de0b6b3a7640000\n-        \/\/ q = 0\n-        testQuoRemIteration(mutable(\"00000001\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"00000001\", 1), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b2\", 1), IMMUTABLE_TEN18);\n-        \/\/ q = 1 -> q = 0\n-        testQuoRemIteration(mutable(\"0de0b6b3\", 1), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b3a763FFFF\", 0), IMMUTABLE_TEN18);\n-        \/\/ q = 1\n-        testQuoRemIteration(mutable(\"0de0b6b3a7640000\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b3FFFFFFFF\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"8ac72304\", 1), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b400000000\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"8ac72305\", 1), IMMUTABLE_TEN18);\n-        \/\/ q = 18\n-        testQuoRemIteration(mutable(\"FFFFFFFF\", 1), IMMUTABLE_TEN18);\n-    }\n-\n-    private static void testCmp(FDBigInteger t, FDBigInteger o) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bo = o.toBigInteger();\n-        int cmp = t.cmp(o);\n-        int bcmp = bt.compareTo(bo);\n-        if (bcmp != cmp) {\n-            throw new Exception(\"cmp returns \" + cmp + \" expected \" + bcmp);\n-        }\n-        check(bt, t, \"cmp corrupts this\");\n-        check(bo, o, \"cmp corrupts other\");\n-        if (o.cmp(t) != -cmp) {\n-            throw new Exception(\"asymmetrical cmp\");\n-        }\n-        check(bt, t, \"cmp corrupts this\");\n-        check(bo, o, \"cmp corrupts other\");\n-    }\n-\n-    private static void testCmp() throws Exception {\n-        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"100000000\", 0));\n-        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"1\", 1));\n-        testCmp(mutable(\"5\", 0), mutable(\"6\", 0));\n-        testCmp(mutable(\"5\", 0), mutable(\"5\", 0));\n-        testCmp(mutable(\"5000000001\", 0), mutable(\"500000001\", 0));\n-        testCmp(mutable(\"5000000001\", 0), mutable(\"6\", 1));\n-        testCmp(mutable(\"5000000001\", 0), mutable(\"5\", 1));\n-        testCmp(mutable(\"5000000000\", 0), mutable(\"5\", 1));\n-    }\n-\n-    private static void testCmpPow52(FDBigInteger t, int p5, int p2) throws Exception {\n-        FDBigInteger o = FDBigInteger.valueOfPow52(p5, p2);\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bo = biPow52(p5, p2);\n-        int cmp = t.cmp(o);\n-        int bcmp = bt.compareTo(bo);\n-        if (bcmp != cmp) {\n-            throw new Exception(\"cmpPow52 returns \" + cmp + \" expected \" + bcmp);\n-        }\n-        check(bt, t, \"cmpPow52 corrupts this\");\n-        check(bo, o, \"cmpPow5 corrupts other\");\n-    }\n-\n-    private static void testCmpPow52() throws Exception {\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 31);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 32);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 33);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 34);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 64);\n-        testCmpPow52(mutable(\"00000003\", 1), 0, 32);\n-        testCmpPow52(mutable(\"00000003\", 1), 0, 33);\n-        testCmpPow52(mutable(\"00000003\", 1), 0, 34);\n-    }\n-\n-    private static void testAddAndCmp(FDBigInteger t, FDBigInteger x, FDBigInteger y) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bx = x.toBigInteger();\n-        BigInteger by = y.toBigInteger();\n-        int cmp = t.addAndCmp(x, y);\n-        int bcmp = bt.compareTo(bx.add(by));\n-        if (bcmp != cmp) {\n-            throw new Exception(\"addAndCmp returns \" + cmp + \" expected \" + bcmp);\n-        }\n-        check(bt, t, \"addAndCmp corrupts this\");\n-        check(bx, x, \"addAndCmp corrupts x\");\n-        check(by, y, \"addAndCmp corrupts y\");\n-    }\n-\n-    private static void testAddAndCmp() throws Exception {\n-        testAddAndCmp(MUTABLE_ZERO, MUTABLE_ZERO, MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 0), MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000001\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000002\", 0), MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000002\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"FFFFFFFF\", 0), mutable(\"FFFFFFFF\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 1), mutable(\"00000001\", 0));\n-\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0F80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0E80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n-\n-        testAddAndCmp(mutable(\"00000002\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-        testAddAndCmp(mutable(\"00000003\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-        testAddAndCmp(mutable(\"00000004\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-        testAddAndCmp(mutable(\"00000005\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000001\", 0));\n-        testAddAndCmp(mutable(\"00000002\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n-        testAddAndCmp(mutable(\"00000003\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n-    }\n-\n-    private static void testMultBy10(FDBigInteger t, boolean isImmutable) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        FDBigInteger r = t.multBy10();\n-        if ((bt.signum() == 0 || !isImmutable) && r != t) {\n-            throw new Exception(\"multBy10 of doesn't reuse its argument\");\n-        }\n-        if (isImmutable) {\n-            check(bt, t, \"multBy10 corrupts its argument\");\n-        }\n-        check(bt.multiply(BigInteger.TEN), r, \"multBy10 returns wrong result\");\n-    }\n-\n-    private static void testMultBy10() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-                \/\/ This strange way of creating a value ensures that it is mutable.\n-                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                testMultBy10(value, false);\n-                value.makeImmutable();\n-                testMultBy10(value, true);\n-            }\n-        }\n-    }\n-\n-    private static void testMultByPow52(FDBigInteger t, int p5, int p2) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        FDBigInteger r = t.multByPow52(p5, p2);\n-        if (bt.signum() == 0 && r != t) {\n-            throw new Exception(\"multByPow52 of doesn't reuse its argument\");\n-        }\n-        check(bt.multiply(biPow52(p5, p2)), r, \"multByPow52 returns wrong result\");\n-    }\n-\n-    private static void testMultByPow52() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-                \/\/ This strange way of creating a value ensures that it is mutable.\n-                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                testMultByPow52(value, p5, p2);\n-            }\n-        }\n-    }\n-\n-    private static void testLeftInplaceSub(FDBigInteger left, FDBigInteger right, boolean isImmutable) throws Exception {\n-        BigInteger biLeft = left.toBigInteger();\n-        BigInteger biRight = right.toBigInteger();\n-        FDBigInteger diff = left.leftInplaceSub(right);\n-        if (!isImmutable && diff != left) {\n-            throw new Exception(\"leftInplaceSub of doesn't reuse its argument\");\n-        }\n-        if (isImmutable) {\n-            check(biLeft, left, \"leftInplaceSub corrupts its left immutable argument\");\n-        }\n-        check(biRight, right, \"leftInplaceSub corrupts its right argument\");\n-        check(biLeft.subtract(biRight), diff, \"leftInplaceSub returns wrong result\");\n-    }\n-\n-    private static void testLeftInplaceSub() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-\/\/                for (int p5r = 0; p5r <= p5; p5r += 10) {\n-\/\/                    for (int p2r = 0; p2r <= p2; p2r += 10) {\n-                for (int p5r = 0; p5r <= p5; p5r++) {\n-                    for (int p2r = 0; p2r <= p2; p2r++) {\n-                        \/\/ This strange way of creating a value ensures that it is mutable.\n-                        FDBigInteger left = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                        FDBigInteger right = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5r, p2r);\n-                        testLeftInplaceSub(left, right, false);\n-                        left = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                        left.makeImmutable();\n-                        testLeftInplaceSub(left, right, true);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void testRightInplaceSub(FDBigInteger left, FDBigInteger right, boolean isImmutable) throws Exception {\n-        BigInteger biLeft = left.toBigInteger();\n-        BigInteger biRight = right.toBigInteger();\n-        FDBigInteger diff = left.rightInplaceSub(right);\n-        if (!isImmutable && diff != right) {\n-            throw new Exception(\"rightInplaceSub of doesn't reuse its argument\");\n-        }\n-        check(biLeft, left, \"leftInplaceSub corrupts its left argument\");\n-        if (isImmutable) {\n-            check(biRight, right, \"leftInplaceSub corrupts its right immutable argument\");\n-        }\n-        try {\n-            check(biLeft.subtract(biRight), diff, \"rightInplaceSub returns wrong result\");\n-        } catch (Exception e) {\n-            System.out.println(biLeft+\" - \"+biRight+\" = \"+biLeft.subtract(biRight));\n-            throw e;\n-        }\n-    }\n-\n-    private static void testRightInplaceSub() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-\/\/                for (int p5r = 0; p5r <= p5; p5r += 10) {\n-\/\/                    for (int p2r = 0; p2r <= p2; p2r += 10) {\n-                for (int p5r = 0; p5r <= p5; p5r++) {\n-                    for (int p2r = 0; p2r <= p2; p2r++) {\n-                        \/\/ This strange way of creating a value ensures that it is mutable.\n-                        FDBigInteger left = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                        FDBigInteger right = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5r, p2r);\n-                        testRightInplaceSub(left, right, false);\n-                        right = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5r, p2r);\n-                        right.makeImmutable();\n-                        testRightInplaceSub(left, right, true);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n@@ -422,12 +38,1 @@\n-        testValueOfPow52();\n-        testValueOfMulPow52();\n-        testLeftShift();\n-        testQuoRemIteration();\n-        testCmp();\n-        testCmpPow52();\n-        testAddAndCmp();\n-        \/\/ Uncomment the following for more comprehensize but slow testing.\n-        \/\/ testLeftInplaceSub();\n-        \/\/ testMultBy10();\n-        \/\/ testMultByPow52();\n-        \/\/ testRightInplaceSub();\n+        FDBigIntegerChecker.main(args);\n@@ -435,0 +40,1 @@\n+\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/TestFDBigInteger.java","additions":8,"deletions":402,"binary":false,"changes":410,"status":"modified"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+\n+public class FDBigIntegerChecker {\n+\n+    private static final int MAX_P5 = 413;\n+    private static final int MAX_P2 = 65;\n+    private static final long LONG_SIGN_MASK = (1L << 63);\n+    private static final BigInteger FIVE = BigInteger.valueOf(5);\n+    private static final FDBigInteger MUTABLE_ZERO = new FDBigInteger(0);\n+    private static final FDBigInteger IMMUTABLE_ZERO = new FDBigInteger(0).makeImmutable();\n+    private static final FDBigInteger IMMUTABLE_MILLION = genMillion1().makeImmutable();\n+    private static final FDBigInteger IMMUTABLE_TEN18 = genTen18().makeImmutable();\n+\n+    private static BigInteger toBigInteger(FDBigInteger v) {\n+        return new BigInteger(v.toByteArray());\n+    }\n+\n+    private static FDBigInteger mutable(String hex, int offset) {\n+        byte[] chars = new BigInteger(hex, 16).toString().getBytes(StandardCharsets.US_ASCII);\n+        return new FDBigInteger(0, chars, 0, chars.length).multByPow52(0, offset * 32);\n+    }\n+\n+    private static BigInteger biPow52(int p5, int p2) {\n+        return FIVE.pow(p5).shiftLeft(p2);\n+    }\n+\n+    \/\/ data.length == 1, nWords == 1, offset == 0\n+    private static FDBigInteger genMillion1() {\n+        return FDBigInteger.valueOfPow52(6, 0).leftShift(6);\n+    }\n+\n+    \/\/ data.length == 2, nWords == 1, offset == 0\n+    private static FDBigInteger genMillion2() {\n+        return FDBigInteger.valueOfMulPow52(1000000L, 0, 0);\n+    }\n+\n+    \/\/ data.length == 2, nWords == 2, offset == 0\n+    private static FDBigInteger genTen18() {\n+        return FDBigInteger.valueOfPow52(18, 0).leftShift(18);\n+    }\n+\n+    private static void check(BigInteger expected, FDBigInteger actual, String message) throws Exception {\n+        if (!expected.equals(toBigInteger(actual))) {\n+            throw new Exception(message + \" result \" + actual + \" expected \" + expected.toString(16));\n+        }\n+    }\n+\n+    private static void testValueOfPow52(int p5, int p2) throws Exception {\n+        check(biPow52(p5, p2), FDBigInteger.valueOfPow52(p5, p2),\n+                \"valueOfPow52(\" + p5 + \",\" + p2 + \")\");\n+    }\n+\n+    private static void testValueOfPow52() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n+                testValueOfPow52(p5, p2);\n+            }\n+        }\n+    }\n+\n+    private static void testValueOfMulPow52(long value, int p5, int p2) throws Exception {\n+        BigInteger bi = BigInteger.valueOf(value & ~LONG_SIGN_MASK);\n+        if (value < 0) {\n+            bi = bi.setBit(63);\n+        }\n+        check(biPow52(p5, p2).multiply(bi), FDBigInteger.valueOfMulPow52(value, p5, p2),\n+                \"valueOfMulPow52(\" + Long.toHexString(value) + \".\" + p5 + \",\" + p2 + \")\");\n+    }\n+\n+    private static void testValueOfMulPow52(long value, int p5) throws Exception {\n+        testValueOfMulPow52(value, p5, 0);\n+        testValueOfMulPow52(value, p5, 1);\n+        testValueOfMulPow52(value, p5, 30);\n+        testValueOfMulPow52(value, p5, 31);\n+        testValueOfMulPow52(value, p5, 33);\n+        testValueOfMulPow52(value, p5, 63);\n+    }\n+\n+    private static void testValueOfMulPow52() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            testValueOfMulPow52(0xFFFFFFFFL, p5);\n+            testValueOfMulPow52(0x123456789AL, p5);\n+            testValueOfMulPow52(0x7FFFFFFFFFFFFFFFL, p5);\n+            testValueOfMulPow52(0xFFFFFFFFFFF54321L, p5);\n+        }\n+    }\n+\n+    private static void testLeftShift(FDBigInteger t, int shift, boolean isImmutable) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        FDBigInteger r = t.leftShift(shift);\n+        if ((bt.signum() == 0 || shift == 0 || !isImmutable) && r != t) {\n+            throw new Exception(\"leftShift doesn't reuse its argument\");\n+        }\n+        if (isImmutable) {\n+            check(bt, t, \"leftShift corrupts its argument\");\n+        }\n+        check(bt.shiftLeft(shift), r, \"leftShift returns wrong result\");\n+    }\n+\n+    private static void testLeftShift() throws Exception {\n+        testLeftShift(IMMUTABLE_ZERO, 0, true);\n+        testLeftShift(IMMUTABLE_ZERO, 10, true);\n+        testLeftShift(MUTABLE_ZERO, 0, false);\n+        testLeftShift(MUTABLE_ZERO, 10, false);\n+\n+        testLeftShift(IMMUTABLE_MILLION, 0, true);\n+        testLeftShift(IMMUTABLE_MILLION, 1, true);\n+        testLeftShift(IMMUTABLE_MILLION, 12, true);\n+        testLeftShift(IMMUTABLE_MILLION, 13, true);\n+        testLeftShift(IMMUTABLE_MILLION, 32, true);\n+        testLeftShift(IMMUTABLE_MILLION, 33, true);\n+        testLeftShift(IMMUTABLE_MILLION, 44, true);\n+        testLeftShift(IMMUTABLE_MILLION, 45, true);\n+\n+        testLeftShift(genMillion1(), 0, false);\n+        testLeftShift(genMillion1(), 1, false);\n+        testLeftShift(genMillion1(), 12, false);\n+        testLeftShift(genMillion1(), 13, false);\n+        testLeftShift(genMillion1(), 25, false);\n+        testLeftShift(genMillion1(), 26, false);\n+        testLeftShift(genMillion1(), 32, false);\n+        testLeftShift(genMillion1(), 33, false);\n+        testLeftShift(genMillion1(), 44, false);\n+        testLeftShift(genMillion1(), 45, false);\n+\n+        testLeftShift(genMillion2(), 0, false);\n+        testLeftShift(genMillion2(), 1, false);\n+        testLeftShift(genMillion2(), 12, false);\n+        testLeftShift(genMillion2(), 13, false);\n+        testLeftShift(genMillion2(), 25, false);\n+        testLeftShift(genMillion2(), 26, false);\n+        testLeftShift(genMillion2(), 32, false);\n+        testLeftShift(genMillion2(), 33, false);\n+        testLeftShift(genMillion2(), 44, false);\n+        testLeftShift(genMillion2(), 45, false);\n+    }\n+\n+    private static void testQuoRemIteration(FDBigInteger t, FDBigInteger s) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bs = toBigInteger(s);\n+        int q = t.quoRemIteration(s);\n+        BigInteger[] qr = bt.divideAndRemainder(bs);\n+        if (!BigInteger.valueOf(q).equals(qr[0])) {\n+            throw new Exception(\"quoRemIteration returns incorrect quo\");\n+        }\n+        check(qr[1].multiply(BigInteger.TEN), t, \"quoRemIteration returns incorrect rem\");\n+    }\n+\n+    private static void testQuoRemIteration() throws Exception {\n+        \/\/ IMMUTABLE_TEN18 == 0de0b6b3a7640000\n+        \/\/ q = 0\n+        testQuoRemIteration(mutable(\"00000001\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"00000001\", 1), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b2\", 1), IMMUTABLE_TEN18);\n+        \/\/ q = 1 -> q = 0\n+        testQuoRemIteration(mutable(\"0de0b6b3\", 1), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b3a763FFFF\", 0), IMMUTABLE_TEN18);\n+        \/\/ q = 1\n+        testQuoRemIteration(mutable(\"0de0b6b3a7640000\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b3FFFFFFFF\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"8ac72304\", 1), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b400000000\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"8ac72305\", 1), IMMUTABLE_TEN18);\n+        \/\/ q = 18\n+        testQuoRemIteration(mutable(\"FFFFFFFF\", 1), IMMUTABLE_TEN18);\n+    }\n+\n+    private static void testCmp(FDBigInteger t, FDBigInteger o) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bo = toBigInteger(o);\n+        int cmp = t.cmp(o);\n+        int bcmp = bt.compareTo(bo);\n+        if (bcmp != cmp) {\n+            throw new Exception(\"cmp returns \" + cmp + \" expected \" + bcmp);\n+        }\n+        check(bt, t, \"cmp corrupts this\");\n+        check(bo, o, \"cmp corrupts other\");\n+        if (o.cmp(t) != -cmp) {\n+            throw new Exception(\"asymmetrical cmp\");\n+        }\n+        check(bt, t, \"cmp corrupts this\");\n+        check(bo, o, \"cmp corrupts other\");\n+    }\n+\n+    private static void testCmp() throws Exception {\n+        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"100000000\", 0));\n+        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"1\", 1));\n+        testCmp(mutable(\"5\", 0), mutable(\"6\", 0));\n+        testCmp(mutable(\"5\", 0), mutable(\"5\", 0));\n+        testCmp(mutable(\"5000000001\", 0), mutable(\"500000001\", 0));\n+        testCmp(mutable(\"5000000001\", 0), mutable(\"6\", 1));\n+        testCmp(mutable(\"5000000001\", 0), mutable(\"5\", 1));\n+        testCmp(mutable(\"5000000000\", 0), mutable(\"5\", 1));\n+    }\n+\n+    private static void testCmpPow52(FDBigInteger t, int p5, int p2) throws Exception {\n+        FDBigInteger o = FDBigInteger.valueOfPow52(p5, p2);\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bo = biPow52(p5, p2);\n+        int cmp = t.cmp(o);\n+        int bcmp = bt.compareTo(bo);\n+        if (bcmp != cmp) {\n+            throw new Exception(\"cmp returns \" + cmp + \" expected \" + bcmp);\n+        }\n+        check(bt, t, \"cmp corrupts this\");\n+        check(bo, o, \"cmpPow5 corrupts other\");\n+    }\n+\n+    private static void testCmpPow52() throws Exception {\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 31);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 32);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 33);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 34);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 64);\n+        testCmpPow52(mutable(\"00000003\", 1), 0, 32);\n+        testCmpPow52(mutable(\"00000003\", 1), 0, 33);\n+        testCmpPow52(mutable(\"00000003\", 1), 0, 34);\n+    }\n+\n+    private static void testAddAndCmp(FDBigInteger t, FDBigInteger x, FDBigInteger y) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bx = toBigInteger(x);\n+        BigInteger by = toBigInteger(y);\n+        int cmp = t.addAndCmp(x, y);\n+        int bcmp = bt.compareTo(bx.add(by));\n+        if (bcmp != cmp) {\n+            throw new Exception(\"addAndCmp returns \" + cmp + \" expected \" + bcmp);\n+        }\n+        check(bt, t, \"addAndCmp corrupts this\");\n+        check(bx, x, \"addAndCmp corrupts x\");\n+        check(by, y, \"addAndCmp corrupts y\");\n+    }\n+\n+    private static void testAddAndCmp() throws Exception {\n+        testAddAndCmp(MUTABLE_ZERO, MUTABLE_ZERO, MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 0), MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000001\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000002\", 0), MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000002\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"FFFFFFFF\", 0), mutable(\"FFFFFFFF\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 1), mutable(\"00000001\", 0));\n+\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0F80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0E80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n+\n+        testAddAndCmp(mutable(\"00000002\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+        testAddAndCmp(mutable(\"00000003\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+        testAddAndCmp(mutable(\"00000004\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+        testAddAndCmp(mutable(\"00000005\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000001\", 0));\n+        testAddAndCmp(mutable(\"00000002\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n+        testAddAndCmp(mutable(\"00000003\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n+    }\n+\n+    private static void testMultBy10(FDBigInteger t, boolean isImmutable) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        FDBigInteger r = t.multBy10();\n+        if ((bt.signum() == 0 || !isImmutable) && r != t) {\n+            throw new Exception(\"multBy10 of doesn't reuse its argument\");\n+        }\n+        if (isImmutable) {\n+            check(bt, t, \"multBy10 corrupts its argument\");\n+        }\n+        check(bt.multiply(BigInteger.TEN), r, \"multBy10 returns wrong result\");\n+    }\n+\n+    private static void testMultBy10() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n+                \/\/ This strange way of creating a value ensures that it is mutable.\n+                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n+                testMultBy10(value, false);\n+                value.makeImmutable();\n+                testMultBy10(value, true);\n+            }\n+        }\n+    }\n+\n+    private static void testMultByPow52(FDBigInteger t, int p5, int p2) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        FDBigInteger r = t.multByPow52(p5, p2);\n+        if (bt.signum() == 0 && r != t) {\n+            throw new Exception(\"multByPow52 of doesn't reuse its argument\");\n+        }\n+        check(bt.multiply(biPow52(p5, p2)), r, \"multByPow52 returns wrong result\");\n+    }\n+\n+    private static void testMultByPow52() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n+                \/\/ This strange way of creating a value ensures that it is mutable.\n+                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n+                testMultByPow52(value, p5, p2);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testValueOfPow52();\n+        testValueOfMulPow52();\n+        testLeftShift();\n+        testQuoRemIteration();\n+        testCmp();\n+        testCmpPow52();\n+        testAddAndCmp();\n+        \/\/ Uncomment the following for more comprehensize but slow testing.\n+        \/\/ testMultBy10();\n+        \/\/ testMultByPow52();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/java.base\/jdk\/internal\/math\/FDBigIntegerChecker.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 3, time = 3)\n+@Fork(value = 3)\n+public class FloatingPointParse {\n+\n+    private static final int N = 1_000_000;\n+    private static final int M = 100_000;\n+\n+    private String[] doubleToString, floatToString, s1, s2, s4, s10;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random();\n+\n+        doubleToString = new String[N];\n+        for (int i = 0; i < doubleToString.length;) {\n+            double v = Double.longBitsToDouble(r.nextLong());\n+            if (Double.isFinite(v)) {\n+                doubleToString[i++] = Double.toString(v);\n+            }\n+        }\n+\n+        floatToString = new String[N];\n+        for (int i = 0; i < floatToString.length;) {\n+            float v = Float.intBitsToFloat(r.nextInt());\n+            if (Float.isFinite(v)) {\n+                floatToString[i++] = Float.toString(v);\n+            }\n+        }\n+\n+        s1 = new String[M];\n+        for (int i = 0; i < s1.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s1[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+        s2 = new String[M];\n+        for (int i = 0; i < s2.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s2[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+        s4 = new String[M];\n+        for (int i = 0; i < s4.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s4[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+        s10 = new String[M];\n+        for (int i = 0; i < s10.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s10[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(N)\n+    public void parseDoubleToString(Blackhole bh) {\n+        for (String s : doubleToString) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS1(Blackhole bh) {\n+        for (String s : s1) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS2(Blackhole bh) {\n+        for (String s : s2) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS4(Blackhole bh) {\n+        for (String s : s4) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS10(Blackhole bh) {\n+        for (String s : s10) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(N)\n+    public void parseFloatToString(Blackhole bh) {\n+        for (String s : floatToString) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS1(Blackhole bh) {\n+        for (String s : s1) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS2(Blackhole bh) {\n+        for (String s : s2) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS4(Blackhole bh) {\n+        for (String s : s4) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS10(Blackhole bh) {\n+        for (String s : s10) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatingPointParse.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"}]}