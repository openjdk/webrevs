{"files":[{"patch":"@@ -657,0 +657,6 @@\n+#ifdef ASSERT\n+void BitMap::IteratorImpl::assert_not_empty() const {\n+  assert(!is_empty(), \"empty iterator\");\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+  struct IteratorImpl;\n+\n@@ -282,0 +284,2 @@\n+  \/\/ See also the Iterator and ReverseIterator classes.\n+  \/\/\n@@ -315,0 +319,5 @@\n+  class Iterator;\n+  class ReverseIterator;\n+  class RBFIterator;\n+  class ReverseRBFIterator;\n+\n@@ -388,0 +397,149 @@\n+\/\/ Implementation support for bitmap iteration.\n+struct BitMap::IteratorImpl {\n+  const BitMap* _map;\n+  idx_t _cur_beg;\n+  idx_t _cur_end;\n+\n+  void assert_not_empty() const NOT_DEBUG_RETURN;\n+\n+  \/\/ Constructs an empty iterator.\n+  IteratorImpl();\n+\n+  \/\/ Constructs an iterator for map, over the range [beg, end).\n+  IteratorImpl(const BitMap* map, idx_t beg, idx_t end);\n+\n+  \/\/ Returns true if the remaining iteration range is empty.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the index of the first set bit in the remaining iteration range.\n+  \/\/ precondition: !is_empty()\n+  idx_t first() const;\n+\n+  \/\/ Returns the index of the last set bit in the remaining iteration range.\n+  \/\/ precondition: !is_empty()\n+  idx_t last() const;\n+\n+  \/\/ Updates first() to the position of the first set bit in the range\n+  \/\/ [first() + 1, last()]. The iterator instead becomes empty if there\n+  \/\/ aren't any set bits in that range.\n+  \/\/ precondition: !is_empty()\n+  void step_next();\n+\n+  \/\/ Updates last() to the position of the last set bit in the range\n+  \/\/ [first(), last()). The iterator instead becomes empty if there aren't\n+  \/\/ any set bits in that range.\n+  \/\/ precondition: !is_empty()\n+  void step_prev();\n+};\n+\n+\/\/ Provides iteration over the indices of the set bits in a range of a bitmap,\n+\/\/ in increasing order. This is an alternative to the iterate() function.\n+class BitMap::Iterator {\n+  IteratorImpl _impl;\n+\n+public:\n+  \/\/ Constructs an empty iterator.\n+  Iterator();\n+\n+  \/\/ Constructs an iterator for map, over the range [0, map.size()).\n+  explicit Iterator(const BitMap& map);\n+\n+  \/\/ Constructs an iterator for map, over the range [beg, end).\n+  \/\/ If there are no set bits in that range, the resulting iterator is empty.\n+  \/\/ Otherwise, index() is initially the position of the first set bit in\n+  \/\/ that range.\n+  \/\/ precondition: beg and end form a valid range for map.\n+  Iterator(const BitMap& map, idx_t beg, idx_t end);\n+\n+  \/\/ Returns true if the remaining iteration range is empty.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the index of the first set bit in the remaining iteration range.\n+  \/\/ precondition: !is_empty()\n+  idx_t index() const;\n+\n+  \/\/ Updates index() to the position of the first set bit in the range\n+  \/\/ [index(), end), where end was the corresponding constructor argument.\n+  \/\/ The iterator instead becomes empty if there aren't any set bits in\n+  \/\/ that range.\n+  \/\/ precondition: !is_empty()\n+  void step();\n+\n+  \/\/ Range-based for loop support.\n+  RBFIterator begin() const;\n+  RBFIterator end() const;\n+};\n+\n+\/\/ Provides iteration over the indices of the set bits in a range of a bitmap,\n+\/\/ in decreasing order. This is an alternative to the reverse_iterate() function.\n+class BitMap::ReverseIterator {\n+  IteratorImpl _impl;\n+\n+  static idx_t initial_end(const BitMap& map, idx_t beg, idx_t end);\n+\n+public:\n+  \/\/ Constructs an empty iterator.\n+  ReverseIterator();\n+\n+  \/\/ Constructs a reverse iterator for map, over the range [0, map.size()).\n+  explicit ReverseIterator(const BitMap& map);\n+\n+  \/\/ Constructs a reverse iterator for map, over the range [beg, end).\n+  \/\/ If there are no set bits in that range, the resulting iterator is empty.\n+  \/\/ Otherwise, index() is initially the position of the last set bit in\n+  \/\/ that range.\n+  \/\/ precondition: beg and end form a valid range for map.\n+  ReverseIterator(const BitMap& map, idx_t beg, idx_t end);\n+\n+  \/\/ Returns true if the remaining iteration range is empty.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the index of the last set bit in the remaining iteration range.\n+  \/\/ precondition: !is_empty()\n+  idx_t index() const;\n+\n+  \/\/ Updates index() to the position of the last set bit in the range\n+  \/\/ [beg, index()), where beg was the corresponding constructor argument.\n+  \/\/ The iterator instead becomes empty if there aren't any set bits in\n+  \/\/ that range.\n+  \/\/ precondition: !is_empty()\n+  void step();\n+\n+  \/\/ Range-based for loop support.\n+  ReverseRBFIterator begin() const;\n+  ReverseRBFIterator end() const;\n+};\n+\n+\/\/ Provides range-based for loop iteration support.  This class is not\n+\/\/ intended for direct use by an application.  It provides the functionality\n+\/\/ required by a range-based for loop with an Iterator as the range.\n+class BitMap::RBFIterator {\n+  friend class Iterator;\n+\n+  IteratorImpl _impl;\n+\n+  RBFIterator(const BitMap* map, idx_t beg, idx_t end);\n+\n+public:\n+  bool operator!=(const RBFIterator& i) const;\n+  idx_t operator*() const;\n+  RBFIterator& operator++();\n+};\n+\n+\/\/ Provides range-based for loop reverse iteration support.  This class is\n+\/\/ not intended for direct use by an application.  It provides the\n+\/\/ functionality required by a range-based for loop with a ReverseIterator\n+\/\/ as the range.\n+class BitMap::ReverseRBFIterator {\n+  friend class ReverseIterator;\n+\n+  IteratorImpl _impl;\n+\n+  ReverseRBFIterator(const BitMap* map, idx_t beg, idx_t end);\n+\n+public:\n+  bool operator!=(const ReverseRBFIterator& i) const;\n+  idx_t operator*() const;\n+  ReverseRBFIterator& operator++();\n+};\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -373,0 +373,155 @@\n+\/\/\/ BitMap::IteratorImpl\n+\n+inline BitMap::IteratorImpl::IteratorImpl()\n+  : _map(nullptr), _cur_beg(0), _cur_end(0)\n+{}\n+\n+inline BitMap::IteratorImpl::IteratorImpl(const BitMap* map, idx_t beg, idx_t end)\n+  : _map(map), _cur_beg(beg), _cur_end(end)\n+{}\n+\n+inline bool BitMap::IteratorImpl::is_empty() const {\n+  return _cur_beg == _cur_end;\n+}\n+\n+inline BitMap::idx_t BitMap::IteratorImpl::first() const {\n+  assert_not_empty();\n+  return _cur_beg;\n+}\n+\n+inline BitMap::idx_t BitMap::IteratorImpl::last() const {\n+  assert_not_empty();\n+  return _cur_end - 1;\n+}\n+\n+inline void BitMap::IteratorImpl::step_next() {\n+  assert_not_empty();\n+  _cur_beg = _map->find_first_set_bit(_cur_beg + 1, _cur_end);\n+}\n+\n+inline void BitMap::IteratorImpl::step_prev() {\n+  assert_not_empty();\n+  idx_t lastpos = last();\n+  idx_t pos = _map->find_last_set_bit(_cur_beg, lastpos);\n+  _cur_end = (pos < lastpos) ? (pos + 1) : _cur_beg;\n+}\n+\n+\/\/\/ BitMap::Iterator\n+\n+inline BitMap::Iterator::Iterator() : _impl() {}\n+\n+inline BitMap::Iterator::Iterator(const BitMap& map)\n+  : Iterator(map, 0, map.size())\n+{}\n+\n+inline BitMap::Iterator::Iterator(const BitMap& map, idx_t beg, idx_t end)\n+  : _impl(&map, map.find_first_set_bit(beg, end), end)\n+{}\n+\n+inline bool BitMap::Iterator::is_empty() const {\n+  return _impl.is_empty();\n+}\n+\n+inline BitMap::idx_t BitMap::Iterator::index() const {\n+  return _impl.first();\n+}\n+\n+inline void BitMap::Iterator::step() {\n+  _impl.step_next();\n+}\n+\n+inline BitMap::RBFIterator BitMap::Iterator::begin() const {\n+  return RBFIterator(_impl._map, _impl._cur_beg, _impl._cur_end);\n+}\n+\n+inline BitMap::RBFIterator BitMap::Iterator::end() const {\n+  return RBFIterator(_impl._map, _impl._cur_end, _impl._cur_end);\n+}\n+\n+\/\/\/ BitMap::ReverseIterator\n+\n+inline BitMap::idx_t BitMap::ReverseIterator::initial_end(const BitMap& map,\n+                                                          idx_t beg,\n+                                                          idx_t end) {\n+  idx_t pos = map.find_last_set_bit(beg, end);\n+  return (pos < end) ? (pos + 1) : beg;\n+}\n+\n+inline BitMap::ReverseIterator::ReverseIterator() : _impl() {}\n+\n+inline BitMap::ReverseIterator::ReverseIterator(const BitMap& map)\n+  : ReverseIterator(map, 0, map.size())\n+{}\n+\n+inline BitMap::ReverseIterator::ReverseIterator(const BitMap& map,\n+                                                idx_t beg,\n+                                                idx_t end)\n+  : _impl(&map, beg, initial_end(map, beg, end))\n+{}\n+\n+inline bool BitMap::ReverseIterator::is_empty() const {\n+  return _impl.is_empty();\n+}\n+\n+inline BitMap::idx_t BitMap::ReverseIterator::index() const {\n+  return _impl.last();\n+}\n+\n+inline void BitMap::ReverseIterator::step() {\n+  _impl.step_prev();\n+}\n+\n+inline BitMap::ReverseRBFIterator BitMap::ReverseIterator::begin() const {\n+  return ReverseRBFIterator(_impl._map, _impl._cur_beg, _impl._cur_end);\n+}\n+\n+inline BitMap::ReverseRBFIterator BitMap::ReverseIterator::end() const {\n+  return ReverseRBFIterator(_impl._map, _impl._cur_beg, _impl._cur_beg);\n+}\n+\n+\/\/\/ BitMap::RBFIterator\n+\n+inline BitMap::RBFIterator::RBFIterator(const BitMap* map, idx_t beg, idx_t end)\n+  : _impl(map, beg, end)\n+{}\n+\n+inline bool BitMap::RBFIterator::operator!=(const RBFIterator& i) const {\n+  \/\/ Shouldn't be comparing RBF iterators from different contexts.\n+  assert(_impl._map == i._impl._map, \"mismatched range-based for iterators\");\n+  assert(_impl._cur_end == i._impl._cur_end, \"mismatched range-based for iterators\");\n+  return _impl._cur_beg != i._impl._cur_beg;\n+}\n+\n+inline BitMap::idx_t BitMap::RBFIterator::operator*() const {\n+  return _impl.first();\n+}\n+\n+inline BitMap::RBFIterator& BitMap::RBFIterator::operator++() {\n+  _impl.step_next();\n+  return *this;\n+}\n+\n+\/\/\/ BitMap::ReverseRBFIterator\n+\n+inline BitMap::ReverseRBFIterator::ReverseRBFIterator(const BitMap* map,\n+                                                      idx_t beg,\n+                                                      idx_t end)\n+  : _impl(map, beg, end)\n+{}\n+\n+inline bool BitMap::ReverseRBFIterator::operator!=(const ReverseRBFIterator& i) const {\n+  \/\/ Shouldn't be comparing RBF iterators from different contexts.\n+  assert(_impl._map == i._impl._map, \"mismatched range-based for iterators\");\n+  assert(_impl._cur_beg == i._impl._cur_beg, \"mismatched range-based for iterators\");\n+  return _impl._cur_end != i._impl._cur_end;\n+}\n+\n+inline BitMap::idx_t BitMap::ReverseRBFIterator::operator*() const {\n+  return _impl.last();\n+}\n+\n+inline BitMap::ReverseRBFIterator& BitMap::ReverseRBFIterator::operator++() {\n+  _impl.step_prev();\n+  return *this;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -178,0 +178,44 @@\n+static void test_iterator(const BitMap& map,\n+                          const idx_t* positions,\n+                          size_t positions_size) {\n+  SCOPED_TRACE(\"iterate with Iterator\");\n+  size_t positions_index = 0;\n+  for (BitMap::Iterator it{map}; !it.is_empty(); it.step()) {\n+    test_iterate_step(map, it.index(), positions, positions_index++, positions_size);\n+  }\n+  ASSERT_EQ(positions_index, positions_size);\n+}\n+\n+static void test_reverse_iterator(const BitMap& map,\n+                                  const idx_t* positions,\n+                                  size_t positions_size) {\n+  SCOPED_TRACE(\"reverse iterate with Iterator\");\n+  size_t positions_index = positions_size;\n+  for (BitMap::ReverseIterator it{map}; !it.is_empty(); it.step()) {\n+    test_iterate_step(map, it.index(), positions, --positions_index, positions_size);\n+  }\n+  ASSERT_EQ(positions_index, 0u);\n+}\n+\n+static void test_for_loop_iterator(const BitMap& map,\n+                                   const idx_t* positions,\n+                                   size_t positions_size) {\n+  SCOPED_TRACE(\"iterate with range-based for loop\");\n+  size_t positions_index = 0;\n+  for (idx_t index : BitMap::Iterator(map)) {\n+    test_iterate_step(map, index, positions, positions_index++, positions_size);\n+  }\n+  ASSERT_EQ(positions_index, positions_size);\n+}\n+\n+static void test_for_loop_reverse_iterator(const BitMap& map,\n+                                           const idx_t* positions,\n+                                           size_t positions_size) {\n+  SCOPED_TRACE(\"reverse iterate with range-based for loop\");\n+  size_t positions_index = positions_size;\n+  for (idx_t index : BitMap::ReverseIterator(map)) {\n+    test_iterate_step(map, index, positions, --positions_index, positions_size);\n+  }\n+  ASSERT_EQ(positions_index, 0u);\n+}\n+\n@@ -199,0 +243,6 @@\n+\n+  test_iterator(map, positions, positions_size);\n+  test_reverse_iterator(map, positions, positions_size);\n+\n+  test_for_loop_iterator(map, positions, positions_size);\n+  test_for_loop_reverse_iterator(map, positions, positions_size);\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_iterate.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}