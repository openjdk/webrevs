{"files":[{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.lang.LazyConstantImpl;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * A lazy constant is a holder of contents that can be set at most once.\n+ * <p>\n+ * A lazy constant is created using the factory method\n+ * {@linkplain LazyConstant#of(Supplier) LazyConstant.of({@code <computing function>})}.\n+ * When created, the contents (and hence the lazy constant itself) is <em>not initialized<\/em>.\n+ * The contents (of type {@code T}) can then be <em>initialized<\/em>\n+ * (and retrieved) by calling {@linkplain #get()}. The first time {@linkplain #get()}\n+ * is called, the underlying <em>computing function<\/em> (provided at construction) will\n+ * be invoked and the result will be used to initialize the contents. Once initialized,\n+ * the contents can <em>never change<\/em> and will be retrieved over and over\n+ * again upon subsequent {@linkplain #get() get} invocations.\n+ * <p>\n+ * A lazy constant is <em>shallowly immutable<\/em>, meaning the reference to the contents\n+ * object will never change once it is initialized. However, the referenced object itself\n+ * may or may not be mutable. Hence, immutability can only be guaranteed at the first\n+ * initial, shallow level.\n+ * <p>\n+ * Consider the following example where a lazy constant field \"{@code logger}\" is a\n+ * shallowly immutable holder of an object of type {@code Logger}:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new uninitialized lazy constant\n+ *    private final LazyConstant<Logger> logger =\n+ *            \/\/ @link substring=\"of\" target=\"#of\" :\n+ *            LazyConstant.of( () -> Logger.create(Component.class) );\n+ *\n+ *    public void process() {\n+ *        logger.get().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * Initially, the lazy constant (and its contents) is <em>not initialized<\/em>.\n+ * When {@code logger.get()} is first invoked, it evaluates the computing function and\n+ * initializes the constant to the result; the result is then returned to the client.\n+ * Hence, {@linkplain #get()} guarantees that the constant is <em>initialized<\/em> before\n+ * it returns, barring any exceptions.\n+ * <p>\n+ * Furthermore, {@linkplain #get()} guarantees that, out of several threads trying to\n+ * invoke the computing function simultaneously, only one is ever selected for\n+ * computation. This property is crucial as evaluation of the computing function may have\n+ * side effects, for example, the call above to {@code Logger.create()} may result in\n+ * storage resources being prepared.\n+ *\n+ * <h2 id=\"exception-handling\">Exception handling<\/h2>\n+ * If the computing function returns {@code null}, a {@linkplain NullPointerException}\n+ * is thrown. Hence, a lazy constant can never hold a {@code null} value. Clients who\n+ * want to use a nullable constant can wrap the value into an {@linkplain Optional} holder.\n+ * <p>\n+ * If the computing function recursively invokes itself (directly or indirectly via\n+ * the lazy constant), an {@linkplain IllegalStateException} is thrown, and the lazy\n+ * constant is not initialized.\n+ * <p>\n+ * If the computing function throws any unchecked {@linkplain Exception} or\n+ * {@linkplain Error}, that {@linkplain Throwable} is propagated to the caller, and the\n+ * lazy constant remains uninitialized. In other words, upon an unsuccessful invocation of\n+ * the computing function, neither a constant, the exception, nor the fact that\n+ * an exception was thrown is ever stored in the lazy constant.\n+ *\n+ * <h2 id=\"composition\">Composing lazy constants<\/h2>\n+ * A lazy constant can depend on other lazy constants, forming a dependency graph\n+ * that can be lazily computed but where access to individual elements can still be\n+ * performant. In the following example, a single {@code Foo} and a {@code Bar}\n+ * instance (that is dependent on the {@code Foo} instance) are lazily created, both of\n+ * which are held by lazy constants:\n+ *\n+ * {@snippet lang = java:\n+ * public final class DependencyUtil {\n+ *\n+ *     private DependencyUtil() {}\n+ *\n+ *     public static class Foo {\n+ *          \/\/ ...\n+ *      }\n+ *\n+ *     public static class Bar {\n+ *         public Bar(Foo foo) {\n+ *              \/\/ ...\n+ *         }\n+ *     }\n+ *\n+ *     private static final LazyConstant<Foo> FOO = LazyConstant.of( Foo::new );\n+ *     private static final LazyConstant<Bar> BAR = LazyConstant.of( () -> new Bar(FOO.get()) );\n+ *\n+ *     public static Foo foo() {\n+ *         return FOO.get();\n+ *     }\n+ *\n+ *     public static Bar bar() {\n+ *         return BAR.get();\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Calling {@code BAR.get()} will create the {@code Bar} singleton if it is not already\n+ * created. Upon such a creation, a dependent {@code Foo} will first be created if\n+ * the {@code Foo} does not already exist.\n+ *\n+ * <h2 id=\"thread-safety\">Thread Safety<\/h2>\n+ * A lazy constant is guaranteed to be initialized atomically and at most once. If\n+ * competing threads are racing to initialize a lazy constant, only one updating thread\n+ * runs the computing function (which runs on the caller's thread and is hereafter denoted\n+ * <em>the computing thread<\/em>), while the other threads are blocked until the constant\n+ * is initialized, after which the other threads observe the lazy constant is initialized\n+ * and leave the constant unchanged and will never invoke any computation.\n+ * <p>\n+ * The invocation of the computing function and the resulting initialization of\n+ * the constant {@linkplain java.util.concurrent##MemoryVisibility <em>happens-before<\/em>}\n+ * the initialized constant is read. Hence, the initialized constant, including any\n+ * {@code final} fields of any newly created objects, is safely published.\n+ * <p>\n+ * Thread interruption does not cancel the initialization of a lazy constant. In other\n+ * words, if the computing thread is interrupted, {@code LazyConstant::get} doesn't clear\n+ * the interrupted threadâ€™s status, nor does it throw an InterruptedException.\n+ * <p>\n+ * If the computing function blocks indefinitely, other threads operating on this\n+ * lazy constant may block indefinitely; no timeouts or cancellations are provided.\n+ *\n+ * <h2 id=\"performance\">Performance<\/h2>\n+ * A lazy constant can never change after it has been initialized. Therefore,\n+ * a JVM implementation may, for an initialized lazy constant, elide all future reads\n+ * of that lazy constant and instead directly use any constant that it has previously\n+ * observed. We call this optimization <em>constant folding<\/em>. This is only possible if\n+ * the reference to the lazy constant is a VM constant (e.g. in cases where\n+ * the lazy constant itself is stored in a {@code static final} field) or forms\n+ * a trusted chain to such a VM constant via one or more trusted fields (i.e., any\n+ * combination of static final fields, {@linkplain Record record} fields, or\n+ * final instance fields in hidden classes).\n+ *\n+ * <h2 id=\"miscellaneous\">Miscellaneous<\/h2>\n+ * Except for {@linkplain Object#equals(Object) equals(obj)} and\n+ * {@linkplain #orElse(Object) orElse(other)} parameters, all method parameters\n+ * must be <em>non-null<\/em>, or a {@link NullPointerException} will be thrown.\n+ *\n+ * @apiNote Once a lazy constant is initialized with an object, the object cannot ever be\n+ *          removed. This can be a source of an unintended memory leak. More specifically,\n+ *          a lazy constant {@linkplain java.lang.ref##reachability strongly references}\n+ *          the object it was initialized with. Hence, a lazy constant will hold\n+ *          the object it was initialized with until the lazy constant itself\n+ *          is collected (if ever).\n+ *          <p>\n+ *          A {@code LazyConstant} that has a type parameter {@code T} that is an\n+ *          array type (of arbitrary rank) will only allow the JVM to treat the\n+ *          <em>array reference<\/em> as a constant, but <em>not its components<\/em>.\n+ *          Instead, a {@linkplain List#ofLazy(int, IntFunction) lazy list} of\n+ *          arbitrary depth can be used, which provides constant components.\n+ *          More generally, a lazy constant can hold other lazy constants of\n+ *          arbitrary depth and still provide transitive constant folding.\n+ *          <p>\n+ *          The {@code LazyConstant} type is not {@link Serializable}.\n+ *          <p>\n+ *          Use in static initializers may interact with class initialization order;\n+ *          cyclic initialization may result in initialization errors as described\n+ *          in {@jls 12.4} of <cite>The Java Language Specification<\/cite>.\n+ *\n+ * @implNote\n+ *           A lazy constant is free to synchronize on itself. Hence, care must be\n+ *           taken when directly or indirectly synchronizing on a lazy constant.\n+ *\n+ * @param <T> type of the constant\n+ *\n+ * @since 26\n+ *\n+ * @see Optional\n+ * @see Supplier\n+ * @see List#ofLazy(int, IntFunction)\n+ * @see Map#ofLazy(Set, Function)\n+ * @jls 12.4 Initialization of Classes and Interfaces\n+ * @jls 17.4.5 Happens-before Order\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.LAZY_CONSTANTS)\n+public sealed interface LazyConstant<T>\n+        extends Supplier<T>\n+        permits LazyConstantImpl {\n+\n+    \/**\n+     * {@return the contents if initialized, otherwise, returns {@code other}}\n+     * <p>\n+     * This method never triggers initialization of this lazy constant and will observe\n+     * initialization by other threads atomically (i.e., it returns the initialized\n+     * contents if and only if the initialization has already completed).\n+     *\n+     * @param other value to return if the content is not initialized\n+     *              (can be {@code null})\n+     *\/\n+    T orElse(T other);\n+\n+    \/**\n+     * {@return the initialized contents. If not initialized, first computes and\n+     *          initializes the contents using the computing function}\n+     * <p>\n+     * After this method returns successfully, the constant is guaranteed to be\n+     * initialized.\n+     * <p>\n+     * If the computing function throws, the throwable is relayed to the caller and\n+     * the lazy constant remains uninitialized; a subsequent call to get() may then\n+     * attempt the computation again.\n+     *\/\n+    T get();\n+\n+    \/**\n+     * {@return {@code true} if the contents is initialized, {@code false} otherwise}\n+     * <p>\n+     * This method never triggers initialization of this lazy constant and will observe\n+     * changes in the initialization state made by other threads atomically.\n+     *\/\n+    boolean isInitialized();\n+\n+    \/\/ Object method\n+\n+    \/**\n+     * {@return a non-initializing string suitable for debugging}\n+     * <p>\n+     * This method never triggers initialization of this lazy constant and will observe\n+     * initialization by other threads atomically (i.e., it observes the initialized\n+     * contents if and only if the initialization has already completed).\n+     * <p>\n+     * If this lazy constant is initialized, the {@linkplain Object#toString()} of the\n+     * initialized contents will be returned; otherwise, an implementation-dependent\n+     * string is returned that indicates this lazy constant is not yet initialized.\n+     *\/\n+    @Override\n+    String toString();\n+\n+    \/\/ Factory\n+\n+    \/**\n+     * {@return a lazy constant to be computed later via the provided\n+     *          {@code computingFunction}}\n+     * <p>\n+     * The returned lazy constant strongly references the provided\n+     * {@code computingFunction} until initialization completes successfully; after\n+     * which the computing function is no longer strongly referenced and becomes\n+     * eligible for garbage collection.\n+     * <p>\n+     * If the provided computing function is already an instance of\n+     * {@code LazyConstant}, the method is free to return the provided computing function\n+     * directly.\n+     *\n+     * @param computingFunction in the form of a Supplier to be used to compute\n+     *                          the constant\n+     * @param <T>               type of the constant\n+     *\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> LazyConstant<T> of(Supplier<? extends T> computingFunction) {\n+        Objects.requireNonNull(computingFunction);\n+        if (computingFunction instanceof LazyConstant<? extends T> lc) {\n+            return (LazyConstant<T>) lc;\n+        }\n+        return LazyConstantImpl.ofLazy(computingFunction);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LazyConstant.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -1,756 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.lang.stable.StableEnumFunction;\n-import jdk.internal.lang.stable.StableFunction;\n-import jdk.internal.lang.stable.StableIntFunction;\n-import jdk.internal.lang.stable.StableSupplier;\n-import jdk.internal.lang.stable.StableUtil;\n-import jdk.internal.lang.stable.StableValueImpl;\n-\n-import java.io.Serializable;\n-import java.util.Collection;\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.RandomAccess;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n-import java.util.function.Supplier;\n-\n-\/**\n- * A stable value is a holder of contents that can be set at most once.\n- * <p>\n- * A {@code StableValue<T>} is typically created using the factory method\n- * {@linkplain StableValue#of() {@code StableValue.of()}}. When created this way,\n- * the stable value is <em>unset<\/em>, which means it holds no <em>contents<\/em>.\n- * Its contents, of type {@code T}, can be <em>set<\/em> by calling\n- * {@linkplain #trySet(Object) trySet()}, {@linkplain #setOrThrow(Object) setOrThrow()},\n- * or {@linkplain #orElseSet(Supplier) orElseSet()}. Once set, the contents\n- * can never change and can be retrieved by calling {@linkplain #orElseThrow() orElseThrow()}\n- * , {@linkplain #orElse(Object) orElse()}, or {@linkplain #orElseSet(Supplier) orElseSet()}.\n- * <p>\n- * Consider the following example where a stable value field \"{@code logger}\" is a\n- * shallowly immutable holder of contents of type {@code Logger} and that is initially\n- * created as <em>unset<\/em>, which means it holds no contents. Later in the example, the\n- * state of the \"{@code logger}\" field is checked and if it is still <em>unset<\/em>,\n- * the contents is <em>set<\/em>:\n- *\n- * {@snippet lang = java:\n- * public class Component {\n- *\n- *    \/\/ Creates a new unset stable value with no contents\n- *    \/\/ @link substring=\"of\" target=\"#of\" :\n- *    private final StableValue<Logger> logger = StableValue.of();\n- *\n- *    private Logger getLogger() {\n- *        if (!logger.isSet()) {\n- *            logger.trySet(Logger.create(Component.class));\n- *        }\n- *        return logger.orElseThrow();\n- *    }\n- *\n- *    public void process() {\n- *        getLogger().info(\"Process started\");\n- *        \/\/ ...\n- *    }\n- * }\n- *}\n- * <p>\n- * If {@code getLogger()} is called from several threads, several instances of\n- * {@code Logger} might be created. However, the contents can only be set at most once\n- * meaning the first writer wins.\n- * <p>\n- * In order to guarantee that, even under races, only one instance of {@code Logger} is\n- * ever created, the {@linkplain #orElseSet(Supplier) orElseSet()} method can be used\n- * instead, where the contents are lazily computed, and atomically set, via a\n- * {@linkplain Supplier supplier}. In the example below, the supplier is provided in the\n- * form of a lambda expression:\n- *\n- * {@snippet lang = java:\n- * public class Component {\n- *\n- *    \/\/ Creates a new unset stable value with no contents\n- *    \/\/ @link substring=\"of\" target=\"#of\" :\n- *    private final StableValue<Logger> logger = StableValue.of();\n- *\n- *    private Logger getLogger() {\n- *        return logger.orElseSet( () -> Logger.create(Component.class) );\n- *    }\n- *\n- *    public void process() {\n- *        getLogger().info(\"Process started\");\n- *        \/\/ ...\n- *    }\n- * }\n- *}\n- * <p>\n- * The {@code getLogger()} method calls {@code logger.orElseSet()} on the stable value to\n- * retrieve its contents. If the stable value is <em>unset<\/em>, then {@code orElseSet()}\n- * evaluates the given supplier, and sets the contents to the result; the result is then\n- * returned to the client. In other words, {@code orElseSet()} guarantees that a\n- * stable value's contents is <em>set<\/em> before it returns.\n- * <p>\n- * Furthermore, {@code orElseSet()} guarantees that out of one or more suppliers provided,\n- * only at most one is ever evaluated, and that one is only ever evaluated once,\n- * even when {@code logger.orElseSet()} is invoked concurrently. This property is crucial\n- * as evaluation of the supplier may have side effects, for example, the call above to\n- * {@code Logger.create()} may result in storage resources being prepared.\n- *\n- * <h2 id=\"stable-functions\">Stable Functions<\/h2>\n- * Stable values provide the foundation for higher-level functional abstractions. A\n- * <em>stable supplier<\/em> is a supplier that computes a value and then caches it into\n- * a backing stable value storage for subsequent use. A stable supplier is created via the\n- * {@linkplain StableValue#supplier(Supplier) StableValue.supplier()} factory, by\n- * providing an underlying {@linkplain Supplier} which is invoked when the stable supplier\n- * is first accessed:\n- *\n- * {@snippet lang = java:\n- * public class Component {\n- *\n- *     private final Supplier<Logger> logger =\n- *             \/\/ @link substring=\"supplier\" target=\"#supplier(Supplier)\" :\n- *             StableValue.supplier( () -> Logger.getLogger(Component.class) );\n- *\n- *     public void process() {\n- *        logger.get().info(\"Process started\");\n- *        \/\/ ...\n- *     }\n- * }\n- *}\n- * A stable supplier encapsulates access to its backing stable value storage. This means\n- * that code inside {@code Component} can obtain the logger object directly from the\n- * stable supplier, without having to go through an accessor method like {@code getLogger()}.\n- * <p>\n- * A <em>stable int function<\/em> is a function that takes an {@code int} parameter and\n- * uses it to compute a result that is then cached by the backing stable value storage\n- * for that parameter value. A stable {@link IntFunction} is created via the\n- * {@linkplain StableValue#intFunction(int, IntFunction) StableValue.intFunction()}\n- * factory. Upon creation, the input range (i.e. {@code [0, size)}) is specified together\n- * with an underlying {@linkplain IntFunction} which is invoked at most once per input\n- * value. In effect, the stable int function will act like a cache for the underlying\n- * {@linkplain IntFunction}:\n- *\n- * {@snippet lang = java:\n- * final class PowerOf2Util {\n- *\n- *     private PowerOf2Util() {}\n- *\n- *     private static final int SIZE = 6;\n- *     private static final IntFunction<Integer> UNDERLYING_POWER_OF_TWO =\n- *         v -> 1 << v;\n- *\n- *     private static final IntFunction<Integer> POWER_OF_TWO =\n- *         \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n- *         StableValue.intFunction(SIZE, UNDERLYING_POWER_OF_TWO);\n- *\n- *     public static int powerOfTwo(int a) {\n- *         return POWER_OF_TWO.apply(a);\n- *     }\n- * }\n- *\n- * int result = PowerOf2Util.powerOfTwo(4);   \/\/ May eventually constant fold to 16 at runtime\n- *\n- *}\n- * The {@code PowerOf2Util.powerOfTwo()} function is a <em>partial function<\/em> that only\n- * allows a subset {@code [0, 5]} of the underlying function's {@code UNDERLYING_POWER_OF_TWO}\n- * input range.\n- *\n- * <p>\n- * A <em>stable function<\/em> is a function that takes a parameter (of type {@code T}) and\n- * uses it to compute a result (of type {@code R}) that is then cached by the backing\n- * stable value storage for that parameter value. A stable function is created via the\n- * {@linkplain StableValue#function(Set, Function) StableValue.function()} factory.\n- * Upon creation, the input {@linkplain Set} is specified together with an underlying\n- * {@linkplain Function} which is invoked at most once per input value. In effect, the\n- * stable function will act like a cache for the underlying {@linkplain Function}:\n- *\n- * {@snippet lang = java:\n- * class Log2Util {\n- *\n- *     private Log2Util() {}\n- *\n- *     private static final Set<Integer> KEYS =\n- *         Set.of(1, 2, 4, 8, 16, 32);\n- *     private static final UnaryOperator<Integer> UNDERLYING_LOG2 =\n- *         i -> 31 - Integer.numberOfLeadingZeros(i);\n- *\n- *     private static final Function<Integer, Integer> LOG2 =\n- *         \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n- *         StableValue.function(KEYS, UNDERLYING_LOG2);\n- *\n- *     public static int log2(int a) {\n- *         return LOG2.apply(a);\n- *     }\n- *\n- * }\n- *\n- * int result = Log2Util.log2(16);   \/\/ May eventually constant fold to 4 at runtime\n- *}\n- *\n- * The {@code Log2Util.log2()} function is a <em>partial function<\/em> that only allows\n- * a subset {@code {1, 2, 4, 8, 16, 32}} of the underlying function's\n- * {@code UNDERLYING_LOG2} input range.\n- *\n- * <h2 id=\"stable-collections\">Stable Collections<\/h2>\n- * Stable values can also be used as backing storage for\n- * {@linkplain Collection##unmodifiable unmodifiable collections}. A <em>stable list<\/em>\n- * is an unmodifiable list, backed by an array of stable values. The stable list elements\n- * are computed when they are first accessed, using a provided {@linkplain IntFunction}:\n- *\n- * {@snippet lang = java:\n- * final class PowerOf2Util {\n- *\n- *     private PowerOf2Util() {}\n- *\n- *     private static final int SIZE = 6;\n- *     private static final IntFunction<Integer> UNDERLYING_POWER_OF_TWO =\n- *             v -> 1 << v;\n- *\n- *     private static final List<Integer> POWER_OF_TWO =\n- *         \/\/ @link substring=\"list\" target=\"#list(int,IntFunction)\" :\n- *         StableValue.list(SIZE, UNDERLYING_POWER_OF_TWO);\n- *\n- *     public static int powerOfTwo(int a) {\n- *         return POWER_OF_TWO.get(a);\n- *     }\n- * }\n- *\n- * int result = PowerOf2Util.powerOfTwo(4);   \/\/ May eventually constant fold to 16 at runtime\n- *\n- * }\n- * <p>\n- * Similarly, a <em>stable map<\/em> is an unmodifiable map whose keys are known at\n- * construction. The stable map values are computed when they are first accessed,\n- * using a provided {@linkplain Function}:\n- *\n- * {@snippet lang = java:\n- * class Log2Util {\n- *\n- *     private Log2Util() {}\n- *\n- *     private static final Set<Integer> KEYS =\n- *         Set.of(1, 2, 4, 8, 16, 32);\n- *     private static final UnaryOperator<Integer> UNDERLYING_LOG2 =\n- *         i -> 31 - Integer.numberOfLeadingZeros(i);\n- *\n- *     private static final Map<Integer, INTEGER> LOG2 =\n- *         \/\/ @link substring=\"map\" target=\"#map(Set,Function)\" :\n- *         StableValue.map(CACHED_KEYS, UNDERLYING_LOG2);\n- *\n- *     public static int log2(int a) {\n- *          return LOG2.get(a);\n- *     }\n- *\n- * }\n- *\n- * int result = Log2Util.log2(16);   \/\/ May eventually constant fold to 4 at runtime\n- *\n- *}\n- *\n- * <h2 id=\"composition\">Composing stable values<\/h2>\n- * A stable value can depend on other stable values, forming a dependency graph\n- * that can be lazily computed but where access to individual elements can still be\n- * performant. In the following example, a single {@code Foo} and a {@code Bar}\n- * instance (that is dependent on the {@code Foo} instance) are lazily created, both of\n- * which are held by stable values:\n- * {@snippet lang = java:\n- * public final class DependencyUtil {\n- *\n- *     private DependencyUtil() {}\n- *\n- *     public static class Foo {\n- *          \/\/ ...\n- *      }\n- *\n- *     public static class Bar {\n- *         public Bar(Foo foo) {\n- *              \/\/ ...\n- *         }\n- *     }\n- *\n- *     private static final Supplier<Foo> FOO = StableValue.supplier(Foo::new);\n- *     private static final Supplier<Bar> BAR = StableValue.supplier(() -> new Bar(FOO.get()));\n- *\n- *     public static Foo foo() {\n- *         return FOO.get();\n- *     }\n- *\n- *     public static Bar bar() {\n- *         return BAR.get();\n- *     }\n- *\n- * }\n- *}\n- * Calling {@code bar()} will create the {@code Bar} singleton if it is not already\n- * created. Upon such a creation, the dependent {@code Foo} will first be created if\n- * the {@code Foo} does not already exist.\n- * <p>\n- * Another example, which has a more complex dependency graph, is to compute the\n- * Fibonacci sequence lazily:\n- * {@snippet lang = java:\n- * public final class Fibonacci {\n- *\n- *     private Fibonacci() {}\n- *\n- *     private static final int MAX_SIZE_INT = 46;\n- *\n- *     private static final IntFunction<Integer> FIB =\n- *         StableValue.intFunction(MAX_SIZE_INT, Fibonacci::fib);\n- *\n- *     public static int fib(int n) {\n- *         return n < 2\n- *                 ? n\n- *                 : FIB.apply(n - 1) + FIB.apply(n - 2);\n- *     }\n- *\n- * }\n- *}\n- * Both {@code FIB} and {@code Fibonacci::fib} recurse into each other. Because the\n- * stable int function {@code FIB} caches intermediate results, the initial\n- * computational complexity is reduced from exponential to linear compared to a\n- * traditional non-caching recursive fibonacci method. Once computed, the VM is free to\n- * constant-fold expressions like {@code Fibonacci.fib(5)}.\n- * <p>\n- * The fibonacci example above is a directed acyclic graph (i.e.,\n- * it has no circular dependencies and is therefore a dependency tree):\n- *{@snippet lang=text :\n- *\n- *              ___________fib(5)____________\n- *             \/                             \\\n- *       ____fib(4)____                  ____fib(3)____\n- *      \/              \\                \/              \\\n- *    fib(3)          fib(2)          fib(2)          fib(1)\n- *   \/     \\         \/     \\         \/     \\\n- * fib(2) fib(1)   fib(1) fib(0)   fib(1) fib(0)\n- *}\n- *\n- * If there are circular dependencies in a dependency graph, a stable value will\n- * eventually throw an {@linkplain IllegalStateException} upon referencing elements in\n- * a circularity.\n- *\n- * <h2 id=\"thread-safety\">Thread Safety<\/h2>\n- * The contents of a stable value is guaranteed to be set at most once. If competing\n- * threads are racing to set a stable value, only one update succeeds, while the other\n- * updates are blocked until the stable value is set, whereafter the other updates\n- * observes the stable value is set and leave the stable value unchanged.\n- * <p>\n- * The at-most-once write operation on a stable value that succeeds\n- * (e.g. {@linkplain #trySet(Object) trySet()})\n- * {@linkplain java.util.concurrent##MemoryVisibility <em>happens-before<\/em>}\n- * any successful read operation (e.g. {@linkplain #orElseThrow()}).\n- * A successful write operation can be either:\n- * <ul>\n- *     <li>a {@link #trySet(Object)} that returns {@code true},<\/li>\n- *     <li>a {@link #setOrThrow(Object)} that does not throw, or<\/li>\n- *     <li>an {@link #orElseSet(Supplier)} that successfully runs the supplier<\/li>\n- * <\/ul>\n- * A successful read operation can be either:\n- * <ul>\n- *     <li>a {@link #orElseThrow()} that does not throw,<\/li>\n- *     <li>a {@link #orElse(Object) orElse(other)} that does not return the {@code other} value<\/li>\n- *     <li>an {@link #orElseSet(Supplier)} that does not {@code throw}, or<\/li>\n- *     <li>an {@link #isSet()} that returns {@code true}<\/li>\n- * <\/ul>\n- * <p>\n- * The method {@link #orElseSet(Supplier)} guarantees that the provided\n- * {@linkplain Supplier} is invoked successfully at most once, even under race.\n- * Invocations of {@link #orElseSet(Supplier)} form a total order of zero or\n- * more exceptional invocations followed by zero (if the contents were already set) or one\n- * successful invocation. Since stable functions and stable collections are built on top\n- * of the same principles as {@linkplain StableValue#orElseSet(Supplier) orElseSet()} they\n- * too are thread safe and guarantee at-most-once-per-input invocation.\n- *\n- * <h2 id=\"performance\">Performance<\/h2>\n- * As the contents of a stable value can never change after it has been set, a JVM\n- * implementation may, for a set stable value, elide all future reads of that\n- * stable value, and instead directly use any contents that it has previously observed.\n- * This is true if the reference to the stable value is a constant (e.g. in cases where\n- * the stable value itself is stored in a {@code static final} field). Stable functions\n- * and collections are built on top of StableValue. As such, they might also be eligible\n- * for the same JVM optimizations as for StableValue.\n- *\n- * @implSpec Implementing classes of {@code StableValue} are free to synchronize on\n- *           {@code this} and consequently, it should be avoided to\n- *           (directly or indirectly) synchronize on a {@code StableValue}. Hence,\n- *           synchronizing on {@code this} may lead to deadlock.\n- *           <p>\n- *           Except for a {@code StableValue}'s contents itself,\n- *           an {@linkplain #orElse(Object) orElse(other)} parameter, and\n- *           an {@linkplain #equals(Object) equals(obj)} parameter; all\n- *           method parameters must be <em>non-null<\/em> or a {@link NullPointerException}\n- *           will be thrown.\n- *\n- * @implNote A {@code StableValue} is mainly intended to be a non-public field in\n- *           a class and is usually neither exposed directly via accessors nor passed as\n- *           a method parameter.\n- *           <p>\n- *           Stable functions and collections make reasonable efforts to provide\n- *           {@link Object#toString()} operations that do not trigger evaluation\n- *           of the internal stable values when called.\n- *           Stable collections have {@link Object#equals(Object)} operations that try\n- *           to minimize evaluation of the internal stable values when called.\n- *           <p>\n- *           As objects can be set via stable values but never removed, this can be a\n- *           source of unintended memory leaks. A stable value's contents are\n- *           {@linkplain java.lang.ref##reachability strongly reachable}.\n- *           Be advised that reachable stable values will hold their set contents until\n- *           the stable value itself is collected.\n- *           <p>\n- *           A {@code StableValue} that has a type parameter {@code T} that is an array\n- *           type (of arbitrary rank) will only allow the JVM to treat the\n- *           <em>array reference<\/em> as a stable value but <em>not its components<\/em>.\n- *           Instead, a {@linkplain #list(int, IntFunction) a stable list} of arbitrary\n- *           depth can be used, which provides stable components. More generally, a\n- *           stable value can hold other stable values of arbitrary depth and still\n- *           provide transitive constantness.\n- *           <p>\n- *           Stable values, functions, and collections are not {@link Serializable}.\n- *\n- * @param <T> type of the contents\n- *\n- * @since 25\n- *\/\n-@PreviewFeature(feature = PreviewFeature.Feature.STABLE_VALUES)\n-public sealed interface StableValue<T>\n-        permits StableValueImpl {\n-\n-    \/**\n-     * Tries to set the contents of this StableValue to the provided {@code contents}.\n-     * The contents of this StableValue can only be set once, implying this method only\n-     * returns {@code true} once.\n-     * <p>\n-     * When this method returns, the contents of this StableValue is always set.\n-     *\n-     * @return {@code true} if the contents of this StableValue was set to the\n-     *         provided {@code contents}, {@code false} otherwise\n-     * @param contents to set\n-     * @throws IllegalStateException if a supplier invoked by {@link #orElseSet(Supplier)}\n-     *         recursively attempts to set this stable value by calling this method\n-     *         directly or indirectly.\n-     *\/\n-    boolean trySet(T contents);\n-\n-    \/**\n-     * {@return the contents if set, otherwise, returns the provided {@code other} value}\n-     *\n-     * @param other to return if the contents is not set\n-     *\/\n-    T orElse(T other);\n-\n-    \/**\n-     * {@return the contents if set, otherwise, throws {@code NoSuchElementException}}\n-     *\n-     * @throws NoSuchElementException if no contents is set\n-     *\/\n-    T orElseThrow();\n-\n-    \/**\n-     * {@return {@code true} if the contents is set, {@code false} otherwise}\n-     *\/\n-    boolean isSet();\n-\n-    \/**\n-     * {@return the contents; if unset, first attempts to compute and set the\n-     *          contents using the provided {@code supplier}}\n-     * <p>\n-     * The provided {@code supplier} is guaranteed to be invoked at most once if it\n-     * completes without throwing an exception. If this method is invoked several times\n-     * with different suppliers, only one of them will be invoked provided it completes\n-     * without throwing an exception.\n-     * <p>\n-     * If the supplier throws an (unchecked) exception, the exception is rethrown and no\n-     * contents is set. The most common usage is to construct a new object serving\n-     * as a lazily computed value or memoized result, as in:\n-     *\n-     * {@snippet lang=java:\n-     * Value v = stable.orElseSet(Value::new);\n-     * }\n-     * <p>\n-     * When this method returns successfully, the contents is always set.\n-     * <p>\n-     * The provided {@code supplier} will only be invoked once even if invoked from\n-     * several threads unless the {@code supplier} throws an exception.\n-     *\n-     * @param  supplier to be used for computing the contents, if not previously set\n-     * @throws IllegalStateException if the provided {@code supplier} recursively\n-     *                               attempts to set this stable value.\n-     *\/\n-    T orElseSet(Supplier<? extends T> supplier);\n-\n-    \/**\n-     * Sets the contents of this StableValue to the provided {@code contents}, or, if\n-     * already set, throws {@code IllegalStateException}.\n-     * <p>\n-     * When this method returns (or throws an exception), the contents is always set.\n-     *\n-     * @param contents to set\n-     * @throws IllegalStateException if the contents was already set\n-     * @throws IllegalStateException if a supplier invoked by {@link #orElseSet(Supplier)}\n-     *         recursively attempts to set this stable value by calling this method\n-     *         directly or indirectly.\n-     *\/\n-    void setOrThrow(T contents);\n-\n-    \/\/ Object methods\n-\n-    \/**\n-     * {@return {@code true} if {@code this == obj}, {@code false} otherwise}\n-     *\n-     * @param obj to check for equality\n-     *\/\n-    boolean equals(Object obj);\n-\n-    \/**\n-     * {@return the {@linkplain System#identityHashCode(Object) identity hash code} of\n-     *          {@code this} object}\n-     *\/\n-    int hashCode();\n-\n-    \/\/ Factories\n-\n-    \/**\n-     * {@return a new unset stable value}\n-     * <p>\n-     * An unset stable value has no contents.\n-     *\n-     * @param <T> type of the contents\n-     *\/\n-    static <T> StableValue<T> of() {\n-        return StableValueImpl.of();\n-    }\n-\n-    \/**\n-     * {@return a new pre-set stable value with the provided {@code contents}}\n-     *\n-     * @param contents to set\n-     * @param <T>     type of the contents\n-     *\/\n-    static <T> StableValue<T> of(T contents) {\n-        final StableValue<T> stableValue = StableValue.of();\n-        stableValue.trySet(contents);\n-        return stableValue;\n-    }\n-\n-    \/**\n-     * {@return a new stable supplier}\n-     * <p>\n-     * The returned {@linkplain Supplier supplier} is a caching supplier that records\n-     * the value of the provided {@code underlying} supplier upon being first accessed via\n-     * the returned supplier's {@linkplain Supplier#get() get()} method.\n-     * <p>\n-     * The provided {@code underlying} supplier is guaranteed to be successfully invoked\n-     * at most once even in a multi-threaded environment. Competing threads invoking the\n-     * returned supplier's {@linkplain Supplier#get() get()} method when a value is\n-     * already under computation will block until a value is computed or an exception is\n-     * thrown by the computing thread. The competing threads will then observe the newly\n-     * computed value (if any) and will then never execute the {@code underlying} supplier.\n-     * <p>\n-     * If the provided {@code underlying} supplier throws an exception, it is rethrown\n-     * to the initial caller and no contents is recorded.\n-     * <p>\n-     * If the provided {@code underlying} supplier recursively calls the returned\n-     * supplier, an {@linkplain IllegalStateException} will be thrown.\n-     *\n-     * @param underlying supplier used to compute a cached value\n-     * @param <T>        the type of results supplied by the returned supplier\n-     *\/\n-    static <T> Supplier<T> supplier(Supplier<? extends T> underlying) {\n-        Objects.requireNonNull(underlying);\n-        return StableSupplier.of(underlying);\n-    }\n-\n-    \/**\n-     * {@return a new stable {@linkplain IntFunction}}\n-     * <p>\n-     * The returned function is a caching function that, for each allowed {@code int}\n-     * input, records the values of the provided {@code underlying}\n-     * function upon being first accessed via the returned function's\n-     * {@linkplain IntFunction#apply(int) apply()} method. If the returned function is\n-     * invoked with an input that is not in the range {@code [0, size)}, an\n-     * {@link IllegalArgumentException} will be thrown.\n-     * <p>\n-     * The provided {@code underlying} function is guaranteed to be successfully invoked\n-     * at most once per allowed input, even in a multi-threaded environment. Competing\n-     * threads invoking the returned function's\n-     * {@linkplain IntFunction#apply(int) apply()} method when a value is already under\n-     * computation will block until a value is computed or an exception is thrown by\n-     * the computing thread.\n-     * <p>\n-     * If invoking the provided {@code underlying} function throws an exception, it is\n-     * rethrown to the initial caller and no contents is recorded.\n-     * <p>\n-     * If the provided {@code underlying} function recursively calls the returned\n-     * function for the same input, an {@linkplain IllegalStateException} will\n-     * be thrown.\n-     *\n-     * @param size       the upper bound of the range {@code [0, size)} indicating\n-     *                   the allowed inputs\n-     * @param underlying {@code IntFunction} used to compute cached values\n-     * @param <R>        the type of results delivered by the returned IntFunction\n-     * @throws IllegalArgumentException if the provided {@code size} is negative.\n-     *\/\n-    static <R> IntFunction<R> intFunction(int size,\n-                                          IntFunction<? extends R> underlying) {\n-        StableUtil.assertSizeNonNegative(size);\n-        Objects.requireNonNull(underlying);\n-        return StableIntFunction.of(size, underlying);\n-    }\n-\n-    \/**\n-     * {@return a new stable {@linkplain Function}}\n-     * <p>\n-     * The returned function is a caching function that, for each allowed\n-     * input in the given set of {@code inputs}, records the values of the provided\n-     * {@code underlying} function upon being first accessed via the returned function's\n-     * {@linkplain Function#apply(Object) apply()} method. If the returned function is\n-     * invoked with an input that is not in {@code inputs}, an {@link IllegalArgumentException}\n-     * will be thrown.\n-     * <p>\n-     * The provided {@code underlying} function is guaranteed to be successfully invoked\n-     * at most once per allowed input, even in a multi-threaded environment. Competing\n-     * threads invoking the returned function's {@linkplain Function#apply(Object) apply()}\n-     * method when a value is already under computation will block until a value is\n-     * computed or an exception is thrown by the computing thread.\n-     * <p>\n-     * If invoking the provided {@code underlying} function throws an exception, it is\n-     * rethrown to the initial caller and no contents is recorded.\n-     * <p>\n-     * If the provided {@code underlying} function recursively calls the returned\n-     * function for the same input, an {@linkplain IllegalStateException} will\n-     * be thrown.\n-     *\n-     * @param inputs     the set of (non-null) allowed input values\n-     * @param underlying {@code Function} used to compute cached values\n-     * @param <T>        the type of the input to the returned Function\n-     * @param <R>        the type of results delivered by the returned Function\n-     * @throws NullPointerException if the provided set of {@code inputs} contains a\n-     *                              {@code null} element.\n-     *\/\n-    static <T, R> Function<T, R> function(Set<? extends T> inputs,\n-                                          Function<? super T, ? extends R> underlying) {\n-        Objects.requireNonNull(inputs);\n-        \/\/ Checking that the Set of inputs does not contain a `null` value is made in the\n-        \/\/ implementing classes.\n-        Objects.requireNonNull(underlying);\n-        return inputs instanceof EnumSet<?> && !inputs.isEmpty()\n-                ? StableEnumFunction.of(inputs, underlying)\n-                : StableFunction.of(inputs, underlying);\n-    }\n-\n-    \/**\n-     * {@return a new stable list with the provided {@code size}}\n-     * <p>\n-     * The returned list is an {@linkplain Collection##unmodifiable unmodifiable} list\n-     * with the provided {@code size}. The list's elements are computed via the\n-     * provided {@code mapper} when they are first accessed\n-     * (e.g. via {@linkplain List#get(int) List::get}).\n-     * <p>\n-     * The provided {@code mapper} function is guaranteed to be successfully invoked\n-     * at most once per list index, even in a multi-threaded environment. Competing\n-     * threads accessing an element already under computation will block until an element\n-     * is computed or an exception is thrown by the computing thread.\n-     * <p>\n-     * If invoking the provided {@code mapper} function throws an exception, it\n-     * is rethrown to the initial caller and no value for the element is recorded.\n-     * <p>\n-     * Any {@link List#subList(int, int) subList} or {@link List#reversed()} views\n-     * of the returned list are also stable.\n-     * <p>\n-     * The returned list and its {@link List#subList(int, int) subList} or\n-     * {@link List#reversed()} views implement the {@link RandomAccess} interface.\n-     * <p>\n-     * The returned list is unmodifiable and does not implement the\n-     * {@linkplain Collection##optional-operation optional operations} in the\n-     * {@linkplain List} interface.\n-     * <p>\n-     * If the provided {@code mapper} recursively calls the returned list for the\n-     * same index, an {@linkplain IllegalStateException} will be thrown.\n-     *\n-     * @param size   the size of the returned list\n-     * @param mapper to invoke whenever an element is first accessed\n-     *               (may return {@code null})\n-     * @param <E>    the type of elements in the returned list\n-     * @throws IllegalArgumentException if the provided {@code size} is negative.\n-     *\/\n-    static <E> List<E> list(int size,\n-                            IntFunction<? extends E> mapper) {\n-        StableUtil.assertSizeNonNegative(size);\n-        Objects.requireNonNull(mapper);\n-        return SharedSecrets.getJavaUtilCollectionAccess().stableList(size, mapper);\n-    }\n-\n-    \/**\n-     * {@return a new stable map with the provided {@code keys}}\n-     * <p>\n-     * The returned map is an {@linkplain Collection##unmodifiable unmodifiable} map whose\n-     * keys are known at construction. The map's values are computed via the provided\n-     * {@code mapper} when they are first accessed\n-     * (e.g. via {@linkplain Map#get(Object) Map::get}).\n-     * <p>\n-     * The provided {@code mapper} function is guaranteed to be successfully invoked\n-     * at most once per key, even in a multi-threaded environment. Competing\n-     * threads accessing a value already under computation will block until an element\n-     * is computed or an exception is thrown by the computing thread.\n-     * <p>\n-     * If invoking the provided {@code mapper} function throws an exception, it\n-     * is rethrown to the initial caller and no value associated with the provided key\n-     * is recorded.\n-     * <p>\n-     * Any {@link Map#values()} or {@link Map#entrySet()} views of the returned map are\n-     * also stable.\n-     * <p>\n-     * The returned map is unmodifiable and does not implement the\n-     * {@linkplain Collection##optional-operations optional operations} in the\n-     * {@linkplain Map} interface.\n-     * <p>\n-     * If the provided {@code mapper} recursively calls the returned map for\n-     * the same key, an {@linkplain IllegalStateException} will be thrown.\n-     *\n-     * @param keys   the (non-null) keys in the returned map\n-     * @param mapper to invoke whenever an associated value is first accessed\n-     *               (may return {@code null})\n-     * @param <K>    the type of keys maintained by the returned map\n-     * @param <V>    the type of mapped values in the returned map\n-     * @throws NullPointerException if the provided set of {@code inputs} contains a\n-     *                              {@code null} element.\n-     *\/\n-    static <K, V> Map<K, V> map(Set<K> keys,\n-                                Function<? super K, ? extends V> mapper) {\n-        Objects.requireNonNull(keys);\n-        \/\/ Checking that the Set of keys does not contain a `null` value is made in the\n-        \/\/ implementing class.\n-        Objects.requireNonNull(mapper);\n-        return SharedSecrets.getJavaUtilCollectionAccess().stableMap(keys, mapper);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":0,"deletions":756,"binary":false,"changes":756,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.misc.ThreadTracker;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -429,1 +427,1 @@\n-    private static final Supplier<List<CharsetProvider>> EXTENDED_PROVIDERS = StableValue.supplier(\n+    private static final LazyConstant<List<CharsetProvider>> EXTENDED_PROVIDERS = LazyConstant.of(\n@@ -620,1 +618,1 @@\n-    private static final Supplier<Charset> defaultCharset = StableValue.supplier(\n+    private static final LazyConstant<Charset> defaultCharset = LazyConstant.of(\n@@ -661,1 +659,1 @@\n-    private final Supplier<Set<String>> aliasSet = StableValue.supplier(\n+    private final LazyConstant<Set<String>> aliasSet = LazyConstant.of(\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -333,0 +334,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,2 +145,7 @@\n-    private static final Supplier<HashSet<Currency>> available =\n-            StableValue.supplier(Currency::computeAllCurrencies);\n+    private static final LazyConstant<HashSet<Currency>> available =\n+            LazyConstant.of(new Supplier<HashSet<Currency>>() {\n+                @Override\n+                public HashSet<Currency> get() {\n+                    return computeAllCurrencies();\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/util\/Currency.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.function.IntFunction;\n@@ -41,1 +40,0 @@\n-import java.util.function.Supplier;\n@@ -46,2 +44,0 @@\n-import jdk.internal.lang.stable.StableUtil;\n-import jdk.internal.lang.stable.StableValueImpl;\n@@ -49,2 +45,0 @@\n-import jdk.internal.util.ArraysSupport;\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -138,8 +132,0 @@\n-                public <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n-                    \/\/ A stable list is not Serializable, so we cannot return `List.of()` if `size == 0`\n-                    return new StableList<>(size, mapper);\n-                }\n-                public <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n-                    \/\/ A stable map is not Serializable, so we cannot return `Map.of()` if `keys.isEmpty()`\n-                    return new StableMap<>(keys, mapper);\n-                }\n@@ -454,1 +440,2 @@\n-            implements RandomAccess {\n+            implements RandomAccess\n+            permits LazyCollections.LazyList.LazySubList {\n@@ -465,2 +452,4 @@\n-        private SubList(AbstractImmutableList<E> root, int offset, int size) {\n-            assert root instanceof List12 || root instanceof ListN || root instanceof StableList;\n+        SubList(AbstractImmutableList<E> root, int offset, int size) {\n+            assert root instanceof List12\n+                    || root instanceof ListN\n+                    || root instanceof LazyCollections.LazyList;\n@@ -787,181 +776,0 @@\n-    @FunctionalInterface\n-    interface HasStableDelegates<E> {\n-        StableValueImpl<E>[] delegates();\n-    }\n-\n-    @jdk.internal.ValueBased\n-    static final class StableList<E>\n-            extends AbstractImmutableList<E>\n-            implements HasStableDelegates<E> {\n-\n-        @Stable\n-        private final IntFunction<? extends E> mapper;\n-        @Stable\n-        final StableValueImpl<E>[] delegates;\n-\n-        StableList(int size, IntFunction<? extends E> mapper) {\n-            this.mapper = mapper;\n-            this.delegates = StableUtil.array(size);\n-        }\n-\n-        @Override public boolean  isEmpty() { return delegates.length == 0;}\n-        @Override public int      size() { return delegates.length; }\n-        @Override public Object[] toArray() { return copyInto(new Object[size()]); }\n-\n-        @ForceInline\n-        @Override\n-        public E get(int i) {\n-            final StableValueImpl<E> delegate;\n-            try {\n-                delegate = delegates[i];\n-            } catch (ArrayIndexOutOfBoundsException aioobe) {\n-                throw new IndexOutOfBoundsException(i);\n-            }\n-            return delegate.orElseSet(new Supplier<E>() {\n-                        @Override  public E get() { return mapper.apply(i); }});\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public <T> T[] toArray(T[] a) {\n-            final int size = delegates.length;\n-            if (a.length < size) {\n-                \/\/ Make a new array of a's runtime type, but my contents:\n-                T[] n = (T[])Array.newInstance(a.getClass().getComponentType(), size);\n-                return copyInto(n);\n-            }\n-            copyInto(a);\n-            if (a.length > size) {\n-                a[size] = null; \/\/ null-terminate\n-            }\n-            return a;\n-        }\n-\n-        @Override\n-        public int indexOf(Object o) {\n-            final int size = size();\n-            for (int i = 0; i < size; i++) {\n-                if (Objects.equals(o, get(i))) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public int lastIndexOf(Object o) {\n-            for (int i = size() - 1; i >= 0; i--) {\n-                if (Objects.equals(o, get(i))) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private <T> T[] copyInto(Object[] a) {\n-            final int len = delegates.length;\n-            for (int i = 0; i < len; i++) {\n-                a[i] = get(i);\n-            }\n-            return (T[]) a;\n-        }\n-\n-        @Override\n-        public List<E> reversed() {\n-            return new StableReverseOrderListView<>(this);\n-        }\n-\n-        @Override\n-        public List<E> subList(int fromIndex, int toIndex) {\n-            subListRangeCheck(fromIndex, toIndex, size());\n-            return StableSubList.fromStableList(this, fromIndex, toIndex);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return StableUtil.renderElements(this, \"StableCollection\", delegates);\n-        }\n-\n-        @Override\n-        public StableValueImpl<E>[] delegates() {\n-            return delegates;\n-        }\n-\n-        private static final class StableSubList<E> extends SubList<E>\n-                implements HasStableDelegates<E> {\n-\n-            private StableSubList(AbstractImmutableList<E> root, int offset, int size) {\n-                super(root, offset, size);\n-            }\n-\n-            @Override\n-            public List<E> reversed() {\n-                return new StableReverseOrderListView<>(this);\n-            }\n-\n-            @Override\n-            public List<E> subList(int fromIndex, int toIndex) {\n-                subListRangeCheck(fromIndex, toIndex, size());\n-                return StableSubList.fromStableSubList(this, fromIndex, toIndex);\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return StableUtil.renderElements(this, \"StableCollection\", delegates());\n-            }\n-\n-            @Override\n-            boolean allowNulls() {\n-                return true;\n-            }\n-\n-            @Override\n-            public StableValueImpl<E>[] delegates() {\n-                @SuppressWarnings(\"unchecked\")\n-                final var rootDelegates = ((HasStableDelegates<E>) root).delegates();\n-                return Arrays.copyOfRange(rootDelegates, offset, offset + size);\n-            }\n-\n-            static <E> SubList<E> fromStableList(StableList<E> list, int fromIndex, int toIndex) {\n-                return new StableSubList<>(list, fromIndex, toIndex - fromIndex);\n-            }\n-\n-            static <E> SubList<E> fromStableSubList(StableSubList<E> parent, int fromIndex, int toIndex) {\n-                return new StableSubList<>(parent.root, parent.offset + fromIndex, toIndex - fromIndex);\n-            }\n-\n-        }\n-\n-        private static final class StableReverseOrderListView<E>\n-                extends ReverseOrderListView.Rand<E>\n-                implements HasStableDelegates<E> {\n-\n-            private StableReverseOrderListView(List<E> base) {\n-                super(base, false);\n-            }\n-\n-            \/\/ This method does not evaluate the elements\n-            @Override\n-            public String toString() {\n-                return StableUtil.renderElements(this, \"StableCollection\", delegates());\n-            }\n-\n-            @Override\n-            public List<E> subList(int fromIndex, int toIndex) {\n-                final int size = base.size();\n-                subListRangeCheck(fromIndex, toIndex, size);\n-                return new StableReverseOrderListView<>(base.subList(size - toIndex, size - fromIndex));\n-            }\n-\n-            @Override\n-            public StableValueImpl<E>[] delegates() {\n-                @SuppressWarnings(\"unchecked\")\n-                final var baseDelegates = ((HasStableDelegates<E>) base).delegates();\n-                return ArraysSupport.reverse(\n-                        Arrays.copyOf(baseDelegates, baseDelegates.length));\n-            }\n-        }\n-\n-    }\n-\n@@ -1606,181 +1414,0 @@\n-    static final class StableMap<K, V>\n-            extends AbstractImmutableMap<K, V> {\n-\n-        @Stable\n-        private final Function<? super K, ? extends V> mapper;\n-        @Stable\n-        private final Map<K, StableValueImpl<V>> delegate;\n-\n-        StableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n-            this.mapper = mapper;\n-            this.delegate = StableUtil.map(keys);\n-        }\n-\n-        @Override public boolean              containsKey(Object o) { return delegate.containsKey(o); }\n-        @Override public int                  size() { return delegate.size(); }\n-        @Override public Set<Map.Entry<K, V>> entrySet() { return StableMapEntrySet.of(this); }\n-\n-        @ForceInline\n-        @Override\n-        public V get(Object key) {\n-            return getOrDefault(key, null);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public V getOrDefault(Object key, V defaultValue) {\n-            final StableValueImpl<V> stable = delegate.get(key);\n-            if (stable == null) {\n-                return defaultValue;\n-            }\n-            @SuppressWarnings(\"unchecked\")\n-            final K k = (K) key;\n-            return stable.orElseSet(new Supplier<V>() {\n-                @Override public V get() { return mapper.apply(k); }});\n-        }\n-\n-        @jdk.internal.ValueBased\n-        static final class StableMapEntrySet<K, V> extends AbstractImmutableSet<Map.Entry<K, V>> {\n-\n-            \/\/ Use a separate field for the outer class in order to facilitate\n-            \/\/ a @Stable annotation.\n-            @Stable\n-            private final StableMap<K, V> outer;\n-\n-            @Stable\n-            private final Set<Map.Entry<K, StableValueImpl<V>>> delegateEntrySet;\n-\n-            private StableMapEntrySet(StableMap<K, V> outer) {\n-                this.outer = outer;\n-                this.delegateEntrySet = outer.delegate.entrySet();\n-            }\n-\n-            @Override public Iterator<Map.Entry<K, V>> iterator() { return LazyMapIterator.of(this); }\n-            @Override public int                       size() { return delegateEntrySet.size(); }\n-            @Override public int                       hashCode() { return outer.hashCode(); }\n-\n-            @Override\n-            public String toString() {\n-                return StableUtil.renderMappings(this, \"StableCollection\", delegateEntrySet, false);\n-            }\n-\n-            \/\/ For @ValueBased\n-            private static <K, V> StableMapEntrySet<K, V> of(StableMap<K, V> outer) {\n-                return new StableMapEntrySet<>(outer);\n-            }\n-\n-            @jdk.internal.ValueBased\n-            static final class LazyMapIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n-\n-                \/\/ Use a separate field for the outer class in order to facilitate\n-                \/\/ a @Stable annotation.\n-                @Stable\n-                private final StableMapEntrySet<K, V> outer;\n-\n-                @Stable\n-                private final Iterator<Map.Entry<K, StableValueImpl<V>>> delegateIterator;\n-\n-                private LazyMapIterator(StableMapEntrySet<K, V> outer) {\n-                    this.outer = outer;\n-                    this.delegateIterator = outer.delegateEntrySet.iterator();\n-                }\n-\n-                @Override public boolean hasNext() { return delegateIterator.hasNext(); }\n-\n-                @Override\n-                public Entry<K, V> next() {\n-                    final Map.Entry<K, StableValueImpl<V>> inner = delegateIterator.next();\n-                    final K k = inner.getKey();\n-                    return new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n-                        @Override public V get() { return outer.outer.mapper.apply(k); }});\n-                }\n-\n-                @Override\n-                public void forEachRemaining(Consumer<? super Map.Entry<K, V>> action) {\n-                    final Consumer<? super Map.Entry<K, StableValueImpl<V>>> innerAction =\n-                            new Consumer<>() {\n-                                @Override\n-                                public void accept(Entry<K, StableValueImpl<V>> inner) {\n-                                    final K k = inner.getKey();\n-                                    action.accept(new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n-                                        @Override public V get() { return outer.outer.mapper.apply(k); }}));\n-                                }\n-                            };\n-                    delegateIterator.forEachRemaining(innerAction);\n-                }\n-\n-                \/\/ For @ValueBased\n-                private static  <K, V> LazyMapIterator<K, V> of(StableMapEntrySet<K, V> outer) {\n-                    return new LazyMapIterator<>(outer);\n-                }\n-\n-            }\n-        }\n-\n-        private record StableEntry<K, V>(K getKey, \/\/ trick\n-                                         StableValueImpl<V> stableValue,\n-                                         Supplier<? extends V> supplier) implements Map.Entry<K, V> {\n-\n-            @Override public V setValue(V value) { throw uoe(); }\n-            @Override public V getValue() { return stableValue.orElseSet(supplier); }\n-            @Override public int hashCode() { return hash(getKey()) ^ hash(getValue()); }\n-            @Override public String toString() { return getKey() + \"=\" + stableValue.toString(); }\n-            @Override public boolean equals(Object o) {\n-                return o instanceof Map.Entry<?, ?> e\n-                        && Objects.equals(getKey(), e.getKey())\n-                        \/\/ Invoke `getValue()` as late as possible to avoid evaluation\n-                        && Objects.equals(getValue(), e.getValue());\n-            }\n-\n-            private int hash(Object obj) { return (obj == null) ? 0 : obj.hashCode(); }\n-        }\n-\n-        @Override\n-        public Collection<V> values() {\n-            return StableMapValues.of(this);\n-        }\n-\n-        @jdk.internal.ValueBased\n-        static final class StableMapValues<V> extends AbstractImmutableCollection<V> {\n-\n-            \/\/ Use a separate field for the outer class in order to facilitate\n-            \/\/ a @Stable annotation.\n-            @Stable\n-            private final StableMap<?, V> outer;\n-\n-            private StableMapValues(StableMap<?, V> outer) {\n-                this.outer = outer;\n-            }\n-\n-            @Override public Iterator<V> iterator() { return outer.new ValueIterator(); }\n-            @Override public int size() { return outer.size(); }\n-            @Override public boolean isEmpty() { return outer.isEmpty();}\n-            @Override public boolean contains(Object v) { return outer.containsValue(v); }\n-\n-            private static final IntFunction<StableValueImpl<?>[]> GENERATOR = new IntFunction<StableValueImpl<?>[]>() {\n-                @Override\n-                public StableValueImpl<?>[] apply(int len) {\n-                    return new StableValueImpl<?>[len];\n-                }\n-            };\n-\n-            @Override\n-            public String toString() {\n-                final StableValueImpl<?>[] values = outer.delegate.values().toArray(GENERATOR);\n-                return StableUtil.renderElements(this, \"StableCollection\", values);\n-            }\n-\n-            \/\/ For @ValueBased\n-            private static <V> StableMapValues<V> of(StableMap<?, V> outer) {\n-                return new StableMapValues<>(outer);\n-            }\n-\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return StableUtil.renderMappings(this, \"StableMap\", delegate.entrySet(), true);\n-        }\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":6,"deletions":379,"binary":false,"changes":385,"status":"modified"},{"patch":"@@ -0,0 +1,822 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import jdk.internal.lang.LazyConstantImpl;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.ImmutableBitSetPredicate;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.LazyConstant;\n+import java.lang.reflect.Array;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntPredicate;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Container class for lazy collections implementations. Not part of the public API.\n+ *\/\n+final class LazyCollections {\n+\n+    \/**\n+     * No instances.\n+     *\/\n+    private LazyCollections() { }\n+\n+    \/\/ Unsafe allows LazyCollection classes to be used early in the boot sequence\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @jdk.internal.ValueBased\n+    static final class LazyList<E>\n+            extends ImmutableCollections.AbstractImmutableList<E>\n+            implements LenientList<E>, ElementBackedList<E> {\n+\n+        @Stable\n+        private final E[] elements;\n+        \/\/ Keeping track of `size` separately reduces bytecode size compared to\n+        \/\/ using `elements.length`.\n+        @Stable\n+        private final int size;\n+        @Stable\n+        final FunctionHolder<IntFunction<? extends E>> functionHolder;\n+        @Stable\n+        private final Mutexes mutexes;\n+\n+        private LazyList(int size, IntFunction<? extends E> computingFunction) {\n+            this.elements = newGenericArray(size);\n+            this.size = size;\n+            this.functionHolder = new FunctionHolder<>(computingFunction, size);\n+            this.mutexes = new Mutexes(size);\n+            super();\n+        }\n+\n+        @Override public boolean  isEmpty() { return size == 0; }\n+        @Override public int      size() { return size; }\n+        @Override public Object[] toArray() { return copyInto(new Object[size]); }\n+\n+        @ForceInline\n+        @Override\n+        public E get(int i) {\n+            final E e = contentsAcquire(offsetFor(Objects.checkIndex(i, size)));\n+            return (e != null) ? e : getSlowPath(i);\n+        }\n+\n+        private E getSlowPath(int i) {\n+            return orElseComputeSlowPath(elements, i, mutexes.acquireMutex(offsetFor(i)), i, functionHolder);\n+        }\n+\n+        @Override\n+        public E getAcquire(int i) {\n+            Objects.checkIndex(i, size);\n+            final long offset = offsetFor(i);\n+            return contentsAcquire(offset);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            if (a.length < size) {\n+                \/\/ Make a new array of a's runtime type, but my contents:\n+                T[] n = (T[]) Array.newInstance(a.getClass().getComponentType(), size);\n+                return copyInto(n);\n+            }\n+            copyInto(a);\n+            if (a.length > size) {\n+                a[size] = null; \/\/ null-terminate\n+            }\n+            return a;\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            for (int i = 0; i < size; i++) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            for (int i = size - 1; i >= 0; i--) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private <T> T[] copyInto(Object[] a) {\n+            for (int i = 0; i < size; i++) {\n+                a[i] = get(i);\n+            }\n+            return (T[]) a;\n+        }\n+\n+        @Override\n+        public List<E> reversed() {\n+            return new ReverseOrderLazyListView<>(this);\n+        }\n+\n+        @Override\n+        public List<E> subList(int fromIndex, int toIndex) {\n+            subListRangeCheck(fromIndex, toIndex, size());\n+            return LazySubList.fromLazyList(this, fromIndex, toIndex);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return renderElements(this);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public E[] elements() {\n+            return elements;\n+        }\n+\n+        @Override\n+        public Mutexes mutexes() {\n+            return mutexes;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @ForceInline\n+        private E contentsAcquire(long offset) {\n+            return (E) UNSAFE.getReferenceAcquire(elements, offset);\n+        }\n+\n+        \/\/ @ValueBased cannot be used here as ImmutableCollections.SubList declares fields\n+        static final class LazySubList<E> extends ImmutableCollections.SubList<E>\n+                implements LenientList<E> {\n+\n+            private LazySubList(ImmutableCollections.AbstractImmutableList<E> root, int offset, int size) {\n+                super(root, offset, size);\n+            }\n+\n+            @Override\n+            public List<E> reversed() {\n+                return new ReverseOrderLazyListView<>(this);\n+            }\n+\n+            @Override\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                subListRangeCheck(fromIndex, toIndex, size());\n+                return LazySubList.fromLazySubList(this, fromIndex, toIndex);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return renderElements(this);\n+            }\n+\n+            @Override\n+            boolean allowNulls() {\n+                return false;\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public E getAcquire(int index) {\n+                Objects.checkIndex(index, size);\n+                return ((LenientList<E>) root).getAcquire(offset + index);\n+            }\n+\n+            static <E> ImmutableCollections.SubList<E> fromLazyList(LazyList<E> list, int fromIndex, int toIndex) {\n+                return new LazySubList<>(list, fromIndex, toIndex - fromIndex);\n+            }\n+\n+            static <E> ImmutableCollections.SubList<E> fromLazySubList(LazySubList<E> parent, int fromIndex, int toIndex) {\n+                return new LazySubList<>(parent.root, parent.offset + fromIndex, toIndex - fromIndex);\n+            }\n+\n+        }\n+\n+        private static final class ReverseOrderLazyListView<E>\n+                extends ReverseOrderListView.Rand<E>\n+                implements LenientList<E> {\n+\n+            private ReverseOrderLazyListView(List<E> base) {\n+                super(base, false);\n+            }\n+\n+            \/\/ This method does not evaluate the elements\n+            @Override\n+            public String toString() {\n+                return renderElements(this);\n+            }\n+\n+            @Override\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                final int size = base.size();\n+                subListRangeCheck(fromIndex, toIndex, size);\n+                return new ReverseOrderLazyListView<>(base.subList(size - toIndex, size - fromIndex));\n+            }\n+\n+            @Override\n+            public E getAcquire(int i) {\n+                final int size = base.size();\n+                Objects.checkIndex(i, size);\n+                return ((LenientList<E>) base).getAcquire(size - i - 1);\n+            }\n+        }\n+\n+    }\n+\n+    interface LenientList<E> extends List<E> {\n+        \/**\n+         * {@return the element at index {@code i} without evaluating it}\n+         * @param i index\n+         *\/\n+        E getAcquire(int i);\n+    }\n+\n+    static final class LazyEnumMap<K extends Enum<K>, V>\n+            extends AbstractLazyMap<K, V> {\n+\n+        @Stable\n+        private final Class<K> enumType;\n+        @Stable\n+        \/\/ We are using a wrapper class here to be able to use a min value of zero that\n+        \/\/ is also stable.\n+        private final Integer min;\n+        @Stable\n+        private final IntPredicate member;\n+\n+        public LazyEnumMap(Set<K> set,\n+                           Class<K> enumType,\n+                           int min,\n+                           int backingSize,\n+                           IntPredicate member,\n+                           Function<? super K, ? extends V> computingFunction) {\n+            this.enumType = enumType;\n+            this.min = min;\n+            this.member = member;\n+            super(set, set.size(), backingSize, computingFunction);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean containsKey(Object o) {\n+            return enumType.isAssignableFrom(o.getClass())\n+                    && member.test(((Enum<?>) o).ordinal());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public V getOrDefault(Object key, V defaultValue) {\n+            if (enumType.isAssignableFrom(key.getClass())) {\n+                final int ordinal = ((Enum<?>) key).ordinal();\n+                if (member.test(ordinal)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final K k = (K) key;\n+                    return orElseCompute(k, indexForAsInt(k));\n+                }\n+            }\n+            return defaultValue;\n+        }\n+\n+        @Override\n+        Integer indexFor(K key) {\n+            return indexForAsInt(key);\n+        }\n+\n+        private int indexForAsInt(K key) {\n+            return key.ordinal() - min;\n+        }\n+\n+    }\n+\n+    static final class LazyMap<K, V>\n+            extends AbstractLazyMap<K, V> {\n+\n+        @Stable\n+        private final Map<K, Integer> indexMapper;\n+\n+        public LazyMap(Set<K> keys, Function<? super K, ? extends V> computingFunction) {\n+            @SuppressWarnings(\"unchecked\")\n+            final Entry<K, Integer>[] entries = (Entry<K, Integer>[]) new Entry<?, ?>[keys.size()];\n+            int i = 0;\n+            for (K k : keys) {\n+                entries[i] = Map.entry(k, i++);\n+            }\n+            this.indexMapper = Map.ofEntries(entries);\n+            super(keys, i, i, computingFunction);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public V getOrDefault(Object key, V defaultValue) {\n+            final Integer index = indexMapper.get(key);\n+            if (index != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                final K k = (K) key;\n+                return orElseCompute(k, index);\n+            }\n+            return defaultValue;\n+        }\n+\n+        @Override public boolean containsKey(Object o) { return indexMapper.containsKey(o); }\n+\n+        @Override\n+        Integer indexFor(K key) {\n+            return indexMapper.get(key);\n+        }\n+    }\n+\n+    static sealed abstract class AbstractLazyMap<K, V>\n+            extends ImmutableCollections.AbstractImmutableMap<K, V> {\n+\n+        @Stable\n+        final V[] values;\n+        @Stable\n+        Mutexes mutexes;\n+        @Stable\n+        private final int size;\n+        @Stable\n+        final FunctionHolder<Function<? super K, ? extends V>> functionHolder;\n+        @Stable\n+        private final Set<Entry<K, V>> entrySet;\n+\n+        private AbstractLazyMap(Set<K> keySet,\n+                                int size,\n+                                int backingSize,\n+                                Function<? super K, ? extends V> computingFunction) {\n+            this.size = size;\n+            this.functionHolder = new FunctionHolder<>(computingFunction, size);\n+            this.values = newGenericArray(backingSize);\n+            this.mutexes = new Mutexes(backingSize);\n+            super();\n+            this.keySet = keySet;\n+            this.entrySet = LazyMapEntrySet.of(this);\n+        }\n+\n+        \/\/ Abstract methods\n+        @Override public abstract boolean containsKey(Object o);\n+        abstract Integer indexFor(K key);\n+\n+        \/\/ Public methods\n+        @Override public final int              size() { return size; }\n+        @Override public final boolean          isEmpty() { return size == 0; }\n+        @Override public final Set<Entry<K, V>> entrySet() { return entrySet; }\n+        @Override public Set<K>                 keySet() { return keySet; }\n+\n+        @ForceInline\n+        @Override\n+        public final V get(Object key) {\n+            return getOrDefault(key, null);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @ForceInline\n+        final V orElseCompute(K key, int index) {\n+            final long offset = offsetFor(index);\n+            final V v = (V) UNSAFE.getReferenceAcquire(values, offset);\n+            if (v != null) {\n+                return v;\n+            }\n+            final Object mutex = mutexes.acquireMutex(offset);\n+            return orElseComputeSlowPath(values, index, mutex, key, functionHolder);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final V getAcquire(K key) {\n+            return (V) UNSAFE.getReferenceAcquire(values, offsetFor(indexFor(key)));\n+        }\n+\n+        @jdk.internal.ValueBased\n+        static final class LazyMapEntrySet<K, V> extends ImmutableCollections.AbstractImmutableSet<Entry<K, V>> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final AbstractLazyMap<K, V> map;\n+\n+            private LazyMapEntrySet(AbstractLazyMap<K, V> map) {\n+                this.map = map;\n+                super();\n+            }\n+\n+            @Override public Iterator<Entry<K, V>> iterator() { return LazyMapIterator.of(map); }\n+            @Override public int                   size() { return map.size(); }\n+            @Override public int                   hashCode() { return map.hashCode(); }\n+\n+            @Override\n+            public String toString() {\n+                return renderMappings(map, \"Collection\", false);\n+            }\n+\n+            \/\/ For @ValueBased\n+            private static <K, V> LazyMapEntrySet<K, V> of(AbstractLazyMap<K, V> outer) {\n+                return new LazyMapEntrySet<>(outer);\n+            }\n+\n+            @jdk.internal.ValueBased\n+            static final class LazyMapIterator<K, V> implements Iterator<Entry<K, V>> {\n+\n+                \/\/ Use a separate field for the outer class in order to facilitate\n+                \/\/ a @Stable annotation.\n+                @Stable\n+                private final AbstractLazyMap<K, V> map;\n+                @Stable\n+                private final Iterator<K> keyIterator;\n+\n+                private LazyMapIterator(AbstractLazyMap<K, V> map) {\n+                    this.map = map;\n+                    this.keyIterator = map.keySet.iterator();\n+                    super();\n+                }\n+\n+                @Override  public boolean hasNext() { return keyIterator.hasNext(); }\n+\n+                @Override\n+                public Entry<K, V> next() {\n+                    final K k = keyIterator.next();\n+                    return new LazyEntry<>(k, map, map.functionHolder);\n+                }\n+\n+                @Override\n+                public void forEachRemaining(Consumer<? super Entry<K, V>> action) {\n+                    final Consumer<? super K> innerAction =\n+                            new Consumer<>() {\n+                                @Override\n+                                public void accept(K key) {\n+                                    action.accept(new LazyEntry<>(key, map, map.functionHolder));\n+                                }\n+                            };\n+                    keyIterator.forEachRemaining(innerAction);\n+                }\n+\n+                \/\/ For @ValueBased\n+                private static <K, V> LazyMapIterator<K, V> of(AbstractLazyMap<K, V> map) {\n+                    return new LazyMapIterator<>(map);\n+                }\n+\n+            }\n+        }\n+\n+        private record LazyEntry<K, V>(K getKey, \/\/ trick\n+                                       AbstractLazyMap<K, V> map,\n+                                       FunctionHolder<Function<? super K, ? extends V>> functionHolder) implements Entry<K, V> {\n+\n+            @Override public V      setValue(V value) { throw ImmutableCollections.uoe(); }\n+            @Override public V      getValue() {\n+                final int index = map.indexFor(getKey);\n+                final V v = map.getAcquire(getKey);\n+                return v != null\n+                        ? v\n+                        : orElseComputeSlowPath(map.values, index, map.mutexes.acquireMutex(offsetFor(index)), getKey, functionHolder);\n+            }\n+            @Override public int    hashCode() { return hash(getKey()) ^ hash(getValue()); }\n+            @Override public String toString() { return getKey() + \"=\" + LazyConstantImpl.renderConstant(map.getAcquire(getKey)); }\n+\n+            @Override\n+            public boolean equals(Object o) {\n+                return o instanceof Map.Entry<?, ?> e\n+                        && Objects.equals(getKey(), e.getKey())\n+                        \/\/ Invoke `getValue()` as late as possible to avoid evaluation\n+                        && Objects.equals(getValue(), e.getValue());\n+            }\n+\n+            private int hash(Object obj) {\n+                return (obj == null) ? 0 : obj.hashCode();\n+            }\n+        }\n+\n+        @Override\n+        public Collection<V> values() {\n+            return LazyMapValues.of(this);\n+        }\n+\n+        @jdk.internal.ValueBased\n+        static final class LazyMapValues<K, V> extends ImmutableCollections.AbstractImmutableCollection<V> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final AbstractLazyMap<K, V> map;\n+\n+            private LazyMapValues(AbstractLazyMap<K, V> map) {\n+                this.map = map;\n+                super();\n+            }\n+\n+            @Override public Iterator<V> iterator() { return map.new ValueIterator(); }\n+            @Override public int         size() { return map.size(); }\n+            @Override public boolean     isEmpty() { return map.isEmpty(); }\n+            @Override public boolean     contains(Object v) { return map.containsValue(v); }\n+\n+            @Override\n+            public String toString() {\n+                final StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n+                for (var k : map.keySet()) {\n+                    final Object value = map.getAcquire(k);\n+                    final String valueString;\n+                    if (value == map) {\n+                        valueString = \"(this Collection)\";\n+                    } else {\n+                        valueString = LazyConstantImpl.renderConstant(value);\n+                    }\n+                    sj.add(valueString);\n+                }\n+                return sj.toString();\n+            }\n+\n+            \/\/ For @ValueBased\n+            private static <K, V> LazyMapValues<K, V> of(AbstractLazyMap<K, V> outer) {\n+                return new LazyMapValues<>(outer);\n+            }\n+\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return renderMappings(this, \"Map\", true);\n+        }\n+\n+    }\n+\n+    interface ElementBackedList<E> {\n+\n+        E[] elements();\n+\n+        Mutexes mutexes();\n+\n+    }\n+\n+    static final class Mutexes {\n+\n+        static final Object TOMB_STONE = new Mutexes.MutexObject(-1, Thread.currentThread().threadId());\n+\n+        \/\/ Filled on demand and then discarded once it is not needed anymore.\n+        \/\/ A mutex element can only transition like so: `null` -> `new Object()` -> `TOMB_STONE`\n+        private volatile Object[] mutexes;\n+        \/\/ Used to detect we have computed all elements and no longer need the `mutexes` array\n+        private volatile AtomicInteger counter;\n+\n+        private Mutexes(int length) {\n+            this.mutexes = new Object[length];\n+            this.counter = new AtomicInteger(length);\n+        }\n+\n+        @ForceInline\n+        private Object acquireMutex(long offset) {\n+            assert mutexes != null;\n+            \/\/ Check if there already is a mutex (Object or TOMB_STONE)\n+            final Object mutex = UNSAFE.getReferenceVolatile(mutexes, offset);\n+            if (mutex != null) {\n+                return mutex;\n+            }\n+            \/\/ Protect against racy stores of mutexe candidates\n+            final Object candidate = new Mutexes.MutexObject(offset, Thread.currentThread().threadId());\n+            final Object witness = UNSAFE.compareAndExchangeReference(mutexes, offset, null, candidate);\n+            check(witness, offset);\n+            return witness == null ? candidate : witness;\n+        }\n+\n+        @ForceInline\n+        private void disposeOfMutex(long offset) {\n+            UNSAFE.putReferenceVolatile(mutexes, offset, TOMB_STONE);\n+            \/\/ Todo: the null check is redundant as this method is invoked at most\n+            \/\/       `size()` times.\n+            if (counter != null && counter.decrementAndGet() == 0) {\n+                \/\/ We don't need these anymore\n+                counter = null;\n+                mutexes = null;\n+            }\n+        }\n+\n+\n+        \/\/ Todo: remove this after stabilization\n+        private Object check(Object mutex, long realOffset) {\n+            if (mutex == null || mutex == TOMB_STONE) {\n+                return mutex;\n+            }\n+            assert (mutex instanceof Mutexes.MutexObject(\n+                    long offset, long _\n+            )) && offset == realOffset :\n+                    mutex +\n+                            \", realOffset = \" + realOffset +\n+                            \", realThread = \" + Thread.currentThread().threadId();\n+            return mutex;\n+        }\n+\n+        \/\/ Todo: remove this after stabilization\n+        record MutexObject(long offset, long tid) { }\n+\n+    }\n+\n+    public static <E> int indexOf(List<LazyConstant<E>> list, Object o) {\n+        Objects.requireNonNull(o);\n+        if (o instanceof LazyConstant<?> s) {\n+            final int size = list.size();\n+            for (int i = 0; i < size; i++) {\n+                if (Objects.equals(s, list.get(i))) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static <E> int lastIndexOf(List<LazyConstant<E>> list, Object o) {\n+        Objects.requireNonNull(o);\n+        if (o instanceof LazyConstant<?> s) {\n+            for (int i = list.size() - 1; i >= 0; i--) {\n+                if (Objects.equals(s, list.get(i))) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @ForceInline\n+    private static long offsetFor(long index) {\n+        return Unsafe.ARRAY_OBJECT_BASE_OFFSET + Unsafe.ARRAY_OBJECT_INDEX_SCALE * index;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E> E[] newGenericArray(int length) {\n+        return (E[]) new Object[length];\n+    }\n+\n+    public static String renderElements(LenientList<?> self) {\n+        final StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n+        for (int i = 0; i < self.size(); i++) {\n+            final Object e = self.getAcquire(i);\n+            if (e == self) {\n+                sj.add(\"(this Collection)\");\n+            } else {\n+                sj.add(LazyConstantImpl.renderConstant(e));\n+            }\n+        }\n+        return sj.toString();\n+    }\n+\n+    public static <E> List<E> ofLazyList(int size,\n+                                         IntFunction<? extends E> computingFunction) {\n+        return new LazyList<>(size, computingFunction);\n+    }\n+\n+    public static <K, V> Map<K, V> ofLazyMap(Set<K> keys,\n+                                             Function<? super K, ? extends V> computingFunction) {\n+        return new LazyMap<>(keys, computingFunction);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, E extends Enum<E>, V>\n+    Map<K, V> ofLazyMapWithEnumKeys(Set<K> keys,\n+                                    Function<? super K, ? extends V> computingFunction) {\n+        \/\/ The input set is not empty\n+        final Class<E> enumType = ((E) keys.iterator().next()).getDeclaringClass();\n+        final BitSet bitSet = new BitSet(enumType.getEnumConstants().length);\n+        int min = Integer.MAX_VALUE;\n+        int max = Integer.MIN_VALUE;\n+        for (K t : keys) {\n+            final int ordinal = ((E) t).ordinal();\n+            min = Math.min(min, ordinal);\n+            max = Math.max(max, ordinal);\n+            bitSet.set(ordinal);\n+        }\n+        final int backingSize = max - min + 1;\n+        final IntPredicate member = ImmutableBitSetPredicate.of(bitSet);\n+        return (Map<K, V>) new LazyEnumMap<>((Set<E>) keys, enumType, min, backingSize, member, (Function<E, V>) computingFunction);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T orElseComputeSlowPath(final T[] array,\n+                                       final int index,\n+                                       final Object mutex,\n+                                       final Object input,\n+                                       final FunctionHolder<?> functionHolder) {\n+        preventReentry(mutex);\n+        synchronized (mutex) {\n+            final T t = array[index];  \/\/ Plain semantics suffice here\n+            if (t == null) {\n+                final T newValue;\n+                if (functionHolder == null) {\n+                    \/\/ If there is no functionHolder, the input must be a\n+                    \/\/ `Supplier` because we were called from `.orElseSet(Supplier)`\n+                    newValue = ((Supplier<T>) input).get();\n+                    Objects.requireNonNull(newValue);\n+                } else {\n+                    final Object u = functionHolder.function();\n+                    newValue = switch (u) {\n+                        case Supplier<?> sup -> (T) sup.get();\n+                        case IntFunction<?> iFun -> (T) iFun.apply((int) input);\n+                        case Function<?, ?> fun ->\n+                                ((Function<Object, T>) fun).apply(input);\n+                        default -> throw new InternalError(\"cannot reach here\");\n+                    };\n+                    Objects.requireNonNull(newValue);\n+                    \/\/ Reduce the counter and if it reaches zero, clear the reference\n+                    \/\/ to the underlying holder.\n+                    functionHolder.countDown();\n+                }\n+                \/\/ The mutex is not reentrant so we know newValue should be returned\n+                set(array, index, mutex, newValue);\n+                return newValue;\n+            }\n+            return t;\n+        }\n+    }\n+\n+    static void preventReentry(Object mutex) {\n+        if (Thread.holdsLock(mutex)) {\n+            throw new IllegalStateException(\"Recursive initialization of a lazy collection is illegal\");\n+        }\n+    }\n+\n+    static <T> void set(T[] array, int index, Object mutex, T newValue) {\n+        assert Thread.holdsLock(mutex) : index + \"didn't hold \" + mutex;\n+        \/\/ We know we hold the monitor here so plain semantic is enough\n+        if (array[index] == null) {\n+            UNSAFE.putReferenceRelease(array, Unsafe.ARRAY_OBJECT_BASE_OFFSET + Unsafe.ARRAY_OBJECT_INDEX_SCALE * (long) index, newValue);\n+        }\n+    }\n+\n+    public static <K, V> String renderMappings(AbstractLazyMap<K, V> self,\n+                                               String selfName,\n+                                               boolean curly) {\n+        final StringJoiner sj = new StringJoiner(\", \", curly ? \"{\" : \"[\", curly ? \"}\" : \"]\");\n+        for (var k : self.keySet()) {\n+            final Object value = self.getAcquire(k);\n+            final String valueString;\n+            if (value == self) {\n+                valueString = \"(this \" + selfName + \")\";\n+            } else {\n+                valueString = LazyConstantImpl.renderConstant(value);\n+            }\n+            sj.add(k + \"=\" + valueString);\n+        }\n+        return sj.toString();\n+    }\n+\n+    \/**\n+     * This class is thread safe. Any thread can create and use an instance of this class at\n+     * any time. The `function` field is only accessed if `counter` is positive so the setting\n+     * of function to `null` is safe.\n+     *\n+     * @param <U> the underlying function type\n+     *\/\n+    static final class FunctionHolder<U> {\n+\n+        private static final long COUNTER_OFFSET = UNSAFE.objectFieldOffset(FunctionHolder.class, \"counter\");\n+\n+        \/\/ This field can only transition at most once from being set to a\n+        \/\/ non-null reference to being `null`. Once `null`, it is never read.\n+        private U function;\n+        \/\/ Used reflectively via Unsafe\n+        private int counter;\n+\n+        public FunctionHolder(U function, int counter) {\n+            this.function = (counter == 0) ? null : function;\n+            this.counter = counter;\n+            \/\/ Safe publication\n+            UNSAFE.storeStoreFence();\n+        }\n+\n+        @ForceInline\n+        public U function() {\n+            return function;\n+        }\n+\n+        public void countDown() {\n+            if (UNSAFE.getAndAddInt(this, COUNTER_OFFSET, -1) == 1) {\n+                \/\/ Do not reference the underlying function anymore so it can be collected.\n+                function = null;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/LazyCollections.java","additions":822,"deletions":0,"binary":false,"changes":822,"status":"added"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.io.Serializable;\n+import java.util.function.IntFunction;\n@@ -90,3 +95,3 @@\n- * <p>The {@link List#of(Object...) List.of} and\n- * {@link List#copyOf List.copyOf} static factory methods\n- * provide a convenient way to create unmodifiable lists. The {@code List}\n+ * <p>The {@link List#of(Object...) List.of},\n+ * {@link List#copyOf List.copyOf}, and {@link List#ofLazy(int, IntFunction)} static\n+ * factory methods provide a convenient way to create unmodifiable lists. The {@code List}\n@@ -103,1 +108,1 @@\n- * <li>They are serializable if all elements are serializable.\n+ * <li>Unless otherwise specified, they are serializable if all elements are serializable.\n@@ -1193,0 +1198,58 @@\n+\n+    \/**\n+     * {@return a new lazily computed list with the provided {@code size}}\n+     * <p>\n+     * The returned list is an {@linkplain Collection##unmodifiable unmodifiable} list\n+     * with the provided {@code size}. The list's elements are lazily computed via the\n+     * provided {@code computingFunction} when they are first accessed\n+     * (e.g., via {@linkplain List#get(int) List::get}).\n+     * <p>\n+     * The provided computing function is guaranteed to be successfully\n+     * invoked at most once per list index, even in a multi-threaded environment.\n+     * Competing threads accessing an element already under computation will block until\n+     * an element is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If invoking the provided computing function throws an exception, it is rethrown\n+     * to the initial caller and no value for the element is recorded.\n+     * <p>\n+     * If the provided computing function returns {@code null},\n+     * a {@linkplain NullPointerException} will be thrown. Hence, just like other\n+     * unmodifiable lists created via the {@code List::of} factories, a lazy list\n+     * cannot contain {@code null} elements. Clients that want to use nullable elements\n+     * can wrap elements into an {@linkplain Optional} holder.\n+     * <p>\n+     * Any {@link List#subList(int, int) subList()} or {@link List#reversed()} views\n+     * of the returned list are also lazily computed.\n+     * <p>\n+     * The returned list and its {@link List#subList(int, int) subList()} or\n+     * {@link List#reversed()} views implement the {@link RandomAccess} interface.\n+     * <p>\n+     * If the provided computing function recursively calls itself or the returned\n+     * lazy list for the same index, an {@linkplain IllegalStateException}\n+     * will be thrown.\n+     * <p>\n+     * The returned lazy list strongly references its computing\n+     * function used to compute elements only so long as there are uncomputed elements\n+     * after which the computing function is not strongly referenced\n+     * anymore and may be collected.\n+     * <p>\n+     * The returned List is <em>not<\/em> {@linkplain Serializable}.\n+     *\n+     * @param size              the size of the returned lazy list\n+     * @param computingFunction to invoke whenever an element is first accessed\n+     *                          (may not return {@code null})\n+     * @param <E>               the type of elements in the returned list\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\n+     * @see LazyConstant\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY_CONSTANTS)\n+    static <E> List<E> ofLazy(int size,\n+                              IntFunction<? extends E> computingFunction) {\n+        Utils.checkNonNegativeArgument(size, \"size\");\n+        Objects.requireNonNull(computingFunction);\n+        \/\/ A computed list is not Serializable, so we cannot return `List.of()` if `size == 0`\n+        return LazyCollections.ofLazyList(size, computingFunction);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":67,"deletions":4,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -986,2 +986,2 @@\n-    private static final Supplier<ReferencedKeyMap<Object, Locale>> LOCALE_CACHE =\n-            StableValue.supplier(new Supplier<>() {\n+    private static final LazyConstant<ReferencedKeyMap<Object, Locale>> LOCALE_CACHE =\n+            LazyConstant.of(new Supplier<>() {\n@@ -2318,2 +2318,2 @@\n-    private final transient Supplier<String> languageTag =\n-            StableValue.supplier(new Supplier<>() {\n+    private final transient LazyConstant<String> languageTag =\n+            LazyConstant.of(new Supplier<>() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    static final Supplier<String[]> ISO_639 =\n-            StableValue.supplier(new Supplier<>() {\n+    static final LazyConstant<String[]> ISO_639 =\n+            LazyConstant.of(new Supplier<>() {\n@@ -41,2 +41,2 @@\n-    static final Supplier<String[]> ISO_3166_1_ALPHA2 =\n-            StableValue.supplier(new Supplier<>() {\n+    static final LazyConstant<String[]> ISO_3166_1_ALPHA2 =\n+            LazyConstant.of(new Supplier<>() {\n@@ -49,2 +49,2 @@\n-    static final Supplier<Set<String>> ISO_3166_1_ALPHA3 =\n-            StableValue.supplier(new Supplier<>() {\n+    static final LazyConstant<Set<String>> ISO_3166_1_ALPHA3 =\n+            LazyConstant.of(new Supplier<>() {\n@@ -57,2 +57,2 @@\n-    static final Supplier<Set<String>> ISO_3166_3 =\n-            StableValue.supplier(new Supplier<>() {\n+    static final LazyConstant<Set<String>> ISO_3166_3 =\n+            LazyConstant.of(new Supplier<>() {\n","filename":"src\/java.base\/share\/classes\/java\/util\/LocaleISOData.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -117,2 +119,3 @@\n- * {@link Map#ofEntries(Map.Entry...) Map.ofEntries}, and\n- * {@link Map#copyOf Map.copyOf}\n+ * {@link Map#ofEntries(Map.Entry...) Map.ofEntries},\n+ * {@link Map#copyOf Map.copyOf}, and\n+ * {@link Map#ofLazy(Set, Function)}\n@@ -131,1 +134,2 @@\n- * <li>They are serializable if all keys and values are serializable.\n+ * <li>Unless otherwise specified, they are serializable if all keys and values\n+ * are serializable.\n@@ -1749,0 +1753,65 @@\n+\n+    \/**\n+     * {@return a new lazily computed map with the provided {@code keys}}\n+     * <p>\n+     * The returned map is an {@linkplain Collection##unmodifiable unmodifiable} map whose\n+     * keys are known at construction. The map's values are lazily computed via the\n+     * provided {@code computingFunction} when they are first accessed\n+     * (e.g., via {@linkplain Map#get(Object) Map::get}).\n+     * <p>\n+     * The provided computing function is guaranteed to be successfully invoked\n+     * at most once per key, even in a multi-threaded environment. Competing\n+     * threads accessing a value already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If invoking the provided computing function throws an exception, it\n+     * is rethrown to the initial caller and no value associated with the provided key\n+     * is recorded.\n+     * <p>\n+     * If the provided computing function returns {@code null},\n+     * a {@linkplain NullPointerException} will be thrown. Hence, just like other\n+     * unmodifiable maps created via the {@code Map::of} factories, a lazy map\n+     * cannot contain {@code null} values. Clients that want to use nullable values can\n+     * wrap values into an {@linkplain Optional} holder.\n+     * <p>\n+     * Any {@link Map#values()} or {@link Map#entrySet()} views of the returned map are\n+     * also lazily computed.\n+     * <p>\n+     * If the provided computing function recursively calls itself or\n+     * the returned lazy map for the same key, an {@linkplain IllegalStateException}\n+     * will be thrown.\n+     * <p>\n+     * The returned lazy map strongly references its underlying\n+     * computing function used to compute values only so long as there are\n+     * uncomputed values after which the underlying function is not strongly referenced\n+     * anymore and may be collected.\n+     * <p>\n+     * The returned Map is <em>not<\/em> {@linkplain Serializable}.\n+     *\n+     * @param keys              the (non-null) keys in the returned computed map\n+     * @param computingFunction to invoke whenever an associated value is first accessed\n+     * @param <K>               the type of keys maintained by the returned map\n+     * @param <V>               the type of mapped values in the returned map\n+     * @throws NullPointerException if the provided set of {@code keys} is {@code null}\n+     *         or if the set of {@code keys} contains a {@code null} element.\n+     *\n+     * @see LazyConstant\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.LAZY_CONSTANTS)\n+    static <K, V> Map<K, V> ofLazy(Set<? extends K> keys,\n+                                   Function<? super K, ? extends V> computingFunction) {\n+        \/\/ Protect against TOC-TOU attacks.\n+        \/\/ Also, implicit null check of `keys` and all its elements\n+        final Set<K> keyCopies = Set.copyOf(keys);\n+        Objects.requireNonNull(computingFunction);\n+        if (keys instanceof EnumSet<?> && !keys.isEmpty()) {\n+            @SuppressWarnings(\"unchecked\")\n+            var enumMap = (Map<K, V>) LazyCollections.ofLazyMapWithEnumKeys(keyCopies, computingFunction);\n+            return enumMap;\n+        } else {\n+            \/\/ A computed map is not Serializable, so we cannot return `Map.of()` if `keys.isEmpty()`\n+            return LazyCollections.ofLazyMap(keyCopies, computingFunction);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":72,"deletions":3,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -27,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -71,0 +74,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/util\/Optional.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-    private final Supplier<Set<String>> keySet = StableValue.supplier(\n+    private final LazyConstant<Set<String>> keySet = LazyConstant.of(\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n@@ -37,2 +33,0 @@\n-    <E> List<E> stableList(int size, IntFunction<? extends E> mapper);\n-    <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -60,1 +62,1 @@\n-    private static final Function<SegmentExtractorKey, MethodHandle> SEGMENT_EXTRACTION_HANDLE_CACHE;\n+    private static final Map<SegmentExtractorKey, MethodHandle> SEGMENT_EXTRACTION_HANDLE_CACHE;\n@@ -80,1 +82,1 @@\n-        SEGMENT_EXTRACTION_HANDLE_CACHE = StableValue.function(inputs, segmentExtractionHandle);\n+        SEGMENT_EXTRACTION_HANDLE_CACHE = Map.ofLazy(inputs, segmentExtractionHandle);\n@@ -191,1 +193,4 @@\n-        final MethodHandle segmentExtractor = SEGMENT_EXTRACTION_HANDLE_CACHE.apply(key);\n+        final MethodHandle segmentExtractor = SEGMENT_EXTRACTION_HANDLE_CACHE.get(key);\n+        if (segmentExtractor == null) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + key);\n+        }\n@@ -211,1 +216,1 @@\n-        innerAdapted = MethodHandles.collectArguments(innerAdapted, 0, HANDLES_CACHE.apply(ALLOCATE));\n+        innerAdapted = MethodHandles.collectArguments(innerAdapted, 0, HANDLES_CACHE.get(ALLOCATE));\n@@ -224,1 +229,1 @@\n-        cleanup = MethodHandles.collectArguments(cleanup, 2, HANDLES_CACHE.apply(ARENA_CLOSE));\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, HANDLES_CACHE.get(ARENA_CLOSE));\n@@ -233,1 +238,1 @@\n-        return MethodHandles.collectArguments(tryFinally, 0, HANDLES_CACHE.apply(ACQUIRE_ARENA));\n+        return MethodHandles.collectArguments(tryFinally, 0, HANDLES_CACHE.get(ACQUIRE_ARENA));\n@@ -263,3 +268,3 @@\n-                    HANDLES_CACHE.apply(NON_NEGATIVE_INT),\n-                    HANDLES_CACHE.apply(SUCCESS_INT),\n-                    HANDLES_CACHE.apply(ERROR_INT).bindTo(intExtractor));\n+                    HANDLES_CACHE.get(NON_NEGATIVE_INT),\n+                    HANDLES_CACHE.get(SUCCESS_INT),\n+                    HANDLES_CACHE.get(ERROR_INT).bindTo(intExtractor));\n@@ -269,3 +274,3 @@\n-                    HANDLES_CACHE.apply(NON_NEGATIVE_LONG),\n-                    HANDLES_CACHE.apply(SUCCESS_LONG),\n-                    HANDLES_CACHE.apply(ERROR_LONG).bindTo(intExtractor));\n+                    HANDLES_CACHE.get(NON_NEGATIVE_LONG),\n+                    HANDLES_CACHE.get(SUCCESS_LONG),\n+                    HANDLES_CACHE.get(ERROR_LONG).bindTo(intExtractor));\n@@ -344,2 +349,2 @@\n-    private static final IntFunction<MethodHandle> HANDLES_CACHE =\n-            StableValue.intFunction(ARENA_CLOSE + 1, UNDERLYING_MAKE_HANDLE);\n+    private static final List<MethodHandle> HANDLES_CACHE =\n+            List.ofLazy(ARENA_CLOSE + 1, UNDERLYING_MAKE_HANDLE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.function.Supplier;\n@@ -117,7 +118,18 @@\n-    private static final StableValue<Optional<JdkConsoleImpl>> INSTANCE = StableValue.of();\n-    public static Optional<JdkConsoleImpl> passwordConsole() {\n-        return INSTANCE.orElseSet(() -> {\n-            \/\/ If there's already a proper console, throw an exception\n-            if (System.console() != null) {\n-                throw new IllegalStateException(\"Canâ€™t create a dedicated password \" +\n-                    \"console since a real console already exists\");\n+    private static final LazyConstant<Optional<JdkConsoleImpl>> PASSWORD_CONSOLE = LazyConstant.of(\n+            new Supplier<Optional<JdkConsoleImpl>>() {\n+                @Override\n+                public Optional<JdkConsoleImpl> get() {\n+                    if (System.console() != null) {\n+                        throw new IllegalStateException(\"Canâ€™t create a dedicated password \" +\n+                                \"console since a real console already exists\");\n+                    }\n+\n+                    \/\/ If stdin is NOT redirected, return an Optional containing a JdkConsoleImpl\n+                    \/\/ instance, otherwise an empty Optional.\n+                    return SharedSecrets.getJavaIOAccess().isStdinTty() ?\n+                            Optional.of(\n+                                    new JdkConsoleImpl(\n+                                            Charset.forName(StaticProperty.stdinEncoding(), UTF_8.INSTANCE),\n+                                            Charset.forName(StaticProperty.stdoutEncoding(), UTF_8.INSTANCE))) :\n+                            Optional.empty();\n+                }\n@@ -125,0 +137,1 @@\n+    );\n@@ -126,9 +139,2 @@\n-            \/\/ If stdin is NOT redirected, return an Optional containing a JdkConsoleImpl\n-            \/\/ instance, otherwise an empty Optional.\n-            return SharedSecrets.getJavaIOAccess().isStdinTty() ?\n-                Optional.of(\n-                    new JdkConsoleImpl(\n-                        Charset.forName(StaticProperty.stdinEncoding(), UTF_8.INSTANCE),\n-                        Charset.forName(StaticProperty.stdoutEncoding(), UTF_8.INSTANCE))) :\n-                Optional.empty();\n-        });\n+    public static Optional<JdkConsoleImpl> passwordConsole() {\n+        return PASSWORD_CONSOLE.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleImpl.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-        @JEP(number = 502, title = \"Stable Values\", status = \"Preview\")\n-        STABLE_VALUES,\n+        @JEP(number = 526, title = \"Lazy Constants\", status = \"Second Preview\")\n+        LAZY_CONSTANTS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * The sole implementation of the LazyConstant interface.\n+ *\n+ * @param <T> type of the constant\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ * rely on reflection, MethodHandles, Streams etc.\n+ *\/\n+public final class LazyConstantImpl<T> implements LazyConstant<T> {\n+\n+    static final String UNSET_LABEL = \".uninitialized\";\n+\n+    \/\/ Unsafe allows `LazyConstant` instances to be used early in the boot sequence\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe offset for access of the `constant` field\n+    private static final long CONSTANT_OFFSET =\n+            UNSAFE.objectFieldOffset(LazyConstantImpl.class, \"constant\");\n+\n+    \/\/ Generally, fields annotated with `@Stable` are accessed by the JVM using special\n+    \/\/ memory semantics rules (see `parse.hpp` and `parse(1|2|3).cpp`).\n+    \/\/\n+    \/\/ This field is used reflectively via Unsafe using explicit memory semantics.\n+    \/\/\n+    \/\/ | Value           | Meaning        |\n+    \/\/ | --------------- | -------------- |\n+    \/\/ | `null`          | Unset          |\n+    \/\/ | `other`         | Set to `other` |\n+    \/\/\n+    @Stable\n+    private T constant;\n+\n+    \/\/ Underlying computing function to be used to compute the `constant` field.\n+    \/\/ The field needs to be `volatile` as a lazy constant can be\n+    \/\/ created by one thread and computed by another thread.\n+    \/\/ After the function is successfully invoked, the field is set to\n+    \/\/ `null` to allow the function to be collected.\n+    @Stable\n+    private volatile Supplier<? extends T> computingFunction;\n+\n+    private LazyConstantImpl(Supplier<? extends T> computingFunction) {\n+        this.computingFunction = computingFunction;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T get() {\n+        final T t = getAcquire();\n+        return (t != null) ? t : getSlowPath();\n+    }\n+\n+    private T getSlowPath() {\n+        preventReentry();\n+        synchronized (this) {\n+            T t = getAcquire();\n+            if (t == null) {\n+                t = computingFunction.get();\n+                Objects.requireNonNull(t);\n+                setRelease(t);\n+                \/\/ Allow the underlying supplier to be collected after successful use\n+                computingFunction = null;\n+            }\n+            return t;\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElse(T other) {\n+        final T t = getAcquire();\n+        return (t == null) ? other : t;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean isInitialized() {\n+        return getAcquire() != null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final T t = getAcquire();\n+        return t == this ? \"(this LazyConstant)\" : renderConstant(t);\n+    }\n+\n+    public static String renderConstant(Object t) {\n+        return (t == null) ? UNSET_LABEL : Objects.toString(t);\n+    }\n+\n+    \/\/ Discussion on the memory semantics used.\n+    \/\/ ----------------------------------------\n+    \/\/ Using acquire\/release semantics on the `constant` field is the cheapest way to\n+    \/\/ establish a happens-before (HB) relation between load and store operations. Every\n+    \/\/ implementation of a method defined in the interface `LazyConstant` except\n+    \/\/ `equals()` starts with a load of the `constant` field using acquire semantics.\n+    \/\/\n+    \/\/ If the underlying supplier was guaranteed to always create a new object,\n+    \/\/ a fence after creation and subsequent plain loads would suffice to ensure\n+    \/\/ new objects' state are always correctly observed. However, no such restriction is\n+    \/\/ imposed on the underlying supplier. Hence, the docs state there should be an\n+    \/\/ HB relation meaning we will have to pay a price (on certain platforms) on every\n+    \/\/ `get()` operation that is not constant-folded.\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @ForceInline\n+    private T getAcquire() {\n+        return (T) UNSAFE.getReferenceAcquire(this, CONSTANT_OFFSET);\n+    }\n+\n+    private void setRelease(T newValue) {\n+        UNSAFE.putReferenceRelease(this, CONSTANT_OFFSET, newValue);\n+    }\n+\n+    private void preventReentry() {\n+        if (Thread.holdsLock(this)) {\n+            throw new IllegalStateException(\"Recursive invocation of a LazyConstant's computing function: \" + computingFunction);\n+        }\n+    }\n+\n+    \/\/ Factory\n+\n+    public static <T> LazyConstantImpl<T> ofLazy(Supplier<? extends T> computingFunction) {\n+        return new LazyConstantImpl<>(computingFunction);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/LazyConstantImpl.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.util.ImmutableBitSetPredicate;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.BitSet;\n-import java.util.Collection;\n-import java.util.EnumSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.IntPredicate;\n-import java.util.function.Supplier;\n-\n-\/**\n- * Optimized implementation of a stable Function with enums as keys.\n- *\n- * @implNote This implementation can be used early in the boot sequence as it does not\n- *           rely on reflection, MethodHandles, Streams etc.\n- *\n- * @param enumType     the class type of the Enum\n- * @param firstOrdinal the lowest ordinal used\n- * @param member       an int predicate that can be used to test if an enum is a member\n- *                     of the valid inputs (as there might be \"holes\")\n- * @param delegates    a delegate array of inputs to StableValue mappings\n- * @param original     the original Function\n- * @param <E>          the type of the input to the function\n- * @param <R>          the type of the result of the function\n- *\/\n-public record StableEnumFunction<E extends Enum<E>, R>(Class<E> enumType,\n-                                                       int firstOrdinal,\n-                                                       IntPredicate member,\n-                                                       @Stable StableValueImpl<R>[] delegates,\n-                                                       Function<? super E, ? extends R> original) implements Function<E, R> {\n-    @ForceInline\n-    @Override\n-    public R apply(E value) {\n-        if (!member.test(value.ordinal())) { \/\/ Implicit null-check of value\n-            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n-        }\n-        final int index = value.ordinal() - firstOrdinal;\n-        \/\/ Since we did the member.test above, we know the index is in bounds\n-        return delegates[index].orElseSet(new Supplier<R>() {\n-                    @Override public R get() { return original.apply(value); }});\n-\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return System.identityHashCode(this);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return obj == this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(delegates.length);\n-        final E[] enumElements = enumType.getEnumConstants();\n-        int ordinal = firstOrdinal;\n-        for (int i = 0; i < delegates.length; i++, ordinal++) {\n-            if (member.test(ordinal)) {\n-                entries.add(new AbstractMap.SimpleImmutableEntry<>(enumElements[ordinal], delegates[i]));\n-            }\n-        }\n-        return StableUtil.renderMappings(this, \"StableFunction\", entries, true);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T, E extends Enum<E>, R> Function<T, R> of(Set<? extends T> inputs,\n-                                                              Function<? super T, ? extends R> original) {\n-        \/\/ The input set is not empty\n-        final Class<E> enumType = ((E) inputs.iterator().next()).getDeclaringClass();\n-        final BitSet bitSet = new BitSet(enumType.getEnumConstants().length);\n-        int min = Integer.MAX_VALUE;\n-        int max = Integer.MIN_VALUE;\n-        for (T t : inputs) {\n-            final int ordinal = ((E) t).ordinal();\n-            min = Math.min(min, ordinal);\n-            max = Math.max(max, ordinal);\n-            bitSet.set(ordinal);\n-        }\n-        final int size = max - min + 1;\n-        final IntPredicate member = ImmutableBitSetPredicate.of(bitSet);\n-        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), (Function<E, R>) original);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-\n-\/\/ Note: It would be possible to just use `StableMap::get` with some additional logic\n-\/\/ instead of this class but explicitly providing a class like this provides better\n-\/\/ debug capability, exception handling, and may provide better performance.\n-\/**\n- * Implementation of a stable Function.\n- *\n- * @implNote This implementation can be used early in the boot sequence as it does not\n- *           rely on reflection, MethodHandles, Streams etc.\n- *\n- * @param values   a delegate map of inputs to StableValue mappings\n- * @param original the original Function\n- * @param <T>      the type of the input to the function\n- * @param <R>      the type of the result of the function\n- *\/\n-public record StableFunction<T, R>(Map<? extends T, StableValueImpl<R>> values,\n-                                   Function<? super T, ? extends R> original) implements Function<T, R> {\n-\n-    @ForceInline\n-    @Override\n-    public R apply(T value) {\n-        final StableValueImpl<R> stable = values.get(value);\n-        if (stable == null) {\n-            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n-        }\n-        return stable.orElseSet(new Supplier<R>() {\n-            @Override  public R get() { return original.apply(value); }});\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return System.identityHashCode(this);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return obj == this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return StableUtil.renderMappings(this, \"StableFunction\", values.entrySet(), true);\n-    }\n-\n-    public static <T, R> StableFunction<T, R> of(Set<? extends T> inputs,\n-                                                 Function<? super T, ? extends R> original) {\n-        return new StableFunction<>(StableUtil.map(inputs), original);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.util.function.IntFunction;\n-import java.util.function.Supplier;\n-\n-\/**\n- * Implementation of a stable IntFunction.\n- * <p>\n- * For performance reasons (~10%), we are not delegating to a StableList but are using\n- * the more primitive functions in StableValueUtil that are shared with StableList\/StableValueImpl.\n- *\n- * @implNote This implementation can be used early in the boot sequence as it does not\n- *           rely on reflection, MethodHandles, Streams etc.\n- *\n- * @param <R> the return type\n- *\/\n-public record StableIntFunction<R>(@Stable StableValueImpl<R>[] delegates,\n-                                   IntFunction<? extends R> original) implements IntFunction<R> {\n-\n-    @ForceInline\n-    @Override\n-    public R apply(int index) {\n-        final StableValueImpl<R> delegate;\n-        try {\n-            delegate =  delegates[index];\n-        } catch (ArrayIndexOutOfBoundsException ioob) {\n-            throw new IllegalArgumentException(\"Input not allowed: \" + index, ioob);\n-        }\n-        return delegate.orElseSet(new Supplier<R>() {\n-                    @Override public R get() { return original.apply(index); }});\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return System.identityHashCode(this);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return obj == this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return StableUtil.renderElements(this, \"StableIntFunction\", delegates);\n-    }\n-\n-    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> original) {\n-        return new StableIntFunction<>(StableUtil.array(size), original);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.util.function.Supplier;\n-\n-\/**\n- * Implementation of a stable supplier.\n- * <p>\n- * @implNote This implementation can be used early in the boot sequence as it does not\n- *           rely on reflection, MethodHandles, Streams etc.\n- *\n- * @param <T> the return type\n- *\/\n-public record StableSupplier<T>(StableValueImpl<T> delegate,\n-                                Supplier<? extends T> original) implements Supplier<T> {\n-\n-    @ForceInline\n-    @Override\n-    public T get() {\n-        return delegate.orElseSet(original);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return System.identityHashCode(this);\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return obj == this;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final Object t = delegate.wrappedContentsAcquire();\n-        return t == this ? \"(this StableSupplier)\" : StableValueImpl.renderWrapped(t);\n-    }\n-\n-    public static <T> StableSupplier<T> of(Supplier<? extends T> original) {\n-        return new StableSupplier<>(StableValueImpl.of(), original);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.lang.stable;\n-\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.StringJoiner;\n-\n-public final class StableUtil {\n-\n-    private StableUtil() {}\n-\n-    public static <R> String renderElements(Object self,\n-                                            String selfName,\n-                                            StableValueImpl<?>[] delegates) {\n-        return renderElements(self, selfName, delegates, 0, delegates.length);\n-    }\n-\n-    public static <R> String renderElements(Object self,\n-                                            String selfName,\n-                                            StableValueImpl<?>[] delegates,\n-                                            int offset,\n-                                            int length) {\n-        final StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n-        for (int i = 0; i < length; i++) {\n-            final Object value = delegates[i + offset].wrappedContentsAcquire();\n-            if (value == self) {\n-                sj.add(\"(this \" + selfName + \")\");\n-            } else {\n-                sj.add(StableValueImpl.renderWrapped(value));\n-            }\n-        }\n-        return sj.toString();\n-    }\n-\n-    public static <K, V> String renderMappings(Object self,\n-                                               String selfName,\n-                                               Iterable<Map.Entry<K, StableValueImpl<V>>> delegates,\n-                                               boolean curly) {\n-        final StringJoiner sj = new StringJoiner(\", \", curly ? \"{\" : \"[\", curly ? \"}\" : \"]\");\n-        for (var e : delegates) {\n-            final Object value = e.getValue().wrappedContentsAcquire();\n-            final String valueString;\n-            if (value == self) {\n-                valueString = \"(this \" + selfName + \")\";\n-            } else {\n-                valueString = StableValueImpl.renderWrapped(value);\n-            }\n-            sj.add(e.getKey() + \"=\" + valueString);\n-        }\n-        return sj.toString();\n-    }\n-\n-    public static <T> StableValueImpl<T>[] array(int size) {\n-        assertSizeNonNegative(size);\n-        @SuppressWarnings(\"unchecked\")\n-        final var stableValues = (StableValueImpl<T>[]) new StableValueImpl<?>[size];\n-        for (int i = 0; i < size; i++) {\n-            stableValues[i] = StableValueImpl.of();\n-        }\n-        return stableValues;\n-    }\n-\n-    public static <K, T> Map<K, StableValueImpl<T>> map(Set<K> keys) {\n-        Objects.requireNonNull(keys);\n-        @SuppressWarnings(\"unchecked\")\n-        final var entries = (Map.Entry<K, StableValueImpl<T>>[]) new Map.Entry<?, ?>[keys.size()];\n-        int i = 0;\n-        for (K key : keys) {\n-            entries[i++] = Map.entry(key, StableValueImpl.of());\n-        }\n-        return Map.ofEntries(entries);\n-    }\n-\n-    public static void assertSizeNonNegative(int size) {\n-        if (size < 0) {\n-            throw new IllegalArgumentException(\"size can not be negative: \" + size);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.lang.stable;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.function.Supplier;\n-\n-\/**\n- * The implementation of StableValue.\n- *\n- * @implNote This implementation can be used early in the boot sequence as it does not\n- *           rely on reflection, MethodHandles, Streams etc.\n- *\n- * @param <T> type of the contents\n- *\/\n-public final class StableValueImpl<T> implements StableValue<T> {\n-\n-    static final String UNSET_LABEL = \".unset\";\n-\n-    \/\/ Unsafe allows StableValue to be used early in the boot sequence\n-    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    \/\/ Unsafe offsets for direct field access\n-\n-    private static final long CONTENTS_OFFSET =\n-            UNSAFE.objectFieldOffset(StableValueImpl.class, \"contents\");\n-\n-    \/\/ Used to indicate a holder value is `null` (see field `contents` below)\n-    private static final Object NULL_SENTINEL = new Object();\n-\n-    \/\/ Generally, fields annotated with `@Stable` are accessed by the JVM using special\n-    \/\/ memory semantics rules (see `parse.hpp` and `parse(1|2|3).cpp`).\n-    \/\/\n-    \/\/ This field is used directly and reflectively via Unsafe using explicit memory semantics.\n-    \/\/\n-    \/\/ | Value          |  Meaning      |\n-    \/\/ | -------------- |  ------------ |\n-    \/\/ | null           |  Unset        |\n-    \/\/ | NULL_SENTINEL  |  Set(null)    |\n-    \/\/ | other          |  Set(other)   |\n-    \/\/\n-    @Stable\n-    private Object contents;\n-\n-    \/\/ Only allow creation via the factory `StableValueImpl::newInstance`\n-    private StableValueImpl() {}\n-\n-    @ForceInline\n-    @Override\n-    public boolean trySet(T contents) {\n-        if (wrappedContentsAcquire() != null) {\n-            return false;\n-        }\n-        \/\/ Prevent reentry via an orElseSet(supplier)\n-        preventReentry();\n-        \/\/ Mutual exclusion is required here as `orElseSet` might also\n-        \/\/ attempt to modify `this.contents`\n-        synchronized (this) {\n-            return wrapAndSet(contents);\n-        }\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public void setOrThrow(T contents) {\n-        if (!trySet(contents)) {\n-            \/\/ Neither the set contents nor the provided contents is revealed in the\n-            \/\/ exception message as it might be sensitive.\n-            throw new IllegalStateException(\"The contents is already set\");\n-        }\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public T orElseThrow() {\n-        final Object t = wrappedContentsAcquire();\n-        if (t == null) {\n-            throw new NoSuchElementException(\"No contents set\");\n-        }\n-        return unwrap(t);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public T orElse(T other) {\n-        final Object t = wrappedContentsAcquire();\n-        return (t == null) ? other : unwrap(t);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public boolean isSet() {\n-        return wrappedContentsAcquire() != null;\n-    }\n-\n-    @ForceInline\n-    @Override\n-    public T orElseSet(Supplier<? extends T> supplier) {\n-        Objects.requireNonNull(supplier);\n-        final Object t = wrappedContentsAcquire();\n-        return (t == null) ? orElseSetSlowPath(supplier) : unwrap(t);\n-    }\n-\n-    @DontInline\n-    private T orElseSetSlowPath(Supplier<? extends T> supplier) {\n-        preventReentry();\n-        synchronized (this) {\n-            final Object t = contents;  \/\/ Plain semantics suffice here\n-            if (t == null) {\n-                final T newValue = supplier.get();\n-                \/\/ The mutex is not reentrant so we know newValue should be returned\n-                wrapAndSet(newValue);\n-                return newValue;\n-            }\n-            return unwrap(t);\n-        }\n-    }\n-\n-    \/\/ The methods equals() and hashCode() should be based on identity (defaults from Object)\n-\n-    @Override\n-    public String toString() {\n-        final Object t = wrappedContentsAcquire();\n-        return t == this\n-                ? \"(this StableValue)\"\n-                : renderWrapped(t);\n-    }\n-\n-    \/\/ Internal methods shared with other internal classes\n-\n-    @ForceInline\n-    public Object wrappedContentsAcquire() {\n-        return UNSAFE.getReferenceAcquire(this, CONTENTS_OFFSET);\n-    }\n-\n-    static String renderWrapped(Object t) {\n-        return (t == null) ? UNSET_LABEL : Objects.toString(unwrap(t));\n-    }\n-\n-    \/\/ Private methods\n-\n-    \/\/ This method is not annotated with @ForceInline as it is always called\n-    \/\/ in a slow path.\n-    private void preventReentry() {\n-        if (Thread.holdsLock(this)) {\n-            throw new IllegalStateException(\"Recursive initialization of a stable value is illegal\");\n-        }\n-    }\n-\n-    \/**\n-     * Wraps the provided {@code newValue} and tries to set the contents.\n-     * <p>\n-     * This method ensures the {@link Stable} field is written to at most once.\n-     *\n-     * @param newValue to wrap and set\n-     * @return if the contents was set\n-     *\/\n-    @ForceInline\n-    private boolean wrapAndSet(T newValue) {\n-        assert Thread.holdsLock(this);\n-        \/\/ We know we hold the monitor here so plain semantic is enough\n-        if (contents == null) {\n-            UNSAFE.putReferenceRelease(this, CONTENTS_OFFSET, wrap(newValue));\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-\n-    \/\/ Wraps `null` values into a sentinel value\n-    @ForceInline\n-    private static Object wrap(Object t) {\n-        return (t == null) ? NULL_SENTINEL : t;\n-    }\n-\n-    \/\/ Unwraps null sentinel values into `null`\n-    @SuppressWarnings(\"unchecked\")\n-    @ForceInline\n-    private static <T> T unwrap(Object t) {\n-        return t != NULL_SENTINEL ? (T) t : null;\n-    }\n-\n-    \/\/ Factory\n-\n-    public static <T> StableValueImpl<T> of() {\n-        return new StableValueImpl<>();\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -51,0 +51,2 @@\n+import java.lang.LazyConstant;\n+import java.util.function.Supplier;\n@@ -97,1 +99,2 @@\n-    private static final StableValue<Boolean> SHUTDOWN_WRITE_BEFORE_CLOSE = StableValue.of();\n+    private static final LazyConstant<Boolean> SHUTDOWN_WRITE_BEFORE_CLOSE = LazyConstant.of(new Supplier<Boolean>() {\n+        @Override  public Boolean get() { return shouldShutdownWriteBeforeClose0(); }});\n@@ -103,1 +106,1 @@\n-        return SHUTDOWN_WRITE_BEFORE_CLOSE.orElseSet(Net::shouldShutdownWriteBeforeClose0);\n+        return SHUTDOWN_WRITE_BEFORE_CLOSE.get();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-    private static final Supplier<ReferencedKeySet<BaseLocale>> CACHE =\n-            StableValue.supplier(new Supplier<>() {\n+    private static final LazyConstant<ReferencedKeySet<BaseLocale>> CACHE =\n+            LazyConstant.of(new Supplier<>() {\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    private final Supplier<Set<String>> keys = StableValue.supplier(\n+    private final LazyConstant<Set<String>> keys = LazyConstant.of(\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/BreakIteratorResourceBundle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    private final Supplier<Map<String, Object>> lookup = StableValue.supplier(\n+    private final LazyConstant<Map<String, Object>> lookup = LazyConstant.of(\n@@ -137,1 +137,1 @@\n-    private final Supplier<Set<String>> keyset = StableValue.supplier(\n+    private final LazyConstant<Set<String>> keyset = LazyConstant.of(\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/OpenListResourceBundle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for dependency injection\n+ * @enablePreview\n+ * @run junit DemoContainerInjectionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class DemoContainerInjectionTest {\n+\n+    interface Foo{}\n+    interface Bar{};\n+    static class FooImpl implements Foo{};\n+    static class BarImpl implements Bar{};\n+\n+    \/\/ Provides a type safe way of associating a type to a supplier\n+    record Provider<T>(Class<T> type, Supplier<? extends T> supplier){}\n+\n+    @Test\n+    void ComputedComponentsViaLambda() {\n+        Container container = ComputedContainer.of(Set.of(Foo.class, Bar.class), t -> switch (t) {\n+            case Class<?> c when c.equals(Foo.class) -> new FooImpl();\n+            case Class<?> c when c.equals(Bar.class) -> new BarImpl();\n+            default -> throw new IllegalArgumentException();\n+        });\n+        assertContainerPopulated(container);\n+    }\n+\n+    @Test\n+    void SettableComponents() {\n+        SettableContainer container = SettableScratchContainer.of(Set.of(Foo.class, Bar.class));\n+        container.set(Foo.class, new FooImpl());\n+        container.set(Bar.class, new BarImpl());\n+        assertContainerPopulated(container);\n+    }\n+\n+\n+    @Test\n+    void ProviderComponents() {\n+        Container container = ProviderContainer.of(Map.of(\n+                Foo.class, FooImpl::new,\n+                Bar.class, BarImpl::new));\n+        assertContainerPopulated(container);\n+    }\n+\n+    @Test\n+    void ProviderTypedComponents() {\n+        Container container = providerTypedContainer(Set.of(\n+           new Provider<>(Foo.class, FooImpl::new),\n+           new Provider<>(Bar.class, BarImpl::new)\n+        ));\n+        assertContainerPopulated(container);\n+    }\n+\n+    private static void assertContainerPopulated(Container container) {\n+        assertInstanceOf(FooImpl.class, container.get(Foo.class));\n+        assertInstanceOf(BarImpl.class, container.get(Bar.class));\n+    }\n+\n+    interface Container {\n+        <T> T get(Class<T> type);\n+    }\n+\n+    interface SettableContainer extends Container {\n+        <T> void set(Class<T> type, T implementation);\n+    }\n+\n+    record ComputedContainer(Map<Class<?>, ?> components) implements Container {\n+\n+        @Override\n+        public <T> T get(Class<T> type) {\n+            return type.cast(components.get(type));\n+        }\n+\n+        static Container of(Set<Class<?>> components, Function<Class<?>, ?> mapper) {\n+            return new ComputedContainer(Map.ofLazy(components, mapper));\n+        }\n+\n+    }\n+\n+    record SettableScratchContainer(Map<Class<?>, Object> scratch, Map<Class<?>, ?> components) implements SettableContainer {\n+\n+        @Override\n+        public <T> void set(Class<T> type, T implementation) {\n+            if (scratch.putIfAbsent(type, type.cast(implementation)) != null) {\n+                throw new IllegalStateException(\"Can only set once for \" + type);\n+            }\n+        }\n+\n+        @Override\n+        public <T> T get(Class<T> type) {\n+            return type.cast(components.get(type));\n+        }\n+\n+        static SettableContainer of(Set<Class<?>> components) {\n+            Map<Class<?>, Object> scratch = new ConcurrentHashMap<>();\n+            return new SettableScratchContainer(scratch, Map.ofLazy(components, scratch::get));\n+        }\n+\n+    }\n+\n+    record ProviderContainer(Map<Class<?>, ?> components) implements Container {\n+\n+        @Override\n+        public <T> T get(Class<T> type) {\n+            return type.cast(components.get(type));\n+        }\n+\n+        static Container of(Map<Class<?>, Supplier<?>> components) {\n+            var map = Map.ofLazy(components.keySet(), t -> components.get(t).get());\n+            return new ProviderContainer(map);\n+        }\n+\n+    }\n+\n+    static Container providerTypedContainer(Set<Provider<?>> providers) {\n+                return ProviderContainer.of(providers.stream()\n+                                .collect(Collectors.toMap(Provider::type, Provider::supplier)));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/DemoContainerInjectionTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test of a demo of an imperative stable value based on a lazy constant\n+ * @enablePreview\n+ * @run junit DemoImperativeTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class DemoImperativeTest {\n+\n+    interface ImperativeStableValue<T> {\n+        T orElse(T other);\n+        boolean isSet();\n+        boolean trySet(T t);\n+        T get();\n+\n+        static <T> ImperativeStableValue<T> of() {\n+            var scratch = new AtomicReference<T>();\n+            return new Impl<>(scratch, LazyConstant.of(scratch::get));\n+        }\n+\n+    }\n+\n+\n+    private record Impl<T>(AtomicReference<T> scratch,\n+                           LazyConstant<T> underlying) implements ImperativeStableValue<T> {\n+\n+        @Override\n+        public boolean trySet(T t) {\n+            final boolean result = scratch.compareAndSet(null, t);\n+            if (result) {\n+                \/\/ Actually set the value\n+                get();\n+            }\n+            return result;\n+        }\n+\n+        @Override public T       orElse(T other) { return underlying.orElse(other); }\n+        @Override public boolean isSet() { return underlying.isInitialized(); }\n+        @Override public T       get() { return underlying.get(); }\n+\n+    }\n+\n+    @Test\n+    void basic() {\n+        var stableValue = ImperativeStableValue.<Integer>of();\n+        assertFalse(stableValue.isSet());\n+        assertEquals(13, stableValue.orElse(13));\n+        assertTrue(stableValue.trySet(42));\n+        assertFalse(stableValue.trySet(13));\n+        assertTrue(stableValue.isSet());\n+        assertEquals(42, stableValue.get());\n+        assertEquals(42, stableValue.orElse(13));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/DemoImperativeTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test of a lazy map application\n+ * @enablePreview\n+ * @run junit DemoMapTest\n+ *\/\n+\n+import org.junit.jupiter.api.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class DemoMapTest {\n+\n+    static class OrderController{}\n+\n+    \/\/ NEW:\n+    static final Map<String, OrderController> ORDERS\n+            = Map.ofLazy(\n+                    Set.of(\"Customers\", \"Internal\", \"Testing\"),\n+                    _ -> new OrderController()\n+    );\n+\n+    public static OrderController orders() {\n+        String groupName = Thread.currentThread().getThreadGroup().getName();\n+        return ORDERS.get(groupName);\n+    }\n+\n+    @Test\n+    void orderController() throws InterruptedException {\n+        Thread t = Thread.ofPlatform()\n+                .group(new ThreadGroup(\"Customers\"))\n+                .start(() -> {\n+                    String groupName = Thread.currentThread().getThreadGroup().getName();\n+                    OrderController orderController = ORDERS.get(groupName);\n+                    assertNotNull(orderController);\n+                });\n+        t.join();\n+    }\n+\n+    private static final Map<Integer, String> SERVER_ERROR_PAGES = Map.ofLazy(\n+            Set.of(500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511),\n+            e -> {\n+                try {\n+                    return Files.readString(Path.of(\"server_error_\" + e + \".html\"));\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(ioe);\n+                }\n+            });\n+\n+    private static String htmlServerErrorPage(int errorCode) {\n+        return SERVER_ERROR_PAGES.get(errorCode); \/\/ Eligible for constant folding\n+    }\n+\n+    @Test\n+    void page500() {\n+        String page = htmlServerErrorPage(500); \/\/ Constant folds\n+        assertEquals(DEFAULT_FS_MSG, page);\n+    }\n+\n+    static final String DEFAULT_FS_MSG = \"\"\"\n+            <!DOCTYPE html>\n+            <html lang=\"en\">\n+              <head>\n+                <meta charset=\"utf-8\">\n+                <title>Internal Server Error (500)<\/title>\n+                <link rel=\"stylesheet\" href=\"style.css\">\n+                <script src=\"script.js\"><\/script>\n+              <\/head>\n+              <body>\n+                There was a general problem with the server, code 500\n+              <\/body>\n+            <\/html>\n+            \"\"\";\n+\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        var file = Path.of(\"server_error_500.html\");\n+        if (Files.notExists(file)) {\n+            Files.createFile(file);\n+            Files.writeString(file, DEFAULT_FS_MSG);\n+        }\n+        assertEquals(DEFAULT_FS_MSG, Files.readString(file));\n+    }\n+\n+    @AfterAll\n+    public static void cleanUp() throws IOException {\n+        var file = Path.of(\"server_error_500.html\");\n+        Files.deleteIfExists(file);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/DemoMapTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for making sure ComputedConstant publishes values safely\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.lang\n+ * @enablePreview\n+ * @run junit LazyConstantSafePublicationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.lang.LazyConstant;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class LazyConstantSafePublicationTest {\n+\n+    private static final int SIZE = 100_000;\n+    private static final int THREADS = Runtime.getRuntime().availableProcessors();\n+    private static final AtomicReference<LazyConstant<Holder>[]> CONSTANTS = new AtomicReference<>();\n+\n+    static LazyConstant<Holder>[] constants() {\n+        @SuppressWarnings(\"unchecked\")\n+        LazyConstant<Holder>[] constants = (LazyConstant<Holder>[]) new LazyConstant[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            constants[i] = LazyConstant.of(Holder::new);\n+        }\n+        return constants;\n+    }\n+\n+    static final class Holder {\n+        \/\/ These are non-final fields but should be seen\n+        \/\/ fully initialized thanks to the HB properties of ComputedConstants.\n+        int a, b, c, d, e;\n+\n+        Holder() {\n+            a = b = c = d = e = 1;\n+        }\n+    }\n+\n+    static final class Consumer implements Runnable {\n+\n+        final int[] observations = new int[SIZE];\n+        final LazyConstant<Holder>[] constants = CONSTANTS.get();\n+        int i = 0;\n+\n+        @Override\n+        public void run() {\n+            for (; i < SIZE; i++) {\n+                LazyConstant<Holder> s = constants[i];\n+                Holder h;\n+                \/\/ Wait until the ComputedConstant has a holder value\n+                while ((h = s.orElse(null)) == null) { Thread.onSpinWait();}\n+                int a = h.a;\n+                int b = h.b;\n+                int c = h.c;\n+                int d = h.d;\n+                int e = h.e;\n+                observations[i] = a + (b << 1) + (c << 2) + (c << 3) + (d << 4) + (e << 5);\n+            }\n+        }\n+    }\n+\n+    static final class Producer implements Runnable {\n+\n+        final LazyConstant<Holder>[] constants = CONSTANTS.get();\n+\n+        @Override\n+        public void run() {\n+            LazyConstant<Holder> s;\n+            long deadlineNs = System.nanoTime();\n+            for (int i = 0; i < SIZE; i++) {\n+                s = constants[i];\n+                s.get();\n+                deadlineNs += 1000;\n+                while (System.nanoTime() < deadlineNs) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void mainTest() {\n+        CONSTANTS.set(constants());\n+\n+        List<Consumer> consumers = IntStream.range(0, THREADS)\n+                .mapToObj(_ -> new Consumer())\n+                .toList();\n+\n+        List<Thread> consumersThreads = IntStream.range(0, THREADS)\n+                .mapToObj(i -> Thread.ofPlatform()\n+                        .name(\"Consumer Thread \" + i)\n+                        .start(consumers.get(i)))\n+                .toList();\n+\n+        Producer producer = new Producer();\n+\n+        Thread producerThread = Thread.ofPlatform()\n+                .name(\"Producer Thread\")\n+                .start(producer);\n+\n+        join(consumers, producerThread);\n+        join(consumers, consumersThreads.toArray(Thread[]::new));\n+\n+        int[] histogram = new int[64];\n+        for (Consumer consumer : consumers) {\n+            for (int i = 0; i < SIZE; i++) {\n+                histogram[consumer.observations[i]]++;\n+            }\n+        }\n+\n+        \/\/ unless a = 1, ..., e = 1, zero observations should be seen\n+        for (int i = 0; i < 63; i++) {\n+            assertEquals(0, histogram[i]);\n+        }\n+        \/\/ a = 1, ..., e = 1 : index 2^5-1 = 63\n+        \/\/ All observations should end up in this bucket\n+        assertEquals(THREADS * SIZE, histogram[63]);\n+    }\n+\n+    static void join(List<Consumer> consumers, Thread... threads) {\n+        try {\n+            for (Thread t:threads) {\n+                long deadline = System.nanoTime() + TimeUnit.MINUTES.toNanos(1);\n+                while (t.isAlive()) {\n+                    t.join(TimeUnit.SECONDS.toMillis(10));\n+                    if (t.isAlive()) {\n+                        String stack = Arrays.stream(t.getStackTrace())\n+                                .map(Objects::toString)\n+                                .collect(Collectors.joining(System.lineSeparator()));\n+                        System.err.println(t + \": \" + stack);\n+                        for (int i = 0; i < consumers.size(); i++) {\n+                            System.err.println(\"Consumer \" + i + \": \" + consumers.get(i).i);\n+                        }\n+                    }\n+                    if (System.nanoTime() > deadline) {\n+                        long nonNulls = CompletableFuture.supplyAsync(() ->\n+                                Stream.of(CONSTANTS.get())\n+                                        .map(s -> s.orElse(null))\n+                                        .filter(Objects::nonNull)\n+                                        .count(), Executors.newSingleThreadExecutor()).join();\n+                        fail(\"Giving up! Set lazy constants seen by a new thread: \" + nonNulls);\n+                    }\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            fail(ie);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyConstantSafePublicationTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for the LazyConstant implementation\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.lang\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang=ALL-UNNAMED LazyConstantTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.lang.LazyConstant;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class LazyConstantTest {\n+\n+    private static final int VALUE = 42;\n+    private static final Supplier<Integer> SUPPLIER = () -> VALUE;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> LazyConstant.of(null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void basic(Function<Supplier<Integer>, LazyConstant<Integer>> factory) {\n+        LazyConstantTestUtil.CountingSupplier<Integer> cs = new LazyConstantTestUtil.CountingSupplier<>(SUPPLIER);\n+        var lazy = factory.apply(cs);\n+        assertEquals(LazyConstantTestUtil.UNINITIALIZED_TAG, lazy.toString());\n+        assertEquals(SUPPLIER.get(), lazy.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(SUPPLIER.get(), lazy.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(Objects.toString(SUPPLIER.get()), lazy.toString());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void exception(Function<Supplier<Integer>, LazyConstant<Integer>> factory) {\n+        LazyConstantTestUtil.CountingSupplier<Integer> cs = new LazyConstantTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = factory.apply(cs);\n+        assertThrows(UnsupportedOperationException.class, lazy::get);\n+        assertEquals(1, cs.cnt());\n+        assertThrows(UnsupportedOperationException.class, lazy::get);\n+        assertEquals(2, cs.cnt());\n+        assertEquals(LazyConstantTestUtil.UNINITIALIZED_TAG, lazy.toString());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void orElse(LazyConstant<Integer> constant) {\n+        assertNull(constant.orElse(null));\n+        constant.get();\n+        assertEquals(VALUE, constant.orElse(null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void get(LazyConstant<Integer> constant) {\n+        assertEquals(VALUE, constant.get());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void isInitialized(LazyConstant<Integer> constant) {\n+        assertFalse(constant.isInitialized());\n+        constant.get();\n+        assertTrue(constant.isInitialized());\n+   }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void testHashCode(LazyConstant<Integer> constant) {\n+        assertEquals(System.identityHashCode(constant), constant.hashCode());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void testEquals(LazyConstant<Integer> c0) {\n+        assertNotEquals(null, c0);\n+        LazyConstant<Integer> different = LazyConstant.of(SUPPLIER);\n+        assertNotEquals(different, c0);\n+        assertNotEquals(c0, different);\n+        assertNotEquals(\"a\", c0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void testLazyConstantAsComputingFunction(LazyConstant<Integer> constant) {\n+        LazyConstant<Integer> c1 = LazyConstant.of(constant);\n+        assertSame(constant, c1);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"lazyConstants\")\n+    void toStringUnset(LazyConstant<Integer> constant) {\n+        assertEquals(LazyConstantTestUtil.UNINITIALIZED_TAG, constant.toString());\n+        constant.get();\n+        assertEquals(Integer.toString(VALUE), constant.toString());\n+    }\n+\n+    @Test\n+    void toStringCircular() {\n+        AtomicReference<LazyConstant<?>> ref = new AtomicReference<>();\n+        LazyConstant<LazyConstant<?>> constant = LazyConstant.of(ref::get);\n+        ref.set(constant);\n+        constant.get();\n+        String toString = assertDoesNotThrow(constant::toString);\n+        assertEquals(\"(this LazyConstant)\", toString);\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        AtomicReference<LazyConstant<Integer>> ref = new AtomicReference<>();\n+        LazyConstant<Integer> constant = LazyConstant.of(() -> ref.get().get());\n+        LazyConstant<Integer> constant1 = LazyConstant.of(constant);\n+        ref.set(constant1);\n+        assertThrows(IllegalStateException.class, constant::get);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void underlying(Function<Supplier<Integer>, LazyConstant<Integer>> factory) {\n+        LazyConstantTestUtil.CountingSupplier<Integer> cs = new LazyConstantTestUtil.CountingSupplier<>(SUPPLIER);\n+        var f1 = factory.apply(cs);\n+\n+        Supplier<?> underlyingBefore = LazyConstantTestUtil.computingFunction(f1);\n+        assertSame(cs, underlyingBefore);\n+        int v = f1.get();\n+        Supplier<?> underlyingAfter = LazyConstantTestUtil.computingFunction(f1);\n+        assertNull(underlyingAfter);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void functionHolderException(Function<Supplier<Integer>, LazyConstant<Integer>> factory) {\n+        LazyConstantTestUtil.CountingSupplier<Integer> cs = new LazyConstantTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var f1 = factory.apply(cs);\n+\n+        Supplier<?> underlyingBefore = LazyConstantTestUtil.computingFunction(f1);\n+        assertSame(cs, underlyingBefore);\n+        try {\n+            int v = f1.get();\n+        } catch (UnsupportedOperationException _) {\n+            \/\/ Expected\n+        }\n+        Supplier<?> underlyingAfter = LazyConstantTestUtil.computingFunction(f1);\n+        assertSame(cs, underlyingAfter);\n+    }\n+\n+    private static Stream<LazyConstant<Integer>> lazyConstants() {\n+        return factories()\n+                .map(f -> f.apply(() -> VALUE));\n+    }\n+\n+    private static Stream<Function<Supplier<Integer>, LazyConstant<Integer>>> factories() {\n+        return Stream.of(\n+                supplier(\"ComputedConstant.of(<lambda>)\", LazyConstant::of)\n+        );\n+    }\n+\n+    private static Function<Supplier<Integer>, LazyConstant<Integer>> supplier(String name,\n+                                                                               Function<Supplier<Integer>, LazyConstant<Integer>> underlying) {\n+        return new Function<Supplier<Integer>, LazyConstant<Integer>>() {\n+            @Override\n+            public LazyConstant<Integer> apply(Supplier<Integer> supplier) {\n+                return underlying.apply(supplier);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n+        };\n+    }\n+\n+    record Lazy<T>(LazyConstant<T> underlying) implements Supplier<T> {\n+        @Override\n+        public T get() { return underlying.get(); }\n+\n+        static <T> Lazy<T> of(Supplier<? extends T> computingFunction) {\n+            return new Lazy<>(LazyConstant.of(computingFunction));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyConstantTest.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+final class LazyConstantTestUtil {\n+\n+    private LazyConstantTestUtil() { }\n+\n+    public static final String UNINITIALIZED_TAG = \".uninitialized\";\n+\n+    public static final class CountingSupplier<T>\n+            extends AbstractCounting<Supplier<T>>\n+            implements Supplier<T> {\n+\n+        public CountingSupplier(Supplier<T> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public T get() {\n+            incrementCounter();\n+            return delegate.get();\n+        }\n+\n+    }\n+\n+    public static final class CountingIntFunction<R>\n+            extends AbstractCounting<IntFunction<R>>\n+            implements IntFunction<R> {\n+\n+        public CountingIntFunction(IntFunction<R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(int value) {\n+            incrementCounter();\n+            return delegate.apply(value);\n+        }\n+\n+    }\n+\n+    public static final class CountingFunction<T, R>\n+            extends AbstractCounting<Function<T, R>>\n+            implements Function<T, R> {\n+\n+        public CountingFunction(Function<T, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t) {\n+            incrementCounter();\n+            return delegate.apply(t);\n+        }\n+\n+    }\n+\n+    public static final class CountingBiFunction<T, U, R>\n+            extends AbstractCounting<BiFunction<T, U, R>>\n+            implements BiFunction<T, U, R> {\n+\n+        public CountingBiFunction(BiFunction<T, U, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t, U u) {\n+            incrementCounter();\n+            return delegate.apply(t, u);\n+        }\n+    }\n+\n+    abstract static class AbstractCounting<D> {\n+\n+        private final AtomicInteger cnt = new AtomicInteger();\n+        protected final D delegate;\n+\n+        protected AbstractCounting(D delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        protected final void incrementCounter() {\n+            cnt.incrementAndGet();\n+        }\n+\n+        public final int cnt() {\n+            return cnt.get();\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            return cnt.toString();\n+        }\n+    }\n+\n+    static Object functionHolder(Object o) {\n+        try {\n+            final Field field = field(o.getClass(), \"functionHolder\");\n+            field.setAccessible(true);\n+            return field.get(o);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Object functionHolderFunction(Object o) {\n+        try {\n+            final Field field = field(o.getClass(), \"function\");\n+            field.setAccessible(true);\n+            return field.get(o);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static int functionHolderCounter(Object o) {\n+        try {\n+            final Field field = field(o.getClass(), \"counter\");\n+            field.setAccessible(true);\n+            return (int)field.get(o);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Supplier<?> computingFunction(LazyConstant<?> o) {\n+        try {\n+            final Field field = field(o.getClass(), \"computingFunction\");\n+            field.setAccessible(true);\n+            return (Supplier<?>) field.get(o);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Field field(Class<?> clazz, String name) {\n+        if (clazz.equals(Object.class)) {\n+            throw new RuntimeException(\"No \" + name);\n+        }\n+        try {\n+            return clazz.getDeclaredField(name);\n+        } catch (NoSuchFieldException e) {\n+            return field(clazz.getSuperclass(), name);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyConstantTestUtil.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,523 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for lazy list methods\n+ * @enablePreview\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED LazyListTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class LazyListTest {\n+\n+    private static final int ZERO = 0;\n+    private static final int INDEX = 7;\n+    private static final int SIZE = 31;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> List.ofLazy(SIZE, null));\n+        assertThrows(IllegalArgumentException.class, () -> List.ofLazy(-1, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newLazyList().isEmpty());\n+        assertTrue(newEmptyLazyList().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(SIZE, newLazyList().size());\n+        assertEquals(ZERO, newEmptyLazyList().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<>(IDENTITY);\n+        var lazy = List.ofLazy(SIZE, cif);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+        }\n+    }\n+\n+    @Test\n+    void getException() {\n+        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = List.ofLazy(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(2, cif.cnt());\n+    }\n+\n+    @Test\n+    void toArray() {\n+        assertArrayEquals(new Object[ZERO], newEmptyLazyList().toArray());\n+        assertArrayEquals(newRegularList().toArray(), newLazyList().toArray());\n+    }\n+\n+    @Test\n+    void toArrayWithArrayLarger() {\n+        Integer[] actual = new Integer[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            actual[INDEX] = 100 + i;\n+        }\n+        var lazy = List.ofLazy(INDEX, IDENTITY);\n+        assertSame(actual, lazy.toArray(actual));\n+        Integer[] expected = IntStream.range(0, SIZE)\n+                .mapToObj(i -> i < INDEX ? i : null)\n+                .toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithArraySmaller() {\n+        Integer[] arr = new Integer[INDEX];\n+        Integer[] actual = newLazyList().toArray(arr);\n+        assertNotSame(arr, actual);\n+        Integer[] expected = newRegularList().toArray(new Integer[0]);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithGenerator() {\n+        Integer[] expected = newRegularList().toArray(Integer[]::new);\n+        Integer[] actual = newLazyList().toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void firstIndex() {\n+        var lazy = newLazyList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.indexOf(i));\n+        }\n+        assertEquals(-1, lazy.indexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void lastIndex() {\n+        var lazy = newLazyList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.lastIndexOf(i));\n+        }\n+        assertEquals(-1, lazy.lastIndexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"[]\", newEmptyLazyList().toString());\n+        var lazy = List.ofLazy(2, IDENTITY);\n+        assertEquals(\"[\" + LazyConstantTestUtil.UNINITIALIZED_TAG + \", \" + LazyConstantTestUtil.UNINITIALIZED_TAG + \"]\", lazy.toString());\n+        lazy.get(0);\n+        assertEquals(\"[0, \" + LazyConstantTestUtil.UNINITIALIZED_TAG + \"]\", lazy.toString());\n+        lazy.get(1);\n+        assertEquals(\"[0, 1]\", lazy.toString());\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(List.of().hashCode(), newEmptyLazyList().hashCode());\n+        assertEquals(newRegularList().hashCode(), newLazyList().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyLazyList().equals(List.of()));\n+        assertTrue(List.of().equals(newEmptyLazyList()));\n+        assertTrue(newLazyList().equals(newRegularList()));\n+        assertTrue(newRegularList().equals(newLazyList()));\n+        assertFalse(newLazyList().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void equalsPartialEvaluationTest() {\n+        var lazy = List.ofLazy(2, IDENTITY);\n+        assertFalse(lazy.equals(List.of(0)));\n+        assertEquals(\"[0, \" + LazyConstantTestUtil.UNINITIALIZED_TAG + \"]\", lazy.toString());\n+        assertTrue(lazy.equals(List.of(0, 1)));\n+        assertEquals(\"[0, 1]\", lazy.toString());\n+    }\n+\n+    @Test\n+    void iteratorTotal() {\n+        var iterator = newLazyList().iterator();\n+        for (int i = 0; i < SIZE; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(0, cnt.get());\n+    }\n+\n+    @Test\n+    void iteratorPartial() {\n+        var iterator = newLazyList().iterator();\n+        for (int i = 0; i < INDEX; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertTrue(iterator.hasNext());\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(SIZE - INDEX, cnt.get());\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+    }\n+\n+    @Test\n+    void subList() {\n+        var lazy = newLazyList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        assertInstanceOf(RandomAccess.class, lazySubList);\n+        var regularList = newRegularList();\n+        var regularSubList = regularList.subList(1, SIZE);\n+        assertEquals(regularSubList, lazySubList);\n+    }\n+\n+    @Test\n+    void subList2() {\n+        var lazy = newLazyList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        lazySubList.get(0);\n+        var eq = newLazyList();\n+        eq.get(1);\n+        assertEquals(eq.toString(), lazy.toString());\n+    }\n+\n+    void assertUnevaluated(List<Integer> subList) {\n+        assertEquals(asString(LazyConstantTestUtil.UNINITIALIZED_TAG, subList), subList.toString());\n+    }\n+\n+    @Test\n+    void reversed() {\n+        var lazy = newLazyList();\n+        var reversedLazy = lazy.reversed();\n+        assertInstanceOf(RandomAccess.class, reversedLazy);\n+        assertEquals(SIZE - 1, reversedLazy.getFirst());\n+        assertEquals(0, reversedLazy.getLast());\n+\n+        var reversed2Lazy = reversedLazy.reversed();\n+        assertInstanceOf(RandomAccess.class, reversed2Lazy);\n+        assertEquals(0, reversed2Lazy.getFirst());\n+        assertEquals(SIZE - 1, reversed2Lazy.getLast());\n+        \/\/ Make sure we get back a non-reversed implementation\n+        assertEquals(lazy.getClass().getName(), reversed2Lazy.getClass().getName());\n+    }\n+\n+    @Test\n+    void sublistReversedToString() {\n+        var actual = List.ofLazy(4, IDENTITY);\n+        var expected = List.of(0, 1, 2, 3);\n+        for (UnaryOperation op : List.of(\n+                new UnaryOperation(\"subList\", l -> l.subList(1, 3)),\n+                new UnaryOperation(\"reversed\", List::reversed))) {\n+            actual = op.apply(actual);\n+            expected = op.apply(expected);\n+        }\n+        \/\/ Touch one of the elements\n+        actual.getLast();\n+\n+        var actualToString = actual.toString();\n+        var expectedToString = expected.toString().replace(\"2\", LazyConstantTestUtil.UNINITIALIZED_TAG);\n+        assertEquals(expectedToString, actualToString);\n+    }\n+\n+    \/\/ This test makes sure successive view operations retains the property\n+    \/\/ of being a lazy view.\n+    @Test\n+    void lazyViews() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach( op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    var list = newLazyList();\n+                    var view1 = op0.apply(list);\n+                    var view2 = op1.apply(view1);\n+                    var view3 = op2.apply(view2);\n+                    var className3 = className(view3);\n+                    var transitions = className(list) + \", \" +\n+                            op0 + \" -> \" + className(view1) + \", \" +\n+                            op1 + \" -> \" + className(view2) + \", \" +\n+                            op2 + \" -> \" + className3;\n+                    assertTrue(className3.contains(\"Lazy\"), transitions);\n+                    assertUnevaluated(list);\n+                    assertUnevaluated(view1);\n+                    assertUnevaluated(view2);\n+                    assertUnevaluated(view3);\n+                });\n+            });\n+        });\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        AtomicReference<IntFunction<Integer>> ref = new AtomicReference<>();\n+        var lazy = List.ofLazy(SIZE, i -> ref.get().apply(i));\n+        ref.set(lazy::get);\n+        var x = assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n+        assertEquals(\"Recursive initialization of a lazy collection is illegal\", x.getMessage());\n+    }\n+\n+    \/\/ Immutability\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"outOfBoundsOperations\")\n+    void outOfBounds(Operation operation) {\n+        assertThrowsForOperation(IndexOutOfBoundsException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newLazyList();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+        var sub = lazy.subList(1, SIZE \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(sub));\n+        var subSub = sub.subList(1, sub.size() \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(subSub));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newLazyList());\n+        serializable(newEmptyLazyList());\n+    }\n+\n+    void serializable(List<Integer> list) {\n+        assertFalse(list instanceof Serializable);\n+        if (list.size()>INDEX) {\n+            assertFalse(newLazyList().subList(1, INDEX) instanceof Serializable);\n+        }\n+        assertFalse(list.iterator() instanceof Serializable);\n+        assertFalse(list.reversed() instanceof Serializable);\n+        assertFalse(list.spliterator() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void randomAccess() {\n+        assertInstanceOf(RandomAccess.class, newLazyList());\n+        assertInstanceOf(RandomAccess.class, newEmptyLazyList());\n+        assertInstanceOf(RandomAccess.class, newLazyList().subList(1, INDEX));\n+    }\n+\n+    @Test\n+    void childObjectOpsLazy() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach(op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    childOperations().forEach(co -> {\n+                        var list = newLazyList();\n+                        var view1 = op0.apply(list);\n+                        var view2 = op1.apply(view1);\n+                        var view3 = op2.apply(view2);\n+                        var child = co.apply(view3);\n+                        var childClassName = className(child);\n+                        var transitions = className(list) + \", \" +\n+                                op0 + \" -> \" + className(view1) + \", \" +\n+                                op1 + \" -> \" + className(view2) + \", \" +\n+                                op2 + \" -> \" + className(view3) + \", \" +\n+                                co + \" -> \" + childClassName;\n+\n+                        \/\/ None of these operations should trigger evaluation\n+                        var childToString = child.toString();\n+                        int childHashCode = child.hashCode();\n+                        boolean childEqualToNewObj = child.equals(new Object());\n+\n+                        assertUnevaluated(list);\n+                        assertUnevaluated(view1);\n+                        assertUnevaluated(view2);\n+                        assertUnevaluated(view3);\n+                    });\n+                });\n+            });\n+        });\n+    }\n+\n+    @Test\n+    void functionHolder() {\n+        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<>(IDENTITY);\n+        List<Integer> f1 = List.ofLazy(SIZE, cif);\n+\n+        Object holder = LazyConstantTestUtil.functionHolder(f1);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(SIZE - i, LazyConstantTestUtil.functionHolderCounter(holder));\n+            assertSame(cif, LazyConstantTestUtil.functionHolderFunction(holder));\n+            int v = f1.get(i);\n+            int v2 = f1.get(i);\n+        }\n+        assertEquals(0, LazyConstantTestUtil.functionHolderCounter(holder));\n+        assertNull(LazyConstantTestUtil.functionHolderFunction(holder));\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<List<Integer>> consumer) implements Consumer<List<Integer>> {\n+        @Override public void   accept(List<Integer> list) { consumer.accept(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    record UnaryOperation(String name,\n+                     UnaryOperator<List<Integer>> operator) implements UnaryOperator<List<Integer>> {\n+        @Override public List<Integer> apply(List<Integer> list) { return operator.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    record ListFunction(String name,\n+                        Function<List<Integer>, Object> function) implements Function<List<Integer>, Object> {\n+        @Override public Object apply(List<Integer> list) { return function.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<UnaryOperation> viewOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new UnaryOperation(\"identity\", l -> l),\n+                new UnaryOperation(\"reversed\", List::reversed),\n+                new UnaryOperation(\"subList\", l -> l.subList(0, l.size()))\n+        );\n+    }\n+\n+    static Stream<ListFunction> childOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new ListFunction(\"iterator\", List::iterator),\n+                new ListFunction(\"listIterator\", List::listIterator),\n+                new ListFunction(\"listIterator\", List::stream)\n+        );\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+                new Operation(\"forEach\",     l -> l.forEach(null)),\n+                new Operation(\"containsAll\", l -> l.containsAll(null)),\n+                new Operation(\"toArray\",     l -> l.toArray((Integer[]) null)),\n+                new Operation(\"toArray\",     l -> l.toArray((IntFunction<Integer[]>) null))\n+        );\n+    }\n+\n+    static Stream<Operation> outOfBoundsOperations() {\n+        return Stream.of(\n+                new Operation(\"get(-1)\",        l -> l.get(-1)),\n+                new Operation(\"get(size)\",      l -> l.get(l.size())),\n+                new Operation(\"sublist(-1,)\",   l -> l.subList(-1, INDEX)),\n+                new Operation(\"sublist(,size)\", l -> l.subList(0, l.size() + 1)),\n+                new Operation(\"listIter(-1)\",   l -> l.listIterator(-1)),\n+                new Operation(\"listIter(size)\", l -> l.listIterator(l.size() + 1))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        final Set<Integer> SET = Set.of(0, 1);\n+        return Stream.of(\n+                new Operation(\"add(0)\",            l -> l.add(0)),\n+                new Operation(\"add(0, 1)\",         l -> l.add(0, 1)),\n+                new Operation(\"addAll(col)\",       l -> l.addAll(SET)),\n+                new Operation(\"addAll(1, coll)\",   l -> l.addAll(1, SET)),\n+                new Operation(\"addFirst(0)\",       l -> l.addFirst(0)),\n+                new Operation(\"addLast(0)\",        l -> l.addLast(0)),\n+                new Operation(\"clear\",             List::clear),\n+                new Operation(\"remove(Obj)\",       l -> l.remove((Object)1)),\n+                new Operation(\"remove(1)\",         l -> l.remove(1)),\n+                new Operation(\"removeAll\",         l -> l.removeAll(SET)),\n+                new Operation(\"removeFirst\",       List::removeFirst),\n+                new Operation(\"removeLast\",        List::removeLast),\n+                new Operation(\"removeIf\",          l -> l.removeIf(i -> i % 2 == 0)),\n+                new Operation(\"replaceAll\",        l -> l.replaceAll(i -> i + 1)),\n+                new Operation(\"sort\",              l -> l.sort(Comparator.naturalOrder())),\n+                new Operation(\"iterator().remove\", l -> l.iterator().remove()),\n+                new Operation(\"listIter().remove\", l -> l.listIterator().remove()),\n+                new Operation(\"listIter().add\",    l -> l.listIterator().add(1)),\n+                new Operation(\"listIter().set\",    l -> l.listIterator().set(1))\n+        );\n+    }\n+\n+    static List<Integer> newLazyList() {\n+        return List.ofLazy(SIZE, IDENTITY);\n+    }\n+\n+    static List<Integer> newEmptyLazyList() {\n+        return List.ofLazy(ZERO, IDENTITY);\n+    }\n+\n+    static List<Integer> newRegularList() {\n+        return IntStream.range(0, SIZE).boxed().toList();\n+    }\n+\n+    static String asString(String first, List<Integer> list) {\n+        return \"[\" + first + \", \" + Stream.generate(() -> LazyConstantTestUtil.UNINITIALIZED_TAG)\n+                .limit(list.size() - 1)\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    static String className(Object o) {\n+        return o.getClass().getName();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyListTest.java","additions":523,"deletions":0,"binary":false,"changes":523,"status":"added"},{"patch":"@@ -0,0 +1,593 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for lazy map methods\n+ * @enablePreview\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED LazyMapTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class LazyMapTest {\n+\n+    enum Value {\n+        \/\/ Zero is here so that we have enums with ordinals before the first one\n+        \/\/ actually used in input sets (i.e. ZERO is not in the input set)\n+        ZERO(0),\n+        ILLEGAL_BEFORE(-1),\n+        \/\/ Valid values\n+        THIRTEEN(13) {\n+            @Override\n+            public String toString() {\n+                \/\/ getEnumConstants will be `null` for this enum as it is overridden\n+                return super.toString()+\" (Overridden)\";\n+            }\n+        },\n+        ILLEGAL_BETWEEN(-2),\n+        FORTY_TWO(42),\n+        \/\/ Illegal values (not in the input set)\n+        ILLEGAL_AFTER(-3);\n+\n+        final int intValue;\n+\n+        Value(int intValue) {\n+            this.intValue = intValue;\n+        }\n+\n+        int asInt() {\n+            return intValue;\n+        }\n+\n+    }\n+\n+    private static final Function<Value, Integer> MAPPER = Value::asInt;\n+\n+    private static final Value KEY = Value.FORTY_TWO;\n+    private static final Integer VALUE = MAPPER.apply(KEY);\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void factoryInvariants(Set<Value> set) {\n+        assertThrows(NullPointerException.class, () -> Map.ofLazy(set, null), set.getClass().getSimpleName());\n+        assertThrows(NullPointerException.class, () -> Map.ofLazy(null, MAPPER));\n+        Set<Value> setWithNull = new HashSet<>();\n+        setWithNull.add(KEY);\n+        setWithNull.add(null);\n+        assertThrows(NullPointerException.class, () -> Map.ofLazy(setWithNull, MAPPER));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"emptySets\")\n+    void empty(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        assertTrue(lazy.isEmpty());\n+        assertEquals(\"{}\", lazy.toString());\n+        assertThrows(NullPointerException.class, () -> lazy.get(null));\n+        assertNotEquals(null, lazy);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void size(Set<Value> set) {\n+        assertEquals(newRegularMap(set).size(), newLazyMap(set).size());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void get(Set<Value> set) {\n+        LazyConstantTestUtil.CountingFunction<Value, Integer> cf = new LazyConstantTestUtil.CountingFunction<>(MAPPER);\n+        var lazy = Map.ofLazy(set, cf);\n+        int cnt = 1;\n+        for (Value v : set) {\n+            assertEquals(MAPPER.apply(v), lazy.get(v));\n+            assertEquals(cnt, cf.cnt());\n+            assertEquals(MAPPER.apply(v), lazy.get(v));\n+            assertEquals(cnt++, cf.cnt());\n+        }\n+        assertNull(lazy.get(Value.ILLEGAL_BETWEEN));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void exception(Set<Value> set) {\n+        LazyConstantTestUtil.CountingFunction<Value, Integer> cif = new LazyConstantTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = Map.ofLazy(set, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(2, cif.cnt());\n+        var toString = lazy.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n+        assertTrue(toString.endsWith(\"}\"));\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void containsKey(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        for (Value v : set) {\n+            assertTrue(lazy.containsKey(v));\n+        }\n+        assertFalse(lazy.containsKey(Value.ILLEGAL_BETWEEN));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void containsValue(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        for (Value v : set) {\n+            assertTrue(lazy.containsValue(MAPPER.apply(v)));\n+        }\n+        assertFalse(lazy.containsValue(MAPPER.apply(Value.ILLEGAL_BETWEEN)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void forEach(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var ref = newRegularMap(set);\n+        Set<Map.Entry<Value, Integer>> expected = ref.entrySet();\n+        Set<Map.Entry<Value, Integer>> actual = new HashSet<>();\n+        lazy.forEach((k, v) -> actual.add(new AbstractMap.SimpleImmutableEntry<>(k , v)));\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"emptySets\")\n+    void toStringTestEmpty(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        assertEquals(\"{}\", lazy.toString());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void toStringTest(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var toString = lazy.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        assertTrue(toString.endsWith(\"}\"));\n+\n+        \/\/ Key order is unspecified\n+        for (Value key : set) {\n+            toString = lazy.toString();\n+            assertTrue(toString.contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG), toString + \" did not contain \" + key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG);\n+            lazy.get(key);\n+            toString = lazy.toString();\n+            assertTrue(toString.contains(key + \"=\" + MAPPER.apply(key)), toString);\n+        }\n+\n+        \/\/ One between the values\n+        assertEquals(set.size() - 1, toString.chars().filter(ch -> ch == ',').count());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void hashCodeTest(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var regular = newRegularMap(set);\n+        assertEquals(regular.hashCode(), lazy.hashCode());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void equality(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var regular = newRegularMap(set);\n+        assertEquals(regular, lazy);\n+        assertEquals(lazy, regular);\n+        assertNotEquals(\"A\", lazy);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void circular(Set<Value> set) {\n+        final AtomicReference<Map<?, ?>> ref = new AtomicReference<>();\n+        Map<Value, Map<?, ?>> lazy = Map.ofLazy(set, _ -> ref.get());\n+        ref.set(lazy);\n+        lazy.get(KEY);\n+        var toString = lazy.toString();\n+        assertTrue(toString.contains(\"FORTY_TWO=(this Map)\"), toString);\n+        assertDoesNotThrow((() -> lazy.equals(lazy)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void recursiveCall(Set<Value> set) {\n+        final AtomicReference<Map<Value, ?>> ref = new AtomicReference<>();\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Value, Map<Value, Object>> lazy = Map.ofLazy(set, k -> (Map<Value, Object>) ref.get().get(k));\n+        ref.set(lazy);\n+        var x = assertThrows(IllegalStateException.class, () -> lazy.get(KEY));\n+        assertEquals(\"Recursive initialization of a lazy collection is illegal\", x.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void entrySet(Set<Value> set) {\n+        var lazy = newLazyMap(set).entrySet();\n+        var regular = newRegularMap(set).entrySet();\n+        assertTrue(regular.equals(lazy));\n+        assertTrue(lazy.equals(regular));\n+        assertTrue(regular.equals(lazy));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void entrySetToString(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var lazyEntrySet = lazy.entrySet();\n+        var toString = lazyEntrySet.toString();\n+        for (var key : set) {\n+            assertTrue(toString.contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n+        }\n+        assertTrue(toString.startsWith(\"[\"));\n+        assertTrue(toString.endsWith(\"]\"));\n+\n+        lazy.get(KEY);\n+        for (var key : set) {\n+            if (key.equals(KEY)) {\n+                continue;\n+            }\n+            assertTrue(lazyEntrySet.toString().contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n+        }\n+        assertTrue(lazyEntrySet.toString().contains(KEY + \"=\" + VALUE));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void values(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var lazyValues = lazy.values();\n+        \/\/ Look at one of the elements\n+        var val = lazyValues.stream().iterator().next();\n+        var toString = lazy.toString();\n+        for (var key : set) {\n+            var v = MAPPER.apply(key);\n+            if (v.equals(val)) {\n+                assertTrue(toString.contains(key + \"=\" + v));\n+            } else {\n+                assertTrue(toString.contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n+            }\n+        }\n+\n+        \/\/ Mod ops\n+        assertThrows(UnsupportedOperationException.class, () -> lazyValues.remove(val));\n+        assertThrows(UnsupportedOperationException.class, () -> lazyValues.add(val));\n+        assertThrows(UnsupportedOperationException.class, lazyValues::clear);\n+        assertThrows(UnsupportedOperationException.class, () -> lazyValues.addAll(Set.of(VALUE)));\n+        assertThrows(UnsupportedOperationException.class, () -> lazyValues.removeIf(i -> true));\n+        assertThrows(UnsupportedOperationException.class, () -> lazyValues.retainAll(Set.of(VALUE)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void valuesToString(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var lazyValues = lazy.values();\n+        var expected = set.stream()\n+                .map(_ -> LazyConstantTestUtil.UNINITIALIZED_TAG)\n+                .collect(joining(\", \", \"[\", \"]\"));\n+        assertEquals(expected, lazyValues.toString());\n+        lazy.get(KEY);\n+        var afterGet = lazyValues.toString();\n+        assertEquals(set.contains(KEY), afterGet.contains(\"\" + VALUE), afterGet);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void iteratorNext(Set<Value> set) {\n+        Set<Value> encountered = new HashSet<>();\n+        var iterator = newLazyMap(set).entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            var entry = iterator.next();\n+            assertEquals(MAPPER.apply(entry.getKey()), entry.getValue());\n+            encountered.add(entry.getKey());\n+        }\n+        assertEquals(set, encountered);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void iteratorForEachRemaining(Set<Value> set) {\n+        Set<Value> encountered = new HashSet<>();\n+        var iterator = newLazyMap(set).entrySet().iterator();\n+        var entry = iterator.next();\n+        assertEquals(MAPPER.apply(entry.getKey()), entry.getValue());\n+        encountered.add(entry.getKey());\n+        iterator.forEachRemaining(e -> {\n+            assertEquals(MAPPER.apply(e.getKey()), e.getValue());\n+            encountered.add(e.getKey());\n+        });\n+        assertEquals(set, encountered);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void lazyEntry(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        var entry = lazy.entrySet().stream()\n+                .filter(e -> e.getKey().equals(KEY))\n+                .findAny()\n+                .orElseThrow();\n+\n+        assertEquals(KEY + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG, entry.toString());\n+        var otherDifferent = Map.entry(Value.ZERO, -1);\n+        assertNotEquals(entry, otherDifferent);\n+        assertEquals(KEY + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG, entry.toString());\n+        var otherEqual = Map.entry(entry.getKey(), entry.getValue());\n+        assertEquals(entry, otherEqual);\n+        assertEquals(KEY + \"=\" + VALUE, entry.toString());\n+        assertEquals(entry.hashCode(), otherEqual.hashCode());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void lazyForEachEntry(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        \/\/ Only touch the key.\n+        lazy.entrySet().iterator().forEachRemaining(Map.Entry::getKey);\n+        lazy.entrySet().iterator()\n+                .forEachRemaining(e -> assertTrue(e.toString().contains(LazyConstantTestUtil.UNINITIALIZED_TAG)));\n+        \/\/ Only touch the value.\n+        lazy.entrySet().iterator().forEachRemaining(Map.Entry::getValue);\n+        lazy.entrySet().iterator()\n+                .forEachRemaining(e -> assertFalse(e.toString().contains(LazyConstantTestUtil.UNINITIALIZED_TAG)));\n+    }\n+\n+    \/\/ Immutability\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        for (Set<Value> set : allSets().toList()) {\n+            var lazy = newLazyMap(set);\n+            assertThrows(expectedType, () -> operation.accept(lazy), set.getClass().getSimpleName() + \" \" + operation);\n+        }\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void serializable(Set<Value> set) {\n+        var lazy = newLazyMap(set);\n+        assertFalse(lazy instanceof Serializable);\n+        assertFalse(lazy.entrySet() instanceof Serializable);\n+        assertFalse(lazy.values() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void nullResult() {\n+        var lazy = Map.ofLazy(Set.of(0), _ -> null);\n+        assertThrows(NullPointerException.class, () -> lazy.getOrDefault(0, 1));;\n+        assertTrue(lazy.containsKey(0));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void functionHolder(Set<Value> set) {\n+        LazyConstantTestUtil.CountingFunction<Value, Integer> cif = new LazyConstantTestUtil.CountingFunction<>(MAPPER);\n+        Map<Value, Integer> lazy = Map.ofLazy(set, cif);\n+\n+        Object holder = LazyConstantTestUtil.functionHolder(lazy);\n+\n+        int i = 0;\n+        for (Value key : set) {\n+            assertEquals(set.size() - i, LazyConstantTestUtil.functionHolderCounter(holder));\n+            assertSame(cif, LazyConstantTestUtil.functionHolderFunction(holder));\n+            int v = lazy.get(key);\n+            int v2 = lazy.get(key);\n+            i++;\n+        }\n+        assertEquals(0, LazyConstantTestUtil.functionHolderCounter(holder));\n+        assertNull(LazyConstantTestUtil.functionHolderFunction(holder));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void functionHolderViaEntrySet(Set<Value> set) {\n+        LazyConstantTestUtil.CountingFunction<Value, Integer> cif = new LazyConstantTestUtil.CountingFunction<>(MAPPER);\n+        Map<Value, Integer> lazy = Map.ofLazy(set, cif);\n+\n+        Object holder = LazyConstantTestUtil.functionHolder(lazy);\n+\n+        int i = 0;\n+        for (Map.Entry<Value, Integer> e : lazy.entrySet()) {\n+            assertEquals(set.size() - i, LazyConstantTestUtil.functionHolderCounter(holder));\n+            assertSame(cif, LazyConstantTestUtil.functionHolderFunction(holder));\n+            int v = e.getValue();\n+            int v2 = e.getValue();\n+            i++;\n+        }\n+        assertEquals(0, LazyConstantTestUtil.functionHolderCounter(holder));\n+        assertNull(LazyConstantTestUtil.functionHolderFunction(holder));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void underlyingRefViaEntrySetForEach(Set<Value> set) {\n+        LazyConstantTestUtil.CountingFunction<Value, Integer> cif = new LazyConstantTestUtil.CountingFunction<>(MAPPER);\n+        Map<Value, Integer> lazy = Map.ofLazy(set, cif);\n+\n+        Object holder = LazyConstantTestUtil.functionHolder(lazy);\n+\n+        final AtomicInteger i = new AtomicInteger();\n+        lazy.entrySet().forEach(e -> {\n+            assertEquals(set.size() - i.get(), LazyConstantTestUtil.functionHolderCounter(holder));\n+            assertSame(cif, LazyConstantTestUtil.functionHolderFunction(holder));\n+            Integer val = e.getValue();\n+            Integer val2 = e.getValue();\n+            i.incrementAndGet();\n+        });\n+        assertEquals(0, LazyConstantTestUtil.functionHolderCounter(holder));\n+        assertNull(LazyConstantTestUtil.functionHolderFunction(holder));\n+    }\n+\n+    @Test\n+    void usesOptimizedVersion() {\n+        Map<Value, Integer> enumMap = Map.ofLazy(EnumSet.of(KEY), Value::asInt);\n+        assertTrue(enumMap.getClass().getName().contains(\"Enum\"), enumMap.getClass().getName());\n+        Map<Value, Integer> emptyMap = Map.ofLazy(EnumSet.noneOf(Value.class), Value::asInt);\n+        assertFalse(emptyMap.getClass().getName().contains(\"Enum\"), emptyMap.getClass().getName());\n+        Map<Value, Integer> regularMap = Map.ofLazy(Set.of(KEY), Value::asInt);\n+        assertFalse(regularMap.getClass().getName().contains(\"Enum\"), regularMap.getClass().getName());\n+    }\n+\n+    @Test\n+    void overriddenEnum() {\n+        final var overridden = Value.THIRTEEN;\n+        Map<Value, Integer> enumMap = Map.ofLazy(EnumSet.of(overridden), MAPPER);\n+        assertEquals(MAPPER.apply(overridden), enumMap.get(overridden), enumMap.toString());\n+    }\n+\n+    @Test\n+    void enumAliasing() {\n+        enum MyEnum {FOO, BAR}\n+        enum MySecondEnum{BAZ, QUX}\n+        Map<MyEnum, Integer> mapEnum = Map.ofLazy(EnumSet.allOf(MyEnum.class), MyEnum::ordinal);\n+        assertEquals(MyEnum.BAR.ordinal(), mapEnum.get(MyEnum.BAR));\n+        \/\/ Make sure class is checked, not just `ordinal()`\n+        assertNull(mapEnum.get(MySecondEnum.QUX));\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<Map<Value, Integer>> consumer) implements Consumer<Map<Value, Integer>> {\n+        @java.lang.Override\n+        public void accept(Map<Value, Integer> map) { consumer.accept(map); }\n+        @java.lang.Override\n+        public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+            new Operation(\"forEach\",     m -> m.forEach(null))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        return Stream.of(\n+            new Operation(\"clear\",             Map::clear),\n+            new Operation(\"compute\",           m -> m.compute(KEY, (_, _) -> 1)),\n+            new Operation(\"computeIfAbsent\",   m -> m.computeIfAbsent(KEY, _ -> 1)),\n+            new Operation(\"computeIfPresent\",  m -> m.computeIfPresent(KEY, (_, _) -> 1)),\n+            new Operation(\"merge\",             m -> m.merge(KEY, VALUE, (a, _) -> a)),\n+            new Operation(\"put\",               m -> m.put(KEY, 0)),\n+            new Operation(\"putAll\",            m -> m.putAll(Map.of())),\n+            new Operation(\"remove1\",           m -> m.remove(KEY)),\n+            new Operation(\"remove2\",           m -> m.remove(KEY, VALUE)),\n+            new Operation(\"replace2\",          m -> m.replace(KEY, 1)),\n+            new Operation(\"replace3\",          m -> m.replace(KEY, VALUE, 1)),\n+            new Operation(\"replaceAll\",        m -> m.replaceAll((a, _) -> MAPPER.apply(a)))\n+        );\n+    }\n+\n+\n+    static Map<Value, Integer> newLazyMap(Set<Value> set) {\n+        return Map.ofLazy(set, MAPPER);\n+    }\n+    static Map<Value, Integer> newRegularMap(Set<Value> set) {\n+        return set.stream()\n+                .collect(Collectors.toMap(Function.identity(), MAPPER));\n+    }\n+\n+    private static Stream<Set<Value>> nonEmptySets() {\n+        return Stream.of(\n+                Set.of(KEY, Value.THIRTEEN),\n+                linkedHashSet(Value.THIRTEEN, KEY),\n+                treeSet(KEY, Value.THIRTEEN),\n+                EnumSet.of(KEY, Value.THIRTEEN)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> emptySets() {\n+        return Stream.of(\n+                Set.of(),\n+                linkedHashSet(),\n+                treeSet(),\n+                EnumSet.noneOf(Value.class)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> allSets() {\n+        return Stream.concat(\n+                nonEmptySets(),\n+                emptySets()\n+        );\n+    }\n+\n+    static Set<Value> treeSet(Value... values) {\n+        return populate(new TreeSet<>(Comparator.comparingInt(Value::asInt).reversed()),values);\n+    }\n+\n+    static Set<Value> linkedHashSet(Value... values) {\n+        return populate(new LinkedHashSet<>(), values);\n+    }\n+\n+    static Set<Value> populate(Set<Value> set, Value... values) {\n+        set.addAll(Arrays.asList(values));\n+        return set;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyMapTest.java","additions":593,"deletions":0,"binary":false,"changes":593,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for TrustedFieldType implementations\n+ * @modules jdk.unsupported\/sun.misc\n+ * @modules java.base\/jdk.internal.lang\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n+ * @run junit\/othervm -Dopens=false TrustedFieldTypeTest\n+ *\/\n+\n+import jdk.internal.lang.LazyConstantImpl;\n+import jdk.internal.misc.Unsafe;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n+import java.lang.LazyConstant;\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TrustedFieldTypeTest {\n+\n+    private static final int VALUE = 42;\n+    private static final Supplier<Integer> SUPPLIER = () -> VALUE;\n+\n+    @Test\n+    void varHandle() throws NoSuchFieldException, IllegalAccessException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        LazyConstant<Integer> originalValue = LazyConstant.of(SUPPLIER);\n+        @SuppressWarnings(\"unchecked\")\n+        LazyConstant<Integer>[] originalArrayValue = new LazyConstant[10];\n+\n+        final class Holder {\n+            private final LazyConstant<Integer> value = originalValue;\n+        }\n+        final class ArrayHolder {\n+            private final LazyConstant<Integer>[] array = originalArrayValue;\n+        }\n+\n+\n+        VarHandle valueVarHandle = lookup.findVarHandle(Holder.class, \"value\", LazyConstant.class);\n+        Holder holder = new Holder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.set(holder, LazyConstant.of(SUPPLIER))\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.compareAndSet(holder, originalValue, LazyConstant.of(SUPPLIER))\n+        );\n+\n+        VarHandle arrayVarHandle = lookup.findVarHandle(ArrayHolder.class, \"array\", LazyConstant[].class);\n+        ArrayHolder arrayHolder = new ArrayHolder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.set(arrayHolder, new LazyConstant[1])\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.compareAndSet(arrayHolder, originalArrayValue, new LazyConstant[1])\n+        );\n+\n+    }\n+\n+    @Test\n+    void updateComputedConstantContentVia_j_i_m_Unsafe() {\n+        LazyConstant<Integer> lazyConstant = LazyConstant.of(SUPPLIER);\n+        lazyConstant.get();\n+        jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        long offset = unsafe.objectFieldOffset(lazyConstant.getClass(), \"constant\");\n+        assertTrue(offset > 0);\n+\n+        \/\/ Unfortunately, it is possible to update the underlying data via jdk.internal.misc.Unsafe\n+        Object oldData = unsafe.getAndSetReference(lazyConstant, offset, 13);\n+        assertEquals(VALUE, oldData);\n+        assertEquals(13, lazyConstant.get());\n+    }\n+\n+    @Test\n+    void updateComputedConstantContentViaSetAccessible() throws NoSuchFieldException, IllegalAccessException {\n+\n+        if (Boolean.getBoolean(\"opens\")) {\n+            \/\/ Unfortunately, add-opens allows direct access to the `value` field\n+            Field field = LazyConstantImpl.class.getDeclaredField(\"constant\");\n+            field.setAccessible(true);\n+\n+            LazyConstant<Integer> lazyConstant = LazyConstant.of(SUPPLIER);\n+            lazyConstant.get();\n+\n+            Object oldData = field.get(lazyConstant);\n+            assertEquals(VALUE, oldData);\n+\n+            field.set(lazyConstant, 13);\n+            assertEquals(13, lazyConstant.get());\n+        } else {\n+            Field field = LazyConstantImpl.class.getDeclaredField(\"constant\");\n+            assertThrows(InaccessibleObjectException.class, ()-> field.setAccessible(true));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/TrustedFieldTypeTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -1,250 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableFunction methods\n- * @enablePreview\n- * @run junit StableFunctionTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableFunctionTest {\n-\n-    enum Value {\n-        \/\/ Zero is here so that we have enums with ordinals before the first one\n-        \/\/ actually used in input sets (i.e. ZERO is not in the input set)\n-        ZERO(0),\n-        ILLEGAL_BEFORE(-1),\n-        \/\/ Valid values\n-        THIRTEEN(13) {\n-            @Override\n-            public String toString() {\n-                \/\/ getEnumConstants will be `null` for this enum as it is overridden\n-                return super.toString()+\" (Overridden)\";\n-            }\n-        },\n-        ILLEGAL_BETWEEN(-2),\n-        FORTY_TWO(42),\n-        \/\/ Illegal values (not in the input set)\n-        ILLEGAL_AFTER(-3);\n-\n-        final int intValue;\n-\n-        Value(int intValue) {\n-            this.intValue = intValue;\n-        }\n-\n-        int asInt() {\n-            return intValue;\n-        }\n-\n-    }\n-\n-    private static final Function<Value, Integer> MAPPER = Value::asInt;\n-\n-    @ParameterizedTest\n-    @MethodSource(\"allSets\")\n-    void factoryInvariants(Set<Value> inputs) {\n-        assertThrows(NullPointerException.class, () -> StableValue.function(null, MAPPER));\n-        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, null));\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"nonEmptySets\")\n-    void basic(Set<Value> inputs) {\n-        basic(inputs, MAPPER);\n-        toStringTest(inputs, MAPPER);\n-        basic(inputs, _ -> null);\n-        toStringTest(inputs, _ -> null);\n-    }\n-\n-    void basic(Set<Value> inputs, Function<Value, Integer> mapper) {\n-        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(mapper);\n-        var cached = StableValue.function(inputs, cif);\n-        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n-        assertEquals(1, cif.cnt());\n-        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n-        assertEquals(1, cif.cnt());\n-        var x0 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BEFORE));\n-        assertEquals(\"Input not allowed: ILLEGAL_BEFORE\", x0.getMessage());\n-        var x1 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BETWEEN));\n-        assertEquals(\"Input not allowed: ILLEGAL_BETWEEN\", x1.getMessage());\n-        var x2 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_AFTER));\n-        assertEquals(\"Input not allowed: ILLEGAL_AFTER\", x2.getMessage());\n-    }\n-\n-    void toStringTest(Set<Value> inputs, Function<Value, Integer> mapper) {\n-        var cached = StableValue.function(inputs, mapper);\n-        cached.apply(Value.FORTY_TWO);\n-        var toString = cached.toString();\n-        assertTrue(toString.startsWith(\"{\"));\n-        \/\/ Key order is unspecified\n-        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n-        assertTrue(toString.contains(Value.FORTY_TWO + \"=\" + mapper.apply(Value.FORTY_TWO)));\n-        assertTrue(toString.endsWith(\"}\"));\n-        \/\/ One between the values\n-        assertEquals(1L, toString.chars().filter(ch -> ch == ',').count());\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"emptySets\")\n-    void empty(Set<Value> inputs) {\n-        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n-        Function<Value, Integer> f1 = StableValue.function(inputs, Value::asInt);\n-        assertEquals(\"{}\", f0.toString());\n-        assertThrows(NullPointerException.class, () -> f0.apply(null));\n-        assertNotEquals(f0, f1);\n-        assertNotEquals(null, f0);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"nonEmptySets\")\n-    void exception(Set<Value> inputs) {\n-        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(_ -> {\n-            throw new UnsupportedOperationException();\n-        });\n-        var cached = StableValue.function(inputs, cif);\n-        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n-        assertEquals(1, cif.cnt());\n-        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n-        assertEquals(2, cif.cnt());\n-        var toString = cached.toString();\n-        assertTrue(toString.startsWith(\"{\"));\n-        \/\/ Key order is unspecified\n-        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n-        assertTrue(toString.contains(Value.FORTY_TWO + \"=.unset\"));\n-        assertTrue(toString.endsWith(\"}\"));\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"nonEmptySets\")\n-    void circular(Set<Value> inputs) {\n-        final AtomicReference<Function<?, ?>> ref = new AtomicReference<>();\n-        Function<Value, Function<?, ?>> cached = StableValue.function(inputs, _ -> ref.get());\n-        ref.set(cached);\n-        cached.apply(Value.FORTY_TWO);\n-        var toString = cached.toString();\n-        assertTrue(toString.contains(\"FORTY_TWO=(this StableFunction)\"), toString);\n-        assertDoesNotThrow(cached::hashCode);\n-        assertDoesNotThrow((() -> cached.equals(cached)));\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"allSets\")\n-    void equality(Set<Value> inputs) {\n-        Function<Value, Integer> mapper = Value::asInt;\n-        Function<Value, Integer> f0 = StableValue.function(inputs, mapper);\n-        Function<Value, Integer> f1 = StableValue.function(inputs, mapper);\n-        \/\/ No function is equal to another function\n-        assertNotEquals(f0, f1);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"allSets\")\n-    void hashCodeStable(Set<Value> inputs) {\n-        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n-        assertEquals(System.identityHashCode(f0), f0.hashCode());\n-        if (!inputs.isEmpty()) {\n-            f0.apply(Value.FORTY_TWO);\n-            assertEquals(System.identityHashCode(f0), f0.hashCode());\n-        }\n-    }\n-\n-    @Test\n-    void nullKeys() {\n-        Set<Value> inputs = new HashSet<>();\n-        inputs.add(Value.FORTY_TWO);\n-        inputs.add(null);\n-        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, MAPPER));\n-    }\n-\n-    @Test\n-    void usesOptimizedVersion() {\n-        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(Value.FORTY_TWO), Value::asInt);\n-        assertEquals(\"jdk.internal.lang.stable.StableEnumFunction\", enumFunction.getClass().getName());\n-        Function<Value, Integer> emptyFunction = StableValue.function(Set.of(), Value::asInt);\n-        assertEquals(\"jdk.internal.lang.stable.StableFunction\", emptyFunction.getClass().getName());\n-    }\n-\n-    @Test\n-    void overriddenEnum() {\n-        final var overridden = Value.THIRTEEN;\n-        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(overridden), Value::asInt);\n-        assertEquals(MAPPER.apply(overridden), enumFunction.apply(overridden));\n-    }\n-\n-    private static Stream<Set<Value>> nonEmptySets() {\n-        return Stream.of(\n-                Set.of(Value.FORTY_TWO, Value.THIRTEEN),\n-                linkedHashSet(Value.THIRTEEN, Value.FORTY_TWO),\n-                treeSet(Value.FORTY_TWO, Value.THIRTEEN),\n-                EnumSet.of(Value.FORTY_TWO, Value.THIRTEEN)\n-        );\n-    }\n-\n-    private static Stream<Set<Value>> emptySets() {\n-        return Stream.of(\n-                Set.of(),\n-                linkedHashSet(),\n-                treeSet(),\n-                EnumSet.noneOf(Value.class)\n-        );\n-    }\n-\n-    private static Stream<Set<Value>> allSets() {\n-        return Stream.concat(\n-                nonEmptySets(),\n-                emptySets()\n-        );\n-    }\n-\n-    static Set<Value> treeSet(Value... values) {\n-        return populate(new TreeSet<>(Comparator.comparingInt(Value::asInt).reversed()),values);\n-    }\n-\n-    static Set<Value> linkedHashSet(Value... values) {\n-        return populate(new LinkedHashSet<>(), values);\n-    }\n-\n-    static Set<Value> populate(Set<Value> set, Value... values) {\n-        set.addAll(Arrays.asList(values));\n-        return set;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":0,"deletions":250,"binary":false,"changes":250,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableIntFunction methods\n- * @enablePreview\n- * @run junit StableIntFunctionTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.IntFunction;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableIntFunctionTest {\n-\n-    private static final int SIZE = 2;\n-    private static final IntFunction<Integer> MAPPER = i -> i;\n-\n-    @Test\n-    void factoryInvariants() {\n-        assertThrows(IllegalArgumentException.class, () -> StableValue.intFunction(-1, MAPPER));\n-        assertThrows(NullPointerException.class, () -> StableValue.intFunction(SIZE, null));\n-    }\n-\n-    @Test\n-    void basic() {\n-        basic(MAPPER);\n-        basic(i -> null);\n-    }\n-\n-    void basic(IntFunction<Integer> mapper) {\n-        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(mapper);\n-        var cached = StableValue.intFunction(SIZE, cif);\n-        assertEquals(\"[.unset, .unset]\", cached.toString());\n-        assertEquals(mapper.apply(1), cached.apply(1));\n-        assertEquals(1, cif.cnt());\n-        assertEquals(mapper.apply(1), cached.apply(1));\n-        assertEquals(1, cif.cnt());\n-        assertEquals(\"[.unset, \" + mapper.apply(1) + \"]\", cached.toString());\n-        assertThrows(IllegalArgumentException.class, () -> cached.apply(SIZE));\n-        assertThrows(IllegalArgumentException.class, () -> cached.apply(-1));\n-        assertThrows(IllegalArgumentException.class, () -> cached.apply(1_000_000));\n-    }\n-\n-    @Test\n-    void exception() {\n-        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n-            throw new UnsupportedOperationException();\n-        });\n-        var cached = StableValue.intFunction(SIZE, cif);\n-        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n-        assertEquals(1, cif.cnt());\n-        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n-        assertEquals(2, cif.cnt());\n-        assertEquals(\"[.unset, .unset]\", cached.toString());\n-    }\n-\n-    @Test\n-    void circular() {\n-        final AtomicReference<IntFunction<?>> ref = new AtomicReference<>();\n-        IntFunction<IntFunction<?>> cached = StableValue.intFunction(SIZE, _ -> ref.get());\n-        ref.set(cached);\n-        cached.apply(0);\n-        String toString = cached.toString();\n-        assertEquals(\"[(this StableIntFunction), .unset]\", toString);\n-        assertDoesNotThrow(cached::hashCode);\n-        assertDoesNotThrow((() -> cached.equals(cached)));\n-    }\n-\n-    @Test\n-    void equality() {\n-        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n-        IntFunction<Integer> f1 = StableValue.intFunction(8, MAPPER);\n-        \/\/ No function is equal to another function\n-        assertNotEquals(f0, f1);\n-    }\n-\n-    @Test\n-    void hashCodeStable() {\n-        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n-        assertEquals(System.identityHashCode(f0), f0.hashCode());\n-        f0.apply(4);\n-        assertEquals(System.identityHashCode(f0), f0.hashCode());\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,540 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableList methods\n- * @modules java.base\/jdk.internal.lang.stable\n- * @enablePreview\n- * @run junit StableListTest\n- *\/\n-\n-import jdk.internal.lang.stable.StableUtil;\n-import jdk.internal.lang.stable.StableValueImpl;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.io.Serializable;\n-import java.util.Comparator;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.RandomAccess;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n-import java.util.function.UnaryOperator;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableListTest {\n-\n-    private static final int ZERO = 0;\n-    private static final int INDEX = 7;\n-    private static final int SIZE = 31;\n-    private static final IntFunction<Integer> IDENTITY = i -> i;\n-\n-    @Test\n-    void factoryInvariants() {\n-        assertThrows(NullPointerException.class, () -> StableValue.list(SIZE, null));\n-        assertThrows(IllegalArgumentException.class, () -> StableValue.list(-1, IDENTITY));\n-    }\n-\n-    @Test\n-    void isEmpty() {\n-        assertFalse(newList().isEmpty());\n-        assertTrue(newEmptyList().isEmpty());\n-    }\n-\n-    @Test\n-    void size() {\n-        assertEquals(SIZE, newList().size());\n-        assertEquals(ZERO, newEmptyList().size());\n-    }\n-\n-    @Test\n-    void get() {\n-        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(IDENTITY);\n-        var lazy = StableValue.list(SIZE, cif);\n-        for (int i = 0; i < SIZE; i++) {\n-            assertEquals(i, lazy.get(i));\n-            assertEquals(i + 1, cif.cnt());\n-            assertEquals(i, lazy.get(i));\n-            assertEquals(i + 1, cif.cnt());\n-        }\n-    }\n-\n-    @Test\n-    void getException() {\n-        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n-            throw new UnsupportedOperationException();\n-        });\n-        var lazy = StableValue.list(SIZE, cif);\n-        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n-        assertEquals(1, cif.cnt());\n-        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n-        assertEquals(2, cif.cnt());\n-    }\n-\n-    @Test\n-    void toArray() {\n-        assertArrayEquals(new Object[ZERO], newEmptyList().toArray());\n-        assertArrayEquals(newRegularList().toArray(), newList().toArray());\n-    }\n-\n-    @Test\n-    void toArrayWithArrayLarger() {\n-        Integer[] actual = new Integer[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            actual[INDEX] = 100 + i;\n-        }\n-        var list = StableValue.list(INDEX, IDENTITY);\n-        assertSame(actual, list.toArray(actual));\n-        Integer[] expected = IntStream.range(0, SIZE)\n-                .mapToObj(i -> i < INDEX ? i : null)\n-                .toArray(Integer[]::new);\n-        assertArrayEquals(expected, actual);\n-    }\n-\n-    @Test\n-    void toArrayWithArraySmaller() {\n-        Integer[] arr = new Integer[INDEX];\n-        Integer[] actual = newList().toArray(arr);\n-        assertNotSame(arr, actual);\n-        Integer[] expected = newRegularList().toArray(new Integer[0]);\n-        assertArrayEquals(expected, actual);\n-    }\n-\n-    @Test\n-    void toArrayWithGenerator() {\n-        Integer[] expected = newRegularList().toArray(Integer[]::new);\n-        Integer[] actual = newList().toArray(Integer[]::new);\n-        assertArrayEquals(expected, actual);\n-    }\n-\n-    @Test\n-    void firstIndex() {\n-        var lazy = newList();\n-        for (int i = INDEX; i < SIZE; i++) {\n-            assertEquals(i, lazy.indexOf(i));\n-        }\n-        assertEquals(-1, lazy.indexOf(SIZE + 1));\n-    }\n-\n-    @Test\n-    void lastIndex() {\n-        var lazy = newList();\n-        for (int i = INDEX; i < SIZE; i++) {\n-            assertEquals(i, lazy.lastIndexOf(i));\n-        }\n-        assertEquals(-1, lazy.lastIndexOf(SIZE + 1));\n-    }\n-\n-    @Test\n-    void toStringTest() {\n-        assertEquals(\"[]\", newEmptyList().toString());\n-        var list = StableValue.list(2, IDENTITY);\n-        assertEquals(\"[.unset, .unset]\", list.toString());\n-        list.get(0);\n-        assertEquals(\"[0, .unset]\", list.toString());\n-        list.get(1);\n-        assertEquals(\"[0, 1]\", list.toString());\n-    }\n-\n-    @Test\n-    void hashCodeTest() {\n-        assertEquals(List.of().hashCode(), newEmptyList().hashCode());\n-        assertEquals(newRegularList().hashCode(), newList().hashCode());\n-    }\n-\n-    @Test\n-    void equalsTest() {\n-        assertTrue(newEmptyList().equals(List.of()));\n-        assertTrue(List.of().equals(newEmptyList()));\n-        assertTrue(newList().equals(newRegularList()));\n-        assertTrue(newRegularList().equals(newList()));\n-        assertFalse(newList().equals(\"A\"));\n-    }\n-\n-    @Test\n-    void equalsPartialEvaluationTest() {\n-        var list = StableValue.list(2, IDENTITY);\n-        assertFalse(list.equals(List.of(0)));\n-        assertEquals(\"[0, .unset]\", list.toString());\n-        assertTrue(list.equals(List.of(0, 1)));\n-        assertEquals(\"[0, 1]\", list.toString());\n-    }\n-\n-    @Test\n-    void iteratorTotal() {\n-        var iterator = newList().iterator();\n-        for (int i = 0; i < SIZE; i++) {\n-            assertTrue(iterator.hasNext());\n-            assertTrue(iterator.hasNext());\n-            assertEquals(i, iterator.next());\n-        }\n-        assertFalse(iterator.hasNext());\n-        assertThrows(NoSuchElementException.class, iterator::next);\n-        AtomicInteger cnt = new AtomicInteger();\n-        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n-        assertEquals(0, cnt.get());\n-    }\n-\n-    @Test\n-    void iteratorPartial() {\n-        var iterator = newList().iterator();\n-        for (int i = 0; i < INDEX; i++) {\n-            assertTrue(iterator.hasNext());\n-            assertTrue(iterator.hasNext());\n-            assertEquals(i, iterator.next());\n-        }\n-        assertTrue(iterator.hasNext());\n-        AtomicInteger cnt = new AtomicInteger();\n-        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n-        assertEquals(SIZE - INDEX, cnt.get());\n-        assertFalse(iterator.hasNext());\n-        assertThrows(NoSuchElementException.class, iterator::next);\n-    }\n-\n-    @Test\n-    void subList() {\n-        var lazy = newList();\n-        var lazySubList = lazy.subList(1, SIZE);\n-        assertInstanceOf(RandomAccess.class, lazySubList);\n-        var regularList = newRegularList();\n-        var regularSubList = regularList.subList(1, SIZE);\n-        assertEquals(regularSubList, lazySubList);\n-    }\n-\n-    @Test\n-    void subList2() {\n-        var lazy = newList();\n-        var lazySubList = lazy.subList(1, SIZE);\n-        lazySubList.get(0);\n-        var eq = newList();\n-        eq.get(1);\n-        assertEquals(eq.toString(), lazy.toString());\n-    }\n-\n-    void assertUnevaluated(List<Integer> subList) {\n-        assertEquals(asString(\".unset\", subList), subList.toString());\n-    }\n-\n-    @Test\n-    void reversed() {\n-        var reversed = newList().reversed();\n-        assertInstanceOf(RandomAccess.class, reversed);\n-        assertEquals(SIZE - 1, reversed.getFirst());\n-        assertEquals(0, reversed.getLast());\n-\n-        var reversed2 = reversed.reversed();\n-        assertInstanceOf(RandomAccess.class, reversed2);\n-        assertEquals(0, reversed2.getFirst());\n-        assertEquals(SIZE - 1, reversed2.getLast());\n-        \/\/ Make sure we get back a non-reversed implementation\n-        assertEquals(\"java.util.ImmutableCollections$StableList\", reversed2.getClass().getName());\n-    }\n-\n-    @Test\n-    void sublistReversedToString() {\n-        var actual = StableValue.list(4, IDENTITY);\n-        var expected = List.of(0, 1, 2, 3);\n-        for (UnaryOperation op : List.of(\n-                new UnaryOperation(\"subList\", l -> l.subList(1, 3)),\n-                new UnaryOperation(\"reversed\", List::reversed))) {\n-            actual = op.apply(actual);\n-            expected = op.apply(expected);\n-        }\n-        \/\/ Touch one of the elements\n-        actual.getLast();\n-\n-        var actualToString = actual.toString();\n-        var expectedToString = expected.toString().replace(\"2\", \".unset\");\n-        assertEquals(expectedToString, actualToString);\n-    }\n-\n-    \/\/ This test makes sure successive view operations retains the property\n-    \/\/ of being a Stable view.\n-    @Test\n-    void viewsStable() {\n-        viewOperations().forEach(op0 -> {\n-            viewOperations().forEach( op1 -> {\n-                viewOperations().forEach(op2 -> {\n-                    var list = newList();\n-                    var view1 = op0.apply(list);\n-                    var view2 = op1.apply(view1);\n-                    var view3 = op2.apply(view2);\n-                    var className3 = className(view3);\n-                    var transitions = className(list) + \", \" +\n-                            op0 + \" -> \" + className(view1) + \", \" +\n-                            op1 + \" -> \" + className(view2) + \", \" +\n-                            op2 + \" -> \" + className3;\n-                    assertTrue(className3.contains(\"Stable\"), transitions);\n-                    assertUnevaluated(list);\n-                    assertUnevaluated(view1);\n-                    assertUnevaluated(view2);\n-                    assertUnevaluated(view3);\n-                });\n-            });\n-        });\n-    }\n-\n-    @Test\n-    void recursiveCall() {\n-        AtomicReference<IntFunction<Integer>> ref = new AtomicReference<>();\n-        var lazy = StableValue.list(SIZE, i -> ref.get().apply(i));\n-        ref.set(lazy::get);\n-        var x = assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n-        assertEquals(\"Recursive initialization of a stable value is illegal\", x.getMessage());\n-    }\n-\n-    @Test\n-    void indexOfNullInViews() {\n-        final int size = 5;\n-        final int middle = 2;\n-        viewOperations().forEach(op0 -> {\n-            viewOperations().forEach( op1 -> {\n-                viewOperations().forEach(op2 -> {\n-                    var list = StableValue.list(size, x -> x == middle ? null : x);;\n-                    var view1 = op0.apply(list);\n-                    var view2 = op1.apply(view1);\n-                    var view3 = op2.apply(view2);\n-                    assertEquals(middle, view3.indexOf(null));\n-                });\n-            });\n-        });\n-    }\n-\n-    \/\/ Immutability\n-\n-    @ParameterizedTest\n-    @MethodSource(\"unsupportedOperations\")\n-    void unsupported(Operation operation) {\n-        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n-    }\n-\n-    \/\/ Method parameter invariant checking\n-\n-    @ParameterizedTest\n-    @MethodSource(\"nullAverseOperations\")\n-    void nullAverse(Operation operation) {\n-        assertThrowsForOperation(NullPointerException.class, operation);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"outOfBoundsOperations\")\n-    void outOfBounds(Operation operation) {\n-        assertThrowsForOperation(IndexOutOfBoundsException.class, operation);\n-    }\n-\n-    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n-        var lazy = newList();\n-        assertThrows(expectedType, () -> operation.accept(lazy));\n-        var sub = lazy.subList(1, SIZE \/ 2);\n-        assertThrows(expectedType, () -> operation.accept(sub));\n-        var subSub = sub.subList(1, sub.size() \/ 2);\n-        assertThrows(expectedType, () -> operation.accept(subSub));\n-    }\n-\n-    \/\/ Implementing interfaces\n-\n-    @Test\n-    void serializable() {\n-        serializable(newList());\n-        serializable(newEmptyList());\n-    }\n-\n-    void serializable(List<Integer> list) {\n-        assertFalse(list instanceof Serializable);\n-        if (list.size()>INDEX) {\n-            assertFalse(newList().subList(1, INDEX) instanceof Serializable);\n-        }\n-        assertFalse(list.iterator() instanceof Serializable);\n-        assertFalse(list.reversed() instanceof Serializable);\n-        assertFalse(list.spliterator() instanceof Serializable);\n-    }\n-\n-    @Test\n-    void randomAccess() {\n-        assertInstanceOf(RandomAccess.class, newList());\n-        assertInstanceOf(RandomAccess.class, newEmptyList());\n-        assertInstanceOf(RandomAccess.class, newList().subList(1, INDEX));\n-    }\n-\n-    @Test\n-    void distinct() {\n-        StableValueImpl<Integer>[] array = StableUtil.array(SIZE);\n-        assertEquals(SIZE, array.length);\n-        \/\/ Check, every StableValue is distinct\n-        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n-        for (var e: array) {\n-            idMap.put(e, true);\n-        }\n-        assertEquals(SIZE, idMap.size());\n-    }\n-\n-    @Test\n-    void childObjectOpsLazy() {\n-        viewOperations().forEach(op0 -> {\n-            viewOperations().forEach(op1 -> {\n-                viewOperations().forEach(op2 -> {\n-                    childOperations().forEach(co -> {\n-                        var list = newList();\n-                        var view1 = op0.apply(list);\n-                        var view2 = op1.apply(view1);\n-                        var view3 = op2.apply(view2);\n-                        var child = co.apply(view3);\n-                        var childClassName = className(child);\n-                        var transitions = className(list) + \", \" +\n-                                op0 + \" -> \" + className(view1) + \", \" +\n-                                op1 + \" -> \" + className(view2) + \", \" +\n-                                op2 + \" -> \" + className(view3) + \", \" +\n-                                co + \" -> \" + childClassName;\n-\n-                        \/\/ None of these operations should trigger evaluation\n-                        var childToString = child.toString();\n-                        int childHashCode = child.hashCode();\n-                        boolean childEqualToNewObj = child.equals(new Object());\n-\n-                        assertUnevaluated(list);\n-                        assertUnevaluated(view1);\n-                        assertUnevaluated(view2);\n-                        assertUnevaluated(view3);\n-                    });\n-                });\n-            });\n-        });\n-    }\n-\n-    \/\/ Support constructs\n-\n-    record Operation(String name,\n-                     Consumer<List<Integer>> consumer) implements Consumer<List<Integer>> {\n-        @Override public void   accept(List<Integer> list) { consumer.accept(list); }\n-        @Override public String toString() { return name; }\n-    }\n-\n-    record UnaryOperation(String name,\n-                     UnaryOperator<List<Integer>> operator) implements UnaryOperator<List<Integer>> {\n-        @Override public List<Integer> apply(List<Integer> list) { return operator.apply(list); }\n-        @Override public String toString() { return name; }\n-    }\n-\n-    record ListFunction(String name,\n-                        Function<List<Integer>, Object> function) implements Function<List<Integer>, Object> {\n-        @Override public Object apply(List<Integer> list) { return function.apply(list); }\n-        @Override public String toString() { return name; }\n-    }\n-\n-    static Stream<UnaryOperation> viewOperations() {\n-        return Stream.of(\n-                \/\/ We need identity to capture all combinations\n-                new UnaryOperation(\"identity\", l -> l),\n-                new UnaryOperation(\"reversed\", List::reversed),\n-                new UnaryOperation(\"subList\", l -> l.subList(0, l.size()))\n-        );\n-    }\n-\n-    static Stream<ListFunction> childOperations() {\n-        return Stream.of(\n-                \/\/ We need identity to capture all combinations\n-                new ListFunction(\"iterator\", List::iterator),\n-                new ListFunction(\"listIterator\", List::listIterator),\n-                new ListFunction(\"listIterator\", List::stream)\n-        );\n-    }\n-\n-    static Stream<Operation> nullAverseOperations() {\n-        return Stream.of(\n-                new Operation(\"forEach\",     l -> l.forEach(null)),\n-                new Operation(\"containsAll\", l -> l.containsAll(null)),\n-                new Operation(\"toArray\",     l -> l.toArray((Integer[]) null)),\n-                new Operation(\"toArray\",     l -> l.toArray((IntFunction<Integer[]>) null))\n-        );\n-    }\n-\n-    static Stream<Operation> outOfBoundsOperations() {\n-        return Stream.of(\n-                new Operation(\"get(-1)\",        l -> l.get(-1)),\n-                new Operation(\"get(size)\",      l -> l.get(l.size())),\n-                new Operation(\"sublist(-1,)\",   l -> l.subList(-1, INDEX)),\n-                new Operation(\"sublist(,size)\", l -> l.subList(0, l.size() + 1)),\n-                new Operation(\"listIter(-1)\",   l -> l.listIterator(-1)),\n-                new Operation(\"listIter(size)\", l -> l.listIterator(l.size() + 1))\n-        );\n-    }\n-\n-    static Stream<Operation> unsupportedOperations() {\n-        final Set<Integer> SET = Set.of(0, 1);\n-        return Stream.of(\n-                new Operation(\"add(0)\",            l -> l.add(0)),\n-                new Operation(\"add(0, 1)\",         l -> l.add(0, 1)),\n-                new Operation(\"addAll(col)\",       l -> l.addAll(SET)),\n-                new Operation(\"addAll(1, coll)\",   l -> l.addAll(1, SET)),\n-                new Operation(\"addFirst(0)\",       l -> l.addFirst(0)),\n-                new Operation(\"addLast(0)\",        l -> l.addLast(0)),\n-                new Operation(\"clear\",             List::clear),\n-                new Operation(\"remove(Obj)\",       l -> l.remove((Object)1)),\n-                new Operation(\"remove(1)\",         l -> l.remove(1)),\n-                new Operation(\"removeAll\",         l -> l.removeAll(SET)),\n-                new Operation(\"removeFirst\",       List::removeFirst),\n-                new Operation(\"removeLast\",        List::removeLast),\n-                new Operation(\"removeIf\",          l -> l.removeIf(i -> i % 2 == 0)),\n-                new Operation(\"replaceAll\",        l -> l.replaceAll(i -> i + 1)),\n-                new Operation(\"sort\",              l -> l.sort(Comparator.naturalOrder())),\n-                new Operation(\"iterator().remove\", l -> l.iterator().remove()),\n-                new Operation(\"listIter().remove\", l -> l.listIterator().remove()),\n-                new Operation(\"listIter().add\",    l -> l.listIterator().add(1)),\n-                new Operation(\"listIter().set\",    l -> l.listIterator().set(1))\n-        );\n-    }\n-\n-    static List<Integer> newList() {\n-        return StableValue.list(SIZE, IDENTITY);\n-    }\n-\n-    static List<Integer> newEmptyList() {\n-        return StableValue.list(ZERO, IDENTITY);\n-    }\n-\n-    static List<Integer> newRegularList() {\n-        return IntStream.range(0, SIZE).boxed().toList();\n-    }\n-\n-    static String asString(String first, List<Integer> list) {\n-        return \"[\" + first + \", \" + Stream.generate(() -> \".unset\")\n-                .limit(list.size() - 1)\n-                .collect(Collectors.joining(\", \")) + \"]\";\n-    }\n-\n-    static String className(Object o) {\n-        return o.getClass().getName();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":0,"deletions":540,"binary":false,"changes":540,"status":"deleted"},{"patch":"@@ -1,388 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableMap methods\n- * @modules java.base\/jdk.internal.lang.stable\n- * @enablePreview\n- * @run junit StableMapTest\n- *\/\n-\n-import jdk.internal.lang.stable.StableUtil;\n-import jdk.internal.lang.stable.StableValueImpl;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.io.Serializable;\n-import java.util.AbstractMap;\n-import java.util.HashSet;\n-import java.util.IdentityHashMap;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableMapTest {\n-\n-    private static final int NOT_PRESENT = 147;\n-    private static final int KEY = 7;\n-    private static final Set<Integer> KEYS = Set.of(0, KEY, 13);\n-    private static final Set<Integer> EMPTY = Set.of();\n-    private static final Function<Integer, Integer> IDENTITY = Function.identity();\n-\n-    @Test\n-    void factoryInvariants() {\n-        assertThrows(NullPointerException.class, () -> StableValue.map(KEYS, null));\n-        assertThrows(NullPointerException.class, () -> StableValue.map(null, IDENTITY));\n-    }\n-\n-    @Test\n-    void isEmpty() {\n-        assertFalse(newMap().isEmpty());\n-        assertTrue(newEmptyMap().isEmpty());\n-    }\n-\n-    @Test\n-    void size() {\n-        assertEquals(KEYS.size(), newMap().size());\n-        assertEquals(EMPTY.size(), newEmptyMap().size());\n-    }\n-\n-    @Test\n-    void get() {\n-        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(IDENTITY);\n-        var lazy = StableValue.map(KEYS, cf);\n-        int cnt = 1;\n-        for (int i : KEYS) {\n-            assertEquals(i, lazy.get(i));\n-            assertEquals(cnt, cf.cnt());\n-            assertEquals(i, lazy.get(i));\n-            assertEquals(cnt++, cf.cnt());\n-        }\n-        assertNull(lazy.get(NOT_PRESENT));\n-    }\n-\n-    @Test\n-    void getException() {\n-        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(_ -> {\n-            throw new UnsupportedOperationException();\n-        });\n-        var lazy = StableValue.map(KEYS, cf);\n-        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n-        assertEquals(1, cf.cnt());\n-        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n-        assertEquals(2, cf.cnt());\n-    }\n-\n-    @Test\n-    void containsKey() {\n-        var lazy = newMap();\n-        for (int i : KEYS) {\n-            assertTrue(lazy.containsKey(i));\n-        }\n-        assertFalse(lazy.containsKey(NOT_PRESENT));\n-    }\n-\n-    @Test\n-    void containsValue() {\n-        var lazy = newMap();\n-        for (int i : KEYS) {\n-            assertTrue(lazy.containsValue(i));\n-        }\n-        assertFalse(lazy.containsValue(NOT_PRESENT));\n-    }\n-\n-    @Test\n-    void forEach() {\n-        var lazy = newMap();\n-        Set<Map.Entry<Integer, Integer>> expected = KEYS.stream()\n-                .map(i -> new AbstractMap.SimpleImmutableEntry<>(i , i))\n-                .collect(Collectors.toSet());\n-        Set<Map.Entry<Integer, Integer>> actual = new HashSet<>();\n-        lazy.forEach((k, v) -> actual.add(new AbstractMap.SimpleImmutableEntry<>(k , v)));\n-        assertEquals(expected, actual);\n-    }\n-\n-    @Test\n-    void toStringTest() {\n-        assertEquals(\"{}\", newEmptyMap().toString());\n-        var map = StableValue.map(Set.of(KEY), IDENTITY);\n-        assertEquals(\"{\" + KEY + \"=.unset}\", map.toString());\n-        map.get(KEY);\n-        assertEquals(\"{\" + KEY + \"=\" + KEY + \"}\", map.toString());\n-        String actual = newMap().toString();\n-        assertTrue(actual.startsWith(\"{\"));\n-        for (int key : KEYS) {\n-            assertTrue(actual.contains(key + \"=.unset\"));\n-        }\n-        assertTrue(actual.endsWith(\"}\"));\n-    }\n-\n-    @Test\n-    void hashCodeTest() {\n-        assertEquals(Map.of().hashCode(), newEmptyMap().hashCode());\n-        assertEquals(newRegularMap().hashCode(), newMap().hashCode());\n-    }\n-\n-    @Test\n-    void equalsTest() {\n-        assertTrue(newEmptyMap().equals(Map.of()));\n-        assertTrue(Map.of().equals(newEmptyMap()));\n-        assertTrue(newMap().equals(newRegularMap()));\n-        assertTrue(newRegularMap().equals(newMap()));\n-        assertFalse(newMap().equals(\"A\"));\n-    }\n-\n-    @Test\n-    void entrySet() {\n-        var regular = newRegularMap().entrySet();\n-        var actual = newMap().entrySet();\n-        assertTrue(regular.equals(actual));\n-        assertTrue(actual.equals(regular));\n-        assertTrue(regular.equals(actual));\n-    }\n-\n-    @Test\n-    void entrySetToString() {\n-        var map = newMap();\n-        var entrySet = map.entrySet();\n-        var toString = entrySet.toString();\n-        for (var key : KEYS) {\n-            assertTrue(toString.contains(key + \"=.unset\"));\n-        }\n-        assertTrue(toString.startsWith(\"[\"));\n-        assertTrue(toString.endsWith(\"]\"));\n-\n-        map.get(KEY);\n-        for (var key : KEYS) {\n-            if (key.equals(KEY)) {\n-                continue;\n-            }\n-            assertTrue(entrySet.toString().contains(key + \"=.unset\"));\n-        }\n-        assertTrue(entrySet.toString().contains(KEY + \"=\" + KEY));\n-    }\n-\n-    @Test\n-    void values() {\n-        var map = newMap();\n-        var values = map.values();\n-        \/\/ Look at one of the elements\n-        var val = values.stream().iterator().next();\n-        var toString = map.toString();\n-        for (var key : KEYS) {\n-            if (key.equals(val)) {\n-                assertTrue(toString.contains(key + \"=\" + key));\n-            } else {\n-                assertTrue(toString.contains(key + \"=.unset\"));\n-            }\n-        }\n-\n-        \/\/ Mod ops\n-        assertThrows(UnsupportedOperationException.class, () -> values.remove(KEY));\n-        assertThrows(UnsupportedOperationException.class, () -> values.add(KEY));\n-        assertThrows(UnsupportedOperationException.class, values::clear);\n-        assertThrows(UnsupportedOperationException.class, () -> values.addAll(Set.of(1)));\n-        assertThrows(UnsupportedOperationException.class, () -> values.removeIf(i -> true));\n-        assertThrows(UnsupportedOperationException.class, () -> values.retainAll(Set.of(KEY)));\n-    }\n-\n-    @Test\n-    void valuesToString() {\n-        var map = newMap();\n-        var values = map.values();\n-        assertEquals(\"[.unset, .unset, .unset]\", values.toString());\n-        map.get(KEY);\n-        var afterGet = values.toString();\n-        assertTrue(afterGet.contains(Integer.toString(KEY)), afterGet);\n-    }\n-\n-    @Test\n-    void iteratorNext() {\n-        Set<Integer> encountered = new HashSet<>();\n-        var iterator = newMap().entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            var entry = iterator.next();\n-            assertEquals(entry.getKey(), entry.getValue());\n-            encountered.add(entry.getValue());\n-        }\n-        assertEquals(KEYS, encountered);\n-    }\n-\n-    @Test\n-    void iteratorForEachRemaining() {\n-        Set<Integer> encountered = new HashSet<>();\n-        var iterator = newMap().entrySet().iterator();\n-        var entry = iterator.next();\n-        assertEquals(entry.getKey(), entry.getValue());\n-        encountered.add(entry.getValue());\n-        iterator.forEachRemaining(e -> {\n-            assertEquals(e.getKey(), e.getValue());\n-            encountered.add(e.getValue());\n-        });\n-        assertEquals(KEYS, encountered);\n-    }\n-\n-    @Test\n-    void stableEntry() {\n-        var map = newMap();\n-        var entry = map.entrySet().stream()\n-                .filter(e -> e.getKey().equals(KEY))\n-                .findAny()\n-                .orElseThrow();\n-\n-        assertEquals(KEY + \"=.unset\", entry.toString());\n-        var otherDifferent = Map.entry(-1, -1);\n-        assertNotEquals(entry, otherDifferent);\n-        assertEquals(KEY + \"=.unset\", entry.toString());\n-        var otherEqual = Map.entry(KEY, KEY);\n-        assertEquals(entry, otherEqual);\n-        assertEquals(KEY + \"=\" + KEY, entry.toString());\n-        assertEquals(entry.hashCode(), otherEqual.hashCode());\n-    }\n-\n-    @Test\n-    void stableForEachEntry() {\n-        var map = newMap();\n-        \/\/ Only touch the key.\n-        map.entrySet().iterator().forEachRemaining(Map.Entry::getKey);\n-        map.entrySet().iterator()\n-                .forEachRemaining(e -> assertTrue(e.toString().contains(\".unset\")));\n-        \/\/ Only touch the value.\n-        map.entrySet().iterator().forEachRemaining(Map.Entry::getValue);\n-        map.entrySet().iterator()\n-                .forEachRemaining(e -> assertFalse(e.toString().contains(\".unset\")));\n-    }\n-\n-    \/\/ Immutability\n-    @ParameterizedTest\n-    @MethodSource(\"unsupportedOperations\")\n-    void unsupported(Operation operation) {\n-        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n-    }\n-\n-    \/\/ Method parameter invariant checking\n-\n-    @ParameterizedTest\n-    @MethodSource(\"nullAverseOperations\")\n-    void nullAverse(Operation operation) {\n-        assertThrowsForOperation(NullPointerException.class, operation);\n-    }\n-\n-    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n-        var lazy = newMap();\n-        assertThrows(expectedType, () -> operation.accept(lazy));\n-    }\n-\n-    \/\/ Implementing interfaces\n-\n-    @Test\n-    void serializable() {\n-        serializable(newMap());\n-        serializable(newEmptyMap());\n-    }\n-\n-    void serializable(Map<Integer, Integer> map) {\n-        assertFalse(map instanceof Serializable);\n-        assertFalse(map.entrySet() instanceof Serializable);\n-        assertFalse(map.keySet() instanceof Serializable);\n-        assertFalse(map.values() instanceof Serializable);\n-    }\n-\n-    @Test\n-    void distinct() {\n-        Map<Integer, StableValueImpl<Integer>> map = StableUtil.map(Set.of(1, 2, 3));\n-        assertEquals(3, map.size());\n-        \/\/ Check, every StableValue is distinct\n-        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n-        map.forEach((k, v) -> idMap.put(v, true));\n-        assertEquals(3, idMap.size());\n-    }\n-\n-    @Test\n-    void nullResult() {\n-        var map = StableValue.map(Set.of(0), _ -> null);\n-        assertNull(map.getOrDefault(0, 1));;\n-        assertTrue(map.containsKey(0));\n-        assertNull(map.get(0));\n-    }\n-\n-    @Test\n-    void nullKeys() {\n-        Set<Integer> inputs = new HashSet<>();\n-        inputs.add(0);\n-        inputs.add(null);\n-        assertThrows(NullPointerException.class, () -> StableValue.map(inputs, IDENTITY));\n-    }\n-\n-    \/\/ Support constructs\n-\n-    record Operation(String name,\n-                     Consumer<Map<Integer, Integer>> consumer) implements Consumer<Map<Integer, Integer>> {\n-        @java.lang.Override\n-        public void accept(Map<Integer, Integer> map) { consumer.accept(map); }\n-        @java.lang.Override\n-        public String toString() { return name; }\n-    }\n-\n-    static Stream<Operation> nullAverseOperations() {\n-        return Stream.of(\n-            new Operation(\"forEach\",     m -> m.forEach(null))\n-        );\n-    }\n-\n-    static Stream<Operation> unsupportedOperations() {\n-        return Stream.of(\n-            new Operation(\"clear\",             Map::clear),\n-            new Operation(\"compute\",           m -> m.compute(KEY, (_, _) -> 1)),\n-            new Operation(\"computeIfAbsent\",   m -> m.computeIfAbsent(KEY, _ -> 1)),\n-            new Operation(\"computeIfPresent\",  m -> m.computeIfPresent(KEY, (_, _) -> 1)),\n-            new Operation(\"merge\",             m -> m.merge(KEY, KEY, (a, _) -> a)),\n-            new Operation(\"put\",               m -> m.put(0, 0)),\n-            new Operation(\"putAll\",            m -> m.putAll(Map.of())),\n-            new Operation(\"remove1\",           m -> m.remove(KEY)),\n-            new Operation(\"remove2\",           m -> m.remove(KEY, KEY)),\n-            new Operation(\"replace2\",          m -> m.replace(KEY, 1)),\n-            new Operation(\"replace3\",          m -> m.replace(KEY, KEY, 1)),\n-            new Operation(\"replaceAll\",        m -> m.replaceAll((a, _) -> a))\n-        );\n-    }\n-\n-    static Map<Integer, Integer> newMap() {\n-        return StableValue.map(KEYS, IDENTITY);\n-    }\n-\n-    static Map<Integer, Integer> newEmptyMap() {\n-        return StableValue.map(EMPTY, IDENTITY);\n-    }\n-\n-    static Map<Integer, Integer> newRegularMap() {\n-        return KEYS.stream().collect(Collectors.toMap(IDENTITY, IDENTITY));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":0,"deletions":388,"binary":false,"changes":388,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableSupplier methods\n- * @enablePreview\n- * @run junit StableSupplierTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableSupplierTest {\n-\n-    private static final Supplier<Integer> SUPPLIER = () -> 42;\n-\n-    @Test\n-    void factoryInvariants() {\n-        assertThrows(NullPointerException.class, () -> StableValue.supplier(null));\n-    }\n-\n-    @Test\n-    void basic() {\n-        basic(SUPPLIER);\n-        basic(() -> null);\n-    }\n-\n-    void basic(Supplier<Integer> supplier) {\n-        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(supplier);\n-        var cached = StableValue.supplier(cs);\n-        assertEquals(\".unset\", cached.toString());\n-        assertEquals(supplier.get(), cached.get());\n-        assertEquals(1, cs.cnt());\n-        assertEquals(supplier.get(), cached.get());\n-        assertEquals(1, cs.cnt());\n-        assertEquals(Objects.toString(supplier.get()), cached.toString());\n-    }\n-\n-    @Test\n-    void exception() {\n-        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> {\n-            throw new UnsupportedOperationException();\n-        });\n-        var cached = StableValue.supplier(cs);\n-        assertThrows(UnsupportedOperationException.class, cached::get);\n-        assertEquals(1, cs.cnt());\n-        assertThrows(UnsupportedOperationException.class, cached::get);\n-        assertEquals(2, cs.cnt());\n-        assertEquals(\".unset\", cached.toString());\n-    }\n-\n-    @Test\n-    void circular() {\n-        final AtomicReference<Supplier<?>> ref = new AtomicReference<>();\n-        Supplier<Supplier<?>> cached = StableValue.supplier(ref::get);\n-        ref.set(cached);\n-        cached.get();\n-        String toString = cached.toString();\n-        assertTrue(toString.startsWith(\"(this StableSupplier)\"));\n-        assertDoesNotThrow(cached::hashCode);\n-    }\n-\n-    @Test\n-    void equality() {\n-        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n-        Supplier<Integer> f1 = StableValue.supplier(SUPPLIER);\n-        \/\/ No function is equal to another function\n-        assertNotEquals(f0, f1);\n-    }\n-\n-    @Test\n-    void hashCodeStable() {\n-        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n-        assertEquals(System.identityHashCode(f0), f0.hashCode());\n-        f0.get();\n-        assertEquals(System.identityHashCode(f0), f0.hashCode());\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n-import java.util.function.Supplier;\n-\n-final class StableTestUtil {\n-\n-    private StableTestUtil() {}\n-\n-    public static final class CountingSupplier<T>\n-            extends AbstractCounting<Supplier<T>>\n-            implements Supplier<T> {\n-\n-        public CountingSupplier(Supplier<T> delegate) {\n-            super(delegate);\n-        }\n-\n-        @Override\n-        public T get() {\n-            incrementCounter();\n-            return delegate.get();\n-        }\n-\n-    }\n-\n-    public static final class CountingIntFunction<R>\n-            extends AbstractCounting<IntFunction<R>>\n-            implements IntFunction<R> {\n-\n-        public CountingIntFunction(IntFunction<R> delegate) {\n-            super(delegate);\n-        }\n-\n-        @Override\n-        public R apply(int value) {\n-            incrementCounter();\n-            return delegate.apply(value);\n-        }\n-\n-    }\n-\n-    public static final class CountingFunction<T, R>\n-            extends AbstractCounting<Function<T, R>>\n-            implements Function<T, R> {\n-\n-        public CountingFunction(Function<T, R> delegate) {\n-            super(delegate);\n-        }\n-\n-        @Override\n-        public R apply(T t) {\n-            incrementCounter();\n-            return delegate.apply(t);\n-        }\n-\n-    }\n-\n-    public static final class CountingBiFunction<T, U, R>\n-            extends AbstractCounting<BiFunction<T, U, R>>\n-            implements BiFunction<T, U, R> {\n-\n-        public CountingBiFunction(BiFunction<T, U, R> delegate) {\n-            super(delegate);\n-        }\n-\n-        @Override\n-        public R apply(T t, U u) {\n-            incrementCounter();\n-            return delegate.apply(t, u);\n-        }\n-    }\n-\n-    abstract static class AbstractCounting<D> {\n-\n-        private final AtomicInteger cnt = new AtomicInteger();\n-        protected final D delegate;\n-\n-        protected AbstractCounting(D delegate) {\n-            this.delegate = delegate;\n-        }\n-\n-        protected final void incrementCounter() {\n-            cnt.incrementAndGet();\n-        }\n-\n-        public final int cnt() {\n-            return cnt.get();\n-        }\n-\n-        @Override\n-        public final String toString() {\n-            return cnt.toString();\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableValue factory implementations\n- * @modules java.base\/jdk.internal.lang.stable\n- * @enablePreview\n- * @run junit StableValueFactoriesTest\n- *\/\n-\n-import jdk.internal.lang.stable.StableUtil;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableValueFactoriesTest {\n-\n-    @Test\n-    void array() {\n-        assertThrows(IllegalArgumentException.class, () -> StableUtil.array(-1));\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueFactoriesTest.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for StableValue implementations\n- * @enablePreview\n- * @run junit StableValueTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.locks.LockSupport;\n-import java.util.function.BiPredicate;\n-import java.util.function.Function;\n-import java.util.function.IntFunction;\n-import java.util.function.UnaryOperator;\n-import java.util.stream.IntStream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-final class StableValueTest {\n-\n-    private static final int VALUE = 42;\n-    private static final int VALUE2 = 13;\n-\n-    @Test\n-    void trySet() {\n-        trySet(VALUE);\n-        trySet(null);\n-    }\n-\n-    @Test\n-    void preSet() {\n-        StableValue<Integer> stable = StableValue.of(VALUE);\n-        assertTrue(stable.isSet());\n-        assertEquals(VALUE, stable.orElseThrow());\n-        assertEquals(VALUE, stable.orElse(VALUE2));\n-        assertEquals(VALUE, stable.orElseSet(() -> VALUE2));\n-        assertFalse(stable.trySet(VALUE2));\n-        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n-        assertEquals(\n-                \"The contents is already set\",\n-                e.getMessage());\n-    }\n-\n-    void trySet(Integer initial) {\n-        StableValue<Integer> stable = StableValue.of();\n-        assertTrue(stable.trySet(initial));\n-        assertFalse(stable.trySet(null));\n-        assertFalse(stable.trySet(VALUE));\n-        assertFalse(stable.trySet(VALUE2));\n-        assertEquals(initial, stable.orElseThrow());\n-    }\n-\n-    @Test\n-    void setOrThrowValue() {\n-        StableValue<Integer> stable = StableValue.of();\n-        stable.setOrThrow(VALUE);\n-        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n-        assertEquals(\"The contents is already set\", e.getMessage());\n-    }\n-\n-    @Test\n-    void setOrThrowNull() {\n-        StableValue<Integer> stable = StableValue.of();\n-        stable.setOrThrow(null);\n-        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(null));\n-        assertEquals(\"The contents is already set\", e.getMessage());\n-    }\n-\n-    @Test\n-    void orElse() {\n-        StableValue<Integer> stable = StableValue.of();\n-        assertEquals(VALUE, stable.orElse(VALUE));\n-        assertNull(stable.orElse(null));\n-        stable.trySet(VALUE);\n-        assertEquals(VALUE, stable.orElse(VALUE2));\n-    }\n-\n-    @Test\n-    void orElseThrow() {\n-        StableValue<Integer> stable = StableValue.of();\n-        var e = assertThrows(NoSuchElementException.class, stable::orElseThrow);\n-        assertEquals(\"No contents set\", e.getMessage());\n-        stable.trySet(VALUE);\n-        assertEquals(VALUE, stable.orElseThrow());\n-    }\n-\n-    @Test\n-    void isSet() {\n-        isSet(VALUE);\n-        isSet(null);\n-   }\n-\n-    void isSet(Integer initial) {\n-        StableValue<Integer> stable = StableValue.of();\n-        assertFalse(stable.isSet());\n-        stable.trySet(initial);\n-        assertTrue(stable.isSet());\n-    }\n-\n-   @Test\n-   void testOrElseSetSupplier() {\n-       StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> VALUE);\n-       StableValue<Integer> stable = StableValue.of();\n-       assertThrows(NullPointerException.class, () -> stable.orElseSet(null));\n-       assertEquals(VALUE, stable.orElseSet(cs));\n-       assertEquals(1, cs.cnt());\n-       assertEquals(VALUE, stable.orElseSet(cs));\n-       assertEquals(1, cs.cnt());\n-   }\n-\n-    @Test\n-    void testHashCode() {\n-        StableValue<Integer> stableValue = StableValue.of();\n-        \/\/ Should be Object::hashCode\n-        assertEquals(System.identityHashCode(stableValue), stableValue.hashCode());\n-    }\n-\n-    @Test\n-    void testEquals() {\n-        StableValue<Integer> s0 = StableValue.of();\n-        assertNotEquals(null, s0);\n-        StableValue<Integer> s1 = StableValue.of();\n-        assertNotEquals(s0, s1); \/\/ Identity based\n-        s0.setOrThrow(42);\n-        s1.setOrThrow(42);\n-        assertNotEquals(s0, s1);\n-        assertNotEquals(\"a\", s0);\n-        StableValue<Integer> null0 = StableValue.of();\n-        StableValue<Integer> null1 = StableValue.of();\n-        null0.setOrThrow(null);\n-        null1.setOrThrow(null);\n-        assertNotEquals(null0, null1);\n-    }\n-\n-    @Test\n-    void toStringUnset() {\n-        StableValue<Integer> stable = StableValue.of();\n-        assertEquals(\".unset\", stable.toString());\n-    }\n-\n-    @Test\n-    void toStringNull() {\n-        StableValue<Integer> stable = StableValue.of();\n-        assertTrue(stable.trySet(null));\n-        assertEquals(\"null\", stable.toString());\n-    }\n-\n-    @Test\n-    void toStringNonNull() {\n-        StableValue<Integer> stable = StableValue.of();\n-        assertTrue(stable.trySet(VALUE));\n-        assertEquals(Objects.toString(VALUE), stable.toString());\n-    }\n-\n-    @Test\n-    void toStringCircular() {\n-        StableValue<StableValue<?>> stable = StableValue.of();\n-        stable.trySet(stable);\n-        String toString = assertDoesNotThrow(stable::toString);\n-        assertEquals(\"(this StableValue)\", toString);\n-        assertDoesNotThrow(stable::hashCode);\n-        assertDoesNotThrow((() -> stable.equals(stable)));\n-    }\n-\n-    @Test\n-    void recursiveCall() {\n-        StableValue<Integer> stable = StableValue.of();\n-        AtomicReference<StableValue<Integer>> ref = new AtomicReference<>(stable);\n-        assertThrows(IllegalStateException.class, () ->\n-                stable.orElseSet(() -> {\n-                    ref.get().trySet(1);\n-                    return 1;\n-                })\n-        );\n-        assertThrows(IllegalStateException.class, () ->\n-                stable.orElseSet(() -> {\n-                    ref.get().orElseSet(() -> 1);\n-                    return 1;\n-                })\n-        );\n-    }\n-\n-    @Test\n-    void intFunctionExample() {\n-        final class SqrtUtil {\n-\n-            private SqrtUtil() {}\n-\n-            private static final int CACHED_SIZE = 10;\n-\n-            private static final IntFunction<Double> SQRT =\n-                    \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n-                    StableValue.intFunction(CACHED_SIZE, StrictMath::sqrt);\n-\n-            public static double sqrt(int a) {\n-                return SQRT.apply(a);\n-            }\n-        }\n-\n-        double sqrt9 = SqrtUtil.sqrt(9);   \/\/ May eventually constant fold to 3.0 at runtime\n-\n-        assertEquals(3, sqrt9);\n-        assertThrows(IllegalArgumentException.class, () -> SqrtUtil.sqrt(16));\n-    }\n-\n-    @Test\n-    void intFunctionExample2() {\n-        final class PowerOf2Util {\n-\n-            private PowerOf2Util() {}\n-\n-            private static final int SIZE = 6;\n-            private static final IntFunction<Integer> ORIGINAL_POWER_OF_TWO =\n-                    v -> 1 << v;\n-\n-            private static final IntFunction<Integer> POWER_OF_TWO =\n-                    \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n-                    StableValue.intFunction(SIZE, ORIGINAL_POWER_OF_TWO);\n-\n-            public static int powerOfTwo(int a) {\n-                return POWER_OF_TWO.apply(a);\n-            }\n-        }\n-\n-        int pwr4 = PowerOf2Util.powerOfTwo(4);   \/\/ May eventually constant fold to 16 at runtime\n-\n-        assertEquals(16, pwr4);\n-        assertEquals(1, PowerOf2Util.powerOfTwo(0));\n-        assertEquals(8, PowerOf2Util.powerOfTwo(3));\n-        assertEquals(32, PowerOf2Util.powerOfTwo(5));\n-        assertThrows(IllegalArgumentException.class, () -> PowerOf2Util.powerOfTwo(10));\n-    }\n-\n-    @Test\n-    void functionExample() {\n-\n-        class Log2Util {\n-\n-            private Log2Util() {}\n-\n-            private static final Set<Integer> CACHED_KEYS =\n-                    Set.of(1, 2, 4, 8, 16, 32);\n-            private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n-                    i -> 31 - Integer.numberOfLeadingZeros(i);\n-\n-            private static final Function<Integer, Integer> LOG2_CACHED =\n-                    \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n-                    StableValue.function(CACHED_KEYS, LOG2_ORIGINAL);\n-\n-            public static double log2(int a) {\n-                if (CACHED_KEYS.contains(a)) {\n-                    return LOG2_CACHED.apply(a);\n-                } else {\n-                    return LOG2_ORIGINAL.apply(a);\n-                }\n-            }\n-\n-        }\n-\n-        double log16 = Log2Util.log2(16); \/\/ May eventually constant fold to 4.0 at runtime\n-        double log256 = Log2Util.log2(256); \/\/ Will not constant fold\n-\n-        assertEquals(4, log16);\n-        assertEquals(8, log256);\n-    }\n-\n-    @Test\n-    void functionExample2() {\n-\n-        class Log2Util {\n-\n-            private Log2Util() {}\n-\n-            private static final Set<Integer> KEYS =\n-                    Set.of(1, 2, 4, 8);\n-            private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n-                    i -> 31 - Integer.numberOfLeadingZeros(i);\n-\n-            private static final Function<Integer, Integer> LOG2 =\n-                    \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n-                    StableValue.function(KEYS, LOG2_ORIGINAL);\n-\n-            public static double log2(int a) {\n-                return LOG2.apply(a);\n-            }\n-\n-        }\n-\n-        double log16 = Log2Util.log2(8); \/\/ May eventually constant fold to 3.0 at runtime\n-\n-        assertEquals(3, log16);\n-        assertThrows(IllegalArgumentException.class, () -> Log2Util.log2(3));\n-    }\n-\n-    private static final BiPredicate<StableValue<Integer>, Integer> TRY_SET = StableValue::trySet;\n-    private static final BiPredicate<StableValue<Integer>, Integer> SET_OR_THROW = (s, i) -> {\n-        try {\n-            s.setOrThrow(i);\n-            return true;\n-        } catch (IllegalStateException e) {\n-            return false;\n-        }\n-    };\n-\n-    @Test\n-    void raceTrySet() {\n-        race(TRY_SET);\n-    }\n-\n-    @Test\n-    void raceSetOrThrow() {\n-        race(SET_OR_THROW);\n-    }\n-\n-    @Test\n-    void raceMixed() {\n-        race((s, i) -> switch (i % 2) {\n-            case 0 -> TRY_SET.test(s, i);\n-            case 1 -> SET_OR_THROW.test(s, i);\n-            default -> fail(\"should not reach here\");\n-        });\n-    }\n-\n-    void race(BiPredicate<StableValue<Integer>, Integer> winnerPredicate) {\n-        int noThreads = 10;\n-        CountDownLatch starter = new CountDownLatch(noThreads);\n-        StableValue<Integer> stable = StableValue.of();\n-        Map<Integer, Boolean> winners = new ConcurrentHashMap<>();\n-        List<Thread> threads = IntStream.range(0, noThreads).mapToObj(i -> new Thread(() -> {\n-                    try {\n-                        \/\/ Ready ...\n-                        starter.countDown();\n-                        \/\/ ... set ...\n-                        starter.await();\n-                        \/\/ Here we go!\n-                        winners.put(i, winnerPredicate.test(stable, i));\n-                    } catch (Throwable t) {\n-                        fail(t);\n-                    }\n-                }))\n-                .toList();\n-        threads.forEach(Thread::start);\n-        threads.forEach(StableValueTest::join);\n-        \/\/ There can only be one winner\n-        assertEquals(1, winners.values().stream().filter(b -> b).count());\n-    }\n-\n-    private static void join(Thread thread) {\n-        try {\n-            thread.join();\n-        } catch (InterruptedException e) {\n-            fail(e);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for making sure StableValue publishes values safely\n- * @modules java.base\/jdk.internal.misc\n- * @enablePreview\n- * @run junit StableValuesSafePublicationTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class StableValuesSafePublicationTest {\n-\n-    private static final int SIZE = 100_000;\n-    private static final int THREADS = Runtime.getRuntime().availableProcessors();\n-    private static final StableValue<Holder>[] STABLES = stables();\n-\n-    static StableValue<Holder>[] stables() {\n-        @SuppressWarnings(\"unchecked\")\n-        StableValue<Holder>[] stables = (StableValue<Holder>[]) new StableValue[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            stables[i] = StableValue.of();\n-        }\n-        return stables;\n-    }\n-\n-    static final class Holder {\n-        \/\/ These are non-final fields but should be seen\n-        \/\/ fully initialized thanks to the HB properties of StableValue.\n-        int a, b, c, d, e;\n-\n-        Holder() {\n-            a = b = c = d = e = 1;\n-        }\n-    }\n-\n-    static final class Consumer implements Runnable {\n-\n-        final int[] observations = new int[SIZE];\n-        final StableValue<Holder>[] stables = STABLES;\n-        int i = 0;\n-\n-        @Override\n-        public void run() {\n-            for (; i < SIZE; i++) {\n-                StableValue<Holder> s = stables[i];\n-                Holder h;\n-                \/\/ Wait until the StableValue has a holder value\n-                while ((h = s.orElse(null)) == null) {}\n-                int a = h.a;\n-                int b = h.b;\n-                int c = h.c;\n-                int d = h.d;\n-                int e = h.e;\n-                observations[i] = a + (b << 1) + (c << 2) + (c << 3) + (d << 4) + (e << 5);\n-            }\n-        }\n-    }\n-\n-    static final class Producer implements Runnable {\n-\n-        final StableValue<Holder>[] stables = STABLES;\n-\n-        @Override\n-        public void run() {\n-            StableValue<Holder> s;\n-            long deadlineNs = System.nanoTime();\n-            for (int i = 0; i < SIZE; i++) {\n-                s = stables[i];\n-                s.trySet(new Holder());\n-                deadlineNs += 1000;\n-                while (System.nanoTime() < deadlineNs) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test\n-    void main() {\n-        List<Consumer> consumers = IntStream.range(0, THREADS)\n-                .mapToObj(_ -> new Consumer())\n-                .toList();\n-\n-        List<Thread> consumersThreads = IntStream.range(0, THREADS)\n-                .mapToObj(i -> Thread.ofPlatform()\n-                        .name(\"Consumer Thread \" + i)\n-                        .start(consumers.get(i)))\n-                .toList();\n-\n-        Producer producer = new Producer();\n-\n-        Thread producerThread = Thread.ofPlatform()\n-                .name(\"Producer Thread\")\n-                .start(producer);\n-\n-        join(consumers, producerThread);\n-        join(consumers, consumersThreads.toArray(Thread[]::new));\n-\n-        int[] histogram = new int[64];\n-        for (Consumer consumer : consumers) {\n-            for (int i = 0; i < SIZE; i++) {\n-                histogram[consumer.observations[i]]++;\n-            }\n-        }\n-\n-        \/\/ unless a = 1, ..., e = 1, zero observations should be seen\n-        for (int i = 0; i < 63; i++) {\n-            assertEquals(0, histogram[i]);\n-        }\n-        \/\/ a = 1, ..., e = 1 : index 2^5-1 = 63\n-        \/\/ All observations should end up in this bucket\n-        assertEquals(THREADS * SIZE, histogram[63]);\n-    }\n-\n-    static void join(List<Consumer> consumers, Thread... threads) {\n-        try {\n-            for (Thread t:threads) {\n-                long deadline = System.nanoTime() + TimeUnit.MINUTES.toNanos(1);\n-                while (t.isAlive()) {\n-                    t.join(TimeUnit.SECONDS.toMillis(10));\n-                    if (t.isAlive()) {\n-                        String stack = Arrays.stream(t.getStackTrace())\n-                                .map(Objects::toString)\n-                                .collect(Collectors.joining(System.lineSeparator()));\n-                        System.err.println(t + \": \" + stack);\n-                        for (int i = 0; i < consumers.size(); i++) {\n-                            System.err.println(\"Consumer \" + i + \": \" + consumers.get(i).i);\n-                        }\n-                    }\n-                    if (System.nanoTime() > deadline) {\n-                        long nonNulls = CompletableFuture.supplyAsync(() ->\n-                                Stream.of(STABLES)\n-                                        .map(s -> s.orElse(null))\n-                                        .filter(Objects::nonNull)\n-                                        .count(), Executors.newSingleThreadExecutor()).join();\n-                        fail(\"Giving up! Set stables seen by a new thread: \" + nonNulls);\n-                    }\n-                }\n-            }\n-        } catch (InterruptedException ie) {\n-            fail(ie);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValuesSafePublicationTest.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @summary Basic tests for TrustedFieldType implementations\n- * @modules jdk.unsupported\/sun.misc\n- * @modules java.base\/jdk.internal.lang.stable\n- * @modules java.base\/jdk.internal.misc\n- * @enablePreview\n- * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n- * @run junit\/othervm -Dopens=false TrustedFieldTypeTest\n- *\/\n-\n-import jdk.internal.lang.stable.StableValueImpl;\n-import jdk.internal.misc.Unsafe;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InaccessibleObjectException;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class TrustedFieldTypeTest {\n-\n-    @Test\n-    void varHandle() throws NoSuchFieldException, IllegalAccessException {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-        StableValue<Integer> originalValue = StableValue.of();\n-        @SuppressWarnings(\"unchecked\")\n-        StableValue<Integer>[] originalArrayValue = new StableValue[10];\n-\n-        final class Holder {\n-            private final StableValue<Integer> value = originalValue;\n-        }\n-        final class ArrayHolder {\n-            private final StableValue<Integer>[] array = originalArrayValue;\n-        }\n-\n-\n-        VarHandle valueVarHandle = lookup.findVarHandle(Holder.class, \"value\", StableValue.class);\n-        Holder holder = new Holder();\n-\n-        assertThrows(UnsupportedOperationException.class, () ->\n-                valueVarHandle.set(holder, StableValue.of())\n-        );\n-\n-        assertThrows(UnsupportedOperationException.class, () ->\n-                valueVarHandle.compareAndSet(holder, originalValue, StableValue.of())\n-        );\n-\n-        VarHandle arrayVarHandle = lookup.findVarHandle(ArrayHolder.class, \"array\", StableValue[].class);\n-        ArrayHolder arrayHolder = new ArrayHolder();\n-\n-        assertThrows(UnsupportedOperationException.class, () ->\n-                arrayVarHandle.set(arrayHolder, new StableValue[1])\n-        );\n-\n-        assertThrows(UnsupportedOperationException.class, () ->\n-                arrayVarHandle.compareAndSet(arrayHolder, originalArrayValue, new StableValue[1])\n-        );\n-\n-    }\n-\n-    @Test\n-    void updateStableValueContentVia_j_i_m_Unsafe() {\n-        StableValue<Integer> stableValue = StableValue.of();\n-        stableValue.trySet(42);\n-        jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        long offset = unsafe.objectFieldOffset(stableValue.getClass(), \"contents\");\n-        assertTrue(offset > 0);\n-\n-        \/\/ Unfortunately, it is possible to update the underlying data via jdk.internal.misc.Unsafe\n-        Object oldData = unsafe.getAndSetReference(stableValue, offset, 13);\n-        assertEquals(42, oldData);\n-        assertEquals(13, stableValue.orElseThrow());\n-    }\n-\n-    @Test\n-    void updateStableValueContentViaSetAccessible() throws NoSuchFieldException, IllegalAccessException {\n-\n-        if (Boolean.getBoolean(\"opens\")) {\n-            \/\/ Unfortunately, add-opens allows direct access to the `value` field\n-            Field field = StableValueImpl.class.getDeclaredField(\"contents\");\n-            field.setAccessible(true);\n-\n-            StableValue<Integer> stableValue = StableValue.of();\n-            stableValue.trySet(42);\n-\n-            Object oldData = field.get(stableValue);\n-            assertEquals(42, oldData);\n-\n-            field.set(stableValue, 13);\n-            assertEquals(13, stableValue.orElseThrow());\n-        } else {\n-            Field field = StableValueImpl.class.getDeclaredField(\"contents\");\n-            assertThrows(InaccessibleObjectException.class, ()-> field.setAccessible(true));\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/StableValue\/TrustedFieldTypeTest.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -223,2 +223,2 @@\n-        testEmptyList(StableValue.list(0, i -> i));\n-        testEmptyList(StableValue.list(3, i -> i).subList(0, 0));\n+        testEmptyList(List.ofLazy(0, i -> i));\n+        testEmptyList(List.ofLazy(3, i -> i).subList(0, 0));\n@@ -227,1 +227,1 @@\n-        testListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n+        testListMutatorsAlwaysThrow(List.ofLazy(0, i -> i));\n@@ -230,2 +230,2 @@\n-        testEmptyListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n-        testEmptyListMutatorsAlwaysThrow(StableValue.list(3, i -> i).subList(0, 0));\n+        testEmptyListMutatorsAlwaysThrow(List.ofLazy(0, i -> i));\n+        testEmptyListMutatorsAlwaysThrow(List.ofLazy(3, i -> i).subList(0, 0));\n@@ -254,3 +254,3 @@\n-                StableValue.list(0, i -> i),\n-                StableValue.list(3, i -> i),\n-                StableValue.list(10, i -> i))) {\n+                List.ofLazy(0, i -> i),\n+                List.ofLazy(3, i -> i),\n+                List.ofLazy(10, i -> i))) {\n@@ -368,3 +368,3 @@\n-        testEmptyMap(StableValue.map(Set.of(), k -> k));\n-        testMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n-        testEmptyMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n+        testEmptyMap(Map.ofLazy(Set.of(), k -> k));\n+        testMapMutatorsAlwaysThrow(Map.ofLazy(Set.of(), k -> k));\n+        testEmptyMapMutatorsAlwaysThrow(Map.ofLazy(Set.of(), k -> k));\n@@ -384,3 +384,3 @@\n-                StableValue.map(Set.<Integer>of(), k -> k),\n-                StableValue.map(Set.of(1), k -> k),\n-                StableValue.map(Set.of(1, 2, 3), k -> k))) {\n+                Map.ofLazy(Set.<Integer>of(), k -> k),\n+                Map.ofLazy(Set.of(1), k -> k),\n+                Map.ofLazy(Set.of(1, 2, 3), k -> k))) {\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -949,1 +949,1 @@\n-        assertCompletion(\"String s() { return \\\"\\\"; } import java.util.List; List.o|\", true, \"of(\");\n+        assertCompletion(\"String s() { return \\\"\\\"; } import java.util.List; List.o|\", true, \"of(\", \"ofLazy(\");\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.stable;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-\/**\n- * Benchmark measuring StableValue performance\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(value = 2, jvmArgsAppend = {\n-        \"--enable-preview\"\n-})\n-@Threads(Threads.MAX)   \/\/ Benchmark under contention\n-@OperationsPerInvocation(100)\n-public class StableFunctionBenchmark {\n-\n-    private static final int SIZE = 100;\n-    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n-\n-    private static final Map<Integer, Integer> MAP = StableValue.map(SET, Function.identity());\n-    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n-\n-    private final Map<Integer, Integer> map = StableValue.map(SET, Function.identity());\n-    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n-\n-    @Benchmark\n-    public int map() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += map.get(i);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int function() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += function.apply(i);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int staticSMap() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += MAP.get(i);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int staticIntFunction() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += FUNCTION.apply(i);\n-        }\n-        return sum;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionBenchmark.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.stable;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-\/**\n- * Benchmark measuring StableValue performance\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(value = 2, jvmArgsAppend = {\n-        \"--enable-preview\"\n-})\n-@Threads(Threads.MAX)   \/\/ Benchmark under contention\n-public class StableFunctionSingleBenchmark {\n-\n-    private static final int SIZE = 100;\n-    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n-\n-    private static final Map<Integer, Integer> MAP = StableValue.map(SET, Function.identity());\n-    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n-\n-    private final Map<Integer, Integer> map = StableValue.map(SET, Function.identity());\n-    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n-\n-    @Benchmark\n-    public int map() {\n-        return map.get(1);\n-    }\n-\n-    @Benchmark\n-    public int function() {\n-        return function.apply(1);\n-    }\n-\n-    @Benchmark\n-    public int staticSMap() {\n-        return MAP.get(1);\n-    }\n-\n-    @Benchmark\n-    public int staticIntFunction() {\n-        return FUNCTION.apply(1);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionSingleBenchmark.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.stable;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.IntFunction;\n-\n-\/**\n- * Benchmark measuring StableValue performance\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(value = 2, jvmArgsAppend = {\n-        \"--enable-preview\"\n-})\n-@Threads(Threads.MAX)   \/\/ Benchmark under contention\n-@OperationsPerInvocation(100)\n-public class StableIntFunctionBenchmark {\n-\n-    private static final int SIZE = 100;\n-    private static final IntFunction<Integer> IDENTITY = i -> i;\n-\n-    private static final List<Integer> LIST = StableValue.list(SIZE, IDENTITY);\n-    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n-\n-    private final List<Integer> list = StableValue.list(SIZE, IDENTITY);\n-    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n-\n-    @Benchmark\n-    public int list() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += list.get(i);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int intFunction() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += intFunction.apply(i);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int staticList() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += LIST.get(i);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int staticIntFunction() {\n-        int sum = 0;\n-        for (int i = 0; i < SIZE; i++) {\n-            sum += INT_FUNCTION.apply(i);\n-        }\n-        return sum;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionBenchmark.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.stable;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.IntFunction;\n-\n-\/**\n- * Benchmark measuring StableValue performance\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(value = 2, jvmArgsAppend = {\n-        \"--enable-preview\"\n-})\n-@Threads(Threads.MAX)   \/\/ Benchmark under contention\n-public class StableIntFunctionSingleBenchmark {\n-\n-    private static final int SIZE = 100;\n-    private static final IntFunction<Integer> IDENTITY = i -> i;\n-\n-    private static final List<Integer> STABLE = StableValue.list(SIZE, IDENTITY);\n-    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n-\n-    private final List<Integer> stable = StableValue.list(SIZE, IDENTITY);\n-    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n-\n-    @Benchmark\n-    public int list() {\n-        return stable.get(1);\n-    }\n-\n-    @Benchmark\n-    public int intFunction() {\n-        return intFunction.apply(1);\n-    }\n-\n-    @Benchmark\n-    public int staticList() {\n-        return STABLE.get(1);\n-    }\n-\n-    @Benchmark\n-    public int staticIntFunction() {\n-        return INT_FUNCTION.apply(1);\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionSingleBenchmark.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring stable list performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableListBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> LIST = List.ofLazy(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = LIST::get;\n+\n+    private final List<Integer> list = List.ofLazy(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = list::get;\n+\n+    @Benchmark\n+    public int list() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += list.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int intFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += intFunction.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += LIST.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += INT_FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableListBenchmark.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring stable list performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableListSingleBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> STABLE = List.ofLazy(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = STABLE::get;\n+\n+    private final List<Integer> stable = List.ofLazy(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = stable::get;\n+\n+    @Benchmark\n+    public int list() {\n+        return stable.get(1);\n+    }\n+\n+    @Benchmark\n+    public int intFunction() {\n+        return intFunction.apply(1);\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        return STABLE.get(1);\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        return INT_FUNCTION.apply(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableListSingleBenchmark.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring stable map performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableMapBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> MAP = Map.ofLazy(SET, Function.identity());\n+    private static final Function<Integer, Integer> FUNCTION = MAP::get;\n+\n+    private final Map<Integer, Integer> map = Map.ofLazy(SET, Function.identity());\n+    private final Function<Integer, Integer> function = map::get;\n+\n+    @Benchmark\n+    public int map() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += map.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += function.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticMap() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += MAP.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMapBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.EnumSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring lazy map performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableMapSingleBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> MAP = Map.ofLazy(SET, Function.identity());\n+    private static final Map<MyEnum, Integer> MAP_ENUM = Map.ofLazy(EnumSet.allOf(MyEnum.class), MyEnum::ordinal);\n+    private static final Map<MyEnum, Optional<Integer>> MAP_ENUM_OPTIONAL = Map.ofLazy(EnumSet.allOf(MyEnum.class), e -> Optional.of(e.ordinal()));\n+    private static final Function<Integer, Integer> FUNCTION = MAP::get;\n+\n+    private final Map<Integer, Integer> map = Map.ofLazy(SET, Function.identity());\n+    private final Map<MyEnum, Integer> mapEnum = Map.ofLazy(EnumSet.allOf(MyEnum.class), MyEnum::ordinal);\n+    private final Function<Integer, Integer> function = map::get;\n+\n+    @Benchmark\n+    public int map() {\n+        return map.get(1);\n+    }\n+\n+    @Benchmark\n+    public int mapEnum() {\n+        return mapEnum.get(MyEnum.BAR);\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        return function.apply(1);\n+    }\n+\n+    @Benchmark\n+    public int staticMap() {\n+        return MAP.get(1);\n+    }\n+\n+    @Benchmark\n+    public int staticMapEnum() {\n+        return MAP_ENUM.get(MyEnum.BAR);\n+    }\n+\n+    @Benchmark\n+    public int staticMapEnumOptional() {\n+        return MAP_ENUM_OPTIONAL.get(MyEnum.BAR).orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        return FUNCTION.apply(1);\n+    }\n+\n+    private enum MyEnum {FOO, BAR}\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMapSingleBenchmark.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -38,2 +38,0 @@\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -43,1 +41,0 @@\n-import java.util.List;\n@@ -49,2 +46,1 @@\n-\n-import static java.lang.constant.ConstantDescs.*;\n+import java.lang.LazyConstant;\n@@ -53,1 +49,1 @@\n- * Benchmark measuring StableValue performance\n+ * Benchmark measuring lazy value performance\n@@ -67,1 +63,1 @@\n-    private static final StableValue<MethodHandle> STABLE_MH;\n+    private static final LazyConstant<MethodHandle> STABLE_MH = LazyConstant.of(StableMethodHandleBenchmark::identityHandle);\n@@ -73,1 +69,1 @@\n-    private static final Map<String, MethodHandle> STABLE_MAP = StableValue.map(Set.of(\"identityHandle\"), _ -> identityHandle());\n+    private static final Map<String, MethodHandle> STABLE_MAP = Map.ofLazy(Set.of(\"identityHandle\"), _ -> identityHandle());\n@@ -76,2 +72,0 @@\n-        STABLE_MH = StableValue.of();\n-        STABLE_MH.setOrThrow(identityHandle());\n@@ -113,1 +107,1 @@\n-        return (int) STABLE_MH.orElseThrow().invokeExact(1);\n+        return (int) STABLE_MH.get().invokeExact(1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMethodHandleBenchmark.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.util.function.Supplier;\n+import java.lang.LazyConstant;\n@@ -42,1 +42,1 @@\n- * Benchmark measuring StableValue performance\n+ * Benchmark measuring lazy constant performance\n@@ -59,4 +59,2 @@\n-    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n-    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n-    private static final Supplier<Integer> SUPPLIER = StableValue.supplier(() -> VALUE);\n-    private static final Supplier<Integer> SUPPLIER2 = StableValue.supplier(() -> VALUE);\n+    private static final LazyConstant<Integer> STABLE = init(VALUE);\n+    private static final LazyConstant<Integer> STABLE2 = init(VALUE2);\n@@ -64,4 +62,2 @@\n-    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n-    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n-    private final Supplier<Integer> supplier = StableValue.supplier(() -> VALUE);\n-    private final Supplier<Integer> supplier2 = StableValue.supplier(() -> VALUE2);\n+    private final LazyConstant<Integer> stable = init(VALUE);\n+    private final LazyConstant<Integer> stable2 = init(VALUE2);\n@@ -71,6 +67,1 @@\n-        return stable.orElseThrow() + stable2.orElseThrow();\n-    }\n-\n-    @Benchmark\n-    public int supplier() {\n-        return supplier.get() + supplier2.get();\n+        return stable.get() + stable2.get();\n@@ -81,6 +72,1 @@\n-        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n-    }\n-\n-    @Benchmark\n-    public int staticSupplier() {\n-        return SUPPLIER.get() + SUPPLIER2.get();\n+        return STABLE.get() + STABLE2.get();\n@@ -89,3 +75,2 @@\n-    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n-        m.trySet(value);\n-        return m;\n+    private static LazyConstant<Integer> init(Integer value) {\n+        return LazyConstant.of(() -> value);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableSupplierBenchmark.java","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Optional;\n@@ -30,0 +31,1 @@\n+import java.lang.LazyConstant;\n@@ -33,1 +35,1 @@\n- * Benchmark measuring StableValue performance\n+ * Benchmark measuring lazy constant performance\n@@ -50,4 +52,4 @@\n-    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n-    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n-    private static final StableValue<Integer> DCL = init(StableValue.of(), VALUE);\n-    private static final StableValue<Integer> DCL2 = init(StableValue.of(), VALUE2);\n+    private static final LazyConstant<Integer> STABLE = init(VALUE);\n+    private static final LazyConstant<Integer> STABLE2 = init(VALUE2);\n+    private static final Supplier<Integer> DCL = new Dcl<>(() -> VALUE);\n+    private static final Supplier<Integer> DCL2 = new Dcl<>(() -> VALUE2);\n@@ -61,4 +63,7 @@\n-    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n-    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n-    private final StableValue<Integer> stableNull = StableValue.of();\n-    private final StableValue<Integer> stableNull2 = StableValue.of();\n+    private static final LazyConstant<Optional<Integer>> OPTIONAL_42 = LazyConstant.of(() -> Optional.of(42));\n+    private static final LazyConstant<Optional<Integer>> OPTIONAL_42_2 = LazyConstant.of(() -> Optional.of(42));\n+    private static final LazyConstant<Optional<Integer>> OPTIONAL_EMPTY = LazyConstant.of(Optional::empty);\n+    private static final LazyConstant<Optional<Integer>> OPTIONAL_EMPTY2 = LazyConstant.of(Optional::empty);\n+\n+    private final LazyConstant<Integer> stable = init(VALUE);\n+    private final LazyConstant<Integer> stable2 = init(VALUE2);\n@@ -72,7 +77,0 @@\n-\n-    @Setup\n-    public void setup() {\n-        stableNull.trySet(null);\n-        stableNull2.trySet(null);\n-    }\n-\n@@ -91,6 +89,1 @@\n-        return stable.orElseThrow() + stable2.orElseThrow();\n-    }\n-\n-    @Benchmark\n-    public int stableNull() {\n-        return (stableNull.orElseThrow() == null ? VALUE : VALUE2) + (stableNull2.orElseThrow() == null ? VALUE : VALUE2);\n+        return stable.get() + stable2.get();\n@@ -112,1 +105,1 @@\n-        return DCL.orElseThrow() + DCL2.orElseThrow();\n+        return DCL.get() + DCL2.get();\n@@ -120,0 +113,10 @@\n+    @Benchmark\n+    public int staticOptional42() {\n+        return OPTIONAL_42.get().orElseThrow() + OPTIONAL_42_2.get().orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public boolean staticOptionalEmpty() {\n+        return OPTIONAL_EMPTY.get().isEmpty() ^ OPTIONAL_EMPTY2.get().isEmpty();\n+    }\n+\n@@ -127,1 +130,1 @@\n-        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+        return STABLE.get() + STABLE2.get();\n@@ -131,3 +134,2 @@\n-    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n-        m.trySet(value);\n-        return m;\n+    private static LazyConstant<Integer> init(Integer value) {\n+        return LazyConstant.of(() -> value);\n@@ -138,1 +140,1 @@\n-        private final StableValue<Integer> delegate = StableValue.of();\n+        private final LazyConstant<Integer> delegate;\n@@ -141,1 +143,1 @@\n-            delegate.setOrThrow(value);\n+            delegate = LazyConstant.of(() -> value);\n@@ -145,1 +147,1 @@\n-            return delegate.orElseThrow();\n+            return delegate.get();\n@@ -150,1 +152,1 @@\n-    private record RecordHolder(StableValue<Integer> delegate) {\n+    private record RecordHolder(LazyConstant<Integer> delegate) {\n@@ -153,2 +155,1 @@\n-            this(StableValue.of());\n-            delegate.setOrThrow(value);\n+            this(LazyConstant.of(() -> value));\n@@ -158,1 +159,1 @@\n-            return delegate.orElseThrow();\n+            return delegate.get();\n@@ -163,1 +164,0 @@\n-\n@@ -170,1 +170,0 @@\n-        private boolean bound;\n@@ -180,9 +179,4 @@\n-                if (!bound) {\n-                    synchronized (this) {\n-                        v = value;\n-                        if (v == null) {\n-                            if (!bound) {\n-                                value = v = supplier.get();\n-                                bound = true;\n-                            }\n-                        }\n+                synchronized (this) {\n+                    v = value;\n+                    if (v == null) {\n+                        value = v = supplier.get();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableValueBenchmark.java","additions":39,"deletions":45,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.function.Supplier;\n@@ -78,2 +77,2 @@\n-    private static final Supplier<VarHandle> SV_X = StableValue.supplier(() -> VAR_HANDLE_FUNCTION.apply(\"x\"));\n-    private static final Supplier<VarHandle> SV_Y = StableValue.supplier(() -> VAR_HANDLE_FUNCTION.apply(\"y\"));\n+    private static final LazyConstant<VarHandle> SV_X = LazyConstant.of(() -> VAR_HANDLE_FUNCTION.apply(\"x\"));\n+    private static final LazyConstant<VarHandle> SV_Y = LazyConstant.of(() -> VAR_HANDLE_FUNCTION.apply(\"y\"));\n@@ -89,1 +88,1 @@\n-    private static final Map<String, VarHandle> S_MAP = StableValue.map(\n+    private static final Map<String, VarHandle> S_MAP = Map.ofLazy(\n@@ -93,3 +92,1 @@\n-    private static final Function<String, VarHandle> S_FUN = StableValue.function(\n-            Set.of(\"x\", \"y\"),\n-            VAR_HANDLE_FUNCTION);\n+    private static final Function<String, VarHandle> S_FUN = S_MAP::get;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/VarHandleHolderBenchmark.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}