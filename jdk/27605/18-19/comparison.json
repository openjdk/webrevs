{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.lang.LazyConstantImpl;\n@@ -58,2 +57,1 @@\n-            extends ImmutableCollections.AbstractImmutableList<E>\n-            implements LenientList<E>, ElementBackedList<E> {\n+            extends ImmutableCollections.AbstractImmutableList<E> {\n@@ -95,7 +93,0 @@\n-        @Override\n-        public E getAcquire(int i) {\n-            Objects.checkIndex(i, size);\n-            final long offset = offsetFor(i);\n-            return contentsAcquire(offset);\n-        }\n-\n@@ -156,16 +147,0 @@\n-        @Override\n-        public String toString() {\n-            return renderElements(this);\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public E[] elements() {\n-            return elements;\n-        }\n-\n-        @Override\n-        public Mutexes mutexes() {\n-            return mutexes;\n-        }\n-\n@@ -179,2 +154,1 @@\n-        static final class LazySubList<E> extends ImmutableCollections.SubList<E>\n-                implements LenientList<E> {\n+        static final class LazySubList<E> extends ImmutableCollections.SubList<E> {\n@@ -197,5 +171,0 @@\n-            @Override\n-            public String toString() {\n-                return renderElements(this);\n-            }\n-\n@@ -207,7 +176,0 @@\n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public E getAcquire(int index) {\n-                Objects.checkIndex(index, size);\n-                return ((LenientList<E>) root).getAcquire(offset + index);\n-            }\n-\n@@ -225,2 +187,1 @@\n-                extends ReverseOrderListView.Rand<E>\n-                implements LenientList<E> {\n+                extends ReverseOrderListView.Rand<E> {\n@@ -232,6 +193,0 @@\n-            \/\/ This method does not evaluate the elements\n-            @Override\n-            public String toString() {\n-                return renderElements(this);\n-            }\n-\n@@ -244,7 +199,0 @@\n-\n-            @Override\n-            public E getAcquire(int i) {\n-                final int size = base.size();\n-                Objects.checkIndex(i, size);\n-                return ((LenientList<E>) base).getAcquire(size - i - 1);\n-            }\n@@ -252,9 +200,0 @@\n-\n-    }\n-\n-    interface LenientList<E> extends List<E> {\n-        \/**\n-         * {@return the element at index {@code i} without evaluating it}\n-         * @param i index\n-         *\/\n-        E getAcquire(int i);\n@@ -437,5 +376,0 @@\n-            @Override\n-            public String toString() {\n-                return renderMappings(map, \"Collection\", false);\n-            }\n-\n@@ -504,1 +438,1 @@\n-            @Override public String toString() { return getKey() + \"=\" + LazyConstantImpl.renderConstant(map.getAcquire(getKey)); }\n+            @Override public String toString() { return getKey() + \"=\" + getValue(); }\n@@ -542,16 +476,0 @@\n-            @Override\n-            public String toString() {\n-                final StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n-                for (var k : map.keySet()) {\n-                    final Object value = map.getAcquire(k);\n-                    final String valueString;\n-                    if (value == map) {\n-                        valueString = \"(this Collection)\";\n-                    } else {\n-                        valueString = LazyConstantImpl.renderConstant(value);\n-                    }\n-                    sj.add(valueString);\n-                }\n-                return sj.toString();\n-            }\n-\n@@ -565,13 +483,0 @@\n-        @Override\n-        public String toString() {\n-            return renderMappings(this, \"Map\", true);\n-        }\n-\n-    }\n-\n-    interface ElementBackedList<E> {\n-\n-        E[] elements();\n-\n-        Mutexes mutexes();\n-\n@@ -622,1 +527,0 @@\n-\n@@ -677,13 +581,0 @@\n-    public static String renderElements(LenientList<?> self) {\n-        final StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n-        for (int i = 0; i < self.size(); i++) {\n-            final Object e = self.getAcquire(i);\n-            if (e == self) {\n-                sj.add(\"(this Collection)\");\n-            } else {\n-                sj.add(LazyConstantImpl.renderConstant(e));\n-            }\n-        }\n-        return sj.toString();\n-    }\n-\n@@ -772,17 +663,0 @@\n-    public static <K, V> String renderMappings(AbstractLazyMap<K, V> self,\n-                                               String selfName,\n-                                               boolean curly) {\n-        final StringJoiner sj = new StringJoiner(\", \", curly ? \"{\" : \"[\", curly ? \"}\" : \"]\");\n-        for (var k : self.keySet()) {\n-            final Object value = self.getAcquire(k);\n-            final String valueString;\n-            if (value == self) {\n-                valueString = \"(this \" + selfName + \")\";\n-            } else {\n-                valueString = LazyConstantImpl.renderConstant(value);\n-            }\n-            sj.add(k + \"=\" + valueString);\n-        }\n-        return sj.toString();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/LazyCollections.java","additions":4,"deletions":130,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-    static final String UNSET_LABEL = \".uninitialized\";\n-\n@@ -115,2 +113,1 @@\n-        final T t = getAcquire();\n-        return t == this ? \"(this LazyConstant)\" : renderConstant(t);\n+        return super.toString() + \"[\" + toStringSuffix() + \"]\";\n@@ -119,2 +116,16 @@\n-    public static String renderConstant(Object t) {\n-        return (t == null) ? UNSET_LABEL : Objects.toString(t);\n+    private String toStringSuffix() {\n+        final T t = getAcquire();\n+        if (t == this) {\n+            return \"(this LazyConstant)\";\n+        } else if (t != null) {\n+            return t.toString();\n+        }\n+        \/\/ Volatile read\n+        final Supplier<? extends T> cf = computingFunction;\n+        \/\/ There could be a race here\n+        if (cf != null) {\n+            return \"computing function=\" + computingFunction.toString();\n+        }\n+        \/\/ As we know `computingFunction` is `null` via a volatile read, we\n+        \/\/ can now be sure that this lazy constant is initialized\n+        return getAcquire().toString();\n@@ -123,0 +134,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/LazyConstantImpl.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        assertEquals(LazyConstantTestUtil.UNINITIALIZED_TAG, lazy.toString());\n+        assertFalse(lazy.isInitialized());\n@@ -65,1 +65,1 @@\n-        assertEquals(Objects.toString(SUPPLIER.get()), lazy.toString());\n+        assertTrue(lazy.toString().contains(Integer.toString(SUPPLIER.get())));\n@@ -79,1 +79,1 @@\n-        assertEquals(LazyConstantTestUtil.UNINITIALIZED_TAG, lazy.toString());\n+        assertTrue(lazy.toString().contains(\"computing function\"));\n@@ -130,1 +130,5 @@\n-        assertEquals(LazyConstantTestUtil.UNINITIALIZED_TAG, constant.toString());\n+        String unInitializedToString = constant.toString();\n+        int suffixEnd = unInitializedToString.indexOf(\"[\");\n+        String suffix = unInitializedToString.substring(0, suffixEnd);\n+        String expectedUninitialized = suffix+\"[computing function=\";\n+        assertTrue(unInitializedToString.startsWith(expectedUninitialized));\n@@ -132,1 +136,2 @@\n-        assertEquals(Integer.toString(VALUE), constant.toString());\n+        String expectedInitialized = suffix + \"[\" + VALUE + \"]\";\n+        assertEquals(expectedInitialized, constant.toString());\n@@ -142,1 +147,1 @@\n-        assertEquals(\"(this LazyConstant)\", toString);\n+        assertTrue(constant.toString().contains(\"(this LazyConstant)\"), toString);\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyConstantTest.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<>(IDENTITY);\n+        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<Integer>(IDENTITY);\n@@ -91,1 +91,1 @@\n-        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<>(_ -> {\n+        LazyConstantTestUtil.CountingIntFunction<Integer> cif = new LazyConstantTestUtil.CountingIntFunction<Integer>(_ -> {\n@@ -158,6 +158,1 @@\n-        var lazy = List.ofLazy(2, IDENTITY);\n-        assertEquals(\"[\" + LazyConstantTestUtil.UNINITIALIZED_TAG + \", \" + LazyConstantTestUtil.UNINITIALIZED_TAG + \"]\", lazy.toString());\n-        lazy.get(0);\n-        assertEquals(\"[0, \" + LazyConstantTestUtil.UNINITIALIZED_TAG + \"]\", lazy.toString());\n-        lazy.get(1);\n-        assertEquals(\"[0, 1]\", lazy.toString());\n+        assertEquals(\"[0, 1]\", List.ofLazy(2, IDENTITY).toString());\n@@ -181,9 +176,0 @@\n-    @Test\n-    void equalsPartialEvaluationTest() {\n-        var lazy = List.ofLazy(2, IDENTITY);\n-        assertFalse(lazy.equals(List.of(0)));\n-        assertEquals(\"[0, \" + LazyConstantTestUtil.UNINITIALIZED_TAG + \"]\", lazy.toString());\n-        assertTrue(lazy.equals(List.of(0, 1)));\n-        assertEquals(\"[0, 1]\", lazy.toString());\n-    }\n-\n@@ -241,4 +227,0 @@\n-    void assertUnevaluated(List<Integer> subList) {\n-        assertEquals(asString(LazyConstantTestUtil.UNINITIALIZED_TAG, subList), subList.toString());\n-    }\n-\n@@ -275,1 +257,1 @@\n-        var expectedToString = expected.toString().replace(\"2\", LazyConstantTestUtil.UNINITIALIZED_TAG);\n+        var expectedToString = expected.toString();\n@@ -296,4 +278,0 @@\n-                    assertUnevaluated(list);\n-                    assertUnevaluated(view1);\n-                    assertUnevaluated(view2);\n-                    assertUnevaluated(view3);\n@@ -370,33 +348,0 @@\n-    @Test\n-    void childObjectOpsLazy() {\n-        viewOperations().forEach(op0 -> {\n-            viewOperations().forEach(op1 -> {\n-                viewOperations().forEach(op2 -> {\n-                    childOperations().forEach(co -> {\n-                        var list = newLazyList();\n-                        var view1 = op0.apply(list);\n-                        var view2 = op1.apply(view1);\n-                        var view3 = op2.apply(view2);\n-                        var child = co.apply(view3);\n-                        var childClassName = className(child);\n-                        var transitions = className(list) + \", \" +\n-                                op0 + \" -> \" + className(view1) + \", \" +\n-                                op1 + \" -> \" + className(view2) + \", \" +\n-                                op2 + \" -> \" + className(view3) + \", \" +\n-                                co + \" -> \" + childClassName;\n-\n-                        \/\/ None of these operations should trigger evaluation\n-                        var childToString = child.toString();\n-                        int childHashCode = child.hashCode();\n-                        boolean childEqualToNewObj = child.equals(new Object());\n-\n-                        assertUnevaluated(list);\n-                        assertUnevaluated(view1);\n-                        assertUnevaluated(view2);\n-                        assertUnevaluated(view3);\n-                    });\n-                });\n-            });\n-        });\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyListTest.java","additions":4,"deletions":59,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import static java.util.stream.Collectors.mapping;\n@@ -144,6 +145,2 @@\n-        var toString = lazy.toString();\n-        assertTrue(toString.startsWith(\"{\"));\n-        \/\/ Key order is unspecified\n-        assertTrue(toString.contains(Value.THIRTEEN + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n-        assertTrue(toString.contains(Value.FORTY_TWO + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n-        assertTrue(toString.endsWith(\"}\"));\n+        assertThrows(UnsupportedOperationException.class, lazy::toString);\n+        assertEquals(3, cif.cnt());\n@@ -152,1 +149,0 @@\n-\n@@ -201,3 +197,0 @@\n-            toString = lazy.toString();\n-            assertTrue(toString.contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG), toString + \" did not contain \" + key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG);\n-            lazy.get(key);\n@@ -270,1 +263,1 @@\n-            assertTrue(toString.contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n+            assertTrue(toString.contains(key + \"=\" + MAPPER.apply(key)));\n@@ -274,9 +267,0 @@\n-\n-        lazy.get(KEY);\n-        for (var key : set) {\n-            if (key.equals(KEY)) {\n-                continue;\n-            }\n-            assertTrue(lazyEntrySet.toString().contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n-        }\n-        assertTrue(lazyEntrySet.toString().contains(KEY + \"=\" + VALUE));\n@@ -292,9 +276,1 @@\n-        var toString = lazy.toString();\n-        for (var key : set) {\n-            var v = MAPPER.apply(key);\n-            if (v.equals(val)) {\n-                assertTrue(toString.contains(key + \"=\" + v));\n-            } else {\n-                assertTrue(toString.contains(key + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG));\n-            }\n-        }\n+        assertEquals(lazy.size() - 1, functionCounter(lazy));\n@@ -316,7 +292,8 @@\n-        var expected = set.stream()\n-                .map(_ -> LazyConstantTestUtil.UNINITIALIZED_TAG)\n-                .collect(joining(\", \", \"[\", \"]\"));\n-        assertEquals(expected, lazyValues.toString());\n-        lazy.get(KEY);\n-        var afterGet = lazyValues.toString();\n-        assertEquals(set.contains(KEY), afterGet.contains(\"\" + VALUE), afterGet);\n+        var toString = lazyValues.toString();\n+\n+        \/\/ Key order is unspecified\n+        for (Value key : set) {\n+            assertTrue(toString.contains(MAPPER.apply(key).toString()), toString);\n+        }\n+        assertTrue(toString.startsWith(\"[\"), toString);\n+        assertTrue(toString.endsWith(\"]\"), toString);\n@@ -362,1 +339,1 @@\n-        assertEquals(KEY + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG, entry.toString());\n+        assertEquals(lazy.size(), functionCounter(lazy));\n@@ -365,1 +342,1 @@\n-        assertEquals(KEY + \"=\" + LazyConstantTestUtil.UNINITIALIZED_TAG, entry.toString());\n+        assertEquals(lazy.size(), functionCounter(lazy));\n@@ -368,1 +345,1 @@\n-        assertEquals(KEY + \"=\" + VALUE, entry.toString());\n+        assertEquals(lazy.size() - 1, functionCounter(lazy));\n@@ -378,2 +355,1 @@\n-        lazy.entrySet().iterator()\n-                .forEachRemaining(e -> assertTrue(e.toString().contains(LazyConstantTestUtil.UNINITIALIZED_TAG)));\n+        assertEquals(lazy.size(), functionCounter(lazy)); \/\/ No evaluation\n@@ -382,2 +358,1 @@\n-        lazy.entrySet().iterator()\n-                .forEachRemaining(e -> assertFalse(e.toString().contains(LazyConstantTestUtil.UNINITIALIZED_TAG)));\n+        assertEquals(0, functionCounter(lazy));\n@@ -593,0 +568,5 @@\n+    private static int functionCounter(Map<?, ?> lazy) {\n+        final Object holder = LazyConstantTestUtil.functionHolder(lazy);\n+        return LazyConstantTestUtil.functionHolderCounter(holder);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyMapTest.java","additions":23,"deletions":43,"binary":false,"changes":66,"status":"modified"}]}