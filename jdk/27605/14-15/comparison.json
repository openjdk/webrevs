{"files":[{"patch":"@@ -32,5 +32,1 @@\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.*;\n@@ -46,7 +42,8 @@\n- * When created, the contents (and hence the lazy constant itself) is <em>not initialized<\/em>.\n- * The contents (of type {@code T}) can then be <em>initialized<\/em>\n- * (and retrieved) by calling {@linkplain #get()}. The first time {@linkplain #get()}\n- * is called, the underlying <em>computing function<\/em> (provided at construction) will\n- * be invoked and the result will be used to initialize the contents. Once initialized,\n- * the contents can <em>never change<\/em> and will be retrieved over and over\n- * again upon subsequent {@linkplain #get() get} invocations.\n+ * When created, the lazy constant is <em>not initialized<\/em>, meaning it has no contents.\n+ * The lazy constant (of type {@code T}) can then be <em>initialized<\/em>\n+ * (and its contents retrieved) by calling {@linkplain #get()}. The first time\n+ * {@linkplain #get()} is called, the underlying <em>computing function<\/em>\n+ * (provided at construction) will be invoked and the result will be used to initialize\n+ * the constant. Once a lazy constant is initialized, its contents can <em>never change<\/em>\n+ * and will be retrieved over and over again upon subsequent {@linkplain #get() get}\n+ * invocations.\n@@ -54,7 +51,2 @@\n- * A lazy constant is <em>shallowly immutable<\/em>, meaning the reference to the contents\n- * object will never change once it is initialized. However, the referenced object itself\n- * may or may not be mutable. Hence, immutability can only be guaranteed at the first\n- * initial, shallow level.\n- * <p>\n- * Consider the following example where a lazy constant field \"{@code logger}\" is a\n- * shallowly immutable holder of an object of type {@code Logger}:\n+ * Consider the following example where a lazy constant field \"{@code logger}\" holds\n+ * an object of type {@code Logger}:\n@@ -77,5 +69,5 @@\n- * Initially, the lazy constant (and its contents) is <em>not initialized<\/em>.\n- * When {@code logger.get()} is first invoked, it evaluates the computing function and\n- * initializes the constant to the result; the result is then returned to the client.\n- * Hence, {@linkplain #get()} guarantees that the constant is <em>initialized<\/em> before\n- * it returns, barring any exceptions.\n+ * Initially, the lazy constant is <em>not initialized<\/em>. When {@code logger.get()}\n+ * is first invoked, it evaluates the computing function and initializes the constant to\n+ * the result; the result is then returned to the client. Hence, {@linkplain #get()}\n+ * guarantees that the constant is <em>initialized<\/em> before it returns, barring\n+ * any exceptions.\n@@ -84,4 +76,4 @@\n- * invoke the computing function simultaneously, only one is ever selected for\n- * computation. This property is crucial as evaluation of the computing function may have\n- * side effects, for example, the call above to {@code Logger.create()} may result in\n- * storage resources being prepared.\n+ * invoke the computing function simultaneously, {@linkplain ##thread-safety only one is\n+ * ever selected} for computation. This property is crucial as evaluation of the computing\n+ * function may have side effects, for example, the call above to {@code Logger.create()}\n+ * may result in storage resources being prepared.\n@@ -100,3 +92,1 @@\n- * lazy constant remains uninitialized. In other words, upon an unsuccessful invocation of\n- * the computing function, neither a constant, the exception, nor the fact that\n- * an exception was thrown is ever stored in the lazy constant.\n+ * lazy constant remains uninitialized.\n@@ -153,2 +143,2 @@\n- * the initialized constant is read. Hence, the initialized constant, including any\n- * {@code final} fields of any newly created objects, is safely published.\n+ * the initialized constant's content is read. Hence, the initialized constant's content,\n+ * including any {@code final} fields of any newly created objects, is safely published.\n@@ -158,1 +148,1 @@\n- * the interrupted thread’s status, nor does it throw an InterruptedException.\n+ * the interrupted thread’s status, nor does it throw an {@linkplain InterruptedException}.\n@@ -164,9 +154,8 @@\n- * A lazy constant can never change after it has been initialized. Therefore,\n- * a JVM implementation may, for an initialized lazy constant, elide all future reads\n- * of that lazy constant and instead directly use any constant that it has previously\n- * observed. We call this optimization <em>constant folding<\/em>. This is only possible if\n- * the reference to the lazy constant is a VM constant (e.g. in cases where\n- * the lazy constant itself is stored in a {@code static final} field) or forms\n- * a trusted chain to such a VM constant via one or more trusted fields (i.e., any\n- * combination of static final fields, {@linkplain Record record} fields, or\n- * final instance fields in hidden classes).\n+ * The contents of lazy constant can never change after it has been initialized. Therefore,\n+ * a JVM implementation may, for an initialized lazy constant, elide all future reads of\n+ * that lazy constant's contents and instead use the contents that has been previously\n+ * observed. We call this optimization <em>constant folding<\/em>. This is only possible\n+ * if the reference to the lazy constant in a {@code static final} field or forms\n+ * a trusted chain to such a field via one or more trusted fields (i.e., any\n+ * combination of {@code static final} fields, {@linkplain Record record} fields,\n+ * lazy constants, lazy lists, lazy maps, or final instance fields in hidden classes).\n@@ -179,2 +168,2 @@\n- * @apiNote Once a lazy constant is initialized with an object, the object cannot ever be\n- *          removed. This can be a source of an unintended memory leak. More specifically,\n+ * @apiNote Once a lazy constant is initialized, its contents cannot ever be removed.\n+ *          This can be a source of an unintended memory leak. More specifically,\n@@ -182,3 +171,2 @@\n- *          the object it was initialized with. Hence, a lazy constant will hold\n- *          the object it was initialized with until the lazy constant itself\n- *          is collected (if ever).\n+ *          it contents. Hence, a lazy constant will hold its contents until\n+ *          the lazy constant itself is collected (if ever).\n@@ -186,7 +174,4 @@\n- *          A {@code LazyConstant} that has a type parameter {@code T} that is an\n- *          array type (of arbitrary rank) will only allow the JVM to treat the\n- *          <em>array reference<\/em> as a constant, but <em>not its components<\/em>.\n- *          Instead, a {@linkplain List#ofLazy(int, IntFunction) lazy list} of\n- *          arbitrary depth can be used, which provides constant components.\n- *          More generally, a lazy constant can hold other lazy constants of\n- *          arbitrary depth and still provide transitive constant folding.\n+ *          A lazy constant whose contents is an array will not optimize access to\n+ *          the elements of such array. Instead, a\n+ *          {@linkplain List#ofLazy(int, IntFunction) lazy list} of arbitrary depth can\n+ *          be used, which provides constant components.\n@@ -203,0 +188,2 @@\n+ *           A lazy constant is unmodifiable but its contents may or may not be\n+ *           immutable (e.g., it may hold an {@linkplain ArrayList}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LazyConstant.java","additions":42,"deletions":55,"binary":false,"changes":97,"status":"modified"}]}