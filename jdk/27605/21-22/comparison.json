{"files":[{"patch":"@@ -89,4 +89,0 @@\n- * <p>\n- * If the computing function throws any unchecked {@linkplain Exception} or\n- * {@linkplain Error}, that {@linkplain Throwable} is propagated to the caller, and the\n- * lazy constant remains uninitialized.\n@@ -161,2 +157,2 @@\n- * {@linkplain Record record} fields, lazy constants, lazy lists, lazy maps,\n- * or final instance fields in hidden classes) -- to a lazy constant.\n+ * {@linkplain Record record} fields, or final instance fields in hidden classes) --\n+ * to a lazy constant.\n@@ -184,1 +180,1 @@\n- *          in {@jls 12.4} of <cite>The Java Language Specification<\/cite>.\n+ *          in section {@jls 12.4} of <cite>The Java Language Specification<\/cite>.\n@@ -209,1 +205,1 @@\n-     * {@return the contents of this lazy constant if initialized, otherwise,\\\n+     * {@return the contents of this lazy constant if initialized, otherwise,\n@@ -281,3 +277,1 @@\n-     * {@code computingFunction} until initialization completes successfully; after\n-     * which the computing function is no longer strongly referenced and becomes\n-     * eligible for garbage collection.\n+     * {@code computingFunction} at least until initialization completes successfully.\n@@ -289,0 +283,4 @@\n+     * @implNote  after initialization completes successfully, the computing function is\n+     *            no longer strongly referenced and becomes eligible for\n+     *            garbage collection.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LazyConstant.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.Stable;\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,6 +146,1 @@\n-            LazyConstant.of(new Supplier<HashSet<Currency>>() {\n-                @Override\n-                public HashSet<Currency> get() {\n-                    return computeAllCurrencies();\n-                }\n-            });\n+            LazyConstant.of(Currency::computeAllCurrencies);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Currency.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-            return orElseComputeSlowPath(elements, i, mutexes.acquireMutex(offsetFor(i)), i, functionHolder);\n+            return orElseComputeSlowPath(elements, i, mutexes, i, functionHolder);\n@@ -350,2 +350,1 @@\n-            final Object mutex = mutexes.acquireMutex(offset);\n-            return orElseComputeSlowPath(values, index, mutex, key, functionHolder);\n+            return orElseComputeSlowPath(values, index, mutexes, key, functionHolder);\n@@ -435,1 +434,1 @@\n-                        : orElseComputeSlowPath(map.values, index, map.mutexes.acquireMutex(offsetFor(index)), getKey, functionHolder);\n+                        : orElseComputeSlowPath(map.values, index, map.mutexes, getKey, functionHolder);\n@@ -487,1 +486,1 @@\n-        static final Object TOMB_STONE = new Mutexes.MutexObject(-1, Thread.currentThread().threadId());\n+        static final Object TOMB_STONE = new Object();\n@@ -509,1 +508,1 @@\n-            final Object candidate = new Mutexes.MutexObject(offset, Thread.currentThread().threadId());\n+            final Object candidate = new Object();\n@@ -511,1 +510,0 @@\n-            check(witness, offset);\n@@ -515,5 +513,2 @@\n-        @ForceInline\n-        private void disposeOfMutex(long offset) {\n-            UNSAFE.putReferenceVolatile(mutexes, offset, TOMB_STONE);\n-            \/\/ Todo: the null check is redundant as this method is invoked at most\n-            \/\/       `size()` times.\n+        private void releaseMutex(long offset) {\n+            UNSAFE.putReference(mutexes, offset, TOMB_STONE);\n@@ -521,2 +516,0 @@\n-                \/\/ We don't need these anymore\n-                counter = null;\n@@ -524,0 +517,1 @@\n+                counter = null;\n@@ -527,42 +521,0 @@\n-        \/\/ Todo: remove this after stabilization\n-        private Object check(Object mutex, long realOffset) {\n-            if (mutex == null || mutex == TOMB_STONE) {\n-                return mutex;\n-            }\n-            assert (mutex instanceof Mutexes.MutexObject(\n-                    long offset, long _\n-            )) && offset == realOffset :\n-                    mutex +\n-                            \", realOffset = \" + realOffset +\n-                            \", realThread = \" + Thread.currentThread().threadId();\n-            return mutex;\n-        }\n-\n-        \/\/ Todo: remove this after stabilization\n-        record MutexObject(long offset, long tid) { }\n-\n-    }\n-\n-    public static <E> int indexOf(List<LazyConstant<E>> list, Object o) {\n-        Objects.requireNonNull(o);\n-        if (o instanceof LazyConstant<?> s) {\n-            final int size = list.size();\n-            for (int i = 0; i < size; i++) {\n-                if (Objects.equals(s, list.get(i))) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public static <E> int lastIndexOf(List<LazyConstant<E>> list, Object o) {\n-        Objects.requireNonNull(o);\n-        if (o instanceof LazyConstant<?> s) {\n-            for (int i = list.size() - 1; i >= 0; i--) {\n-                if (Objects.equals(s, list.get(i))) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return -1;\n@@ -614,1 +566,1 @@\n-                                       final Object mutex,\n+                                       final Mutexes mutexes,\n@@ -617,0 +569,2 @@\n+        final long offset = offsetFor(index);\n+        final Object mutex = mutexes.acquireMutex(offset);\n@@ -621,20 +575,11 @@\n-                final T newValue;\n-                if (functionHolder == null) {\n-                    \/\/ If there is no functionHolder, the input must be a\n-                    \/\/ `Supplier` because we were called from `.orElseSet(Supplier)`\n-                    newValue = ((Supplier<T>) input).get();\n-                    Objects.requireNonNull(newValue);\n-                } else {\n-                    final Object u = functionHolder.function();\n-                    newValue = switch (u) {\n-                        case Supplier<?> sup -> (T) sup.get();\n-                        case IntFunction<?> iFun -> (T) iFun.apply((int) input);\n-                        case Function<?, ?> fun ->\n-                                ((Function<Object, T>) fun).apply(input);\n-                        default -> throw new InternalError(\"cannot reach here\");\n-                    };\n-                    Objects.requireNonNull(newValue);\n-                    \/\/ Reduce the counter and if it reaches zero, clear the reference\n-                    \/\/ to the underlying holder.\n-                    functionHolder.countDown();\n-                }\n+                final T newValue = switch (functionHolder.function()) {\n+                    case Supplier<?> sup     -> (T) sup.get();\n+                    case IntFunction<?> iFun -> (T) iFun.apply((int) input);\n+                    case Function<?, ?> fun  ->  ((Function<Object, T>) fun).apply(input);\n+                    default -> throw new InternalError(\"cannot reach here\");\n+                };\n+                Objects.requireNonNull(newValue);\n+                \/\/ Reduce the counter and if it reaches zero, clear the reference\n+                \/\/ to the underlying holder.\n+                functionHolder.countDown();\n+\n@@ -643,0 +588,2 @@\n+                \/\/ We do not need the mutex anymore\n+                mutexes.releaseMutex(offset);\n","filename":"src\/java.base\/share\/classes\/java\/util\/LazyCollections.java","additions":24,"deletions":77,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1200,1 +1200,1 @@\n-     * {@return a new lazily computed list with the provided {@code size}}\n+     * {@return a new lazily computed list of the provided {@code size}}\n@@ -1238,3 +1238,2 @@\n-     * function used to compute elements only so long as there are uncomputed elements\n-     * after which the computing function is not strongly referenced\n-     * anymore and may be collected.\n+     * function used to compute elements at least so long as there are uninitialized\n+     * elements.\n@@ -1244,0 +1243,4 @@\n+     * @implNote  after all elements have been initialized successfully, the computing\n+     *            function is no longer strongly referenced and becomes eligible for\n+     *            garbage collection.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1791,3 +1791,2 @@\n-     * computing function used to compute values only so long as there are\n-     * uncomputed values after which the underlying function is not strongly referenced\n-     * anymore and may be collected.\n+     * computing function used to compute values at least so long as there are\n+     * uncomputed values.\n@@ -1797,0 +1796,4 @@\n+     * @implNote  after all values have been initialized successfully, the computing\n+     *            function is no longer strongly referenced and becomes eligible for\n+     *            garbage collection.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}