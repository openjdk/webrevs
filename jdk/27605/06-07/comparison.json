{"files":[{"patch":"@@ -192,4 +192,0 @@\n- *          It is not recommended putting lazy constants into equality-based collections\n- *          (or similar constructs) prior to initialization if the underlying functions\n- *          have side effects or may fail.\n- *          <p>\n@@ -199,1 +195,1 @@\n- * @implSpec Except for {@linkplain #equals(Object) equals(obj)} and\n+ * @implSpec Except for {@linkplain Object#equals(Object) equals(obj)} and\n@@ -256,41 +252,1 @@\n-\n-    \/\/ Object methods\n-\n-    \/**\n-     * Indicates whether some other object is \"equal to\" this lazy constant.\n-     * <p>\n-     * The other object is considered equal if:\n-     * <ul>\n-     * <li>it is also an instance of {@code LazyConstant} and;\n-     * <li>the constant values obtained via {@linkplain #get()} are \"equal to\"\n-     * each other via {@code equals()}.\n-     * <\/ul>\n-     * <p>\n-     * In other words, equality is based solely on the initialized constants, not on\n-     * computing functions or lazy constants' identities.\n-     * <p>\n-     * This method may trigger initialization of this lazy constant and\/or the provided\n-     * {@code obj}, if it is an instance of a {@linkplain LazyConstant}. Consequently,\n-     * this method might block or throw.\n-     *\n-     * @implSpec The order of potential initialization triggering is specified as:\n-     * <ol>\n-     *     <li>{@code this} lazy constant<\/li>\n-     *     <li>{@code obj} lazy constant<\/li>\n-     * <\/ol>\n-     *\n-     * @param obj an object to be tested for equality (can be {@code null})\n-     * @return {@code true} if the other object is \"equal to\" this object\n-     *         otherwise {@code false}\n-     *\/\n-    @Override\n-    boolean equals(Object obj);\n-\n-    \/**\n-     * {@return the hash code of this constant}\n-     * <p>\n-     * This method may trigger initialization of this lazy constant. Consequently,\n-     * this method might block or throw.\n-     *\/\n-    @Override\n-    int hashCode();\n+    \/\/ Object method\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LazyConstant.java","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -113,15 +113,0 @@\n-    @Override\n-    public boolean equals(Object obj) {\n-        \/\/ In order to guarantee a happens-before edge between\n-        \/\/ any operation on a lazy constant, we need to read the constant\n-        \/\/ up front even though the `obj` might not be an instance of `LazyConstant`.\n-        final T t = get();\n-        return obj instanceof LazyConstant<?> that\n-                && t.equals(that.get());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return get().hashCode();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/LazyConstantImpl.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -107,8 +107,1 @@\n-        LazyConstant<Integer> c1 = LazyConstant.of(SUPPLIER);\n-        assertEquals(c1.hashCode(), constant.hashCode());\n-        constant.get();\n-        assertEquals(c1.hashCode(), constant.hashCode());\n-        c1.get();\n-        assertEquals(c1.hashCode(), constant.hashCode());\n-        LazyConstant<Integer> different = LazyConstant.of(() -> 13);\n-        assertNotEquals(different.hashCode(), constant.hashCode());\n+        assertEquals(System.identityHashCode(constant), constant.hashCode());\n@@ -121,10 +114,1 @@\n-        LazyConstant<Integer> s1 = LazyConstant.of(SUPPLIER);\n-        assertEquals(c0, s1);\n-        assertEquals(s1, c0);\n-        c0.get();\n-        assertEquals(c0, s1);\n-        assertEquals(s1, c0);\n-        s1.get();\n-        assertEquals(c0, s1);\n-        assertEquals(s1, c0);\n-        LazyConstant<Integer> different = LazyConstant.of(() -> 13);\n+        LazyConstant<Integer> different = LazyConstant.of(SUPPLIER);\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyConstantTest.java","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"}]}