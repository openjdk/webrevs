{"files":[{"patch":"@@ -45,8 +45,8 @@\n- * {@linkplain LazyConstant#of(Supplier)}. When created, the lazy constant is\n- * <em>not initialized<\/em>, which means the constant is not yet set. The constant,\n- * of type {@code T}, can then be <em>initialized<\/em> (and retrieved) by calling\n- * {@linkplain #get()}. The first time {@linkplain #get()} is called, an underlying\n- * <em>computing function<\/em> will be invoked which would compute\n- * the constant. The computing function is provided at construction. Once initialized,\n- * the constant can <em>never change<\/em> and can be retrieved over and over again\n- * by subsequent {@linkplain #get() get} invocations.\n+ * {@linkplain LazyConstant#of(Supplier) LazyConstant.of({@code <computing function>})}.\n+ * When created, the contents (and hence the lazy constant itself) is <em>not initialized<\/em>.\n+ * The contents (of type {@code T}) can then be <em>initialized<\/em>\n+ * (and retrieved) by calling {@linkplain #get()}. The first time {@linkplain #get()}\n+ * is called, the underlying <em>computing function<\/em> (provided at construction) will\n+ * be invoked and the result will be used to initialize the contents. Once initialized,\n+ * the contents can <em>never change<\/em> and will be retrieved over and over\n+ * again upon subsequent {@linkplain #get() get} invocations.\n@@ -54,4 +54,4 @@\n- * The term \"shallowly immutable\" means the reference to the constant will never change\n- * once it is initialized. However, the referenced object itself may or may not\n- * be mutable. Hence, immutability can only be guaranteed at the first initial, shallow\n- * level.\n+ * A lazy constant is <em>shallowly immutable<\/em>, meaning the reference to the contents\n+ * object will never change once it is initialized. However, the referenced object itself\n+ * may or may not be mutable. Hence, immutability can only be guaranteed at the first\n+ * initial, shallow level.\n@@ -60,1 +60,1 @@\n- * shallowly immutable holder of a constant of type {@code Logger}:\n+ * shallowly immutable holder of an object of type {@code Logger}:\n@@ -77,4 +77,5 @@\n- * Initially, the lazy constant is <em>not initialized<\/em>, until {@code logger.get()}\n- * evaluates the computing function, and initializes the constant to the result;\n- * the result is then returned to the client. Hence, {@linkplain #get()} guarantees that\n- * a lazy constant is <em>initialized<\/em> before it returns, barring any exceptions.\n+ * Initially, the lazy constant (and its contents) is <em>not initialized<\/em>.\n+ * When {@code logger.get()} is first invoked, it evaluates the computing function and\n+ * initializes the constant to the result; the result is then returned to the client.\n+ * Hence, {@linkplain #get()} guarantees that the constant is <em>initialized<\/em> before\n+ * it returns, barring any exceptions.\n@@ -90,2 +91,2 @@\n- * is thrown. Hence, a lazy constant can never be {@code null}. Clients that want to\n- * use a nullable constant can wrap the value into an {@linkplain Optional} holder.\n+ * is thrown. Hence, a lazy constant can never hold a {@code null} value. Clients who\n+ * want to use a nullable constant can wrap the value into an {@linkplain Optional} holder.\n@@ -94,1 +95,1 @@\n- * the lazy constant), an {@linkplain IllegalStateException} is thrown and the lazy\n+ * the lazy constant), an {@linkplain IllegalStateException} is thrown, and the lazy\n@@ -97,3 +98,3 @@\n- * If the computing function throws any unchecked exception or {@linkplain Error}, that\n- * {@linkplain Throwable} is propagated to the caller, and the lazy constant remains\n- * uninitialized. In other words, upon an unsuccessful invocation of\n+ * If the computing function throws any unchecked {@linkplain Exception} or\n+ * {@linkplain Error}, that {@linkplain Throwable} is propagated to the caller, and the\n+ * lazy constant remains uninitialized. In other words, upon an unsuccessful invocation of\n@@ -101,1 +102,1 @@\n- * an exception was thrown are ever stored in the lazy constant.\n+ * an exception was thrown is ever stored in the lazy constant.\n@@ -145,1 +146,1 @@\n- * runs the computing function (which is the caller's thread and is hereafter denoted\n+ * runs the computing function (which runs on the caller's thread and is hereafter denoted\n@@ -153,1 +154,1 @@\n- * {@code final} fields of any newly created objects, are safely published.\n+ * {@code final} fields of any newly created objects, is safely published.\n@@ -155,2 +156,2 @@\n- * Thread interruption does not cancel initialization of a lazy constant. In other words,\n- * if the computing thread is interrupted, {@code LazyConstant::get} doesn't clear\n+ * Thread interruption does not cancel the initialization of a lazy constant. In other\n+ * words, if the computing thread is interrupted, {@code LazyConstant::get} doesn't clear\n@@ -165,1 +166,1 @@\n- * of that lazy constant, and instead directly use any constant that it has previously\n+ * of that lazy constant and instead directly use any constant that it has previously\n@@ -173,6 +174,11 @@\n- * @apiNote As a lazy constant can be initialized with an object but, it is not\n- *          possible to ever remove that object, this can be a source of an unintended\n- *          memory leak. In other words, a lazy constant\n- *          {@linkplain java.lang.ref##reachability strongly references} the object\n- *          it was initialized with. Hence, a lazy constant will hold the object it\n- *          was initialized with until the lazy constant itself is collected (if ever).\n+ * <h2 id=\"miscellaneous\">Miscellaneous<\/h2>\n+ * Except for {@linkplain Object#equals(Object) equals(obj)} and\n+ * {@linkplain #orElse(Object) orElse(other)} parameters, all method parameters\n+ * must be <em>non-null<\/em>, or a {@link NullPointerException} will be thrown.\n+ *\n+ * @apiNote Once a lazy constant is initialized with an object, the object cannot ever be\n+ *          removed. This can be a source of an unintended memory leak. More specifically,\n+ *          a lazy constant {@linkplain java.lang.ref##reachability strongly references}\n+ *          the object it was initialized with. Hence, a lazy constant will hold\n+ *          the object it was initialized with until the lazy constant itself\n+ *          is collected (if ever).\n@@ -182,1 +188,1 @@\n- *          <em>array reference<\/em> as a constant but <em>not its components<\/em>.\n+ *          <em>array reference<\/em> as a constant, but <em>not its components<\/em>.\n@@ -191,5 +197,2 @@\n- *          cyclic initialization may result in initialization errors per JLS 12.4.\n- *\n- * @implSpec Except for {@linkplain Object#equals(Object) equals(obj)} and\n- *           {@linkplain #orElse(Object) orElse(other)} parameters; all method parameters\n- *           must be <em>non-null<\/em> or a {@link NullPointerException} will be thrown.\n+ *          cyclic initialization may result in initialization errors as described\n+ *          in {@jls 12.4} of <cite>The Java Language Specification<\/cite>.\n@@ -209,1 +212,1 @@\n- * @jls 12.2 Initialization of Classes and Interfaces\n+ * @jls 12.4 Initialization of Classes and Interfaces\n@@ -218,1 +221,1 @@\n-     * {@return the constant if initialized, otherwise, returns {@code other}}\n+     * {@return the contents if initialized, otherwise, returns {@code other}}\n@@ -222,1 +225,1 @@\n-     * value if and only if the initialization has already completed).\n+     * contents if and only if the initialization has already completed).\n@@ -224,1 +227,1 @@\n-     * @param other value to return if the constant is not initialized\n+     * @param other value to return if the content is not initialized\n@@ -230,2 +233,2 @@\n-     * {@return the initialized constant. If not initialized, first computes and\n-     *          initializes the constant using the computing function}\n+     * {@return the initialized contents. If not initialized, first computes and\n+     *          initializes the contents using the computing function}\n@@ -243,1 +246,1 @@\n-     * {@return {@code true} if the constant is initialized, {@code false} otherwise}\n+     * {@return {@code true} if the contents is initialized, {@code false} otherwise}\n@@ -257,1 +260,1 @@\n-     * value if and only if the initialization has already completed).\n+     * contents if and only if the initialization has already completed).\n@@ -260,1 +263,1 @@\n-     * initialized constant will be returned, otherwise, an implementation dependent\n+     * initialized contents will be returned; otherwise, an implementation-dependent\n@@ -277,2 +280,3 @@\n-     * If the provided computing function already is an instance of LazyConstant, the\n-     * method is free to return the provided computing function directly.\n+     * If the provided computing function is already an instance of\n+     * {@code LazyConstant}, the method is free to return the provided computing function\n+     * directly.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LazyConstant.java","additions":56,"deletions":52,"binary":false,"changes":108,"status":"modified"}]}