{"files":[{"patch":"@@ -36,1 +36,1 @@\n-    Poller readPoller() throws IOException {\n+    Poller readPoller(boolean subPoller) throws IOException {\n@@ -41,1 +41,1 @@\n-    Poller writePoller() throws IOException {\n+    Poller writePoller(boolean subPoller) throws IOException {\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    private final int event;\n@@ -49,1 +50,1 @@\n-        super(read);\n+        this.event = (read) ? Net.POLLIN : Net.POLLOUT;\n@@ -61,2 +62,1 @@\n-        int ret = Pollset.pollsetCtl(setid, Pollset.PS_MOD, fd,\n-                          Pollset.PS_POLLPRI | (this.reading() ? Net.POLLIN : Net.POLLOUT));\n+        int ret = Pollset.pollsetCtl(setid, Pollset.PS_MOD, fd, Pollset.PS_POLLPRI | event);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/PollsetPoller.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.vm.ContinuationSupport;\n@@ -36,2 +37,6 @@\n-    Poller readPoller() throws IOException {\n-        return new EPollPoller(true);\n+    Poller.Mode defaultPollerMode() {\n+        if (ContinuationSupport.isSupported()) {\n+            return Poller.Mode.VTHREAD_POLLERS;\n+        } else {\n+            return Poller.Mode.SYSTEM_THREADS;\n+        }\n@@ -41,2 +46,17 @@\n-    Poller writePoller() throws IOException {\n-        return new EPollPoller(false);\n+    int defaultReadPollers(Poller.Mode mode) {\n+        int ncpus = Runtime.getRuntime().availableProcessors();\n+        if (mode == Poller.Mode.VTHREAD_POLLERS) {\n+            return Math.min(Integer.highestOneBit(ncpus), 32);\n+        } else {\n+            return Math.max(Integer.highestOneBit(ncpus \/ 4), 1);\n+        }\n+    }\n+\n+    @Override\n+    Poller readPoller(boolean subPoller) throws IOException {\n+        return new EPollPoller(subPoller, true);\n+    }\n+\n+    @Override\n+    Poller writePoller(boolean subPoller) throws IOException {\n+        return new EPollPoller(subPoller, false);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-    private static final int MAX_EVENTS_TO_POLL = 512;\n@@ -40,0 +39,1 @@\n+    private final int maxEvents;\n@@ -42,2 +42,1 @@\n-    EPollPoller(boolean read) throws IOException {\n-        super(read);\n+    EPollPoller(boolean subPoller, boolean read) throws IOException {\n@@ -46,1 +45,2 @@\n-        this.address = EPoll.allocatePollArray(MAX_EVENTS_TO_POLL);\n+        this.maxEvents = (subPoller) ? 64 : 512;\n+        this.address = EPoll.allocatePollArray(maxEvents);\n@@ -71,1 +71,1 @@\n-        int n = EPoll.wait(epfd, address, MAX_EVENTS_TO_POLL, timeout);\n+        int n = EPoll.wait(epfd, address, maxEvents, timeout);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollPoller.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    Poller readPoller() throws IOException {\n-        return new KQueuePoller(true);\n+    Poller readPoller(boolean subPoller) throws IOException {\n+        return new KQueuePoller(subPoller, true);\n@@ -41,2 +41,2 @@\n-    Poller writePoller() throws IOException {\n-        return new KQueuePoller(false);\n+    Poller writePoller(boolean subPoller) throws IOException {\n+        return new KQueuePoller(subPoller, false);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-    private static final int MAX_EVENTS_TO_POLL = 512;\n-\n@@ -38,0 +36,1 @@\n+    private final int maxEvents;\n@@ -40,2 +39,1 @@\n-    KQueuePoller(boolean read) throws IOException {\n-        super(read);\n+    KQueuePoller(boolean subPoller, boolean read) throws IOException {\n@@ -44,1 +42,2 @@\n-        this.address = KQueue.allocatePollArray(MAX_EVENTS_TO_POLL);\n+        this.maxEvents = (subPoller) ? 64 : 512;\n+        this.address = KQueue.allocatePollArray(maxEvents);\n@@ -66,1 +65,1 @@\n-        int n = KQueue.poll(kqfd, address, MAX_EVENTS_TO_POLL, timeout);\n+        int n = KQueue.poll(kqfd, address, maxEvents, timeout);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueuePoller.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.IOError;\n@@ -29,0 +28,1 @@\n+import java.util.Arrays;\n@@ -30,1 +30,0 @@\n-import java.util.concurrent.BlockingQueue;\n@@ -32,1 +31,3 @@\n-import java.util.concurrent.LinkedTransferQueue;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n@@ -35,1 +36,0 @@\n-import java.util.stream.Stream;\n@@ -37,2 +37,0 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -45,9 +43,11 @@\n-public abstract class Poller {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    private static final Poller[] READ_POLLERS;\n-    private static final Poller[] WRITE_POLLERS;\n-    private static final int READ_MASK, WRITE_MASK;\n-    private static final boolean USE_DIRECT_REGISTER;\n-\n-    \/\/ true if this is a poller for reading, false for writing\n-    private final boolean read;\n+abstract class Poller {\n+    private static final Pollers POLLERS;\n+    static {\n+        try {\n+            var pollers = new Pollers();\n+            pollers.start();\n+            POLLERS = pollers;\n+        } catch (IOException ioe) {\n+            throw new ExceptionInInitializerError(ioe);\n+        }\n+    }\n@@ -58,2 +58,21 @@\n-    \/\/ the queue of updates to the updater Thread\n-    private final BlockingQueue<Request> queue = new LinkedTransferQueue<>();\n+    \/**\n+     * Poller mode.\n+     *\/\n+    enum Mode {\n+        \/**\n+         * ReadPoller and WritePoller are dedicated platform threads that block waiting\n+         * for events and unpark virtual threads when file descriptors are ready for I\/O.\n+         *\/\n+        SYSTEM_THREADS,\n+\n+        \/**\n+         * ReadPoller and WritePoller threads are virtual threads that poll for events,\n+         * yielding between polls and unparking virtual threads when file descriptors are\n+         * ready for I\/O. If there are no events then the poller threads park until there\n+         * are I\/O events to poll. This mode helps to integrate polling with virtual\n+         * thread scheduling. The approach is similar to the default scheme in \"User-level\n+         * Threading: Have Your Cake and Eat It Too\" by Karsten and Barghi 2020\n+         * (https:\/\/dl.acm.org\/doi\/10.1145\/3379483).\n+         *\/\n+        VTHREAD_POLLERS\n+    }\n@@ -62,1 +81,1 @@\n-     * Initialize a Poller for reading or writing.\n+     * Initialize a Poller.\n@@ -64,2 +83,1 @@\n-    protected Poller(boolean read) {\n-        this.read = read;\n+    protected Poller() {\n@@ -69,1 +87,31 @@\n-     * Returns true if this poller is for read (POLLIN) events.\n+     * Returns the poller's file descriptor, used when the read and write poller threads\n+     * are virtual threads.\n+     *\n+     * @throws UnsupportedOperationException if not supported\n+     *\/\n+    int fdVal() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Register the file descriptor.\n+     *\/\n+    abstract void implRegister(int fdVal) throws IOException;\n+\n+    \/**\n+     * Deregister the file descriptor.\n+     *\/\n+    abstract void implDeregister(int fdVal);\n+\n+    \/**\n+     * Poll for events. The {@link #polled(int)} method is invoked for each\n+     * polled file descriptor.\n+     *\n+     * @param timeout if positive then block for up to {@code timeout} milliseconds,\n+     *     if zero then don't block, if -1 then block indefinitely\n+     * @return the number of file descriptors polled\n+     *\/\n+    abstract int poll(int timeout) throws IOException;\n+\n+    \/**\n+     * Callback by the poll method when a file descriptor is polled.\n@@ -71,2 +119,2 @@\n-    final boolean reading() {\n-        return read;\n+    final void polled(int fdVal) {\n+        wakeup(fdVal);\n@@ -82,1 +130,1 @@\n-    public static void poll(int fdVal, int event, long nanos, BooleanSupplier supplier)\n+    static void poll(int fdVal, int event, long nanos, BooleanSupplier supplier)\n@@ -87,1 +135,1 @@\n-            readPoller(fdVal).poll(fdVal, nanos, supplier);\n+            POLLERS.readPoller(fdVal).poll(fdVal, nanos, supplier);\n@@ -89,1 +137,1 @@\n-            writePoller(fdVal).poll(fdVal, nanos, supplier);\n+            POLLERS.writePoller(fdVal).poll(fdVal, nanos, supplier);\n@@ -96,1 +144,2 @@\n-     * Parks the current thread until a file descriptor is ready.\n+     * If there is a thread polling the given file descriptor for the given event then\n+     * the thread is unparked.\n@@ -98,3 +147,5 @@\n-    private void poll(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n-        if (USE_DIRECT_REGISTER) {\n-            pollDirect(fdVal, nanos, supplier);\n+    static void stopPoll(int fdVal, int event) {\n+        if (event == Net.POLLIN) {\n+            POLLERS.readPoller(fdVal).wakeup(fdVal);\n+        } else if (event == Net.POLLOUT) {\n+            POLLERS.writePoller(fdVal).wakeup(fdVal);\n@@ -102,1 +153,1 @@\n-            pollIndirect(fdVal, nanos, supplier);\n+            throw new IllegalArgumentException();\n@@ -107,2 +158,1 @@\n-     * Parks the current thread until a file descriptor is ready. This implementation\n-     * registers the file descriptor, then parks until the file descriptor is polled.\n+     * If there are any threads polling the given file descriptor then they are unparked.\n@@ -110,14 +160,3 @@\n-    private void pollDirect(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n-        register(fdVal);\n-        try {\n-            boolean isOpen = supplier.getAsBoolean();\n-            if (isOpen) {\n-                if (nanos > 0) {\n-                    LockSupport.parkNanos(nanos);\n-                } else {\n-                    LockSupport.park();\n-                }\n-            }\n-        } finally {\n-            deregister(fdVal);\n-        }\n+    static void stopPoll(int fdVal) {\n+        stopPoll(fdVal, Net.POLLIN);\n+        stopPoll(fdVal, Net.POLLOUT);\n@@ -127,3 +166,1 @@\n-     * Parks the current thread until a file descriptor is ready. This implementation\n-     * queues the file descriptor to the update thread, then parks until the file\n-     * descriptor is polled.\n+     * Parks the current thread until a file descriptor is ready.\n@@ -131,2 +168,2 @@\n-    private void pollIndirect(int fdVal, long nanos, BooleanSupplier supplier) {\n-        Request request = registerAsync(fdVal);\n+    private void poll(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n+        register(fdVal);\n@@ -143,1 +180,0 @@\n-            request.awaitFinish();\n@@ -157,12 +193,0 @@\n-    \/**\n-     * Queues the file descriptor to be registered by the updater thread, returning\n-     * a Request object to track the request.\n-     *\/\n-    private Request registerAsync(int fdVal) {\n-        Thread previous = map.putIfAbsent(fdVal, Thread.currentThread());\n-        assert previous == null;\n-        Request request = new Request(fdVal);\n-        queue.add(request);\n-        return request;\n-    }\n-\n@@ -181,70 +205,1 @@\n-     * A registration request queued to the updater thread.\n-     *\/\n-    private static class Request {\n-        private final int fdVal;\n-        private volatile boolean done;\n-        private volatile Thread waiter;\n-\n-        Request(int fdVal) {\n-            this.fdVal = fdVal;\n-        }\n-\n-        private int fdVal() {\n-            return fdVal;\n-        }\n-\n-        \/**\n-         * Invoked by the updater when the request has been processed.\n-         *\/\n-        void finish() {\n-            done = true;\n-            Thread waiter = this.waiter;\n-            if (waiter != null) {\n-                LockSupport.unpark(waiter);\n-            }\n-        }\n-\n-        \/**\n-         * Waits for a request to be processed.\n-         *\/\n-        void awaitFinish() {\n-            if (!done) {\n-                waiter = Thread.currentThread();\n-                boolean interrupted = false;\n-                while (!done) {\n-                    LockSupport.park();\n-                    if (Thread.interrupted()) {\n-                        interrupted = true;\n-                    }\n-                }\n-                if (interrupted) {\n-                    Thread.currentThread().interrupt();\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Register the file descriptor.\n-     *\/\n-    abstract void implRegister(int fdVal) throws IOException;\n-\n-    \/**\n-     * Deregister the file descriptor.\n-     *\/\n-    abstract void implDeregister(int fdVal);\n-\n-    \/**\n-     * Starts the poller threads.\n-     *\/\n-    private Poller start() {\n-        String prefix = (read) ? \"Read\" : \"Write\";\n-        startThread(prefix + \"-Poller\", this::pollLoop);\n-        if (!USE_DIRECT_REGISTER) {\n-            startThread(prefix + \"-Updater\", this::updateLoop);\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Starts a platform thread to run the given task.\n+     * Unparks any thread that is polling the given file descriptor.\n@@ -252,9 +207,4 @@\n-    private void startThread(String name, Runnable task) {\n-        try {\n-            Thread thread = JLA.executeOnCarrierThread(() ->\n-                InnocuousThread.newSystemThread(name, task)\n-            );\n-            thread.setDaemon(true);\n-            thread.start();\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n+    private void wakeup(int fdVal) {\n+        Thread t = map.remove(fdVal);\n+        if (t != null) {\n+            LockSupport.unpark(t);\n@@ -265,1 +215,2 @@\n-     * Polling loop.\n+     * Master polling loop. The {@link #polled(int)} method is invoked for each file\n+     * descriptor that is polled.\n@@ -267,1 +218,1 @@\n-    private void pollLoop() {\n+    private void pollerLoop() {\n@@ -270,1 +221,1 @@\n-                poll();\n+                poll(-1);\n@@ -278,1 +229,7 @@\n-     * The update loop to handle updates to the interest set.\n+     * Sub-poller polling loop. The {@link #polled(int)} method is invoked for each file\n+     * descriptor that is polled.\n+     *\n+     * The sub-poller registers its file descriptor with the master poller to park until\n+     * there are events to poll. When unparked, it does non-blocking polls and parks\n+     * again when there are no more events. The sub-poller yields after each poll to help\n+     * with fairness and to avoid re-registering with the master poller where possible.\n@@ -280,1 +237,2 @@\n-    private void updateLoop() {\n+    private void subPollerLoop(Poller masterPoller) {\n+        assert Thread.currentThread().isVirtual();\n@@ -282,0 +240,1 @@\n+            int polled = 0;\n@@ -283,5 +242,4 @@\n-                Request req = null;\n-                while (req == null) {\n-                    try {\n-                        req = queue.take();\n-                    } catch (InterruptedException ignore) { }\n+                if (polled == 0) {\n+                    masterPoller.poll(fdVal(), 0, () -> true);  \/\/ park\n+                } else {\n+                    Thread.yield();\n@@ -289,2 +247,1 @@\n-                implRegister(req.fdVal());\n-                req.finish();\n+                polled = poll(0);\n@@ -298,29 +255,1 @@\n-     * Maps the file descriptor value to a read poller.\n-     *\/\n-    private static Poller readPoller(int fdVal) {\n-        return READ_POLLERS[fdVal & READ_MASK];\n-    }\n-\n-    \/**\n-     * Maps the file descriptor value to a write poller.\n-     *\/\n-    private static Poller writePoller(int fdVal) {\n-        return WRITE_POLLERS[fdVal & WRITE_MASK];\n-    }\n-\n-    \/**\n-     * Unparks any thread that is polling the given file descriptor for the\n-     * given event.\n-     *\/\n-    static void stopPoll(int fdVal, int event) {\n-        if (event == Net.POLLIN) {\n-            readPoller(fdVal).wakeup(fdVal);\n-        } else if (event == Net.POLLOUT) {\n-            writePoller(fdVal).wakeup(fdVal);\n-        } else {\n-            throw new IllegalArgumentException();\n-        }\n-    }\n-\n-    \/**\n-     * Unparks any threads that are polling the given file descriptor.\n+     * The Pollers used for read and write events.\n@@ -328,4 +257,6 @@\n-    static void stopPoll(int fdVal) {\n-        stopPoll(fdVal, Net.POLLIN);\n-        stopPoll(fdVal, Net.POLLOUT);\n-    }\n+    private static class Pollers {\n+        private final PollerProvider provider;\n+        private final Poller.Mode pollerMode;\n+        private final Poller masterPoller;\n+        private final Poller[] readPollers;\n+        private final Poller[] writePollers;\n@@ -333,9 +264,2 @@\n-    \/**\n-     * Unparks any thread that is polling the given file descriptor.\n-     *\/\n-    private void wakeup(int fdVal) {\n-        Thread t = map.remove(fdVal);\n-        if (t != null) {\n-            LockSupport.unpark(t);\n-        }\n-    }\n+        \/\/ used by start method to executor is kept alive\n+        private Executor executor;\n@@ -343,15 +267,18 @@\n-    \/**\n-     * Called by the polling facility when the file descriptor is polled\n-     *\/\n-    final void polled(int fdVal) {\n-        wakeup(fdVal);\n-    }\n-\n-    \/**\n-     * Poll for events. The {@link #polled(int)} method is invoked for each\n-     * polled file descriptor.\n-     *\n-     * @param timeout if positive then block for up to {@code timeout} milliseconds,\n-     *     if zero then don't block, if -1 then block indefinitely\n-     *\/\n-    abstract int poll(int timeout) throws IOException;\n+        \/**\n+         * Creates the Poller instances based on configuration.\n+         *\/\n+        Pollers() throws IOException {\n+            PollerProvider provider = PollerProvider.provider();\n+            Poller.Mode mode;\n+            String s = GetPropertyAction.privilegedGetProperty(\"jdk.pollerMode\");\n+            if (s != null) {\n+                if (s.equalsIgnoreCase(Mode.SYSTEM_THREADS.name()) || s.equals(\"1\")) {\n+                    mode = Mode.SYSTEM_THREADS;\n+                } else if (s.equalsIgnoreCase(Mode.VTHREAD_POLLERS.name()) || s.equals(\"2\")) {\n+                    mode = Mode.VTHREAD_POLLERS;\n+                } else {\n+                    throw new RuntimeException(\"Can't parse '\" + s + \"' as polling mode\");\n+                }\n+            } else {\n+                mode = provider.defaultPollerMode();\n+            }\n@@ -359,6 +286,4 @@\n-    \/**\n-     * Poll for events, blocks indefinitely.\n-     *\/\n-    final int poll() throws IOException {\n-        return poll(-1);\n-    }\n+            \/\/ vthread poller mode needs a master poller\n+            Poller masterPoller = (mode == Mode.VTHREAD_POLLERS)\n+                    ? provider.readPoller(false)\n+                    : null;\n@@ -366,6 +291,6 @@\n-    \/**\n-     * Poll for events, non-blocking.\n-     *\/\n-    final int pollNow() throws IOException {\n-        return poll(0);\n-    }\n+            \/\/ read pollers (or sub-pollers)\n+            int readPollerCount = pollerCount(\"jdk.readPollers\", provider.defaultReadPollers(mode));\n+            Poller[] readPollers = new Poller[readPollerCount];\n+            for (int i = 0; i < readPollerCount; i++) {\n+                readPollers[i] = provider.readPoller(mode == Mode.VTHREAD_POLLERS);\n+            }\n@@ -373,6 +298,6 @@\n-    \/**\n-     * Returns the poller's file descriptor, or -1 if none.\n-     *\/\n-    int fdVal() {\n-        return -1;\n-    }\n+            \/\/ write pollers (or sub-pollers)\n+            int writePollerCount = pollerCount(\"jdk.writePollers\", provider.defaultWritePollers(mode));\n+            Poller[] writePollers = new Poller[writePollerCount];\n+            for (int i = 0; i < writePollerCount; i++) {\n+                writePollers[i] = provider.writePoller(mode == Mode.VTHREAD_POLLERS);\n+            }\n@@ -380,10 +305,5 @@\n-    \/**\n-     * Creates the read and writer pollers.\n-     *\/\n-    static {\n-        PollerProvider provider = PollerProvider.provider();\n-        String s = GetPropertyAction.privilegedGetProperty(\"jdk.useDirectRegister\");\n-        if (s == null) {\n-            USE_DIRECT_REGISTER = provider.useDirectRegister();\n-        } else {\n-            USE_DIRECT_REGISTER = \"\".equals(s) || Boolean.parseBoolean(s);\n+            this.provider = provider;\n+            this.pollerMode = mode;\n+            this.masterPoller = masterPoller;\n+            this.readPollers = readPollers;\n+            this.writePollers = writePollers;\n@@ -391,11 +311,0 @@\n-        try {\n-            Poller[] readPollers = createReadPollers(provider);\n-            READ_POLLERS = readPollers;\n-            READ_MASK = readPollers.length - 1;\n-            Poller[] writePollers = createWritePollers(provider);\n-            WRITE_POLLERS = writePollers;\n-            WRITE_MASK = writePollers.length - 1;\n-        } catch (IOException ioe) {\n-            throw new IOError(ioe);\n-        }\n-    }\n@@ -403,9 +312,26 @@\n-    \/**\n-     * Create the read poller(s).\n-     *\/\n-    private static Poller[] createReadPollers(PollerProvider provider) throws IOException {\n-        int readPollerCount = pollerCount(\"jdk.readPollers\");\n-        Poller[] readPollers = new Poller[readPollerCount];\n-        for (int i = 0; i< readPollerCount; i++) {\n-            var poller = provider.readPoller();\n-            readPollers[i] = poller.start();\n+        \/**\n+         * Starts the Poller threads.\n+         *\/\n+        void start() {\n+            if (pollerMode == Mode.VTHREAD_POLLERS) {\n+                startPlatformThread(\"MasterPoller\", masterPoller::pollerLoop);\n+                ThreadFactory factory = Thread.ofVirtual()\n+                        .inheritInheritableThreadLocals(false)\n+                        .name(\"SubPoller-\", 0)\n+                        .uncaughtExceptionHandler((t, e) -> e.printStackTrace())\n+                        .factory();\n+                executor = Executors.newThreadPerTaskExecutor(factory);\n+                Arrays.stream(readPollers).forEach(p -> {\n+                    executor.execute(() -> p.subPollerLoop(masterPoller));\n+                });\n+                Arrays.stream(writePollers).forEach(p -> {\n+                    executor.execute(() -> p.subPollerLoop(masterPoller));\n+                });\n+            } else {\n+                Arrays.stream(readPollers).forEach(p -> {\n+                    startPlatformThread(\"Read-Poller\", p::pollerLoop);\n+                });\n+                Arrays.stream(writePollers).forEach(p -> {\n+                    startPlatformThread(\"Write-Poller\", p::pollerLoop);\n+                });\n+            }\n@@ -413,2 +339,0 @@\n-        return readPollers;\n-    }\n@@ -416,9 +340,6 @@\n-    \/**\n-     * Create the write poller(s).\n-     *\/\n-    private static Poller[] createWritePollers(PollerProvider provider) throws IOException {\n-        int writePollerCount = pollerCount(\"jdk.writePollers\");\n-        Poller[] writePollers = new Poller[writePollerCount];\n-        for (int i = 0; i< writePollerCount; i++) {\n-            var poller = provider.writePoller();\n-            writePollers[i] = poller.start();\n+        \/**\n+         * Returns the read poller for the given file descriptor.\n+         *\/\n+        Poller readPoller(int fdVal) {\n+            int index = provider.fdValToIndex(fdVal, readPollers.length);\n+            return readPollers[index];\n@@ -426,2 +347,0 @@\n-        return writePollers;\n-    }\n@@ -429,15 +348,6 @@\n-    \/**\n-     * Reads the given property name to get the poller count. If the property is\n-     * set then the value must be a power of 2. Returns 1 if the property is not\n-     * set.\n-     * @throws IllegalArgumentException if the property is set to a value that\n-     * is not a power of 2.\n-     *\/\n-    private static int pollerCount(String propName) {\n-        String s = GetPropertyAction.privilegedGetProperty(propName, \"1\");\n-        int count = Integer.parseInt(s);\n-\n-        \/\/ check power of 2\n-        if (count != (1 << log2(count))) {\n-            String msg = propName + \" is set to a vale that is not a power of 2\";\n-            throw new IllegalArgumentException(msg);\n+        \/**\n+         * Returns the write poller for the given file descriptor.\n+         *\/\n+        Poller writePoller(int fdVal) {\n+            int index = provider.fdValToIndex(fdVal, writePollers.length);\n+            return writePollers[index];\n@@ -445,2 +355,0 @@\n-        return count;\n-    }\n@@ -448,14 +356,17 @@\n-    private static int log2(int n) {\n-        return 31 - Integer.numberOfLeadingZeros(n);\n-    }\n-\n-    \/**\n-     * Return a stream of all threads blocked waiting for I\/O operations.\n-     *\/\n-    public static Stream<Thread> blockedThreads() {\n-        Stream<Thread> s = Stream.empty();\n-        for (int i = 0; i < READ_POLLERS.length; i++) {\n-            s = Stream.concat(s, READ_POLLERS[i].registeredThreads());\n-        }\n-        for (int i = 0; i < WRITE_POLLERS.length; i++) {\n-            s = Stream.concat(s, WRITE_POLLERS[i].registeredThreads());\n+        \/**\n+         * Reads the given property name to get the poller count. If the property is\n+         * set then the value must be a power of 2. Returns 1 if the property is not\n+         * set.\n+         * @throws IllegalArgumentException if the property is set to a value that\n+         * is not a power of 2.\n+         *\/\n+        private static int pollerCount(String propName, int defaultCount) {\n+            String s = GetPropertyAction.privilegedGetProperty(propName);\n+            int count = (s != null) ? Integer.parseInt(s) : defaultCount;\n+\n+            \/\/ check power of 2\n+            if (count != Integer.highestOneBit(count)) {\n+                String msg = propName + \" is set to a vale that is not a power of 2\";\n+                throw new IllegalArgumentException(msg);\n+            }\n+            return count;\n@@ -463,2 +374,0 @@\n-        return s;\n-    }\n@@ -466,2 +375,13 @@\n-    private Stream<Thread> registeredThreads() {\n-        return map.values().stream();\n+        \/**\n+         * Starts a platform thread to run the given task.\n+         *\/\n+        private void startPlatformThread(String name, Runnable task) {\n+            try {\n+                Thread thread = InnocuousThread.newSystemThread(name, task);\n+                thread.setDaemon(true);\n+                thread.setUncaughtExceptionHandler((t, e) -> e.printStackTrace());\n+                thread.start();\n+            } catch (Exception e) {\n+                throw new InternalError(e);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":229,"deletions":309,"binary":false,"changes":538,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.util.ServiceConfigurationError;\n-import sun.security.action.GetPropertyAction;\n@@ -31,0 +29,3 @@\n+\/**\n+ * Provider class for Poller implementations.\n+ *\/\n@@ -32,0 +33,2 @@\n+    private static final PollerProvider INSTANCE = new DefaultPollerProvider();\n+\n@@ -35,4 +38,1 @@\n-     * Returns true if threads should register file descriptors directly,\n-     * false to queue registrations to an updater thread.\n-     *\n-     * The default implementation returns false.\n+     * Returns the system-wide PollerProvider.\n@@ -40,2 +40,2 @@\n-    boolean useDirectRegister() {\n-        return false;\n+    static PollerProvider provider() {\n+        return INSTANCE;\n@@ -45,1 +45,2 @@\n-     * Creates a Poller for read ops.\n+     * Returns the default poller mode.\n+     * @implSpec The default implementation uses system threads.\n@@ -47,1 +48,3 @@\n-    abstract Poller readPoller() throws IOException;\n+    Poller.Mode defaultPollerMode() {\n+        return Poller.Mode.SYSTEM_THREADS;\n+    }\n@@ -50,1 +53,2 @@\n-     * Creates a Poller for write ops.\n+     * Default number of read pollers for the given mode. The count must be a power of 2.\n+     * @implSpec The default implementation returns 1.\n@@ -52,1 +56,3 @@\n-    abstract Poller writePoller() throws IOException;\n+    int defaultReadPollers(Poller.Mode mode) {\n+        return 1;\n+    }\n@@ -55,1 +61,2 @@\n-     * Creates the PollerProvider.\n+     * Default number of write pollers for the given mode. The count must be a power of 2.\n+     * @implSpec The default implementation returns 1.\n@@ -57,12 +64,10 @@\n-    static PollerProvider provider() {\n-        String cn = GetPropertyAction.privilegedGetProperty(\"jdk.PollerProvider\");\n-        if (cn != null) {\n-            try {\n-                Class<?> clazz = Class.forName(cn, true, ClassLoader.getSystemClassLoader());\n-                return (PollerProvider) clazz.getConstructor().newInstance();\n-            } catch (Exception e) {\n-                throw new ServiceConfigurationError(null, e);\n-            }\n-        } else {\n-            return new DefaultPollerProvider();\n-        }\n+    int defaultWritePollers(Poller.Mode mode) {\n+        return 1;\n+    }\n+\n+    \/**\n+     * Maps a file descriptor to an index from 0 to {@code toIndex}.\n+     * @implSpec The default implementation is good for Unix file descriptors.\n+     *\/\n+    int fdValToIndex(int fdVal, int toIndex) {\n+        return fdVal & (toIndex - 1);\n@@ -70,0 +75,12 @@\n+\n+    \/**\n+     * Creates a Poller for read ops.\n+     * @param subPoller true to create a sub-poller\n+     *\/\n+    abstract Poller readPoller(boolean subPoller) throws IOException;\n+\n+    \/**\n+     * Creates a Poller for write ops.\n+     * @param subPoller true to create a sub-poller\n+     *\/\n+    abstract Poller writePoller(boolean subPoller) throws IOException;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/PollerProvider.java","additions":43,"deletions":26,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,14 @@\n-    Poller readPoller() throws IOException {\n+    int defaultReadPollers(Poller.Mode mode) {\n+        assert mode == Poller.Mode.SYSTEM_THREADS;\n+        int ncpus = Runtime.getRuntime().availableProcessors();\n+        return Math.max(Integer.highestOneBit(ncpus \/ 8), 1);\n+    }\n+\n+    @Override\n+    int fdValToIndex(int fdVal, int toIndex) {\n+        return (fdVal >> 2) & (toIndex - 1);\n+    }\n+\n+    @Override\n+    Poller readPoller(boolean subPoller) throws IOException {\n+        assert !subPoller;\n@@ -41,1 +54,2 @@\n-    Poller writePoller() throws IOException {\n+    Poller writePoller(boolean subPoller) throws IOException {\n+        assert !subPoller;\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/DefaultPollerProvider.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-        super(read);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WEPollPoller.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-# This test always times out on windows. This is due to the test forcing OOME in the\n-# debuggee, which has the side affect of making the Read-Poller thread exit. Because\n+# This test times out on Windows and Linux. This is due to the test forcing OOME in\n+# the debuggee, which can lead to I\/O poller threads exiting. Because\n@@ -91,1 +91,1 @@\n-vmTestbase\/nsk\/jdi\/VMOutOfMemoryException\/VMOutOfMemoryException001\/VMOutOfMemoryException001.java 8285417 windows-all\n+vmTestbase\/nsk\/jdi\/VMOutOfMemoryException\/VMOutOfMemoryException001\/VMOutOfMemoryException001.java 8285417 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Test virtual threads doing blocking I\/O on java.net sockets\n+ * @summary Test virtual threads doing blocking I\/O on java.net Sockets\n@@ -33,3 +33,2 @@\n- * @test id=direct-register\n- * @summary Test virtual threads doing blocking I\/O on java.net sockets and with\n- *    the I\/O poller configured to use direct registration\n+ * @test id=poller-modes\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n@@ -37,1 +36,2 @@\n- * @run junit\/othervm -Djdk.useDirectRegister BlockingSocketOps\n+ * @run junit\/othervm -Djdk.pollerMode=1 BlockingSocketOps\n+ * @run junit\/othervm -Djdk.pollerMode=2 BlockingSocketOps\n","filename":"test\/jdk\/java\/net\/vthread\/BlockingSocketOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,3 +33,2 @@\n- * @test id=direct-register\n- * @summary Test virtual threads doing blocking I\/O on NIO channels and with\n- *    the I\/O poller configured to use direct registration\n+ * @test id=poller-modes\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n@@ -37,1 +36,2 @@\n- * @run junit\/othervm -Djdk.useDirectRegister BlockingChannelOps\n+ * @run junit\/othervm -Djdk.pollerMode=1 BlockingChannelOps\n+ * @run junit\/othervm -Djdk.pollerMode=2 BlockingChannelOps\n@@ -510,1 +510,1 @@\n-        testDatagramSocketAdaptorReceive(60_1000);\n+        testDatagramSocketAdaptorReceive(60_000);\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}