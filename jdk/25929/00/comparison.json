{"files":[{"patch":"@@ -301,13 +301,46 @@\n-\/\/ Create a skeleton strip mined outer loop: a Loop head before the\n-\/\/ inner strip mined loop, a safepoint and an exit condition guarded\n-\/\/ by an opaque node after the inner strip mined loop with a backedge\n-\/\/ to the loop head. The inner strip mined loop is left as it is. Only\n-\/\/ once loop optimizations are over, do we adjust the inner loop exit\n-\/\/ condition to limit its number of iterations, set the outer loop\n-\/\/ exit condition and add Phis to the outer loop head. Some loop\n-\/\/ optimizations that operate on the inner strip mined loop need to be\n-\/\/ aware of the outer strip mined loop: loop unswitching needs to\n-\/\/ clone the outer loop as well as the inner, unrolling needs to only\n-\/\/ clone the inner loop etc. No optimizations need to change the outer\n-\/\/ strip mined loop as it is only a skeleton.\n-IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,\n+\/\/ Create a skeleton strip mined outer loop: an OuterStripMinedLoop head before the inner strip mined CountedLoop, a\n+\/\/ SafePoint on exit of the inner CountedLoopEnd and an OuterStripMinedLoopEnd test that can't constant fold until loop\n+\/\/ optimizations are over. The inner strip mined loop is left as it is. Only once loop optimizations are over, do we\n+\/\/ adjust the inner loop exit condition to limit its number of iterations, set the outer loop exit condition and add\n+\/\/ Phis to the outer loop head. Some loop optimizations that operate on the inner strip mined loop need to be aware of\n+\/\/ the outer strip mined loop: loop unswitching needs to clone the outer loop as well as the inner, unrolling needs to\n+\/\/ only clone the inner loop etc. No optimizations need to change the outer strip mined loop as it is only a skeleton.\n+\/\/\n+\/\/ Schematically:\n+\/\/\n+\/\/ OuterStripMinedLoop -------|\n+\/\/       |                    |\n+\/\/ CountedLoop ----------- |  |\n+\/\/     \\- Phi (iv) -|      |  |\n+\/\/       \/  \\       |      |  |\n+\/\/     CmpI  AddI --|      |  |\n+\/\/       \\                 |  |\n+\/\/        Bool             |  |\n+\/\/         \\               |  |\n+\/\/ CountedLoopEnd          |  |\n+\/\/       \/  \\              |  |\n+\/\/ IfFalse   IfTrue--------|  |\n+\/\/      |                     |\n+\/\/ SafePoint                  |\n+\/\/      |                     |\n+\/\/ OuterStripMinedLoopEnd     |\n+\/\/       \/   \\                |\n+\/\/ IfFalse   IfTrue-----------|\n+\/\/      |\n+\/\/\n+\/\/\n+\/\/ As loop optimizations transform the inner loop, the outer strip mined loop stays mostly unchanged. The only exception\n+\/\/ is nodes referenced from the SafePoint and sunk from the inner loop: they end up in the outer strip mined loop.\n+\/\/\n+\/\/ Not adding Phis to the outer loop head from the beginning, and only adding them after loop optimizations does not\n+\/\/ conform to C2's IR rules: any variable or memory slice that is mutated in a loop should have a Phi. The main\n+\/\/ motivation for such a design that doesn't conform to C2's IR rules is to allow existing loop optimizations to be\n+\/\/ mostly unaffected by the outer strip mined loop: the only extra step needed in most cases is to step over the\n+\/\/ OuterStripMinedLoop. The main drawback is that once loop optimizations are over, an extra step is needed to finish\n+\/\/ constructing the outer loop. This is handled by OuterStripMinedLoopNode::adjust_strip_mined_loop().\n+\/\/\n+\/\/ Adding Phis to the outer loop is largely straightforward: there needs to be one Phi in the outer loop for every Phi\n+\/\/ in the inner loop. Things may be more complicated for sunk Store nodes: there may not be any inner loop Phi left\n+\/\/ after sinking for a particular memory slice but the outer loop needs a Phi. See\n+\/\/ OuterStripMinedLoopNode::handle_sunk_stores_when_finishing_construction()\n+IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(Node* init_control,\n@@ -2258,3 +2291,2 @@\n-    outer_ilt = create_outer_strip_mined_loop(test, cmp, init_control, loop,\n-                                              cl_prob, le->_fcnt, entry_control,\n-                                              iffalse);\n+    outer_ilt = create_outer_strip_mined_loop(init_control, loop, cl_prob, le->_fcnt,\n+                                              entry_control, iffalse);\n@@ -2873,4 +2905,5 @@\n-void OuterStripMinedLoopNode::fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* inner_cl, PhaseIterGVN* igvn,\n-                                              PhaseIdealLoop* iloop) {\n-  Node* cle_out = inner_cle->proj_out(false);\n-  Node* cle_tail = inner_cle->proj_out(true);\n+void OuterStripMinedLoopNode::fix_sunk_stores_when_back_to_counted_loop(PhaseIterGVN* igvn,\n+                                                                        PhaseIdealLoop* iloop) const {\n+  CountedLoopNode* inner_cl = inner_counted_loop();\n+  IfFalseNode* cle_out = inner_loop_exit();\n+\n@@ -2991,0 +3024,78 @@\n+\/\/ The outer strip mined loop is initially only partially constructed. In particular Phis are omitted.\n+\/\/ See comment above: PhaseIdealLoop::create_outer_strip_mined_loop()\n+\/\/ We're now in the process of finishing the construction of the outer loop. For each Phi in the inner loop, a Phi in\n+\/\/ the outer loop was just now created. However, Sunk Stores cause an extra challenge:\n+\/\/ 1) If all Stores in the inner loop were sunk for a particular memory slice, there's no Phi left for that memory slice\n+\/\/    in the inner loop anymore, and hence we did not yet add a Phi for the outer loop. So an extra Phi must now be\n+\/\/    added for each chain of sunk Stores for a particular memory slice.\n+\/\/ 2) If some Stores were sunk and some left in the inner loop, a Phi was already created in the outer loop but\n+\/\/    its backedge input wasn't wired correctly to the last Store of the chain: the backedge input was set to the\n+\/\/    backedge of the inner loop Phi instead, but it needs to be the last Store of the chain in the outer loop. We now\n+\/\/    have to fix that too.\n+void OuterStripMinedLoopNode::handle_sunk_stores_when_finishing_construction(PhaseIterGVN* igvn) {\n+  IfFalseNode* cle_exit_proj = inner_loop_exit();\n+\n+  \/\/ Find Sunk stores: Sunk stores are pinned on the loop exit projection of the inner loop. Indeed, because Sunk Stores\n+  \/\/ modify the memory state captured by the SafePoint in the outer strip mined loop, they must be above it. The\n+  \/\/ SafePoint's control input is the loop exit projection. It's also the only control out of the inner loop above the\n+  \/\/ SafePoint.\n+#ifdef ASSERT\n+  int stores_in_outer_loop_cnt = 0;\n+  for (DUIterator_Fast imax, i = cle_exit_proj->fast_outs(imax); i < imax; i++) {\n+    Node* u = cle_exit_proj->fast_out(i);\n+    if (u->is_Store()) {\n+      stores_in_outer_loop_cnt++;\n+    }\n+  }\n+#endif\n+\n+  \/\/ Sunk stores are reachable from the memory state of the outer loop safepoint\n+  SafePointNode* safepoint = outer_safepoint();\n+  MergeMemNode* mm = safepoint->in(TypeFunc::Memory)->isa_MergeMem();\n+  if (mm == nullptr) {\n+    \/\/ There is no MergeMem, which should only happen if there was no memory node\n+    \/\/ sunk out of the loop.\n+    assert(stores_in_outer_loop_cnt == 0, \"inconsistent\");\n+    return;\n+  }\n+  DEBUG_ONLY(int stores_in_outer_loop_cnt2 = 0);\n+  for (MergeMemStream mms(mm); mms.next_non_empty();) {\n+    Node* mem = mms.memory();\n+    \/\/ Traverse up the chain of stores to find the first store pinned\n+    \/\/ at the loop exit projection.\n+    Node* last = mem;\n+    Node* first = nullptr;\n+    while (mem->is_Store() && mem->in(0) == cle_exit_proj) {\n+      DEBUG_ONLY(stores_in_outer_loop_cnt2++);\n+      first = mem;\n+      mem = mem->in(MemNode::Memory);\n+    }\n+    if (first != nullptr) {\n+      \/\/ Found a chain of Stores that were sunk\n+      \/\/ Do we already have a memory Phi for that slice on the outer loop? If that is the case, that Phi was created\n+      \/\/ by cloning an inner loop Phi. The inner loop Phi should have mem, the memory state of the first Store out of\n+      \/\/ the inner loop, as input on the backedge. So does the outer loop Phi given it's a clone.\n+      Node* phi = nullptr;\n+      for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+        Node* u = mem->fast_out(i);\n+        if (u->is_Phi() && u->in(0) == this && u->in(LoopBackControl) == mem) {\n+          assert(phi == nullptr, \"there should be only one\");\n+          phi = u;\n+          PRODUCT_ONLY(break);\n+        }\n+      }\n+      if (phi == nullptr) {\n+        \/\/ No outer loop Phi? create one\n+        phi = PhiNode::make(this, last);\n+        phi->set_req(EntryControl, mem);\n+        phi = igvn->transform(phi);\n+        igvn->replace_input_of(first, MemNode::Memory, phi);\n+      } else {\n+        \/\/ Fix memory state along the backedge: it should be the last sunk Store of the chain\n+        igvn->replace_input_of(phi, LoopBackControl, last);\n+      }\n+    }\n+  }\n+  assert(stores_in_outer_loop_cnt == stores_in_outer_loop_cnt2, \"inconsistent\");\n+}\n+\n@@ -2992,0 +3103,1 @@\n+  verify_strip_mined(1);\n@@ -2995,1 +3107,1 @@\n-  CountedLoopNode* inner_cl = unique_ctrl_out()->as_CountedLoop();\n+  CountedLoopNode* inner_cl = inner_counted_loop();\n@@ -3013,1 +3125,1 @@\n-  CountedLoopEndNode* inner_cle = inner_cl->loopexit();\n+  CountedLoopEndNode* inner_cle = inner_counted_loop_end();\n@@ -3094,2 +3206,3 @@\n-  \/\/ Make a clone of each phi in the inner loop\n-  \/\/ for the outer loop\n+  \/\/ Make a clone of each phi in the inner loop for the outer loop\n+  \/\/ When Stores were Sunk, after this step, a Phi may still be missing or its backedge incorrectly wired. See\n+  \/\/ handle_sunk_stores_when_finishing_construction()\n@@ -3114,0 +3227,2 @@\n+  handle_sunk_stores_when_finishing_construction(igvn);\n+\n@@ -3169,1 +3284,1 @@\n-  fix_sunk_stores(inner_cle, inner_cl, igvn, iloop);\n+  fix_sunk_stores_when_back_to_counted_loop(igvn, iloop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":140,"deletions":25,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -576,1 +576,2 @@\n-  static void fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* inner_cl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+  void fix_sunk_stores_when_back_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop) const;\n+  void handle_sunk_stores_when_finishing_construction(PhaseIterGVN* igvn);\n@@ -592,0 +593,4 @@\n+  CountedLoopNode* inner_counted_loop() const { return unique_ctrl_out()->as_CountedLoop(); }\n+  CountedLoopEndNode* inner_counted_loop_end() const { return  inner_counted_loop()->loopexit(); }\n+  IfFalseNode* inner_loop_exit() const { return inner_counted_loop_end()->proj_out(false)->as_IfFalse(); }\n+\n@@ -1296,1 +1301,1 @@\n-  IdealLoopTree* create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,\n+  IdealLoopTree* create_outer_strip_mined_loop(Node* init_control,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8356708\n+ * @summary C2: loop strip mining expansion doesn't take sunk stores into account\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=26601954 TestStoresSunkInOuterStripMinedLoop\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestStoresSunkInOuterStripMinedLoop\n+ * @run main TestStoresSunkInOuterStripMinedLoop\n+ *\n+ *\/\n+\n+public class TestStoresSunkInOuterStripMinedLoop {\n+    private static int field;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        A a1 = new A();\n+        A a2 = new A();\n+        A a3 = new A();\n+        for (int i = 0; i < 20_000; i++) {\n+            field = 0;\n+            test1();\n+            if (field != 1500) {\n+                throw new RuntimeException(field + \" != 1500\");\n+            }\n+            a1.field = 0;\n+            test2(a1, a2);\n+            if (a1.field != 1500) {\n+                throw new RuntimeException(a1.field + \" != 1500\");\n+            }\n+            a1.field = 0;\n+            test3(a1, a2);\n+            if (a1.field != 1500) {\n+                throw new RuntimeException(a1.field + \" != 1500\");\n+            }\n+            a1.field = 0;\n+            test4(a1, a2, a3);\n+            if (a1.field != 1500) {\n+                throw new RuntimeException(a1.field + \" != 1500\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Single store sunk in outer loop, no store in inner loop\n+    private static float test1() {\n+        int v = field;\n+        float f = 1;\n+        for (int i = 0; i < 1500; i++) {\n+            f *= 2;\n+            v++;\n+            field = v;\n+        }\n+        return f;\n+    }\n+\n+    \/\/ Multiple stores sunk in outer loop, no store in inner loop\n+    private static float test2(A a1, A a2) {\n+        field = a1.field + a2.field;\n+        volatileField = 42;\n+        int v = a1.field;\n+        float f = 1;\n+        for (int i = 0; i < 1500; i++) {\n+            f *= 2;\n+            v++;\n+            a1.field = v;\n+            a2.field = v;\n+        }\n+        return f;\n+    }\n+\n+    \/\/ Store sunk in outer loop, store in inner loop\n+    private static float test3(A a1, A a2) {\n+        field = a1.field + a2.field;\n+        volatileField = 42;\n+        int v = a1.field;\n+        float f = 1;\n+        A a = a2;\n+        for (int i = 0; i < 1500; i++) {\n+            f *= 2;\n+            v++;\n+            a.field = v;\n+            a = a1;\n+            a2.field = v;\n+        }\n+        return f;\n+    }\n+\n+    \/\/ Multiple stores sunk in outer loop, store in inner loop\n+    private static float test4(A a1, A a2, A a3) {\n+        field = a1.field + a2.field + a3.field;\n+        volatileField = 42;\n+        int v = a1.field;\n+        float f = 1;\n+        A a = a2;\n+        for (int i = 0; i < 1500; i++) {\n+            f *= 2;\n+            v++;\n+            a.field = v;\n+            a = a1;\n+            a2.field = v;\n+            a3.field = v;\n+        }\n+        return f;\n+    }\n+\n+    static class A {\n+        int field;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestStoresSunkInOuterStripMinedLoop.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}