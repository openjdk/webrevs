{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,48 +67,0 @@\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a class}\n-     * @param mask the flags to be set, as a bit mask\n-     *\/\n-    static AccessFlags ofClass(int mask) {\n-        return new AccessFlagsImpl(AccessFlag.Location.CLASS, mask);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a class}\n-     * @param flags the flags to be set\n-     *\/\n-    static AccessFlags ofClass(AccessFlag... flags) {\n-        return new AccessFlagsImpl(AccessFlag.Location.CLASS, flags);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a field}\n-     * @param mask the flags to be set, as a bit mask\n-     *\/\n-    static AccessFlags ofField(int mask) {\n-        return new AccessFlagsImpl(AccessFlag.Location.FIELD, mask);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a field}\n-     * @param flags the flags to be set\n-     *\/\n-    static AccessFlags ofField(AccessFlag... flags) {\n-        return new AccessFlagsImpl(AccessFlag.Location.FIELD, flags);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a method}\n-     * @param mask the flags to be set, as a bit mask\n-     *\/\n-    static AccessFlags ofMethod(int mask) {\n-        return new AccessFlagsImpl(AccessFlag.Location.METHOD, mask);\n-    }\n-\n-    \/**\n-     * {@return an {@linkplain AccessFlags} for a method}\n-     * @param flags the flags to be set\n-     *\/\n-    static AccessFlags ofMethod(AccessFlag... flags) {\n-        return new AccessFlagsImpl(AccessFlag.Location.METHOD, flags);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AccessFlags.java","additions":1,"deletions":49,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n@@ -76,1 +78,1 @@\n-        return with(AccessFlags.ofClass(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.CLASS, flags));\n@@ -85,1 +87,1 @@\n-        return with(AccessFlags.ofClass(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.CLASS, flags));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n@@ -58,1 +60,1 @@\n-        return with(AccessFlags.ofField(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.FIELD, flags));\n@@ -67,1 +69,1 @@\n-        return with(AccessFlags.ofField(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.FIELD, flags));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n@@ -58,1 +60,1 @@\n-        return with(AccessFlags.ofMethod(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.METHOD, flags));\n@@ -67,1 +69,1 @@\n-        return with(AccessFlags.ofMethod(flags));\n+        return with(new AccessFlagsImpl(AccessFlag.Location.METHOD, flags));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -53,1 +54,1 @@\n-        this.flags = AccessFlags.ofField();\n+        this.flags = new AccessFlagsImpl(AccessFlag.Location.FIELD);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        this.flags = AccessFlags.ofMethod(flags);\n+        this.flags = new AccessFlagsImpl(AccessFlag.Location.METHOD, flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        return AccessFlags.ofClass(reader.flags());\n+        return new AccessFlagsImpl(AccessFlag.Location.CLASS, reader.flags());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -51,1 +52,1 @@\n-        return AccessFlags.ofField(reader.readU2(startPos));\n+        return new AccessFlagsImpl(AccessFlag.Location.FIELD, reader.readU2(startPos));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -54,1 +55,1 @@\n-        return AccessFlags.ofMethod(reader.readU2(startPos));\n+        return new AccessFlagsImpl(AccessFlag.Location.METHOD, reader.readU2(startPos));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -32,0 +33,1 @@\n+import java.util.EnumSet;\n@@ -152,1 +154,1 @@\n-        writeModifiers(getClassModifiers(cm.flags().flagsMask()));\n+        writeModifiers(getClassModifiers(cm.flags()));\n@@ -213,1 +215,1 @@\n-                    getClassFlags(cm.flags().flagsMask()), \"\\n\");\n+                    getClassFlags(cm.flags()), \"\\n\");\n@@ -419,1 +421,1 @@\n-        var flags = AccessFlags.ofField(f.flags().flagsMask());\n+        var flags = f.flags();\n@@ -797,3 +799,10 @@\n-    private Set<String> getClassModifiers(int mask) {\n-        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask)));\n+    private Set<String> getClassModifiers(AccessFlags flags) {\n+        var flagSet = flagsReportUnknown(flags);\n+        Set<AccessFlag> set;\n+        if (flagSet.contains(AccessFlag.INTERFACE)) {\n+            set = EnumSet.copyOf(flagSet);\n+            set.remove(AccessFlag.ABSTRACT);\n+        } else {\n+            set = flagSet;\n+        }\n+        return getModifiers(set);\n@@ -809,10 +818,2 @@\n-    private Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n-    }\n-\n-    private Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n-    }\n-\n-    private Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n+    private Set<String> getClassFlags(AccessFlags flags) {\n+        return getFlags(flags.flagsMask(), flagsReportUnknown(flags));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n@@ -37,0 +40,4 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -48,3 +55,14 @@\n-            case CLASS -> AccessFlags::ofClass;\n-            case METHOD -> AccessFlags::ofMethod;\n-            case FIELD -> AccessFlags::ofField;\n+            case CLASS -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> clb.withFlags(v));\n+                return ClassFile.of().parse(bytes).flags();\n+            };\n+            case METHOD -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withMethod(\"test\", MTD_void, v & ACC_STATIC, mb -> mb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).methods().getFirst().flags();\n+            };\n+            case FIELD -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withField(\"test\", CD_int, fb -> fb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).fields().getFirst().flags();\n+            };\n@@ -54,3 +72,15 @@\n-            case CLASS -> AccessFlags::ofClass;\n-            case METHOD -> AccessFlags::ofMethod;\n-            case FIELD -> AccessFlags::ofField;\n+            case CLASS -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> clb.withFlags(v));\n+                return ClassFile.of().parse(bytes).flags();\n+            };\n+            case METHOD -> v -> {\n+                boolean hasStatic = Arrays.stream(v).anyMatch(f -> f == AccessFlag.STATIC);\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withMethod(\"test\", MTD_void, hasStatic ? ACC_STATIC : 0, mb -> mb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).methods().getFirst().flags();\n+            };\n+            case FIELD -> v -> {\n+                var bytes = ClassFile.of().build(ClassDesc.of(\"Test\"), clb ->\n+                        clb.withField(\"test\", CD_int, fb -> fb.withFlags(v)));\n+                return ClassFile.of().parse(bytes).fields().getFirst().flags();\n+            };\n@@ -75,5 +105,5 @@\n-        assertAll(\n-            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofClass),\n-            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofField),\n-            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofMethod)\n-        );\n+        ClassFile.of().build(ClassDesc.of(\"Test\"), clb -> {\n+            assertThrowsForInvalidFlagsUse(clb::withFlags);\n+            clb.withMethod(\"test\", MTD_void, ACC_STATIC, mb -> assertThrowsForInvalidFlagsUse(mb::withFlags));\n+            clb.withField(\"test\", CD_int, fb -> assertThrowsForInvalidFlagsUse(fb::withFlags));\n+        });\n","filename":"test\/jdk\/jdk\/classfile\/AccessFlagsTest.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -56,0 +55,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -119,1 +120,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -138,1 +139,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -156,1 +157,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -176,1 +177,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -196,1 +197,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -215,1 +216,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n@@ -240,1 +241,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -38,0 +37,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -46,1 +48,0 @@\n-import java.lang.reflect.AccessFlag;\n@@ -187,1 +188,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {\n@@ -218,1 +219,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {\n@@ -281,1 +282,1 @@\n-                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -41,1 +44,0 @@\n-import static java.lang.classfile.TypeKind.VoidType;\n@@ -59,1 +61,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -38,1 +41,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -78,1 +80,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/LowAdaptTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.nio.file.Path;\n@@ -41,1 +40,0 @@\n-import java.util.Arrays;\n@@ -44,1 +42,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -61,0 +58,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -63,3 +62,0 @@\n-import static java.lang.classfile.Opcode.*;\n-import static java.lang.classfile.Opcode.INVOKEVIRTUAL;\n-import static java.lang.classfile.TypeKind.VoidType;\n@@ -131,1 +127,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -246,1 +242,1 @@\n-                          ClassFile.ACC_PUBLIC,\n+                          ACC_PUBLIC,\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -34,1 +37,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -41,1 +43,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -77,1 +78,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -32,0 +31,3 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -41,3 +43,0 @@\n-import static java.lang.reflect.AccessFlag.PUBLIC;\n-import static java.lang.reflect.AccessFlag.STATIC;\n-\n@@ -51,1 +50,1 @@\n-            cb.withMethodBody(\"m\", mtd, AccessFlags.ofMethod(PUBLIC, STATIC).flagsMask(), xb -> {\n+            cb.withMethodBody(\"m\", mtd, ACC_PUBLIC | ACC_STATIC, xb -> {\n","filename":"test\/jdk\/jdk\/classfile\/SwapTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -36,1 +35,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -42,0 +40,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -43,4 +43,0 @@\n-import static java.lang.classfile.Opcode.*;\n-import static java.lang.classfile.TypeKind.IntType;\n-import static java.lang.classfile.TypeKind.ReferenceType;\n-import static java.lang.classfile.TypeKind.VoidType;\n@@ -64,1 +60,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n@@ -105,1 +101,1 @@\n-                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/jdk\/jdk\/classfile\/WriteTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-                case AccessFlags a -> fb.with(AccessFlags.ofField(a.flagsMask() & ~ClassFile.ACC_PUBLIC & ~ClassFile.ACC_PROTECTED));\n+                case AccessFlags a -> fb.withFlags(a.flagsMask() & ~ClassFile.ACC_PUBLIC & ~ClassFile.ACC_PROTECTED);\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import java.lang.classfile.AccessFlags;\n@@ -33,0 +32,2 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n@@ -151,1 +152,1 @@\n-                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                              ACC_PUBLIC | ACC_STATIC,\n@@ -199,1 +200,1 @@\n-                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                              ACC_PUBLIC | ACC_STATIC,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}