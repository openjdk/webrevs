{"files":[{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.runtime;\n+\n+import org.openjdk.bench.vm.lang.Throw;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import java.lang.*;\n+import java.util.*;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.whitebox.WhiteBox;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+public abstract class NMTBenchmark_wb {\n+\n+    @Param({\"2\", \"4\", \"8\", \"16\"})\n+    public int THREADS;\n+\n+    @Param({\"16\", \"32\", \"64\"})\n+    public int REGIONS;\n+\n+    @Param({\"4\", \"8\", \"16\", \"32\", \"64\"})\n+    public int SUB_REGIONS;\n+\n+    private static final int PAGE_SIZE = 1024 * 4;\n+\n+    \/\/ Need to wrap WhiteBox in a holder class so that it doesn't get initialized on the host VM (which won't\n+    \/\/ have WB enabled.\n+    private static class WhiteBoxHolder {\n+\n+        private static final WhiteBox WB;\n+\n+        static {\n+            System.out.println(\"Current user dir: \" + System.getProperty(\"user.dir\"));\n+            WhiteBox wb = null;\n+            try {\n+                wb = WhiteBox.getWhiteBox();\n+            } catch (Throwable t) {\n+                System.out.println(\"WhiteBox initialization failure: \" + t);\n+                t.printStackTrace();\n+                \/\/ Explicit exit to avoid initialization loops.\n+                System.exit(17);\n+            }\n+            WB = wb;\n+        }\n+    }\n+\n+    private static long reserve (long size           ) { return WhiteBoxHolder.WB.NMTReserveMemory (size                             ); }\n+    private static void commit  (long base, int pno  ) {        WhiteBoxHolder.WB.NMTCommitMemory  (base + pno * PAGE_SIZE, PAGE_SIZE); }\n+    private static void uncommit(long base, int pno  ) {        WhiteBoxHolder.WB.NMTUncommitMemory(base + pno * PAGE_SIZE, PAGE_SIZE); }\n+    private static void release (long base, long size) {        WhiteBoxHolder.WB.NMTReleaseMemory (base                  , size     ); }\n+\n+    public static void doAllMemoryOps(int reserved_regions_count, int committed_regions_count) {\n+        long region_size = committed_regions_count * PAGE_SIZE;\n+        long[] base_array = new long[reserved_regions_count];\n+\n+        for (int i = 0; i < reserved_regions_count; i++)\n+          base_array[i] = reserve(region_size);\n+\n+        for (int r = 0; r < reserved_regions_count; r++) {\n+          long base = base_array[r];\n+          for (int i = 0; i < region_count; i += 4) commit  (base, i    );\n+          for (int i = 1; i < region_count; i += 4) commit  (base, i    ); \/\/ causes merge from right\n+          for (int i = 4; i < region_count; i += 4) commit  (base, i - 1); \/\/ causes merge from left\n+          for (int i = 4; i < region_count; i += 4) uncommit(base, i - 1); \/\/ causes split from left\n+          for (int i = 1; i < region_count; i += 4) uncommit(base, i    ); \/\/ causes split from right\n+          for (int i = 0; i < region_count; i += 4) uncommit(base, i    ); \/\/ remove the regions\n+        }\n+\n+        for (int i = 0; i < reserved_regions_count; i++)\n+          release(base_array[i], region_size);\n+    }\n+\n+    public static void doTest(int reserved_regions_count, int threads_count, int committed_regions_count) throws InterruptedException{\n+        int regions_per_thread = reserved_regions_count \/ threads_count;\n+        Thread[] threads =  new Thread[threads_count];\n+        for (int t = 0; t < threads_count; t++) {\n+            threads[t] = new Thread(() -> doAllMemoryOps(regions_per_thread, committed_regions_count));\n+            threads[t].start();\n+        }\n+        for (Thread t: threads) t.join();\n+    }\n+\n+    @Benchmark\n+    public void virtualMemoryTests() {\n+        try { doTest(REGIONS, THREADS, SUB_REGIONS); }\n+        catch (Throwable t) {\n+            System.out.println(t.getMessage());\n+        }\n+    }\n+\n+    public static final String ADD_EXPORTS = \"--add-exports\";\n+\n+    public static final String MISC_PACKAGE = \"java.base\/jdk.internal.misc=ALL-UNNAMED\"; \/\/ used for Unsafe API\n+\n+    public static final String WB_UNLOCK_OPTION = \"-XX:+UnlockDiagnosticVMOptions\";\n+\n+    public static final String WB_API = \"-XX:+WhiteBoxAPI\";\n+\n+    public static final String WB_JAR_APPEND = \"-Xbootclasspath\/a:lib-test\/wb.jar\";\n+\n+    @Fork(value = 2, jvmArgsPrepend = { WB_JAR_APPEND, WB_UNLOCK_OPTION, WB_API, ADD_EXPORTS, MISC_PACKAGE, \"-XX:NativeMemoryTracking=off\"})\n+    public static class NMTOff extends NMTBenchmark_wb { }\n+\n+    @Fork(value = 2, jvmArgsPrepend = { WB_JAR_APPEND, WB_UNLOCK_OPTION, WB_API, ADD_EXPORTS, MISC_PACKAGE, \"-XX:NativeMemoryTracking=summary\"})\n+    public static class NMTSummary extends NMTBenchmark_wb { }\n+\n+    @Fork(value = 2, jvmArgsPrepend = { WB_JAR_APPEND, WB_UNLOCK_OPTION, WB_API, ADD_EXPORTS, MISC_PACKAGE, \"-XX:NativeMemoryTracking=detail\"})\n+    public static class NMTDetail extends NMTBenchmark_wb { }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/runtime\/NMTBenchmark_wb.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"}]}