{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -771,1 +771,0 @@\n-            out.write(\"#include \\\"oops\/klass.hpp\\\"\");\n@@ -774,0 +773,2 @@\n+            out.write(\"#include \\\"oops\/klass.hpp\\\"\");\n+            out.write(\"#include \\\"runtime\/thread.hpp\\\"\");\n@@ -792,0 +793,1 @@\n+            printHelpers(out, false);\n@@ -809,0 +811,1 @@\n+            printHelpers(out, true);\n@@ -816,0 +819,30 @@\n+    private static void printHelpers(Printer out, boolean empty) {\n+        out.write(\"template <typename EventType>\");\n+        out.write(\"class JfrNonReentrant : public EventType {\");\n+        if (!empty) {\n+            out.write(\" private:\");\n+            out.write(\"  Thread* const _thread;\");\n+            out.write(\"  int32_t _previous_nesting;\");\n+        }\n+        out.write(\" public:\");\n+        out.write(\"  JfrNonReentrant(EventStartTime timing = TIMED)\");\n+        if (empty) {\n+            out.write(\"  {}\");\n+        } else {\n+            out.write(\"    : EventType(timing), _thread(Thread::current()), _previous_nesting(JfrThreadLocal::make_non_reentrant(_thread)) {}\");\n+            out.write(\"\");\n+            out.write(\"  JfrNonReentrant(Thread* thread, EventStartTime timing = TIMED)\");\n+            out.write(\"    : EventType(timing), _thread(thread), _previous_nesting(JfrThreadLocal::make_non_reentrant(_thread)) {\");\n+            out.write(\"      assert(_thread != nullptr, \\\"invariant\\\");\");\n+            out.write(\"  }\");\n+        }\n+        if (!empty) {\n+          out.write(\"  ~JfrNonReentrant() {\");\n+          out.write(\"    if (_previous_nesting != -1) {\");\n+          out.write(\"      JfrThreadLocal::make_reentrant(_thread, _previous_nesting);\");\n+          out.write(\"    }\");\n+          out.write(\"  }\");\n+        }\n+        out.write(\"};\");\n+    }\n+\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  EventZStatisticsCounter e;\n+  JfrNonReentrant<EventZStatisticsCounter> e;\n@@ -139,1 +139,1 @@\n-  EventZStatisticsSampler e;\n+  JfrNonReentrant<EventZStatisticsSampler> e;\n","filename":"src\/hotspot\/share\/gc\/z\/zTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -680,0 +680,4 @@\n+void JfrCheckpointManager::write_simplified_vthread_checkpoint(traceid vtid) {\n+  JfrTypeManager::write_simplified_vthread_checkpoint(vtid);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  static void write_simplified_vthread_checkpoint(traceid vtid);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -315,0 +315,17 @@\n+\/\/ This serializer is used when the vthread name cannot\n+\/\/ be determined because we cannot access any oops.\n+void JfrSimplifiedVirtualThreadConstant::serialize(JfrCheckpointWriter & writer) {\n+  writer.write_key(_vtid);\n+  \/\/ Write the null string categorically as the os name for virtual threads.\n+  writer.write((const char*)nullptr); \/\/ os name\n+  writer.write(0); \/\/ os id\n+  \/\/ vthread name cannot be determined for this simplified version.\n+  \/\/ This is because we cannot access any oops.\n+  writer.write_empty_string();\n+  writer.write(_vtid); \/\/ java tid\n+  \/\/ java thread group - VirtualThread threadgroup reserved id 1\n+  writer.write(1);\n+  writer.write<bool>(true); \/\/ isVirtual\n+  \/\/ VirtualThread threadgroup already serialized invariant.\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -120,0 +120,8 @@\n+class JfrSimplifiedVirtualThreadConstant : public JfrSerializer {\n+ private:\n+  traceid _vtid;\n+ public:\n+  JfrSimplifiedVirtualThreadConstant(traceid vtid) : _vtid(vtid) {}\n+  void serialize(JfrCheckpointWriter & writer);\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -135,0 +135,11 @@\n+void JfrTypeManager::write_simplified_vthread_checkpoint(traceid vtid) {\n+  Thread* const current = Thread::current();\n+  assert(current != nullptr, \"invariant\");\n+  ResourceMark rm(current);\n+  JfrCheckpointWriter writer(current, true, THREADS, JFR_VIRTUAL_THREADLOCAL);\n+  \/\/ TYPE_THREAD and count is written later as part of vthread bulk serialization.\n+  writer.set_count(1); \/\/ Only a logical marker for the checkpoint header.\n+  JfrSimplifiedVirtualThreadConstant type_simple_vthread(vtid);\n+  type_simple_vthread.serialize(writer);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+  static void write_simplified_vthread_checkpoint(traceid vtid);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  _non_reentrant_nesting(0),\n@@ -368,2 +369,2 @@\n-  \/\/ To support event recursion, we update the native side first,\n-  \/\/ this provides the terminating case.\n+  assert(!is_non_reentrant(), \"invariant\");\n+\n@@ -371,13 +372,1 @@\n-  \/*\n-  * The java side, i.e. the vthread object, can now be updated.\n-  * Accessing the vthread object itself is a recursive case,\n-  * because it can trigger additional events, e.g.\n-  * loading the oop through load barriers.\n-  * Note there is a potential problem with this solution:\n-  * The recursive write hitting the terminating case will\n-  * use the thread id _before_ the checkpoint is committed.\n-  * Hence, the periodic thread can possibly flush that event\n-  * to a segment that does not include an associated checkpoint.\n-  * Considered rare and quite benign for now. The worst case is\n-  * that thread information for that event is not resolvable, i.e. null.\n-  *\/\n+\n@@ -386,0 +375,1 @@\n+\n@@ -390,0 +380,15 @@\n+void JfrThreadLocal::set_vthread_epoch_checked(const JavaThread* jt, traceid tid, u2 epoch) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(is_vthread(jt), \"invariant\");\n+\n+  \/\/ If the event is marked as non reentrant, write only a simplified version of the vthread info.\n+  \/\/ Essentially all the same info except the vthread name, because we cannot touch the oop.\n+  \/\/ Since we cannot touch the oop, we also cannot update its vthread epoch.\n+  if (is_non_reentrant()) {\n+    JfrCheckpointManager::write_simplified_vthread_checkpoint(tid);\n+    return;\n+  }\n+\n+  set_vthread_epoch(jt, tid, epoch);\n+}\n+\n@@ -419,1 +424,1 @@\n-      set_vthread_epoch(jt, tid, current_epoch);\n+      set_vthread_epoch_checked(jt, tid, current_epoch);\n@@ -483,0 +488,20 @@\n+int32_t JfrThreadLocal::make_non_reentrant(Thread* t) {\n+  assert(t != nullptr, \"invariant\");\n+  if (!t->is_Java_thread() || !is_vthread(JavaThread::cast(t))) {\n+    return -1;\n+  }\n+  return t->jfr_thread_local()->_non_reentrant_nesting++;\n+}\n+\n+void JfrThreadLocal::make_reentrant(Thread* t, int32_t previous_nesting) {\n+  assert(t->is_Java_thread() && is_vthread(JavaThread::cast(t)), \"invariant\");\n+  assert(previous_nesting >= 0, \"invariant\");\n+  t->jfr_thread_local()->_non_reentrant_nesting = previous_nesting;\n+}\n+\n+bool JfrThreadLocal::is_non_reentrant() {\n+  Thread* const current_thread = Thread::current();\n+  assert(current_thread != nullptr, \"invariant\");\n+  return current_thread->jfr_thread_local()->_non_reentrant_nesting > 0;\n+}\n+\n@@ -496,0 +521,1 @@\n+  assert(tl->_non_reentrant_nesting == 0, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":42,"deletions":16,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+  int32_t _non_reentrant_nesting;\n@@ -84,1 +85,2 @@\n-  static void set_vthread_epoch(const JavaThread* jt, traceid id, u2 epoch);\n+  static void set_vthread_epoch(const JavaThread* jt, traceid tid, u2 epoch);\n+  static void set_vthread_epoch_checked(const JavaThread* jt, traceid tid, u2 epoch);\n@@ -92,0 +94,1 @@\n+  static bool is_non_reentrant();\n@@ -269,0 +272,3 @@\n+  static int32_t make_non_reentrant(Thread* thread);\n+  static void make_reentrant(Thread* thread, int32_t previous_nesting);\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}