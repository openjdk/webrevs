{"files":[{"patch":"@@ -234,11 +234,0 @@\n-        \/\/ preprocess for links\n-        switch (kind) {\n-            case CONSTRUCTORS, METHODS -> {\n-                for (var m : members) {\n-                    \/\/ nit picking: constructors are not members, see JLS 8.2. Class Members\n-                    htmlIds.register(typeElement, (ExecutableElement) m);\n-                }\n-                htmlIds.endRegistration(typeElement, kind == CONSTRUCTORS ?\n-                        ElementKind.CONSTRUCTOR : ElementKind.METHOD);\n-            }\n-        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.LinkedHashSet;\n@@ -34,2 +33,0 @@\n-import java.util.Optional;\n-import java.util.SequencedSet;\n@@ -37,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -177,1 +175,1 @@\n-        return forExecutable((TypeElement) element.getEnclosingElement(), element);\n+        return forExecutable(element);\n@@ -549,12 +547,1 @@\n-    private final Map<TypeElement, Map<ExecutableElement, String>> ids = new HashMap<>();\n-    \/*\n-     * This map is transient in a sense that it keeps its elements until\n-     * the registration is over. The order of the elements is important\n-     * for reproducibility of ids.\n-     *\/\n-    private final Map<Key, Optional<SequencedSet<ExecutableElement>>> registered = new HashMap<>();\n-    \/*\n-     * Registration key to differentiate between methods and constructors,\n-     * whose registration ends at different times.\n-     *\/\n-    private record Key(TypeElement typeElement, ElementKind elementKind) { }\n+    private final Map<ExecutableElement, HtmlId> ids = new HashMap<>();\n@@ -566,35 +553,1 @@\n-     * The primary goal is to provide coordination, not cache.\n-     *\/\n-    private HtmlId forExecutable(TypeElement t, ExecutableElement e) {\n-        var map = ids.get(t);\n-        if (map != null) {\n-            assert !map.isEmpty();\n-            String name = map.get(e);\n-            \/\/ name == null can happen when a link is processed before the\n-            \/\/ page\/element-type it refers to. For example, a class constructor\n-            \/\/ can @link to a class method which has not been registered yet\n-            \/\/ (because methods of a class are registered after the constructors\n-            \/\/ of that class).\n-            if (name != null)\n-                return HtmlId.of(name);\n-        }\n-        \/\/ must be an external @link\/@see, which might be processed before the\n-        \/\/ methods from the page it links to has been registered; cannot do\n-        \/\/ much about it, unless all constructors and methods register before\n-        \/\/ even the first page is generated -- something to think about (i.e.\n-        \/\/ \"TODO\")\n-        return forMember0(e);\n-    }\n-\n-    public void register(TypeElement t, ExecutableElement e) {\n-        var opt = registered.computeIfAbsent(new Key(t, e.getKind()),\n-                t_ -> Optional.of(new LinkedHashSet<>()));\n-        if (opt.isEmpty())\n-            throw new IllegalStateException(\"Registration for \" + t + \" has ended\");\n-        else\n-            opt.get().add(e);\n-    }\n-\n-    \/*\n-     * Declares that there won't be any more executable elements (of the\n-     * specified kind) registered for the specified type element.\n+     * The goal is to provide coordination, not cache.\n@@ -602,6 +555,18 @@\n-    public void endRegistration(TypeElement t, ElementKind k) {\n-        var prev = registered.put(new Key(t, k), Optional.empty());\n-        if (prev == null)\n-            return;\n-        var map = ids.computeIfAbsent(t, t_ -> new HashMap<>());\n-        var dups = new HashSet<>();\n+    private HtmlId forExecutable(ExecutableElement e) {\n+        HtmlId htmlId = ids.get(e);\n+        if (htmlId != null)\n+            return htmlId;\n+        if (e.getKind() != ElementKind.CONSTRUCTOR\n+                && e.getKind() != ElementKind.METHOD)\n+            throw new IllegalArgumentException(String.valueOf(e.getKind()));\n+        var vmt = configuration.getVisibleMemberTable((TypeElement) e.getEnclosingElement());\n+        var ctors = vmt.getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        var methods = vmt.getVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+        \/\/ for whatever reason annotation methods are not of Kind.METHODS\n+        var otherMethods = vmt.getVisibleMembers(VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER);\n+        \/\/ the order of the elements is important for reproducibility of ids:\n+        \/\/ the same executable element must have the same id across javadoc runs\n+        var list = Stream.concat(Stream.concat(ctors.stream(), methods.stream()), otherMethods.stream())\n+                .map(e1 -> (ExecutableElement) e1)\n+                .toList();\n+        var dups = new HashSet<String>();\n@@ -611,5 +576,5 @@\n-        for (var e : prev.get()) {\n-            if (forErasure(e) == null) {\n-                var id = forMember0(e).name();\n-                map.put(e, id);\n-                boolean added = dups.add(id);\n+        for (var m : list) {\n+            if (forErasure(m) == null) {\n+                var simpleId = forMember0(m);\n+                ids.put(m, simpleId);\n+                boolean added = dups.add(simpleId.name());\n@@ -623,6 +588,6 @@\n-        for (var e : prev.get()) {\n-            var erasure = forErasure(e);\n-            if (erasure != null) {\n-                var simpleId = forMember0(e).name();\n-                if (dups.add(simpleId)) {\n-                    map.put(e, simpleId);\n+        for (var m : list) {\n+            var erasedId = forErasure(m);\n+            if (erasedId != null) {\n+                var simpleId = forMember0(m);\n+                if (dups.add(simpleId.name())) {\n+                    ids.put(m, simpleId);\n@@ -630,2 +595,2 @@\n-                    map.put(e, erasure.name());\n-                    boolean added = dups.add(erasure.name());\n+                    ids.put(m, erasedId);\n+                    boolean added = dups.add(erasedId.name());\n@@ -641,0 +606,13 @@\n+        htmlId = ids.get(e);\n+        if (htmlId == null) {\n+            \/\/ Safety net: if for whatever reason we cannot find the element\n+            \/\/ among those we just expanded, return the simple id. It might\n+            \/\/ not be right, but at least it won't fail.\n+            \/\/ One example where it might happen is linking to an inherited\n+            \/\/ undocumented method (see test case T5093723)\n+            \/\/ TODO the above will need to be revisited if and when we redesign\n+            \/\/  VisibleMemberTable, which currently cannot correctly return the\n+            \/\/  owner of such a method\n+            htmlId = forMember0(e);\n+        }\n+        return htmlId;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":48,"deletions":70,"binary":false,"changes":118,"status":"modified"}]}