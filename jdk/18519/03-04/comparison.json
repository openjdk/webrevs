{"files":[{"patch":"@@ -103,1 +103,1 @@\n-                writer.tableOfContents.addLink(htmlIds.forMember(typeElement, (ExecutableElement) member),\n+                writer.tableOfContents.addLink(htmlIds.forMember((ExecutableElement) member).getFirst(),\n@@ -213,1 +213,1 @@\n-                .setId(htmlIds.forMember(typeElement, (ExecutableElement) member));\n+                .setId(htmlIds.forMember((ExecutableElement) member).getFirst());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                writer.tableOfContents.addLink(htmlIds.forMember(currentConstructor),\n+                writer.tableOfContents.addLink(htmlIds.forMember(currentConstructor).getFirst(),\n@@ -192,5 +192,4 @@\n-        HtmlId memberAnchor = htmlIds.forMember(constructor);\n-        HtmlId erasureAnchor = htmlIds.forErasure(constructor);\n-        if (erasureAnchor != null\n-                && !erasureAnchor.name().equals(memberAnchor.name())) {\n-            heading.setId(erasureAnchor);\n+\n+        var anchors = htmlIds.forMember(constructor);\n+        if (anchors.size() > 1) {\n+            heading.setId(anchors.getLast());\n@@ -200,1 +199,1 @@\n-                .setId(memberAnchor);\n+                .setId(anchors.getFirst());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1040,1 +1040,1 @@\n-            HtmlId id = isProperty ? htmlIds.forProperty(ee) : htmlIds.forMember(ee);\n+            HtmlId id = isProperty ? htmlIds.forProperty(ee) : htmlIds.forMember(ee).getFirst();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,3 +167,3 @@\n-     * Returns an id for an executable element, suitable for use when the\n-     * simple name and argument list will be unique within the page, such as\n-     * in the page for the declaration of the enclosing class or interface.\n+     * {@return a non-empty list of ids to a constructor or a method}\n+     * The ids from the returned list are alternative: the given constructor\n+     * or method can be equally referred to by any of those ids.\n@@ -171,3 +171,1 @@\n-     * @param element the element\n-     *\n-     * @return the id\n+     * @param executable a constructor or method\n@@ -175,2 +173,66 @@\n-    HtmlId forMember(ExecutableElement element) {\n-        return forExecutable(element);\n+    List<HtmlId> forMember(ExecutableElement executable) {\n+        var htmlId = ids.get(executable);\n+        if (htmlId != null)\n+            return htmlId;\n+        if (executable.getKind() != ElementKind.CONSTRUCTOR\n+                && executable.getKind() != ElementKind.METHOD)\n+            throw new IllegalArgumentException(String.valueOf(executable.getKind()));\n+        var vmt = configuration.getVisibleMemberTable((TypeElement) executable.getEnclosingElement());\n+        var ctors = vmt.getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n+        var methods = vmt.getVisibleMembers(VisibleMemberTable.Kind.METHODS);\n+        record Erased(ExecutableElement element, HtmlId id) { }\n+        \/\/ split elements into two buckets:\n+        \/\/  - elements whose erased id is present\n+        \/\/  - elements whose erased id is absent (i.e. is null)\n+        enum ErasedId { PRESENT, ABSENT }\n+        var buckets = Stream.concat(ctors.stream(), methods.stream())\n+                .map(e -> (ExecutableElement) e)\n+                .map(e -> new Erased(e, forErasure(e)))\n+                .collect(Collectors.groupingBy(erased -> erased.id == null ?\n+                        ErasedId.ABSENT : ErasedId.PRESENT));\n+        var dups = new HashSet<String>();\n+        \/\/ the order of elements in each bucket is important for reproducibility\n+        \/\/ of ids: the same executable element must have the same id in any\n+        \/\/ javadoc run\n+        \/\/ Use simple id, unless we have to use erased id; for that, do the\n+        \/\/ following _in order_:\n+        \/\/ 1. Map all elements that can _only_ be addressed by the simple id\n+        for (var e : buckets.getOrDefault(ErasedId.ABSENT, List.of())) {\n+            var simpleId = forMember0(e.element);\n+            ids.put(e.element, List.of(simpleId));\n+            boolean added = dups.add(simpleId.name());\n+            \/\/ we assume that the simple id for an executable member that\n+            \/\/ does not use type parameters is unique\n+            assert added;\n+        }\n+        \/\/ 2. Map all elements that can be addressed by simple id or erased id;\n+        \/\/ if the simple id is not yet used, use it, otherwise use the erased id\n+        for (var e : buckets.getOrDefault(ErasedId.PRESENT, List.of())) {\n+            var simpleId = forMember0(e.element);\n+            if (dups.add(simpleId.name())) {\n+                ids.put(e.element, List.of(simpleId, e.id));\n+            } else {\n+                ids.put(e.element, List.of(e.id));\n+                boolean added = dups.add(e.id.name());\n+                \/\/ Not only must an erased id not clash with any simple id,\n+                \/\/ but it must also not clash with any other erased id.\n+                \/\/ The latter is because JLS 8.4.2. Method Signature:\n+                \/\/ it is a compile-time error to declare two methods\n+                \/\/ with override-equivalent signatures in a class\n+                assert added;\n+            }\n+        }\n+        \/\/ Safety net: if for whatever reason we cannot find the element\n+        \/\/ among those we just expanded, return the simple id. It might\n+        \/\/ not be always right, but at least it won't fail.\n+        \/\/\n+        \/\/ - one example where it might happen is linking to an inherited\n+        \/\/   undocumented method (see test case T5093723)\n+        \/\/   TODO the above will need to be revisited if and when we redesign\n+        \/\/    VisibleMemberTable, which currently cannot correctly return the\n+        \/\/    owner of such a method\n+        \/\/\n+        \/\/ - another example is annotation interface methods: they are not\n+        \/\/   included in VisibleMemberTable.Kind.METHODS and so cannot be\n+        \/\/   found among them\n+        return ids.computeIfAbsent(executable, e -> List.of(forMember0(e)));\n@@ -179,0 +241,2 @@\n+    private final Map<ExecutableElement, List<HtmlId>> ids = new HashMap<>();\n+\n@@ -186,13 +250,0 @@\n-    \/**\n-     * Returns an id for an executable element, including the context\n-     * of its documented enclosing class or interface.\n-     *\n-     * @param typeElement the enclosing class or interface\n-     * @param member      the element\n-     *\n-     * @return the id\n-     *\/\n-    HtmlId forMember(TypeElement typeElement, ExecutableElement member) {\n-        return HtmlId.of(utils.getSimpleName(member) + utils.signature(member, typeElement));\n-    }\n-\n@@ -241,1 +292,1 @@\n-    protected HtmlId forErasure(ExecutableElement executableElement) {\n+    private HtmlId forErasure(ExecutableElement executableElement) {\n@@ -495,1 +546,1 @@\n-            case CONSTRUCTOR, METHOD -> forMember((ExecutableElement) el).name();\n+            case CONSTRUCTOR, METHOD -> forMember((ExecutableElement) el).getFirst().name();\n@@ -509,1 +560,1 @@\n-        return HtmlId.of(\"restricted-\" + forMember(el).name());\n+        return HtmlId.of(\"restricted-\" + forMember(el).getFirst().name());\n@@ -547,77 +598,0 @@\n-\n-    private final Map<ExecutableElement, HtmlId> ids = new HashMap<>();\n-\n-    \/*\n-     * Returns an id to a constructor or a method, from a centralised\n-     * registry. Use to get an anchor to a constructor or method.\n-     *\n-     * The goal is to provide coordination, not cache.\n-     *\/\n-    private HtmlId forExecutable(ExecutableElement e) {\n-        HtmlId htmlId = ids.get(e);\n-        if (htmlId != null)\n-            return htmlId;\n-        if (e.getKind() != ElementKind.CONSTRUCTOR\n-                && e.getKind() != ElementKind.METHOD)\n-            throw new IllegalArgumentException(String.valueOf(e.getKind()));\n-        var vmt = configuration.getVisibleMemberTable((TypeElement) e.getEnclosingElement());\n-        var ctors = vmt.getVisibleMembers(VisibleMemberTable.Kind.CONSTRUCTORS);\n-        var methods = vmt.getVisibleMembers(VisibleMemberTable.Kind.METHODS);\n-        \/\/ for whatever reason annotation methods are not of Kind.METHODS\n-        var otherMethods = vmt.getVisibleMembers(VisibleMemberTable.Kind.ANNOTATION_TYPE_MEMBER);\n-        \/\/ the order of the elements is important for reproducibility of ids:\n-        \/\/ the same executable element must have the same id across javadoc runs\n-\n-        record Erased(ExecutableElement element, HtmlId id) { }\n-        \/\/ split elements into two buckets:\n-        \/\/  - elements whose erased id is present\n-        \/\/  - elements whose erased id is absent (i.e. is null)\n-        enum ErasedId { PRESENT, ABSENT }\n-        var buckets = Stream.concat(Stream.concat(ctors.stream(), methods.stream()), otherMethods.stream())\n-                .map(e1 -> (ExecutableElement) e1)\n-                .map(e1 -> new Erased(e1, forErasure(e1)))\n-                .collect(Collectors.groupingBy(erased -> erased.id == null ?\n-                        ErasedId.ABSENT : ErasedId.PRESENT));\n-        var dups = new HashSet<String>();\n-        \/\/ Use simple id, unless we have to use erased id; for that, do the\n-        \/\/ following _in order_:\n-        \/\/ 1. Map all elements that can _only_ be addressed by the simple id\n-        for (var m : buckets.getOrDefault(ErasedId.ABSENT, List.of())) {\n-            var simpleId = forMember0(m.element);\n-            ids.put(m.element, simpleId);\n-            boolean added = dups.add(simpleId.name());\n-            \/\/ we assume that the simple id for an executable member that\n-            \/\/ does not use type parameters is unique\n-            assert added;\n-        }\n-        \/\/ 2. Map all elements that can be addressed by simple id or erased id;\n-        \/\/ if the simple id is not yet used, use it, otherwise use the erased id\n-        for (var m : buckets.getOrDefault(ErasedId.PRESENT, List.of())) {\n-            var simpleId = forMember0(m.element);\n-            if (dups.add(simpleId.name())) {\n-                ids.put(m.element, simpleId);\n-            } else {\n-                ids.put(m.element, m.id);\n-                boolean added = dups.add(m.id.name());\n-                \/\/ Not only must an erased id not clash with any simple id,\n-                \/\/ but it must also not clash with any other erased id.\n-                \/\/ The latter is because JLS 8.4.2. Method Signature:\n-                \/\/ it is a compile-time error to declare two methods\n-                \/\/ with override-equivalent signatures in a class\n-                assert added;\n-            }\n-        }\n-        htmlId = ids.get(e);\n-        if (htmlId == null) {\n-            \/\/ Safety net: if for whatever reason we cannot find the element\n-            \/\/ among those we just expanded, return the simple id. It might\n-            \/\/ not be right, but at least it won't fail.\n-            \/\/ One example where it might happen is linking to an inherited\n-            \/\/ undocumented method (see test case T5093723)\n-            \/\/ TODO the above will need to be revisited if and when we redesign\n-            \/\/  VisibleMemberTable, which currently cannot correctly return the\n-            \/\/  owner of such a method\n-            htmlId = forMember0(e);\n-        }\n-        return htmlId;\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":75,"deletions":101,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-                    String url = HtmlTree.encodeURL(htmlIds.forMember((ExecutableElement) element).name());\n+                    String url = HtmlTree.encodeURL(htmlIds.forMember((ExecutableElement) element).getFirst().name());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIndexBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                writer.tableOfContents.addLink(htmlIds.forMember(currentMethod),\n+                writer.tableOfContents.addLink(htmlIds.forMember(currentMethod).getFirst(),\n@@ -207,5 +207,3 @@\n-        HtmlId memberAnchor = htmlIds.forMember(method);\n-        HtmlId erasureAnchor = htmlIds.forErasure(method);\n-        if (erasureAnchor != null\n-                && !erasureAnchor.name().equals(memberAnchor.name())) {\n-            heading.setId(erasureAnchor);\n+        var anchors = htmlIds.forMember(method);\n+        if (anchors.size() > 1) {\n+            heading.setId(anchors.getLast());\n@@ -215,1 +213,1 @@\n-                .setId(htmlIds.forMember(method));\n+                .setId(anchors.getFirst());\n@@ -380,1 +378,1 @@\n-                        .fragment(writer.htmlIds.forMember(method).name())\n+                        .fragment(writer.htmlIds.forMember(method).getFirst().name())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"}]}