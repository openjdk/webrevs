{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Collectors;\n@@ -569,1 +570,7 @@\n-        var list = Stream.concat(Stream.concat(ctors.stream(), methods.stream()), otherMethods.stream())\n+\n+        record Erased(ExecutableElement element, HtmlId id) { }\n+        \/\/ split elements into two buckets:\n+        \/\/  - elements whose erased id is present\n+        \/\/  - elements whose erased id is absent (i.e. is null)\n+        enum ErasedId { PRESENT, ABSENT }\n+        var buckets = Stream.concat(Stream.concat(ctors.stream(), methods.stream()), otherMethods.stream())\n@@ -571,1 +578,3 @@\n-                .toList();\n+                .map(e1 -> new Erased(e1, forErasure(e1)))\n+                .collect(Collectors.groupingBy(erased -> erased.id == null ?\n+                        ErasedId.ABSENT : ErasedId.PRESENT));\n@@ -576,9 +585,7 @@\n-        for (var m : list) {\n-            if (forErasure(m) == null) {\n-                var simpleId = forMember0(m);\n-                ids.put(m, simpleId);\n-                boolean added = dups.add(simpleId.name());\n-                \/\/ we assume that the simple id for an executable member that\n-                \/\/ does not use type parameters is unique\n-                assert added;\n-            }\n+        for (var m : buckets.getOrDefault(ErasedId.ABSENT, List.of())) {\n+            var simpleId = forMember0(m.element);\n+            ids.put(m.element, simpleId);\n+            boolean added = dups.add(simpleId.name());\n+            \/\/ we assume that the simple id for an executable member that\n+            \/\/ does not use type parameters is unique\n+            assert added;\n@@ -588,16 +595,13 @@\n-        for (var m : list) {\n-            var erasedId = forErasure(m);\n-            if (erasedId != null) {\n-                var simpleId = forMember0(m);\n-                if (dups.add(simpleId.name())) {\n-                    ids.put(m, simpleId);\n-                } else {\n-                    ids.put(m, erasedId);\n-                    boolean added = dups.add(erasedId.name());\n-                    \/\/ Not only must an erased id not clash with any simple id,\n-                    \/\/ but it must also not clash with any other erased id.\n-                    \/\/ The latter is because JLS 8.4.2. Method Signature:\n-                    \/\/ it is a compile-time error to declare two methods\n-                    \/\/ with override-equivalent signatures in a class\n-                    assert added;\n-                }\n+        for (var m : buckets.getOrDefault(ErasedId.PRESENT, List.of())) {\n+            var simpleId = forMember0(m.element);\n+            if (dups.add(simpleId.name())) {\n+                ids.put(m.element, simpleId);\n+            } else {\n+                ids.put(m.element, m.id);\n+                boolean added = dups.add(m.id.name());\n+                \/\/ Not only must an erased id not clash with any simple id,\n+                \/\/ but it must also not clash with any other erased id.\n+                \/\/ The latter is because JLS 8.4.2. Method Signature:\n+                \/\/ it is a compile-time error to declare two methods\n+                \/\/ with override-equivalent signatures in a class\n+                assert added;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"}]}