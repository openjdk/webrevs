{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -37,0 +38,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -43,0 +46,2 @@\n+import sun.invoke.util.Wrapper;\n+\n@@ -202,0 +207,37 @@\n+\n+    private static long computePadding(long offset, long align) {\n+        boolean isAligned = offset == 0 || offset % align == 0;\n+        if (isAligned) {\n+            return 0;\n+        } else {\n+            long gap = offset % align;\n+            return align - gap;\n+        }\n+    }\n+\n+    \/**\n+     * {@return return a struct layout constructed from the given elements, with padding\n+     * computed automatically so that they are naturally aligned}.\n+     *\n+     * @param elements the structs' fields\n+     *\/\n+    public static StructLayout computePaddedStructLayout(MemoryLayout... elements) {\n+        long offset = 0L;\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        long align = 0;\n+        for (MemoryLayout l : elements) {\n+            long padding = computePadding(offset, l.bitAlignment());\n+            if (padding != 0) {\n+                layouts.add(MemoryLayout.paddingLayout(padding));\n+                offset += padding;\n+            }\n+            layouts.add(l);\n+            align = Math.max(align, l.bitAlignment());\n+            offset += l.bitSize();\n+        }\n+        long padding = computePadding(offset, align);\n+        if (padding != 0) {\n+            layouts.add(MemoryLayout.paddingLayout(padding));\n+        }\n+        return MemoryLayout.structLayout(layouts.toArray(MemoryLayout[]::new));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -29,1 +28,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -33,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -38,0 +35,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -40,2 +38,0 @@\n-import static org.testng.Assert.*;\n-\n@@ -59,27 +55,0 @@\n-    public static void assertStructEquals(MemorySegment actual, MemorySegment expected, MemoryLayout layout) {\n-        assertEquals(actual.byteSize(), expected.byteSize());\n-        GroupLayout g = (GroupLayout) layout;\n-        for (MemoryLayout field : g.memberLayouts()) {\n-            if (field instanceof ValueLayout) {\n-                VarHandle vh = g.varHandle(MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n-                assertEquals(vh.get(actual), vh.get(expected));\n-            }\n-        }\n-    }\n-\n-    private static Class<?> vhCarrier(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                if (layout.bitSize() == 64) {\n-                    return long.class;\n-                }\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            }\n-            return double.class;\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n@@ -143,19 +112,4 @@\n-                long offset = 0L;\n-                List<MemoryLayout> layouts = new ArrayList<>();\n-                long align = 0;\n-                for (StructFieldType field : fields) {\n-                    MemoryLayout l = field.layout();\n-                    long padding = offset % l.bitAlignment();\n-                    if (padding != 0) {\n-                        layouts.add(MemoryLayout.paddingLayout(padding));\n-                        offset += padding;\n-                    }\n-                    layouts.add(l.withName(\"field\" + offset));\n-                    align = Math.max(align, l.bitAlignment());\n-                    offset += l.bitSize();\n-                }\n-                long padding = offset % align;\n-                if (padding != 0) {\n-                    layouts.add(MemoryLayout.paddingLayout(padding));\n-                }\n-                return MemoryLayout.structLayout(layouts.toArray(new MemoryLayout[0]));\n+                return Utils.computePaddedStructLayout(\n+                        IntStream.range(0, fields.size())\n+                            .mapToObj(i -> fields.get(i).layout().withName(\"f\" + i))\n+                            .toArray(MemoryLayout[]::new));\n@@ -379,73 +333,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {\n-        if (layout instanceof GroupLayout) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n-            initStruct(segment, (GroupLayout)layout, checks, check);\n-            return segment;\n-        } else if (isPointer(layout)) {\n-            MemorySegment segment = MemorySegment.allocateNative(1L, SegmentScope.auto());\n-            if (check) {\n-                checks.add(o -> {\n-                    try {\n-                        assertEquals(o, segment);\n-                    } catch (Throwable ex) {\n-                        throw new IllegalStateException(ex);\n-                    }\n-                });\n-            }\n-            return segment;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                if (check) {\n-                    checks.add(o -> assertEquals(o, 42));\n-                }\n-                return 42;\n-            } else if (layout.bitSize() == 32) {\n-                if (check) {\n-                    checks.add(o -> assertEquals(o, 12f));\n-                }\n-                return 12f;\n-            } else {\n-                if (check) {\n-                    checks.add(o -> assertEquals(o, 24d));\n-                }\n-                return 24d;\n-            }\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n-    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {\n-        for (MemoryLayout l : g.memberLayouts()) {\n-            if (l instanceof PaddingLayout) continue;\n-            VarHandle accessor = g.varHandle(MemoryLayout.PathElement.groupElement(l.name().get()));\n-            List<Consumer<Object>> fieldsCheck = new ArrayList<>();\n-            Object value = makeArg(l, fieldsCheck, check);\n-            \/\/set value\n-            accessor.set(str, value);\n-            \/\/add check\n-            if (check) {\n-                assertTrue(fieldsCheck.size() == 1);\n-                checks.add(o -> {\n-                    MemorySegment actual = (MemorySegment)o;\n-                    try {\n-                        fieldsCheck.get(0).accept(accessor.get(actual));\n-                    } catch (Throwable ex) {\n-                        throw new IllegalStateException(ex);\n-                    }\n-                });\n-            }\n-        }\n-    }\n-\n-    static Class<?> carrier(MemoryLayout layout) {\n-        if (layout instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } if (layout instanceof ValueLayout valueLayout) {\n-            return valueLayout.carrier();\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":5,"deletions":124,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -59,0 +61,1 @@\n+    private static final RandomGenerator DEFAULT_RANDOM;\n@@ -61,0 +64,5 @@\n+        int seed = Integer.getInteger(\"NativeTestHelper.DEFAULT_RANDOM.seed\", ThreadLocalRandom.current().nextInt());\n+        System.out.println(\"NativeTestHelper::DEFAULT_RANDOM.seed = \" + seed);\n+        System.out.println(\"Re-run with '-DNativeTestHelper.DEFAULT_RANDOM.seed=\" + seed + \"' to reproduce\");\n+        DEFAULT_RANDOM = new Random(seed);\n+\n@@ -118,1 +126,1 @@\n-    private static final Linker LINKER = Linker.nativeLinker();\n+    public static final Linker LINKER = Linker.nativeLinker();\n@@ -161,0 +169,4 @@\n+    public static TestValue genTestValue(MemoryLayout layout, SegmentAllocator allocator) {\n+        return genTestValue(DEFAULT_RANDOM, layout, allocator);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,2 +39,0 @@\n-    static Linker LINKER = Linker.nativeLinker();\n-\n@@ -41,2 +41,1 @@\n-        Object res = mh.invokeWithArguments(args);\n-        return res;\n+        return mh.invokeWithArguments(args);\n@@ -53,2 +52,3 @@\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n-        Object[] args = new Object[prefix.size() + params.size()];\n+    static Object[] makeArgs(Arena arena, FunctionDescriptor descriptor, List<Consumer<Object>> checks, int returnIdx) {\n+        List<MemoryLayout> argLayouts = descriptor.argumentLayouts();\n+        TestValue[] args = new TestValue[argLayouts.size()];\n@@ -56,2 +56,2 @@\n-        for (MemoryLayout layout : prefix) {\n-            args[argNum++] = makeArg(layout, null, false);\n+        for (MemoryLayout layout : argLayouts) {\n+            args[argNum++] = genTestValue(layout, arena);\n@@ -59,2 +59,3 @@\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+\n+        if (descriptor.returnLayout().isPresent()) {\n+            checks.add(args[returnIdx].check());\n@@ -62,1 +63,1 @@\n-        return args;\n+        return Stream.of(args).map(TestValue::value).toArray();\n","filename":"test\/jdk\/java\/foreign\/TestDowncallBase.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -65,1 +66,0 @@\n-        Object[] args = makeArgs(paramTypes, fields, checks);\n@@ -67,0 +67,1 @@\n+            Object[] args = makeArgs(arena, descriptor, checks);\n@@ -86,2 +87,2 @@\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n-        return makeArgs(params, fields, checks, List.of());\n+    static Object[] makeArgs(Arena arena, FunctionDescriptor descriptor, List<Consumer<Object>> checks) {\n+        return makeArgs(arena, descriptor, checks, 0);\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -37,5 +38,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -61,1 +58,0 @@\n-        Object[] args = makeArgsStack(paramTypes, fields, checks);\n@@ -63,0 +59,1 @@\n+            Object[] args = makeArgsStack(arena, descriptor, checks);\n@@ -65,1 +62,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.scope()) :\n+                    arena :\n@@ -82,2 +79,2 @@\n-    static Object[] makeArgsStack(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n-        return makeArgs(params, fields, checks, STACK_PREFIX_LAYOUTS);\n+    static Object[] makeArgsStack(Arena arena, FunctionDescriptor descriptor, List<Consumer<Object>> checks) {\n+        return makeArgs(arena, descriptor, checks, STACK_PREFIX_LAYOUTS.size());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -49,0 +50,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -61,0 +63,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -73,0 +76,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -85,0 +89,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -96,0 +101,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -107,0 +113,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -118,0 +125,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -129,0 +137,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -141,0 +150,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -153,0 +163,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -165,0 +176,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -177,0 +189,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -189,0 +202,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -201,0 +215,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -213,0 +228,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -225,0 +241,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -237,0 +254,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -249,0 +267,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -261,0 +280,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -274,0 +294,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -36,5 +37,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -44,1 +41,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -51,0 +47,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -63,1 +60,1 @@\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        List<Consumer<Object>> argChecks = new ArrayList<>();\n@@ -67,2 +64,3 @@\n-            MethodHandle mh = downcallHandle(ABI, addr, arena, descriptor);\n-            Object[] args = makeArgs(SegmentScope.auto(), ret, paramTypes, fields, returnChecks, argChecks);\n+            MethodHandle mh = downcallHandle(LINKER, addr, arena, descriptor);\n+            AtomicReference<Object[]> capturedArgs = new AtomicReference<>();\n+            Object[] args = makeArgs(capturedArgs, arena, descriptor, returnChecks, argChecks, 0);\n@@ -75,1 +73,1 @@\n-            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.scope());\n+            MemorySegment callback = LINKER.upcallStub(mh, callbackDesc, arena.scope());\n@@ -81,1 +79,1 @@\n-                    ? invoker.invoke(arena.scope(), callback)\n+                    ? invoker.invoke(arena, callback)\n@@ -83,1 +81,1 @@\n-            argChecks.forEach(c -> c.accept(args));\n+\n@@ -87,0 +85,5 @@\n+\n+            Object[] capturedArgsArr = capturedArgs.get();\n+            for (int i = 0; i < capturedArgsArr.length; i++) {\n+                argChecks.get(i).accept(capturedArgsArr[i]);\n+            }\n@@ -96,1 +99,1 @@\n-                    ABI.downcallHandle(\n+                    LINKER.downcallHandle(\n@@ -109,1 +112,1 @@\n-            return ABI.downcallHandle(invokerSymbol, desc);\n+            return LINKER.downcallHandle(invokerSymbol, desc);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -25,6 +25,2 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n+import java.lang.foreign.Arena;\n@@ -32,6 +28,0 @@\n-import org.testng.annotations.BeforeClass;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n@@ -41,0 +31,1 @@\n+import java.util.function.Function;\n@@ -44,3 +35,0 @@\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-import static org.testng.Assert.assertEquals;\n-\n@@ -49,22 +37,0 @@\n-    static Linker ABI = Linker.nativeLinker();\n-\n-    private static MethodHandle DUMMY;\n-    private static MethodHandle PASS_AND_SAVE;\n-\n-    static {\n-        try {\n-            DUMMY = MethodHandles.lookup().findStatic(TestUpcallBase.class, \"dummy\", MethodType.methodType(void.class));\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcallBase.class, \"passAndSave\",\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class, List.class));\n-        } catch (Throwable ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static MemorySegment DUMMY_STUB;\n-\n-    @BeforeClass\n-    void setup() {\n-        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n-    }\n-\n@@ -84,46 +50,13 @@\n-    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(session, ret, params, fields, checks, argChecks, List.of());\n-    }\n-\n-    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n-        Object[] args = new Object[prefix.size() + params.size() + 1];\n-        int argNum = 0;\n-        for (MemoryLayout layout : prefix) {\n-            args[argNum++] = makeArg(layout, null, false);\n-        }\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n-        }\n-        args[argNum] = makeCallback(session, ret, params, fields, checks, argChecks, prefix);\n-        return args;\n-    }\n-\n-    static MemorySegment makeCallback(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n-        if (params.isEmpty()) {\n-            return DUMMY_STUB;\n-        }\n-\n-        AtomicReference<Object[]> box = new AtomicReference<>();\n-        List<MemoryLayout> layouts = new ArrayList<>();\n-        layouts.addAll(prefix);\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            layouts.add(params.get(i).layout(fields));\n-        }\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size(), layouts);\n-        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n-\n-        for(int i = 0; i < prefix.size(); i++) {\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i))));\n-        }\n-\n-        for (int i = 0; i < params.size(); i++) {\n-            ParamType pt = params.get(i);\n-            MemoryLayout layout = pt.layout(fields);\n-            Class<?> carrier = carrier(layout);\n-            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n-\n-            final int finalI = prefix.size() + i;\n-            if (layout instanceof GroupLayout) {\n-                argChecks.add(o -> assertStructEquals((MemorySegment) box.get()[finalI], (MemorySegment) o[finalI], layout));\n-            } else {\n-                argChecks.add(o -> assertEquals(box.get()[finalI], o[finalI]));\n+    static Object[] makeArgs(AtomicReference<Object[]> capturedArgs, Arena arena, FunctionDescriptor downcallDescriptor,\n+                             List<Consumer<Object>> checks, List<Consumer<Object>> argChecks, int numPrefixArgs) {\n+        MemoryLayout[] upcallArgLayouts = downcallDescriptor.argumentLayouts()\n+                .subList(0, downcallDescriptor.argumentLayouts().size() - 1)  \/\/ drop CB layout\n+                .toArray(MemoryLayout[]::new);\n+\n+        TestValue[] args = new TestValue[upcallArgLayouts.length];\n+        for (int i = 0; i < args.length; i++) {\n+            MemoryLayout layout = upcallArgLayouts[i];\n+            TestValue testValue = genTestValue(layout, arena);\n+            args[i] = testValue;\n+            if (i >= numPrefixArgs) {\n+                argChecks.add(testValue.check());\n@@ -133,5 +66,6 @@\n-        ParamType firstParam = params.get(0);\n-        MemoryLayout firstlayout = firstParam.layout(fields);\n-        Class<?> firstCarrier = carrier(firstlayout);\n-        if (firstlayout instanceof GroupLayout) {\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n+        int returnedArgIdx;\n+        FunctionDescriptor upcallDescriptor;\n+        if (downcallDescriptor.returnLayout().isPresent()) {\n+            returnedArgIdx = numPrefixArgs;\n+            upcallDescriptor = FunctionDescriptor.of(downcallDescriptor.returnLayout().get(), upcallArgLayouts);\n+            checks.add(args[returnedArgIdx].check());\n@@ -139,1 +73,2 @@\n-            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n+            returnedArgIdx = -1;\n+            upcallDescriptor = FunctionDescriptor.ofVoid(upcallArgLayouts);\n@@ -142,24 +77,2 @@\n-        mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));\n-\n-        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n-        FunctionDescriptor func = ret != Ret.VOID\n-                ? FunctionDescriptor.of(firstlayout, paramLayouts)\n-                : FunctionDescriptor.ofVoid(paramLayouts);\n-        return ABI.upcallStub(mh, func, session);\n-    }\n-\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg, List<MemoryLayout> layouts) {\n-        for (int i = 0; i < o.length; i++) {\n-            if (layouts.get(i) instanceof GroupLayout) {\n-                MemorySegment ms = (MemorySegment) o[i];\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n-                copy.copyFrom(ms);\n-                o[i] = copy;\n-            }\n-        }\n-        ref.set(o);\n-        return o[retArg];\n-    }\n-\n-    static void dummy() {\n-        \/\/do nothing\n+        MemorySegment callback = makeArgSaverCB(upcallDescriptor, arena, capturedArgs, returnedArgIdx);\n+        return Stream.concat(Stream.of(args).map(TestValue::value), Stream.of(callback)).toArray();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":26,"deletions":113,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -36,6 +37,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -46,1 +42,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -48,1 +43,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -50,0 +44,1 @@\n+import java.util.ArrayList;\n@@ -52,2 +47,1 @@\n-\n-import static org.testng.Assert.assertEquals;\n+import java.util.function.Consumer;\n@@ -57,1 +51,0 @@\n-    static final MethodHandle MH_passAndSave;\n@@ -69,27 +62,9 @@\n-        try {\n-            System.loadLibrary(\"TestUpcallHighArity\");\n-            MH_do_upcall = LINKER.downcallHandle(\n-                    findNativeOrThrow(\"do_upcall\"),\n-                    FunctionDescriptor.ofVoid(C_POINTER,\n-                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n-                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n-                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n-                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER)\n-            );\n-            MH_passAndSave = MethodHandles.lookup().findStatic(TestUpcallHighArity.class, \"passAndSave\",\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemoryLayout> layouts) {\n-        for (int i = 0; i < o.length; i++) {\n-            if (layouts.get(i) instanceof GroupLayout) {\n-                MemorySegment ms = (MemorySegment) o[i];\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n-                copy.copyFrom(ms);\n-                o[i] = copy;\n-            }\n-        }\n-        ref.set(o);\n+        System.loadLibrary(\"TestUpcallHighArity\");\n+        MH_do_upcall = LINKER.downcallHandle(\n+                findNativeOrThrow(\"do_upcall\"),\n+                FunctionDescriptor.ofVoid(C_POINTER,\n+                S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER)\n+        );\n@@ -102,3 +77,0 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, upcallDescriptor.argumentLayouts())\n-                                         .asCollector(Object[].class, upcallType.parameterCount())\n-                                         .asType(upcallType);\n@@ -106,1 +78,0 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.scope());\n@@ -108,1 +79,1 @@\n-            args[0] = upcallStub;\n+            args[0] = makeArgSaverCB(upcallDescriptor, arena, capturedArgs, -1);\n@@ -110,0 +81,1 @@\n+            List<Consumer<Object>> checks = new ArrayList<>();\n@@ -111,1 +83,3 @@\n-                args[i] = makeArg(argLayouts.get(i - 1), null, false);\n+                TestValue testValue = genTestValue(argLayouts.get(i - 1), arena);\n+                args[i] = testValue.value();\n+                checks.add(testValue.check());\n@@ -118,5 +92,1 @@\n-                if (upcallDescriptor.argumentLayouts().get(i) instanceof GroupLayout) {\n-                    assertStructEquals((MemorySegment) capturedArgsArr[i], (MemorySegment) args[i + 1], argLayouts.get(i));\n-                } else {\n-                    assertEquals(capturedArgsArr[i], args[i + 1], \"For index \" + i);\n-                }\n+                checks.get(i).accept(capturedArgsArr[i]);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":19,"deletions":49,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -36,0 +37,1 @@\n+import java.lang.foreign.FunctionDescriptor;\n@@ -43,0 +45,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -54,1 +57,1 @@\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        List<Consumer<Object>> argChecks = new ArrayList<>();\n@@ -57,5 +60,7 @@\n-            MethodHandle mh = downcallHandle(ABI, addr, arena, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(LINKER, addr, arena, descriptor);\n+            AtomicReference<Object[]> capturedArgs = new AtomicReference<>();\n+            Object[] args = makeArgs(capturedArgs, arena, descriptor, returnChecks, argChecks, 0);\n+\n+            Object res = mh.invokeWithArguments(args);\n+\n@@ -65,0 +70,5 @@\n+\n+            Object[] capturedArgsArr = capturedArgs.get();\n+            for (int i = 0; i < capturedArgsArr.length; i++) {\n+                argChecks.get(i).accept(capturedArgsArr[i]);\n+            }\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -38,1 +39,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -45,0 +45,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -54,1 +55,2 @@\n-    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes,\n+                                 List<StructFieldType> fields) throws Throwable {\n@@ -56,1 +58,1 @@\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        List<Consumer<Object>> argChecks = new ArrayList<>();\n@@ -59,5 +61,7 @@\n-            MethodHandle mh = downcallHandle(ABI, addr, arena, functionStack(ret, paramTypes, fields));\n-            Object[] args = makeArgsStack(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n+            FunctionDescriptor descriptor = functionStack(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(LINKER, addr, arena, descriptor);\n+            AtomicReference<Object[]> capturedArgs = new AtomicReference<>();\n+            Object[] args = makeArgsStack(capturedArgs, arena, descriptor, returnChecks, argChecks);\n+\n+            Object res = mh.invokeWithArguments(args);\n+\n@@ -67,0 +71,7 @@\n+\n+            Object[] capturedArgsArr = capturedArgs.get();\n+            for (int capturedIdx = STACK_PREFIX_LAYOUTS.size(), checkIdx = 0;\n+                 capturedIdx < capturedArgsArr.length;\n+                 capturedIdx++, checkIdx++) {\n+                argChecks.get(checkIdx).accept(capturedArgsArr[capturedIdx]);\n+            }\n@@ -74,2 +85,3 @@\n-    static Object[] makeArgsStack(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(session, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n+    static Object[] makeArgsStack(AtomicReference<Object[]> capturedArgs, Arena session, FunctionDescriptor descriptor,\n+                                  List<Consumer<Object>> checks, List<Consumer<Object>> argChecks) {\n+        return makeArgs(capturedArgs, session, descriptor, checks, argChecks, STACK_PREFIX_LAYOUTS.size());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -35,1 +36,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -38,2 +38,0 @@\n-import java.lang.foreign.PaddingLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -44,0 +42,2 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SegmentScope;\n@@ -50,1 +50,0 @@\n-import java.util.function.Consumer;\n@@ -53,1 +52,0 @@\n-import static org.testng.Assert.*;\n@@ -76,2 +74,0 @@\n-        List<Arg> args = makeArgs(paramTypes, fields);\n-\n@@ -79,0 +75,1 @@\n+            List<Arg> args = makeArgs(arena, paramTypes, fields);\n@@ -81,2 +78,3 @@\n-            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.scope());;\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.scope());;\n+            MemorySegment callInfo = arena.allocate(CallInfo.LAYOUT);\n+            MemoryLayout layout = MemoryLayout.sequenceLayout(args.size(), C_INT);\n+            MemorySegment argIDs = arena.allocate(layout);\n@@ -106,1 +104,1 @@\n-            args.forEach(a -> argValues.add(a.value));\n+            args.forEach(a -> argValues.add(a.value()));\n@@ -166,1 +164,1 @@\n-    private static List<Arg> makeArgs(List<ParamType> paramTypes, List<StructFieldType> fields) throws ReflectiveOperationException {\n+    private static List<Arg> makeArgs(Arena arena, List<ParamType> paramTypes, List<StructFieldType> fields) {\n@@ -170,2 +168,1 @@\n-            List<Consumer<Object>> checks = new ArrayList<>();\n-            Object arg = makeArg(layout, checks, true);\n+            TestValue testValue = genTestValue(layout, arena);\n@@ -174,2 +171,2 @@\n-                ? Arg.structArg(type, layout, arg, checks)\n-                : Arg.primitiveArg(type, layout, arg, checks));\n+                ? Arg.structArg(type, layout, testValue)\n+                : Arg.primitiveArg(type, layout, testValue));\n@@ -184,1 +181,0 @@\n-        List<Consumer<Object>> checks = varArg.checks;\n@@ -188,1 +184,1 @@\n-            checks.forEach(check -> check.accept(obj));\n+            varArg.check(obj);\n@@ -211,0 +207,2 @@\n+        private final TestValue value;\n+\n@@ -213,1 +211,0 @@\n-        final Object value;\n@@ -215,1 +212,0 @@\n-        final List<Consumer<Object>> checks;\n@@ -217,1 +213,1 @@\n-        private Arg(NativeType id, MemoryLayout layout, Object value, MethodHandle getter, List<Consumer<Object>> checks) {\n+        private Arg(NativeType id, MemoryLayout layout, TestValue value, MethodHandle getter) {\n@@ -222,1 +218,0 @@\n-            this.checks = checks;\n@@ -225,2 +220,10 @@\n-        private static Arg primitiveArg(NativeType id, MemoryLayout layout, Object value, List<Consumer<Object>> checks) {\n-            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET), checks);\n+        private static Arg primitiveArg(NativeType id, MemoryLayout layout, TestValue value) {\n+            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET));\n+        }\n+\n+        private static Arg structArg(NativeType id, MemoryLayout layout, TestValue value) {\n+            return new Arg(id, layout, value, MethodHandles.identity(MemorySegment.class));\n+        }\n+\n+        public void check(Object actual) {\n+            value.check().accept(actual);\n@@ -229,2 +232,2 @@\n-        private static Arg structArg(NativeType id, MemoryLayout layout, Object value, List<Consumer<Object>> checks) {\n-            return new Arg(id, layout, value, MethodHandles.identity(MemorySegment.class), checks);\n+        public Object value() {\n+            return value.value();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":28,"deletions":25,"binary":false,"changes":53,"status":"modified"}]}