{"files":[{"patch":"@@ -223,8 +223,0 @@\n-    public static void releaseByteBuffer(ByteBuffer buffer) {\n-        Objects.requireNonNull(buffer);\n-\n-        if (!MAP_ALL) {\n-            ImageBufferCache.releaseBuffer(buffer);\n-        }\n-    }\n-\n@@ -380,1 +372,1 @@\n-            ByteBuffer buffer = ImageBufferCache.getBuffer(size);\n+            ByteBuffer buffer = allocateBuffer(size);\n@@ -386,1 +378,0 @@\n-                ImageBufferCache.releaseBuffer(buffer);\n@@ -391,1 +382,0 @@\n-                ImageBufferCache.releaseBuffer(buffer);\n@@ -400,0 +390,9 @@\n+    private static ByteBuffer allocateBuffer(long size) {\n+        if (size < 0 || Integer.MAX_VALUE < size) {\n+            throw new IndexOutOfBoundsException(\"size\");\n+        }\n+        ByteBuffer result = ByteBuffer.allocateDirect((int) ((size + 0xFFF) & ~0xFFF));\n+        result.limit((int) size);\n+        return result;\n+    }\n+\n@@ -409,9 +408,1 @@\n-\n-        if (buffer != null) {\n-            byte[] bytes = getBufferBytes(buffer);\n-            ImageBufferCache.releaseBuffer(buffer);\n-\n-            return bytes;\n-        }\n-\n-        return null;\n+        return buffer != null ? getBufferBytes(buffer) : null;\n@@ -420,0 +411,3 @@\n+    \/**\n+     * Returns the content of jimage location in a newly allocated byte buffer.\n+     *\/\n@@ -440,1 +434,0 @@\n-\n@@ -443,1 +436,0 @@\n-                ImageBufferCache.releaseBuffer(buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":14,"deletions":22,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jimage;\n-\n-import java.lang.ref.WeakReference;\n-import java.nio.ByteBuffer;\n-import java.util.AbstractMap;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.Map;\n-\n-\/**\n- * @implNote This class needs to maintain JDK 8 source compatibility.\n- *\n- * It is used internally in the JDK to implement jimage\/jrtfs access,\n- * but also compiled and delivered as part of the jrt-fs.jar to support access\n- * to the jimage file provided by the shipped JDK by tools running on JDK 8.\n- *\/\n-class ImageBufferCache {\n-    private static final int MAX_CACHED_BUFFERS = 3;\n-    private static final int LARGE_BUFFER = 0x10000;\n-\n-    \/*\n-     * We used to have a class BufferReference extending from WeakReference<ByteBuffer>.\n-     * BufferReference class had an  instance field called \"capacity\". This field was\n-     * used to make DECREASING_CAPACITY_NULLS_LAST comparator stable in the presence\n-     * of GC clearing the WeakReference concurrently.\n-     *\n-     * But this scheme results in metaspace leak. The thread local is alive till the\n-     * the thread is alive. And so ImageBufferCache$BufferReference class was kept alive.\n-     * Because this class and ImageBufferCache$BufferReference are all loaded by a URL\n-     * class loader from jrt-fs.jar, the class loader and so all the classes loaded by it\n-     * were alive!\n-     *\n-     * Solution is to avoid using a URL loader loaded class type with thread local. All we\n-     * need is a pair of WeakReference<ByteBuffer>, Integer (saved capacity for stability\n-     * of comparator). We use Map.Entry as pair implementation. With this, all types used\n-     * with thread local are bootstrap types and so no metaspace leak.\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private static final ThreadLocal<Map.Entry<WeakReference<ByteBuffer>, Integer>[]> CACHE =\n-        new ThreadLocal<Map.Entry<WeakReference<ByteBuffer>, Integer>[]>() {\n-            @Override\n-            protected Map.Entry<WeakReference<ByteBuffer>, Integer>[] initialValue() {\n-                \/\/ 1 extra slot to simplify logic of releaseBuffer()\n-                return (Map.Entry<WeakReference<ByteBuffer>, Integer>[])new Map.Entry<?,?>[MAX_CACHED_BUFFERS + 1];\n-            }\n-        };\n-\n-    private static ByteBuffer allocateBuffer(long size) {\n-        return ByteBuffer.allocateDirect((int)((size + 0xFFF) & ~0xFFF));\n-    }\n-\n-    static ByteBuffer getBuffer(long size) {\n-        if (size < 0 || Integer.MAX_VALUE < size) {\n-            throw new IndexOutOfBoundsException(\"size\");\n-        }\n-\n-        ByteBuffer result = null;\n-\n-        if (size > LARGE_BUFFER) {\n-            result = allocateBuffer(size);\n-        } else {\n-            Map.Entry<WeakReference<ByteBuffer>, Integer>[] cache = CACHE.get();\n-\n-            \/\/ buffers are ordered by decreasing capacity\n-            \/\/ cache[MAX_CACHED_BUFFERS] is always null\n-            for (int i = MAX_CACHED_BUFFERS - 1; i >= 0; i--) {\n-                Map.Entry<WeakReference<ByteBuffer>, Integer> reference = cache[i];\n-\n-                if (reference != null) {\n-                    ByteBuffer buffer = getByteBuffer(reference);\n-\n-                    if (buffer != null && size <= buffer.capacity()) {\n-                        cache[i] = null;\n-                        result = buffer;\n-                        result.rewind();\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            if (result == null) {\n-                result = allocateBuffer(size);\n-            }\n-        }\n-\n-        result.limit((int)size);\n-\n-        return result;\n-    }\n-\n-    static void releaseBuffer(ByteBuffer buffer) {\n-        if (buffer.capacity() > LARGE_BUFFER) {\n-            return;\n-        }\n-\n-        Map.Entry<WeakReference<ByteBuffer>, Integer>[] cache = CACHE.get();\n-\n-        \/\/ expunge cleared BufferRef(s)\n-        for (int i = 0; i < MAX_CACHED_BUFFERS; i++) {\n-            Map.Entry<WeakReference<ByteBuffer>, Integer> reference = cache[i];\n-            if (reference != null && getByteBuffer(reference) == null) {\n-                cache[i] = null;\n-            }\n-        }\n-\n-        \/\/ insert buffer back with new BufferRef wrapping it\n-        cache[MAX_CACHED_BUFFERS] = newCacheEntry(buffer);\n-        Arrays.sort(cache, DECREASING_CAPACITY_NULLS_LAST);\n-        \/\/ squeeze the smallest one out\n-        cache[MAX_CACHED_BUFFERS] = null;\n-    }\n-\n-    private static Map.Entry<WeakReference<ByteBuffer>, Integer> newCacheEntry(ByteBuffer bb) {\n-        return new AbstractMap.SimpleEntry<WeakReference<ByteBuffer>, Integer>(\n-                    new WeakReference<ByteBuffer>(bb), bb.capacity());\n-    }\n-\n-    private static int getCapacity(Map.Entry<WeakReference<ByteBuffer>, Integer> e) {\n-        return e == null? 0 : e.getValue();\n-    }\n-\n-    private static ByteBuffer getByteBuffer(Map.Entry<WeakReference<ByteBuffer>, Integer> e) {\n-        return e == null? null : e.getKey().get();\n-    }\n-\n-    private static Comparator<Map.Entry<WeakReference<ByteBuffer>, Integer>> DECREASING_CAPACITY_NULLS_LAST =\n-        new Comparator<Map.Entry<WeakReference<ByteBuffer>, Integer>>() {\n-            @Override\n-            public int compare(Map.Entry<WeakReference<ByteBuffer>, Integer> br1,\n-                        Map.Entry<WeakReference<ByteBuffer>, Integer> br2) {\n-                return Integer.compare(getCapacity(br1), getCapacity(br2));\n-            }\n-        };\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageBufferCache.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -193,14 +193,1 @@\n-     * Releases a (possibly cached) {@link ByteBuffer} obtained via\n-     * {@link #getResourceBuffer(Node)}.\n-     *\n-     * <p>Note that no testing is performed to check whether the buffer about\n-     * to be released actually came from a call to {@code getResourceBuffer()}.\n-     *\/\n-    public static void releaseByteBuffer(ByteBuffer buffer) {\n-        BasicImageReader.releaseByteBuffer(buffer);\n-    }\n-\n-    \/**\n-     * Returns the content of a resource node in a possibly cached byte buffer.\n-     * Callers of this method must call {@link #releaseByteBuffer(ByteBuffer)}\n-     * when they are finished with it.\n+     * Returns the content of a resource node in a newly allocated byte buffer.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -468,6 +468,0 @@\n-        }\n-\n-        @Override\n-        public void release(ByteBuffer bb) {\n-            Objects.requireNonNull(bb);\n-            ImageReader.releaseByteBuffer(bb);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}