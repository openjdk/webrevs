{"files":[{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  template(jdk_jfr_internal_event_EventWriterFactory,                 \"jdk\/jfr\/internal\/event\/EventWriterFactory\")   \\\n+  template(jdk_jfr_internal_event_EventWriter,                        \"jdk\/jfr\/internal\/event\/EventWriter\")   \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,1 +185,1 @@\n-static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)'\";\n+static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriter.getEventWriter()'\";\n@@ -202,3 +202,3 @@\n-  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n-  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n-  if (info.resolved_klass()->name() != event_writer_factory_klass_name) {\n+  static const Symbol* const event_writer_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriter();\n+  assert(event_writer_klass_name != nullptr, \"invariant\");\n+  if (info.resolved_klass()->name() != event_writer_klass_name) {\n@@ -207,1 +207,1 @@\n-  \/\/ Attempting to link against jdk.jfr.internal.event.EventWriterFactory.getEventWriter().\n+  \/\/ Attempting to link against jdk.jfr.internal.event.EventWriter.getEventWriter().\n@@ -231,3 +231,3 @@\n-  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n-  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n-  if (holder != event_writer_factory_klass_name) {\n+  static const Symbol* const event_writer_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriter();\n+  assert(event_writer_klass_name != nullptr, \"invariant\");\n+  if (holder != event_writer_klass_name) {\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -118,1 +117,0 @@\n-        SecuritySupport.checkRegisterPermission();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -102,2 +101,0 @@\n-        SecuritySupport.checkRegisterPermission();\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -47,1 +45,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -160,1 +157,0 @@\n-            SecuritySupport.checkAccessFlightRecorder();\n@@ -216,4 +212,1 @@\n-        SecuritySupport.checkRegisterPermission();\n-        @SuppressWarnings(\"removal\")\n-        AccessControlContext acc = AccessController.getContext();\n-        PeriodicEvents.addUserEvent(acc, eventClass, hook);\n+        PeriodicEvents.addJavaEvent(eventClass, hook);\n@@ -230,1 +223,0 @@\n-        SecuritySupport.checkRegisterPermission();\n@@ -263,1 +255,0 @@\n-        SecuritySupport.checkAccessFlightRecorder();\n@@ -283,1 +274,0 @@\n-        SecuritySupport.checkAccessFlightRecorder();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorder.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.AccessControlContext;\n@@ -37,1 +36,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -159,6 +157,0 @@\n-        @SuppressWarnings(\"removal\")\n-        @Override\n-        public AccessControlContext getContext(SettingControl settingControl) {\n-            return settingControl.getContext();\n-        }\n-\n@@ -187,1 +179,1 @@\n-        if (!name.equals(SecuritySupport.ACCESS_FLIGHT_RECORDER) && !name.equals(SecuritySupport.REGISTER_EVENT)) {\n+        if (!name.equals(\"accessFlightRecorder\") && !name.equals(\"registerEvent\")) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderPermission.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-import jdk.jfr.internal.WriteableUserPath;\n+import jdk.jfr.internal.WriteablePath;\n@@ -371,1 +371,1 @@\n-        internal.dump(new WriteableUserPath(destination));\n+        internal.dump(new WriteablePath(destination));\n@@ -464,1 +464,1 @@\n-        internal.setDestination(destination != null ? new WriteableUserPath(destination) : null);\n+        internal.setDestination(destination != null ? new WriteablePath(destination) : null);\n@@ -474,2 +474,2 @@\n-        WriteableUserPath usp = internal.getDestination();\n-        if (usp == null) {\n+        WriteablePath wp = internal.getDestination();\n+        if (wp == null) {\n@@ -478,1 +478,1 @@\n-            return usp.getPotentiallyMaliciousOriginal();\n+            return wp.getPath();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -32,2 +30,0 @@\n-import jdk.jfr.internal.settings.JDKSettingControl;\n-\n@@ -80,4 +76,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext context;\n-    private final boolean initialized;\n-\n@@ -87,1 +79,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -89,15 +80,0 @@\n-        context = this instanceof JDKSettingControl ? null : AccessController.getContext();\n-        initialized = true;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    final AccessControlContext getContext() {\n-        \/\/ Ensure object state is safe\n-        if (!initialized) {\n-            throw new InternalError(\"Object must be initialized before security context can be retrieved\");\n-        }\n-        AccessControlContext c = this.context;\n-        if (c == null && !(this instanceof JDKSettingControl)) {\n-            throw new InternalError(\"Security context can only be null for trusted setting controls\");\n-        }\n-        return c;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/SettingControl.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -146,1 +145,0 @@\n-        SecuritySupport.checkRegisterPermission();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/ValueDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -38,1 +36,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -41,1 +38,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -116,1 +112,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -118,1 +113,0 @@\n-        SecuritySupport.checkAccessFlightRecorder();\n@@ -120,1 +114,0 @@\n-            AccessController.getContext(),\n@@ -122,1 +115,0 @@\n-            SecuritySupport.PRIVILEGED,\n@@ -146,2 +138,0 @@\n-        @SuppressWarnings(\"removal\")\n-        AccessControlContext acc = AccessController.getContext();\n@@ -149,1 +139,0 @@\n-            acc,\n@@ -151,1 +140,0 @@\n-            FileAccess.UNPRIVILEGED,\n@@ -172,1 +160,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -175,1 +162,1 @@\n-        return new EventFileStream(AccessController.getContext(), file);\n+        return new EventFileStream(file);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -84,1 +83,1 @@\n-        this.input = new RecordingInput(this.file, FileAccess.UNPRIVILEGED);\n+        this.input = new RecordingInput(this.file);\n@@ -149,1 +148,1 @@\n-        try (RecordingInput ri = new RecordingInput(file, FileAccess.UNPRIVILEGED)) {\n+        try (RecordingInput ri = new RecordingInput(file)) {\n@@ -165,1 +164,1 @@\n-        try (RecordingInput ri = new RecordingInput(file, FileAccess.UNPRIVILEGED)) {\n+        try (RecordingInput ri = new RecordingInput(file)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -48,1 +46,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -101,3 +98,0 @@\n-        SecuritySupport.checkAccessFlightRecorder();\n-        @SuppressWarnings(\"removal\")\n-        AccessControlContext acc = AccessController.getContext();\n@@ -110,1 +104,0 @@\n-                acc,\n@@ -112,1 +105,0 @@\n-                SecuritySupport.PRIVILEGED,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.file.Files;\n@@ -68,1 +69,1 @@\n-        stream = new BufferedInputStream(SecuritySupport.newFileInputStream(currentChunk.getFile()));\n+        stream = new BufferedInputStream(Files.newInputStream(currentChunk.getFile()));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ChunkInputStream.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Collections;\n@@ -37,1 +33,0 @@\n-import jdk.jfr.internal.settings.JDKSettingControl;\n@@ -43,2 +38,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext context;\n@@ -54,1 +47,0 @@\n-        this.context = PrivateAccess.getInstance().getContext(delegate);\n@@ -57,3 +49,0 @@\n-        if (this.context == null && !(delegate instanceof JDKSettingControl)) {\n-            throw new InternalError(\"Security context can only be null for trusted setting controls\");\n-        }\n@@ -77,1 +66,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -79,17 +67,1 @@\n-        if (context == null) {\n-            \/\/ VM events requires no access control context\n-            return delegate.getValue();\n-        } else {\n-            return AccessController.doPrivileged(new PrivilegedAction<String>() {\n-                @Override\n-                public String run() {\n-                    try {\n-                        return delegate.getValue();\n-                    } catch (Throwable t) {\n-                        \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                        Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, \"Exception occurred when trying to get value for \" + getClass());\n-                    }\n-                    return defaultValue != null ? defaultValue : \"\"; \/\/ Need to return something\n-                }\n-            }, context);\n-        }\n+        return delegate.getValue();\n@@ -105,1 +77,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -107,23 +78,6 @@\n-        if (context == null) {\n-            \/\/ VM events requires no access control context\n-            try {\n-                delegate.setValue(value);\n-                lastValue = delegate.getValue();\n-            } catch (Throwable t) {\n-                Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, \"Exception occurred when setting value \\\"\" + value + \"\\\" for \" + getClass());\n-                lastValue = null;\n-            }\n-        } else {\n-            lastValue = AccessController.doPrivileged(new PrivilegedAction<String>() {\n-                @Override\n-                public String run() {\n-                    try {\n-                        delegate.setValue(value);\n-                        return delegate.getValue();\n-                    } catch (Throwable t) {\n-                        \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                        Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, \"Exception occurred when setting value \\\"\" + value + \"\\\" for \" + getClass());\n-                    }\n-                    return null;\n-                }\n-            }, context);\n+        try {\n+            delegate.setValue(value);\n+            lastValue = delegate.getValue();\n+        } catch (Throwable t) {\n+            Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, \"Exception occurred when setting value \\\"\" + value + \"\\\". \" + t.getMessage());\n+            lastValue = null;\n@@ -133,2 +87,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n@@ -136,16 +88,1 @@\n-        if (context == null) {\n-            \/\/ VM events requires no access control context\n-            return delegate.combine(values);\n-        }\n-        return AccessController.doPrivileged(new PrivilegedAction<String>() {\n-            @Override\n-            public String run() {\n-                try {\n-                    return delegate.combine(Collections.unmodifiableSet(values));\n-                } catch (Throwable t) {\n-                    \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                    Logger.log(LogTag.JFR_SETTING, LogLevel.WARN, \"Exception occurred when combining \" + values + \" for \" + getClass());\n-                }\n-                return null;\n-            }\n-        }, context);\n+        return delegate.combine(values);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":9,"deletions":72,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,1 @@\n-        SecuritySupport.setAccessible(cc);\n+        cc.setAccessible(true);\n@@ -376,7 +376,0 @@\n-    \/**\n-     * A malicious user must never be able to run a callback in the wrong\n-     * context. Methods on SettingControl must therefore never be invoked directly\n-     * by JFR, instead use jdk.jfr.internal.Control.\n-     *\n-     * The returned list is only to be used inside EventConfiguration\n-     *\/\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-    private static final ClassDesc TYPE_EVENT_WRITER_FACTORY = ClassDesc.of(\"jdk.jfr.internal.event.EventWriterFactory\");\n@@ -103,1 +102,1 @@\n-    private static final MethodDesc METHOD_GET_EVENT_WRITER_KEY = MethodDesc.of(\"getEventWriter\", \"(J)\" + TYPE_EVENT_WRITER.descriptorString());\n+    private static final MethodDesc METHOD_GET_EVENT_WRITER = MethodDesc.of(\"getEventWriter\", \"()\" + TYPE_EVENT_WRITER.descriptorString());\n@@ -770,2 +769,1 @@\n-        codeBuilder.ldc(EventWriterKey.getKey());\n-        invokestatic(codeBuilder, TYPE_EVENT_WRITER_FACTORY, METHOD_GET_EVENT_WRITER_KEY);\n+        invokestatic(codeBuilder, TYPE_EVENT_WRITER, METHOD_GET_EVENT_WRITER);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal;\n-\n-import jdk.jfr.internal.event.EventWriter;\n-\n-\/\/ This class is not directly used but renamed to\n-\/\/ jdk.jfr.internal.event.EventWriterFactory and loaded dynamically\n-\/\/ when the first event class is bytecode instrumented.\n-\/\/ See JVMUpcalls and EventWriterKey::ensureEventWriterFactory()\n-public final class EventWriterFactoryRecipe {\n-    private static final long KEY = EventWriterKey.getKey();\n-\n-    public static EventWriter getEventWriter(long key) {\n-        if (key == KEY) {\n-            EventWriter ew = JVM.getEventWriter();\n-            return ew != null ? ew : JVM.newEventWriter();\n-        }\n-        EventWriterKey.block();\n-        return null; \/\/ Can't reach here.\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterFactoryRecipe.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -33,2 +35,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n-\n@@ -39,1 +39,1 @@\n-    private static final SequencedSet<SafePath> paths = new LinkedHashSet<>();\n+    private static final SequencedSet<Path> paths = new LinkedHashSet<>();\n@@ -41,1 +41,1 @@\n-    public static synchronized void add(SafePath p) {\n+    public static synchronized void add(Path p) {\n@@ -53,1 +53,1 @@\n-        for (SafePath p : new ArrayList<>(paths)) {\n+        for (Path p : new ArrayList<>(paths)) {\n@@ -64,7 +64,3 @@\n-    private static boolean delete(SafePath p) {\n-        try {\n-            if (!SecuritySupport.exists(p)) {\n-                return true;\n-            }\n-        } catch (IOException e) {\n-            \/\/ ignore\n+    private static boolean delete(Path p) {\n+        if (!Files.exists(p)) {\n+            return true;\n@@ -73,1 +69,1 @@\n-            SecuritySupport.delete(p);\n+            Files.delete(p);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/FilePurger.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-                    SecuritySupport.registerEvent((Class<? extends Event>) eventClass);\n+                    MetadataRepository.getInstance().register((Class<? extends Event>) eventClass);\n@@ -96,3 +96,3 @@\n-                PeriodicEvents.addJDKEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);\n-                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n-                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n+                PeriodicEvents.addJavaEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);\n+                PeriodicEvents.addJavaEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n+                PeriodicEvents.addJavaEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n@@ -119,5 +119,5 @@\n-        SecuritySupport.registerEvent(ContainerConfigurationEvent.class);\n-        SecuritySupport.registerEvent(ContainerCPUUsageEvent.class);\n-        SecuritySupport.registerEvent(ContainerCPUThrottlingEvent.class);\n-        SecuritySupport.registerEvent(ContainerMemoryUsageEvent.class);\n-        SecuritySupport.registerEvent(ContainerIOUsageEvent.class);\n+        registerEvent(ContainerConfigurationEvent.class);\n+        registerEvent(ContainerCPUUsageEvent.class);\n+        registerEvent(ContainerCPUThrottlingEvent.class);\n+        registerEvent(ContainerMemoryUsageEvent.class);\n+        registerEvent(ContainerIOUsageEvent.class);\n@@ -125,5 +125,9 @@\n-        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n-        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n-        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n-        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n-        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n+        PeriodicEvents.addJavaEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n+        PeriodicEvents.addJavaEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n+        PeriodicEvents.addJavaEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n+        PeriodicEvents.addJavaEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n+        PeriodicEvents.addJavaEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n+    }\n+\n+    private static void registerEvent(Class<? extends jdk.internal.event.Event> eventClass) {\n+        MetadataRepository.getInstance().register(eventClass);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JDKEvents.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-            if (SecuritySupport.getBooleanProperty(\"jfr.unsupported.vm\")) {\n+            if (Boolean.getBoolean(\"jfr.unsupported.vm\")) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,0 @@\n-                EventWriterKey.ensureEventWriterFactory();\n@@ -127,1 +126,0 @@\n-            EventWriterKey.ensureEventWriterFactory();\n@@ -158,1 +156,3 @@\n-        return SecuritySupport.createRecorderThread(systemThreadGroup, contextClassLoader);\n+        Thread thread = new Thread(systemThreadGroup, \"JFR Recorder Thread\");\n+        thread.setContextClassLoader(contextClassLoader);\n+        return thread;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,1 +194,1 @@\n-                SecuritySupport.getResourceAsStream(\"\/jdk\/jfr\/internal\/types\/metadata.bin\"))) {\n+                MetadataLoader.class.getResourceAsStream(\"\/jdk\/jfr\/internal\/types\/metadata.bin\"))) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,0 @@\n-        SecuritySupport.checkRegisterPermission();\n@@ -138,1 +137,0 @@\n-        SecuritySupport.checkRegisterPermission();\n@@ -189,1 +187,1 @@\n-                SecuritySupport.setAccessible(c);\n+                c.setAccessible(true);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -30,1 +32,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -53,1 +54,1 @@\n-    private static final SafePath DEFAULT_DUMP_PATH = null;\n+    private static final Path DEFAULT_DUMP_PATH = null;\n@@ -118,1 +119,1 @@\n-    public static synchronized void setDumpPath(SafePath path) throws IOException {\n+    public static synchronized void setDumpPath(Path path) throws IOException {\n@@ -120,2 +121,2 @@\n-            if (SecuritySupport.isWritable(path)) {\n-                path = SecuritySupport.toRealPath(path, NOFOLLOW_LINKS);\n+            if (Files.isWritable(path)) {\n+                path = path.toRealPath(NOFOLLOW_LINKS);\n@@ -129,2 +130,2 @@\n-    public static synchronized SafePath getDumpPath() {\n-        return new SafePath(JVM.getDumpPath());\n+    public static synchronized Path getDumpPath() {\n+        return Path.of(JVM.getDumpPath());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Options.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n+import java.nio.file.Path;\n@@ -49,1 +48,0 @@\n-import java.util.concurrent.CopyOnWriteArrayList;\n@@ -57,2 +55,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n-import jdk.jfr.internal.SecuritySupport.SecureRecorderListener;\n@@ -67,1 +63,1 @@\n-    private static final List<SecureRecorderListener> changeListeners = new ArrayList<>();\n+    private static final List<FlightRecorderListener> changeListeners = new ArrayList<>();\n@@ -86,19 +82,3 @@\n-        shutdownHook = SecuritySupport.createThreadWitNoPermissions(\"JFR Shutdown Hook\", new ShutdownHook(this));\n-        SecuritySupport.setUncaughtExceptionHandler(shutdownHook, new ShutdownHook.ExceptionHandler());\n-        SecuritySupport.registerShutdownHook(shutdownHook);\n-    }\n-\n-\n-    private static Timer createTimer() {\n-        try {\n-            List<Timer> result = new CopyOnWriteArrayList<>();\n-            Thread t = SecuritySupport.createThreadWitNoPermissions(\"Permissionless thread\", ()-> {\n-                result.add(new Timer(\"JFR Recording Scheduler\", true));\n-            });\n-            JVM.exclude(t);\n-            t.start();\n-            t.join();\n-            return result.getFirst();\n-        } catch (InterruptedException e) {\n-            throw new IllegalStateException(\"Not able to create timer task. \" + e.getMessage(), e);\n-        }\n+        shutdownHook = new ShutdownHook(this);\n+        shutdownHook.setUncaughtExceptionHandler(new ShutdownHook.ExceptionHandler());\n+        Runtime.getRuntime().addShutdownHook(shutdownHook);\n@@ -141,3 +121,0 @@\n-        @SuppressWarnings(\"removal\")\n-        AccessControlContext context = AccessController.getContext();\n-        SecureRecorderListener sl = new SecureRecorderListener(context, changeListener);\n@@ -147,1 +124,1 @@\n-            changeListeners.add(sl);\n+            changeListeners.add(changeListener);\n@@ -150,1 +127,1 @@\n-            sl.recorderInitialized(FlightRecorder.getFlightRecorder());\n+            changeListener.recorderInitialized(FlightRecorder.getFlightRecorder());\n@@ -155,7 +132,1 @@\n-        for (SecureRecorderListener s : new ArrayList<>(changeListeners)) {\n-            if (s.getChangeListener() == changeListener) {\n-                changeListeners.remove(s);\n-                return true;\n-            }\n-        }\n-        return false;\n+        return changeListeners.remove(changeListener);\n@@ -170,1 +141,1 @@\n-            timer = createTimer();\n+            timer = new Timer(\"JFR Recording Scheduler\", true);\n@@ -369,1 +340,1 @@\n-        WriteableUserPath dest = recording.getDestination();\n+        WriteablePath dest = recording.getDestination();\n@@ -444,2 +415,2 @@\n-        Thread t = SecuritySupport.createThreadWitNoPermissions(\"JFR Periodic Tasks\", () -> periodicTask());\n-        SecuritySupport.setDaemonThread(t, true);\n+        Thread t = new Thread(() -> periodicTask(), \"JFR Periodic Tasks\");\n+        t.setDaemon(true);\n@@ -475,1 +446,1 @@\n-                    WriteableUserPath path = r.getDestination();\n+                    WriteablePath path = r.getDestination();\n@@ -522,1 +493,1 @@\n-                Logger.log(JFR_SYSTEM, ERROR, \"Error in Periodic task: \" + t.getClass().getName());\n+                Logger.log(JFR_SYSTEM, WARN, \"Error in Periodic task: \" + t.getMessage());\n@@ -663,1 +634,1 @@\n-    public synchronized void migrate(SafePath repo) throws IOException {\n+    public synchronized void migrate(Path repo) throws IOException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.nio.file.Path;\n@@ -39,4 +40,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -62,1 +59,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -76,1 +72,1 @@\n-    private WriteableUserPath destination;\n+    private WriteablePath destination;\n@@ -81,1 +77,1 @@\n-    private SafePath dumpDirectory;\n+    private Path dumpDirectory;\n@@ -93,2 +89,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext dumpDirectoryControlContext;\n@@ -102,7 +96,0 @@\n-        \/\/ Typically the access control context is taken\n-        \/\/ when you call dump(Path) or setDestination(Path),\n-        \/\/ but if no destination is set and the filename is auto-generated,\n-        \/\/ the control context of the recording is taken when the\n-        \/\/ Recording object is constructed. This works well for\n-        \/\/ -XX:StartFlightRecording and JFR.dump\n-        this.dumpDirectoryControlContext = AccessController.getContext();\n@@ -178,1 +165,1 @@\n-        WriteableUserPath dest = getDestination();\n+        WriteablePath dest = getDestination();\n@@ -198,2 +185,1 @@\n-    @SuppressWarnings(\"removal\")\n-    public WriteableUserPath makeDumpPath() {\n+    public WriteablePath makeDumpPath() {\n@@ -202,17 +188,3 @@\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<WriteableUserPath>() {\n-                @Override\n-                public WriteableUserPath run() throws Exception {\n-                    SafePath p = dumpDirectory;\n-                    if (p == null) {\n-                        p = new SafePath(\".\");\n-                    }\n-                    return new WriteableUserPath(p.toPath().resolve(name));\n-                }\n-            }, dumpDirectoryControlContext);\n-        } catch (PrivilegedActionException e) {\n-            Throwable t = e.getCause();\n-            if (t instanceof SecurityException) {\n-                Logger.log(LogTag.JFR, LogLevel.WARN, \"Not allowed to create dump path for recording \" + recording.getId() + \" on exit.\");\n-            }\n-            if (t instanceof IOException) {\n-                Logger.log(LogTag.JFR, LogLevel.WARN, \"Could not dump \" + recording.getId() + \" on exit.\");\n+            Path p = dumpDirectory;\n+            if (p == null) {\n+                p = Path.of(\".\");\n@@ -220,1 +192,3 @@\n-            return null;\n+            return new WriteablePath(p.resolve(name));\n+        } catch (IOException e) {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"Could not dump \" + recording.getId() + \" on exit. \" + e.getMessage());\n@@ -222,0 +196,1 @@\n+        return null;\n@@ -425,1 +400,1 @@\n-    public void setDestination(WriteableUserPath userSuppliedPath) throws IOException {\n+    public void setDestination(WriteablePath destination) throws IOException {\n@@ -427,2 +402,2 @@\n-            checkSetDestination(userSuppliedPath);\n-            this.destination = userSuppliedPath;\n+            checkSetDestination(destination);\n+            this.destination = destination;\n@@ -432,1 +407,3 @@\n-    public void checkSetDestination(WriteableUserPath userSuppliedPath) throws IOException {\n+    public void checkSetDestination(WriteablePath writeablePath) throws IOException {\n+        \/\/ The writeablePath argument is not checked. It's sufficient that an instance has\n+        \/\/ been created.\n@@ -440,1 +417,1 @@\n-    public WriteableUserPath getDestination() {\n+    public WriteablePath getDestination() {\n@@ -710,2 +687,1 @@\n-                    \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                    Logger.log(LogTag.JFR, LogLevel.ERROR, \"Could not stop recording.\");\n+                    Logger.log(LogTag.JFR, LogLevel.ERROR, \"Could not stop recording. \" + t.getMessage());\n@@ -740,1 +716,1 @@\n-    public void dump(WriteableUserPath writeableUserPath) throws IOException {\n+    public void dump(WriteablePath writeablePath) throws IOException {\n@@ -743,1 +719,1 @@\n-                p.dumpStopped(writeableUserPath);\n+                p.dumpStopped(writeablePath);\n@@ -748,1 +724,1 @@\n-    public void dumpStopped(WriteableUserPath userPath) throws IOException {\n+    public void dumpStopped(WriteablePath path) throws IOException {\n@@ -750,1 +726,1 @@\n-            transferChunksWithRetry(userPath);\n+            transferChunksWithRetry(path);\n@@ -754,13 +730,10 @@\n-    private void transferChunksWithRetry(WriteableUserPath userPath) throws IOException {\n-        userPath.doPrivilegedIO(() -> {\n-            try {\n-                transferChunks(userPath);\n-            } catch (NoSuchFileException nsfe) {\n-                Logger.log(LogTag.JFR, LogLevel.ERROR, \"Missing chunkfile when writing recording \\\"\" + name + \"\\\" (\" + id + \") to \" + userPath.getRealPathText() + \".\");\n-                \/\/ if one chunkfile was missing, its likely more are missing\n-                removeNonExistantPaths();\n-                \/\/ and try the transfer again\n-                transferChunks(userPath);\n-            }\n-            return null;\n-        });\n+    private void transferChunksWithRetry(WriteablePath path) throws IOException {\n+        try {\n+            transferChunks(path);\n+        } catch (NoSuchFileException nsfe) {\n+            Logger.log(LogTag.JFR, LogLevel.ERROR, \"Missing chunkfile when writing recording \\\"\" + name + \"\\\" (\" + id + \") to \" + path.getRealPathText() + \".\");\n+            \/\/ if one chunkfile was missing, its likely more are missing\n+            removeNonExistantPaths();\n+            \/\/ and try the transfer again\n+            transferChunks(path);\n+        }\n@@ -769,2 +742,2 @@\n-    private void transferChunks(WriteableUserPath userPath) throws IOException {\n-        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(userPath.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n+    private void transferChunks(WriteablePath path) throws IOException {\n+        try (ChunksChannel cc = new ChunksChannel(chunks); FileChannel fc = FileChannel.open(path.getReal(), StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {\n@@ -862,1 +835,1 @@\n-    public void setDumpDirectory(SafePath directory) {\n+    public void setDumpDirectory(Path directory) {\n@@ -916,1 +889,1 @@\n-    public void removePath(SafePath path) {\n+    public void removePath(Path path) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":39,"deletions":66,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.AccessControlContext;\n@@ -38,1 +37,0 @@\n-import jdk.jfr.SettingControl;\n@@ -63,1 +61,1 @@\n-            new FlightRecorderPermission(SecuritySupport.REGISTER_EVENT);\n+            new FlightRecorderPermission(\"accessFlightRecorder\");\n@@ -102,3 +100,0 @@\n-    @SuppressWarnings(\"removal\")\n-    public abstract AccessControlContext getContext(SettingControl sc);\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PrivateAccess.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.file.Files;\n@@ -36,1 +37,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -39,0 +39,2 @@\n+import jdk.jfr.internal.util.DirectoryCleaner;\n+import jdk.jfr.internal.util.Utils;\n@@ -42,0 +44,1 @@\n+    private static final Path JAVA_IO_TMPDIR = Utils.getPathInProperty(\"java.io.tmpdir\", null);\n@@ -44,1 +47,0 @@\n-\n@@ -46,4 +48,3 @@\n-\n-    private final Set<SafePath> cleanupDirectories = new HashSet<>();\n-    private SafePath baseLocation;\n-    private SafePath repository;\n+    private final Set<Path> cleanupDirectories = new HashSet<>();\n+    private Path baseLocation;\n+    private Path repository;\n@@ -59,1 +60,1 @@\n-    public synchronized void setBasePath(SafePath baseLocation) throws IOException {\n+    public synchronized void setBasePath(Path baseLocation) throws IOException {\n@@ -71,1 +72,1 @@\n-            SecuritySupport.delete(repository);\n+            Files.delete(repository);\n@@ -80,1 +81,1 @@\n-            setBasePath(SecuritySupport.JAVA_IO_TMPDIR);\n+            setBasePath(JAVA_IO_TMPDIR);\n@@ -87,1 +88,1 @@\n-            if (!SecuritySupport.existDirectory(repository)) {\n+            if (!Files.exists(repository)) {\n@@ -90,1 +91,1 @@\n-                SecuritySupport.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());\n+                System.setProperty(JFR_REPOSITORY_LOCATION_PROPERTY, repository.toString());\n@@ -95,1 +96,1 @@\n-                chunkFilename = ChunkFilename.newPriviliged(repository.toPath());\n+                chunkFilename = new ChunkFilename(repository);\n@@ -98,1 +99,1 @@\n-            return new RepositoryChunk(new SafePath(filename));\n+            return new RepositoryChunk(Path.of(filename));\n@@ -116,3 +117,3 @@\n-    private static SafePath createRepository(SafePath basePath) throws IOException {\n-        SafePath canonicalBaseRepositoryPath = createRealBasePath(basePath);\n-        SafePath f = null;\n+    private static Path createRepository(Path basePath) throws IOException {\n+        Path canonicalBaseRepositoryPath = createRealBasePath(basePath);\n+        Path f = null;\n@@ -125,1 +126,1 @@\n-            f = new SafePath(canonicalBaseRepositoryPath.toPath().resolve(name));\n+            f = canonicalBaseRepositoryPath.resolve(name);\n@@ -135,1 +136,1 @@\n-        return SecuritySupport.toRealPath(f);\n+        return f.toRealPath();\n@@ -138,4 +139,4 @@\n-    private static SafePath createRealBasePath(SafePath safePath) throws IOException {\n-        if (SecuritySupport.exists(safePath)) {\n-            if (!SecuritySupport.isWritable(safePath)) {\n-                throw new IOException(\"JFR repository directory (\" + safePath.toString() + \") exists, but isn't writable\");\n+    private static Path createRealBasePath(Path path) throws IOException {\n+        if (Files.exists(path)) {\n+            if (!Files.isWritable(path)) {\n+                throw new IOException(\"JFR repository directory (\" + path.toString() + \") exists, but isn't writable\");\n@@ -143,1 +144,1 @@\n-            return SecuritySupport.toRealPath(safePath);\n+            return path.toRealPath();\n@@ -145,2 +146,1 @@\n-        SafePath p = SecuritySupport.createDirectories(safePath);\n-        return SecuritySupport.toRealPath(p);\n+        return Files.createDirectories(path).toRealPath();\n@@ -149,2 +149,2 @@\n-    private static boolean tryToUseAsRepository(final SafePath path) {\n-        Path parent = path.toPath().getParent();\n+    private static boolean tryToUseAsRepository(Path path) {\n+        Path parent = path.getParent();\n@@ -155,13 +155,8 @@\n-            try {\n-                SecuritySupport.createDirectories(path);\n-            } catch (Exception e) {\n-                \/\/ file already existed or some other problem occurred\n-            }\n-            if (!SecuritySupport.exists(path)) {\n-                return false;\n-            }\n-            if (!SecuritySupport.isDirectory(path)) {\n-                return false;\n-            }\n-            return true;\n-        } catch (IOException io) {\n+            Files.createDirectories(path);\n+        } catch (Exception e) {\n+            \/\/ file already existed or some other problem occurred\n+        }\n+        if (!Files.exists(path)) {\n+            return false;\n+        }\n+        if (!Files.isDirectory(path)) {\n@@ -170,0 +165,1 @@\n+        return true;\n@@ -177,1 +173,1 @@\n-        for (SafePath p : cleanupDirectories) {\n+        for (Path p : cleanupDirectories) {\n@@ -179,1 +175,1 @@\n-                SecuritySupport.clearDirectory(p);\n+                DirectoryCleaner.clear(p);\n@@ -187,1 +183,1 @@\n-    public synchronized SafePath getRepositoryPath() {\n+    public synchronized Path getRepositoryPath() {\n@@ -191,1 +187,1 @@\n-    public synchronized SafePath getBaseLocation() {\n+    public synchronized Path getBaseLocation() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java","additions":41,"deletions":45,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.channels.FileChannel;\n@@ -31,0 +32,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n@@ -34,2 +38,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n-\n@@ -45,1 +47,1 @@\n-    private final SafePath chunkFile;\n+    private final Path chunkFile;\n@@ -53,1 +55,1 @@\n-    RepositoryChunk(SafePath path) throws Exception {\n+    RepositoryChunk(Path path) throws Exception {\n@@ -55,1 +57,1 @@\n-        this.unFinishedRAF = SecuritySupport.createRandomAccessFile(chunkFile);\n+        this.unFinishedRAF = new RandomAccessFile(path.toFile(), \"rw\");\n@@ -61,1 +63,1 @@\n-            size = SecuritySupport.getFileSize(chunkFile);\n+            size = Files.size(chunkFile);\n@@ -92,1 +94,1 @@\n-    private void delete(SafePath f) {\n+    private void delete(Path f) {\n@@ -94,1 +96,1 @@\n-            SecuritySupport.delete(f);\n+            Files.delete(f);\n@@ -156,1 +158,1 @@\n-        return ((SecuritySupport.newFileChannelToRead(chunkFile)));\n+        return FileChannel.open(chunkFile, StandardOpenOption.READ);\n@@ -169,1 +171,1 @@\n-    public SafePath getFile() {\n+    public Path getFile() {\n@@ -175,1 +177,1 @@\n-            return SecuritySupport.getFileSize(chunkFile);\n+            return Files.size(chunkFile);\n@@ -182,5 +184,1 @@\n-        try {\n-            return !SecuritySupport.exists(chunkFile);\n-        } catch (IOException ioe) {\n-            return true;\n-        }\n+        return !Files.exists(chunkFile);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,0 @@\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.RandomAccessFile;\n-import java.io.Reader;\n@@ -35,27 +29,0 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.ReflectPermission;\n-import java.nio.channels.FileChannel;\n-import java.nio.channels.ReadableByteChannel;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.LinkOption;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.StandardOpenOption;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permission;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.PropertyPermission;\n-import java.util.concurrent.Callable;\n-\n@@ -64,5 +31,0 @@\n-import jdk.jfr.FlightRecorder;\n-import jdk.jfr.FlightRecorderListener;\n-import jdk.jfr.FlightRecorderPermission;\n-import jdk.jfr.Recording;\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -70,4 +32,0 @@\n-\/**\n- * Contains JFR code that does\n- * {@link AccessController#doPrivileged(PrivilegedAction)}\n- *\/\n@@ -75,6 +33,0 @@\n-    private static final String EVENTS_PACKAGE_NAME = \"jdk.jfr.events\";\n-    private static final String EVENT_PACKAGE_NAME = \"jdk.jfr.internal.event\";\n-\n-    public static final String REGISTER_EVENT = \"registerEvent\";\n-    public static final String ACCESS_FLIGHT_RECORDER = \"accessFlightRecorder\";\n-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n@@ -82,3 +34,1 @@\n-    public  static final SafePath JFC_DIRECTORY = getPathInProperty(\"java.home\", \"lib\/jfr\");\n-    public static final FileAccess PRIVILEGED = new Privileged();\n-    static final SafePath JAVA_IO_TMPDIR = getPathInProperty(\"java.io.tmpdir\", null);\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n@@ -93,209 +43,0 @@\n-    static final class SecureRecorderListener implements FlightRecorderListener {\n-\n-        @SuppressWarnings(\"removal\")\n-        private final AccessControlContext context;\n-        private final FlightRecorderListener changeListener;\n-\n-        SecureRecorderListener(@SuppressWarnings(\"removal\") AccessControlContext context, FlightRecorderListener changeListener) {\n-            this.context = Objects.requireNonNull(context);\n-            this.changeListener = Objects.requireNonNull(changeListener);\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        @Override\n-        public void recordingStateChanged(Recording recording) {\n-            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                try {\n-                    changeListener.recordingStateChanged(recording);\n-                } catch (Throwable t) {\n-                    \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                    Logger.log(LogTag.JFR, LogLevel.WARN, \"Unexpected exception in listener \" + changeListener.getClass()+ \" at recording state change\");\n-                }\n-                return null;\n-            }, context);\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        @Override\n-        public void recorderInitialized(FlightRecorder recorder) {\n-            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-                try  {\n-                    changeListener.recorderInitialized(recorder);\n-                } catch (Throwable t) {\n-                    \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                    Logger.log(LogTag.JFR, LogLevel.WARN, \"Unexpected exception in listener \" + changeListener.getClass()+ \" when initializing FlightRecorder\");\n-                }\n-                return null;\n-            }, context);\n-        }\n-\n-        public FlightRecorderListener getChangeListener() {\n-            return changeListener;\n-        }\n-    }\n-\n-    private static final class DirectoryCleaner extends SimpleFileVisitor<Path> {\n-        @Override\n-        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {\n-            Files.delete(path);\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n-            if (exc != null) {\n-                throw exc;\n-            }\n-            Files.delete(dir);\n-            return FileVisitResult.CONTINUE;\n-        }\n-    }\n-\n-    \/**\n-     * Path created by the default file provider, and not\n-     * a malicious provider.\n-     *\n-     *\/\n-    public static final class SafePath implements Comparable<SafePath> {\n-        private final Path path;\n-        private final String text;\n-\n-        public SafePath(Path p) {\n-            \/\/ sanitize\n-            text = p.toString();\n-            path = Paths.get(text);\n-        }\n-\n-        public SafePath(String path) {\n-            this(Paths.get(path));\n-        }\n-\n-        public Path toPath() {\n-            return path;\n-        }\n-\n-        public File toFile() {\n-            return path.toFile();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return text;\n-        }\n-\n-        @Override\n-        public int compareTo(SafePath that) {\n-            return that.text.compareTo(this.text);\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if(other != null && other instanceof SafePath s){\n-                return this.toPath().equals(s.toPath());\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return this.toPath().hashCode();\n-        }\n-    }\n-\n-    private interface RunnableWithCheckedException {\n-        public void run() throws Exception;\n-    }\n-\n-    private interface CallableWithoutCheckException<T> {\n-        public T call();\n-    }\n-\n-    public static void checkAccessFlightRecorder() throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new FlightRecorderPermission(ACCESS_FLIGHT_RECORDER));\n-        }\n-    }\n-\n-    public static void checkRegisterPermission() throws SecurityException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new FlightRecorderPermission(REGISTER_EVENT));\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static <U> U doPrivilegedIOWithReturn(Callable<U> function) throws IOException {\n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<U>() {\n-                @Override\n-                public U run() throws Exception {\n-                    return function.call();\n-                }\n-            }, null);\n-        } catch (PrivilegedActionException e) {\n-            Throwable t = e.getCause();\n-            if (t instanceof IOException) {\n-                throw (IOException) t;\n-            }\n-            throw new IOException(\"Unexpected error during I\/O operation. \" + t.getMessage(), t);\n-        }\n-    }\n-\n-    private static void doPriviligedIO(RunnableWithCheckedException function) throws IOException {\n-        doPrivilegedIOWithReturn(() -> {\n-            function.run();\n-            return null;\n-        });\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static void doPrivileged(Runnable function, Permission... perms) {\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                function.run();\n-                return null;\n-            }\n-        }, null, perms);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static void doPrivileged(Runnable function) {\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                function.run();\n-                return null;\n-            }\n-        });\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static <T> T doPrivilegedWithReturn(CallableWithoutCheckException<T> function, Permission... perms) {\n-        return AccessController.doPrivileged(new PrivilegedAction<T>() {\n-            @Override\n-            public T run() {\n-                return function.call();\n-            }\n-        }, null, perms);\n-    }\n-\n-    public static List<SafePath> getPredefinedJFCFiles() {\n-        List<SafePath> list = new ArrayList<>();\n-        try (var ds = doPrivilegedIOWithReturn(() -> Files.newDirectoryStream(JFC_DIRECTORY.toPath()))) {\n-            for (Path path : ds) {\n-                SafePath s = new SafePath(path);\n-                String text = s.toString();\n-                if (text.endsWith(\".jfc\") && !SecuritySupport.isDirectory(s)) {\n-                    list.add(s);\n-                }\n-            }\n-        } catch (IOException ioe) {\n-            Logger.log(LogTag.JFR, LogLevel.WARN, \"Could not access .jfc-files in \" + JFC_DIRECTORY + \", \" + ioe.getMessage());\n-        }\n-        return list;\n-    }\n-\n@@ -317,1 +58,1 @@\n-        Modules.addExports(JFR_MODULE, EVENT_PACKAGE_NAME, clazz.getModule());\n+        Modules.addExports(JFR_MODULE, \"jdk.jfr.internal.event\", clazz.getModule());\n@@ -321,1 +62,1 @@\n-        Modules.addExports(JFR_MODULE, EVENTS_PACKAGE_NAME, clazz.getModule());\n+        Modules.addExports(JFR_MODULE, \"jdk.jfr.events\", clazz.getModule());\n@@ -328,107 +69,0 @@\n-    public static void registerEvent(Class<? extends jdk.internal.event.Event> eventClass) {\n-        doPrivileged(() ->  MetadataRepository.getInstance().register(eventClass), new FlightRecorderPermission(REGISTER_EVENT));\n-    }\n-\n-    public static void setProperty(String propertyName, String value) {\n-        doPrivileged(() -> System.setProperty(propertyName, value), new PropertyPermission(propertyName, \"write\"));\n-    }\n-\n-    static boolean getBooleanProperty(String propertyName) {\n-        return doPrivilegedWithReturn(() -> Boolean.getBoolean(propertyName), new PropertyPermission(propertyName, \"read\"));\n-    }\n-\n-    private static SafePath getPathInProperty(String prop, String subPath) {\n-        return doPrivilegedWithReturn(() -> {\n-            String path = System.getProperty(prop);\n-            if (path == null) {\n-                return null;\n-            }\n-            File file = subPath == null ? new File(path) : new File(path, subPath);\n-            return new SafePath(file.getAbsolutePath());\n-        }, new PropertyPermission(\"*\", \"read\"));\n-    }\n-\n-    \/\/ Called by JVM during initialization of JFR\n-    static Thread createRecorderThread(ThreadGroup systemThreadGroup, ClassLoader contextClassLoader) {\n-        \/\/ The thread should have permission = new Permission[0], and not \"modifyThreadGroup\" and \"modifyThread\" on the stack,\n-        \/\/ but it's hard circumvent if we are going to pass in system thread group in the constructor\n-        Thread thread = doPrivilegedWithReturn(() -> new Thread(systemThreadGroup, \"JFR Recorder Thread\"), new RuntimePermission(\"modifyThreadGroup\"), new RuntimePermission(\"modifyThread\"));\n-        doPrivileged(() -> thread.setContextClassLoader(contextClassLoader), new RuntimePermission(\"setContextClassLoader\"), new RuntimePermission(\"modifyThread\"));\n-        return thread;\n-    }\n-\n-    static void registerShutdownHook(Thread shutdownHook) {\n-        doPrivileged(() -> Runtime.getRuntime().addShutdownHook(shutdownHook), new RuntimePermission(\"shutdownHooks\"));\n-    }\n-\n-    static void setUncaughtExceptionHandler(Thread thread, Thread.UncaughtExceptionHandler eh) {\n-        doPrivileged(() -> thread.setUncaughtExceptionHandler(eh), new RuntimePermission(\"modifyThread\"));\n-    }\n-\n-    static void clearDirectory(SafePath safePath) throws IOException {\n-        doPriviligedIO(() -> Files.walkFileTree(safePath.toPath(), new DirectoryCleaner()));\n-    }\n-\n-    static SafePath toRealPath(SafePath safePath, LinkOption... options) throws IOException {\n-        return new SafePath(doPrivilegedIOWithReturn(() -> safePath.toPath().toRealPath(options)));\n-    }\n-\n-    static boolean existDirectory(SafePath directory) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> Files.exists(directory.toPath()));\n-    }\n-\n-    static RandomAccessFile createRandomAccessFile(SafePath path) throws Exception {\n-        return doPrivilegedIOWithReturn(() -> new RandomAccessFile(path.toPath().toFile(), \"rw\"));\n-    }\n-\n-    public static InputStream newFileInputStream(SafePath safePath) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> Files.newInputStream(safePath.toPath()));\n-    }\n-\n-    public static long getFileSize(SafePath safePath) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> Files.size(safePath.toPath()));\n-    }\n-\n-    static SafePath createDirectories(SafePath safePath) throws IOException {\n-        Path p = doPrivilegedIOWithReturn(() -> Files.createDirectories(safePath.toPath()));\n-        return new SafePath(p);\n-    }\n-\n-    public static boolean exists(SafePath safePath) throws IOException {\n-        \/\/ Files.exist(path) is allocation intensive\n-        return doPrivilegedIOWithReturn(() -> safePath.toPath().toFile().exists());\n-    }\n-\n-    public static boolean isDirectory(SafePath safePath) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> Files.isDirectory(safePath.toPath()));\n-    }\n-\n-    static void delete(SafePath localPath) throws IOException {\n-        doPriviligedIO(() -> Files.delete(localPath.toPath()));\n-    }\n-\n-    static boolean isWritable(SafePath safePath) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> Files.isWritable(safePath.toPath()));\n-    }\n-\n-    static ReadableByteChannel newFileChannelToRead(SafePath safePath) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> FileChannel.open(safePath.toPath(), StandardOpenOption.READ));\n-    }\n-\n-    public static InputStream getResourceAsStream(String name) throws IOException {\n-        return doPrivilegedIOWithReturn(() -> SecuritySupport.class.getResourceAsStream(name));\n-    }\n-\n-    public static Reader newFileReader(SafePath safePath) throws FileNotFoundException, IOException {\n-        return doPrivilegedIOWithReturn(() -> Files.newBufferedReader(safePath.toPath()));\n-    }\n-\n-    static void setAccessible(Method method) {\n-        doPrivileged(() -> method.setAccessible(true), new ReflectPermission(\"suppressAccessChecks\"));\n-    }\n-\n-    static void setAccessible(Constructor<?> constructor) {\n-        doPrivileged(() -> constructor.setAccessible(true), new ReflectPermission(\"suppressAccessChecks\"));\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n@@ -437,11 +71,1 @@\n-            MethodHandles.Lookup lookup;\n-            if (System.getSecurityManager() == null) {\n-                lookup = MethodHandles.privateLookupIn(clazz, LOOKUP);\n-            } else {\n-                lookup = AccessController.doPrivileged(new PrivilegedExceptionAction<>() {\n-                    @Override\n-                    public MethodHandles.Lookup run() throws IllegalAccessException {\n-                        return MethodHandles.privateLookupIn(clazz, LOOKUP);\n-                    }\n-                }, null, new ReflectPermission(\"suppressAccessChecks\"));\n-            }\n+            MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(clazz, LOOKUP);\n@@ -451,2 +75,0 @@\n-        } catch (PrivilegedActionException e) {\n-            throw new InternalError(e.getCause());\n@@ -456,1 +78,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -458,64 +79,4 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {\n-            @Override\n-            public Class<?> run() {\n-                try {\n-                    return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);\n-                } catch (IllegalAccessException e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n-        });\n-    }\n-\n-    public static Thread createThreadWitNoPermissions(String threadName, Runnable runnable) {\n-        return doPrivilegedWithReturn(() -> new Thread(runnable, threadName), new Permission[0]);\n-    }\n-\n-    public static void setDaemonThread(Thread t, boolean daemon) {\n-      doPrivileged(()-> t.setDaemon(daemon), new RuntimePermission(\"modifyThread\"));\n-    }\n-\n-    public static SafePath getAbsolutePath(SafePath path) throws IOException {\n-        return new SafePath(doPrivilegedIOWithReturn((()-> path.toPath().toAbsolutePath())));\n-    }\n-\n-    private static final class Privileged extends FileAccess {\n-        @Override\n-        public RandomAccessFile openRAF(File f, String mode) throws IOException {\n-            return doPrivilegedIOWithReturn( () -> new RandomAccessFile(f, mode));\n-        }\n-\n-        @Override\n-        public  DirectoryStream<Path> newDirectoryStream(Path directory)  throws IOException  {\n-            return doPrivilegedIOWithReturn( () -> Files.newDirectoryStream(directory));\n-        }\n-\n-        @Override\n-        public  String getAbsolutePath(File f) throws IOException {\n-            return doPrivilegedIOWithReturn( () -> f.getAbsolutePath());\n-        }\n-        @Override\n-        public long length(File f) throws IOException {\n-            return doPrivilegedIOWithReturn( () -> f.length());\n-        }\n-\n-        @Override\n-        public  long fileSize(Path p) throws IOException {\n-            return doPrivilegedIOWithReturn( () -> Files.size(p));\n-        }\n-\n-        @Override\n-        public boolean exists(Path p) throws IOException {\n-            return doPrivilegedIOWithReturn( () -> Files.exists(p));\n-        }\n-\n-        @Override\n-        public boolean isDirectory(Path p) {\n-            return doPrivilegedWithReturn( () -> Files.isDirectory(p));\n-        }\n-\n-        @Override\n-        public FileTime getLastModified(Path p) throws IOException {\n-            \/\/ Timestamp only needed when examining repository for other JVMs,\n-            \/\/ in which case an unprivileged mode should be used.\n-            throw new InternalError(\"Should not reach here\");\n+        try {\n+            return MethodHandles.privateLookupIn(lookupClass, LOOKUP).defineClass(bytes);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n@@ -524,2 +85,0 @@\n-\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":9,"deletions":450,"binary":false,"changes":459,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-\n@@ -39,1 +34,1 @@\n-final class ShutdownHook implements Runnable {\n+final class ShutdownHook extends Thread {\n@@ -44,0 +39,1 @@\n+        super(\"JFR Shutdown Hook\");\n@@ -64,1 +60,1 @@\n-            WriteableUserPath dest = recording.getDestination();\n+            WriteablePath dest = recording.getDestination();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,1 +192,1 @@\n-        SecuritySupport.setAccessible(m);\n+        m.setAccessible(true);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+import java.io.BufferedWriter;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public final class WriteablePath {\n+    private final Path path;\n+    private final Path real;\n+\n+    public WriteablePath(Path path) throws IOException {\n+        \/\/ verify that the path is writeable\n+        if (Files.exists(path) && !Files.isWritable(path)) {\n+            \/\/ throw same type of exception as FileOutputStream\n+            \/\/ constructor, if file can't be opened.\n+            throw new FileNotFoundException(\"Could not write to file: \" + path.toAbsolutePath());\n+        }\n+        \/\/ will throw if non-writeable\n+        BufferedWriter fw = Files.newBufferedWriter(path);\n+        fw.close();\n+        this.path = path;\n+        this.real = path.toRealPath();\n+    }\n+\n+    public Path getPath() {\n+        return path;\n+    }\n+\n+    public Path getReal() {\n+        return real;\n+    }\n+\n+    public String getRealPathText() {\n+        return real.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/WriteablePath.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import java.io.BufferedWriter;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.concurrent.Callable;\n-\n-\/**\n- * Purpose of this class is to simplify analysis of security risks.\n- * <p>\n- * Paths in the public API should be wrapped in this class so we\n- * at all time know what kind of paths we are dealing with.\n- * <p>\n- * A user supplied path must never be used in an unsafe context, such as a\n- * shutdown hook or any other thread created by JFR.\n- * <p>\n- * All operation using this path must happen in {@link #doPrivilegedIO(Callable)}\n- *\/\n-public final class WriteableUserPath {\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext controlContext;\n-    private final Path original;\n-    private final Path real;\n-    private final String realPathText;\n-    private final String originalText;\n-\n-    \/\/ Not to ensure security, but to help\n-    \/\/ against programming errors\n-    private volatile boolean inPrivileged;\n-\n-    @SuppressWarnings(\"removal\")\n-    public WriteableUserPath(Path path) throws IOException {\n-        controlContext = AccessController.getContext();\n-        \/\/ verify that the path is writeable\n-        if (Files.exists(path) && !Files.isWritable(path)) {\n-            \/\/ throw same type of exception as FileOutputStream\n-            \/\/ constructor, if file can't be opened.\n-            throw new FileNotFoundException(\"Could not write to file: \" + path.toAbsolutePath());\n-        }\n-        \/\/ will throw if non-writeable\n-        BufferedWriter fw = Files.newBufferedWriter(path);\n-        fw.close();\n-        this.original = path;\n-        this.originalText = path.toString();\n-        this.real = path.toRealPath();\n-        this.realPathText = real.toString();\n-    }\n-\n-    \/**\n-     * Returns a potentially malicious path where the user may have implemented\n-     * their own version of Path. This method should never be called in an\n-     * unsafe context and the Path value should never be passed along to other\n-     * methods.\n-     *\n-     * @return path from a potentially malicious user\n-     *\/\n-    public Path getPotentiallyMaliciousOriginal() {\n-        return original;\n-    }\n-\n-    \/**\n-     * Returns a string representation of the real path.\n-     *\n-     * @return path as text\n-     *\/\n-    public String getRealPathText() {\n-        return realPathText;\n-    }\n-\n-    \/**\n-     * Returns a string representation of the original path.\n-     *\n-     * @return path as text\n-     *\/\n-    public String getOriginalText() {\n-        return originalText;\n-    }\n-\n-\n-    \/**\n-     * Returns a potentially malicious path where the user may have implemented\n-     * their own version of Path. This method should never be called in an\n-     * unsafe context and the Path value should never be passed along to other\n-     * methods.\n-     *\n-     * @return path from a potentially malicious user\n-     *\/\n-    public Path getReal() {\n-        if (!inPrivileged) {\n-            throw new InternalError(\"A user path was accessed outside the context it was supplied in\");\n-        }\n-        return real;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    public void doPrivilegedIO(Callable<?> function) throws IOException {\n-        try {\n-            inPrivileged = true;\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                @Override\n-                public Void run() throws Exception {\n-                    function.call();\n-                    return null;\n-                }\n-            }, controlContext);\n-        } catch (Throwable t) {\n-            \/\/ prevent malicious user to propagate exception callback\n-            \/\/ in the wrong context\n-            Throwable cause = null;\n-            if (System.getSecurityManager() == null) {\n-                cause = t;\n-            }\n-            throw new IOException(\"Unexpected error during I\/O operation\", cause);\n-        } finally {\n-            inPrivileged = false;\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/WriteableUserPath.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -49,1 +46,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -60,2 +56,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext accessControllerContext;\n@@ -70,2 +64,1 @@\n-    AbstractEventStream(@SuppressWarnings(\"removal\") AccessControlContext acc, List<Configuration> configurations) throws IOException {\n-        this.accessControllerContext = Objects.requireNonNull(acc);\n+    AbstractEventStream(List<Configuration> configurations) throws IOException {\n@@ -224,3 +217,3 @@\n-        Runnable r = () -> run(accessControllerContext);\n-        Thread thread = SecuritySupport.createThreadWitNoPermissions(nextThreadName(), r);\n-        SecuritySupport.setDaemonThread(thread, daemon);\n+        Runnable r = () -> execute();\n+        Thread thread = new Thread(r, nextThreadName());\n+        thread.setDaemon(daemon);\n@@ -232,1 +225,1 @@\n-        run(accessControllerContext);\n+        execute();\n@@ -239,1 +232,0 @@\n-\n@@ -279,11 +271,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private void run(AccessControlContext accessControlContext) {\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                execute();\n-                return null;\n-            }\n-        }, accessControlContext);\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.security.AccessControlContext;\n@@ -35,1 +34,0 @@\n-import java.util.Objects;\n@@ -47,1 +45,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -61,1 +58,0 @@\n-    private final FileAccess fileAccess;\n@@ -72,2 +68,0 @@\n-            @SuppressWarnings(\"removal\")\n-            AccessControlContext acc,\n@@ -75,1 +69,0 @@\n-            FileAccess fileAccess,\n@@ -79,1 +72,1 @@\n-        super(acc, configurations);\n+        super(configurations);\n@@ -81,5 +74,1 @@\n-        if (p != null && SecuritySupport.PRIVILEGED == fileAccess) {\n-            throw new SecurityException(\"Priviliged file access not allowed with potentially malicious Path implementation\");\n-        }\n-        this.fileAccess = Objects.requireNonNull(fileAccess);\n-        this.repositoryFiles = new RepositoryFiles(fileAccess, p, allowSubDirectories);\n+        this.repositoryFiles = new RepositoryFiles(p, allowSubDirectories);\n@@ -156,1 +145,1 @@\n-        try (RecordingInput input = new RecordingInput(path.toFile(), fileAccess)) {\n+        try (RecordingInput input = new RecordingInput(path.toFile())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.security.AccessControlContext;\n@@ -48,3 +47,3 @@\n-    public EventFileStream(@SuppressWarnings(\"removal\") AccessControlContext acc, Path file) throws IOException {\n-        super(acc, Collections.emptyList());\n-        this.input = new RecordingInput(file.toFile(), FileAccess.UNPRIVILEGED);\n+    public EventFileStream(Path file) throws IOException {\n+        super(Collections.emptyList());\n+        this.input = new RecordingInput(file.toFile());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.consumer;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.RandomAccessFile;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.FileTime;\n-\n-\/\/ Protected by modular boundaries.\n-public abstract class FileAccess {\n-    public static final FileAccess UNPRIVILEGED = new UnPrivileged();\n-\n-    public abstract RandomAccessFile openRAF(File f, String mode) throws IOException;\n-\n-    public abstract DirectoryStream<Path> newDirectoryStream(Path repository) throws IOException;\n-\n-    public abstract String getAbsolutePath(File f) throws IOException;\n-\n-    public abstract long length(File f) throws IOException;\n-\n-    public abstract long fileSize(Path p) throws IOException;\n-\n-    public abstract boolean exists(Path s) throws IOException;\n-\n-    public abstract boolean isDirectory(Path p);\n-\n-    public abstract FileTime getLastModified(Path p) throws IOException;\n-\n-    private static class UnPrivileged extends FileAccess {\n-        @Override\n-        public RandomAccessFile openRAF(File f, String mode) throws IOException {\n-            return new RandomAccessFile(f, mode);\n-        }\n-\n-        @Override\n-        public DirectoryStream<Path> newDirectoryStream(Path dir) throws IOException {\n-            return Files.newDirectoryStream(dir);\n-        }\n-\n-        @Override\n-        public String getAbsolutePath(File f) throws IOException {\n-            return f.getAbsolutePath();\n-        }\n-\n-        @Override\n-        public long length(File f) throws IOException {\n-            return f.length();\n-        }\n-\n-        @Override\n-        public long fileSize(Path p) throws IOException {\n-            return Files.size(p);\n-        }\n-\n-        @Override\n-        public boolean exists(Path p) {\n-            return Files.exists(p);\n-        }\n-\n-        @Override\n-        public boolean isDirectory(Path p) {\n-            return Files.isDirectory(p);\n-        }\n-\n-        @Override\n-        public FileTime getLastModified(Path p) throws IOException {\n-            return Files.getLastModifiedTime(p);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.file.Files;\n@@ -34,1 +35,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -66,1 +66,1 @@\n-        this.repositoryFiles = new RepositoryFiles(SecuritySupport.PRIVILEGED, null, false);\n+        this.repositoryFiles = new RepositoryFiles(null, false);\n@@ -209,1 +209,1 @@\n-            if (SecuritySupport.getFileSize(new SafePath(path)) < HEADER_SIZE) {\n+            if (Files.size(path) < HEADER_SIZE) {\n@@ -212,1 +212,1 @@\n-            input = new RecordingInput(path.toFile(), SecuritySupport.PRIVILEGED);\n+            input = new RecordingInput(path.toFile());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.jfr.internal.util.Utils;\n@@ -71,1 +70,0 @@\n-    private final FileAccess fileAccess;\n@@ -82,1 +80,1 @@\n-    RecordingInput(File f, FileAccess fileAccess, int blockSize) throws IOException {\n+    RecordingInput(File f, int blockSize) throws IOException {\n@@ -84,1 +82,0 @@\n-        this.fileAccess = fileAccess;\n@@ -89,2 +86,2 @@\n-        this.filename = fileAccess.getAbsolutePath(f);\n-        this.file = fileAccess.openRAF(f, \"r\");\n+        this.filename = f.getAbsolutePath();\n+        this.file = new RandomAccessFile(f, \"r\");\n@@ -95,2 +92,2 @@\n-        if (fileAccess.length(f) < 8) {\n-            throw new IOException(\"Not a valid Flight Recorder file. File length is only \" + fileAccess.length(f) + \" bytes.\");\n+        if (f.length() < 8) {\n+            throw new IOException(\"Not a valid Flight Recorder file. File length is only \" + f.length() + \" bytes.\");\n@@ -100,2 +97,2 @@\n-    public RecordingInput(File f, FileAccess fileAccess) throws IOException {\n-        this(f, fileAccess, DEFAULT_BLOCK_SIZE);\n+    public RecordingInput(File f) throws IOException {\n+        this(f, DEFAULT_BLOCK_SIZE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RecordingInput.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.nio.file.Files;\n@@ -48,1 +49,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -60,1 +60,0 @@\n-    private final FileAccess fileAccess;\n@@ -68,1 +67,1 @@\n-    public RepositoryFiles(FileAccess fileAccess, Path repository, boolean allowSubDirectory) {\n+    public RepositoryFiles(Path repository, boolean allowSubDirectory) {\n@@ -70,1 +69,0 @@\n-        this.fileAccess = fileAccess;\n@@ -175,2 +173,2 @@\n-            SafePath sf = Repository.getRepository().getRepositoryPath();\n-            if (sf == null) {\n+            Path path = Repository.getRepository().getRepositoryPath();\n+            if (path == null) {\n@@ -179,1 +177,1 @@\n-            repoPath = sf.toPath();\n+            repoPath = path;\n@@ -182,1 +180,1 @@\n-        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {\n+        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(repoPath)) {\n@@ -211,1 +209,1 @@\n-                long size = fileAccess.fileSize(p);\n+                long size = Files.size(p);\n@@ -235,1 +233,1 @@\n-        try (DirectoryStream<Path> dirStream = fileAccess.newDirectoryStream(repoPath)) {\n+        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(repoPath)) {\n@@ -238,1 +236,1 @@\n-                if (isRepository(filename) && fileAccess.isDirectory(p)) {\n+                if (isRepository(filename) && Files.isDirectory(p)) {\n@@ -256,1 +254,1 @@\n-            return fileAccess.getLastModified(p);\n+            return Files.getLastModifiedTime(p);\n@@ -280,1 +278,1 @@\n-        try (RecordingInput in = new RecordingInput(p.toFile(), fileAccess, 100)) {\n+        try (RecordingInput in = new RecordingInput(p.toFile(), 100)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/RepositoryFiles.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -70,1 +69,1 @@\n-        this.input = new RecordingInput(source.toFile(), FileAccess.UNPRIVILEGED);\n+        this.input = new RecordingInput(source.toFile());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/ChunkWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -137,1 +135,1 @@\n-    protected final SafePath resolvePath(Recording recording, String filename) throws InvalidPathException {\n+    protected Path resolvePath(Recording recording, String filename) throws InvalidPathException {\n@@ -145,1 +143,1 @@\n-        return new SafePath(path.toAbsolutePath().normalize());\n+        return path.toAbsolutePath().normalize();\n@@ -148,2 +146,2 @@\n-    private SafePath makeGenerated(Recording recording, Path directory) {\n-        return new SafePath(directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize());\n+    private Path makeGenerated(Recording recording, Path directory) {\n+        return directory.toAbsolutePath().resolve(JVMSupport.makeFilename(recording)).normalize();\n@@ -161,1 +159,1 @@\n-    protected final void reportOperationComplete(String actionPrefix, String name, SafePath file) {\n+    protected final void reportOperationComplete(String actionPrefix, String name, Path file) {\n@@ -171,1 +169,1 @@\n-                long bytes = SecuritySupport.getFileSize(file);\n+                long bytes = Files.size(file);\n@@ -222,1 +220,1 @@\n-    protected final void printPath(SafePath path) {\n+    protected final void printPath(Path path) {\n@@ -227,5 +225,1 @@\n-        try {\n-            printPath(SecuritySupport.getAbsolutePath(path).toPath());\n-        } catch (IOException ioe) {\n-            printPath(path.toPath());\n-        }\n+        println(path.toAbsolutePath().toString());\n@@ -240,9 +234,0 @@\n-    protected final void printPath(Path path) {\n-        try {\n-            println(path.toAbsolutePath().toString());\n-        } catch (SecurityException e) {\n-            \/\/ fall back on filename\n-            println(path.toString());\n-        }\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/AbstractDCmd.java","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.file.Path;\n@@ -37,1 +38,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -92,1 +92,1 @@\n-                SafePath s = new SafePath(repositoryPath);\n+                Path s = Path.of(repositoryPath);\n@@ -118,1 +118,1 @@\n-                Options.setDumpPath(new SafePath(dumpPath));\n+                Options.setDumpPath(Path.of(dumpPath));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdConfigure.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -45,1 +44,1 @@\n-import jdk.jfr.internal.WriteableUserPath;\n+import jdk.jfr.internal.WriteablePath;\n@@ -129,1 +128,1 @@\n-            WriteableUserPath wup = null;\n+            WriteablePath wp = null;\n@@ -132,1 +131,1 @@\n-                wup = pRecording.getDestination();\n+                wp = pRecording.getDestination();\n@@ -134,3 +133,2 @@\n-            if (filename != null || (filename == null && wup == null) ) {\n-                SafePath safe = resolvePath(recording, filename);\n-                wup = new WriteableUserPath(safe.toPath());\n+            if (filename != null || (filename == null && wp == null) ) {\n+                wp = new WriteablePath(resolvePath(recording, filename));\n@@ -138,2 +136,2 @@\n-            r.dumpStopped(wup);\n-            reportOperationComplete(\"Dumped\", name, new SafePath(wup.getRealPathText()));\n+            r.dumpStopped(wp);\n+            reportOperationComplete(\"Dumped\", name, wp.getReal());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdDump.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -51,2 +49,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n-import jdk.jfr.internal.SecuritySupport;\n@@ -157,1 +153,1 @@\n-        SafePath safePath = null;\n+        Path dumpPath = null;\n@@ -176,1 +172,1 @@\n-                    pr.setDumpDirectory(new SafePath(p));\n+                    pr.setDumpDirectory(p);\n@@ -178,2 +174,2 @@\n-                    safePath = resolvePath(recording, path);\n-                    recording.setDestination(safePath.toPath());\n+                    dumpPath = resolvePath(recording, path);\n+                    recording.setDestination(dumpPath);\n@@ -224,1 +220,1 @@\n-        if (safePath != null && duration != null) {\n+        if (dumpPath != null && duration != null) {\n@@ -227,1 +223,1 @@\n-            printPath(safePath);\n+            printPath(dumpPath);\n@@ -259,1 +255,1 @@\n-                model.parse(JFC.createSafePath(setting));\n+                model.parse(JFC.ofPath(setting));\n@@ -466,2 +462,2 @@\n-            for (SafePath s : SecuritySupport.getPredefinedJFCFiles()) {\n-                String name = JFC.nameFromPath(s.toPath());\n+            for (Path s : JFC.getPredefined()) {\n+                String name = JFC.nameFromPath(s);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStart.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.file.Path;\n@@ -33,2 +34,1 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n-import jdk.jfr.internal.WriteableUserPath;\n+import jdk.jfr.internal.WriteablePath;\n@@ -50,2 +50,2 @@\n-            WriteableUserPath path = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();\n-            SafePath safePath = path == null ? null : new SafePath(path.getRealPathText());\n+            WriteablePath wp = PrivateAccess.getInstance().getPlatformRecording(recording).getDestination();\n+            Path path = wp == null ? null : wp.getReal();\n@@ -54,1 +54,1 @@\n-                    \/\/ Ensure path is valid. Don't generate safePath if filename == null, as a user may\n+                    \/\/ Ensure path is valid. Don't generate path if filename == null, as a user may\n@@ -56,1 +56,1 @@\n-                    safePath = resolvePath(null, filename);\n+                    path = resolvePath(null, filename);\n@@ -63,1 +63,1 @@\n-            reportOperationComplete(\"Stopped\", recording.getName(), safePath);\n+            reportOperationComplete(\"Stopped\", recording.getName(), path);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/dcmd\/DCmdStop.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.jfr.internal.EventWriterKey;\n@@ -40,15 +39,2 @@\n-\/\/ This is prevented in three ways:\n-\/\/\n-\/\/ 1. For code to access the jdk.jfr.internal.event package\n-\/\/    at least one event class (for a particular module) must be\n-\/\/    registered having FlightRecorderPermission(\"registerEvent\").\n-\/\/\n-\/\/ 2. The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from\n-\/\/    the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.\n-\/\/    (The EventWriterFactory class is dynamically generated before the first event\n-\/\/    is instrumented. See EventWriterFactoryRecipe)\n-\/\/\n-\/\/ 3. Steps 1 and 2 are sufficient to make it fully secure, with or without a Security\n-\/\/    Manager, but as an additional measure, the method EventWriterFactory::getEventWriter(long)\n-\/\/    requires the caller to provide a key that is hard to guess. The key is generated\n-\/\/    into the bytecode of the method invoking getEventWriter(long).\n+\/\/ The EventWriter EventWriterFactory::getEventWriter(long) method can only be linked from\n+\/\/ the UserEvent::commit() method instrumented by JFR. This is ensured by the JVM.\n@@ -74,0 +60,8 @@\n+    public static EventWriter getEventWriter() {\n+        EventWriter ew = JVM.getEventWriter();\n+        if (ew != null) {\n+            return ew;\n+        }\n+        return JVM.newEventWriter();\n+    }\n+\n@@ -242,3 +236,1 @@\n-        \/\/ Malicious code could take the EventConfiguration object from one\n-        \/\/ event class field and assign it to another. This check makes sure\n-        \/\/ the event type matches what was added by instrumentation.\n+        \/\/ This check makes sure the event type matches what was added by instrumentation.\n@@ -246,1 +238,1 @@\n-            EventWriterKey.block();\n+            throw new InternalError(\"Unexpected type id \" + typeId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,1 @@\n-import jdk.jfr.internal.SecuritySupport;\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n+import jdk.jfr.internal.util.Utils;\n@@ -56,0 +55,1 @@\n+    private static final Path JFC_DIRECTORY = Utils.getPathInProperty(\"java.home\", \"lib\/jfr\");\n@@ -61,0 +61,15 @@\n+    public static List<Path> getPredefined() {\n+        List<Path> list = new ArrayList<>();\n+        try (var ds = Files.newDirectoryStream(JFC_DIRECTORY)) {\n+            for (Path path : ds) {\n+                String text = path.toString();\n+                if (text.endsWith(\".jfc\") && !Files.isDirectory(path)) {\n+                    list.add(path);\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"Could not access .jfc-files in \" + JFC_DIRECTORY + \", \" + ioe.getMessage());\n+        }\n+        return list;\n+    }\n+\n@@ -69,1 +84,1 @@\n-        private final SafePath path;\n+        private final Path path;\n@@ -72,1 +87,1 @@\n-        public KnownConfiguration(SafePath knownPath) throws IOException {\n+        public KnownConfiguration(Path knownPath) throws IOException {\n@@ -75,2 +90,2 @@\n-            this.name = nameFromPath(knownPath.toPath());\n-            this.filename = nullSafeFileName(knownPath.toPath());\n+            this.name = nameFromPath(knownPath);\n+            this.filename = nullSafeFileName(knownPath);\n@@ -94,2 +109,2 @@\n-        private static String readContent(SafePath knownPath) throws IOException {\n-            if (SecuritySupport.getFileSize(knownPath) > MAXIMUM_FILE_SIZE) {\n+        private static String readContent(Path knownPath) throws IOException {\n+            if (Files.size(knownPath) > MAXIMUM_FILE_SIZE) {\n@@ -99,1 +114,1 @@\n-            try (InputStream r = SecuritySupport.newFileInputStream(knownPath)) {\n+            try (InputStream r = Files.newInputStream(knownPath)) {\n@@ -117,2 +132,0 @@\n-     * @throws SecurityException if a security manager exists and its\n-     *         {@code checkRead} method denies read access to the file\n@@ -120,1 +133,0 @@\n-     * @see java.lang.SecurityManager#checkRead(java.lang.String)\n@@ -139,1 +151,1 @@\n-     * @return a safe path, not null\n+     * @return a path, not null\n@@ -141,2 +153,2 @@\n-    public static SafePath createSafePath(String path) {\n-        for (SafePath predefined : SecuritySupport.getPredefinedJFCFiles()) {\n+    public static Path ofPath(String path) {\n+        for (Path predefined : JFC.getPredefined()) {\n@@ -144,1 +156,1 @@\n-                String name = JFC.nameFromPath(predefined.toPath());\n+                String name = JFC.nameFromPath(predefined);\n@@ -152,1 +164,1 @@\n-        return new SafePath(path);\n+        return Path.of(path);\n@@ -175,1 +187,0 @@\n-        \/\/ Known name, no need for permission\n@@ -182,2 +193,2 @@\n-        SafePath path = SecuritySupport.JFC_DIRECTORY;\n-        if (path != null && SecuritySupport.exists(path)) {\n+        Path path = JFC_DIRECTORY;\n+        if (path != null && Files.exists(path)) {\n@@ -185,4 +196,4 @@\n-                SafePath file = new SafePath(path.toPath().resolveSibling(name + extension));\n-                if (SecuritySupport.exists(file) && !SecuritySupport.isDirectory(file)) {\n-                    try (Reader r = SecuritySupport.newFileReader(file)) {\n-                        String jfcName = nameFromPath(file.toPath());\n+                Path file = path.resolveSibling(name + extension);\n+                if (Files.exists(file) && !Files.isDirectory(file)) {\n+                    try (Reader r = Files.newBufferedReader(file)) {\n+                        String jfcName = nameFromPath(file);\n@@ -263,1 +274,1 @@\n-            for (SafePath p : SecuritySupport.getPredefinedJFCFiles()) {\n+            for (Path p : JFC.getPredefined()) {\n@@ -284,1 +295,1 @@\n-    public static Reader newReader(SafePath sf) throws IOException {\n+    public static Reader newReader(Path sf) throws IOException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/JFC.java","additions":38,"deletions":27,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.file.Path;\n@@ -38,1 +39,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -68,1 +68,1 @@\n-    public void parse(SafePath file) throws IOException, JFCModelException, ParseException {\n+    public void parse(Path file) throws IOException, JFCModelException, ParseException {\n@@ -83,1 +83,1 @@\n-    public static JFCModel create(SafePath file, Consumer<String> logger) throws IOException, JFCModelException, ParseException{\n+    public static JFCModel create(Path file, Consumer<String> logger) throws IOException, JFCModelException, ParseException{\n@@ -157,1 +157,1 @@\n-    public void saveToFile(SafePath path) throws IOException {\n+    public void saveToFile(Path path) throws IOException {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/model\/JFCModel.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.file.Files;\n@@ -32,1 +33,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n@@ -34,1 +34,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -43,1 +42,0 @@\n-   private final FileAccess fileAcess;\n@@ -48,12 +46,2 @@\n-   public static ChunkFilename newUnpriviliged(Path directory) {\n-       return new ChunkFilename(directory, FileAccess.UNPRIVILEGED);\n-   }\n-\n-   public static ChunkFilename newPriviliged(Path directory) {\n-       return new ChunkFilename(directory, SecuritySupport.PRIVILEGED);\n-   }\n-\n-   private ChunkFilename(Path directory, FileAccess fileAccess) {\n-       \/\/ Avoid malicious implementations of Path interface\n-       this.directory = Paths.get(directory.toString());\n-       this.fileAcess = fileAccess;\n+   public ChunkFilename(Path directory) {\n+       this.directory = directory;\n@@ -68,1 +56,1 @@\n-           if (!fileAcess.exists(p)) {\n+           if (!Files.exists(p)) {\n@@ -80,1 +68,1 @@\n-           if (!fileAcess.exists(p)) {\n+           if (!Files.exists(p)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import java.security.AccessControlContext;\n-\n@@ -52,2 +50,0 @@\n-import jdk.jfr.internal.SecuritySupport;\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -57,1 +53,1 @@\n-import jdk.jfr.internal.WriteableUserPath;\n+import jdk.jfr.internal.WriteablePath;\n@@ -60,1 +56,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -87,1 +82,0 @@\n-        SecuritySupport.checkAccessFlightRecorder();\n@@ -124,2 +118,2 @@\n-        WriteableUserPath wup = pr.getDestination();\n-        return wup == null ? null : wup.getOriginalText();\n+        WriteablePath wp = pr.getDestination();\n+        return wp == null ? null : wp.getPath().toString();\n@@ -130,1 +124,1 @@\n-    public static void checkSetDestination(Recording recording, String destination) throws IOException{\n+    public static void checkSetDestination(Recording recording, String destination) throws IOException {\n@@ -133,2 +127,1 @@\n-            WriteableUserPath wup = new WriteableUserPath(Paths.get(destination));\n-            pr.checkSetDestination(wup);\n+            pr.checkSetDestination(new WriteablePath(Paths.get(destination)));\n@@ -146,1 +139,1 @@\n-        pr.removePath(new SafePath(path));\n+        pr.removePath(path);\n@@ -172,2 +165,0 @@\n-            @SuppressWarnings(\"removal\")\n-            AccessControlContext acc,\n@@ -177,1 +168,0 @@\n-            acc,\n@@ -179,1 +169,0 @@\n-            FileAccess.UNPRIVILEGED,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal.periodic;\n-\n-import jdk.internal.event.Event;\n-import jdk.jfr.internal.util.Utils;\n-\n-\/**\n- * Periodic task that runs trusted code that doesn't require an access control\n- * context.\n- * <p>\n- * This class can be removed once the Security Manager is no longer supported.\n- *\/\n-final class JDKEventTask extends JavaEventTask {\n-\n-    public JDKEventTask(Class<? extends Event> eventClass, Runnable runnable) {\n-        super(eventClass, runnable);\n-        if (!getEventType().isJDK()) {\n-            throw new InternalError(\"Must be a JDK event\");\n-        }\n-        if (!Utils.isJDKClass(eventClass)) {\n-            throw new SecurityException(\"Periodic task can only be registered for event classes that belongs to the JDK\");\n-        }\n-        if (!Utils.isJDKClass(runnable.getClass())) {\n-            throw new SecurityException(\"Runnable class must belong to the JDK\");\n-        }\n-    }\n-\n-    @Override\n-    public void execute(long timestamp, PeriodicType periodicType) {\n-        getRunnable().run();\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/JDKEventTask.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * Base class for periodic Java events.\n+ * Class for periodic Java events.\n@@ -35,1 +35,1 @@\n-abstract class JavaEventTask extends EventTask {\n+final class JavaEventTask extends EventTask {\n@@ -51,2 +51,3 @@\n-    protected final Runnable getRunnable() {\n-        return runnable;\n+    @Override\n+    public void execute(long timestamp, PeriodicType periodicType) {\n+        runnable.run();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/JavaEventTask.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,2 @@\n- * Lookup key that can safely be used in a {@code Map}.\n- * <p>\n- * {@code Runnable} objects can't be used with {@code LinkedHashMap} as it\n- * invokes {@code hashCode} and {@code equals}, for example when resizing the\n- * {@code Map}, possibly in a non-secure context.\n+ * Lookup key that can be used in a {@code Map} in\n+ * case hashCode and equals are incorrectly overridden.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/LookupKey.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.security.AccessControlContext;\n@@ -61,2 +60,2 @@\n-    public static void addJDKEvent(Class<? extends Event> eventClass, Runnable runnable) {\n-        taskRepository.add(new JDKEventTask(eventClass, runnable));\n+    public static void addJavaEvent(Class<? extends Event> eventClass, Runnable runnable) {\n+        taskRepository.add(new JavaEventTask(eventClass, runnable));\n@@ -69,4 +68,0 @@\n-    public static void addUserEvent(@SuppressWarnings(\"removal\") AccessControlContext acc, Class<? extends Event> eventClass, Runnable runnable) {\n-        taskRepository.add(new UserEventTask(acc, eventClass, runnable));\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicEvents.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n- *                \/         \\\n- *               \/           \\\n- *      UserEventTask     JDKEventTask\n@@ -130,2 +127,2 @@\n-            \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Exception occurred during execution of \" + name);\n+            String msg = \"Exception occurred during execution of \" + name + \". \" + e.getMessage();\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, msg);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicTask.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal.periodic;\n-\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Objects;\n-\n-import jdk.internal.event.Event;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-\/**\n- * Class to be used with user-defined events that runs untrusted code.\n- * <p>\n- * This class can be removed once the Security Manager is no longer supported.\n- *\/\n-final class UserEventTask extends JavaEventTask {\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext controlContext;\n-\n-    public UserEventTask(@SuppressWarnings(\"removal\") AccessControlContext controlContext, Class<? extends Event> eventClass, Runnable runnable) {\n-        super(eventClass, runnable);\n-        this.controlContext = Objects.requireNonNull(controlContext);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    @Override\n-    public void execute(long timestamp, PeriodicType periodicType) {\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            execute();\n-            return null;\n-        }, controlContext);\n-    }\n-\n-    private void execute() {\n-        try {\n-            getRunnable().run();\n-            if (Logger.shouldLog(LogTag.JFR_EVENT, LogLevel.DEBUG)) {\n-                Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, \"Executed periodic task for \" + getEventType().getLogName());\n-            }\n-        } catch (Throwable t) {\n-            \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-            Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, \"Exception occurred during execution of period task for \" + getEventType().getLogName());\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/UserEventTask.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.jfr.SettingControl;\n@@ -33,1 +34,1 @@\n-abstract class BooleanSetting extends JDKSettingControl {\n+abstract class BooleanSetting extends SettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/BooleanSetting.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.SettingControl;\n@@ -47,1 +48,1 @@\n-public final class CutoffSetting extends JDKSettingControl {\n+public final class CutoffSetting extends SettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CutoffSetting.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.settings;\n-\n-import jdk.jfr.SettingControl;\n-\n-\/**\n- * SettingControls that derive from this class avoids executing settings\n- * modifications in a AccessController.doPrivilege(...) block.\n- *\/\n-public abstract class JDKSettingControl extends SettingControl {\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/JDKSettingControl.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.SettingControl;\n@@ -42,1 +43,1 @@\n-public final class LevelSetting extends JDKSettingControl {\n+public final class LevelSetting extends SettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/LevelSetting.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.jfr.SettingControl;\n@@ -44,1 +45,1 @@\n-public final class PeriodSetting extends JDKSettingControl {\n+public final class PeriodSetting extends SettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/PeriodSetting.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.jfr.SettingControl;\n@@ -47,1 +48,1 @@\n-public final class ThresholdSetting extends JDKSettingControl {\n+public final class ThresholdSetting extends SettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThresholdSetting.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.jfr.SettingControl;\n@@ -50,1 +51,1 @@\n-public final class ThrottleSetting extends JDKSettingControl {\n+public final class ThrottleSetting extends SettingControl {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-        \/\/ commands.add(new Query());\n+        commands.add(new Query());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -132,1 +131,1 @@\n-            SafePath path = JFC.createSafePath(name);\n+            Path path = JFC.ofPath(name);\n@@ -147,1 +146,1 @@\n-        SafePath output = null;\n+        Path output = null;\n@@ -195,1 +194,1 @@\n-    private void configure(boolean interactive, boolean log, SafePath output, Map<String, String> options) throws UserDataException {\n+    private void configure(boolean interactive, boolean log, Path output, Map<String, String> options) throws UserDataException {\n@@ -204,1 +203,1 @@\n-                model.parse(JFC.createSafePath(input));\n+                model.parse(JFC.ofPath(input));\n@@ -211,1 +210,1 @@\n-                output = new SafePath(Path.of(\"custom.jfc\"));\n+                output = Path.of(\"custom.jfc\");\n@@ -233,1 +232,1 @@\n-            ui.println(output.toPath().toAbsolutePath().toString());\n+            ui.println(output.toAbsolutePath().toString());\n@@ -249,1 +248,1 @@\n-    private static SafePath filename(UserInterface ui, SafePath file) throws AbortException {\n+    private static Path filename(UserInterface ui, Path file) throws AbortException {\n@@ -259,1 +258,1 @@\n-                    return new SafePath(line);\n+                    return Path.of(line);\n@@ -268,1 +267,1 @@\n-    private SafePath makeJFCPath(String file) throws UserDataException, UserSyntaxException {\n+    private Path makeJFCPath(String file) throws UserDataException, UserSyntaxException {\n@@ -275,1 +274,1 @@\n-            return new SafePath(path);\n+            return path;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Configure.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -169,1 +168,1 @@\n-        try (RecordingInput input = new RecordingInput(p.toFile(), FileAccess.UNPRIVILEGED)) {\n+        try (RecordingInput input = new RecordingInput(p.toFile())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Disassemble.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import jdk.jfr.internal.consumer.FileAccess;\n@@ -96,1 +95,1 @@\n-        try (RecordingInput input = new RecordingInput(p.toFile(), FileAccess.UNPRIVILEGED)) {\n+        try (RecordingInput input = new RecordingInput(p.toFile())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Summary.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+\n+public final class DirectoryCleaner extends SimpleFileVisitor<Path> {\n+\n+    public static void clear(Path path) throws IOException {\n+        Files.walkFileTree(path, new DirectoryCleaner());\n+    }\n+\n+    @Override\n+    public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {\n+        Files.delete(path);\n+        return FileVisitResult.CONTINUE;\n+    }\n+\n+    @Override\n+    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+        if (exc != null) {\n+            throw exc;\n+        }\n+        Files.delete(dir);\n+        return FileVisitResult.CONTINUE;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/DirectoryCleaner.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.File;\n@@ -29,0 +30,1 @@\n+import java.io.InputStream;\n@@ -451,0 +453,9 @@\n+\n+    public static Path getPathInProperty(String prop, String subPath) {\n+        String path = System.getProperty(prop);\n+        if (path == null) {\n+            return null;\n+        }\n+        File file = subPath == null ? new File(path) : new File(path, subPath);\n+        return file.toPath().toAbsolutePath();\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-        this.chunkFilename = ChunkFilename.newUnpriviliged(path);\n+        this.chunkFilename = new ChunkFilename(path);\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -70,1 +67,0 @@\n-import jdk.jfr.FlightRecorderPermission;\n@@ -83,2 +79,0 @@\n-        @SuppressWarnings(\"removal\")\n-        private final AccessControlContext context;\n@@ -88,1 +82,0 @@\n-            this.context = AccessController.getContext();\n@@ -96,7 +89,1 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    sendNotification(createNotification(recording));\n-                    return null;\n-                }\n-            }, context);\n+            sendNotification(createNotification(recording));\n@@ -127,1 +114,0 @@\n-        MBeanUtils.checkControl();\n@@ -133,1 +119,0 @@\n-        MBeanUtils.checkControl();\n@@ -139,1 +124,0 @@\n-        MBeanUtils.checkControl();\n@@ -145,1 +129,0 @@\n-        MBeanUtils.checkControl();\n@@ -172,1 +155,0 @@\n-        MBeanUtils.checkControl();\n@@ -178,1 +160,0 @@\n-        MBeanUtils.checkMonitor();\n@@ -184,1 +165,0 @@\n-        MBeanUtils.checkMonitor();\n@@ -193,1 +173,0 @@\n-        MBeanUtils.checkMonitor();\n@@ -199,10 +178,1 @@\n-        MBeanUtils.checkMonitor();\n-        @SuppressWarnings(\"removal\")\n-        List<EventType> eventTypes = AccessController.doPrivileged(new PrivilegedAction<List<EventType>>() {\n-            @Override\n-            public List<EventType> run() {\n-                return ManagementSupport.getEventTypes();\n-            }\n-        }, null, new FlightRecorderPermission(\"accessFlightRecorder\"));\n-\n-        return MBeanUtils.transformList(eventTypes, EventTypeInfo::new);\n+        return MBeanUtils.transformList(ManagementSupport.getEventTypes(), EventTypeInfo::new);\n@@ -213,1 +183,0 @@\n-        MBeanUtils.checkMonitor();\n@@ -220,1 +189,0 @@\n-        MBeanUtils.checkControl();\n@@ -224,1 +192,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -227,1 +194,0 @@\n-        MBeanUtils.checkControl();\n@@ -229,6 +195,1 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<Recording>() {\n-            @Override\n-            public Recording run() {\n-                return new Recording();\n-            }\n-        }, null, new FlightRecorderPermission(\"accessFlightRecorder\")).getId();\n+        return new Recording().getId();\n@@ -239,1 +200,0 @@\n-        MBeanUtils.checkControl();\n@@ -246,1 +206,0 @@\n-        MBeanUtils.checkControl();\n@@ -258,1 +217,0 @@\n-        MBeanUtils.checkControl();\n@@ -272,1 +230,0 @@\n-        MBeanUtils.checkControl();\n@@ -279,1 +236,0 @@\n-        MBeanUtils.checkControl();\n@@ -318,1 +274,0 @@\n-        MBeanUtils.checkMonitor();\n@@ -333,2 +288,1 @@\n-    public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {\n-        MBeanUtils.checkControl();\n+    public long cloneRecording(long id, boolean stop) throws IllegalStateException {\n@@ -400,1 +354,1 @@\n-    private FlightRecorder getRecorder() throws SecurityException {\n+    private FlightRecorder getRecorder() {\n@@ -404,6 +358,1 @@\n-                recorder = AccessController.doPrivileged(new PrivilegedAction<FlightRecorder>() {\n-                    @Override\n-                    public FlightRecorder run() {\n-                        return FlightRecorder.getFlightRecorder();\n-                    }\n-                }, null, new FlightRecorderPermission(\"accessFlightRecorder\"));\n+                recorder = FlightRecorder.getFlightRecorder();\n@@ -428,7 +377,1 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run(){\n-                FlightRecorder.addListener(mxbeanListener);\n-                return null;\n-            }\n-        }, null, new FlightRecorderPermission(\"accessFlightRecorder\"));\n+        FlightRecorder.addListener(mxbeanListener);\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBeanImpl.java","additions":8,"deletions":65,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.lang.management.ManagementPermission;\n-import java.security.Permission;\n@@ -46,3 +44,0 @@\n-    private static final Permission monitor = new ManagementPermission(\"monitor\");\n-    private static final Permission control = new ManagementPermission(\"control\");\n-\n@@ -57,16 +52,0 @@\n-    static void checkControl() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager secManager = System.getSecurityManager();\n-        if (secManager != null) {\n-            secManager.checkPermission(control);\n-        }\n-    }\n-\n-    static void checkMonitor() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager secManager = System.getSecurityManager();\n-        if (secManager != null) {\n-            secManager.checkPermission(monitor);\n-        }\n-    }\n-\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/MBeanUtils.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -47,1 +45,0 @@\n-import java.security.AccessControlException;\n@@ -152,2 +149,0 @@\n-    @SuppressWarnings(\"removal\")\n-    final AccessControlContext accessControllerContext;\n@@ -208,3 +203,1 @@\n-        accessControllerContext = AccessController.getContext();\n-        \/\/ Make sure users can't implement malicious version of a Path object.\n-        path = Paths.get(directory.toString());\n+        path = directory;\n@@ -222,1 +215,1 @@\n-        stream = ManagementSupport.newEventDirectoryStream(accessControllerContext, path, configurations(mbean));\n+        stream = ManagementSupport.newEventDirectoryStream(path, configurations(mbean));\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.file.Path;\n@@ -33,1 +34,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -134,1 +134,1 @@\n-            SafePath initialPath = Repository.getRepository().getRepositoryPath();\n+            Path initialPath = Repository.getRepository().getRepositoryPath();\n@@ -137,1 +137,1 @@\n-            SafePath samePath = Repository.getRepository().getRepositoryPath();\n+            Path samePath = Repository.getRepository().getRepositoryPath();\n@@ -144,1 +144,1 @@\n-            SafePath changedPath = Repository.getRepository().getRepositoryPath();\n+            Path changedPath = Repository.getRepository().getRepositoryPath();\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdConfigure.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        PlaceholderEventWriter.getEventWriter();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/MyCommitRegisteredFalseEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        PlaceholderEventWriter.getEventWriter();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/MyCommitRegisteredTrueEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        PlaceholderEventWriter ew = PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        PlaceholderEventWriter ew = PlaceholderEventWriter.getEventWriter();;\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/NonEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+    public static PlaceholderEventWriter getEventWriter() {\n+        return null;\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/PlaceholderEventWriter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.jvm;\n-\n-\/\/ Purpose of this class is to have something to\n-\/\/ statically link against for TestGetEventWriter.\n-\/\/\n-\/\/ When the class is loaded \"jdk.jfr.jvm.PlaceholderEventWriterFactory\"\n-\/\/ will be replaced with \"jdk.jfr.internal.event.EventWriterFactory\"\n-public class PlaceholderEventWriterFactory {\n-\n-    public static PlaceholderEventWriter getEventWriter(long value) {\n-        throw new RuntimeException(\"Test error, PlaceholderEventWriterFactory class should have been replaced with EventWriterFactory\");\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/PlaceholderEventWriterFactory.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        PlaceholderEventWriter.getEventWriter();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/RegisteredFalseEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        PlaceholderEventWriter.getEventWriter();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/RegisteredTrueEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-        PlaceholderEventWriterFactory.getEventWriter(4711L);\n+        PlaceholderEventWriter.getEventWriter();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/StaticCommitEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n- * @compile PlaceholderEventWriterFactory.java\n@@ -83,1 +82,0 @@\n- * @compile PlaceholderEventWriterFactory.java\n@@ -108,2 +106,2 @@\n-        \/\/ Make sure EventWriterFactory can be accessed.\n-        Class<?> clazz = Class.forName(\"jdk.jfr.internal.event.EventWriterFactory\");\n+        \/\/ Make sure EventWriter class can be accessed.\n+        Class<?> clazz = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n@@ -111,1 +109,1 @@\n-            throw new Exception(\"Test error, not able to access jdk.jfr.internal.event.EventWriterFactory class\");\n+            throw new Exception(\"Test error, not able to access jdk.jfr.internal.event.EventWriter class\");\n@@ -125,1 +123,1 @@\n-    \/\/ attempts to resolve and link against EventWriterFactory. This user implementation\n+    \/\/ attempts to resolve and link against EventWriter. This user implementation\n@@ -181,1 +179,1 @@\n-    \/\/ overload. that attempts to resolve and link EventWriterFactory. This will fail,\n+    \/\/ overload. that attempts to resolve and link EventWriter. This will fail,\n@@ -233,4 +231,3 @@\n-                MethodType t = MethodType.methodType(ew, List.of(long.class));\n-                Class<?> factory = Class.forName(\"jdk.jfr.internal.event.EventWriterFactory\");\n-                MethodHandle mh = MethodHandles.lookup().findStatic(factory, \"getEventWriter\", t);\n-                mh.invoke(Long.valueOf(4711)); \/\/ throws IllegalAccessException\n+                MethodType t = MethodType.methodType(ew, List.of());\n+                MethodHandle mh = MethodHandles.lookup().findStatic(ew, \"getEventWriter\", t);\n+                mh.invoke(); \/\/ throws IllegalAccessException\n@@ -265,2 +262,2 @@\n-                c = Class.forName(\"jdk.jfr.internal.event.EventWriterFactory\");\n-                Method m = c.getMethod(\"getEventWriter\", new Class[] {long.class});\n+                c = Class.forName(\"jdk.jfr.internal.event.EventWriter\");\n+                Method m = c.getMethod(\"getEventWriter\", new Class[0]);\n@@ -286,1 +283,1 @@\n-                    if (iae.getMessage().contains(\"getEventWriter(long)\")) {\n+                    if (iae.getMessage().contains(\"getEventWriter()\")) {\n@@ -348,1 +345,0 @@\n-        bytes = replace(bytes, \"jdk\/jfr\/jvm\/PlaceholderEventWriterFactory\", \"jdk\/jfr\/internal\/event\/EventWriterFactory\");\n@@ -375,1 +371,1 @@\n-     * Checks that JVMCI prevents unblessed access to {@code EventWriterFactory.getEventWriter(long)}.\n+     * Checks that JVMCI prevents unblessed access to {@code EventWriter.getEventWriter()}.\n@@ -383,1 +379,1 @@\n-        \/\/ to be the call to jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long).\n+        \/\/ to be the call to jdk.jfr.internal.event.EventWriter.getEventWriter().\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriter.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -83,1 +82,1 @@\n-        SafePath repository = Repository.getRepository().getRepositoryPath();\n+        Path repository = Repository.getRepository().getRepositoryPath();\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestAssemble.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}