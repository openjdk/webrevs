{"files":[{"patch":"@@ -4423,0 +4423,42 @@\n+void C2_MacroAssembler::vector_signum_evex(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n+                                           KRegister ktmp1, int vec_enc) {\n+  if (opcode == Op_SignumVD) {\n+    vsubpd(dst, zero, one, vec_enc);\n+    \/\/ if src < 0 ? -1 : 1\n+    evcmppd(ktmp1, k0, src, zero, Assembler::LT_OQ, vec_enc);\n+    evblendmpd(dst, ktmp1, one, dst, true, vec_enc);\n+    \/\/ if src == NaN, -0.0 or 0.0 return src.\n+    evcmppd(ktmp1, k0, src, zero, Assembler::EQ_UQ, vec_enc);\n+    evblendmpd(dst, ktmp1, dst, src, true, vec_enc);\n+  } else {\n+    assert(opcode == Op_SignumVF, \"\");\n+    vsubps(dst, zero, one, vec_enc);\n+    \/\/ if src < 0 ? -1 : 1\n+    evcmpps(ktmp1, k0, src, zero, Assembler::LT_OQ, vec_enc);\n+    evblendmps(dst, ktmp1, one, dst, true, vec_enc);\n+    \/\/ if src == NaN, -0.0 or 0.0 return src.\n+    evcmpps(ktmp1, k0, src, zero, Assembler::EQ_UQ, vec_enc);\n+    evblendmps(dst, ktmp1, dst, src, true, vec_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_signum_avx(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n+                                          XMMRegister xtmp1, int vec_enc) {\n+  if (opcode == Op_SignumVD) {\n+    vsubpd(dst, zero, one, vec_enc);\n+    \/\/ if src < 0 ? -1 : 1\n+    vblendvpd(dst, one, dst, src, vec_enc);\n+    \/\/ if src == NaN, -0.0 or 0.0 return src.\n+    vcmppd(xtmp1, src, zero, Assembler::EQ_UQ, vec_enc);\n+    vblendvpd(dst, dst, src, xtmp1, vec_enc);\n+  } else {\n+    assert(opcode == Op_SignumVF, \"\");\n+    vsubps(dst, zero, one, vec_enc);\n+    \/\/ if src < 0 ? -1 : 1\n+    vblendvps(dst, one, dst, src, vec_enc);\n+    \/\/ if src == NaN, -0.0 or 0.0 return src.\n+    vcmpps(xtmp1, src, zero, Assembler::EQ_UQ, vec_enc);\n+    vblendvps(dst, dst, src, xtmp1, vec_enc);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -343,0 +343,6 @@\n+  void vector_signum_avx(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n+                         XMMRegister xtmp1, int vec_enc);\n+\n+  void vector_signum_evex(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n+                          KRegister ktmp1, int vec_enc);\n+\n@@ -352,0 +358,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1889,0 +1889,6 @@\n+    case Op_SignumVD:\n+    case Op_SignumVF:\n+      if (UseAVX < 1) {\n+        return false;\n+      }\n+      break;\n@@ -6092,0 +6098,30 @@\n+instruct signumV_reg_avx(vec dst, vec src, vec zero, vec one, vec xtmp1) %{\n+  predicate(Matcher::vector_length_in_bytes(n) < 64);\n+  match(Set dst (SignumVF src (Binary zero one)));\n+  match(Set dst (SignumVD src (Binary zero one)));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_signum_avx $dst, $src\\t! using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vec_enc = vector_length_encoding(this);\n+    __ vector_signum_avx(opcode, $dst$$XMMRegister, $src$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister,\n+                         $xtmp1$$XMMRegister, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct signumV_reg_evex(vec dst, vec src, vec zero, vec one, kReg ktmp1) %{\n+  predicate(Matcher::vector_length_in_bytes(n) ==  64);\n+  match(Set dst (SignumVF src (Binary zero one)));\n+  match(Set dst (SignumVD src (Binary zero one)));\n+  effect(TEMP dst, TEMP ktmp1);\n+  format %{ \"vector_signum_evex $dst, $src\\t! using $ktmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vec_enc = vector_length_encoding(this);\n+    __ vector_signum_evex(opcode, $dst$$XMMRegister, $src$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister,\n+                          $ktmp1$$KRegister, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4239,1 +4239,1 @@\n-    \"FmaVD\",\"FmaVF\",\"PopCountVI\", \"PopCountVL\", \"VectorLongToMask\",\n+    \"FmaVD\",\"FmaVF\",\"PopCountVI\", \"PopCountVL\", \"SignumVF\", \"SignumVD\", \"VectorLongToMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,0 +317,2 @@\n+macro(SignumVF)\n+macro(SignumVD)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2459,0 +2459,2 @@\n+    case Op_SignumVF:\n+    case Op_SignumVD:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2519,0 +2519,7 @@\n+      } else if (opc == Op_SignumF || opc == Op_SignumD) {\n+        assert(n->req() == 4, \"four inputs expected\");\n+        Node* in = vector_opd(p, 1);\n+        Node* zero = vector_opd(p, 2);\n+        Node* one = vector_opd(p, 3);\n+        vn = VectorNode::make(opc, in, zero, one, vlen, velt_basic_type(n));\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -248,0 +248,4 @@\n+  case Op_SignumF:\n+    return Op_SignumVF;\n+  case Op_SignumD:\n+    return Op_SignumVD;\n@@ -644,0 +648,2 @@\n+  case Op_SignumVD: return new SignumVDNode(n1, n2, n3, vt);\n+  case Op_SignumVF: return new SignumVFNode(n1, n2, n3, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1669,0 +1669,16 @@\n+\n+class SignumVFNode : public VectorNode {\n+public:\n+  SignumVFNode(Node* in1, Node* zero, Node* one, const TypeVect* vt)\n+  : VectorNode(in1, zero, one, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class SignumVDNode : public VectorNode {\n+public:\n+  SignumVDNode(Node* in1, Node* zero, Node* one, const TypeVect* vt)\n+  : VectorNode(in1, zero, one, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+      test_signum(a0, a1);\n@@ -429,0 +430,13 @@\n+      test_signum(a0, a1);\n+      errn += verify(\"test_signum: \", 0, a0[0], (Double.NaN));\n+      errn += verify(\"test_signum: \", 1, a0[1],  1.0);\n+      errn += verify(\"test_signum: \", 2, a0[2], -1.0);\n+      errn += verify(\"test_signum: \", 3, a0[3],  1.0);\n+      errn += verify(\"test_signum: \", 4, a0[4],  1.0);\n+      errn += verify(\"test_signum: \", 5, a0[5],  1.0);\n+      errn += verify(\"test_signum: \", 6, a0[6],  0.0);\n+      errn += verify(\"test_signum: \", 7, a0[7], -0.0);\n+      for (int i=8; i<ARRLEN; i++) {\n+        errn += verify(\"test_signum: \", i, a0[i], (double)(((double)(ADD_INIT+i)) > 0.0 ? 1.0 : -1.0));\n+      }\n+\n@@ -593,0 +607,7 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_signum(a0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_signum_n: \" + (end - start));\n+\n@@ -696,0 +717,6 @@\n+  static void test_signum(double[] a0, double[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.signum(a1[i]);\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestDoubleVect.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+      test_signum(a0, a1);\n@@ -348,0 +349,1 @@\n+\n@@ -375,0 +377,13 @@\n+      test_signum(a0, a1);\n+      errn += verify(\"test_signum: \", 0, a0[0], (Float.NaN));\n+      errn += verify(\"test_signum: \", 1, a0[1],  1.0f);\n+      errn += verify(\"test_signum: \", 2, a0[2], -1.0f);\n+      errn += verify(\"test_signum: \", 3, a0[3],  1.0f);\n+      errn += verify(\"test_signum: \", 4, a0[4],  1.0f);\n+      errn += verify(\"test_signum: \", 5, a0[5],  1.0f);\n+      errn += verify(\"test_signum: \", 6, a0[6],  0.0f);\n+      errn += verify(\"test_signum: \", 7, a0[7], -0.0f);\n+      for (int i=8; i<ARRLEN; i++) {\n+        errn += verify(\"test_signum: \", i, a0[i], (((float)(ADD_INIT+i)) > 0.0f ? 1.0f : -1.0f));\n+      }\n+\n@@ -403,1 +418,0 @@\n-\n@@ -540,0 +554,7 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_signum(a0, a1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_signum_n: \" + (end - start));\n+\n@@ -638,0 +659,6 @@\n+  static void test_signum(float[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.signum(a1[i]);\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestFloatVect.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8282711\n+ * @summary Accelerate Math.signum function for AVX and AVX512.\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestSignumVector\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestSignumVector {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+\n+  private static double [] dinp;\n+  private static double [] dout;\n+  private static float  [] finp;\n+  private static float  [] fout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                  \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {\"SignumVD\" , \" > 0 \"})\n+  public void test_signum_double(double[] dout, double[] dinp) {\n+      for (int i = 0; i < dout.length; i+=1) {\n+          dout[i] = Math.signum(dinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_signum_double\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_signum_double() {\n+      dinp = new double[ARRLEN];\n+      dout = new double[ARRLEN];\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+          dinp[i] = (double)i*1.4;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_signum_double(dout , dinp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {\"SignumVF\" , \" > 0 \"})\n+  public void test_signum_float(float[] fout, float[] finp) {\n+      for (int i = 0; i < finp.length; i+=1) {\n+          fout[i] = Math.signum(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_signum_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round() {\n+      finp = new float[ARRLEN];\n+      fout = new float[ARRLEN];\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+          finp[i] = (float)i*1.4f;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_signum_float(fout , finp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSignumVector.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class VectorSignum {\n+    @Param({\"256\", \"512\", \"1024\", \"2048\"})\n+    private static int SIZE;\n+\n+    private double[] res_doubles = new double[SIZE];\n+    private double[] doubles = new double[SIZE];\n+    private float[] res_floats = new float[SIZE];\n+    private float[] floats = new float[SIZE];\n+\n+    private Random r = new Random(1024);\n+\n+    @Setup\n+    public void init() {\n+        doubles = new double[SIZE];\n+        floats = new float[SIZE];\n+        res_doubles = new double[SIZE];\n+        res_floats = new float[SIZE];\n+        for (int i=0; i<SIZE; i++) {\n+            floats[i] = r.nextFloat();\n+            doubles[i] = r.nextDouble();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void floatSignum() {\n+        for(int i = 0; i < SIZE; i++) {\n+            res_floats[i] = Math.signum(floats[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleSignum() {\n+        for(int i = 0; i < SIZE; i++) {\n+            res_doubles[i] = Math.signum(doubles[i]);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/VectorSignum.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}