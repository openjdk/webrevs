{"files":[{"patch":"@@ -25,2 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/arena.hpp\"\n@@ -28,1 +26,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -41,18 +38,2 @@\n-  struct I {\n-    friend IndexedFreeListAllocator<E, flag>;\n-    int32_t _idx;\n-\n-  public:\n-    bool operator !=(I other) {\n-      return _idx != other._idx;\n-    }\n-    bool operator==(I other) {\n-      return _idx == other._idx;\n-    }\n-\n-    bool is_nil() {\n-      return *this == IndexedFreeListAllocator<E, flag>::nil;\n-    }\n-  };\n-\n-  static constexpr const I nil = I{-1};\n+  using I = int32_t;\n+  static constexpr const I nil = -1;\n@@ -76,1 +57,1 @@\n-    _free_start(I{nil._idx}) {}\n+    _free_start(nil) {}\n@@ -84,2 +65,2 @@\n-      be = &_backing_storage.at(_free_start._idx);\n-      i = _free_start._idx;\n+      be = &_backing_storage.at(_free_start);\n+      i = _free_start;\n@@ -98,3 +79,3 @@\n-    assert(!i.is_nil() || (i._idx > 0 && i._idx < _backing_storage.length()), \"out of bounds free\");\n-    if (i.is_nil()) return;\n-    BackingElement& be_freed = _backing_storage.at(i._idx);\n+    assert(i != nil || (i > 0 && i < _backing_storage.length()), \"out of bounds free\");\n+    if (i != nil) return;\n+    BackingElement& be_freed = _backing_storage.at(i);\n@@ -106,3 +87,3 @@\n-    assert(!i.is_nil(), \"null pointer dereference\");\n-    assert(i._idx > 0 && i._idx < _backing_storage.length(), \"out of bounds dereference\");\n-    return reinterpret_cast<E&>(_backing_storage.at(i._idx).e);\n+    assert(i != nil, \"null pointer dereference\");\n+    assert(i > 0 && i < _backing_storage.length(), \"out of bounds dereference\");\n+    return reinterpret_cast<E&>(_backing_storage.at(i).e);\n@@ -112,29 +93,2 @@\n-    assert(!i.is_nil(), \"null pointer dereference\");\n-    return reinterpret_cast<const E&>(_backing_storage.at(i._idx).e);\n-  }\n-};\n-\n-\/\/ A CHeap allocator\n-template<typename E, MEMFLAGS flag>\n-class CHeapAllocator {\n-public:\n-  struct I {\n-    E* e;\n-    bool operator !=(I other) {\n-      return e != other.e;\n-    }\n-    bool operator==(I other) {\n-      return e == other.e;\n-    }\n-\n-    bool is_nil() {\n-      return e == nullptr;\n-    }\n-  };\n-  static constexpr const I nil = {nullptr};\n-\n-  template<typename... Args>\n-  I allocate(Args... args) {\n-    void* place = os::malloc(sizeof(E), flag);\n-    ::new (place) E(args...);\n-    return I{static_cast<E*>(place)};\n+    assert(i != nil, \"null pointer dereference\");\n+    return reinterpret_cast<const E&>(_backing_storage.at(i).e);\n@@ -142,53 +96,0 @@\n-\n-  void free(I i) {\n-    return os::free(i.e);\n-  }\n-\n-  E& at(I i) {\n-    return *i.e;\n-  };\n-\n-  const E& at(I i) const {\n-    return *i.e;\n-  };\n-};\n-\n-\/\/ An Arena allocator\n-template<typename E, MEMFLAGS flag>\n-class ArenaAllocator {\n-  Arena _arena;\n-public:\n-  ArenaAllocator() : _arena(flag) {}\n-\n-  struct I {\n-    E* e;\n-    bool operator !=(I other) {\n-      return e != other.e;\n-    }\n-    bool operator==(I other) {\n-      return e == other.e;\n-    }\n-    bool is_nil() {\n-      return e == nullptr;\n-    }\n-  };\n-  static constexpr const I nil = {nullptr};\n-\n-  template<typename... Args>\n-  I allocate(Args... args) {\n-    void* place = _arena.Amalloc(sizeof(E));\n-    ::new (place) E(args...);\n-    return I{static_cast<E*>(place)};\n-  }\n-\n-  void free(I i) {\n-    _arena.Afree(i.e, sizeof(E));\n-  }\n-\n-  E& at(I i) {\n-    return *i.e;\n-  };\n-\n-  const E& at(I i) const {\n-    return *i.e;\n-  };\n","filename":"src\/hotspot\/share\/nmt\/indexedFreeListAllocator.hpp","additions":13,"deletions":112,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  LinkPtr nil() { return Allocator::nil; }\n+\n@@ -91,1 +93,1 @@\n-    while (!link.is_nil()) {\n+    while (link != nil()) {\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}