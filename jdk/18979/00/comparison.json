{"files":[{"patch":"@@ -0,0 +1,149 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+\/\/ A free list, growth only, allocator for a specific type E.\n+\/\/ The allocator returns 'pointers' of 4-bytes in size, allowing for\n+\/\/ memory savings if a pointer-heavy self-referential structure is used.\n+\/\/ It is \"indexed\" as a reference is base + index * sizeof(E).\n+\/\/ It never returns any memory to the system.\n+template<typename E, MEMFLAGS flag>\n+class IndexedFreeListAllocator {\n+public:\n+  \/\/ Make the index opaque.\n+  struct I {\n+    int32_t idx;\n+    bool operator !=(I other) {\n+      return idx != other.idx;\n+    }\n+    bool operator==(I other) {\n+      return idx == other.idx;\n+    }\n+  };\n+  static constexpr const I nil = I{-1};\n+  \/\/ A free list allocator element is either a link to the next free space\n+  \/\/ Or an actual element.\n+  union BackingElement {\n+    I link;\n+    E e;\n+    BackingElement() {\n+      this->link = nil;\n+    }\n+    BackingElement(I link) {\n+      this->link = link;\n+    }\n+    BackingElement(E& e) {\n+      this->e = e;\n+    }\n+  };\n+  GrowableArrayCHeap<BackingElement, flag> backing_storage;\n+  I free_start;\n+\n+  IndexedFreeListAllocator()\n+  : backing_storage(8),\n+  free_start(I{0}) {}\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    int32_t i = free_start.idx;\n+    backing_storage.at_grow(i);\n+    BackingElement& be = backing_storage.at(i);\n+    if (be.link == nil) {\n+      \/\/ Must be at end, simply increment\n+      free_start.idx += 1;\n+    } else {\n+      \/\/ Follow the link to the next free element\n+      free_start = be.link;\n+    }\n+    ::new (&be) E(args...);\n+    return I{i};\n+  }\n+\n+  void free(I i) {\n+    BackingElement& be_freed = backing_storage.at(i.idx);\n+    be_freed.link = free_start;\n+    free_start = i;\n+  }\n+\n+  E& operator[](I i) {\n+    return backing_storage.at(i.idx).e;\n+  }\n+\n+  E& translate(I i) {\n+    return backing_storage.at(i.idx).e;\n+  }\n+};\n+\n+\/\/ A CHeap allocator\n+template<typename E, MEMFLAGS flag>\n+class CHeapAllocator {\n+public:\n+  struct I {\n+    E* e;\n+    bool operator !=(I other) {\n+      return e != other.e;\n+    }\n+    bool operator==(I other) {\n+      return e == other.e;\n+    }\n+  };\n+  static constexpr const I nil = {nullptr};\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    void* place = os::malloc(sizeof(E), flag);\n+    ::new (place) E(args...);\n+    return I{static_cast<E*>(place)};\n+  }\n+\n+  void free(I i) {\n+    return os::free(i.e);\n+  }\n+\n+  E& operator[](I i) {\n+    return *i.e;\n+  }\n+\n+  E& translate(I i) {\n+    return *i.e;\n+  };\n+};\n+\n+\/\/ An Arena allocator\n+template<typename E, MEMFLAGS flag>\n+class ArenaAllocator {\n+  Arena _arena;\n+public:\n+  ArenaAllocator() : _arena(flag) {}\n+\n+  struct I {\n+    E* e;\n+    bool operator !=(I other) {\n+      return e != other.e;\n+    }\n+    bool operator==(I other) {\n+      return e == other.e;\n+    }\n+  };\n+  static constexpr const I nil = {nullptr};\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    void* place = _arena.Amalloc(sizeof(E));\n+    ::new (place) E(args...);\n+    return I{static_cast<E*>(place)};\n+  }\n+\n+  void free(I i) {\n+    _arena.Afree(i.e, sizeof(E));\n+  }\n+\n+  E& operator[](I i) {\n+    return *i.e;\n+  }\n+\n+  E& translate(I i) {\n+    return *i.e;\n+  };\n+};\n","filename":"src\/hotspot\/share\/nmt\/indexedFreeListAllocator.hpp","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/arena.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/indexedFreeListAllocator.hpp\"\n@@ -43,1 +43,2 @@\n-class NativeCallStackStorage : public CHeapObj<mtNMT> {\n+template<template<typename, MEMFLAGS> class ALLOCATOR>\n+class NativeCallStackStorageWithAllocator : public CHeapObj<mtNMT> {\n@@ -46,1 +47,1 @@\n-    friend NativeCallStackStorage;\n+    friend NativeCallStackStorageWithAllocator;\n@@ -71,2 +72,8 @@\n-  struct Link : public ArenaObj {\n-    Link* next;\n+  struct Link;\n+  using Allocator = ALLOCATOR<Link, mtNMT>;\n+  using LinkPtr = typename Allocator::I;\n+  static LinkPtr null() { return Allocator::nil; }\n+  Allocator _allocator;\n+\n+  struct Link {\n+    LinkPtr next;\n@@ -74,1 +81,1 @@\n-    Link(Link* next, StackIndex v)\n+    Link(LinkPtr next, StackIndex v)\n@@ -78,0 +85,2 @@\n+    Link()\n+    : next(null()), stack() {}\n@@ -79,0 +88,1 @@\n+\n@@ -81,4 +91,5 @@\n-    Link* link = _table[bucket];\n-    while (link != nullptr) {\n-      if (value.equals(get(link->stack))) {\n-        return link->stack;\n+    LinkPtr link = _table[bucket];\n+    while (link != null()) {\n+      Link& l = _allocator.translate(link);\n+      if (value.equals(get(l.stack))) {\n+        return l.stack;\n@@ -86,1 +97,1 @@\n-      link = link->next;\n+      link = l.next;\n@@ -89,1 +100,2 @@\n-    Link* new_link = new (&_arena) Link(_table[bucket], StackIndex(idx));\n+    StackIndex si(idx);\n+    LinkPtr new_link = _allocator.allocate(_table[bucket], si);\n@@ -91,1 +103,1 @@\n-    return new_link->stack;\n+    return si;\n@@ -94,2 +106,0 @@\n-  \/\/ For storage of the Links\n-  Arena _arena;\n@@ -100,1 +110,1 @@\n-  Link** _table;\n+  LinkPtr* _table;\n@@ -122,2 +132,2 @@\n-  NativeCallStackStorage(bool is_detailed_mode, int table_size = default_table_size)\n-  : _arena(mtNMT), _table_size(table_size), _table(nullptr), _stacks(),\n+  NativeCallStackStorageWithAllocator(bool is_detailed_mode, int table_size = default_table_size)\n+  : _table_size(table_size), _table(nullptr), _stacks(),\n@@ -126,1 +136,1 @@\n-      _table = NEW_ARENA_ARRAY(&_arena, Link*, _table_size);\n+      _table = NEW_C_HEAP_ARRAY(LinkPtr, _table_size, mtNMT);\n@@ -128,1 +138,1 @@\n-        _table[i] = nullptr;\n+        _table[i] = null();\n@@ -132,0 +142,4 @@\n+\n+  ~NativeCallStackStorageWithAllocator() {\n+    FREE_C_HEAP_ARRAY(LinkPtr, _table);\n+  }\n@@ -134,0 +148,2 @@\n+using NativeCallStackStorage = NativeCallStackStorageWithAllocator<IndexedFreeListAllocator>;\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":36,"deletions":20,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"unittest.hpp\"\n+#include \"nmt\/indexedFreeListAllocator.hpp\"\n+\n+class TIFLA {\n+public:\n+  \/\/ A linked list which sets the allocator itself\n+  template<typename E>\n+  struct LL {\n+    struct Node;\n+    using NodeAllocator = IndexedFreeListAllocator<Node, mtTest>;\n+    using NodePtr = typename NodeAllocator::I;\n+    NodeAllocator alloc;\n+    struct Node {\n+      E e;\n+      NodePtr next;\n+      Node(E e, NodePtr next)\n+        : e(e),\n+          next(next) {\n+      }\n+    };\n+\n+    NodePtr start;\n+    LL() : start(NodeAllocator::nil) {\n+\n+    }\n+\n+    void append(E&& e) {\n+      NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+      NodePtr& current = start;\n+      if (current == NodeAllocator::nil) {\n+        current = new_element;\n+        return;\n+      }\n+      while (alloc[current].next != NodeAllocator::nil) {\n+        current = alloc[current].next;\n+      }\n+      alloc[current].next = new_element;\n+    };\n+\n+    E pop() {\n+      assert(start != NodeAllocator::nil, \"must be\");\n+      Node& n = alloc[start];\n+      E e = n.e;\n+      alloc.free(start);\n+      start = n.next;\n+      return e;\n+    }\n+\n+  };\n+  \/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n+  \/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n+  \/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n+  \/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n+  template<typename E, template<typename, MEMFLAGS> class Allocator>\n+  struct LL2 {\n+    struct Node;\n+    using NodeAllocator = Allocator<Node, mtTest>;\n+    using NodePtr = typename NodeAllocator::I;\n+    NodeAllocator alloc;\n+    struct Node {\n+      E e;\n+      NodePtr next;\n+      Node(E e, NodePtr next)\n+        : e(e),\n+          next(next) {\n+      }\n+    };\n+\n+    NodePtr start;\n+    LL2() : start(NodeAllocator::nil) {}\n+\n+    void append(E&& e) {\n+      NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+      NodePtr& current = start;\n+      if (current == NodeAllocator::nil) {\n+        current = new_element;\n+        return;\n+      }\n+      while (alloc[current].next != NodeAllocator::nil) {\n+        current = alloc[current].next;\n+      }\n+      alloc[current].next = new_element;\n+    };\n+\n+    E pop() {\n+      assert(start != NodeAllocator::nil, \"must be\");\n+      Node& n = alloc[start];\n+      E e = n.e;\n+      alloc.free(start);\n+      start = n.next;\n+      return e;\n+    }\n+\n+  };\n+};\n+\n+TEST_VM(IFLATest, TestIt) {\n+  {\n+    TIFLA::LL<int> list;\n+    list.append(1);\n+    list.append(2);\n+    tty->print_cr(\"%d\", list.pop());\n+    tty->print_cr(\"%d\", list.pop());\n+  }\n+  {\n+    TIFLA::LL2<int, IndexedFreeListAllocator> list;\n+    tty->print_cr(\"size: %lu\", sizeof(TIFLA::LL2<int, IndexedFreeListAllocator>::Node));\n+    list.append(1);\n+    list.append(2);\n+    tty->print_cr(\"%d\", list.pop());\n+    tty->print_cr(\"%d\", list.pop());\n+  }\n+  {\n+    TIFLA::LL2<int, CHeapAllocator> list;\n+    tty->print_cr(\"size: %lu\", sizeof(TIFLA::LL2<int, CHeapAllocator>::Node));\n+    list.append(1);\n+    list.append(2);\n+    tty->print_cr(\"%d\", list.pop());\n+    tty->print_cr(\"%d\", list.pop());\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_indexedFreeListAllocator.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include <chrono>\n@@ -64,0 +65,76 @@\n+\n+TEST_VM_F(NativeCallStackStorageTest, PerfTest) {\n+      using std::chrono::high_resolution_clock;\n+    using std::chrono::duration_cast;\n+    using std::chrono::duration;\n+    using std::chrono::milliseconds;\n+\n+    \/* Getting number of milliseconds as an integer. *\/\n+\n+    \/* Getting number of milliseconds as a double. *\/\n+\n+  NativeCallStackStorage ncss(true);\n+  NativeCallStackStorageWithAllocator<CHeapAllocator> ncss_cheap(true);\n+  NativeCallStackStorageWithAllocator<ArenaAllocator> ncss_arena(true);\n+\n+  auto make_stack = []() -> NativeCallStack {\n+    size_t a = os::random();\n+    size_t b = os::random();\n+    size_t c = os::random();\n+    size_t d = os::random();\n+    address as[4] = {(address)a, (address)b, (address)c, (address)d};\n+    NativeCallStack stack(as, 4);\n+    return stack;\n+  };\n+\n+  constexpr const int size = 1000000;\n+  tty->print(\"Generate stacks... \");\n+  NativeCallStack* all = NEW_C_HEAP_ARRAY(NativeCallStack, size, mtTest);\n+  for (int i = 0; i < size; i++) {\n+    all[i] = make_stack();\n+  }\n+  tty->print_cr(\"Done\");\n+\n+  auto t1 = high_resolution_clock::now();\n+  for (int i = 0; i < size; i++) {\n+    ncss.push(all[i]);\n+  }\n+  auto t2 = high_resolution_clock::now();\n+\n+  auto ms_int = duration_cast<milliseconds>(t2 - t1);\n+  duration<double, std::milli> ms_double = t2 - t1;\n+  tty->print_cr(\"Time taken with GrowableArray: %f\", ms_double.count());\n+\n+  t1 = high_resolution_clock::now();\n+  for (int i = 0; i < size; i++) {\n+    ncss_cheap.push(all[i]);\n+  }\n+  t2 = high_resolution_clock::now();\n+\n+  ms_int = duration_cast<milliseconds>(t2 - t1);\n+  ms_double = t2 - t1;\n+  tty->print_cr(\"Time taken with CHeap: %f\", ms_double.count());\n+\n+  t1 = high_resolution_clock::now();\n+  for (int i = 0; i < size; i++) {\n+    ncss_arena.push(all[i]);\n+  }\n+  t2 = high_resolution_clock::now();\n+\n+  ms_int = duration_cast<milliseconds>(t2 - t1);\n+  ms_double = t2 - t1;\n+  tty->print_cr(\"Time taken with Arena: %f\", ms_double.count());\n+\n+  {\n+    NativeCallStackStorage ncss(true);\n+    auto t1 = high_resolution_clock::now();\n+    for (int i = 0; i < size; i++) {\n+      ncss.push(all[i]);\n+    }\n+    auto t2 = high_resolution_clock::now();\n+\n+    auto ms_int = duration_cast<milliseconds>(t2 - t1);\n+    duration<double, std::milli> ms_double = t2 - t1;\n+    tty->print_cr(\"Time taken with GrowableArray again: %f\", ms_double.count());\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativecallstackstorage.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"}]}