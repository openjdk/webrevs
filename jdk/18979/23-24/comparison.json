{"files":[{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n+\n+NativeCallStackStorage::StackIndex NativeCallStackStorage::put(const NativeCallStack& value) {\n+  int bucket = value.calculate_hash() % _table_size;\n+  TableEntryIndex link = _table[bucket];\n+  while (link != TableEntryStorage::nil) {\n+    TableEntry& l = _entry_storage.at(link);\n+    if (value.equals(get(l.stack))) {\n+      return l.stack;\n+    }\n+    link = l.next;\n+  }\n+  int idx = _stacks.append(value);\n+  StackIndex si(idx);\n+  TableEntryIndex new_link = _entry_storage.allocate(_table[bucket], si);\n+  _table[bucket] = new_link;\n+  return si;\n+}\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -71,4 +71,3 @@\n-  struct Link;\n-  using Allocator = HomogenousObjectArray<Link, mtNMT>;\n-  using LinkPtr = typename Allocator::I;\n-  LinkPtr nil() { return Allocator::nil; }\n+  struct TableEntry;\n+  using TableEntryStorage = HomogenousObjectArray<TableEntry, mtNMT>;\n+  using TableEntryIndex = typename TableEntryStorage::I;\n@@ -76,1 +75,1 @@\n-  Allocator _allocator;\n+  TableEntryStorage _entry_storage;\n@@ -78,2 +77,2 @@\n-  struct Link {\n-    LinkPtr next;\n+  struct TableEntry {\n+    TableEntryIndex next;\n@@ -81,1 +80,1 @@\n-    Link(LinkPtr next, StackIndex v)\n+    TableEntry(TableEntryIndex next, StackIndex v)\n@@ -85,2 +84,2 @@\n-    Link()\n-    : next(Allocator::nil), stack() {}\n+    TableEntry()\n+    : next(TableEntryStorage::nil), stack() {}\n@@ -89,16 +88,1 @@\n-  StackIndex put(const NativeCallStack& value) {\n-    int bucket = value.calculate_hash() % _table_size;\n-    LinkPtr link = _table[bucket];\n-    while (link != nil()) {\n-      Link& l = _allocator.at(link);\n-      if (value.equals(get(l.stack))) {\n-        return l.stack;\n-      }\n-      link = l.next;\n-    }\n-    int idx = _stacks.append(value);\n-    StackIndex si(idx);\n-    LinkPtr new_link = _allocator.allocate(_table[bucket], si);\n-    _table[bucket] = new_link;\n-    return si;\n-  }\n+  StackIndex put(const NativeCallStack& value);\n@@ -110,1 +94,1 @@\n-  LinkPtr* _table;\n+  TableEntryIndex* _table;\n@@ -136,1 +120,1 @@\n-      _table = NEW_C_HEAP_ARRAY(LinkPtr, _table_size, mtNMT);\n+      _table = NEW_C_HEAP_ARRAY(TableEntryIndex, _table_size, mtNMT);\n@@ -138,1 +122,1 @@\n-        _table[i] = Allocator::nil;\n+        _table[i] = TableEntryStorage::nil;\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":13,"deletions":29,"binary":false,"changes":42,"status":"modified"}]}