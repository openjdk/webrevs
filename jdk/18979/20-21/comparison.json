{"files":[{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"utilities\/growableArray.hpp\"\n+\n+#ifndef SHARE_NMT_HOMOGENOUSOBJECTARRAY_HPP\n+#define SHARE_NMT_HOMOGENOUSOBJECTARRAY_HPP\n+\n+\/\/ A flat array of elements E, backed by C-heap, growing on-demand. It allows for\n+\/\/ returning arbitrary elements and keeps them in a freelist. Elements can be uniquely\n+\/\/ identified via array index.\n+template<typename E, MEMFLAGS flag>\n+class HomogenousObjectArray {\n+public:\n+  using I = int32_t;\n+  static constexpr const I nil = -1;\n+\n+private:\n+  \/\/ A free list allocator element is either a link to the next free space\n+  \/\/ Or an actual element.\n+  union alignas(E) BackingElement {\n+    I link;\n+    char e[sizeof(E)];\n+  };\n+\n+  GrowableArrayCHeap<BackingElement, flag> _backing_storage;\n+  I _free_start;\n+\n+  bool is_in_bounds(I i) {\n+    return i >= 0 && i < _backing_storage.length();\n+  }\n+\n+public:\n+  NONCOPYABLE(HomogenousObjectArray<E COMMA flag>);\n+\n+  HomogenousObjectArray(int initial_capacity = 8)\n+    : _backing_storage(initial_capacity),\n+    _free_start(nil) {}\n+\n+  template<typename... Args>\n+  I allocate(Args... args) {\n+    BackingElement* be;\n+    I i;\n+    if (_free_start != nil) {\n+      \/\/ Must point to already existing index\n+      be = &_backing_storage.at(_free_start);\n+      i = _free_start;\n+      _free_start = be->link;\n+    } else {\n+      \/\/ There are no free elements, allocate a new one.\n+      i = _backing_storage.append(BackingElement());\n+      be = _backing_storage.adr_at(i);\n+    }\n+\n+    ::new (be) E(args...);\n+    return i;\n+  }\n+\n+  void free(I i) {\n+    assert(i == nil || is_in_bounds(i), \"out of bounds free\");\n+    if (i == nil) return;\n+    BackingElement& be_freed = _backing_storage.at(i);\n+    be_freed.link = _free_start;\n+    _free_start = i;\n+  }\n+\n+  E& at(I i) {\n+    assert(i != nil, \"null pointer dereference\");\n+    assert(is_in_bounds(i), \"out of bounds dereference\");\n+    return reinterpret_cast<E&>(_backing_storage.at(i).e);\n+  }\n+};\n+\n+#endif \/\/ SHARE_NMT_HOMOGENOUSOBJECTARRAY_HPP\n","filename":"src\/hotspot\/share\/nmt\/homogenousObjectArray.hpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n-\n- *\/\n-\n-#include \"utilities\/growableArray.hpp\"\n-\n-#ifndef SHARE_NMT_INDEXEDFREELISTALLOCATOR_HPP\n-#define SHARE_NMT_INDEXEDFREELISTALLOCATOR_HPP\n-\n-\/\/ A free list, growth only, allocator for a specific type E.\n-\/\/ The allocator returns 'pointers' of 4-bytes in size, allowing for\n-\/\/ memory savings if a pointer-heavy self-referential structure is used.\n-\/\/ It is \"indexed\" as a reference is base + index * sizeof(E).\n-\/\/ It never returns any memory to the system.\n-template<typename E, MEMFLAGS flag>\n-class IndexedFreeListAllocator {\n-public:\n-  using I = int32_t;\n-  static constexpr const I nil = -1;\n-\n-private:\n-  \/\/ A free list allocator element is either a link to the next free space\n-  \/\/ Or an actual element.\n-  union alignas(E) BackingElement {\n-    I link;\n-    char e[sizeof(E)];\n-  };\n-\n-  GrowableArrayCHeap<BackingElement, flag> _backing_storage;\n-  I _free_start;\n-\n-  bool is_in_bounds(I i) {\n-    return i >= 0 && i < _backing_storage.length();\n-  }\n-\n-public:\n-  NONCOPYABLE(IndexedFreeListAllocator<E COMMA flag>);\n-\n-  IndexedFreeListAllocator(int initial_capacity = 8)\n-    : _backing_storage(initial_capacity),\n-    _free_start(nil) {}\n-\n-  template<typename... Args>\n-  I allocate(Args... args) {\n-    BackingElement* be;\n-    I i;\n-    if (_free_start != nil) {\n-      \/\/ Must point to already existing index\n-      be = &_backing_storage.at(_free_start);\n-      i = _free_start;\n-      _free_start = be->link;\n-    } else {\n-      \/\/ There are no free elements, allocate a new one.\n-      i = _backing_storage.append(BackingElement());\n-      be = _backing_storage.adr_at(i);\n-    }\n-\n-    ::new (be) E(args...);\n-    return i;\n-  }\n-\n-  void free(I i) {\n-    assert(i == nil || is_in_bounds(i), \"out of bounds free\");\n-    if (i == nil) return;\n-    BackingElement& be_freed = _backing_storage.at(i);\n-    be_freed.link = _free_start;\n-    _free_start = i;\n-  }\n-\n-  E& at(I i) {\n-    assert(i != nil, \"null pointer dereference\");\n-    assert(is_in_bounds(i), \"out of bounds dereference\");\n-    return reinterpret_cast<E&>(_backing_storage.at(i).e);\n-  }\n-\n-  const E& at(I i) const {\n-    assert(i != nil, \"null pointer dereference\");\n-    return reinterpret_cast<const E&>(_backing_storage.at(i).e);\n-  }\n-};\n-\n-#endif \/\/ SHARE_NMT_INDEXEDFREELISTALLOCATOR_HPP\n","filename":"src\/hotspot\/share\/nmt\/indexedFreeListAllocator.hpp","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -43,2 +43,1 @@\n-template<template<typename, MEMFLAGS> class ALLOCATOR>\n-class NativeCallStackStorageWithAllocator : public CHeapObj<mtNMT> {\n+class NativeCallStackStorage : public CHeapObjBase {\n@@ -47,1 +46,1 @@\n-    friend NativeCallStackStorageWithAllocator;\n+    friend NativeCallStackStorage;\n@@ -73,1 +72,1 @@\n-  using Allocator = ALLOCATOR<Link, mtNMT>;\n+  using Allocator = HomogenousObjectArray<Link, mtNMT>;\n@@ -133,1 +132,1 @@\n-  NativeCallStackStorageWithAllocator(bool is_detailed_mode, int table_size = default_table_size)\n+  NativeCallStackStorage(bool is_detailed_mode, int table_size = default_table_size)\n@@ -144,1 +143,1 @@\n-  ~NativeCallStackStorageWithAllocator() {\n+  ~NativeCallStackStorage() {\n@@ -149,2 +148,0 @@\n-using NativeCallStackStorage = NativeCallStackStorageWithAllocator<IndexedFreeListAllocator>;\n-\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"unittest.hpp\"\n+#include \"nmt\/homogenousObjectArray.hpp\"\n+\n+using A = HomogenousObjectArray<int, mtTest>;\n+\n+class HomogenousObjectArrayTest  : public testing::Test {\n+};\n+\n+\/\/ A linked list which sets the allocator itself\n+template<typename E>\n+struct LL {\n+  struct Node;\n+  using NodeAllocator = HomogenousObjectArray<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+    Node(E e, NodePtr next)\n+      : e(e),\n+        next(next) {\n+    }\n+  };\n+\n+  NodePtr start;\n+  LL()\n+    : start(NodeAllocator::nil) {\n+  }\n+\n+  void push(E e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n+    }\n+    alloc.at(new_element).next = current;\n+    current = new_element;\n+  };\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.free(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n+\/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n+\/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n+\/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n+template<typename E, template<typename, MEMFLAGS> class Allocator>\n+struct LL2 {\n+  struct Node;\n+  using NodeAllocator = Allocator<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+    Node(E e, NodePtr next)\n+      : e(e),\n+        next(next) {\n+    }\n+  };\n+\n+  NodePtr start;\n+  LL2()\n+    : start(NodeAllocator::nil) {\n+  }\n+\n+  void push(E e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n+    }\n+    alloc.at(new_element).next = current;\n+    current = new_element;\n+  };\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.free(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\n+template<typename List>\n+void test_with_list(List& list) {\n+  list.push(1);\n+  list.push(2);\n+  EXPECT_EQ(2, list.pop());\n+  EXPECT_EQ(1, list.pop());\n+}\n+\n+TEST_VM_F(HomogenousObjectArrayTest, TestLinkedLists) {\n+  {\n+    LL<int> list;\n+    test_with_list(list);\n+  }\n+  {\n+    LL2<int, HomogenousObjectArray> list;\n+    test_with_list(list);\n+  }\n+}\n+\n+TEST_VM_F(HomogenousObjectArrayTest, FreeingShouldReuseMemory) {\n+  A alloc;\n+  A::I i = alloc.allocate(1);\n+  int* x = &alloc.at(i);\n+  alloc.free(i);\n+  i = alloc.allocate(1);\n+  int* y = &alloc.at(i);\n+  EXPECT_EQ(x, y);\n+}\n+\n+TEST_VM_F(HomogenousObjectArrayTest, FreeingInTheMiddleWorks) {\n+  A alloc;\n+  A::I i0 = alloc.allocate(0);\n+  A::I i1 = alloc.allocate(0);\n+  A::I i2 = alloc.allocate(0);\n+  int* p1 = &alloc.at(i1);\n+  alloc.free(i1);\n+  A::I i3 = alloc.allocate(0);\n+  EXPECT_EQ(p1, &alloc.at(i3));\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_homogenousObjectArray.hpp","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n-\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"unittest.hpp\"\n-#include \"nmt\/indexedFreeListAllocator.hpp\"\n-\n-class IndexedFreeListAllocatorTest  : public testing::Test {\n-};\n-\n-\/\/ A linked list which sets the allocator itself\n-template<typename E>\n-struct LL {\n-  struct Node;\n-  using NodeAllocator = IndexedFreeListAllocator<Node, mtTest>;\n-  using NodePtr = typename NodeAllocator::I;\n-  NodeAllocator alloc;\n-  struct Node {\n-    E e;\n-    NodePtr next;\n-    Node(E e, NodePtr next)\n-      : e(e),\n-        next(next) {\n-    }\n-  };\n-\n-  NodePtr start;\n-  LL()\n-    : start(NodeAllocator::nil) {\n-  }\n-\n-  void push(E e) {\n-    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n-    NodePtr& current = start;\n-    if (current == NodeAllocator::nil) {\n-      current = new_element;\n-      return;\n-    }\n-    alloc.at(new_element).next = current;\n-    current = new_element;\n-  };\n-\n-  E pop() {\n-    assert(start != NodeAllocator::nil, \"must be\");\n-    Node& n = alloc.at(start);\n-    E e = n.e;\n-    NodePtr next_start = n.next;\n-    alloc.free(start);\n-    start = next_start;\n-    return e;\n-  }\n-};\n-\/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n-\/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n-\/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n-\/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n-template<typename E, template<typename, MEMFLAGS> class Allocator>\n-struct LL2 {\n-  struct Node;\n-  using NodeAllocator = Allocator<Node, mtTest>;\n-  using NodePtr = typename NodeAllocator::I;\n-  NodeAllocator alloc;\n-  struct Node {\n-    E e;\n-    NodePtr next;\n-    Node(E e, NodePtr next)\n-      : e(e),\n-        next(next) {\n-    }\n-  };\n-\n-  NodePtr start;\n-  LL2()\n-    : start(NodeAllocator::nil) {\n-  }\n-\n-  void push(E e) {\n-    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n-    NodePtr& current = start;\n-    if (current == NodeAllocator::nil) {\n-      current = new_element;\n-      return;\n-    }\n-    alloc.at(new_element).next = current;\n-    current = new_element;\n-  };\n-\n-  E pop() {\n-    assert(start != NodeAllocator::nil, \"must be\");\n-    Node& n = alloc.at(start);\n-    E e = n.e;\n-    NodePtr next_start = n.next;\n-    alloc.free(start);\n-    start = next_start;\n-    return e;\n-  }\n-};\n-\n-template<typename List>\n-void test_with_list(List& list) {\n-  list.push(1);\n-  list.push(2);\n-  EXPECT_EQ(2, list.pop());\n-  EXPECT_EQ(1, list.pop());\n-}\n-\n-TEST_VM_F(IndexedFreeListAllocatorTest, TestLinkedLists) {\n-  {\n-    LL<int> list;\n-    test_with_list(list);\n-  }\n-  {\n-    LL2<int, IndexedFreeListAllocator> list;\n-    test_with_list(list);\n-  }\n-}\n-\n-TEST_VM_F(IndexedFreeListAllocatorTest, FreeingShouldReuseMemory) {\n-  using A = IndexedFreeListAllocator<int, mtTest>;\n-  A alloc;\n-  A::I i = alloc.allocate(1);\n-  int* x = &alloc.at(i);\n-  alloc.free(i);\n-  i = alloc.allocate(1);\n-  int* y = &alloc.at(i);\n-  EXPECT_EQ(x, y);\n-}\n","filename":"test\/hotspot\/gtest\/nmt\/test_indexedFreeListAllocator.cpp","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"}]}