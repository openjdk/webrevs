{"files":[{"patch":"@@ -43,4 +43,3 @@\n-    int32_t _idx;\n-#ifdef ASSERT\n-    IndexedFreeListAllocator<E, flag>* _owner;\n-#endif\n+    const int32_t _idx;\n+\n+    I(int32_t idx) : _idx(idx) {}\n@@ -49,0 +48,3 @@\n+    I(const I&) = default;\n+    I& operator=(const I&) = default;\n+\n@@ -56,2 +58,3 @@\n-    I(int32_t idx DEBUG_ONLY(COMMA IndexedFreeListAllocator<E COMMA flag>* owner))\n-    : _idx(idx) DEBUG_ONLY(COMMA _owner(owner)) {}\n+    bool is_nil() {\n+      return *this == IndexedFreeListAllocator<E, flag>::nil;\n+    }\n@@ -59,0 +62,1 @@\n+\n@@ -68,2 +72,1 @@\n-    BackingElement() {\n-      this->link = nil;\n+    BackingElement() : link(nil) {\n@@ -77,0 +80,2 @@\n+  NONCOPYABLE(IndexedFreeListAllocator<E COMMA flag>);\n+\n@@ -79,1 +84,1 @@\n-      _free_start(I(nil._idx DEBUG_ONLY(COMMA this))) {}\n+      _free_start(I(nil._idx)) {}\n@@ -84,1 +89,1 @@\n-    int i = -1;\n+    int i;\n@@ -97,1 +102,1 @@\n-    return I(i DEBUG_ONLY(COMMA this));\n+    return I(i);\n@@ -101,1 +106,1 @@\n-    assert(i == nil || i._owner == this, \"attempt to free via wrong allocator\");\n+    assert(!i.is_nil() || (i._idx > 0 && i._idx < _backing_storage.length()), \"out of bounds free\");\n@@ -109,2 +114,2 @@\n-    assert(i != nil, \"null pointer dereference\");\n-    assert(i._owner == this, \"attempt to access via wrong allocator\");\n+    assert(!i.is_nil(), \"null pointer dereference\");\n+    assert(i._idx > 0 && i._idx < _backing_storage.length(), \"out of bounds dereference\");\n@@ -115,2 +120,1 @@\n-    assert(i != nil, \"null pointer dereference\");\n-    assert(i._owner == this, \"attempt to access via wrong allocator\");\n+    assert(!i.is_nil(), \"null pointer dereference\");\n@@ -123,1 +127,1 @@\n-    IndexedFreeListAllocator<E, flag>::nil(-1 DEBUG_ONLY(COMMA nullptr));\n+    IndexedFreeListAllocator<E, flag>::nil(-1);\n","filename":"src\/hotspot\/share\/nmt\/indexedFreeListAllocator.hpp","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-  static LinkPtr null() { return Allocator::nil; }\n@@ -86,1 +85,1 @@\n-    : next(null()), stack() {}\n+    : next(Allocator::nil), stack() {}\n@@ -92,1 +91,1 @@\n-    while (link != null()) {\n+    while (!link.is_nil()) {\n@@ -138,1 +137,1 @@\n-        _table[i] = null();\n+        _table[i] = Allocator::nil;\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,20 +29,2 @@\n-class TIFLA {\n-public:\n-  \/\/ A linked list which sets the allocator itself\n-  template<typename E>\n-  struct LL {\n-    struct Node;\n-    using NodeAllocator = IndexedFreeListAllocator<Node, mtTest>;\n-    using NodePtr = typename NodeAllocator::I;\n-    NodeAllocator alloc;\n-    struct Node {\n-      E e;\n-      NodePtr next;\n-      Node(E e, NodePtr next)\n-        : e(e),\n-          next(next) {\n-      }\n-    };\n-\n-    NodePtr start;\n-    LL() : start(NodeAllocator::nil) {\n+class IndexedFreeListAllocatorTest  : public testing::Test {\n+};\n@@ -50,0 +32,13 @@\n+\/\/ A linked list which sets the allocator itself\n+template<typename E>\n+struct LL {\n+  struct Node;\n+  using NodeAllocator = IndexedFreeListAllocator<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+    Node(E e, NodePtr next)\n+      : e(e),\n+        next(next) {\n@@ -51,0 +46,1 @@\n+  };\n@@ -52,12 +48,4 @@\n-    void append(E&& e) {\n-      NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n-      NodePtr& current = start;\n-      if (current == NodeAllocator::nil) {\n-        current = new_element;\n-        return;\n-      }\n-      while (alloc.at(current).next != NodeAllocator::nil) {\n-        current = alloc.at(current).next;\n-      }\n-      alloc.at(current).next = new_element;\n-    };\n+  NodePtr start;\n+  LL()\n+    : start(NodeAllocator::nil) {\n+  }\n@@ -65,8 +53,6 @@\n-    E pop() {\n-      assert(start != NodeAllocator::nil, \"must be\");\n-      Node& n = alloc.at(start);\n-      E e = n.e;\n-      NodePtr next_start = n.next;\n-      alloc.free(start);\n-      start = next_start;\n-      return e;\n+  void append(E&& e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n@@ -74,1 +60,4 @@\n-\n+    while (alloc.at(current).next != NodeAllocator::nil) {\n+      current = alloc.at(current).next;\n+    }\n+    alloc.at(current).next = new_element;\n@@ -76,18 +65,0 @@\n-  \/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n-  \/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n-  \/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n-  \/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n-  template<typename E, template<typename, MEMFLAGS> class Allocator>\n-  struct LL2 {\n-    struct Node;\n-    using NodeAllocator = Allocator<Node, mtTest>;\n-    using NodePtr = typename NodeAllocator::I;\n-    NodeAllocator alloc;\n-    struct Node {\n-      E e;\n-      NodePtr next;\n-      Node(E e, NodePtr next)\n-        : e(e),\n-          next(next) {\n-      }\n-    };\n@@ -95,2 +66,28 @@\n-    NodePtr start;\n-    LL2() : start(NodeAllocator::nil) {}\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.free(start);\n+    start = next_start;\n+    return e;\n+  }\n+};\n+\/\/ A linked list which is capable of having multiple different allocators. This is done through higher-kinded types.\n+\/\/ That's a very fancy word that means that a templated type like Foo<E> can be passed around like only Foo at first\n+\/\/ and then be 'applied' to some E. Think of it like passing around a lambda or function pointer, but on a template level,\n+\/\/ where Foo is a function that can be called on some type with the return type being Foo<E>.\n+template<typename E, template<typename, MEMFLAGS> class Allocator>\n+struct LL2 {\n+  struct Node;\n+  using NodeAllocator = Allocator<Node, mtTest>;\n+  using NodePtr = typename NodeAllocator::I;\n+  NodeAllocator alloc;\n+  struct Node {\n+    E e;\n+    NodePtr next;\n+    Node(E e, NodePtr next)\n+      : e(e),\n+        next(next) {\n+    }\n+  };\n@@ -98,12 +95,4 @@\n-    void append(E&& e) {\n-      NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n-      NodePtr& current = start;\n-      if (current == NodeAllocator::nil) {\n-        current = new_element;\n-        return;\n-      }\n-      while (alloc.at(current).next != NodeAllocator::nil) {\n-        current = alloc.at(current).next;\n-      }\n-      alloc.at(current).next = new_element;\n-    };\n+  NodePtr start;\n+  LL2()\n+    : start(NodeAllocator::nil) {\n+  }\n@@ -111,8 +100,6 @@\n-    E pop() {\n-      assert(start != NodeAllocator::nil, \"must be\");\n-      Node& n = alloc.at(start);\n-      E e = n.e;\n-      NodePtr next_start = n.next;\n-      alloc.free(start);\n-      start = next_start;\n-      return e;\n+  void append(E&& e) {\n+    NodePtr new_element = alloc.allocate(e, NodeAllocator::nil);\n+    NodePtr& current = start;\n+    if (current == NodeAllocator::nil) {\n+      current = new_element;\n+      return;\n@@ -120,1 +107,4 @@\n-\n+    while (alloc.at(current).next != NodeAllocator::nil) {\n+      current = alloc.at(current).next;\n+    }\n+    alloc.at(current).next = new_element;\n@@ -122,0 +112,10 @@\n+\n+  E pop() {\n+    assert(start != NodeAllocator::nil, \"must be\");\n+    Node& n = alloc.at(start);\n+    E e = n.e;\n+    NodePtr next_start = n.next;\n+    alloc.free(start);\n+    start = next_start;\n+    return e;\n+  }\n@@ -124,1 +124,9 @@\n-TEST_VM(IFLATest, TestIt) {\n+template<typename List>\n+void test_with_list(List& list) {\n+  list.append(1);\n+  list.append(2);\n+  EXPECT_EQ(2, list.pop());\n+  EXPECT_EQ(1, list.pop());\n+}\n+\n+TEST_VM_F(IndexedFreeListAllocatorTest, TestLinkedLists) {\n@@ -126,5 +134,2 @@\n-    TIFLA::LL<int> list;\n-    list.append(1);\n-    list.append(2);\n-    tty->print_cr(\"%d\", list.pop());\n-    tty->print_cr(\"%d\", list.pop());\n+    LL<int> list;\n+    test_with_list(list);\n@@ -133,6 +138,2 @@\n-    TIFLA::LL2<int, IndexedFreeListAllocator> list;\n-    tty->print_cr(\"size: %zu\", sizeof(TIFLA::LL2<int, IndexedFreeListAllocator>::Node));\n-    list.append(1);\n-    list.append(2);\n-    tty->print_cr(\"%d\", list.pop());\n-    tty->print_cr(\"%d\", list.pop());\n+    LL2<int, IndexedFreeListAllocator> list;\n+    test_with_list(list);\n@@ -141,6 +142,2 @@\n-    TIFLA::LL2<int, CHeapAllocator> list;\n-    tty->print_cr(\"size: %zu\", sizeof(TIFLA::LL2<int, CHeapAllocator>::Node));\n-    list.append(1);\n-    list.append(2);\n-    tty->print_cr(\"%d\", list.pop());\n-    tty->print_cr(\"%d\", list.pop());\n+    LL2<int, CHeapAllocator> list;\n+    test_with_list(list);\n","filename":"test\/hotspot\/gtest\/nmt\/test_indexedFreeListAllocator.cpp","additions":97,"deletions":100,"binary":false,"changes":197,"status":"modified"}]}