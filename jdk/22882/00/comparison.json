{"files":[{"patch":"@@ -563,1 +563,1 @@\n-                    fc = FileChannelImpl.open(fd, path, true, false, false, false, this);\n+                    fc = FileChannelImpl.open(fd, path, true, false, false, false, false, this);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -451,1 +451,1 @@\n-                    fc = FileChannelImpl.open(fd, path, false, true, false, false, this);\n+                    fc = FileChannelImpl.open(fd, path, false, true, false, false, false, this);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-                    fc = FileChannelImpl.open(fd, path, true, rw, sync, false, this);\n+                    fc = FileChannelImpl.open(fd, path, true, rw, sync, false, false, this);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2970,1 +2970,1 @@\n-        try (SeekableByteChannel sbc = Files.newByteChannel(path);\n+        try (SeekableByteChannel sbc = Files.newByteChannel(path, StandardOpenOption.NOT_INTERRUPTIBLE);\n@@ -2972,2 +2972,0 @@\n-            if (sbc instanceof FileChannelImpl)\n-                ((FileChannelImpl) sbc).setUninterruptible();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,10 @@\n-    DSYNC;\n+    DSYNC,\n+\n+    \/**\n+     * Prevents blocking operations on this file from interacting with the\n+     * {@link Thread#interrupt} system. This also prevents the file from being\n+     * closed when a blocking operation is interrupted.\n+     *\n+     * @since 25\n+     *\/\n+    NOT_INTERRUPTIBLE;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/StandardOpenOption.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.channels.ReadableByteChannel;\n@@ -33,1 +32,0 @@\n-import java.nio.channels.WritableByteChannel;\n@@ -71,2 +69,0 @@\n-import sun.nio.ch.FileChannelImpl;\n-\n@@ -338,0 +334,3 @@\n+    private static final Set<OpenOption> DEFAULT_INPUT_OPTIONS =\n+            Set.of(StandardOpenOption.NOT_INTERRUPTIBLE);\n+\n@@ -365,9 +364,13 @@\n-        for (OpenOption opt : options) {\n-            \/\/ All OpenOption values except for APPEND and WRITE are allowed\n-            if (opt == StandardOpenOption.APPEND ||\n-                opt == StandardOpenOption.WRITE)\n-                throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n-        }\n-        ReadableByteChannel rbc = Files.newByteChannel(path, options);\n-        if (rbc instanceof FileChannelImpl) {\n-            ((FileChannelImpl) rbc).setUninterruptible();\n+        Set<OpenOption> opts;\n+        if (options.length == 0) {\n+            opts = DEFAULT_INPUT_OPTIONS;\n+        } else {\n+            opts = new HashSet<>();\n+            for (OpenOption opt : options) {\n+                \/\/ All OpenOption values except for APPEND and WRITE are allowed\n+                if (opt == StandardOpenOption.APPEND ||\n+                        opt == StandardOpenOption.WRITE)\n+                    throw new UnsupportedOperationException(\"'\" + opt + \"' not allowed\");\n+                opts.add(opt);\n+            }\n+            opts.add(StandardOpenOption.NOT_INTERRUPTIBLE);\n@@ -375,1 +378,1 @@\n-        return Channels.newInputStream(rbc);\n+        return Channels.newInputStream(Files.newByteChannel(path, opts));\n@@ -378,1 +381,1 @@\n-    private static final Set<OpenOption> DEFAULT_OPEN_OPTIONS =\n+    private static final Set<OpenOption> DEFAULT_OUTPUT_OPTIONS =\n@@ -380,1 +383,1 @@\n-            StandardOpenOption.WRITE);\n+            StandardOpenOption.WRITE, StandardOpenOption.NOT_INTERRUPTIBLE);\n@@ -416,1 +419,1 @@\n-            opts = DEFAULT_OPEN_OPTIONS;\n+            opts = DEFAULT_OUTPUT_OPTIONS;\n@@ -425,0 +428,1 @@\n+            opts.add(StandardOpenOption.NOT_INTERRUPTIBLE);\n@@ -426,5 +430,1 @@\n-        WritableByteChannel wbc = newByteChannel(path, opts);\n-        if (wbc instanceof FileChannelImpl) {\n-            ((FileChannelImpl) wbc).setUninterruptible();\n-        }\n-        return Channels.newOutputStream(wbc);\n+        return Channels.newOutputStream(newByteChannel(path, opts));\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/spi\/FileSystemProvider.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.file.OpenOption;\n@@ -40,0 +41,1 @@\n+import java.util.HashSet;\n@@ -41,0 +43,1 @@\n+import java.util.Set;\n@@ -106,1 +109,18 @@\n-            channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n+            Set<OpenOption> opts = new HashSet<>();\n+            opts.add(StandardOpenOption.READ);\n+            \/\/ No lambdas during bootstrap\n+            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+                @Override\n+                public Void run() {\n+                    try {\n+                        opts.add((OpenOption) StandardOpenOption.class.getField(\"NOT_INTERRUPTIBLE\").get(null));\n+                    } catch (NoSuchFieldException |\n+                            IllegalAccessException ex) {\n+                        \/\/ fall through - will happen on pre-25 JDKs\n+                    }\n+\n+                    return null;\n+                }\n+            });\n+\n+            channel = FileChannel.open(imagePath, opts);\n@@ -123,1 +143,2 @@\n-                            \/\/ is only used by tools using jrt-fs (non-critical.)\n+                            \/\/ is only used by tools using jrt-fs (non-critical),\n+                            \/\/ or on JDK-25+ systems where NOT_INTERRUPTIBLE is available.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    private volatile boolean uninterruptible;\n+    private final boolean uninterruptible;\n@@ -133,1 +133,1 @@\n-                            Closeable parent)\n+                            boolean uninterruptible, Closeable parent)\n@@ -148,0 +148,1 @@\n+        this.uninterruptible = uninterruptible;\n@@ -162,1 +163,2 @@\n-                                   boolean sync, boolean direct, Closeable parent)\n+                                   boolean sync, boolean direct,\n+                                   boolean uninterruptible, Closeable parent)\n@@ -164,1 +166,1 @@\n-        return new FileChannelImpl(fd, path, readable, writable, sync, direct, parent);\n+        return new FileChannelImpl(fd, path, readable, writable, sync, direct, uninterruptible, parent);\n@@ -172,4 +174,0 @@\n-    public void setUninterruptible() {\n-        uninterruptible = true;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+        boolean uninterruptible;\n@@ -84,0 +85,1 @@\n+                        case NOT_INTERRUPTIBLE : flags.uninterruptible = true; break;\n@@ -134,1 +136,1 @@\n-                (flags.sync || flags.dsync), flags.direct, null);\n+                (flags.sync || flags.dsync), flags.direct, flags.uninterruptible, null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixChannelFactory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+        boolean uninterruptible;\n@@ -101,0 +102,1 @@\n+                        case NOT_INTERRUPTIBLE : flags.uninterruptible = true; break;\n@@ -167,1 +169,1 @@\n-                (flags.sync || flags.dsync), flags.direct, null);\n+                (flags.sync || flags.dsync), flags.direct, flags.uninterruptible, null);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsChannelFactory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+import static java.nio.file.StandardOpenOption.NOT_INTERRUPTIBLE;\n@@ -169,1 +170,1 @@\n-        this.ch = Files.newByteChannel(zfpath, READ);\n+        this.ch = Files.newByteChannel(zfpath, READ, NOT_INTERRUPTIBLE);\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8316882\n+ * @run testng CallWithInterruptSet\n+ * @summary Test invoking ZipFS methods with the interrupt status set\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class CallWithInterruptSet {\n+\n+    @Test\n+    public void testReadAllBytes() throws Exception {\n+        Path file = Files.createTempFile(Path.of(\".\"), \"tmp\", \".zip\");\n+        try (var zout = new ZipOutputStream(Files.newOutputStream(file))) {\n+            zout.putNextEntry(new ZipEntry(\"entry\"));\n+            zout.write(\"HEHE\".getBytes(StandardCharsets.UTF_8), 0, 4);\n+            zout.closeEntry();\n+        }\n+        try (var zipfs = FileSystems.newFileSystem(file)) {\n+            var zippath = zipfs.getPath(\"entry\");\n+            Thread.currentThread().interrupt();\n+            assertEquals(\n+                    Files.readAllBytes(zippath),\n+                    \"HEHE\".getBytes(StandardCharsets.UTF_8));\n+        }\n+        assertTrue(Thread.interrupted()); \/\/ clear interrupt\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/CallWithInterruptSet.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}