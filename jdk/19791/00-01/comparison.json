{"files":[{"patch":"@@ -565,1 +565,9 @@\n-static bool already_enqueued(const Node_List& worklist_mem, const Node_List& worklist_store, Node* mem, Node* store) {\n+static bool already_enqueued(const Node_List& worklist_mem, const Node_List& worklist_store, Node* mem, PhiNode* phi) {\n+  \/\/ mem is one of the inputs of phi and at least one input of phi is\n+  \/\/ not mem. It's however possible that phi has mem as input multiple\n+  \/\/ times. If that happens, phi is recorded as a use of mem multiple\n+  \/\/ times as well. When PhaseCFG::insert_anti_dependences() goes over\n+  \/\/ uses of mem and enqueues them for processing, phi would then be\n+  \/\/ enqueued for processing multiple times when it only needs to be\n+  \/\/ processed once. The code below checks if phi as a use of mem was\n+  \/\/ already enqueued to avoid redundant processing of phi.\n@@ -567,0 +575,7 @@\n+  \/\/ The pair worklist_mem\/worklist_store is used as a queue of pairs\n+  \/\/ (mem,store) where mem is pushed to worklist_mem and store is\n+  \/\/ pushed to worklist_store and store is a use of mem. Anytime a mem\n+  \/\/ is pushed\/popped to\/from worklist_mem, a store has to be\n+  \/\/ pushed\/popped to\/from worklist_store.\n+  \/\/ If there are any use of mem already enqueued, they were enqueued\n+  \/\/ last (all use of mem are processed in one go).\n@@ -569,0 +584,1 @@\n+      \/\/ We're done with the uses of mem\n@@ -571,1 +587,1 @@\n-    if (worklist_store.at(j-1) == store) {\n+    if (worklist_store.at(j-1) == phi) {\n@@ -687,0 +703,1 @@\n+        \/\/ If this is not a store, load can't be anti dependent on this node\n@@ -702,1 +719,1 @@\n-          if (already_enqueued(worklist_mem, worklist_store, mem, store)) {\n+          if (already_enqueued(worklist_mem, worklist_store, mem, store->as_Phi())) {\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"}]}