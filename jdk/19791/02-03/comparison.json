{"files":[{"patch":"@@ -565,1 +565,1 @@\n-class MemStoreQueue : public StackObj {\n+class DefUseMemStatesQueue : public StackObj {\n@@ -567,1 +567,1 @@\n-  class MemStorePair : public StackObj {\n+  class DefUsePair : public StackObj {\n@@ -569,2 +569,2 @@\n-    Node* _mem; \/\/ memory state\n-    Node* _store; \/\/ use of the memory state that also modifies the memory state\n+    Node* _def; \/\/ memory state\n+    Node* _use; \/\/ use of the memory state that also modifies the memory state\n@@ -573,2 +573,2 @@\n-    MemStorePair(Node* mem, Node* store) :\n-            _mem(mem), _store(store) {\n+    DefUsePair(Node* def, Node* use) :\n+      _def(def), _use(use) {\n@@ -577,2 +577,2 @@\n-    MemStorePair() :\n-            _mem(nullptr), _store(nullptr) {\n+    DefUsePair() :\n+      _def(nullptr), _use(nullptr) {\n@@ -581,2 +581,2 @@\n-    Node* mem() const {\n-      return _mem;\n+    Node* def() const {\n+      return _def;\n@@ -585,2 +585,2 @@\n-    Node* store() const {\n-      return _store;\n+    Node* use() const {\n+      return _use;\n@@ -590,1 +590,1 @@\n-  GrowableArray<MemStorePair> _queue;\n+  GrowableArray<DefUsePair> _queue;\n@@ -606,2 +606,2 @@\n-      const MemStorePair& mem_store_pair = _queue.at(j);\n-      if (mem_store_pair.mem() != def_mem) {\n+      const DefUsePair& def_use_pair = _queue.at(j);\n+      if (def_use_pair.def() != def_mem) {\n@@ -611,1 +611,1 @@\n-      if (mem_store_pair.store() == use_phi) {\n+      if (def_use_pair.use() == use_phi) {\n@@ -617,2 +617,2 @@\n-      const MemStorePair& mem_store_pair = _queue.at(j);\n-      assert(mem_store_pair.mem() != def_mem, \"Should be done with the uses of def_mem\");\n+      const DefUsePair& def_use_pair = _queue.at(j);\n+      assert(def_use_pair.def() != def_mem, \"Should be done with the uses of def_mem\");\n@@ -625,1 +625,1 @@\n-  MemStoreQueue(ResourceArea* area) :\n+  DefUseMemStatesQueue(ResourceArea* area) :\n@@ -629,2 +629,2 @@\n-  void push(Node* mem, Node* store) {\n-    if (store->is_MergeMem()) {\n+  void push(Node* def_mem_state, Node* use_mem_state) {\n+    if (use_mem_state->is_MergeMem()) {\n@@ -635,1 +635,1 @@\n-        if (_worklist_visited.at(j-1) == store)  return; \/\/ already on work list; do not repeat\n+        if (_worklist_visited.at(j-1) == use_mem_state)  return; \/\/ already on work list; do not repeat\n@@ -637,2 +637,2 @@\n-      _worklist_visited.push(store);\n-    } else if (store->is_Phi()) {\n+      _worklist_visited.push(use_mem_state);\n+    } else if (use_mem_state->is_Phi()) {\n@@ -641,1 +641,1 @@\n-      if (already_enqueued(mem, store->as_Phi())) {\n+      if (already_enqueued(def_mem_state, use_mem_state->as_Phi())) {\n@@ -646,1 +646,1 @@\n-    _queue.push(MemStorePair(mem, store));\n+    _queue.push(DefUsePair(def_mem_state, use_mem_state));\n@@ -653,2 +653,2 @@\n-  Node* top_mem() const {\n-    return _queue.top().mem();\n+  Node* top_def() const {\n+    return _queue.top().def();\n@@ -657,2 +657,2 @@\n-  Node* top_store() const {\n-    return _queue.top().store();\n+  Node* top_use() const {\n+    return _queue.top().use();\n@@ -731,1 +731,1 @@\n-  MemStoreQueue worklist_mem_store(area); \/\/ prior memory state to store and possible-def to explore\n+  DefUseMemStatesQueue worklist_def_use_mem_states(area); \/\/ prior memory state to store and possible-def to explore\n@@ -751,2 +751,2 @@\n-  worklist_mem_store.push(nullptr, initial_mem);\n-  while (worklist_mem_store.is_nonempty()) {\n+  worklist_def_use_mem_states.push(nullptr, initial_mem);\n+  while (worklist_def_use_mem_states.is_nonempty()) {\n@@ -754,3 +754,3 @@\n-    Node* mem   = worklist_mem_store.top_mem();\n-    Node* store = worklist_mem_store.top_store();\n-    worklist_mem_store.pop();\n+    Node* def_mem_state = worklist_def_use_mem_states.top_def();\n+    Node* use_mem_state = worklist_def_use_mem_states.top_use();\n+    worklist_def_use_mem_states.pop();\n@@ -758,2 +758,2 @@\n-    uint op = store->Opcode();\n-    assert(!store->needs_anti_dependence_check(), \"only stores\");\n+    uint op = use_mem_state->Opcode();\n+    assert(!use_mem_state->needs_anti_dependence_check(), \"only stores\");\n@@ -764,1 +764,1 @@\n-    if (store == initial_mem    \/\/ root (exclusive) of tree we are searching\n+    if (use_mem_state == initial_mem    \/\/ root (exclusive) of tree we are searching\n@@ -767,2 +767,2 @@\n-      mem = store;   \/\/ It's not a possibly interfering store.\n-      if (store == initial_mem)\n+      def_mem_state = use_mem_state;   \/\/ It's not a possibly interfering store.\n+      if (use_mem_state == initial_mem)\n@@ -771,2 +771,2 @@\n-      for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n-        store = mem->fast_out(i);\n+      for (DUIterator_Fast imax, i = def_mem_state->fast_outs(imax); i < imax; i++) {\n+        use_mem_state = def_mem_state->fast_out(i);\n@@ -774,1 +774,1 @@\n-        if (store->needs_anti_dependence_check()) {\n+        if (use_mem_state->needs_anti_dependence_check()) {\n@@ -777,1 +777,1 @@\n-        worklist_mem_store.push(mem, store);\n+        worklist_def_use_mem_states.push(def_mem_state, use_mem_state);\n@@ -787,1 +787,1 @@\n-    const TypePtr* adr_type = store->adr_type();\n+    const TypePtr* adr_type = use_mem_state->adr_type();\n@@ -792,2 +792,2 @@\n-    if (store->is_Mach()) {\n-      MachNode* mstore = store->as_Mach();\n+    if (use_mem_state->is_Mach()) {\n+      MachNode* mstore = use_mem_state->as_Mach();\n@@ -832,1 +832,1 @@\n-    Block* store_block = get_block_for_node(store);\n+    Block* store_block = get_block_for_node(use_mem_state);\n@@ -835,1 +835,1 @@\n-    if (store->is_Phi()) {\n+    if (use_mem_state->is_Phi()) {\n@@ -850,2 +850,2 @@\n-      for (uint j = PhiNode::Input, jmax = store->req(); j < jmax; j++) {\n-        if (store->in(j) == mem) {   \/\/ Found matching input?\n+      for (uint j = PhiNode::Input, jmax = use_mem_state->req(); j < jmax; j++) {\n+        if (use_mem_state->in(j) == def_mem_state) {   \/\/ Found matching input?\n@@ -877,1 +877,1 @@\n-      if (LCA != early && !unrelated_load_in_store_null_block(store, load)) {\n+      if (LCA != early && !unrelated_load_in_store_null_block(use_mem_state, load)) {\n@@ -880,1 +880,1 @@\n-        non_early_stores.push(store);\n+        non_early_stores.push(use_mem_state);\n@@ -886,1 +886,1 @@\n-      assert(store != load->find_exact_control(load->in(0)), \"dependence cycle found\");\n+      assert(use_mem_state != load->find_exact_control(load->in(0)), \"dependence cycle found\");\n@@ -888,1 +888,1 @@\n-        assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load),\n+        assert(use_mem_state->find_edge(load) != -1 || unrelated_load_in_store_null_block(use_mem_state, load),\n@@ -891,1 +891,1 @@\n-        store->add_prec(load);\n+        use_mem_state->add_prec(load);\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"}]}