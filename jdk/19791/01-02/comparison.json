{"files":[{"patch":"@@ -565,21 +565,10 @@\n-static bool already_enqueued(const Node_List& worklist_mem, const Node_List& worklist_store, Node* mem, PhiNode* phi) {\n-  \/\/ mem is one of the inputs of phi and at least one input of phi is\n-  \/\/ not mem. It's however possible that phi has mem as input multiple\n-  \/\/ times. If that happens, phi is recorded as a use of mem multiple\n-  \/\/ times as well. When PhaseCFG::insert_anti_dependences() goes over\n-  \/\/ uses of mem and enqueues them for processing, phi would then be\n-  \/\/ enqueued for processing multiple times when it only needs to be\n-  \/\/ processed once. The code below checks if phi as a use of mem was\n-  \/\/ already enqueued to avoid redundant processing of phi.\n-  uint j = worklist_mem.size();\n-  \/\/ The pair worklist_mem\/worklist_store is used as a queue of pairs\n-  \/\/ (mem,store) where mem is pushed to worklist_mem and store is\n-  \/\/ pushed to worklist_store and store is a use of mem. Anytime a mem\n-  \/\/ is pushed\/popped to\/from worklist_mem, a store has to be\n-  \/\/ pushed\/popped to\/from worklist_store.\n-  \/\/ If there are any use of mem already enqueued, they were enqueued\n-  \/\/ last (all use of mem are processed in one go).\n-  for (; j > 0; j--) {\n-    if (worklist_mem.at(j-1) != mem) {\n-      \/\/ We're done with the uses of mem\n-      return false;\n+class MemStoreQueue : public StackObj {\n+private:\n+  class MemStorePair : public StackObj {\n+  private:\n+    Node* _mem; \/\/ memory state\n+    Node* _store; \/\/ use of the memory state that also modifies the memory state\n+\n+  public:\n+    MemStorePair(Node* mem, Node* store) :\n+            _mem(mem), _store(store) {\n@@ -587,2 +576,43 @@\n-    if (worklist_store.at(j-1) == phi) {\n-      return true;\n+\n+    MemStorePair() :\n+            _mem(nullptr), _store(nullptr) {\n+    }\n+\n+    Node* mem() const {\n+      return _mem;\n+    }\n+\n+    Node* store() const {\n+      return _store;\n+    }\n+  };\n+\n+  GrowableArray<MemStorePair> _queue;\n+  Node_List _worklist_visited; \/\/ visited mergemem nodes\n+\n+  bool already_enqueued(Node* def_mem, PhiNode* use_phi) const {\n+    \/\/ def_mem is one of the inputs of use_phi and at least one input of use_phi is\n+    \/\/ not def_mem. It's however possible that use_phi has def_mem as input multiple\n+    \/\/ times. If that happens, use_phi is recorded as a use of def_mem multiple\n+    \/\/ times as well. When PhaseCFG::insert_anti_dependences() goes over\n+    \/\/ uses of def_mem and enqueues them for processing, use_phi would then be\n+    \/\/ enqueued for processing multiple times when it only needs to be\n+    \/\/ processed once. The code below checks if use_phi as a use of def_mem was\n+    \/\/ already enqueued to avoid redundant processing of use_phi.\n+    int j = _queue.length()-1;\n+    \/\/ If there are any use of def_mem already enqueued, they were enqueued\n+    \/\/ last (all use of def_mem are processed in one go).\n+    for (; j >= 0; j--) {\n+      const MemStorePair& mem_store_pair = _queue.at(j);\n+      if (mem_store_pair.mem() != def_mem) {\n+        \/\/ We're done with the uses of def_mem\n+        break;\n+      }\n+      if (mem_store_pair.store() == use_phi) {\n+        return true;\n+      }\n+    }\n+#ifdef ASSERT\n+    for (; j >= 0; j--) {\n+      const MemStorePair& mem_store_pair = _queue.at(j);\n+      assert(mem_store_pair.mem() != def_mem, \"Should be done with the uses of def_mem\");\n@@ -590,0 +620,7 @@\n+#endif\n+    return false;\n+  }\n+\n+public:\n+  MemStoreQueue(ResourceArea* area) :\n+          _worklist_visited((area)) {\n@@ -591,2 +628,37 @@\n-  return false;\n-}\n+\n+  void push(Node* mem, Node* store) {\n+    if (store->is_MergeMem()) {\n+      \/\/ Be sure we don't get into combinatorial problems.\n+      \/\/ (Allow phis to be repeated; they can merge two relevant states.)\n+      uint j = _worklist_visited.size();\n+      for (; j > 0; j--) {\n+        if (_worklist_visited.at(j-1) == store)  return; \/\/ already on work list; do not repeat\n+      }\n+      _worklist_visited.push(store);\n+    } else if (store->is_Phi()) {\n+      \/\/ A Phi could have the same mem as input multiple times. If that's the case, we don't need to enqueue it\n+      \/\/ more than once.\n+      if (already_enqueued(mem, store->as_Phi())) {\n+        return;\n+      }\n+    }\n+\n+    _queue.push(MemStorePair(mem, store));\n+  }\n+\n+  bool is_nonempty() const {\n+    return _queue.is_nonempty();\n+  }\n+\n+  Node* top_mem() const {\n+    return _queue.top().mem();\n+  }\n+\n+  Node* top_store() const {\n+    return _queue.top().store();\n+  }\n+\n+  void pop() {\n+    _queue.pop();\n+  }\n+};\n@@ -658,4 +730,2 @@\n-  ResourceArea *area = Thread::current()->resource_area();\n-  Node_List worklist_mem(area);     \/\/ prior memory state to store\n-  Node_List worklist_store(area);   \/\/ possible-def to explore\n-  Node_List worklist_visited(area); \/\/ visited mergemem nodes\n+  ResourceArea* area = Thread::current()->resource_area();\n+  MemStoreQueue worklist_mem_store(area); \/\/ prior memory state to store and possible-def to explore\n@@ -681,4 +751,2 @@\n-  worklist_store.push(initial_mem);\n-  worklist_visited.push(initial_mem);\n-  worklist_mem.push(nullptr);\n-  while (worklist_store.size() > 0) {\n+  worklist_mem_store.push(nullptr, initial_mem);\n+  while (worklist_mem_store.is_nonempty()) {\n@@ -686,2 +754,4 @@\n-    Node* mem   = worklist_mem.pop();\n-    Node* store = worklist_store.pop();\n+    Node* mem   = worklist_mem_store.top_mem();\n+    Node* store = worklist_mem_store.top_store();\n+    worklist_mem_store.pop();\n+\n@@ -707,18 +777,1 @@\n-        if (store->is_MergeMem()) {\n-          \/\/ Be sure we don't get into combinatorial problems.\n-          \/\/ (Allow phis to be repeated; they can merge two relevant states.)\n-          uint j = worklist_visited.size();\n-          for (; j > 0; j--) {\n-            if (worklist_visited.at(j-1) == store)  break;\n-          }\n-          if (j > 0)  continue; \/\/ already on work list; do not repeat\n-          worklist_visited.push(store);\n-        } else if (store->is_Phi()) {\n-          \/\/ A Phi could have the same mem as input multiple times. If that's the case, we don't need to enqueue it\n-          \/\/ more than once.\n-          if (already_enqueued(worklist_mem, worklist_store, mem, store->as_Phi())) {\n-            continue;\n-          }\n-        }\n-        worklist_mem.push(mem);\n-        worklist_store.push(store);\n+        worklist_mem_store.push(mem, store);\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":106,"deletions":53,"binary":false,"changes":159,"status":"modified"}]}