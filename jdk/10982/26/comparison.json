{"files":[{"patch":"@@ -595,1 +595,10 @@\n-  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native\n+  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native \\\n+        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.jdktypes=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\n","filename":"make\/RunTests.gmk","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-JAVAC_FLAGS += -XDstringConcat=inline\n+JAVAC_FLAGS += -XDstringConcat=inline \\\n+    --enable-preview\n+DISABLED_WARNINGS_java += preview\n@@ -36,1 +38,3 @@\n-EXCLUDES += java\/lang\/doc-files\n+EXCLUDES += java\/lang\/doc-files \\\n+    jdk\/internal\/classfile\/snippet-files \\\n+    jdk\/internal\/classfile\/components\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,0 +99,9 @@\n+        --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.jdktypes=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.impl=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.Set;\n+import jdk.internal.classfile.impl.AccessFlagsImpl;\n+import java.lang.reflect.AccessFlag;\n+\n+\/**\n+ * Models the access flags for a class, method, or field.  Delivered as a\n+ *  {@link jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.FieldElement}, or\n+ *  {@link jdk.internal.classfile.MethodElement} when traversing\n+ *  the corresponding model type.\n+ *\/\n+public sealed interface AccessFlags\n+        extends ClassElement, MethodElement, FieldElement\n+        permits AccessFlagsImpl {\n+\n+    \/**\n+     * {@return the access flags, as a bit mask}\n+     *\/\n+    int flagsMask();\n+\n+    \/**\n+     * {@return the access flags}\n+     *\/\n+    Set<AccessFlag> flags();\n+\n+    \/**\n+     * {@return whether the specified flag is present}  The specified flag\n+     * should be a valid flag for the classfile location associated with this\n+     * element.\n+     * @param flag the flag to test\n+     *\/\n+    boolean has(AccessFlag flag);\n+\n+    \/**\n+     * {@return the classfile location for this element, which is either class,\n+     * method, or field}\n+     *\/\n+    AccessFlag.Location location();\n+\n+    \/**\n+     * {@return an {@linkplain AccessFlags} for a class}\n+     * @param mask the flags to be set, as a bit mask\n+     *\/\n+    static AccessFlags ofClass(int mask) {\n+        return new AccessFlagsImpl(AccessFlag.Location.CLASS, mask);\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain AccessFlags} for a class}\n+     * @param flags the flags to be set\n+     *\/\n+    static AccessFlags ofClass(AccessFlag... flags) {\n+        return new AccessFlagsImpl(AccessFlag.Location.CLASS, flags);\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain AccessFlags} for a field}\n+     * @param mask the flags to be set, as a bit mask\n+     *\/\n+    static AccessFlags ofField(int mask) {\n+        return new AccessFlagsImpl(AccessFlag.Location.FIELD, mask);\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain AccessFlags} for a field}\n+     * @param flags the flags to be set\n+     *\/\n+    static AccessFlags ofField(AccessFlag... flags) {\n+        return new AccessFlagsImpl(AccessFlag.Location.FIELD, flags);\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain AccessFlags} for a method}\n+     * @param mask the flags to be set, as a bit mask\n+     *\/\n+    static AccessFlags ofMethod(int mask) {\n+        return new AccessFlagsImpl(AccessFlag.Location.METHOD, mask);\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain AccessFlags} for a method}\n+     * @param flags the flags to be set\n+     *\/\n+    static AccessFlags ofMethod(AccessFlag... flags) {\n+        return new AccessFlagsImpl(AccessFlag.Location.METHOD, flags);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AccessFlags.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AnnotationImpl;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+\n+\/**\n+ * Models an annotation on a declaration.\n+ *\n+ * @see AnnotationElement\n+ * @see AnnotationValue\n+ * @see RuntimeVisibleAnnotationsAttribute\n+ * @see RuntimeInvisibleAnnotationsAttribute\n+ * @see RuntimeVisibleParameterAnnotationsAttribute\n+ * @see RuntimeInvisibleParameterAnnotationsAttribute\n+ *\/\n+public sealed interface Annotation\n+        extends WritableElement<Annotation>\n+        permits TypeAnnotation, AnnotationImpl {\n+\n+    \/**\n+     * {@return the class of the annotation}\n+     *\/\n+    Utf8Entry className();\n+\n+    \/**\n+     * {@return the class of the annotation, as a symbolic descriptor}\n+     *\/\n+    default ClassDesc classSymbol() {\n+        return ClassDesc.ofDescriptor(className().stringValue());\n+    }\n+\n+    \/**\n+     * {@return the elements of the annotation}\n+     *\/\n+    List<AnnotationElement> elements();\n+\n+    \/**\n+     * {@return an annotation}\n+     * @param annotationClass the class of the annotation\n+     * @param elements the elements of the annotation\n+     *\/\n+    static Annotation of(Utf8Entry annotationClass,\n+                         List<AnnotationElement> elements) {\n+        return new AnnotationImpl(annotationClass, elements);\n+    }\n+\n+    \/**\n+     * {@return an annotation}\n+     * @param annotationClass the class of the annotation\n+     * @param elements the elements of the annotation\n+     *\/\n+    static Annotation of(Utf8Entry annotationClass,\n+                         AnnotationElement... elements) {\n+        return of(annotationClass, List.of(elements));\n+    }\n+\n+    \/**\n+     * {@return an annotation}\n+     * @param annotationClass the class of the annotation\n+     * @param elements the elements of the annotation\n+     *\/\n+    static Annotation of(ClassDesc annotationClass,\n+                         List<AnnotationElement> elements) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), elements);\n+    }\n+\n+    \/**\n+     * {@return an annotation}\n+     * @param annotationClass the class of the annotation\n+     * @param elements the elements of the annotation\n+     *\/\n+    static Annotation of(ClassDesc annotationClass,\n+                         AnnotationElement... elements) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), elements);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Annotation.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AnnotationImpl;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+\/**\n+ * Models a key-value pair of an annotation.\n+ *\n+ * @see Annotation\n+ * @see AnnotationValue\n+ *\/\n+public sealed interface AnnotationElement\n+        extends WritableElement<AnnotationElement>\n+        permits AnnotationImpl.AnnotationElementImpl {\n+\n+    \/**\n+     * {@return the element name}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the element value}\n+     *\/\n+    AnnotationValue value();\n+\n+    \/**\n+     * {@return an annotation key-value pair}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement of(Utf8Entry name,\n+                                AnnotationValue value) {\n+        return new AnnotationImpl.AnnotationElementImpl(name, value);\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement of(String name,\n+                                AnnotationValue value) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(name), value);\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a class-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofClass(String name,\n+                                     ClassDesc value) {\n+        return of(name, AnnotationValue.ofClass(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a string-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofString(String name,\n+                                      String value) {\n+        return of(name, AnnotationValue.ofString(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a long-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofLong(String name,\n+                                    long value) {\n+        return of(name, AnnotationValue.ofLong(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for an int-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofInt(String name,\n+                                   int value) {\n+        return of(name, AnnotationValue.ofInt(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a char-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofChar(String name,\n+                                    char value) {\n+        return of(name, AnnotationValue.ofChar(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a short-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofShort(String name,\n+                                     short value) {\n+        return of(name, AnnotationValue.ofShort(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a byte-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofByte(String name,\n+                                      byte value) {\n+        return of(name, AnnotationValue.ofByte(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a boolean-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofBoolean(String name,\n+                                      boolean value) {\n+        return of(name, AnnotationValue.ofBoolean(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a double-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofDouble(String name,\n+                                      double value) {\n+        return of(name, AnnotationValue.ofDouble(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for a float-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofFloat(String name,\n+                                     float value) {\n+        return of(name, AnnotationValue.ofFloat(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for an annotation-valued annotation}\n+     * @param name the name of the key\n+     * @param value the associated value\n+     *\/\n+    static AnnotationElement ofAnnotation(String name,\n+                                          Annotation value) {\n+        return of(name, AnnotationValue.ofAnnotation(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation key-value pair for an array-valued annotation}\n+     * @param name the name of the key\n+     * @param values the associated values\n+     *\/\n+    static AnnotationElement ofArray(String name,\n+                                     AnnotationValue... values) {\n+        return of(name, AnnotationValue.ofArray(values));\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AnnotationElement.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,467 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.constantpool.AnnotationConstantValueEntry;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.FloatEntry;\n+import jdk.internal.classfile.constantpool.IntegerEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AnnotationImpl;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Models the value of a key-value pair of an annotation.\n+ *\n+ * @see Annotation\n+ * @see AnnotationElement\n+ *\/\n+\n+public sealed interface AnnotationValue extends WritableElement<AnnotationValue>\n+        permits AnnotationValue.OfAnnotation, AnnotationValue.OfArray,\n+                AnnotationValue.OfConstant, AnnotationValue.OfClass,\n+                AnnotationValue.OfEnum {\n+\n+    \/** Models an annotation-valued element *\/\n+    sealed interface OfAnnotation extends AnnotationValue\n+            permits AnnotationImpl.OfAnnotationImpl {\n+        \/** {@return the annotation} *\/\n+        Annotation annotation();\n+    }\n+\n+    \/** Models an array-valued element *\/\n+    sealed interface OfArray extends AnnotationValue\n+            permits AnnotationImpl.OfArrayImpl {\n+        \/** {@return the values} *\/\n+        List<AnnotationValue> values();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfConstant extends AnnotationValue\n+            permits AnnotationValue.OfString, AnnotationValue.OfDouble,\n+                    AnnotationValue.OfFloat, AnnotationValue.OfLong,\n+                    AnnotationValue.OfInteger, AnnotationValue.OfShort,\n+                    AnnotationValue.OfCharacter, AnnotationValue.OfByte,\n+                    AnnotationValue.OfBoolean, AnnotationImpl.OfConstantImpl {\n+        \/** {@return the constant} *\/\n+        AnnotationConstantValueEntry constant();\n+        \/** {@return the constant} *\/\n+        ConstantDesc constantValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfString extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfStringImpl {\n+        \/** {@return the constant} *\/\n+        String stringValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfDouble extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfDoubleImpl {\n+        \/** {@return the constant} *\/\n+        double doubleValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfFloat extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfFloatImpl {\n+        \/** {@return the constant} *\/\n+        float floatValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfLong extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfLongImpl {\n+        \/** {@return the constant} *\/\n+        long longValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfInteger extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfIntegerImpl {\n+        \/** {@return the constant} *\/\n+        int intValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfShort extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfShortImpl {\n+        \/** {@return the constant} *\/\n+        short shortValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfCharacter extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfCharacterImpl {\n+        \/** {@return the constant} *\/\n+        char charValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfByte extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfByteImpl {\n+        \/** {@return the constant} *\/\n+        byte byteValue();\n+    }\n+\n+    \/** Models a constant-valued element *\/\n+    sealed interface OfBoolean extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfBooleanImpl {\n+        \/** {@return the constant} *\/\n+        boolean booleanValue();\n+    }\n+\n+    \/** Models a class-valued element *\/\n+    sealed interface OfClass extends AnnotationValue\n+            permits AnnotationImpl.OfClassImpl {\n+        \/** {@return the class name} *\/\n+        Utf8Entry className();\n+\n+        \/** {@return the class symbol} *\/\n+        default ClassDesc classSymbol() {\n+            return ClassDesc.ofDescriptor(className().stringValue());\n+        }\n+    }\n+\n+    \/** Models an enum-valued element *\/\n+    sealed interface OfEnum extends AnnotationValue\n+            permits AnnotationImpl.OfEnumImpl {\n+        \/** {@return the enum class name} *\/\n+        Utf8Entry className();\n+\n+        \/** {@return the enum class symbol} *\/\n+        default ClassDesc classSymbol() {\n+            return ClassDesc.ofDescriptor(className().stringValue());\n+        }\n+\n+        \/** {@return the enum constant name} *\/\n+        Utf8Entry constantName();\n+    }\n+\n+    \/**\n+     * @return the tag character for this type as per {@jvms 4.7.16.1}\n+     *\/\n+    char tag();\n+\n+    \/**\n+     * {@return an annotation element for a enum-valued element}\n+     * @param className the name of the enum class\n+     * @param constantName the name of the enum constant\n+     *\/\n+    static OfEnum ofEnum(Utf8Entry className,\n+                         Utf8Entry constantName) {\n+        return new AnnotationImpl.OfEnumImpl(className, constantName);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a enum-valued element}\n+     * @param className the name of the enum class\n+     * @param constantName the name of the enum constant\n+     *\/\n+    static OfEnum ofEnum(ClassDesc className, String constantName) {\n+        return ofEnum(TemporaryConstantPool.INSTANCE.utf8Entry(className.descriptorString()),\n+                      TemporaryConstantPool.INSTANCE.utf8Entry(constantName));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a class-valued element}\n+     * @param className the name of the enum class\n+     *\/\n+    static OfClass ofClass(Utf8Entry className) {\n+        return new AnnotationImpl.OfClassImpl(className);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a class-valued element}\n+     * @param className the name of the enum class\n+     *\/\n+    static OfClass ofClass(ClassDesc className) {\n+        return ofClass(TemporaryConstantPool.INSTANCE.utf8Entry(className.descriptorString()));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a string-valued element}\n+     * @param value the string\n+     *\/\n+    static OfConstant ofString(Utf8Entry value) {\n+        return new AnnotationImpl.OfStringImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a string-valued element}\n+     * @param value the string\n+     *\/\n+    static OfConstant ofString(String value) {\n+        return ofString(TemporaryConstantPool.INSTANCE.utf8Entry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a double-valued element}\n+     * @param value the double value\n+     *\/\n+    static OfConstant ofDouble(DoubleEntry value) {\n+        return new AnnotationImpl.OfDoubleImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a double-valued element}\n+     * @param value the double value\n+     *\/\n+    static OfConstant ofDouble(double value) {\n+        return ofDouble(TemporaryConstantPool.INSTANCE.doubleEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a float-valued element}\n+     * @param value the float value\n+     *\/\n+    static OfConstant ofFloat(FloatEntry value) {\n+        return new AnnotationImpl.OfFloatImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a float-valued element}\n+     * @param value the float value\n+     *\/\n+    static OfConstant ofFloat(float value) {\n+        return ofFloat(TemporaryConstantPool.INSTANCE.floatEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a long-valued element}\n+     * @param value the long value\n+     *\/\n+    static OfConstant ofLong(LongEntry value) {\n+        return new AnnotationImpl.OfLongImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a long-valued element}\n+     * @param value the long value\n+     *\/\n+    static OfConstant ofLong(long value) {\n+        return ofLong(TemporaryConstantPool.INSTANCE.longEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for an int-valued element}\n+     * @param value the int value\n+     *\/\n+    static OfConstant ofInt(IntegerEntry value) {\n+        return new AnnotationImpl.OfIntegerImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for an int-valued element}\n+     * @param value the int value\n+     *\/\n+    static OfConstant ofInt(int value) {\n+        return ofInt(TemporaryConstantPool.INSTANCE.intEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a short-valued element}\n+     * @param value the short value\n+     *\/\n+    static OfConstant ofShort(IntegerEntry value) {\n+        return new AnnotationImpl.OfShortImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a short-valued element}\n+     * @param value the short value\n+     *\/\n+    static OfConstant ofShort(short value) {\n+        return ofShort(TemporaryConstantPool.INSTANCE.intEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a char-valued element}\n+     * @param value the char value\n+     *\/\n+    static OfConstant ofChar(IntegerEntry value) {\n+        return new AnnotationImpl.OfCharacterImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a char-valued element}\n+     * @param value the char value\n+     *\/\n+    static OfConstant ofChar(char value) {\n+        return ofChar(TemporaryConstantPool.INSTANCE.intEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a byte-valued element}\n+     * @param value the byte value\n+     *\/\n+    static OfConstant ofByte(IntegerEntry value) {\n+        return new AnnotationImpl.OfByteImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a byte-valued element}\n+     * @param value the byte value\n+     *\/\n+    static OfConstant ofByte(byte value) {\n+        return ofByte(TemporaryConstantPool.INSTANCE.intEntry(value));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a boolean-valued element}\n+     * @param value the boolean value\n+     *\/\n+    static OfConstant ofBoolean(IntegerEntry value) {\n+        return new AnnotationImpl.OfBooleanImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for a boolean-valued element}\n+     * @param value the boolean value\n+     *\/\n+    static OfConstant ofBoolean(boolean value) {\n+        int i = value ? 1 : 0;\n+        return ofBoolean(TemporaryConstantPool.INSTANCE.intEntry(i));\n+    }\n+\n+    \/**\n+     * {@return an annotation element for an annotation-valued element}\n+     * @param value the annotation\n+     *\/\n+    static OfAnnotation ofAnnotation(Annotation value) {\n+        return new AnnotationImpl.OfAnnotationImpl(value);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for an array-valued element}\n+     * @param values the values\n+     *\/\n+    static OfArray ofArray(List<AnnotationValue> values) {\n+        return new AnnotationImpl.OfArrayImpl(values);\n+    }\n+\n+    \/**\n+     * {@return an annotation element for an array-valued element}\n+     * @param values the values\n+     *\/\n+    static OfArray ofArray(AnnotationValue... values) {\n+        return ofArray(List.of(values));\n+    }\n+\n+    \/**\n+     * {@return an annotation element}  The {@code value} parameter must be\n+     * a primitive, a String, a ClassDesc, an enum constant, or an array of\n+     * one of these.\n+     *\n+     * @param value the annotation value\n+     *\/\n+    static AnnotationValue of(Object value) {\n+        if (value instanceof String s) {\n+            return ofString(s);\n+        } else if (value instanceof Byte b) {\n+            return ofByte(b);\n+        } else if (value instanceof Boolean b) {\n+            return ofBoolean(b);\n+        } else if (value instanceof Short s) {\n+            return ofShort(s);\n+        } else if (value instanceof Character c) {\n+            return ofChar(c);\n+        } else if (value instanceof Integer i) {\n+            return ofInt(i);\n+        } else if (value instanceof Long l) {\n+            return ofLong(l);\n+        } else if (value instanceof Float f) {\n+            return ofFloat(f);\n+        } else if (value instanceof Double d) {\n+            return ofDouble(d);\n+        } else if (value instanceof ClassDesc clsDesc) {\n+            return ofClass(clsDesc);\n+        } else if (value instanceof byte[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofByte(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof boolean[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofBoolean(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof short[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofShort(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof char[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofChar(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof int[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofInt(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof long[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofLong(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof float[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofFloat(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof double[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(ofDouble(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof Object[] arr) {\n+            var els = new ArrayList<AnnotationValue>(arr.length);\n+            for (var el : arr) {\n+                els.add(of(el));\n+            }\n+            return ofArray(els);\n+        } else if (value instanceof Enum<?> e) {\n+            return ofEnum(ClassDesc.ofDescriptor(e.getDeclaringClass().descriptorString()), e.name());\n+        }\n+        throw new IllegalArgumentException(\"Illegal annotation constant value type \" + value.getClass());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AnnotationValue.java","additions":467,"deletions":0,"binary":false,"changes":467,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.CompilationIDAttribute;\n+import jdk.internal.classfile.attribute.ConstantValueAttribute;\n+import jdk.internal.classfile.attribute.DeprecatedAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableTableAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.attribute.SourceIDAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.attribute.SyntheticAttribute;\n+import jdk.internal.classfile.attribute.UnknownAttribute;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a classfile attribute {@jvms 4.7}.  Many, though not all, subtypes of\n+ * {@linkplain Attribute} will implement {@link ClassElement}, {@link\n+ * MethodElement}, {@link FieldElement}, or {@link CodeElement}; attributes that\n+ * are also elements will be delivered when traversing the elements of the\n+ * corresponding model type. Additionally, all attributes are accessible\n+ * directly from the corresponding model type through {@link\n+ * AttributedElement#findAttribute(AttributeMapper)}.\n+ *\/\n+public sealed interface Attribute<A extends Attribute<A>>\n+        extends WritableElement<A>\n+        permits AnnotationDefaultAttribute, BootstrapMethodsAttribute,\n+                CharacterRangeTableAttribute, CodeAttribute, CompilationIDAttribute,\n+                ConstantValueAttribute, DeprecatedAttribute, EnclosingMethodAttribute,\n+                ExceptionsAttribute, InnerClassesAttribute, LineNumberTableAttribute,\n+                LocalVariableTableAttribute, LocalVariableTypeTableAttribute,\n+                MethodParametersAttribute, ModuleAttribute, ModuleHashesAttribute,\n+                ModuleMainClassAttribute, ModulePackagesAttribute, ModuleResolutionAttribute,\n+                ModuleTargetAttribute, NestHostAttribute, NestMembersAttribute,\n+                PermittedSubclassesAttribute,\n+                RecordAttribute, RuntimeInvisibleAnnotationsAttribute,\n+                RuntimeInvisibleParameterAnnotationsAttribute, RuntimeInvisibleTypeAnnotationsAttribute,\n+                RuntimeVisibleAnnotationsAttribute, RuntimeVisibleParameterAnnotationsAttribute,\n+                RuntimeVisibleTypeAnnotationsAttribute, SignatureAttribute,\n+                SourceDebugExtensionAttribute, SourceFileAttribute, SourceIDAttribute,\n+                StackMapTableAttribute, SyntheticAttribute,\n+                UnknownAttribute, BoundAttribute, UnboundAttribute {\n+    \/**\n+     * {@return the name of the attribute}\n+     *\/\n+    String attributeName();\n+\n+    \/**\n+     * {@return the {@link AttributeMapper} associated with this attribute}\n+     *\/\n+    AttributeMapper<A> attributeMapper();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Attribute.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Bidirectional mapper between the classfile representation of an attribute and\n+ * how that attribute is modeled in the API.  The attribute mapper is used\n+ * to parse the classfile representation into a model, and to write the model\n+ * representation back to a classfile.  For each standard attribute, there is a\n+ * predefined attribute mapper defined in {@link Attributes}. For nonstandard\n+ * attributes, clients can define their own {@linkplain AttributeMapper}.\n+ * Classes that model nonstandard attributes should extend {@link\n+ * CustomAttribute}.\n+ *\/\n+public interface AttributeMapper<A> {\n+\n+    \/**\n+     * {@return the name of the attribute}\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Create an {@link Attribute} instance from a classfile.\n+     *\n+     * @param enclosing The class, method, field, or code attribute in which\n+     *                  this attribute appears\n+     * @param cf The {@link ClassReader} describing the classfile to read from\n+     * @param pos The offset into the classfile at which the attribute starts\n+     * @return the new attribute\n+     *\/\n+    A readAttribute(AttributedElement enclosing, ClassReader cf, int pos);\n+\n+    \/**\n+     * Write an {@link Attribute} instance to a classfile.\n+     *\n+     * @param buf The {@link BufWriter} to which the attribute should be written\n+     * @param attr The attribute to write\n+     *\/\n+    void writeAttribute(BufWriter buf, A attr);\n+\n+    \/**\n+     * {@return The earliest classfile version for which this attribute is\n+     * applicable}\n+     *\/\n+    default int validSince() {\n+        return Classfile.JAVA_1_VERSION;\n+    }\n+\n+    \/**\n+     * {@return whether this attribute may appear more than once in a given location}\n+     *\/\n+    default boolean allowMultiple() {\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AttributeMapper.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.impl.AbstractUnboundModel;\n+\n+\/**\n+ * A {@link ClassfileElement} describing an entity that has attributes, such\n+ * as a class, field, method, code attribute, or record component.\n+ *\/\n+public sealed interface AttributedElement extends ClassfileElement\n+        permits ClassModel, CodeModel, FieldModel, MethodModel,\n+                RecordComponentInfo, AbstractUnboundModel {\n+\n+    \/**\n+     * {@return the attributes of this element}\n+     *\/\n+    List<Attribute<?>> attributes();\n+\n+    \/**\n+     * Finds an attribute by name.\n+     * @param attr the attribute mapper\n+     * @param <T> the type of the attribute\n+     * @return the attribute, or an empty {@linkplain Optional} if the attribute\n+     * is not present\n+     *\/\n+    default <T extends Attribute<T>> Optional<T> findAttribute(AttributeMapper<T> attr) {\n+        for (Attribute<?> la : attributes()) {\n+            if (la.attributeMapper() == attr) {\n+                @SuppressWarnings(\"unchecked\")\n+                var res = Optional.of((T) la);\n+                return res;\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Finds one or more attributes by name.\n+     * @param attr the attribute mapper\n+     * @param <T> the type of the attribute\n+     * @return the attributes, or an empty {@linkplain List} if the attribute\n+     * is not present\n+     *\/\n+    default <T extends Attribute<T>> List<T> findAttributes(AttributeMapper<T> attr) {\n+        var list = new ArrayList<T>();\n+        for (var a : attributes()) {\n+            if (a.attributeMapper() == attr) {\n+                @SuppressWarnings(\"unchecked\")\n+                T t = (T)a;\n+                list.add(t);\n+            }\n+        }\n+        return list;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AttributedElement.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,786 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.attribute.CharacterRangeInfo;\n+import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.CompilationIDAttribute;\n+import jdk.internal.classfile.attribute.ConstantValueAttribute;\n+import jdk.internal.classfile.attribute.DeprecatedAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.LineNumberInfo;\n+import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableInfo;\n+import jdk.internal.classfile.attribute.LocalVariableTableAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n+import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n+import jdk.internal.classfile.attribute.MethodParameterInfo;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleHashInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModuleOpenInfo;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleProvideInfo;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.attribute.SourceIDAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.attribute.SyntheticAttribute;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractAttributeMapper;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.CodeImpl;\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.StackMapDecoder;\n+\n+\/**\n+ * Attribute mappers for standard classfile attributes.\n+ *\n+ * @see AttributeMapper\n+ *\/\n+public class Attributes {\n+    public static final String NAME_ANNOTATION_DEFAULT = \"AnnotationDefault\";\n+    public static final String NAME_BOOTSTRAP_METHODS = \"BootstrapMethods\";\n+    public static final String NAME_CHARACTER_RANGE_TABLE = \"CharacterRangeTable\";\n+    public static final String NAME_CODE = \"Code\";\n+    public static final String NAME_COMPILATION_ID = \"CompilationID\";\n+    public static final String NAME_CONSTANT_VALUE = \"ConstantValue\";\n+    public static final String NAME_DEPRECATED = \"Deprecated\";\n+    public static final String NAME_ENCLOSING_METHOD = \"EnclosingMethod\";\n+    public static final String NAME_EXCEPTIONS = \"Exceptions\";\n+    public static final String NAME_INNER_CLASSES = \"InnerClasses\";\n+    public static final String NAME_LINE_NUMBER_TABLE = \"LineNumberTable\";\n+    public static final String NAME_LOCAL_VARIABLE_TABLE = \"LocalVariableTable\";\n+    public static final String NAME_LOCAL_VARIABLE_TYPE_TABLE = \"LocalVariableTypeTable\";\n+    public static final String NAME_METHOD_PARAMETERS = \"MethodParameters\";\n+    public static final String NAME_MODULE = \"Module\";\n+    public static final String NAME_MODULE_HASHES = \"ModuleHashes\";\n+    public static final String NAME_MODULE_MAIN_CLASS = \"ModuleMainClass\";\n+    public static final String NAME_MODULE_PACKAGES = \"ModulePackages\";\n+    public static final String NAME_MODULE_RESOLUTION = \"ModuleResolution\";\n+    public static final String NAME_MODULE_TARGET = \"ModuleTarget\";\n+    public static final String NAME_NEST_HOST = \"NestHost\";\n+    public static final String NAME_NEST_MEMBERS = \"NestMembers\";\n+    public static final String NAME_PERMITTED_SUBCLASSES = \"PermittedSubclasses\";\n+    public static final String NAME_RECORD = \"Record\";\n+    public static final String NAME_RUNTIME_INVISIBLE_ANNOTATIONS = \"RuntimeInvisibleAnnotations\";\n+    public static final String NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = \"RuntimeInvisibleParameterAnnotations\";\n+    public static final String NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = \"RuntimeInvisibleTypeAnnotations\";\n+    public static final String NAME_RUNTIME_VISIBLE_ANNOTATIONS = \"RuntimeVisibleAnnotations\";\n+    public static final String NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = \"RuntimeVisibleParameterAnnotations\";\n+    public static final String NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS = \"RuntimeVisibleTypeAnnotations\";\n+    public static final String NAME_SIGNATURE = \"Signature\";\n+    public static final String NAME_SOURCE_DEBUG_EXTENSION = \"SourceDebugExtension\";\n+    public static final String NAME_SOURCE_FILE = \"SourceFile\";\n+    public static final String NAME_SOURCE_ID = \"SourceID\";\n+    public static final String NAME_STACK_MAP_TABLE = \"StackMapTable\";\n+    public static final String NAME_SYNTHETIC = \"Synthetic\";\n+\n+    private Attributes() {\n+    }\n+\n+    \/** Attribute mapper for the {@code AnnotationDefault} attribute *\/\n+    public static final AttributeMapper<AnnotationDefaultAttribute>\n+            ANNOTATION_DEFAULT = new AbstractAttributeMapper<>(NAME_ANNOTATION_DEFAULT, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public AnnotationDefaultAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundAnnotationDefaultAttr(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, AnnotationDefaultAttribute attr) {\n+                    attr.defaultValue().writeTo(buf);\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code BootstrapMethods} attribute *\/\n+    public static final AttributeMapper<BootstrapMethodsAttribute>\n+            BOOTSTRAP_METHODS = new AbstractAttributeMapper<>(NAME_BOOTSTRAP_METHODS, Classfile.JAVA_17_VERSION) {\n+                @Override\n+                public BootstrapMethodsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundBootstrapMethodsAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, BootstrapMethodsAttribute attr) {\n+                    buf.writeList(attr.bootstrapMethods());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code CharacterRangeTable} attribute *\/\n+    public static final AttributeMapper<CharacterRangeTableAttribute>\n+            CHARACTER_RANGE_TABLE = new AbstractAttributeMapper<>(NAME_CHARACTER_RANGE_TABLE, true, Classfile.JAVA_4_VERSION) {\n+                @Override\n+                public CharacterRangeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundCharacterRangeTableAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+                    List<CharacterRangeInfo> ranges = attr.characterRangeTable();\n+                    buf.writeU2(ranges.size());\n+                    for (CharacterRangeInfo info : ranges) {\n+                        buf.writeU2(info.startPc());\n+                        buf.writeU2(info.endPc());\n+                        buf.writeInt(info.characterRangeStart());\n+                        buf.writeInt(info.characterRangeEnd());\n+                        buf.writeU2(info.flags());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Code} attribute *\/\n+    public static final AttributeMapper<CodeAttribute>\n+            CODE = new AbstractAttributeMapper<>(NAME_CODE) {\n+                @Override\n+                public CodeAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new CodeImpl(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, CodeAttribute attr) {\n+                    throw new UnsupportedOperationException(\"Code attribute does not support direct write\");\n+                }\n+            };\n+\n+\n+    \/** Attribute mapper for the {@code CompilationID} attribute *\/\n+    public static final AttributeMapper<CompilationIDAttribute>\n+            COMPILATION_ID = new AbstractAttributeMapper<>(NAME_COMPILATION_ID, true) {\n+                @Override\n+                public CompilationIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundCompilationIDAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, CompilationIDAttribute attr) {\n+                    buf.writeIndex(attr.compilationId());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code ConstantValue} attribute *\/\n+    public static final AttributeMapper<ConstantValueAttribute>\n+            CONSTANT_VALUE = new AbstractAttributeMapper<>(NAME_CONSTANT_VALUE) {\n+                @Override\n+                public ConstantValueAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundConstantValueAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ConstantValueAttribute attr) {\n+                    buf.writeIndex(attr.constant());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Deprecated} attribute *\/\n+    public static final AttributeMapper<DeprecatedAttribute>\n+            DEPRECATED = new AbstractAttributeMapper<>(NAME_DEPRECATED, true) {\n+                @Override\n+                public DeprecatedAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundDeprecatedAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, DeprecatedAttribute attr) {\n+                    \/\/ empty\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code EnclosingMethod} attribute *\/\n+    public static final AttributeMapper<EnclosingMethodAttribute>\n+            ENCLOSING_METHOD = new AbstractAttributeMapper<>(NAME_ENCLOSING_METHOD, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public EnclosingMethodAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundEnclosingMethodAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n+                    buf.writeIndex(attr.enclosingClass());\n+                    buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Exceptions} attribute *\/\n+    public static final AttributeMapper<ExceptionsAttribute>\n+            EXCEPTIONS = new AbstractAttributeMapper<>(NAME_EXCEPTIONS) {\n+                @Override\n+                public ExceptionsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundExceptionsAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ExceptionsAttribute attr) {\n+                    buf.writeListIndices(attr.exceptions());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code InnerClasses} attribute *\/\n+    public static final AttributeMapper<InnerClassesAttribute>\n+            INNER_CLASSES = new AbstractAttributeMapper<>(NAME_INNER_CLASSES) {\n+                @Override\n+                public InnerClassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundInnerClassesAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+                    List<InnerClassInfo> classes = attr.classes();\n+                    buf.writeU2(classes.size());\n+                    for (InnerClassInfo ic : classes) {\n+                        buf.writeIndex(ic.innerClass());\n+                        buf.writeIndexOrZero(ic.outerClass().orElse(null));\n+                        buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                        buf.writeU2(ic.flagsMask());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code LineNumberTable} attribute *\/\n+    public static final AttributeMapper<LineNumberTableAttribute>\n+            LINE_NUMBER_TABLE = new AbstractAttributeMapper<>(NAME_LINE_NUMBER_TABLE, true) {\n+                @Override\n+                public LineNumberTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundLineNumberTableAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+                    List<LineNumberInfo> lines = attr.lineNumbers();\n+                    buf.writeU2(lines.size());\n+                    for (LineNumberInfo line : lines) {\n+                        buf.writeU2(line.startPc());\n+                        buf.writeU2(line.lineNumber());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code LocalVariableTable} attribute *\/\n+    public static final AttributeMapper<LocalVariableTableAttribute>\n+            LOCAL_VARIABLE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TABLE, true) {\n+                @Override\n+                public LocalVariableTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundLocalVariableTableAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+                    List<LocalVariableInfo> infos = attr.localVariables();\n+                    buf.writeU2(infos.size());\n+                    for (LocalVariableInfo info : infos) {\n+                        buf.writeU2(info.startPc());\n+                        buf.writeU2(info.length());\n+                        buf.writeIndex(info.name());\n+                        buf.writeIndex(info.type());\n+                        buf.writeU2(info.slot());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code LocalVariableTypeTable} attribute *\/\n+    public static final AttributeMapper<LocalVariableTypeTableAttribute>\n+            LOCAL_VARIABLE_TYPE_TABLE = new AbstractAttributeMapper<>(NAME_LOCAL_VARIABLE_TYPE_TABLE, true, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public LocalVariableTypeTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundLocalVariableTypeTableAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+                    List<LocalVariableTypeInfo> infos = attr.localVariableTypes();\n+                    buf.writeU2(infos.size());\n+                    for (LocalVariableTypeInfo info : infos) {\n+                        buf.writeU2(info.startPc());\n+                        buf.writeU2(info.length());\n+                        buf.writeIndex(info.name());\n+                        buf.writeIndex(info.signature());\n+                        buf.writeU2(info.slot());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code MethodParameters} attribute *\/\n+    public static final AttributeMapper<MethodParametersAttribute>\n+            METHOD_PARAMETERS = new AbstractAttributeMapper<>(NAME_METHOD_PARAMETERS, Classfile.JAVA_8_VERSION) {\n+                @Override\n+                public MethodParametersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundMethodParametersAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+                    List<MethodParameterInfo> parameters = attr.parameters();\n+                    buf.writeU1(parameters.size());\n+                    for (MethodParameterInfo info : parameters) {\n+                        buf.writeIndexOrZero(info.name().orElse(null));\n+                        buf.writeU2(info.flagsMask());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Module} attribute *\/\n+    public static final AttributeMapper<ModuleAttribute>\n+            MODULE = new AbstractAttributeMapper<>(NAME_MODULE, Classfile.JAVA_9_VERSION) {\n+        @Override\n+        public ModuleAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+            return new BoundAttribute.BoundModuleAttribute(e, cf, this, p);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n+            buf.writeIndex(attr.moduleName());\n+            buf.writeU2(attr.moduleFlagsMask());\n+            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+            buf.writeU2(attr.requires().size());\n+            for (ModuleRequireInfo require : attr.requires()) {\n+                buf.writeIndex(require.requires());\n+                buf.writeU2(require.requiresFlagsMask());\n+                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+            }\n+            buf.writeU2(attr.exports().size());\n+            for (ModuleExportInfo export : attr.exports()) {\n+                buf.writeIndex(export.exportedPackage());\n+                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeListIndices(export.exportsTo());\n+            }\n+            buf.writeU2(attr.opens().size());\n+            for (ModuleOpenInfo open : attr.opens()) {\n+                buf.writeIndex(open.openedPackage());\n+                buf.writeU2(open.opensFlagsMask());\n+                buf.writeListIndices(open.opensTo());\n+            }\n+            buf.writeListIndices(attr.uses());\n+            buf.writeU2(attr.provides().size());\n+            for (ModuleProvideInfo provide : attr.provides()) {\n+                buf.writeIndex(provide.provides());\n+                buf.writeListIndices(provide.providesWith());\n+            }\n+        }\n+    };\n+\n+    \/** Attribute mapper for the {@code ModuleHashes} attribute *\/\n+    public static final AttributeMapper<ModuleHashesAttribute>\n+            MODULE_HASHES = new AbstractAttributeMapper<>(NAME_MODULE_HASHES, Classfile.JAVA_9_VERSION) {\n+                @Override\n+                public ModuleHashesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundModuleHashesAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n+                    buf.writeIndex(attr.algorithm());\n+                    List<ModuleHashInfo> hashes = attr.hashes();\n+                    buf.writeU2(hashes.size());\n+                    for (ModuleHashInfo hash : hashes) {\n+                        buf.writeIndex(hash.moduleName());\n+                        buf.writeU2(hash.hash().length);\n+                        buf.writeBytes(hash.hash());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code ModuleMainClass} attribute *\/\n+    public static final AttributeMapper<ModuleMainClassAttribute>\n+            MODULE_MAIN_CLASS = new AbstractAttributeMapper<>(NAME_MODULE_MAIN_CLASS, Classfile.JAVA_9_VERSION) {\n+                @Override\n+                public ModuleMainClassAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundModuleMainClassAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ModuleMainClassAttribute attr) {\n+                    buf.writeIndex(attr.mainClass());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code ModulePackages} attribute *\/\n+    public static final AttributeMapper<ModulePackagesAttribute>\n+            MODULE_PACKAGES = new AbstractAttributeMapper<>(NAME_MODULE_PACKAGES, Classfile.JAVA_9_VERSION) {\n+                @Override\n+                public ModulePackagesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundModulePackagesAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ModulePackagesAttribute attr) {\n+                    buf.writeListIndices(attr.packages());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code ModuleResolution} attribute *\/\n+    public static final AttributeMapper<ModuleResolutionAttribute>\n+            MODULE_RESOLUTION = new AbstractAttributeMapper<>(NAME_MODULE_RESOLUTION, true, Classfile.JAVA_9_VERSION) {\n+                @Override\n+                public ModuleResolutionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundModuleResolutionAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ModuleResolutionAttribute attr) {\n+                    buf.writeU2(attr.resolutionFlags());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code ModuleTarget} attribute *\/\n+    public static final AttributeMapper<ModuleTargetAttribute>\n+            MODULE_TARGET = new AbstractAttributeMapper<>(NAME_MODULE_TARGET, true, Classfile.JAVA_9_VERSION) {\n+                @Override\n+                public ModuleTargetAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundModuleTargetAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, ModuleTargetAttribute attr) {\n+                    buf.writeIndex(attr.targetPlatform());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code NestHost} attribute *\/\n+    public static final AttributeMapper<NestHostAttribute>\n+            NEST_HOST = new AbstractAttributeMapper<>(NAME_NEST_HOST, Classfile.JAVA_11_VERSION) {\n+                @Override\n+                public NestHostAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundNestHostAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, NestHostAttribute attr) {\n+                    buf.writeIndex(attr.nestHost());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code NestMembers} attribute *\/\n+    public static final AttributeMapper<NestMembersAttribute>\n+            NEST_MEMBERS = new AbstractAttributeMapper<>(NAME_NEST_MEMBERS, Classfile.JAVA_11_VERSION) {\n+                @Override\n+                public NestMembersAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundNestMembersAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, NestMembersAttribute attr) {\n+                    buf.writeListIndices(attr.nestMembers());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code PermittedSubclasses} attribute *\/\n+    public static final AttributeMapper<PermittedSubclassesAttribute>\n+            PERMITTED_SUBCLASSES = new AbstractAttributeMapper<>(NAME_PERMITTED_SUBCLASSES, Classfile.JAVA_15_VERSION) {\n+                @Override\n+                public PermittedSubclassesAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundPermittedSubclassesAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, PermittedSubclassesAttribute attr) {\n+                    buf.writeListIndices(attr.permittedSubclasses());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Record} attribute *\/\n+    public static final AttributeMapper<RecordAttribute>\n+            RECORD = new AbstractAttributeMapper<>(NAME_RECORD, Classfile.JAVA_16_VERSION) {\n+                @Override\n+                public RecordAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundRecordAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+                    List<RecordComponentInfo> components = attr.components();\n+                    buf.writeU2(components.size());\n+                    for (RecordComponentInfo info : components) {\n+                        buf.writeIndex(info.name());\n+                        buf.writeIndex(info.descriptor());\n+                        buf.writeList(info.attributes());\n+                    }\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code RuntimeInvisibleAnnotations} attribute *\/\n+    public static final AttributeMapper<RuntimeInvisibleAnnotationsAttribute>\n+            RUNTIME_INVISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public RuntimeInvisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                    return new BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute(cf, pos);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, RuntimeInvisibleAnnotationsAttribute attr) {\n+                    buf.writeList(attr.annotations());\n+                }\n+    };\n+\n+    \/** Attribute mapper for the {@code RuntimeInvisibleParameterAnnotations} attribute *\/\n+    public static final AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute>\n+            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public RuntimeInvisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, RuntimeInvisibleParameterAnnotationsAttribute attr) {\n+                    List<List<Annotation>> lists = attr.parameterAnnotations();\n+                    buf.writeU1(lists.size());\n+                    for (List<Annotation> list : lists)\n+                        buf.writeList(list);\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code RuntimeInvisibleTypeAnnotations} attribute *\/\n+    public static final AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute>\n+            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, Classfile.JAVA_8_VERSION) {\n+                @Override\n+                public RuntimeInvisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, RuntimeInvisibleTypeAnnotationsAttribute attr) {\n+                    buf.writeList(attr.annotations());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code RuntimeVisibleAnnotations} attribute *\/\n+    public static final AttributeMapper<RuntimeVisibleAnnotationsAttribute>\n+            RUNTIME_VISIBLE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+        @Override\n+        public RuntimeVisibleAnnotationsAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+            return new BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute(cf, pos);\n+        }\n+\n+        @Override\n+        protected void writeBody(BufWriter buf, RuntimeVisibleAnnotationsAttribute attr) {\n+            buf.writeList(attr.annotations());\n+        }\n+    };\n+\n+    \/** Attribute mapper for the {@code RuntimeVisibleParameterAnnotations} attribute *\/\n+    public static final AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute>\n+            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public RuntimeVisibleParameterAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, RuntimeVisibleParameterAnnotationsAttribute attr) {\n+                    List<List<Annotation>> lists = attr.parameterAnnotations();\n+                    buf.writeU1(lists.size());\n+                    for (List<Annotation> list : lists)\n+                        buf.writeList(list);\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code RuntimeVisibleTypeAnnotations} attribute *\/\n+    public static final AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute>\n+            RUNTIME_VISIBLE_TYPE_ANNOTATIONS = new AbstractAttributeMapper<>(NAME_RUNTIME_VISIBLE_TYPE_ANNOTATIONS, Classfile.JAVA_8_VERSION) {\n+                @Override\n+                public RuntimeVisibleTypeAnnotationsAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, RuntimeVisibleTypeAnnotationsAttribute attr) {\n+                    buf.writeList(attr.annotations());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code Signature} attribute *\/\n+    public static final AttributeMapper<SignatureAttribute>\n+            SIGNATURE = new AbstractAttributeMapper<>(NAME_SIGNATURE, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public SignatureAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundSignatureAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, SignatureAttribute attr) {\n+                    buf.writeIndex(attr.signature());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code SourceDebug} attribute *\/\n+    public static final AttributeMapper<SourceDebugExtensionAttribute>\n+            SOURCE_DEBUG_EXTENSION = new AbstractAttributeMapper<>(NAME_SOURCE_DEBUG_EXTENSION, Classfile.JAVA_5_VERSION) {\n+                @Override\n+                public SourceDebugExtensionAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundSourceDebugExtensionAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, SourceDebugExtensionAttribute attr) {\n+                    buf.writeBytes(attr.contents());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code SourceFile} attribute *\/\n+    public static final AttributeMapper<SourceFileAttribute>\n+            SOURCE_FILE = new AbstractAttributeMapper<>(NAME_SOURCE_FILE) {\n+                @Override\n+                public SourceFileAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundSourceFileAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, SourceFileAttribute attr) {\n+                    buf.writeIndex(attr.sourceFile());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code SourceID} attribute *\/\n+    public static final AttributeMapper<SourceIDAttribute>\n+            SOURCE_ID = new AbstractAttributeMapper<>(NAME_SOURCE_ID) {\n+                @Override\n+                public SourceIDAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundSourceIDAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, SourceIDAttribute attr) {\n+                    buf.writeIndex(attr.sourceId());\n+                }\n+            };\n+\n+    \/** Attribute mapper for the {@code StackMapTable} attribute *\/\n+    public static final AttributeMapper<StackMapTableAttribute>\n+            STACK_MAP_TABLE = new AbstractAttributeMapper<>(NAME_STACK_MAP_TABLE, Classfile.JAVA_6_VERSION) {\n+                @Override\n+                public StackMapTableAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundStackMapTableAttribute((CodeImpl)e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter b, StackMapTableAttribute attr) {\n+                    StackMapDecoder.writeFrames(b, attr.entries());\n+                }\n+            };\n+\n+\n+    \/** Attribute mapper for the {@code Synthetic} attribute *\/\n+    public static final AttributeMapper<SyntheticAttribute>\n+            SYNTHETIC = new AbstractAttributeMapper<>(NAME_SYNTHETIC) {\n+                @Override\n+                public SyntheticAttribute readAttribute(AttributedElement e, ClassReader cf, int p) {\n+                    return new BoundAttribute.BoundSyntheticAttribute(e, cf, this, p);\n+                }\n+\n+                @Override\n+                protected void writeBody(BufWriter buf, SyntheticAttribute attr) {\n+                    \/\/ empty\n+                }\n+            };\n+\n+    \/**\n+     * {@return the attribute mapper for a standard attribute}\n+     *\n+     * @param name the name of the attribute to find\n+     *\/\n+    public static AttributeMapper<?> standardAttribute(Utf8Entry name) {\n+        return _ATTR_MAP.get(name);\n+    }\n+\n+    \/**\n+     * All standard attribute mappers.\n+     *\/\n+    public static final Set<AttributeMapper<?>> PREDEFINED_ATTRIBUTES = Set.of(\n+            ANNOTATION_DEFAULT,\n+            BOOTSTRAP_METHODS,\n+            CHARACTER_RANGE_TABLE,\n+            CODE,\n+            COMPILATION_ID,\n+            CONSTANT_VALUE,\n+            DEPRECATED,\n+            ENCLOSING_METHOD,\n+            EXCEPTIONS,\n+            INNER_CLASSES,\n+            LINE_NUMBER_TABLE,\n+            LOCAL_VARIABLE_TABLE,\n+            LOCAL_VARIABLE_TYPE_TABLE,\n+            METHOD_PARAMETERS,\n+            MODULE,\n+            MODULE_HASHES,\n+            MODULE_MAIN_CLASS,\n+            MODULE_PACKAGES,\n+            MODULE_RESOLUTION,\n+            MODULE_TARGET,\n+            NEST_HOST,\n+            NEST_MEMBERS,\n+            PERMITTED_SUBCLASSES,\n+            RECORD,\n+            RUNTIME_INVISIBLE_ANNOTATIONS,\n+            RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,\n+            RUNTIME_INVISIBLE_TYPE_ANNOTATIONS,\n+            RUNTIME_VISIBLE_ANNOTATIONS,\n+            RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,\n+            RUNTIME_VISIBLE_TYPE_ANNOTATIONS,\n+            SIGNATURE,\n+            SOURCE_DEBUG_EXTENSION,\n+            SOURCE_FILE,\n+            SOURCE_ID,\n+            STACK_MAP_TABLE,\n+            SYNTHETIC);\n+\n+    private static final Map<Utf8Entry, AttributeMapper<?>> _ATTR_MAP;\n+    \/\/no lambdas here as this is on critical JDK boostrap path\n+    static {\n+        var map = new HashMap<Utf8Entry, AttributeMapper<?>>(64);\n+        for (var am : PREDEFINED_ATTRIBUTES) {\n+            map.put(ConcreteEntry.rawUtf8EntryFromStandardAttributeName(am.name()), am);\n+        }\n+        _ATTR_MAP = Collections.unmodifiableMap(map);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Attributes.java","additions":786,"deletions":0,"binary":false,"changes":786,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.impl.ConcreteBootstrapMethodEntry;\n+\n+\/**\n+ * Models an entry in the bootstrap method table.  The bootstrap method table\n+ * is stored in the {@code BootstrapMethods} attribute, but is modeled by\n+ * the {@link ConstantPool}, since the bootstrap method table is logically\n+ * part of the constant pool.\n+ *\/\n+public sealed interface BootstrapMethodEntry\n+        extends WritableElement<BootstrapMethodEntry>\n+        permits ConcreteBootstrapMethodEntry {\n+\n+    \/**\n+     * {@return the constant pool associated with this entry}\n+     *\/\n+    ConstantPool constantPool();\n+\n+    \/**\n+     * {@return the index into the bootstrap method table corresponding to this entry}\n+     *\/\n+    int bsmIndex();\n+\n+    \/**\n+     * {@return the bootstrap method}\n+     *\/\n+    MethodHandleEntry bootstrapMethod();\n+\n+    \/**\n+     * {@return the bootstrap arguments}\n+     *\/\n+    List<LoadableConstantEntry> arguments();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/BootstrapMethodEntry.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+\n+\/**\n+ * Supports writing portions of a classfile to a growable buffer.   Method\n+ * are provided to write various standard entities (e.g., {@code u2}, {@code u4})\n+ * to the end of the buffer, as well as to create constant pool entries.\n+ *\/\n+public sealed interface BufWriter\n+        permits BufWriterImpl {\n+\n+    \/** {@return the constant pool builder associated with this buffer} *\/\n+    ConstantPoolBuilder constantPool();\n+\n+    \/**\n+     * {@return whether the provided constant pool is index-compatible with this\n+     * one}  This may be because they are the same constant pool, or because this\n+     * constant pool was copied from the other.\n+     *\n+     * @param other the other constant pool\n+     *\/\n+    boolean canWriteDirect(ConstantPool other);\n+\n+    \/**\n+     * Ensure that the buffer has at least {@code freeBytes} bytes of unused space\n+     * @param freeBytes the number of bytes to reserve\n+     *\/\n+    void reserveSpace(int freeBytes);\n+\n+    \/**\n+     * Write an unsigned byte to the buffer\n+     *\n+     * @param x the byte value\n+     *\/\n+    void writeU1(int x);\n+\n+    \/**\n+     * Write an unsigned short to the buffer\n+     *\n+     * @param x the short value\n+     *\/\n+    void writeU2(int x);\n+\n+    \/**\n+     * Write a signed int to the buffer\n+     *\n+     * @param x the int value\n+     *\/\n+    void writeInt(int x);\n+\n+    \/**\n+     * Write a float value to the buffer\n+     *\n+     * @param x the float value\n+     *\/\n+    void writeFloat(float x);\n+\n+    \/**\n+     * Write a long value to the buffer\n+     *\n+     * @param x the long value\n+     *\/\n+    void writeLong(long x);\n+\n+    \/**\n+     * Write a double value to the buffer\n+     *\n+     * @param x the int value\n+     *\/\n+    void writeDouble(double x);\n+\n+    \/**\n+     * Write the contents of a byte array to the buffer\n+     *\n+     * @param arr the byte array\n+     *\/\n+    void writeBytes(byte[] arr);\n+\n+    \/**\n+     * Write the contents of another {@link BufWriter} to the buffer\n+     *\n+     * @param other the other {@linkplain BufWriter}\n+     *\/\n+    void writeBytes(BufWriter other);\n+\n+    \/**\n+     * Write a range of a byte array to the buffer\n+     *\n+     * @param arr the byte array\n+     * @param start the offset within the byte array of the range\n+     * @param length the length of the range\n+     *\/\n+    void writeBytes(byte[] arr, int start, int length);\n+\n+    \/**\n+     * Patch a previously written integer value.  Depending on the specified\n+     * size, the entire value, or the low 1 or 2 bytes, may be written.\n+     *\n+     * @param offset the offset at which to patch\n+     * @param size the size of the integer value being written, in bytes\n+     * @param value the integer value\n+     *\/\n+    void patchInt(int offset, int size, int value);\n+\n+    \/**\n+     * Write a 1, 2, 4, or 8 byte integer value to the buffer.  Depending on\n+     * the specified size, the entire value, or the low 1, 2, or 4 bytes, may\n+     * be written.\n+     *\n+     * @param intSize the size of the integer value being written, in bytes\n+     * @param intValue the integer value\n+     *\/\n+    void writeIntBytes(int intSize, long intValue);\n+\n+    \/**\n+     * Write the index of the specified constant pool entry, as a {@code u2},\n+     * to the buffer\n+     *\n+     * @param entry the constant pool entry\n+     * @throws NullPointerException if the entry is null\n+     *\/\n+    void writeIndex(PoolEntry entry);\n+\n+    \/**\n+     * Write the index of the specified constant pool entry, as a {@code u2},\n+     * to the buffer, or zero if the entry is null\n+     *\n+     * @param entry the constant pool entry\n+     *\/\n+    void writeIndexOrZero(PoolEntry entry);\n+\n+    \/**\n+     * Write a list of entities to the buffer.  The length of the list is\n+     * written as a {@code u2}, followed by the bytes corresponding to each\n+     * element in the list.  Writing of the entities is delegated to the entry.\n+     *\n+     * @param list the entities\n+     * @param <T> the type of entity\n+     *\/\n+    <T extends WritableElement<?>> void writeList(List<T> list);\n+\n+    \/**\n+     * Write a list of constant pool entry indexes to the buffer.  The length\n+     * of the list is written as a {@code u2}, followed by a {@code u2} for each\n+     * entry in the list.\n+     *\n+     * @param list the list of entries\n+     *\/\n+    void writeListIndices(List<? extends PoolEntry> list);\n+\n+    \/**\n+     * {@return the number of bytes that have been written to the buffer}\n+     *\/\n+    int size();\n+\n+    \/**\n+     * {@return a {@link java.nio.ByteBuffer ByteBuffer} view of the bytes in the buffer}\n+     *\/\n+    ByteBuffer asByteBuffer();\n+\n+    \/**\n+     * Copy the contents of the buffer into a byte array.\n+     *\n+     * @param array the byte array\n+     * @param bufferOffset the offset into the array at which to write the\n+     *                     contents of the buffer\n+     *\/\n+    void copyTo(byte[] array, int bufferOffset);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/BufWriter.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.ChainedClassBuilder;\n+import jdk.internal.classfile.impl.DirectClassBuilder;\n+import jdk.internal.classfile.impl.Util;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+\n+\/**\n+ * A builder for classfiles.  Builders are not created directly; they are passed\n+ * to handlers by methods such as {@link Classfile#build(ClassDesc, Consumer)}\n+ * or to class transforms.  The elements of a classfile can be specified\n+ * abstractly (by passing a {@link ClassElement} to {@link #with(ClassfileElement)})\n+ * or concretely by calling the various {@code withXxx} methods.\n+ *\n+ * @see ClassTransform\n+ *\/\n+public sealed interface ClassBuilder\n+        extends ClassfileBuilder<ClassElement, ClassBuilder>\n+        permits ChainedClassBuilder, DirectClassBuilder {\n+\n+    \/**\n+     * {@return the {@link ClassModel} representing the class being transformed,\n+     * if this class builder represents the transformation of some {@link ClassModel}}\n+     *\/\n+    Optional<ClassModel> original();\n+\n+    \/**\n+     * Sets the classfile version.\n+     * @param major the major version number\n+     * @param minor the minor version number\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withVersion(int major, int minor) {\n+        return with(ClassfileVersion.of(major, minor));\n+    }\n+\n+    \/**\n+     * Sets the classfile access flags.\n+     * @param flags the access flags, as a bit mask\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withFlags(int flags) {\n+        return with(AccessFlags.ofClass(flags));\n+    }\n+\n+    \/**\n+     * Sets the classfile access flags.\n+     * @param flags the access flags\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withFlags(AccessFlag... flags) {\n+        return with(AccessFlags.ofClass(flags));\n+    }\n+\n+    \/**\n+     * Sets the superclass of this class.\n+     * @param superclassEntry the superclass\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withSuperclass(ClassEntry superclassEntry) {\n+        return with(Superclass.of(superclassEntry));\n+    }\n+\n+    \/**\n+     * Sets the superclass of this class.\n+     * @param desc the superclass\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withSuperclass(ClassDesc desc) {\n+        return withSuperclass(constantPool().classEntry(desc));\n+    }\n+\n+    \/**\n+     * Sets the interfaces of this class.\n+     * @param interfaces the interfaces\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withInterfaces(List<ClassEntry> interfaces) {\n+        return with(Interfaces.of(interfaces));\n+    }\n+\n+    \/**\n+     * Sets the interfaces of this class.\n+     * @param interfaces the interfaces\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withInterfaces(ClassEntry... interfaces) {\n+        return withInterfaces(List.of(interfaces));\n+    }\n+\n+    \/**\n+     * Sets the interfaces of this class.\n+     * @param interfaces the interfaces\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withInterfaceSymbols(List<ClassDesc> interfaces) {\n+        return withInterfaces(Util.entryList(interfaces));\n+    }\n+\n+    \/**\n+     * Sets the interfaces of this class.\n+     * @param interfaces the interfaces\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withInterfaceSymbols(ClassDesc... interfaces) {\n+        \/\/ List view, since ref to interfaces is temporary\n+        return withInterfaceSymbols(Arrays.asList(interfaces));\n+    }\n+\n+    \/**\n+     * Adds a field.\n+     * @param name the name of the field\n+     * @param descriptor the field descriptor\n+     * @param handler handler which receives a {@link FieldBuilder} which can\n+     *                    further define the contents of the field\n+     * @return this builder\n+     *\/\n+    ClassBuilder withField(Utf8Entry name,\n+                           Utf8Entry descriptor,\n+                           Consumer<? super FieldBuilder> handler);\n+\n+    \/**\n+     * Adds a field.\n+     * @param name the name of the field\n+     * @param descriptor the field descriptor\n+     * @param flags the access flags for this field\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withField(Utf8Entry name,\n+                                   Utf8Entry descriptor,\n+                                   int flags) {\n+        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+    }\n+\n+    \/**\n+     * Adds a field.\n+     * @param name the name of the field\n+     * @param descriptor the field descriptor\n+     * @param handler handler which receives a {@link FieldBuilder} which can\n+     *                    further define the contents of the field\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withField(String name,\n+                                   ClassDesc descriptor,\n+                                   Consumer<? super FieldBuilder> handler) {\n+        return withField(constantPool().utf8Entry(name),\n+                         constantPool().utf8Entry(descriptor),\n+                         handler);\n+    }\n+\n+    \/**\n+     * Adds a field.\n+     * @param name the name of the field\n+     * @param descriptor the field descriptor\n+     * @param flags the access flags for this field\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withField(String name,\n+                                   ClassDesc descriptor,\n+                                   int flags) {\n+        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+    }\n+\n+    \/**\n+     * Adds a field by transforming a field from another class.\n+     *\n+     * @implNote\n+     * <p>This method behaves as if:\n+     * {@snippet lang=java :\n+     *     withField(field.fieldName(), field.fieldType(),\n+     *                b -> b.transformField(field, transform));\n+     * }\n+     *\n+     * @param field the field to be transformed\n+     * @param transform the transform to apply to the field\n+     * @return this builder\n+     *\/\n+    ClassBuilder transformField(FieldModel field, FieldTransform transform);\n+\n+    \/**\n+     * Adds a method.\n+     * @param name the name of the method\n+     * @param descriptor the method descriptor\n+     * @param methodFlags the access flags\n+     * @param handler handler which receives a {@link MethodBuilder} which can\n+     *                    further define the contents of the method\n+     * @return this builder\n+     *\/\n+    ClassBuilder withMethod(Utf8Entry name,\n+                            Utf8Entry descriptor,\n+                            int methodFlags,\n+                            Consumer<? super MethodBuilder> handler);\n+\n+    \/**\n+     * Adds a method, with only a {@code Code} attribute.\n+     *\n+     * @param name the name of the method\n+     * @param descriptor the method descriptor\n+     * @param methodFlags the access flags\n+     * @param handler handler which receives a {@link CodeBuilder} which can\n+     *                    define the contents of the method body\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withMethodBody(Utf8Entry name,\n+                                        Utf8Entry descriptor,\n+                                        int methodFlags,\n+                                        Consumer<? super CodeBuilder> handler) {\n+        return withMethod(name, descriptor, methodFlags, mb -> mb.withCode(handler));\n+    }\n+\n+    \/**\n+     * Adds a method.\n+     * @param name the name of the method\n+     * @param descriptor the method descriptor\n+     * @param methodFlags the access flags\n+     * @param handler handler which receives a {@link MethodBuilder} which can\n+     *                    further define the contents of the method\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withMethod(String name,\n+                                    MethodTypeDesc descriptor,\n+                                    int methodFlags,\n+                                    Consumer<? super MethodBuilder> handler) {\n+        return withMethod(constantPool().utf8Entry(name),\n+                          constantPool().utf8Entry(descriptor),\n+                          methodFlags,\n+                          handler);\n+    }\n+\n+    \/**\n+     * Adds a method, with only a {@link CodeAttribute}.\n+     * @param name the name of the method\n+     * @param descriptor the method descriptor\n+     * @param methodFlags the access flags\n+     * @param handler handler which receives a {@link CodeBuilder} which can\n+     *                    define the contents of the method body\n+     * @return this builder\n+     *\/\n+    default ClassBuilder withMethodBody(String name,\n+                                        MethodTypeDesc descriptor,\n+                                        int methodFlags,\n+                                        Consumer<? super CodeBuilder> handler) {\n+        return withMethodBody(constantPool().utf8Entry(name),\n+                              constantPool().utf8Entry(descriptor),\n+                              methodFlags,\n+                              handler);\n+    }\n+\n+    \/**\n+     * Adds a method by transforming a method from another class.\n+     *\n+     * @implNote\n+     * <p>This method behaves as if:\n+     * {@snippet lang=java :\n+     *     withMethod(method.methodName(), method.methodType(),\n+     *                b -> b.transformMethod(method, transform));\n+     * }\n+     * @param method the method to be transformed\n+     * @param transform the transform to apply to the method\n+     * @return this builder\n+     *\/\n+    ClassBuilder transformMethod(MethodModel method, MethodTransform transform);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassBuilder.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.CompilationIDAttribute;\n+import jdk.internal.classfile.attribute.DeprecatedAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.attribute.SourceIDAttribute;\n+import jdk.internal.classfile.attribute.SyntheticAttribute;\n+import jdk.internal.classfile.attribute.UnknownAttribute;\n+\n+\/**\n+ * A {@link ClassfileElement} that can appear when traversing the elements\n+ * of a {@link ClassModel} or be presented to a {@link ClassBuilder}.\n+ *\/\n+public sealed interface ClassElement extends ClassfileElement\n+        permits AccessFlags, Superclass, Interfaces, ClassfileVersion,\n+                FieldModel, MethodModel,\n+                CustomAttribute, CompilationIDAttribute, DeprecatedAttribute,\n+                EnclosingMethodAttribute, InnerClassesAttribute,\n+                ModuleAttribute, ModuleHashesAttribute, ModuleMainClassAttribute,\n+                ModulePackagesAttribute, ModuleResolutionAttribute, ModuleTargetAttribute,\n+                NestHostAttribute, NestMembersAttribute, PermittedSubclassesAttribute,\n+                RecordAttribute,\n+                RuntimeInvisibleAnnotationsAttribute, RuntimeInvisibleTypeAnnotationsAttribute,\n+                RuntimeVisibleAnnotationsAttribute, RuntimeVisibleTypeAnnotationsAttribute,\n+                SignatureAttribute, SourceDebugExtensionAttribute,\n+                SourceFileAttribute, SourceIDAttribute, SyntheticAttribute, UnknownAttribute {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassElement.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.io.InputStream;\n+import java.lang.constant.ClassDesc;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.function.Function;\n+import jdk.internal.classfile.impl.Util;\n+\n+import jdk.internal.classfile.impl.ClassHierarchyImpl;\n+\n+\/**\n+ * Provides class hierarchy information for generating correct stack maps\n+ * during code building.\n+ *\/\n+@FunctionalInterface\n+public interface ClassHierarchyResolver {\n+\n+    \/**\n+     * Default singleton instance of {@linkplain ClassHierarchyResolver}\n+     * using {@link ClassLoader#getSystemResourceAsStream(String)}\n+     * as the {@code ClassStreamResolver}\n+     *\/\n+    ClassHierarchyResolver DEFAULT_CLASS_HIERARCHY_RESOLVER\n+            = new ClassHierarchyImpl.CachedClassHierarchyResolver(\n+            new Function<ClassDesc, InputStream>() {\n+                @Override\n+                public InputStream apply(ClassDesc classDesc) {\n+                    return ClassLoader.getSystemResourceAsStream(Util.toInternalName(classDesc) + \".class\");\n+                }\n+            });\n+\n+    \/**\n+     * {@return the {@link ClassHierarchyInfo} for a given class name, or null\n+     * if the name is unknown to the resolver}\n+     * @param classDesc descriptor of the class\n+     *\/\n+    ClassHierarchyInfo getClassInfo(ClassDesc classDesc);\n+\n+    \/**\n+     * Chains this {@linkplain ClassHierarchyResolver} with another to be\n+     * consulted if this resolver does not know about the specified class.\n+     *\n+     * @param other the other resolver\n+     * @return the chained resolver\n+     *\/\n+    default ClassHierarchyResolver orElse(ClassHierarchyResolver other) {\n+        return new ClassHierarchyResolver() {\n+            @Override\n+            public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+                var chi = ClassHierarchyResolver.this.getClassInfo(classDesc);\n+                if (chi == null)\n+                    chi = other.getClassInfo(classDesc);\n+                return chi;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Information about a resolved class.\n+     * @param thisClass descriptor of this class\n+     * @param isInterface whether this class is an interface\n+     * @param superClass descriptor of the superclass (not relevant for interfaces)\n+     *\/\n+    public record ClassHierarchyInfo(ClassDesc thisClass, boolean isInterface, ClassDesc superClass) {\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain  ClassHierarchyResolver} that extracts class hierarchy\n+     * information from classfiles located by a mapping function\n+     *\n+     * @param classStreamResolver maps class descriptors to classfile input streams\n+     * @return the {@linkplain ClassHierarchyResolver}\n+     *\/\n+    public static ClassHierarchyResolver ofCached(Function<ClassDesc, InputStream> classStreamResolver) {\n+        return new ClassHierarchyImpl.CachedClassHierarchyResolver(classStreamResolver);\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain  ClassHierarchyResolver} that extracts class hierarchy\n+     * information from collections of class hierarchy metadata\n+     *\n+     * @param interfaces a collection of classes known to be interfaces\n+     * @param classToSuperClass a map from classes to their super classes\n+     * @return the {@linkplain ClassHierarchyResolver}\n+     *\/\n+    public static ClassHierarchyResolver of(Collection<ClassDesc> interfaces,\n+                                            Map<ClassDesc, ClassDesc> classToSuperClass) {\n+        return new ClassHierarchyImpl.StaticClassHierarchyResolver(interfaces, classToSuperClass);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassHierarchyResolver.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.impl.ClassImpl;\n+import jdk.internal.classfile.impl.verifier.VerifierImpl;\n+\n+\/**\n+ * Models a classfile.  The contents of the classfile can be traversed via\n+ * a streaming view (e.g., {@link #elements()}), or via random access (e.g.,\n+ * {@link #flags()}), or by freely mixing the two.\n+ *\/\n+public sealed interface ClassModel\n+        extends CompoundElement<ClassElement>, AttributedElement\n+        permits ClassImpl {\n+\n+    \/**\n+     * {@return the constant pool for this class}\n+     *\/\n+    ConstantPool constantPool();\n+\n+    \/** {@return the access flags} *\/\n+    AccessFlags flags();\n+\n+    \/** {@return the constant pool entry describing the name of this class} *\/\n+    ClassEntry thisClass();\n+\n+    \/** {@return the major classfile version} *\/\n+    int majorVersion();\n+\n+    \/** {@return the minor classfile version} *\/\n+    int minorVersion();\n+\n+    \/** {@return the fields of this class} *\/\n+    List<FieldModel> fields();\n+\n+    \/** {@return the methods of this class} *\/\n+    List<MethodModel> methods();\n+\n+    \/** {@return the superclass of this class, if there is one} *\/\n+    Optional<ClassEntry> superclass();\n+\n+    \/** {@return the interfaces implemented by this class} *\/\n+    List<ClassEntry> interfaces();\n+\n+    \/**\n+     * Transform this classfile into a new classfile with the aid of a\n+     * {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     *\n+     * @implNote\n+     * <p>This method behaves as if:\n+     * {@snippet lang=java :\n+     *     Classfile.build(thisClass(), ConstantPoolBuilder.of(this),\n+     *                     b -> b.transform(this, transform);\n+     * }\n+     *\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     *\/\n+    byte[] transform(ClassTransform transform);\n+\n+    \/** {@return whether this class is a module descriptor} *\/\n+    boolean isModuleInfo();\n+\n+    \/**\n+     * Verify this classfile.  Any verification errors found will be returned.\n+     *\n+     * @param debugOutput handler to receive debug information\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     *\/\n+    default List<VerifyError> verify(Consumer<String> debugOutput) {\n+        return VerifierImpl.verify(this, debugOutput);\n+    }\n+\n+    \/**\n+     * Verify this classfile.  Any verification errors found will be returned.\n+     *\n+     * @param debugOutput handler to receive debug information\n+     * @param classHierarchyResolver class hierarchy resolver to provide\n+     *                               additional information about the class hiearchy\n+     * @return a list of verification errors, or an empty list if no errors are\n+     * found\n+     *\/\n+    default List<VerifyError> verify(ClassHierarchyResolver classHierarchyResolver,\n+                                     Consumer<String> debugOutput) {\n+        return VerifierImpl.verify(this, classHierarchyResolver, debugOutput);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassModel.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.ClassReaderImpl;\n+\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+\/**\n+ * Supports reading from a classfile.  Methods are provided to read data of\n+ * various numeric types (e.g., {@code u2}, {@code u4}) at a given offset within\n+ * the classfile, copying raw bytes, and reading constant pool entries.\n+ * Encapsulates additional reading context such as mappers for custom attributes\n+ * and processing options.\n+ *\/\n+public sealed interface ClassReader extends ConstantPool\n+        permits ClassReaderImpl {\n+\n+    \/\/ Processing context\n+\n+    \/**\n+     * {@return the table of custom attribute mappers}  This is derived from\n+     * the processing option {@link Classfile.Option#attributeMapper(Function)}.\n+     *\/\n+    Function<Utf8Entry, AttributeMapper<?>> customAttributes();\n+\n+    \/\/ Class context\n+\n+    \/** {@return the access flags for the class, as a bit mask } *\/\n+    int flags();\n+\n+    \/** {@return the constant pool entry describing the name of class} *\/\n+    ClassEntry thisClassEntry();\n+\n+    \/** {@return the constant pool entry describing the name of the superclass, if any} *\/\n+    Optional<ClassEntry> superclassEntry();\n+\n+    \/** {@return the offset into the classfile of the {@code this_class} field} *\/\n+    int thisClassPos();\n+\n+    \/** {@return the length of the classfile, in bytes} *\/\n+    int classfileLength();\n+\n+    \/\/ Buffer related\n+\n+    \/**\n+     * {@return the offset following the block of attributes starting at the\n+     * specified position}\n+     * @param offset the offset into the classfile at which the attribute block\n+     *               starts\n+     *\/\n+    int skipAttributeHolder(int offset);\n+\n+    \/\/ Constant pool\n+\n+    \/**\n+     * {@return the UTF8 constant pool entry at the given index of the constant\n+     * pool}  The given index must correspond to a valid constant pool index\n+     * whose slot holds a UTF8 constant.\n+     * @param index the index into the constant pool\n+     *\/\n+    Utf8Entry utf8EntryByIndex(int index);\n+\n+    \/**\n+     * {@return the constant pool entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     *\/\n+    PoolEntry readEntry(int offset);\n+\n+    \/**\n+     * {@return the constant pool entry whose index is given at the specified\n+     * offset within the classfile, or null if the index at the specified\n+     * offset is zero}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size\n+     *\/\n+    PoolEntry readEntryOrNull(int offset);\n+\n+    \/**\n+     * {@return the UTF8 entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     * @throws IllegalArgumentException if the index does not correspond to\n+     *         a UTF8 entry\n+     *\/\n+    Utf8Entry readUtf8Entry(int offset);\n+\n+    \/**\n+     * {@return the UTF8 entry whose index is given at the specified\n+     * offset within the classfile, or null if the index at the specified\n+     * offset is zero}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size\n+     * @throws IllegalArgumentException if the index does not correspond to\n+     *         a UTF8 entry\n+     *\/\n+    Utf8Entry readUtf8EntryOrNull(int offset);\n+\n+    \/**\n+     * {@return the module entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     * @throws ClassCastException if the index does not correspond to\n+     *         a module entry\n+     *\/\n+    ModuleEntry readModuleEntry(int offset);\n+\n+    \/**\n+     * {@return the package entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     * @throws ClassCastException if the index does not correspond to\n+     *         a package entry\n+     *\/\n+    PackageEntry readPackageEntry(int offset);\n+\n+    \/**\n+     * {@return the class entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     * @throws ClassCastException if the index does not correspond to\n+     *         a class entry\n+     *\/\n+    ClassEntry readClassEntry(int offset);\n+\n+    \/**\n+     * {@return the name-and-type entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     * @throws ClassCastException if the index does not correspond to\n+     *         a name-and-type entry\n+     *\/\n+    NameAndTypeEntry readNameAndTypeEntry(int offset);\n+\n+    \/**\n+     * {@return the method handle entry whose index is given at the specified\n+     * offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @throws IndexOutOfBoundsException if the index is out of range of the\n+     *         constant pool size, or zero\n+     * @throws ClassCastException if the index does not correspond to\n+     *         a method handle entry\n+     *\/\n+    MethodHandleEntry readMethodHandleEntry(int offset);\n+\n+    \/**\n+     * {@return the unsigned byte at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    int readU1(int offset);\n+\n+    \/**\n+     * {@return the unsigned short at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    int readU2(int offset);\n+\n+    \/**\n+     * {@return the signed byte at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    int readS1(int offset);\n+\n+    \/**\n+     * {@return the signed byte at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    int readS2(int offset);\n+\n+    \/**\n+     * {@return the signed int at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    int readInt(int offset);\n+\n+    \/**\n+     * {@return the signed long at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    long readLong(int offset);\n+\n+    \/**\n+     * {@return the float value at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    float readFloat(int offset);\n+\n+    \/**\n+     * {@return the double value at the specified offset within the classfile}\n+     * @param offset the offset within the classfile\n+     *\/\n+    double readDouble(int offset);\n+\n+    \/**\n+     * {@return a copy of the bytes at the specified range in the classfile}\n+     * @param offset the offset within the classfile\n+     * @param len the length of the range\n+     *\/\n+    byte[] readBytes(int offset, int len);\n+\n+    \/**\n+     * Copy a range of bytes from the classfile to a {@link BufWriter}\n+     *\n+     * @param buf the {@linkplain BufWriter}\n+     * @param offset the offset within the classfile\n+     * @param len the length of the range\n+     *\/\n+    void copyBytesTo(BufWriter buf, int offset, int len);\n+\n+    \/**\n+     * Compare a range of bytes from the classfile to a range of bytes within\n+     * a {@link BufWriter}.\n+     *\n+     * @param bufWriter the {@linkplain BufWriter}\n+     * @param bufWriterOffset the offset within the {@linkplain BufWriter}\n+     * @param classReaderOffset the offset within the classfile\n+     * @param length the length of the range\n+     * @return whether the two ranges were identical\n+     *\/\n+    boolean compare(BufWriter bufWriter,\n+                    int bufWriterOffset,\n+                    int classReaderOffset,\n+                    int length);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassReader.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.List;\n+import jdk.internal.classfile.impl.SignaturesImpl;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Models the generic signature of a class file, as defined by {@jvms 4.7.9}.\n+ *\/\n+public sealed interface ClassSignature\n+        permits SignaturesImpl.ClassSignatureImpl {\n+\n+    \/** {@return the type parameters of this class} *\/\n+    List<Signature.TypeParam> typeParameters();\n+\n+    \/** {@return the instantiation of the superclass in this signature} *\/\n+    Signature.RefTypeSig superclassSignature();\n+\n+    \/** {@return the instantiation of the interfaces in this signature} *\/\n+    List<Signature.RefTypeSig> superinterfaceSignatures();\n+\n+    \/** {@return the raw signature string} *\/\n+    String signatureString();\n+\n+    \/**\n+     * @return class signature\n+     * @param superclassSignature the superclass\n+     * @param superinterfaceSignatures the interfaces\n+     *\/\n+    public static ClassSignature of(Signature.RefTypeSig superclassSignature,\n+                                    Signature.RefTypeSig... superinterfaceSignatures) {\n+        return of(List.of(), superclassSignature, superinterfaceSignatures);\n+    }\n+\n+    \/**\n+     * @return class signature\n+     * @param typeParameters the type parameters\n+     * @param superclassSignature the superclass\n+     * @param superinterfaceSignatures the interfaces\n+     *\/\n+    public static ClassSignature of(List<Signature.TypeParam> typeParameters,\n+                                    Signature.RefTypeSig superclassSignature,\n+                                    Signature.RefTypeSig... superinterfaceSignatures) {\n+        return new SignaturesImpl.ClassSignatureImpl(\n+                requireNonNull(typeParameters),\n+                requireNonNull(superclassSignature),\n+                List.of(superinterfaceSignatures));\n+    }\n+\n+    \/**\n+     * Parses a raw class signature string into a {@linkplain Signature}\n+     * @param classSignature the raw class signature string\n+     * @return class signature\n+     *\/\n+    public static ClassSignature parseFrom(String classSignature) {\n+        return new SignaturesImpl().parseClassSignature(requireNonNull(classSignature));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassSignature.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.impl.TransformImpl;\n+\n+\/**\n+ * A transformation on streams of {@link ClassElement}.\n+ *\n+ * @see ClassfileTransform\n+ *\/\n+@FunctionalInterface\n+public non-sealed interface ClassTransform\n+        extends ClassfileTransform<ClassTransform, ClassElement, ClassBuilder> {\n+\n+    \/**\n+     * A class transform that sends all elements to the builder.\n+     *\/\n+    static final ClassTransform ACCEPT_ALL = new ClassTransform() {\n+        @Override\n+        public void accept(ClassBuilder builder, ClassElement element) {\n+            builder.with(element);\n+        }\n+    };\n+\n+    \/**\n+     * Create a stateful class transform from a {@link Supplier}.  The supplier\n+     * will be invoked for each transformation.\n+     *\n+     * @param supplier a {@link Supplier} that produces a fresh transform object\n+     *                 for each traversal\n+     * @return the stateful class transform\n+     *\/\n+    static ClassTransform ofStateful(Supplier<ClassTransform> supplier) {\n+        return new TransformImpl.SupplierClassTransform(supplier);\n+    }\n+\n+    \/**\n+     * Create a class transform that passes each element through to the builder,\n+     * and calls the specified function when transformation is complete.\n+     *\n+     * @param finisher the function to call when transformation is complete\n+     * @return the class transform\n+     *\/\n+    static ClassTransform endHandler(Consumer<ClassBuilder> finisher) {\n+        return new ClassTransform() {\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                builder.with(element);\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                finisher.accept(builder);\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Create a class transform that passes each element through to the builder,\n+     * except for those that the supplied {@link Predicate} is true for.\n+     *\n+     * @param filter the predicate that determines which elements to drop\n+     * @return the class transform\n+     *\/\n+    static ClassTransform dropping(Predicate<ClassElement> filter) {\n+        return (b, e) -> {\n+            if (!filter.test(e))\n+                b.with(e);\n+        };\n+    }\n+\n+    \/**\n+     * Create a class transform that transforms {@link MethodModel} elements\n+     * with the supplied method transform.\n+     *\n+     * @param filter a predicate that determines which methods to transform\n+     * @param xform the method transform\n+     * @return the class transform\n+     *\/\n+    static ClassTransform transformingMethods(Predicate<MethodModel> filter,\n+                                              MethodTransform xform) {\n+        return new TransformImpl.ClassMethodTransform(xform, filter);\n+    }\n+\n+    \/**\n+     * Create a class transform that transforms {@link MethodModel} elements\n+     * with the supplied method transform.\n+     *\n+     * @param xform the method transform\n+     * @return the class transform\n+     *\/\n+    static ClassTransform transformingMethods(MethodTransform xform) {\n+        return transformingMethods(mm -> true, xform);\n+    }\n+\n+    \/**\n+     * Create a class transform that transforms the {@link CodeAttribute} (method body)\n+     * of {@link MethodModel} elements with the supplied code transform.\n+     *\n+     * @param filter a predicate that determines which methods to transform\n+     * @param xform the code transform\n+     * @return the class transform\n+     *\/\n+    static ClassTransform transformingMethodBodies(Predicate<MethodModel> filter,\n+                                                   CodeTransform xform) {\n+        return transformingMethods(filter, MethodTransform.transformingCode(xform));\n+    }\n+\n+    \/**\n+     * Create a class transform that transforms the {@link CodeAttribute} (method body)\n+     * of {@link MethodModel} elements with the supplied code transform.\n+     *\n+     * @param xform the code transform\n+     * @return the class transform\n+     *\/\n+    static ClassTransform transformingMethodBodies(CodeTransform xform) {\n+        return transformingMethods(MethodTransform.transformingCode(xform));\n+    }\n+\n+    \/**\n+     * Create a class transform that transforms {@link FieldModel} elements\n+     * with the supplied field transform.\n+     *\n+     * @param xform the field transform\n+     * @return the class transform\n+     *\/\n+    static ClassTransform transformingFields(FieldTransform xform) {\n+        return new TransformImpl.ClassFieldTransform(xform, f -> true);\n+    }\n+\n+    @Override\n+    default ClassTransform andThen(ClassTransform t) {\n+        return new TransformImpl.ChainedClassTransform(this, t);\n+    }\n+\n+    @Override\n+    default ResolvedTransform<ClassElement> resolve(ClassBuilder builder) {\n+        return new TransformImpl.ClassTransformImpl(e -> accept(builder, e),\n+                                                    () -> atEnd(builder),\n+                                                    () -> atStart(builder));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassTransform.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,652 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.UnknownAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.ClassImpl;\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.DirectClassBuilder;\n+import jdk.internal.classfile.impl.Options;\n+import jdk.internal.classfile.impl.SplitConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.attribute.CharacterRangeInfo;\n+import jdk.internal.classfile.attribute.LocalVariableInfo;\n+import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+\n+\/**\n+ * Main entry points for parsing, transforming, and generating classfiles.\n+ *\/\n+public class Classfile {\n+    private Classfile() {\n+    }\n+\n+    \/**\n+     * An option that affects the writing of classfiles.\n+     *\/\n+    public sealed interface Option permits Options.OptionValue {\n+\n+        \/**\n+         * {@return an option describing whether or not to generate stackmaps}\n+         * Default is to generate stack maps.\n+         * @param b whether to generate stack maps\n+         *\/\n+        static Option generateStackmap(boolean b) { return new Options.OptionValue(Options.Key.GENERATE_STACK_MAPS, b); }\n+\n+        \/**\n+         * {@return an option describing whether to process or discard debug elements}\n+         * Debug elements include the local variable table, local variable type\n+         * table, and character range table.  Discarding debug elements may\n+         * reduce the overhead of parsing or transforming classfiles.\n+         * Default is to process debug elements.\n+         * @param b whether or not to process debug elements\n+         *\/\n+        static Option processDebug(boolean b) { return new Options.OptionValue(Options.Key.PROCESS_DEBUG, b); }\n+\n+        \/**\n+         * {@return an option describing whether to process or discard line numbers}\n+         * Discarding line numbers may reduce the overhead of parsing or transforming\n+         * classfiles.\n+         * Default is to process line numbers.\n+         * @param b whether or not to process line numbers\n+         *\/\n+        static Option processLineNumbers(boolean b) { return new Options.OptionValue(Options.Key.PROCESS_LINE_NUMBERS, b); }\n+\n+        \/**\n+         * {@return an option describing whether to process or discard unrecognized\n+         * attributes}\n+         * Default is to process unrecognized attributes, and deliver as instances\n+         * of {@link UnknownAttribute}.\n+         * @param b whether or not to process unrecognized attributes\n+         *\/\n+        static Option processUnknownAttributes(boolean b) { return new Options.OptionValue(Options.Key.PROCESS_UNKNOWN_ATTRIBUTES, b); }\n+\n+        \/**\n+         * {@return an option describing whether to preserve the original constant\n+         * pool when transforming a classfile}  Reusing the constant pool enables significant\n+         * optimizations in processing time and minimizes differences between the\n+         * original and transformed classfile, but may result in a bigger classfile\n+         * when a classfile is significantly transformed.\n+         * Default is to preserve the original constant pool.\n+         * @param b whether or not to preserve the original constant pool\n+         *\/\n+        static Option constantPoolSharing(boolean b) { return new Options.OptionValue(Options.Key.CP_SHARING, b); }\n+\n+        \/**\n+         * {@return an option describing whether or not to automatically rewrite\n+         * short jumps to long when necessary}\n+         * Default is to automatically rewrite jump instructions.\n+         * @param b whether or not to automatically rewrite short jumps to long when necessary\n+         *\/\n+        static Option fixShortJumps(boolean b) { return new Options.OptionValue(Options.Key.FIX_SHORT_JUMPS, b); }\n+\n+        \/**\n+         * {@return an option describing whether or not to patch out unreachable code}\n+         * Default is to automatically patch out unreachable code with NOPs.\n+         * @param b whether or not to automatically patch out unreachable code\n+         *\/\n+        static Option patchDeadCode(boolean b) { return new Options.OptionValue(Options.Key.PATCH_DEAD_CODE, b); }\n+\n+        \/**\n+         * {@return an option describing the class hierarchy resolver to use when\n+         * generating stack maps}\n+         * @param r the resolver\n+         *\/\n+        static Option classHierarchyResolver(ClassHierarchyResolver r) { return new Options.OptionValue(Options.Key.HIERARCHY_RESOLVER, r); }\n+\n+        \/**\n+         * {@return an option describing attribute mappers for custom attributes}\n+         * Default is only to process standard attributes.\n+         * @param r a function mapping attribute names to attribute mappers\n+         *\/\n+        static Option attributeMapper(Function<Utf8Entry, AttributeMapper<?>> r) { return new Options.OptionValue(Options.Key.ATTRIBUTE_MAPPER, r); }\n+\n+        \/**\n+         * {@return an option describing whether or not to filter unresolved labels}\n+         * Default is to throw IllegalStateException when any {@link ExceptionCatch},\n+         * {@link LocalVariableInfo}, {@link LocalVariableTypeInfo}, or {@link CharacterRangeInfo}\n+         * reference to unresolved {@link Label} during bytecode serialization.\n+         * Setting this option to true filters the above elements instead.\n+         * @param b whether or not to automatically patch out unreachable code\n+         *\/\n+        static Option filterDeadLabels(boolean b) { return new Options.OptionValue(Options.Key.FILTER_DEAD_LABELS, b); }\n+    }\n+\n+    \/**\n+     * Parse a classfile into a {@link ClassModel}.\n+     * @param bytes the bytes of the classfile\n+     * @param options the desired processing options\n+     * @return the class model\n+     *\/\n+    public static ClassModel parse(byte[] bytes, Option... options) {\n+        Collection<Option> os = (options == null || options.length == 0)\n+                                   ? Collections.emptyList()\n+                                   : List.of(options);\n+        return new ClassImpl(bytes, os);\n+    }\n+\n+    \/**\n+     * Parse a classfile into a {@link ClassModel}.\n+     * @param path the path to the classfile\n+     * @param options the desired processing options\n+     * @return the class model\n+     *\/\n+    public static ClassModel parse(Path path, Option... options) throws IOException {\n+        return parse(Files.readAllBytes(path), options);\n+    }\n+\n+    \/**\n+     * Build a classfile into a byte array.\n+     * @param thisClass the name of the class to build\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     *\/\n+    public static byte[] build(ClassDesc thisClass,\n+                               Consumer<ClassBuilder> handler) {\n+        return build(thisClass, Collections.emptySet(), handler);\n+    }\n+\n+    \/**\n+     * Build a classfile into a byte array.\n+     * @param thisClass the name of the class to build\n+     * @param options the desired processing options\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     *\/\n+    public static byte[] build(ClassDesc thisClass,\n+                               Collection<Option> options,\n+                               Consumer<? super ClassBuilder> handler) {\n+        ConstantPoolBuilder pool = ConstantPoolBuilder.of(options);\n+        return build(pool.classEntry(thisClass), pool, handler);\n+    }\n+\n+    \/**\n+     * Build a classfile into a byte array using the provided constant pool\n+     * builder (which encapsulates classfile processing options.)\n+     *\n+     * @param thisClassEntry the name of the class to build\n+     * @param constantPool the constant pool builder\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     *\/\n+    public static byte[] build(ClassEntry thisClassEntry,\n+                               ConstantPoolBuilder constantPool,\n+                               Consumer<? super ClassBuilder> handler) {\n+        thisClassEntry = ConcreteEntry.maybeClone(constantPool, thisClassEntry);\n+        DirectClassBuilder builder = new DirectClassBuilder((SplitConstantPool)constantPool, thisClassEntry);\n+        handler.accept(builder);\n+        return builder.build();\n+    }\n+\n+    \/**\n+     * Build a classfile into a file.\n+     * @param path the path to the file to write\n+     * @param thisClass the name of the class to build\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     *\/\n+    public static void buildTo(Path path,\n+                               ClassDesc thisClass,\n+                               Consumer<ClassBuilder> handler) throws IOException {\n+        Files.write(path, build(thisClass, Collections.emptySet(), handler));\n+    }\n+\n+    \/**\n+     * Build a classfile into a file.\n+     * @param path the path to the file to write\n+     * @param thisClass the name of the class to build\n+     * @param options the desired processing options\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     *\/\n+    public static void buildTo(Path path,\n+                               ClassDesc thisClass,\n+                               Collection<Option> options,\n+                               Consumer<? super ClassBuilder> handler) throws IOException {\n+        Files.write(path, build(thisClass, options, handler));\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a byte array.\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @return the classfile bytes\n+     *\/\n+    public static byte[] buildModule(ModuleAttribute moduleAttribute) {\n+        return buildModule(moduleAttribute, List.of(), clb -> {});\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a byte array.\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param packages additional module packages\n+     * @return the classfile bytes\n+     *\/\n+    public static byte[] buildModule(ModuleAttribute moduleAttribute,\n+                                     List<PackageDesc> packages) {\n+        return buildModule(moduleAttribute, packages, clb -> {});\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a byte array.\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param packages additional module packages\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the classfile bytes\n+     *\/\n+    public static byte[] buildModule(ModuleAttribute moduleAttribute,\n+                                     List<PackageDesc> packages,\n+                                     Consumer<? super ClassBuilder> handler) {\n+        return build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            clb.with(moduleAttribute);\n+            if (!packages.isEmpty()) {\n+                var cp = clb.constantPool();\n+                var allPackages = new LinkedHashSet<PackageEntry>();\n+                for (var exp : moduleAttribute.exports()) allPackages.add(ConcreteEntry.maybeClone(cp, exp.exportedPackage()));\n+                for (var opn : moduleAttribute.opens()) allPackages.add(ConcreteEntry.maybeClone(cp, opn.openedPackage()));\n+                boolean emitMPA = false;\n+                for (var p : packages)\n+                    emitMPA |= allPackages.add(cp.packageEntry(p));\n+                if(emitMPA)\n+                    clb.with(new UnboundAttribute.UnboundModulePackagesAttribute(allPackages));\n+            }\n+            handler.accept(clb);\n+        });\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a file.\n+     * @param path the file to write\n+     * @param moduleAttribute the {@code Module} attribute\n+     *\/\n+    public static void buildModuleTo(Path path,\n+                                     ModuleAttribute moduleAttribute) throws IOException {\n+        buildModuleTo(path, moduleAttribute, List.of(), clb -> {});\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a file.\n+     * @param path the file to write\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param packages additional module packages\n+     *\/\n+    public static void buildModuleTo(Path path,\n+                                     ModuleAttribute moduleAttribute,\n+                                     List<PackageDesc> packages) throws IOException {\n+        buildModuleTo(path, moduleAttribute, packages, clb -> {});\n+    }\n+\n+    \/**\n+     * Build a module descriptor into a file.\n+     * @param path the file to write\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param packages additional module packages\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     *\/\n+    public static void buildModuleTo(Path path,\n+                                     ModuleAttribute moduleAttribute,\n+                                     List<PackageDesc> packages,\n+                                     Consumer<? super ClassBuilder> handler) throws IOException {\n+        Files.write(path, buildModule(moduleAttribute, packages, handler));\n+    }\n+\n+    public static final int MAGIC_NUMBER = 0xCAFEBABE;\n+\n+    public static final int NOP             = 0;\n+    public static final int ACONST_NULL     = 1;\n+    public static final int ICONST_M1       = 2;\n+    public static final int ICONST_0        = 3;\n+    public static final int ICONST_1        = 4;\n+    public static final int ICONST_2        = 5;\n+    public static final int ICONST_3        = 6;\n+    public static final int ICONST_4        = 7;\n+    public static final int ICONST_5        = 8;\n+    public static final int LCONST_0        = 9;\n+    public static final int LCONST_1        = 10;\n+    public static final int FCONST_0        = 11;\n+    public static final int FCONST_1        = 12;\n+    public static final int FCONST_2        = 13;\n+    public static final int DCONST_0        = 14;\n+    public static final int DCONST_1        = 15;\n+    public static final int BIPUSH          = 16;\n+    public static final int SIPUSH          = 17;\n+    public static final int LDC             = 18;\n+    public static final int LDC_W           = 19;\n+    public static final int LDC2_W          = 20;\n+    public static final int ILOAD           = 21;\n+    public static final int LLOAD           = 22;\n+    public static final int FLOAD           = 23;\n+    public static final int DLOAD           = 24;\n+    public static final int ALOAD           = 25;\n+    public static final int ILOAD_0         = 26;\n+    public static final int ILOAD_1         = 27;\n+    public static final int ILOAD_2         = 28;\n+    public static final int ILOAD_3         = 29;\n+    public static final int LLOAD_0         = 30;\n+    public static final int LLOAD_1         = 31;\n+    public static final int LLOAD_2         = 32;\n+    public static final int LLOAD_3         = 33;\n+    public static final int FLOAD_0         = 34;\n+    public static final int FLOAD_1         = 35;\n+    public static final int FLOAD_2         = 36;\n+    public static final int FLOAD_3         = 37;\n+    public static final int DLOAD_0         = 38;\n+    public static final int DLOAD_1         = 39;\n+    public static final int DLOAD_2         = 40;\n+    public static final int DLOAD_3         = 41;\n+    public static final int ALOAD_0         = 42;\n+    public static final int ALOAD_1         = 43;\n+    public static final int ALOAD_2         = 44;\n+    public static final int ALOAD_3         = 45;\n+    public static final int IALOAD          = 46;\n+    public static final int LALOAD          = 47;\n+    public static final int FALOAD          = 48;\n+    public static final int DALOAD          = 49;\n+    public static final int AALOAD          = 50;\n+    public static final int BALOAD          = 51;\n+    public static final int CALOAD          = 52;\n+    public static final int SALOAD          = 53;\n+    public static final int ISTORE          = 54;\n+    public static final int LSTORE          = 55;\n+    public static final int FSTORE          = 56;\n+    public static final int DSTORE          = 57;\n+    public static final int ASTORE          = 58;\n+    public static final int ISTORE_0        = 59;\n+    public static final int ISTORE_1        = 60;\n+    public static final int ISTORE_2        = 61;\n+    public static final int ISTORE_3        = 62;\n+    public static final int LSTORE_0        = 63;\n+    public static final int LSTORE_1        = 64;\n+    public static final int LSTORE_2        = 65;\n+    public static final int LSTORE_3        = 66;\n+    public static final int FSTORE_0        = 67;\n+    public static final int FSTORE_1        = 68;\n+    public static final int FSTORE_2        = 69;\n+    public static final int FSTORE_3        = 70;\n+    public static final int DSTORE_0        = 71;\n+    public static final int DSTORE_1        = 72;\n+    public static final int DSTORE_2        = 73;\n+    public static final int DSTORE_3        = 74;\n+    public static final int ASTORE_0        = 75;\n+    public static final int ASTORE_1        = 76;\n+    public static final int ASTORE_2        = 77;\n+    public static final int ASTORE_3        = 78;\n+    public static final int IASTORE         = 79;\n+    public static final int LASTORE         = 80;\n+    public static final int FASTORE         = 81;\n+    public static final int DASTORE         = 82;\n+    public static final int AASTORE         = 83;\n+    public static final int BASTORE         = 84;\n+    public static final int CASTORE         = 85;\n+    public static final int SASTORE         = 86;\n+    public static final int POP             = 87;\n+    public static final int POP2            = 88;\n+    public static final int DUP             = 89;\n+    public static final int DUP_X1          = 90;\n+    public static final int DUP_X2          = 91;\n+    public static final int DUP2            = 92;\n+    public static final int DUP2_X1         = 93;\n+    public static final int DUP2_X2         = 94;\n+    public static final int SWAP            = 95;\n+    public static final int IADD            = 96;\n+    public static final int LADD            = 97;\n+    public static final int FADD            = 98;\n+    public static final int DADD            = 99;\n+    public static final int ISUB            = 100;\n+    public static final int LSUB            = 101;\n+    public static final int FSUB            = 102;\n+    public static final int DSUB            = 103;\n+    public static final int IMUL            = 104;\n+    public static final int LMUL            = 105;\n+    public static final int FMUL            = 106;\n+    public static final int DMUL            = 107;\n+    public static final int IDIV            = 108;\n+    public static final int LDIV            = 109;\n+    public static final int FDIV            = 110;\n+    public static final int DDIV            = 111;\n+    public static final int IREM            = 112;\n+    public static final int LREM            = 113;\n+    public static final int FREM            = 114;\n+    public static final int DREM            = 115;\n+    public static final int INEG            = 116;\n+    public static final int LNEG            = 117;\n+    public static final int FNEG            = 118;\n+    public static final int DNEG            = 119;\n+    public static final int ISHL            = 120;\n+    public static final int LSHL            = 121;\n+    public static final int ISHR            = 122;\n+    public static final int LSHR            = 123;\n+    public static final int IUSHR           = 124;\n+    public static final int LUSHR           = 125;\n+    public static final int IAND            = 126;\n+    public static final int LAND            = 127;\n+    public static final int IOR             = 128;\n+    public static final int LOR             = 129;\n+    public static final int IXOR            = 130;\n+    public static final int LXOR            = 131;\n+    public static final int IINC            = 132;\n+    public static final int I2L             = 133;\n+    public static final int I2F             = 134;\n+    public static final int I2D             = 135;\n+    public static final int L2I             = 136;\n+    public static final int L2F             = 137;\n+    public static final int L2D             = 138;\n+    public static final int F2I             = 139;\n+    public static final int F2L             = 140;\n+    public static final int F2D             = 141;\n+    public static final int D2I             = 142;\n+    public static final int D2L             = 143;\n+    public static final int D2F             = 144;\n+    public static final int I2B             = 145;\n+    public static final int I2C             = 146;\n+    public static final int I2S             = 147;\n+    public static final int LCMP            = 148;\n+    public static final int FCMPL           = 149;\n+    public static final int FCMPG           = 150;\n+    public static final int DCMPL           = 151;\n+    public static final int DCMPG           = 152;\n+    public static final int IFEQ            = 153;\n+    public static final int IFNE            = 154;\n+    public static final int IFLT            = 155;\n+    public static final int IFGE            = 156;\n+    public static final int IFGT            = 157;\n+    public static final int IFLE            = 158;\n+    public static final int IF_ICMPEQ       = 159;\n+    public static final int IF_ICMPNE       = 160;\n+    public static final int IF_ICMPLT       = 161;\n+    public static final int IF_ICMPGE       = 162;\n+    public static final int IF_ICMPGT       = 163;\n+    public static final int IF_ICMPLE       = 164;\n+    public static final int IF_ACMPEQ       = 165;\n+    public static final int IF_ACMPNE       = 166;\n+    public static final int GOTO            = 167;\n+    public static final int JSR             = 168;\n+    public static final int RET             = 169;\n+    public static final int TABLESWITCH     = 170;\n+    public static final int LOOKUPSWITCH    = 171;\n+    public static final int IRETURN         = 172;\n+    public static final int LRETURN         = 173;\n+    public static final int FRETURN         = 174;\n+    public static final int DRETURN         = 175;\n+    public static final int ARETURN         = 176;\n+    public static final int RETURN          = 177;\n+    public static final int GETSTATIC       = 178;\n+    public static final int PUTSTATIC       = 179;\n+    public static final int GETFIELD        = 180;\n+    public static final int PUTFIELD        = 181;\n+    public static final int INVOKEVIRTUAL   = 182;\n+    public static final int INVOKESPECIAL   = 183;\n+    public static final int INVOKESTATIC    = 184;\n+    public static final int INVOKEINTERFACE = 185;\n+    public static final int INVOKEDYNAMIC   = 186;\n+    public static final int NEW             = 187;\n+    public static final int NEWARRAY        = 188;\n+    public static final int ANEWARRAY       = 189;\n+    public static final int ARRAYLENGTH     = 190;\n+    public static final int ATHROW          = 191;\n+    public static final int CHECKCAST       = 192;\n+    public static final int INSTANCEOF      = 193;\n+    public static final int MONITORENTER    = 194;\n+    public static final int MONITOREXIT     = 195;\n+    public static final int WIDE            = 196;\n+    public static final int MULTIANEWARRAY  = 197;\n+    public static final int IFNULL          = 198;\n+    public static final int IFNONNULL       = 199;\n+    public static final int GOTO_W          = 200;\n+    public static final int JSR_W           = 201;\n+\n+    public static final int ACC_PUBLIC = 0x0001;\n+    public static final int ACC_PROTECTED = 0x0004;\n+    public static final int ACC_PRIVATE = 0x0002;\n+    public static final int ACC_INTERFACE = 0x0200;\n+    public static final int ACC_ENUM = 0x4000;\n+    public static final int ACC_ANNOTATION = 0x2000;\n+    public static final int ACC_SUPER = 0x0020;\n+    public static final int ACC_ABSTRACT = 0x0400;\n+    public static final int ACC_VOLATILE = 0x0040;\n+    public static final int ACC_TRANSIENT = 0x0080;\n+    public static final int ACC_SYNTHETIC = 0x1000;\n+    public static final int ACC_STATIC = 0x0008;\n+    public static final int ACC_FINAL = 0x0010;\n+    public static final int ACC_SYNCHRONIZED = 0x0020;\n+    public static final int ACC_BRIDGE = 0x0040;\n+    public static final int ACC_VARARGS = 0x0080;\n+    public static final int ACC_NATIVE = 0x0100;\n+    public static final int ACC_STRICT = 0x0800;\n+    public static final int ACC_MODULE = 0x8000;\n+    public static final int ACC_OPEN = 0x20;\n+    public static final int ACC_MANDATED = 0x8000;\n+    public static final int ACC_TRANSITIVE = 0x20;\n+    public static final int ACC_STATIC_PHASE = 0x40;\n+\n+    public static final int CRT_STATEMENT       = 0x0001;\n+    public static final int CRT_BLOCK           = 0x0002;\n+    public static final int CRT_ASSIGNMENT      = 0x0004;\n+    public static final int CRT_FLOW_CONTROLLER = 0x0008;\n+    public static final int CRT_FLOW_TARGET     = 0x0010;\n+    public static final int CRT_INVOKE          = 0x0020;\n+    public static final int CRT_CREATE          = 0x0040;\n+    public static final int CRT_BRANCH_TRUE     = 0x0080;\n+    public static final int CRT_BRANCH_FALSE    = 0x0100;\n+\n+    public static final int TAG_CLASS = 7;\n+    public static final int TAG_CONSTANTDYNAMIC = 17;\n+    public static final int TAG_DOUBLE = 6;\n+    public static final int TAG_FIELDREF = 9;\n+    public static final int TAG_FLOAT = 4;\n+    public static final int TAG_INTEGER = 3;\n+    public static final int TAG_INTERFACEMETHODREF = 11;\n+    public static final int TAG_INVOKEDYNAMIC = 18;\n+    public static final int TAG_LONG = 5;\n+    public static final int TAG_METHODHANDLE = 15;\n+    public static final int TAG_METHODREF = 10;\n+    public static final int TAG_METHODTYPE = 16;\n+    public static final int TAG_MODULE = 19;\n+    public static final int TAG_NAMEANDTYPE = 12;\n+    public static final int TAG_PACKAGE = 20;\n+    public static final int TAG_STRING = 8;\n+    public static final int TAG_UNICODE = 2;\n+    public static final int TAG_UTF8 = 1;\n+\n+    \/\/type annotations\n+    public static final int TAT_CLASS_TYPE_PARAMETER = 0x00;\n+    public static final int TAT_METHOD_TYPE_PARAMETER = 0x01;\n+    public static final int TAT_CLASS_EXTENDS = 0x10;\n+    public static final int TAT_CLASS_TYPE_PARAMETER_BOUND = 0x11;\n+    public static final int TAT_METHOD_TYPE_PARAMETER_BOUND = 0x12;\n+    public static final int TAT_FIELD = 0x13;\n+    public static final int TAT_METHOD_RETURN = 0x14;\n+    public static final int TAT_METHOD_RECEIVER = 0x15;\n+    public static final int TAT_METHOD_FORMAL_PARAMETER = 0x16;\n+    public static final int TAT_THROWS = 0x17;\n+    public static final int TAT_LOCAL_VARIABLE = 0x40;\n+    public static final int TAT_RESOURCE_VARIABLE = 0x41;\n+    public static final int TAT_EXCEPTION_PARAMETER = 0x42;\n+    public static final int TAT_INSTANCEOF = 0x43;\n+    public static final int TAT_NEW = 0x44;\n+    public static final int TAT_CONSTRUCTOR_REFERENCE = 0x45;\n+    public static final int TAT_METHOD_REFERENCE = 0x46;\n+    public static final int TAT_CAST = 0x47;\n+    public static final int TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;\n+    public static final int TAT_METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;\n+    public static final int TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;\n+    public static final int TAT_METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;\n+\n+    \/\/stackmap verification types\n+    public static final int VT_TOP = 0;\n+    public static final int VT_INTEGER = 1;\n+    public static final int VT_FLOAT = 2;\n+    public static final int VT_DOUBLE = 3;\n+    public static final int VT_LONG = 4;\n+    public static final int VT_NULL = 5;\n+    public static final int VT_UNINITIALIZED_THIS = 6;\n+    public static final int VT_OBJECT = 7;\n+    public static final int VT_UNINITIALIZED = 8;\n+\n+    public static final int DEFAULT_CLASS_FLAGS = ACC_PUBLIC;\n+\n+    public static final int JAVA_1_VERSION = 45;\n+    public static final int JAVA_2_VERSION = 46;\n+    public static final int JAVA_3_VERSION = 47;\n+    public static final int JAVA_4_VERSION = 48;\n+    public static final int JAVA_5_VERSION = 49;\n+    public static final int JAVA_6_VERSION = 50;\n+    public static final int JAVA_7_VERSION = 51;\n+    public static final int JAVA_8_VERSION = 52;\n+    public static final int JAVA_9_VERSION = 53;\n+    public static final int JAVA_10_VERSION = 54;\n+    public static final int JAVA_11_VERSION = 55;\n+    public static final int JAVA_12_VERSION = 56;\n+    public static final int JAVA_13_VERSION = 57;\n+    public static final int JAVA_14_VERSION = 58;\n+    public static final int JAVA_15_VERSION = 59;\n+    public static final int JAVA_16_VERSION = 60;\n+    public static final int JAVA_17_VERSION = 61;\n+    public static final int JAVA_18_VERSION = 62;\n+    public static final int JAVA_19_VERSION = 63;\n+    public static final int JAVA_20_VERSION = 64;\n+    public static final int JAVA_21_VERSION = 65;\n+\n+    public static final int LATEST_MAJOR_VERSION = JAVA_21_VERSION;\n+    public static final int LATEST_MINOR_VERSION = 0;\n+    public static final int PREVIEW_MINOR_VERSION = -1;\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":652,"deletions":0,"binary":false,"changes":652,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+\n+\/**\n+ * A builder for a classfile or portion of a classfile.  Builders are rarely\n+ * created directly; they are passed to handlers by methods such as\n+ * {@link Classfile#build(ClassDesc, Consumer)} or to transforms.\n+ * Elements of the newly built entity can be specified\n+ * abstractly (by passing a {@link ClassfileElement} to {@link #with(ClassfileElement)}\n+ * or concretely by calling the various {@code withXxx} methods.\n+ *\n+ * @see ClassfileTransform\n+ *\/\n+public\n+interface ClassfileBuilder<E extends ClassfileElement, B extends ClassfileBuilder<E, B>>\n+        extends Consumer<E> {\n+\n+    \/**\n+     * Integrate the {@link ClassfileElement} into the entity being built.\n+     * @param e the element\n+     *\/\n+    @Override\n+    default void accept(E e) {\n+        with(e);\n+    }\n+\n+    \/**\n+     * Integrate the {@link ClassfileElement} into the entity being built.\n+     * @param e the element\n+     * @return this builder\n+     *\/\n+    B with(E e);\n+\n+    \/**\n+     * {@return the constant pool builder associated with this builder}\n+     *\/\n+    ConstantPoolBuilder constantPool();\n+\n+    \/**\n+     * {@return whether the provided constant pool is compatible with this builder}\n+     * @param source the constant pool to test compatibility with\n+     *\/\n+    default boolean canWriteDirect(ConstantPool source) {\n+        return constantPool().canWriteDirect(source);\n+    }\n+\n+    \/**\n+     * Apply a transform to a model, directing results to this builder.\n+     * @param model the model to transform\n+     * @param transform the transform to apply\n+     *\/\n+    default void transform(CompoundElement<E> model, ClassfileTransform<?, E, B> transform) {\n+        @SuppressWarnings(\"unchecked\")\n+        B builder = (B) this;\n+        var resolved = transform.resolve(builder);\n+        resolved.startHandler().run();\n+        model.forEachElement(resolved.consumer());\n+        resolved.endHandler().run();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassfileBuilder.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+\/**\n+ * Immutable model for a portion of (or the entirety of) a classfile.  Elements\n+ * that model parts of the classfile that have attributes will implement {@link\n+ * AttributedElement}; elements that model complex parts of the classfile that\n+ * themselves contain their own child elements will implement {@link\n+ * CompoundElement}.  Elements specific to various locations in the classfile\n+ * will implement {@link ClassElement}, {@link MethodElement}, etc.\n+ *\/\n+public sealed interface ClassfileElement\n+        permits AttributedElement, CompoundElement, WritableElement,\n+                ClassElement, CodeElement, FieldElement, MethodElement {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassfileElement.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+\n+\/**\n+ * A transformation on streams of elements. Transforms are used during\n+ * transformation of classfile entities; a transform is provided to a method like\n+ * {@link ClassModel#transform(ClassTransform)}, and the elements of the class,\n+ * along with a builder, are presented to the transform.\n+ *\n+ * <p>The subtypes of {@linkplain\n+ * ClassfileTransform} (e.g., {@link ClassTransform}) are functional interfaces\n+ * that accept an element and a corresponding builder.  Since any element can be\n+ * reproduced on the builder via {@link ClassBuilder#with(ClassfileElement)}, a\n+ * transform can easily leave elements in place, remove them, replace them, or\n+ * augment them with other elements.  This enables localized transforms to be\n+ * represented concisely.\n+ *\n+ * <p>Transforms also have an {@link #atEnd(ClassfileBuilder)} method, for\n+ * which the default implementation does nothing, so that a transform can\n+ * perform additional building after the stream of elements is exhausted.\n+ *\n+ * <p>Transforms can be chained together via the {@link\n+ * #andThen(ClassfileTransform)} method, so that the output of one becomes the\n+ * input to another.  This allows smaller units of transformation to be captured\n+ * and reused.\n+ *\n+ * <p>Some transforms are stateful; for example, a transform that injects an\n+ * annotation on a class may watch for the {@link RuntimeVisibleAnnotationsAttribute}\n+ * element and transform it if found, but if it is not found, will generate a\n+ * {@linkplain RuntimeVisibleAnnotationsAttribute} element containing the\n+ * injected annotation from the {@linkplain #atEnd(ClassfileBuilder)} handler.\n+ * To do this, the transform must accumulate some state during the traversal so\n+ * that the end handler knows what to do.  If such a transform is to be reused,\n+ * its state must be reset for each traversal; this will happen automatically if\n+ * the transform is created with {@link ClassTransform#ofStateful(Supplier)} (or\n+ * corresponding methods for other classfile locations.)\n+ * <p>\n+ * Class transformation sample where code transformation is stateful:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeRelabeling\"}\n+ * <p>\n+ * Complex class instrumentation sample chaining multiple transformations:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"classInstrumentation\"}\n+ *\/\n+public sealed interface ClassfileTransform<\n+        C extends ClassfileTransform<C, E, B>,\n+        E extends ClassfileElement,\n+        B extends ClassfileBuilder<E, B>>\n+        permits ClassTransform, FieldTransform, MethodTransform, CodeTransform {\n+    \/**\n+     * Transform an element by taking the appropriate actions on the builder.\n+     * Used when transforming a classfile entity (class, method, field, method\n+     * body.) If no transformation is desired, the element can be presented to\n+     * {@link B#with(ClassfileElement)}.  If the element is to be dropped, no\n+     * action is required.\n+     *\n+     * @param builder the builder for the new entity\n+     * @param element the element\n+     *\/\n+    void accept(B builder, E element);\n+\n+    \/**\n+     * Take any final action during transformation of a classfile entity.  Called\n+     * after all elements of the class are presented to {@link\n+     * #accept(ClassfileBuilder, ClassfileElement)}.\n+     *\n+     * @param builder the builder for the new entity\n+     * @implSpec The default implementation does nothing.\n+     *\/\n+    default void atEnd(B builder) {\n+    }\n+\n+    \/**\n+     * Take any preliminary action during transformation of a classfile entity.\n+     * Called before any elements of the class are presented to {@link\n+     * #accept(ClassfileBuilder, ClassfileElement)}.\n+     *\n+     * @param builder the builder for the new entity\n+     * @implSpec The default implementation does nothing.\n+     *\/\n+    default void atStart(B builder) {\n+    }\n+\n+    \/**\n+     * Chain this transform with another; elements presented to the builder of\n+     * this transform will become the input to the next transform.\n+     *\n+     * @param next the downstream transform\n+     * @return the chained transform\n+     *\/\n+    C andThen(C next);\n+\n+    \/**\n+     * The result of binding a transform to a builder.  Used primarily within\n+     * the implementation to perform transformation.\n+     *\n+     * @param <E> the element type\n+     *\/\n+    interface ResolvedTransform<E extends ClassfileElement> {\n+        \/**\n+         * {@return a {@link Consumer} to receive elements}\n+         *\/\n+        Consumer<E> consumer();\n+\n+        \/**\n+         * {@return an action to call at the end of transformation}\n+         *\/\n+        Runnable endHandler();\n+\n+        \/**\n+         * {@return an action to call at the start of transformation}\n+         *\/\n+        Runnable startHandler();\n+    }\n+\n+    \/**\n+     * Bind a transform to a builder.  If the transform is chained, intermediate\n+     * builders are created for each chain link.  If the transform is stateful\n+     * (see, e.g., {@link ClassTransform#ofStateful(Supplier)}), the supplier is\n+     * invoked to get a fresh transform object.\n+     *\n+     * <p>This method is a low-level method that should rarely be used by\n+     * user code; most of the time, user code should prefer\n+     * {@link ClassfileBuilder#transform(CompoundElement, ClassfileTransform)},\n+     * which resolves the transform and executes it on the current builder.\n+     *\n+     * @param builder the builder to bind to\n+     * @return the bound result\n+     *\/\n+    ResolvedTransform<E> resolve(B builder);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassfileTransform.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.impl.ClassfileVersionImpl;\n+\n+\/**\n+ * Models the classfile version information for a class.  Delivered as a {@link\n+ * jdk.internal.classfile.ClassElement} when traversing the elements of a {@link\n+ * ClassModel}.\n+ *\/\n+public sealed interface ClassfileVersion\n+        extends ClassElement\n+        permits ClassfileVersionImpl {\n+    \/**\n+     * {@return the major classfile version}\n+     *\/\n+    int majorVersion();\n+\n+    \/**\n+     * {@return the minor classfile version}\n+     *\/\n+    int minorVersion();\n+\n+    \/**\n+     * {@return a {@link ClassfileVersion} element}\n+     * @param majorVersion the major classfile version\n+     * @param minorVersion the minor classfile version\n+     *\/\n+    static ClassfileVersion of(int majorVersion, int minorVersion) {\n+        return new ClassfileVersionImpl(majorVersion, minorVersion);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassfileVersion.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,1386 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.BlockCodeBuilderImpl;\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.CatchBuilderImpl;\n+import jdk.internal.classfile.impl.ChainedCodeBuilder;\n+import jdk.internal.classfile.impl.LabelImpl;\n+import jdk.internal.classfile.impl.LineNumberImpl;\n+import jdk.internal.classfile.impl.NonterminalCodeBuilder;\n+import jdk.internal.classfile.impl.TerminalCodeBuilder;\n+import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n+import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.ConvertInstruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.MonitorInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StackInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.SwitchCase;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.instruction.ThrowInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+\n+import static java.util.Objects.requireNonNull;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+import static jdk.internal.classfile.impl.BytecodeHelpers.handleDescToHandleInfo;\n+import jdk.internal.classfile.impl.TransformingCodeBuilder;\n+\n+\/**\n+ * A builder for code attributes (method bodies).  Builders are not created\n+ * directly; they are passed to handlers by methods such as {@link\n+ * MethodBuilder#withCode(Consumer)} or to code transforms.  The elements of a\n+ * code can be specified abstractly (by passing a {@link CodeElement} to {@link\n+ * #with(ClassfileElement)} or concretely by calling the various {@code withXxx}\n+ * methods.\n+ *\n+ * @see CodeTransform\n+ *\/\n+public sealed interface CodeBuilder\n+        extends ClassfileBuilder<CodeElement, CodeBuilder>\n+        permits CodeBuilder.BlockCodeBuilder, ChainedCodeBuilder, TerminalCodeBuilder, NonterminalCodeBuilder {\n+\n+    \/**\n+     * {@return the {@link CodeModel} representing the method body being transformed,\n+     * if this code builder represents the transformation of some {@link CodeModel}}\n+     *\/\n+    Optional<CodeModel> original();\n+\n+    \/** {@return a fresh unbound label} *\/\n+    Label newLabel();\n+\n+    \/** {@return the label associated with the beginning of the current block}\n+     * If the current {@linkplain CodeBuilder} is not a \"block\" builder, such as\n+     * those provided by {@link #block(Consumer)} or {@link #ifThenElse(Consumer, Consumer)},\n+     * the current block will be the entire method body. *\/\n+    Label startLabel();\n+\n+    \/** {@return the label associated with the end of the current block}\n+     * If the current {@linkplain CodeBuilder} is not a \"block\" builder, such as\n+     * those provided by {@link #block(Consumer)} or {@link #ifThenElse(Consumer, Consumer)},\n+     * the current block will be the entire method body. *\/\n+    Label endLabel();\n+\n+    \/**\n+     * {@return the local variable slot associated with the receiver}.\n+     *\n+     * @throws IllegalStateException if this is not a static method\n+     *\/\n+    int receiverSlot();\n+\n+    \/**\n+     * {@return the local variable slot associated with the specified parameter}.\n+     * The returned value is adjusted for the receiver slot (if the method is\n+     * an instance method) and for the requirement that {@code long} and {@code double}\n+     * values require two slots.\n+     *\n+     * @param paramNo the index of the parameter\n+     *\/\n+    int parameterSlot(int paramNo);\n+\n+    \/**\n+     * {@return the local variable slot of a fresh local variable}  This method\n+     * makes reasonable efforts to determine which slots are in use and which\n+     * are not.  When transforming a method, fresh locals begin at the {@code maxLocals}\n+     * of the original method.  For a method being built directly, fresh locals\n+     * begin after the last parameter slot.\n+     *\n+     * <p>If the current code builder is a \"block\" code builder provided by\n+     * {@link #block(Consumer)}, {@link #ifThen(Consumer)}, or\n+     * {@link #ifThenElse(Consumer, Consumer)}, at the end of the block, locals\n+     * are reset to their value at the beginning of the block.\n+     *\n+     * @param typeKind the type of the local variable\n+     *\/\n+    int allocateLocal(TypeKind typeKind);\n+\n+    \/**\n+     * Builds code fragment generated by the handler and synchronously transformed.\n+     *\n+     * @param transform the transform to apply to the code generated by the handler\n+     * @param handler handler that receives a {@linkplain CodeBuilder} to\n+     * generate the code.\n+     * @return this builder\n+     *\/\n+    default CodeBuilder transforming(CodeTransform transform, Consumer<CodeBuilder> handler) {\n+        var resolved = transform.resolve(this);\n+        resolved.startHandler().run();\n+        handler.accept(new TransformingCodeBuilder(this, resolved.consumer()));\n+        resolved.endHandler().run();\n+        return this;\n+    }\n+\n+    \/**\n+     * A builder for blocks of code.\n+     *\/\n+    sealed interface BlockCodeBuilder extends CodeBuilder\n+            permits BlockCodeBuilderImpl {\n+        \/**\n+         * {@return the label locating where control is passed back to the parent block.}\n+         * A branch to this label \"break\"'s out of the current block.\n+         * <p>\n+         * If an instruction occurring immediately after the built block's last instruction would\n+         * be reachable from that last instruction, then a {@linkplain #goto_ goto} instruction\n+         * targeting the \"break\" label is appended to the built block.\n+         *\/\n+        Label breakLabel();\n+    }\n+\n+    \/**\n+     * Add a lexical block to the method being built.\n+     * <p>\n+     * Within this block, the {@link #startLabel()} and {@link #endLabel()} correspond\n+     * to the start and end of the block, and the {@link BlockCodeBuilder#breakLabel()}\n+     * also corresponds to the end of the block.\n+     *\n+     * @param handler handler that receives a {@linkplain BlockCodeBuilder} to\n+     * generate the body of the lexical block.\n+     *\/\n+    default CodeBuilder block(Consumer<BlockCodeBuilder> handler) {\n+        Label breakLabel = newLabel();\n+        BlockCodeBuilderImpl child = new BlockCodeBuilderImpl(this, breakLabel);\n+        child.start();\n+        handler.accept(child);\n+        child.end();\n+        labelBinding(breakLabel);\n+        return this;\n+    }\n+\n+    \/**\n+     * Add an \"if-then\" block that is conditional on the boolean value\n+     * on top of the operand stack.\n+     * <p>\n+     * The {@link BlockCodeBuilder#breakLabel()} for the \"then\" block corresponds to the\n+     * end of that block.\n+     *\n+     * @param thenHandler handler that receives a {@linkplain BlockCodeBuilder} to\n+     *                    generate the body of the {@code if}\n+     * @return this builder\n+     *\/\n+    default CodeBuilder ifThen(Consumer<BlockCodeBuilder> thenHandler) {\n+        return ifThen(Opcode.IFNE, thenHandler);\n+    }\n+\n+    \/**\n+     * Add an \"if-then\" block that is conditional on the value(s) on top of the operand stack\n+     * in accordance with the given opcode.\n+     * <p>\n+     * The {@link BlockCodeBuilder#breakLabel()} for the \"then\" block corresponds to the\n+     * end of that block.\n+     *\n+     * @param opcode the operation code for a branch instructions that accepts one or two operands on the stack\n+     * @param thenHandler handler that receives a {@linkplain BlockCodeBuilder} to\n+     *                    generate the body of the {@code if}\n+     * @return this builder\n+     * @throws java.lang.IllegalArgumentException if the operation code is not for a branch instruction that accepts\n+     * one or two operands\n+     *\/\n+    default CodeBuilder ifThen(Opcode opcode,\n+                               Consumer<BlockCodeBuilder> thenHandler) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+            throw new IllegalArgumentException(\"Illegal branch opcode: \" + opcode);\n+        }\n+\n+        Label breakLabel = newLabel();\n+        BlockCodeBuilderImpl thenBlock = new BlockCodeBuilderImpl(this, breakLabel);\n+        branchInstruction(BytecodeHelpers.reverseBranchOpcode(opcode), thenBlock.endLabel());\n+        thenBlock.start();\n+        thenHandler.accept(thenBlock);\n+        thenBlock.end();\n+        labelBinding(breakLabel);\n+        return this;\n+    }\n+\n+    \/**\n+     * Add an \"if-then-else\" block that is conditional on the boolean value\n+     * on top of the operand stack.\n+     * <p>\n+     * The {@link BlockCodeBuilder#breakLabel()} for each block corresponds to the\n+     * end of the \"else\" block.\n+     *\n+     * @param thenHandler handler that receives a {@linkplain BlockCodeBuilder} to\n+     *                    generate the body of the {@code if}\n+     * @param elseHandler handler that receives a {@linkplain BlockCodeBuilder} to\n+     *                    generate the body of the {@code else}\n+     * @return this builder\n+     *\/\n+    default CodeBuilder ifThenElse(Consumer<BlockCodeBuilder> thenHandler,\n+                                   Consumer<BlockCodeBuilder> elseHandler) {\n+        return ifThenElse(Opcode.IFNE, thenHandler, elseHandler);\n+    }\n+\n+    \/**\n+     * Add an \"if-then-else\" block that is conditional on the value(s) on top of the operand stack\n+     * in accordance with the given opcode.\n+     * <p>\n+     * The {@link BlockCodeBuilder#breakLabel()} for each block corresponds to the\n+     * end of the \"else\" block.\n+     *\n+     * @param opcode the operation code for a branch instructions that accepts one or two operands on the stack\n+     * @param thenHandler handler that receives a {@linkplain BlockCodeBuilder} to\n+     *                    generate the body of the {@code if}\n+     * @param elseHandler handler that receives a {@linkplain BlockCodeBuilder} to\n+     *                    generate the body of the {@code else}\n+     * @return this builder\n+     * @throws java.lang.IllegalArgumentException if the operation code is not for a branch instruction that accepts\n+     * one or two operands\n+     *\/\n+    default CodeBuilder ifThenElse(Opcode opcode,\n+                                   Consumer<BlockCodeBuilder> thenHandler,\n+                                   Consumer<BlockCodeBuilder> elseHandler) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+            throw new IllegalArgumentException(\"Illegal branch opcode: \" + opcode);\n+        }\n+\n+        Label breakLabel = newLabel();\n+        BlockCodeBuilderImpl thenBlock = new BlockCodeBuilderImpl(this, breakLabel);\n+        BlockCodeBuilderImpl elseBlock = new BlockCodeBuilderImpl(this, breakLabel);\n+        branchInstruction(BytecodeHelpers.reverseBranchOpcode(opcode), elseBlock.startLabel());\n+        thenBlock.start();\n+        thenHandler.accept(thenBlock);\n+        if (thenBlock.reachable())\n+            thenBlock.branchInstruction(Opcode.GOTO, thenBlock.breakLabel());\n+        thenBlock.end();\n+        elseBlock.start();\n+        elseHandler.accept(elseBlock);\n+        elseBlock.end();\n+        labelBinding(breakLabel);\n+        return this;\n+    }\n+\n+    \/**\n+     * A builder to add catch blocks.\n+     *\n+     * @see #trying\n+     *\/\n+    sealed interface CatchBuilder permits CatchBuilderImpl {\n+        \/**\n+         * Adds a catch block that catches an exception of the given type.\n+         * <p>\n+         * The caught exception will be on top of the operand stack when the catch block is entered.\n+         * <p>\n+         * If the type of exception is {@code null} then the catch block catches all exceptions.\n+         *\n+         * @param exceptionType the type of exception to catch.\n+         * @param catchHandler handler that receives a {@linkplain CodeBuilder} to\n+         *                     generate the body of the catch block.\n+         * @return this builder\n+         * @throws java.lang.IllegalArgumentException if an existing catch block catches an exception of the given type.\n+         * @see #catchingMulti\n+         * @see #catchingAll\n+         *\/\n+        CatchBuilder catching(ClassDesc exceptionType, Consumer<BlockCodeBuilder> catchHandler);\n+\n+        \/**\n+         * Adds a catch block that catches exceptions of the given types.\n+         * <p>\n+         * The caught exception will be on top of the operand stack when the catch block is entered.\n+         * <p>\n+         * If the type of exception is {@code null} then the catch block catches all exceptions.\n+         *\n+         * @param exceptionTypes the types of exception to catch.\n+         * @param catchHandler handler that receives a {@linkplain CodeBuilder} to\n+         *                     generate the body of the catch block.\n+         * @return this builder\n+         * @throws java.lang.IllegalArgumentException if an existing catch block catches one or more exceptions of the given types.\n+         * @see #catching\n+         * @see #catchingAll\n+         *\/\n+        CatchBuilder catchingMulti(List<ClassDesc> exceptionTypes, Consumer<BlockCodeBuilder> catchHandler);\n+\n+        \/**\n+         * Adds a \"catch\" block that catches all exceptions.\n+         * <p>\n+         * The caught exception will be on top of the operand stack when the catch block is entered.\n+         *\n+         * @param catchAllHandler handler that receives a {@linkplain CodeBuilder} to\n+         *                        generate the body of the catch block\n+         * @throws java.lang.IllegalArgumentException if an existing catch block catches all exceptions.\n+         * @see #catching\n+         * @see #catchingMulti\n+         *\/\n+        void catchingAll(Consumer<BlockCodeBuilder> catchAllHandler);\n+    }\n+\n+    \/**\n+     * Adds a \"try-catch\" block comprising one try block and zero or more catch blocks.\n+     * Exceptions thrown by instructions in the try block may be caught by catch blocks.\n+     *\n+     * @param tryHandler handler that receives a {@linkplain CodeBuilder} to\n+     *                   generate the body of the try block.\n+     * @param catchesHandler a handler that receives a {@linkplain CatchBuilder}\n+     *                       to generate bodies of catch blocks.\n+     * @return this builder\n+     * @see CatchBuilder\n+     *\/\n+    default CodeBuilder trying(Consumer<BlockCodeBuilder> tryHandler,\n+                               Consumer<CatchBuilder> catchesHandler) {\n+        Label tryCatchEnd = newLabel();\n+\n+        BlockCodeBuilderImpl tryBlock = new BlockCodeBuilderImpl(this, tryCatchEnd);\n+        tryBlock.start();\n+        tryHandler.accept(tryBlock);\n+        tryBlock.end();\n+\n+        \/\/ Check for empty try block\n+        if (tryBlock.isEmpty()) {\n+            throw new IllegalStateException(\"The body of the try block is empty\");\n+        }\n+\n+        var catchBuilder = new CatchBuilderImpl(this, tryBlock, tryCatchEnd);\n+        catchesHandler.accept(catchBuilder);\n+        catchBuilder.finish();\n+\n+        return this;\n+    }\n+\n+    \/\/ Base convenience methods\n+\n+    default CodeBuilder loadInstruction(TypeKind tk, int slot) {\n+        with(LoadInstruction.of(tk, slot));\n+        return this;\n+    }\n+\n+    default CodeBuilder storeInstruction(TypeKind tk, int slot) {\n+        with(StoreInstruction.of(tk, slot));\n+        return this;\n+    }\n+\n+    default CodeBuilder incrementInstruction(int slot, int val) {\n+        with(IncrementInstruction.of(slot, val));\n+        return this;\n+    }\n+\n+    default CodeBuilder branchInstruction(Opcode op, Label target) {\n+        with(BranchInstruction.of(op, target));\n+        return this;\n+    }\n+\n+    default CodeBuilder lookupSwitchInstruction(Label defaultTarget, List<SwitchCase> cases) {\n+        with(LookupSwitchInstruction.of(defaultTarget, cases));\n+        return this;\n+    }\n+\n+    default CodeBuilder tableSwitchInstruction(int lowValue, int highValue, Label defaultTarget, List<SwitchCase> cases) {\n+        with(TableSwitchInstruction.of(lowValue, highValue, defaultTarget, cases));\n+        return this;\n+    }\n+\n+    default CodeBuilder returnInstruction(TypeKind tk) {\n+        with(ReturnInstruction.of(tk));\n+        return this;\n+    }\n+\n+    default CodeBuilder throwInstruction() {\n+        with(ThrowInstruction.of());\n+        return this;\n+    }\n+\n+    default CodeBuilder fieldInstruction(Opcode opcode, FieldRefEntry ref) {\n+        with(FieldInstruction.of(opcode, ref));\n+        return this;\n+    }\n+\n+    default CodeBuilder fieldInstruction(Opcode opcode, ClassDesc owner, String name, ClassDesc type) {\n+        return fieldInstruction(opcode, constantPool().fieldRefEntry(owner, name, type));\n+    }\n+\n+    default CodeBuilder invokeInstruction(Opcode opcode, MemberRefEntry ref) {\n+        return with(InvokeInstruction.of(opcode, ref));\n+    }\n+\n+    default CodeBuilder invokeInstruction(Opcode opcode, ClassDesc owner, String name, MethodTypeDesc desc, boolean isInterface) {\n+        return invokeInstruction(opcode,\n+                isInterface ? constantPool().interfaceMethodRefEntry(owner, name, desc)\n+                            : constantPool().methodRefEntry(owner, name, desc));\n+    }\n+\n+    default CodeBuilder invokeDynamicInstruction(InvokeDynamicEntry ref) {\n+        with(InvokeDynamicInstruction.of(ref));\n+        return this;\n+    }\n+\n+    default CodeBuilder invokeDynamicInstruction(DynamicCallSiteDesc desc) {\n+        MethodHandleEntry bsMethod = handleDescToHandleInfo(constantPool(), (DirectMethodHandleDesc) desc.bootstrapMethod());\n+        var cpArgs = desc.bootstrapArgs();\n+        List<LoadableConstantEntry> bsArguments = new ArrayList<>(cpArgs.length);\n+        for (var constantValue : cpArgs) {\n+            bsArguments.add(BytecodeHelpers.constantEntry(constantPool(), constantValue));\n+        }\n+        BootstrapMethodEntry bm = constantPool().bsmEntry(bsMethod, bsArguments);\n+        NameAndTypeEntry nameAndType = constantPool().natEntry(desc.invocationName(), desc.invocationType());\n+        invokeDynamicInstruction(constantPool().invokeDynamicEntry(bm, nameAndType));\n+        return this;\n+    }\n+\n+    default CodeBuilder newObjectInstruction(ClassEntry type) {\n+        with(NewObjectInstruction.of(type));\n+        return this;\n+    }\n+\n+    default CodeBuilder newObjectInstruction(ClassDesc type) {\n+        return newObjectInstruction(constantPool().classEntry(type));\n+    }\n+\n+    default CodeBuilder newPrimitiveArrayInstruction(TypeKind typeKind) {\n+        with(NewPrimitiveArrayInstruction.of(typeKind));\n+        return this;\n+    }\n+\n+    default CodeBuilder newReferenceArrayInstruction(ClassEntry type) {\n+        with(NewReferenceArrayInstruction.of(type));\n+        return this;\n+    }\n+\n+    default CodeBuilder newReferenceArrayInstruction(ClassDesc type) {\n+        return newReferenceArrayInstruction(constantPool().classEntry(type));\n+    }\n+\n+    default CodeBuilder newMultidimensionalArrayInstruction(int dimensions,\n+                                                            ClassEntry type) {\n+        with(NewMultiArrayInstruction.of(type, dimensions));\n+        return this;\n+    }\n+\n+    default CodeBuilder newMultidimensionalArrayInstruction(int dimensions,\n+                                                            ClassDesc type) {\n+        return newMultidimensionalArrayInstruction(dimensions, constantPool().classEntry(type));\n+    }\n+\n+    default CodeBuilder arrayLoadInstruction(TypeKind tk) {\n+        Opcode opcode = BytecodeHelpers.arrayLoadOpcode(tk);\n+        with(ArrayLoadInstruction.of(opcode));\n+        return this;\n+    }\n+\n+    default CodeBuilder arrayStoreInstruction(TypeKind tk) {\n+        Opcode opcode = BytecodeHelpers.arrayStoreOpcode(tk);\n+        with(ArrayStoreInstruction.of(opcode));\n+        return this;\n+    }\n+\n+    default CodeBuilder typeCheckInstruction(Opcode opcode,\n+                                             ClassEntry type) {\n+        with(TypeCheckInstruction.of(opcode, type));\n+        return this;\n+    }\n+\n+    default CodeBuilder typeCheckInstruction(Opcode opcode, ClassDesc type) {\n+        return typeCheckInstruction(opcode, constantPool().classEntry(type));\n+    }\n+\n+    default CodeBuilder convertInstruction(TypeKind fromType, TypeKind toType) {\n+        with(ConvertInstruction.of(fromType, toType));\n+        return this;\n+    }\n+\n+    default CodeBuilder stackInstruction(Opcode opcode) {\n+        with(StackInstruction.of(opcode));\n+        return this;\n+    }\n+\n+    default CodeBuilder operatorInstruction(Opcode opcode) {\n+        with(OperatorInstruction.of(opcode));\n+        return this;\n+    }\n+\n+    default CodeBuilder constantInstruction(Opcode opcode, ConstantDesc value) {\n+        BytecodeHelpers.validateValue(opcode, value);\n+        return with(switch (opcode) {\n+            case SIPUSH, BIPUSH -> ConstantInstruction.ofArgument(opcode, ((Number)value).intValue());\n+            case LDC, LDC_W, LDC2_W -> ConstantInstruction.ofLoad(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n+            default -> ConstantInstruction.ofIntrinsic(opcode);\n+        });\n+    }\n+\n+    default CodeBuilder constantInstruction(ConstantDesc value) {\n+        \/\/avoid switch expressions here\n+        if (value == null || value == ConstantDescs.NULL)\n+            return aconst_null();\n+        if (value instanceof Integer iVal)\n+            return switch (iVal) {\n+                case -1 -> iconst_m1();\n+                case  0 -> iconst_0();\n+                case  1 -> iconst_1();\n+                case  2 -> iconst_2();\n+                case  3 -> iconst_3();\n+                case  4 -> iconst_4();\n+                case  5 -> iconst_5();\n+                default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n+                         : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n+                         : ldc(constantPool().intEntry(iVal));\n+            };\n+        if (value instanceof Long lVal)\n+            return lVal == 0l ? lconst_0()\n+                 : lVal == 1l ? lconst_1()\n+                 : ldc(constantPool().longEntry(lVal));\n+        if (value instanceof Float fVal)\n+            return fVal == 0.0f ? fconst_0()\n+                 : fVal == 1.0f ? fconst_1()\n+                 : fVal == 2.0f ? fconst_2()\n+                 : ldc(constantPool().floatEntry(fVal));\n+        if (value instanceof Double dVal)\n+            return dVal == 0.0d ? dconst_0()\n+                 : dVal == 1.0d ? dconst_1()\n+                 : ldc(constantPool().doubleEntry(dVal));\n+        return ldc(BytecodeHelpers.constantEntry(constantPool(), value));\n+    }\n+\n+    default CodeBuilder monitorInstruction(Opcode opcode) {\n+        with(MonitorInstruction.of(opcode));\n+        return null;\n+    }\n+\n+    default CodeBuilder nopInstruction() {\n+        with(NopInstruction.of());\n+        return this;\n+    }\n+\n+\n+    default CodeBuilder nop() {\n+        return nopInstruction();\n+    }\n+\n+    \/\/ Base pseudo-instruction builder methods\n+\n+    default Label newBoundLabel() {\n+        var label = newLabel();\n+        labelBinding(label);\n+        return label;\n+    }\n+\n+    default CodeBuilder labelBinding(Label label) {\n+        with((LabelImpl) label);\n+        return this;\n+    }\n+\n+    default CodeBuilder lineNumber(int line) {\n+        with(LineNumberImpl.of(line));\n+        return this;\n+    }\n+\n+    default CodeBuilder exceptionCatch(Label start, Label end, Label handler, ClassEntry catchType) {\n+        with(ExceptionCatch.of(handler, start, end, Optional.of(catchType)));\n+        return this;\n+    }\n+\n+    default CodeBuilder exceptionCatch(Label start, Label end, Label handler, Optional<ClassEntry> catchType) {\n+        with(ExceptionCatch.of(handler, start, end, catchType));\n+        return this;\n+    }\n+\n+    default CodeBuilder exceptionCatch(Label start, Label end, Label handler, ClassDesc catchType) {\n+        requireNonNull(catchType);\n+        return exceptionCatch(start, end, handler, constantPool().classEntry(catchType));\n+    }\n+\n+    default CodeBuilder exceptionCatchAll(Label start, Label end, Label handler) {\n+        with(ExceptionCatch.of(handler, start, end));\n+        return this;\n+    }\n+\n+    default CodeBuilder characterRange(Label startScope, Label endScope, int characterRangeStart, int characterRangeEnd, int flags) {\n+        with(new AbstractPseudoInstruction.UnboundCharacterRange(startScope, endScope, characterRangeStart, characterRangeEnd, flags));\n+        return this;\n+    }\n+\n+    default CodeBuilder localVariable(int slot, Utf8Entry nameEntry, Utf8Entry descriptorEntry, Label startScope, Label endScope) {\n+        with(new AbstractPseudoInstruction.UnboundLocalVariable(slot, nameEntry, descriptorEntry,\n+                                                          startScope, endScope));\n+        return this;\n+    }\n+\n+    default CodeBuilder localVariable(int slot, String name, ClassDesc descriptor, Label startScope, Label endScope) {\n+        return localVariable(slot,\n+                             constantPool().utf8Entry(name),\n+                             constantPool().utf8Entry(descriptor.descriptorString()),\n+                             startScope, endScope);\n+    }\n+\n+    default CodeBuilder localVariableType(int slot, Utf8Entry nameEntry, Utf8Entry signatureEntry, Label startScope, Label endScope) {\n+        with(new AbstractPseudoInstruction.UnboundLocalVariableType(slot, nameEntry, signatureEntry,\n+                                                              startScope, endScope));\n+        return this;\n+    }\n+\n+    default CodeBuilder localVariableType(int slot, String name, Signature signature, Label startScope, Label endScope) {\n+        return localVariableType(slot,\n+                                 constantPool().utf8Entry(name),\n+                                 constantPool().utf8Entry(signature.signatureString()),\n+                                 startScope, endScope);\n+    }\n+\n+    \/\/ Bytecode conveniences\n+\n+    default CodeBuilder aconst_null() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ACONST_NULL));\n+    }\n+\n+    default CodeBuilder aaload() {\n+        return arrayLoadInstruction(TypeKind.ReferenceType);\n+    }\n+\n+    default CodeBuilder aastore() {\n+        return arrayStoreInstruction(TypeKind.ReferenceType);\n+    }\n+\n+    default CodeBuilder aload(int slot) {\n+        return loadInstruction(TypeKind.ReferenceType, slot);\n+    }\n+\n+    default CodeBuilder anewarray(ClassEntry classEntry) {\n+        return newReferenceArrayInstruction(classEntry);\n+    }\n+\n+    default CodeBuilder anewarray(ClassDesc className) {\n+        return newReferenceArrayInstruction(constantPool().classEntry(className));\n+    }\n+\n+    default CodeBuilder areturn() {\n+        return returnInstruction(TypeKind.ReferenceType);\n+    }\n+\n+    default CodeBuilder arraylength() {\n+        return operatorInstruction(Opcode.ARRAYLENGTH);\n+    }\n+\n+    default CodeBuilder astore(int slot) {\n+        return storeInstruction(TypeKind.ReferenceType, slot);\n+    }\n+\n+    default CodeBuilder athrow() {\n+        return throwInstruction();\n+    }\n+\n+    default CodeBuilder baload() {\n+        return arrayLoadInstruction(TypeKind.ByteType);\n+    }\n+\n+    default CodeBuilder bastore() {\n+        return arrayStoreInstruction(TypeKind.ByteType);\n+    }\n+\n+    default CodeBuilder bipush(int b) {\n+        return constantInstruction(Opcode.BIPUSH, b);\n+    }\n+\n+    default CodeBuilder caload() {\n+        return arrayLoadInstruction(TypeKind.CharType);\n+    }\n+\n+    default CodeBuilder castore() {\n+        return arrayStoreInstruction(TypeKind.CharType);\n+    }\n+\n+    default CodeBuilder checkcast(ClassEntry type) {\n+        return typeCheckInstruction(Opcode.CHECKCAST, type);\n+    }\n+\n+    default CodeBuilder checkcast(ClassDesc type) {\n+        return typeCheckInstruction(Opcode.CHECKCAST, type);\n+    }\n+\n+    default CodeBuilder d2f() {\n+        return convertInstruction(TypeKind.DoubleType, TypeKind.FloatType);\n+    }\n+\n+    default CodeBuilder d2i() {\n+        return convertInstruction(TypeKind.DoubleType, TypeKind.IntType);\n+    }\n+\n+    default CodeBuilder d2l() {\n+        return convertInstruction(TypeKind.DoubleType, TypeKind.LongType);\n+    }\n+\n+    default CodeBuilder dadd() {\n+        return operatorInstruction(Opcode.DADD);\n+    }\n+\n+    default CodeBuilder daload() {\n+        return arrayLoadInstruction(TypeKind.DoubleType);\n+    }\n+\n+    default CodeBuilder dastore() {\n+        return arrayStoreInstruction(TypeKind.DoubleType);\n+    }\n+\n+    default CodeBuilder dcmpg() {\n+        return operatorInstruction(Opcode.DCMPG);\n+    }\n+\n+    default CodeBuilder dcmpl() {\n+        return operatorInstruction(Opcode.DCMPL);\n+    }\n+\n+    default CodeBuilder dconst_0() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.DCONST_0));\n+    }\n+\n+    default CodeBuilder dconst_1() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.DCONST_1));\n+    }\n+\n+    default CodeBuilder ddiv() {\n+        return operatorInstruction(Opcode.DDIV);\n+    }\n+\n+    default CodeBuilder dload(int slot) {\n+        return loadInstruction(TypeKind.DoubleType, slot);\n+    }\n+\n+    default CodeBuilder dmul() {\n+        return operatorInstruction(Opcode.DMUL);\n+    }\n+\n+    default CodeBuilder dneg() {\n+        return operatorInstruction(Opcode.DNEG);\n+    }\n+\n+    default CodeBuilder drem() {\n+        return operatorInstruction(Opcode.DREM);\n+    }\n+\n+    default CodeBuilder dreturn() {\n+        return returnInstruction(TypeKind.DoubleType);\n+    }\n+\n+    default CodeBuilder dstore(int slot) {\n+        return storeInstruction(TypeKind.DoubleType, slot);\n+    }\n+\n+    default CodeBuilder dsub() {\n+        return operatorInstruction(Opcode.DSUB);\n+    }\n+\n+    default CodeBuilder dup() {\n+        return stackInstruction(Opcode.DUP);\n+    }\n+\n+    default CodeBuilder dup2() {\n+        return stackInstruction(Opcode.DUP2);\n+    }\n+\n+    default CodeBuilder dup2_x1() {\n+        return stackInstruction(Opcode.DUP2_X1);\n+    }\n+\n+    default CodeBuilder dup2_x2() {\n+        return stackInstruction(Opcode.DUP2_X2);\n+    }\n+\n+    default CodeBuilder dup_x1() {\n+        return stackInstruction(Opcode.DUP_X1);\n+    }\n+\n+    default CodeBuilder dup_x2() {\n+        return stackInstruction(Opcode.DUP_X2);\n+    }\n+\n+    default CodeBuilder f2d() {\n+        return convertInstruction(TypeKind.FloatType, TypeKind.DoubleType);\n+    }\n+\n+    default CodeBuilder f2i() {\n+        return convertInstruction(TypeKind.FloatType, TypeKind.IntType);\n+    }\n+\n+    default CodeBuilder f2l() {\n+        return convertInstruction(TypeKind.FloatType, TypeKind.LongType);\n+    }\n+\n+    default CodeBuilder fadd() {\n+        return operatorInstruction(Opcode.FADD);\n+    }\n+\n+    default CodeBuilder faload() {\n+        return arrayLoadInstruction(TypeKind.FloatType);\n+    }\n+\n+    default CodeBuilder fastore() {\n+        return arrayStoreInstruction(TypeKind.FloatType);\n+    }\n+\n+    default CodeBuilder fcmpg() {\n+        return operatorInstruction(Opcode.FCMPG);\n+    }\n+\n+    default CodeBuilder fcmpl() {\n+        return operatorInstruction(Opcode.FCMPL);\n+    }\n+\n+    default CodeBuilder fconst_0() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.FCONST_0));\n+    }\n+\n+    default CodeBuilder fconst_1() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.FCONST_1));\n+    }\n+\n+    default CodeBuilder fconst_2() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.FCONST_2));\n+    }\n+\n+    default CodeBuilder fdiv() {\n+        return operatorInstruction(Opcode.FDIV);\n+    }\n+\n+    default CodeBuilder fload(int slot) {\n+        return loadInstruction(TypeKind.FloatType, slot);\n+    }\n+\n+    default CodeBuilder fmul() {\n+        return operatorInstruction(Opcode.FMUL);\n+    }\n+\n+    default CodeBuilder fneg() {\n+        return operatorInstruction(Opcode.FNEG);\n+    }\n+\n+    default CodeBuilder frem() {\n+        return operatorInstruction(Opcode.FREM);\n+    }\n+\n+    default CodeBuilder freturn() {\n+        return returnInstruction(TypeKind.FloatType);\n+    }\n+\n+    default CodeBuilder fstore(int slot) {\n+        return storeInstruction(TypeKind.FloatType, slot);\n+    }\n+\n+    default CodeBuilder fsub() {\n+        return operatorInstruction(Opcode.FSUB);\n+    }\n+\n+    default CodeBuilder getfield(FieldRefEntry ref) {\n+        return fieldInstruction(Opcode.GETFIELD, ref);\n+    }\n+\n+    default CodeBuilder getfield(ClassDesc owner, String name, ClassDesc type) {\n+        return fieldInstruction(Opcode.GETFIELD, owner, name, type);\n+    }\n+\n+    default CodeBuilder getstatic(FieldRefEntry ref) {\n+        return fieldInstruction(Opcode.GETSTATIC, ref);\n+    }\n+\n+    default CodeBuilder getstatic(ClassDesc owner, String name, ClassDesc type) {\n+        return fieldInstruction(Opcode.GETSTATIC, owner, name, type);\n+    }\n+\n+    default CodeBuilder goto_(Label target) {\n+        return branchInstruction(Opcode.GOTO, target);\n+    }\n+\n+    default CodeBuilder goto_w(Label target) {\n+        return branchInstruction(Opcode.GOTO_W, target);\n+    }\n+\n+    default CodeBuilder i2b() {\n+        return convertInstruction(TypeKind.IntType, TypeKind.ByteType);\n+    }\n+\n+    default CodeBuilder i2c() {\n+        return convertInstruction(TypeKind.IntType, TypeKind.CharType);\n+    }\n+\n+    default CodeBuilder i2d() {\n+        return convertInstruction(TypeKind.IntType, TypeKind.DoubleType);\n+    }\n+\n+    default CodeBuilder i2f() {\n+        return convertInstruction(TypeKind.IntType, TypeKind.FloatType);\n+    }\n+\n+    default CodeBuilder i2l() {\n+        return convertInstruction(TypeKind.IntType, TypeKind.LongType);\n+    }\n+\n+    default CodeBuilder i2s() {\n+        return convertInstruction(TypeKind.IntType, TypeKind.ShortType);\n+    }\n+\n+    default CodeBuilder iadd() {\n+        return operatorInstruction(Opcode.IADD);\n+    }\n+\n+    default CodeBuilder iaload() {\n+        return arrayLoadInstruction(TypeKind.IntType);\n+    }\n+\n+    default CodeBuilder iand() {\n+        return operatorInstruction(Opcode.IAND);\n+    }\n+\n+    default CodeBuilder iastore() {\n+        return arrayStoreInstruction(TypeKind.IntType);\n+    }\n+\n+    default CodeBuilder iconst_0() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_0));\n+    }\n+\n+    default CodeBuilder iconst_1() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_1));\n+    }\n+\n+    default CodeBuilder iconst_2() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_2));\n+    }\n+\n+    default CodeBuilder iconst_3() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_3));\n+    }\n+\n+    default CodeBuilder iconst_4() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_4));\n+    }\n+\n+    default CodeBuilder iconst_5() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_5));\n+    }\n+\n+    default CodeBuilder iconst_m1() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.ICONST_M1));\n+    }\n+\n+    default CodeBuilder idiv() {\n+        return operatorInstruction(Opcode.IDIV);\n+    }\n+\n+    default CodeBuilder if_acmpeq(Label target) {\n+        return branchInstruction(Opcode.IF_ACMPEQ, target);\n+    }\n+\n+    default CodeBuilder if_acmpne(Label target) {\n+        return branchInstruction(Opcode.IF_ACMPNE, target);\n+    }\n+\n+    default CodeBuilder if_icmpeq(Label target) {\n+        return branchInstruction(Opcode.IF_ICMPEQ, target);\n+    }\n+\n+    default CodeBuilder if_icmpge(Label target) {\n+        return branchInstruction(Opcode.IF_ICMPGE, target);\n+    }\n+\n+    default CodeBuilder if_icmpgt(Label target) {\n+        return branchInstruction(Opcode.IF_ICMPGT, target);\n+    }\n+\n+    default CodeBuilder if_icmple(Label target) {\n+        return branchInstruction(Opcode.IF_ICMPLE, target);\n+    }\n+\n+    default CodeBuilder if_icmplt(Label target) {\n+        return branchInstruction(Opcode.IF_ICMPLT, target);\n+    }\n+\n+    default CodeBuilder if_icmpne(Label target) {\n+        return branchInstruction(Opcode.IF_ICMPNE, target);\n+    }\n+\n+    default CodeBuilder if_nonnull(Label target) {\n+        return branchInstruction(Opcode.IFNONNULL, target);\n+    }\n+\n+    default CodeBuilder if_null(Label target) {\n+        return branchInstruction(Opcode.IFNULL, target);\n+    }\n+\n+    default CodeBuilder ifeq(Label target) {\n+        return branchInstruction(Opcode.IFEQ, target);\n+    }\n+\n+    default CodeBuilder ifge(Label target) {\n+        return branchInstruction(Opcode.IFGE, target);\n+    }\n+\n+    default CodeBuilder ifgt(Label target) {\n+        return branchInstruction(Opcode.IFGT, target);\n+    }\n+\n+    default CodeBuilder ifle(Label target) {\n+        return branchInstruction(Opcode.IFLE, target);\n+    }\n+\n+    default CodeBuilder iflt(Label target) {\n+        return branchInstruction(Opcode.IFLT, target);\n+    }\n+\n+    default CodeBuilder ifne(Label target) {\n+        return branchInstruction(Opcode.IFNE, target);\n+    }\n+\n+    default CodeBuilder iinc(int slot, int val) {\n+        return incrementInstruction(slot, val);\n+    }\n+\n+    default CodeBuilder iload(int slot) {\n+        return loadInstruction(TypeKind.IntType, slot);\n+    }\n+\n+    default CodeBuilder imul() {\n+        return operatorInstruction(Opcode.IMUL);\n+    }\n+\n+    default CodeBuilder ineg() {\n+        return operatorInstruction(Opcode.INEG);\n+    }\n+\n+    default CodeBuilder instanceof_(ClassEntry target) {\n+        return typeCheckInstruction(Opcode.INSTANCEOF, target);\n+    }\n+\n+    default CodeBuilder instanceof_(ClassDesc target) {\n+        return typeCheckInstruction(Opcode.INSTANCEOF, constantPool().classEntry(target));\n+    }\n+\n+    default CodeBuilder invokedynamic(InvokeDynamicEntry ref) {\n+        return invokeDynamicInstruction(ref);\n+    }\n+\n+    default CodeBuilder invokedynamic(DynamicCallSiteDesc ref) {\n+        return invokeDynamicInstruction(ref);\n+    }\n+\n+    default CodeBuilder invokeinterface(InterfaceMethodRefEntry ref) {\n+        return invokeInstruction(Opcode.INVOKEINTERFACE, ref);\n+    }\n+\n+    default CodeBuilder invokeinterface(ClassDesc owner, String name, MethodTypeDesc type) {\n+        return invokeInstruction(Opcode.INVOKEINTERFACE, constantPool().interfaceMethodRefEntry(owner, name, type));\n+    }\n+\n+    default CodeBuilder invokespecial(InterfaceMethodRefEntry ref) {\n+        return invokeInstruction(Opcode.INVOKESPECIAL, ref);\n+    }\n+\n+    default CodeBuilder invokespecial(MethodRefEntry ref) {\n+        return invokeInstruction(Opcode.INVOKESPECIAL, ref);\n+    }\n+\n+    default CodeBuilder invokespecial(ClassDesc owner, String name, MethodTypeDesc type) {\n+        return invokeInstruction(Opcode.INVOKESPECIAL, owner, name, type, false);\n+    }\n+\n+    default CodeBuilder invokespecial(ClassDesc owner, String name, MethodTypeDesc type, boolean isInterface) {\n+        return invokeInstruction(Opcode.INVOKESPECIAL, owner, name, type, isInterface);\n+    }\n+\n+    default CodeBuilder invokestatic(InterfaceMethodRefEntry ref) {\n+        return invokeInstruction(Opcode.INVOKESTATIC, ref);\n+    }\n+\n+    default CodeBuilder invokestatic(MethodRefEntry ref) {\n+        return invokeInstruction(Opcode.INVOKESTATIC, ref);\n+    }\n+\n+    default CodeBuilder invokestatic(ClassDesc owner, String name, MethodTypeDesc type) {\n+        return invokeInstruction(Opcode.INVOKESTATIC, owner, name, type, false);\n+    }\n+\n+    default CodeBuilder invokestatic(ClassDesc owner, String name, MethodTypeDesc type, boolean isInterface) {\n+        return invokeInstruction(Opcode.INVOKESTATIC, owner, name, type, isInterface);\n+    }\n+\n+    default CodeBuilder invokevirtual(MethodRefEntry ref) {\n+        return invokeInstruction(Opcode.INVOKEVIRTUAL, ref);\n+    }\n+\n+    default CodeBuilder invokevirtual(ClassDesc owner, String name, MethodTypeDesc type) {\n+        return invokeInstruction(Opcode.INVOKEVIRTUAL, owner, name, type, false);\n+    }\n+\n+    default CodeBuilder ior() {\n+        return operatorInstruction(Opcode.IOR);\n+    }\n+\n+    default CodeBuilder irem() {\n+        return operatorInstruction(Opcode.IREM);\n+    }\n+\n+    default CodeBuilder ireturn() {\n+        return returnInstruction(TypeKind.IntType);\n+    }\n+\n+    default CodeBuilder ishl() {\n+        return operatorInstruction(Opcode.ISHL);\n+    }\n+\n+    default CodeBuilder ishr() {\n+        return operatorInstruction(Opcode.ISHR);\n+    }\n+\n+    default CodeBuilder istore(int slot) {\n+        return storeInstruction(TypeKind.IntType, slot);\n+    }\n+\n+    default CodeBuilder isub() {\n+        return operatorInstruction(Opcode.ISUB);\n+    }\n+\n+    default CodeBuilder iushr() {\n+        return operatorInstruction(Opcode.IUSHR);\n+    }\n+\n+    default CodeBuilder ixor() {\n+        return operatorInstruction(Opcode.IXOR);\n+    }\n+\n+    default CodeBuilder lookupswitch(Label defaultTarget, List<SwitchCase> cases) {\n+        return lookupSwitchInstruction(defaultTarget, cases);\n+    }\n+\n+    default CodeBuilder l2d() {\n+        return convertInstruction(TypeKind.LongType, TypeKind.DoubleType);\n+    }\n+\n+    default CodeBuilder l2f() {\n+        return convertInstruction(TypeKind.LongType, TypeKind.FloatType);\n+    }\n+\n+    default CodeBuilder l2i() {\n+        return convertInstruction(TypeKind.LongType, TypeKind.IntType);\n+    }\n+\n+    default CodeBuilder ladd() {\n+        return operatorInstruction(Opcode.LADD);\n+    }\n+\n+    default CodeBuilder laload() {\n+        return arrayLoadInstruction(TypeKind.LongType);\n+    }\n+\n+    default CodeBuilder land() {\n+        return operatorInstruction(Opcode.LAND);\n+    }\n+\n+    default CodeBuilder lastore() {\n+        return arrayStoreInstruction(TypeKind.LongType);\n+    }\n+\n+    default CodeBuilder lcmp() {\n+        return operatorInstruction(Opcode.LCMP);\n+    }\n+\n+    default CodeBuilder lconst_0() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.LCONST_0));\n+    }\n+\n+    default CodeBuilder lconst_1() {\n+        return with(ConstantInstruction.ofIntrinsic(Opcode.LCONST_1));\n+    }\n+\n+    default CodeBuilder ldc(LoadableConstantEntry entry) {\n+        return with(ConstantInstruction.ofLoad(\n+                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n+                : entry.index() > 0xff ? Opcode.LDC_W\n+                : Opcode.LDC, entry));\n+    }\n+\n+    default CodeBuilder ldiv() {\n+        return operatorInstruction(Opcode.LDIV);\n+    }\n+\n+    default CodeBuilder lload(int slot) {\n+        return loadInstruction(TypeKind.LongType, slot);\n+    }\n+\n+    default CodeBuilder lmul() {\n+        return operatorInstruction(Opcode.LMUL);\n+    }\n+\n+    default CodeBuilder lneg() {\n+        return operatorInstruction(Opcode.LNEG);\n+    }\n+\n+    default CodeBuilder lor() {\n+        return operatorInstruction(Opcode.LOR);\n+    }\n+\n+    default CodeBuilder lrem() {\n+        return operatorInstruction(Opcode.LREM);\n+    }\n+\n+    default CodeBuilder lreturn() {\n+        return returnInstruction(TypeKind.LongType);\n+    }\n+\n+    default CodeBuilder lshl() {\n+        return operatorInstruction(Opcode.LSHL);\n+    }\n+\n+    default CodeBuilder lshr() {\n+        return operatorInstruction(Opcode.LSHR);\n+    }\n+\n+    default CodeBuilder lstore(int slot) {\n+        return storeInstruction(TypeKind.LongType, slot);\n+    }\n+\n+    default CodeBuilder lsub() {\n+        return operatorInstruction(Opcode.LSUB);\n+    }\n+\n+    default CodeBuilder lushr() {\n+        return operatorInstruction(Opcode.LUSHR);\n+    }\n+\n+    default CodeBuilder lxor() {\n+        return operatorInstruction(Opcode.LXOR);\n+    }\n+\n+    default CodeBuilder monitorenter() {\n+        return monitorInstruction(Opcode.MONITORENTER);\n+    }\n+\n+    default CodeBuilder monitorexit() {\n+        return monitorInstruction(Opcode.MONITOREXIT);\n+    }\n+\n+    default CodeBuilder multianewarray(ClassEntry array, int dims) {\n+        return newMultidimensionalArrayInstruction(dims, array);\n+    }\n+\n+    default CodeBuilder multianewarray(ClassDesc array, int dims) {\n+        return newMultidimensionalArrayInstruction(dims, constantPool().classEntry(array));\n+    }\n+\n+    default CodeBuilder new_(ClassEntry clazz) {\n+        return newObjectInstruction(clazz);\n+    }\n+\n+    default CodeBuilder new_(ClassDesc clazz) {\n+        return newObjectInstruction(constantPool().classEntry(clazz));\n+    }\n+\n+    default CodeBuilder newarray(TypeKind typeKind) {\n+        return newPrimitiveArrayInstruction(typeKind);\n+    }\n+\n+    default CodeBuilder pop() {\n+        return stackInstruction(Opcode.POP);\n+    }\n+\n+    default CodeBuilder pop2() {\n+        return stackInstruction(Opcode.POP2);\n+    }\n+\n+    default CodeBuilder putfield(FieldRefEntry ref) {\n+        return fieldInstruction(Opcode.PUTFIELD, ref);\n+    }\n+\n+    default CodeBuilder putfield(ClassDesc owner, String name, ClassDesc type) {\n+        return fieldInstruction(Opcode.PUTFIELD, owner, name, type);\n+    }\n+\n+    default CodeBuilder putstatic(FieldRefEntry ref) {\n+        return fieldInstruction(Opcode.PUTSTATIC, ref);\n+    }\n+\n+    default CodeBuilder putstatic(ClassDesc owner, String name, ClassDesc type) {\n+        return fieldInstruction(Opcode.PUTSTATIC, owner, name, type);\n+    }\n+\n+    default CodeBuilder return_() {\n+        return returnInstruction(TypeKind.VoidType);\n+    }\n+\n+    default CodeBuilder saload() {\n+        return arrayLoadInstruction(TypeKind.ShortType);\n+    }\n+\n+    default CodeBuilder sastore() {\n+        return arrayStoreInstruction(TypeKind.ShortType);\n+    }\n+\n+    default CodeBuilder sipush(int s) {\n+        return constantInstruction(Opcode.SIPUSH, s);\n+    }\n+\n+    default CodeBuilder swap() {\n+        return stackInstruction(Opcode.SWAP);\n+    }\n+\n+    default CodeBuilder tableswitch(int low, int high, Label defaultTarget, List<SwitchCase> cases) {\n+        return tableSwitchInstruction(low, high, defaultTarget, cases);\n+    }\n+\n+    default CodeBuilder tableswitch(Label defaultTarget, List<SwitchCase> cases) {\n+        int low = Integer.MAX_VALUE;\n+        int high = Integer.MIN_VALUE;\n+        for (var c : cases) {\n+            int i = c.caseValue();\n+            if (i < low) low = i;\n+            if (i > high) high = i;\n+        }\n+        return tableSwitchInstruction(low, high, defaultTarget, cases);\n+    }\n+\n+    \/\/ Structured conveniences:\n+\n+    \/\/   allocLocal(type)\n+    \/\/   returnFromMethod(inferred)\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeBuilder.java","additions":1386,"deletions":0,"binary":false,"changes":1386,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+\n+\/**\n+ * A {@link ClassfileElement} that can appear when traversing the elements\n+ * of a {@link CodeModel} or be presented to a {@link CodeBuilder}.  Code elements\n+ * are either an {@link Instruction}, which models an instruction in the body\n+ * of a method, or a {@link PseudoInstruction}, which models metadata from\n+ * the code attribute, such as line number metadata, local variable metadata,\n+ * exception metadata, label target metadata, etc.\n+ *\/\n+public sealed interface CodeElement extends ClassfileElement\n+        permits Instruction, PseudoInstruction,\n+                CustomAttribute, RuntimeVisibleTypeAnnotationsAttribute, RuntimeInvisibleTypeAnnotationsAttribute,\n+                StackMapTableAttribute {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeElement.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.impl.BufferedCodeBuilder;\n+import jdk.internal.classfile.impl.CodeImpl;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+\n+\/**\n+ * Models the body of a method (the {@code Code} attribute).  The instructions\n+ * of the method body are accessed via a streaming view (e.g., {@link\n+ * #elements()}).\n+ *\/\n+public sealed interface CodeModel\n+        extends CompoundElement<CodeElement>, AttributedElement, MethodElement\n+        permits CodeAttribute, BufferedCodeBuilder.Model, CodeImpl {\n+\n+    \/**\n+     * {@return the maximum size of the local variable table}\n+     *\/\n+    int maxLocals();\n+\n+    \/**\n+     * {@return the maximum size of the operand stack}\n+     *\/\n+    int maxStack();\n+\n+    \/**\n+     * {@return the enclosing method, if known}\n+     *\/\n+    Optional<MethodModel> parent();\n+\n+    \/**\n+     * {@return the exception table of the method}  The exception table is also\n+     * modeled by {@link ExceptionCatch} elements in the streaming view.\n+     *\/\n+    List<ExceptionCatch> exceptionHandlers();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeModel.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.classfile.impl.TransformImpl;\n+\n+\/**\n+ * A transformation on streams of {@link CodeElement}.\n+ *\n+ * @see ClassfileTransform\n+ *\/\n+@FunctionalInterface\n+public non-sealed interface CodeTransform\n+        extends ClassfileTransform<CodeTransform, CodeElement, CodeBuilder> {\n+\n+    \/**\n+     * A code transform that sends all elements to the builder.\n+     *\/\n+    CodeTransform ACCEPT_ALL = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder builder, CodeElement element) {\n+            builder.with(element);\n+        }\n+    };\n+\n+    \/**\n+     * Create a stateful code transform from a {@link Supplier}.  The supplier\n+     * will be invoked for each transformation.\n+     *\n+     * @param supplier a {@link Supplier} that produces a fresh transform object\n+     *                 for each traversal\n+     * @return the stateful code transform\n+     *\/\n+    static CodeTransform ofStateful(Supplier<CodeTransform> supplier) {\n+        return new TransformImpl.SupplierCodeTransform(supplier);\n+    }\n+\n+    \/**\n+     * Create a code transform that passes each element through to the builder,\n+     * and calls the specified function when transformation is complete.\n+     *\n+     * @param finisher the function to call when transformation is complete\n+     * @return the code transform\n+     *\/\n+    static CodeTransform endHandler(Consumer<CodeBuilder> finisher) {\n+        return new CodeTransform() {\n+            @Override\n+            public void accept(CodeBuilder builder, CodeElement element) {\n+                builder.with(element);\n+            }\n+\n+            @Override\n+            public void atEnd(CodeBuilder builder) {\n+                finisher.accept(builder);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    default CodeTransform andThen(CodeTransform t) {\n+        return new TransformImpl.ChainedCodeTransform(this, t);\n+    }\n+\n+    @Override\n+    default ResolvedTransform<CodeElement> resolve(CodeBuilder builder) {\n+        return new TransformImpl.CodeTransformImpl(e -> accept(builder, e),\n+                                                   () -> atEnd(builder),\n+                                                   () -> atStart(builder));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeTransform.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\/**\n+ * A {@link ClassfileElement} that has complex structure defined in terms of\n+ * other classfile elements, such as a method, field, method body, or entire\n+ * class.  When encountering a {@linkplain CompoundElement}, clients have the\n+ * option to treat the element as a single entity (e.g., an entire method)\n+ * or to traverse the contents of that element with the methods in this class\n+ * (e.g., {@link #elements()}, {@link #forEachElement(Consumer)}, etc.)\n+ *\/\n+public sealed interface CompoundElement<E extends ClassfileElement>\n+        extends ClassfileElement, Iterable<E>\n+        permits ClassModel, CodeModel, FieldModel, MethodModel, jdk.internal.classfile.impl.AbstractUnboundModel {\n+    \/**\n+     * Invoke the provided handler with each element contained in this\n+     * compound element\n+     * @param consumer the handler\n+     *\/\n+    void forEachElement(Consumer<E> consumer);\n+\n+    \/**\n+     * {@return an {@link Iterable} describing all the elements contained in this\n+     * compound element}\n+     *\/\n+    default Iterable<E> elements() {\n+        return elementList();\n+    }\n+\n+    \/**\n+     * {@return an {@link Iterator} describing all the elements contained in this\n+     * compound element}\n+     *\/\n+    @Override\n+    default Iterator<E> iterator() {\n+        return elements().iterator();\n+    }\n+\n+    \/**\n+     * {@return a {@link Stream} containing all the elements contained in this\n+     * compound element}\n+     *\/\n+    default Stream<E> elementStream() {\n+        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n+                                            iterator(),\n+                                            Spliterator.IMMUTABLE | Spliterator.NONNULL | Spliterator.ORDERED),\n+                                    false);\n+    }\n+\n+    \/**\n+     * {@return an {@link List} containing all the elements contained in this\n+     * compound element}\n+     *\/\n+    default List<E> elementList() {\n+        List<E> list = new ArrayList<>();\n+        forEachElement(new Consumer<>() {\n+            @Override\n+            public void accept(E e) {\n+                list.add(e);\n+            }\n+        });\n+        return list;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CompoundElement.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a non-standard attribute of a classfile.  Clients should extend\n+ * this class to provide an implementation class for non-standard attributes,\n+ * and provide an {@link AttributeMapper} to mediate between the classfile\n+ * format and the {@linkplain CustomAttribute} representation.\n+ *\/\n+@SuppressWarnings(\"exports\")\n+public abstract non-sealed class CustomAttribute<T extends CustomAttribute<T>>\n+        extends UnboundAttribute.CustomAttribute<T>\n+        implements CodeElement, ClassElement, MethodElement, FieldElement {\n+\n+    \/**\n+     * Construct a {@linkplain CustomAttribute}.\n+     * @param mapper the attribute mapper\n+     *\/\n+    protected CustomAttribute(AttributeMapper<T> mapper) {\n+        super(mapper);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CustomAttribute.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.ChainedFieldBuilder;\n+import jdk.internal.classfile.impl.TerminalFieldBuilder;\n+import java.lang.reflect.AccessFlag;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * A builder for fields.  Builders are not created directly; they are passed\n+ * to handlers by methods such as {@link ClassBuilder#withField(Utf8Entry, Utf8Entry, Consumer)}\n+ * or to field transforms.  The elements of a field can be specified\n+ * abstractly (by passing a {@link FieldElement} to {@link #with(ClassfileElement)}\n+ * or concretely by calling the various {@code withXxx} methods.\n+ *\n+ * @see FieldTransform\n+ *\/\n+public sealed interface FieldBuilder\n+        extends ClassfileBuilder<FieldElement, FieldBuilder>\n+        permits TerminalFieldBuilder, ChainedFieldBuilder {\n+\n+    \/**\n+     * Sets the field access flags.\n+     * @param flags the access flags, as a bit mask\n+     * @return this builder\n+     *\/\n+    default FieldBuilder withFlags(int flags) {\n+        return with(AccessFlags.ofField(flags));\n+    }\n+\n+    \/**\n+     * Sets the field access flags.\n+     * @param flags the access flags, as a bit mask\n+     * @return this builder\n+     *\/\n+    default FieldBuilder withFlags(AccessFlag... flags) {\n+        return with(AccessFlags.ofField(flags));\n+    }\n+\n+    \/**\n+     * {@return the {@link FieldModel} representing the field being transformed,\n+     * if this field builder represents the transformation of some {@link FieldModel}}\n+     *\/\n+    Optional<FieldModel> original();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/FieldBuilder.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.ConstantValueAttribute;\n+import jdk.internal.classfile.attribute.DeprecatedAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.attribute.SyntheticAttribute;\n+import jdk.internal.classfile.attribute.UnknownAttribute;\n+\n+\/**\n+ * A {@link ClassfileElement} that can appear when traversing the elements\n+ * of a {@link FieldModel} or be presented to a {@link FieldBuilder}.\n+ *\/\n+public sealed interface FieldElement extends ClassfileElement\n+        permits AccessFlags,\n+                CustomAttribute, ConstantValueAttribute, DeprecatedAttribute,\n+                RuntimeInvisibleAnnotationsAttribute, RuntimeInvisibleTypeAnnotationsAttribute,\n+                RuntimeVisibleAnnotationsAttribute, RuntimeVisibleTypeAnnotationsAttribute,\n+                SignatureAttribute, SyntheticAttribute, UnknownAttribute {\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/FieldElement.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BufferedFieldBuilder;\n+import jdk.internal.classfile.impl.FieldImpl;\n+\n+\/**\n+ * Models a field.  The contents of the field can be traversed via\n+ * a streaming view (e.g., {@link #elements()}), or via random access (e.g.,\n+ * {@link #flags()}), or by freely mixing the two.\n+ *\/\n+public sealed interface FieldModel\n+        extends WritableElement<FieldModel>, CompoundElement<FieldElement>, AttributedElement, ClassElement\n+        permits BufferedFieldBuilder.Model, FieldImpl {\n+\n+    \/** {@return the access flags} *\/\n+    AccessFlags flags();\n+\n+    \/** {@return the class model this field is a member of, if known} *\/\n+    Optional<ClassModel> parent();\n+\n+    \/** {@return the name of this field} *\/\n+    Utf8Entry fieldName();\n+\n+    \/** {@return the field descriptor of this field} *\/\n+    Utf8Entry fieldType();\n+\n+    \/** {@return the field descriptor of this field, as a symbolic descriptor} *\/\n+    default ClassDesc fieldTypeSymbol() {\n+        return ClassDesc.ofDescriptor(fieldType().stringValue());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/FieldModel.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.classfile.impl.TransformImpl;\n+\n+\/**\n+ * A transformation on streams of {@link FieldElement}.\n+ *\n+ * @see ClassfileTransform\n+ *\/\n+@FunctionalInterface\n+public non-sealed interface FieldTransform\n+        extends ClassfileTransform<FieldTransform, FieldElement, FieldBuilder> {\n+\n+    \/**\n+     * A field transform that sends all elements to the builder.\n+     *\/\n+    FieldTransform ACCEPT_ALL = new FieldTransform() {\n+        @Override\n+        public void accept(FieldBuilder builder, FieldElement element) {\n+            builder.with(element);\n+        }\n+    };\n+\n+    \/**\n+     * Create a stateful field transform from a {@link Supplier}.  The supplier\n+     * will be invoked for each transformation.\n+     *\n+     * @param supplier a {@link Supplier} that produces a fresh transform object\n+     *                 for each traversal\n+     * @return the stateful field transform\n+     *\/\n+    static FieldTransform ofStateful(Supplier<FieldTransform> supplier) {\n+        return new TransformImpl.SupplierFieldTransform(supplier);\n+    }\n+\n+    \/**\n+     * Create a field transform that passes each element through to the builder,\n+     * and calls the specified function when transformation is complete.\n+     *\n+     * @param finisher the function to call when transformation is complete\n+     * @return the field transform\n+     *\/\n+    static FieldTransform endHandler(Consumer<FieldBuilder> finisher) {\n+        return new FieldTransform() {\n+            @Override\n+            public void accept(FieldBuilder builder, FieldElement element) {\n+                builder.with(element);\n+            }\n+\n+            @Override\n+            public void atEnd(FieldBuilder builder) {\n+                finisher.accept(builder);\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Create a field transform that passes each element through to the builder,\n+     * except for those that the supplied {@link Predicate} is true for.\n+     *\n+     * @param filter the predicate that determines which elements to drop\n+     * @return the field transform\n+     *\/\n+    static FieldTransform dropping(Predicate<FieldElement> filter) {\n+        return (b, e) -> {\n+            if (!filter.test(e))\n+                b.with(e);\n+        };\n+    }\n+\n+    default FieldTransform andThen(FieldTransform t) {\n+        return new TransformImpl.ChainedFieldTransform(this, t);\n+    }\n+\n+    @Override\n+    default ResolvedTransform<FieldElement> resolve(FieldBuilder builder) {\n+        return new TransformImpl.FieldTransformImpl(e -> accept(builder, e),\n+                                                    () -> atEnd(builder),\n+                                                    () -> atStart(builder));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/FieldTransform.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n+import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.ConvertInstruction;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.MonitorInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StackInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.instruction.ThrowInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+\n+\/**\n+ * Models an executable instruction in a method body.\n+ *\/\n+public sealed interface Instruction extends CodeElement\n+        permits ArrayLoadInstruction, ArrayStoreInstruction, BranchInstruction,\n+                ConstantInstruction, ConvertInstruction, FieldInstruction,\n+                InvokeDynamicInstruction, InvokeInstruction, LoadInstruction,\n+                StoreInstruction, IncrementInstruction,\n+                LookupSwitchInstruction, MonitorInstruction, NewMultiArrayInstruction,\n+                NewObjectInstruction, NewPrimitiveArrayInstruction, NewReferenceArrayInstruction,\n+                NopInstruction, OperatorInstruction, ReturnInstruction,\n+                StackInstruction, TableSwitchInstruction,\n+                ThrowInstruction, TypeCheckInstruction, AbstractInstruction {\n+\n+    \/**\n+     * {@return the opcode of this instruction}\n+     *\/\n+    Opcode opcode();\n+\n+    \/**\n+     * {@return the size in bytes of this instruction}\n+     *\/\n+    int sizeInBytes();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Instruction.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.InterfacesImpl;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the interfaces of a class.  Delivered as a {@link\n+ * jdk.internal.classfile.ClassElement} when traversing a {@link ClassModel}.\n+ *\/\n+public sealed interface Interfaces\n+        extends ClassElement\n+        permits InterfacesImpl {\n+\n+    \/** {@return the interfaces of this class} *\/\n+    List<ClassEntry> interfaces();\n+\n+    \/**\n+     * {@return an {@linkplain Interfaces} element}\n+     * @param interfaces the interfaces\n+     *\/\n+    static Interfaces of(List<ClassEntry> interfaces) {\n+        return new InterfacesImpl(interfaces);\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain Interfaces} element}\n+     * @param interfaces the interfaces\n+     *\/\n+    static Interfaces of(ClassEntry... interfaces) {\n+        return of(List.of(interfaces));\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain Interfaces} element}\n+     * @param interfaces the interfaces\n+     *\/\n+    static Interfaces ofSymbols(List<ClassDesc> interfaces) {\n+        return of(Util.entryList(interfaces));\n+    }\n+\n+    \/**\n+     * {@return an {@linkplain Interfaces} element}\n+     * @param interfaces the interfaces\n+     *\/\n+    static Interfaces ofSymbols(ClassDesc... interfaces) {\n+        return ofSymbols(Arrays.asList(interfaces));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Interfaces.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.impl.LabelImpl;\n+\n+\/**\n+ * A marker for a position within the instructions of a method body.  The\n+ * assocation between a label's identity and the position it represents is\n+ * managed by the entity managing the method body (a {@link CodeModel} or {@link\n+ * CodeBuilder}), not the label itself; this allows the same label to have a\n+ * meaning both in an existing method (as managed by a {@linkplain CodeModel})\n+ * and in the transformation of that method (as managed by a {@linkplain\n+ * CodeBuilder}), while corresponding to different positions in each. When\n+ * traversing the elements of a {@linkplain CodeModel}, {@linkplain Label}\n+ * markers will be delivered at the position to which they correspond.  A label\n+ * can be bound to the current position within a {@linkplain CodeBuilder} via\n+ * {@link CodeBuilder#labelBinding(Label)} or {@link CodeBuilder#with(ClassfileElement)}.\n+ *\/\n+public sealed interface Label\n+        permits LabelImpl {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Label.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.ChainedMethodBuilder;\n+import jdk.internal.classfile.impl.TerminalMethodBuilder;\n+import java.lang.reflect.AccessFlag;\n+\n+\/**\n+ * A builder for methods.  Builders are not created directly; they are passed\n+ * to handlers by methods such as {@link ClassBuilder#withMethod(Utf8Entry, Utf8Entry, int, Consumer)}\n+ * or to method transforms.  The elements of a method can be specified\n+ * abstractly (by passing a {@link MethodElement} to {@link #with(ClassfileElement)}\n+ * or concretely by calling the various {@code withXxx} methods.\n+ *\n+ * @see MethodTransform\n+ *\/\n+public sealed interface MethodBuilder\n+        extends ClassfileBuilder<MethodElement, MethodBuilder>\n+        permits ChainedMethodBuilder, TerminalMethodBuilder {\n+\n+    \/**\n+     * {@return the {@link MethodModel} representing the method being transformed,\n+     * if this method builder represents the transformation of some {@link MethodModel}}\n+     *\/\n+    Optional<MethodModel> original();\n+\n+    \/**\n+     * Sets the method access flags.\n+     * @param flags the access flags, as a bit mask\n+     * @return this builder\n+     *\/\n+    default MethodBuilder withFlags(int flags) {\n+        return with(AccessFlags.ofMethod(flags));\n+    }\n+\n+    \/**\n+     * Sets the method access flags.\n+     * @param flags the access flags, as a bit mask\n+     * @return this builder\n+     *\/\n+    default MethodBuilder withFlags(AccessFlag... flags) {\n+        return with(AccessFlags.ofMethod(flags));\n+    }\n+\n+    \/**\n+     * Build the method body for this method.\n+     * @param code a handler receiving a {@link CodeBuilder}\n+     * @return this builder\n+     *\/\n+    MethodBuilder withCode(Consumer<? super CodeBuilder> code);\n+\n+    \/**\n+     * Build the method body for this method by transforming the body of another\n+     * method.\n+     *\n+     * @implNote\n+     * <p>This method behaves as if:\n+     * {@snippet lang=java :\n+     *     withCode(b -> b.transformCode(code, transform));\n+     * }\n+     *\n+     * @param code the method body to be transformed\n+     * @param transform the transform to apply to the method body\n+     * @return this builder\n+     *\/\n+    MethodBuilder transformCode(CodeModel code, CodeTransform transform);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/MethodBuilder.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.DeprecatedAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.attribute.SyntheticAttribute;\n+import jdk.internal.classfile.attribute.UnknownAttribute;\n+\n+\/**\n+ * A {@link ClassfileElement} that can appear when traversing the elements\n+ * of a {@link MethodModel} or be presented to a {@link MethodBuilder}.\n+ *\/\n+public sealed interface MethodElement\n+        extends ClassfileElement\n+        permits AccessFlags, CodeModel, CustomAttribute,\n+                AnnotationDefaultAttribute, DeprecatedAttribute,\n+                ExceptionsAttribute, MethodParametersAttribute,\n+                RuntimeInvisibleAnnotationsAttribute, RuntimeInvisibleParameterAnnotationsAttribute,\n+                RuntimeInvisibleTypeAnnotationsAttribute, RuntimeVisibleAnnotationsAttribute,\n+                RuntimeVisibleParameterAnnotationsAttribute, RuntimeVisibleTypeAnnotationsAttribute,\n+                SignatureAttribute, SyntheticAttribute, UnknownAttribute {\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/MethodElement.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BufferedMethodBuilder;\n+import jdk.internal.classfile.impl.MethodImpl;\n+\n+\/**\n+ * Models a method.  The contents of the method can be traversed via\n+ * a streaming view (e.g., {@link #elements()}), or via random access (e.g.,\n+ * {@link #flags()}), or by freely mixing the two.\n+ *\/\n+public sealed interface MethodModel\n+        extends WritableElement<MethodModel>, CompoundElement<MethodElement>, AttributedElement, ClassElement\n+        permits BufferedMethodBuilder.Model, MethodImpl {\n+\n+    \/** {@return the access flags} *\/\n+    AccessFlags flags();\n+\n+    \/** {@return the class model this method is a member of, if known} *\/\n+    Optional<ClassModel> parent();\n+\n+    \/** {@return the name of this method} *\/\n+    Utf8Entry methodName();\n+\n+    \/** {@return the method descriptor of this method} *\/\n+    Utf8Entry methodType();\n+\n+    \/** {@return the method descriptor of this method, as a symbolic descriptor} *\/\n+    default MethodTypeDesc methodTypeSymbol() {\n+        return MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+    }\n+\n+    \/** {@return the body of this method, if there is one} *\/\n+    Optional<CodeModel> code();\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/MethodModel.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import jdk.internal.classfile.impl.SignaturesImpl;\n+import static java.util.Objects.requireNonNull;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the generic signature of a method, as defined by {@jvms 4.7.9}.\n+ *\/\n+public sealed interface MethodSignature\n+        permits SignaturesImpl.MethodSignatureImpl {\n+\n+    \/** {@return the type parameters of this method} *\/\n+    List<Signature.TypeParam> typeParameters();\n+\n+    \/** {@return the signatures of the parameters of this method} *\/\n+    List<Signature> arguments();\n+\n+    \/** {@return the signatures of the return value of this method} *\/\n+    Signature result();\n+\n+    \/** {@return the signatures of the exceptions thrown by this method} *\/\n+    List<Signature.ThrowableSig> throwableSignatures();\n+\n+    \/** {@return the raw signature string} *\/\n+    String signatureString();\n+\n+    \/**\n+     * @return method signature for a raw (no generic information) method descriptor\n+     * @param methodDescriptor the method descriptor\n+     *\/\n+    public static MethodSignature of(MethodTypeDesc methodDescriptor) {\n+\n+        requireNonNull(methodDescriptor);\n+        return new SignaturesImpl.MethodSignatureImpl(\n+                List.of(),\n+                List.of(),\n+                Signature.of(methodDescriptor.returnType()),\n+                Util.mappedList(methodDescriptor.parameterList(), Signature::of));\n+    }\n+\n+    \/**\n+     * @return method signature\n+     * @param result signature for the return type\n+     * @param arguments signatures for the method arguments\n+     *\/\n+    public static MethodSignature of(Signature result,\n+                                     Signature... arguments) {\n+\n+        return new SignaturesImpl.MethodSignatureImpl(List.of(),\n+                                                      List.of(),\n+                                                      requireNonNull(result),\n+                                                      List.of(arguments));\n+    }\n+\n+    \/**\n+     * @return method signature\n+     * @param typeParameters signatures for the type parameters\n+     * @param exceptions sigantures for the exceptions\n+     * @param result signature for the return type\n+     * @param arguments signatures for the method arguments\n+     *\/\n+    public static MethodSignature of(List<Signature.TypeParam> typeParameters,\n+                                     List<Signature.ThrowableSig> exceptions,\n+                                     Signature result,\n+                                     Signature... arguments) {\n+\n+        return new SignaturesImpl.MethodSignatureImpl(\n+                List.copyOf(requireNonNull(typeParameters)),\n+                List.copyOf(requireNonNull(exceptions)),\n+                requireNonNull(result),\n+                List.of(arguments));\n+    }\n+\n+    \/**\n+     * Parses a raw method signature string into a {@linkplain MethodSignature}\n+     * @param methodSignature the raw method signature string\n+     * @return method signature\n+     *\/\n+    public static MethodSignature parseFrom(String methodSignature) {\n+\n+        return new SignaturesImpl().parseMethodSignature(requireNonNull(methodSignature));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/MethodSignature.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.classfile.impl.TransformImpl;\n+\n+\/**\n+ * A transformation on streams of {@link MethodElement}.\n+ *\n+ * @see ClassfileTransform\n+ *\/\n+@FunctionalInterface\n+public non-sealed interface MethodTransform\n+        extends ClassfileTransform<MethodTransform, MethodElement, MethodBuilder> {\n+\n+    \/**\n+     * A method transform that sends all elements to the builder.\n+     *\/\n+    MethodTransform ACCEPT_ALL = new MethodTransform() {\n+        @Override\n+        public void accept(MethodBuilder builder, MethodElement element) {\n+            builder.with(element);\n+        }\n+    };\n+\n+    \/**\n+     * Create a stateful method transform from a {@link Supplier}.  The supplier\n+     * will be invoked for each transformation.\n+     *\n+     * @param supplier a {@link Supplier} that produces a fresh transform object\n+     *                 for each traversal\n+     * @return the stateful method transform\n+     *\/\n+    static MethodTransform ofStateful(Supplier<MethodTransform> supplier) {\n+        return new TransformImpl.SupplierMethodTransform(supplier);\n+    }\n+\n+    \/**\n+     * Create a method transform that passes each element through to the builder,\n+     * and calls the specified function when transformation is complete.\n+     *\n+     * @param finisher the function to call when transformation is complete\n+     * @return the method transform\n+     *\/\n+    static MethodTransform endHandler(Consumer<MethodBuilder> finisher) {\n+        return new MethodTransform() {\n+            @Override\n+            public void accept(MethodBuilder builder, MethodElement element) {\n+                builder.with(element);\n+            }\n+\n+            @Override\n+            public void atEnd(MethodBuilder builder) {\n+                finisher.accept(builder);\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Create a method transform that passes each element through to the builder,\n+     * except for those that the supplied {@link Predicate} is true for.\n+     *\n+     * @param filter the predicate that determines which elements to drop\n+     * @return the method transform\n+     *\/\n+    static MethodTransform dropping(Predicate<MethodElement> filter) {\n+        return (b, e) -> {\n+            if (!filter.test(e))\n+                b.with(e);\n+        };\n+    }\n+\n+    \/**\n+     * Create a method transform that transforms {@link CodeModel} elements\n+     * with the supplied code transform.\n+     *\n+     * @param xform the method transform\n+     * @return the class transform\n+     *\/\n+    static MethodTransform transformingCode(CodeTransform xform) {\n+        return new TransformImpl.MethodCodeTransform(xform);\n+    }\n+\n+    @Override\n+    default ResolvedTransform<MethodElement> resolve(MethodBuilder builder) {\n+        return new TransformImpl.MethodTransformImpl(e -> accept(builder, e),\n+                                                     () -> atEnd(builder),\n+                                                     () -> atStart(builder));\n+    }\n+\n+    @Override\n+    default MethodTransform andThen(MethodTransform t) {\n+        return new TransformImpl.ChainedMethodTransform(this, t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/MethodTransform.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+\n+\/**\n+ * Describes the opcodes of the JVM instruction set, as well as a number of\n+ * pseudo-instructions that may be encountered when traversing the instructions\n+ * of a method.\n+ *\n+ * @see Instruction\n+ * @see PseudoInstruction\n+ *\/\n+public enum Opcode {\n+    NOP(Classfile.NOP, 1, Kind.NOP),\n+    ACONST_NULL(Classfile.ACONST_NULL, 1, Kind.CONSTANT, TypeKind.ReferenceType, 0, ConstantDescs.NULL),\n+    ICONST_M1(Classfile.ICONST_M1, 1, Kind.CONSTANT, TypeKind.IntType, 0, -1),\n+    ICONST_0(Classfile.ICONST_0, 1, Kind.CONSTANT, TypeKind.IntType, 0, 0),\n+    ICONST_1(Classfile.ICONST_1, 1, Kind.CONSTANT, TypeKind.IntType, 0, 1),\n+    ICONST_2(Classfile.ICONST_2, 1, Kind.CONSTANT, TypeKind.IntType, 0, 2),\n+    ICONST_3(Classfile.ICONST_3, 1, Kind.CONSTANT, TypeKind.IntType, 0, 3),\n+    ICONST_4(Classfile.ICONST_4, 1, Kind.CONSTANT, TypeKind.IntType, 0, 4),\n+    ICONST_5(Classfile.ICONST_5, 1, Kind.CONSTANT, TypeKind.IntType, 0, 5),\n+    LCONST_0(Classfile.LCONST_0, 1, Kind.CONSTANT, TypeKind.LongType, 0, 0L),\n+    LCONST_1(Classfile.LCONST_1, 1, Kind.CONSTANT, TypeKind.LongType, 0, 1L),\n+    FCONST_0(Classfile.FCONST_0, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 0.0f),\n+    FCONST_1(Classfile.FCONST_1, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 1.0f),\n+    FCONST_2(Classfile.FCONST_2, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 2.0f),\n+    DCONST_0(Classfile.DCONST_0, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 0.0d),\n+    DCONST_1(Classfile.DCONST_1, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 1.0d),\n+    BIPUSH(Classfile.BIPUSH, 2, Kind.CONSTANT, TypeKind.ByteType),\n+    SIPUSH(Classfile.SIPUSH, 3, Kind.CONSTANT, TypeKind.ShortType),\n+    LDC(Classfile.LDC, 2, Kind.CONSTANT),\n+    LDC_W(Classfile.LDC_W, 3, Kind.CONSTANT),\n+    LDC2_W(Classfile.LDC2_W, 3, Kind.CONSTANT),\n+    ILOAD(Classfile.ILOAD, 2, Kind.LOAD, TypeKind.IntType, -1),\n+    LLOAD(Classfile.LLOAD, 2, Kind.LOAD, TypeKind.LongType, -1),\n+    FLOAD(Classfile.FLOAD, 2, Kind.LOAD, TypeKind.FloatType, -1),\n+    DLOAD(Classfile.DLOAD, 2, Kind.LOAD, TypeKind.DoubleType, -1),\n+    ALOAD(Classfile.ALOAD, 2, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ILOAD_0(Classfile.ILOAD_0, 1, Kind.LOAD, TypeKind.IntType, 0),\n+    ILOAD_1(Classfile.ILOAD_1, 1, Kind.LOAD, TypeKind.IntType, 1),\n+    ILOAD_2(Classfile.ILOAD_2, 1, Kind.LOAD, TypeKind.IntType, 2),\n+    ILOAD_3(Classfile.ILOAD_3, 1, Kind.LOAD, TypeKind.IntType, 3),\n+    LLOAD_0(Classfile.LLOAD_0, 1, Kind.LOAD, TypeKind.LongType, 0),\n+    LLOAD_1(Classfile.LLOAD_1, 1, Kind.LOAD, TypeKind.LongType, 1),\n+    LLOAD_2(Classfile.LLOAD_2, 1, Kind.LOAD, TypeKind.LongType, 2),\n+    LLOAD_3(Classfile.LLOAD_3, 1, Kind.LOAD, TypeKind.LongType, 3),\n+    FLOAD_0(Classfile.FLOAD_0, 1, Kind.LOAD, TypeKind.FloatType, 0),\n+    FLOAD_1(Classfile.FLOAD_1, 1, Kind.LOAD, TypeKind.FloatType, 1),\n+    FLOAD_2(Classfile.FLOAD_2, 1, Kind.LOAD, TypeKind.FloatType, 2),\n+    FLOAD_3(Classfile.FLOAD_3, 1, Kind.LOAD, TypeKind.FloatType, 3),\n+    DLOAD_0(Classfile.DLOAD_0, 1, Kind.LOAD, TypeKind.DoubleType, 0),\n+    DLOAD_1(Classfile.DLOAD_1, 1, Kind.LOAD, TypeKind.DoubleType, 1),\n+    DLOAD_2(Classfile.DLOAD_2, 1, Kind.LOAD, TypeKind.DoubleType, 2),\n+    DLOAD_3(Classfile.DLOAD_3, 1, Kind.LOAD, TypeKind.DoubleType, 3),\n+    ALOAD_0(Classfile.ALOAD_0, 1, Kind.LOAD, TypeKind.ReferenceType, 0),\n+    ALOAD_1(Classfile.ALOAD_1, 1, Kind.LOAD, TypeKind.ReferenceType, 1),\n+    ALOAD_2(Classfile.ALOAD_2, 1, Kind.LOAD, TypeKind.ReferenceType, 2),\n+    ALOAD_3(Classfile.ALOAD_3, 1, Kind.LOAD, TypeKind.ReferenceType, 3),\n+    IALOAD(Classfile.IALOAD, 1, Kind.ARRAY_LOAD, TypeKind.IntType),\n+    LALOAD(Classfile.LALOAD, 1, Kind.ARRAY_LOAD, TypeKind.LongType),\n+    FALOAD(Classfile.FALOAD, 1, Kind.ARRAY_LOAD, TypeKind.FloatType),\n+    DALOAD(Classfile.DALOAD, 1, Kind.ARRAY_LOAD, TypeKind.DoubleType),\n+    AALOAD(Classfile.AALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ReferenceType),\n+    BALOAD(Classfile.BALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ByteType),\n+    CALOAD(Classfile.CALOAD, 1, Kind.ARRAY_LOAD, TypeKind.CharType),\n+    SALOAD(Classfile.SALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ShortType),\n+    ISTORE(Classfile.ISTORE, 2, Kind.STORE, TypeKind.IntType, -1),\n+    LSTORE(Classfile.LSTORE, 2, Kind.STORE, TypeKind.LongType, -1),\n+    FSTORE(Classfile.FSTORE, 2, Kind.STORE, TypeKind.FloatType, -1),\n+    DSTORE(Classfile.DSTORE, 2, Kind.STORE, TypeKind.DoubleType, -1),\n+    ASTORE(Classfile.ASTORE, 2, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ISTORE_0(Classfile.ISTORE_0, 1, Kind.STORE, TypeKind.IntType, 0),\n+    ISTORE_1(Classfile.ISTORE_1, 1, Kind.STORE, TypeKind.IntType, 1),\n+    ISTORE_2(Classfile.ISTORE_2, 1, Kind.STORE, TypeKind.IntType, 2),\n+    ISTORE_3(Classfile.ISTORE_3, 1, Kind.STORE, TypeKind.IntType, 3),\n+    LSTORE_0(Classfile.LSTORE_0, 1, Kind.STORE, TypeKind.LongType, 0),\n+    LSTORE_1(Classfile.LSTORE_1, 1, Kind.STORE, TypeKind.LongType, 1),\n+    LSTORE_2(Classfile.LSTORE_2, 1, Kind.STORE, TypeKind.LongType, 2),\n+    LSTORE_3(Classfile.LSTORE_3, 1, Kind.STORE, TypeKind.LongType, 3),\n+    FSTORE_0(Classfile.FSTORE_0, 1, Kind.STORE, TypeKind.FloatType, 0),\n+    FSTORE_1(Classfile.FSTORE_1, 1, Kind.STORE, TypeKind.FloatType, 1),\n+    FSTORE_2(Classfile.FSTORE_2, 1, Kind.STORE, TypeKind.FloatType, 2),\n+    FSTORE_3(Classfile.FSTORE_3, 1, Kind.STORE, TypeKind.FloatType, 3),\n+    DSTORE_0(Classfile.DSTORE_0, 1, Kind.STORE, TypeKind.DoubleType, 0),\n+    DSTORE_1(Classfile.DSTORE_1, 1, Kind.STORE, TypeKind.DoubleType, 1),\n+    DSTORE_2(Classfile.DSTORE_2, 1, Kind.STORE, TypeKind.DoubleType, 2),\n+    DSTORE_3(Classfile.DSTORE_3, 1, Kind.STORE, TypeKind.DoubleType, 3),\n+    ASTORE_0(Classfile.ASTORE_0, 1, Kind.STORE, TypeKind.ReferenceType, 0),\n+    ASTORE_1(Classfile.ASTORE_1, 1, Kind.STORE, TypeKind.ReferenceType, 1),\n+    ASTORE_2(Classfile.ASTORE_2, 1, Kind.STORE, TypeKind.ReferenceType, 2),\n+    ASTORE_3(Classfile.ASTORE_3, 1, Kind.STORE, TypeKind.ReferenceType, 3),\n+    IASTORE(Classfile.IASTORE, 1, Kind.ARRAY_STORE, TypeKind.IntType),\n+    LASTORE(Classfile.LASTORE, 1, Kind.ARRAY_STORE, TypeKind.LongType),\n+    FASTORE(Classfile.FASTORE, 1, Kind.ARRAY_STORE, TypeKind.FloatType),\n+    DASTORE(Classfile.DASTORE, 1, Kind.ARRAY_STORE, TypeKind.DoubleType),\n+    AASTORE(Classfile.AASTORE, 1, Kind.ARRAY_STORE, TypeKind.ReferenceType),\n+    BASTORE(Classfile.BASTORE, 1, Kind.ARRAY_STORE, TypeKind.ByteType),\n+    CASTORE(Classfile.CASTORE, 1, Kind.ARRAY_STORE, TypeKind.CharType),\n+    SASTORE(Classfile.SASTORE, 1, Kind.ARRAY_STORE, TypeKind.ShortType),\n+    POP(Classfile.POP, 1, Kind.STACK),\n+    POP2(Classfile.POP2, 1, Kind.STACK),\n+    DUP(Classfile.DUP, 1, Kind.STACK),\n+    DUP_X1(Classfile.DUP_X1, 1, Kind.STACK),\n+    DUP_X2(Classfile.DUP_X2, 1, Kind.STACK),\n+    DUP2(Classfile.DUP2, 1, Kind.STACK),\n+    DUP2_X1(Classfile.DUP2_X1, 1, Kind.STACK),\n+    DUP2_X2(Classfile.DUP2_X2, 1, Kind.STACK),\n+    SWAP(Classfile.SWAP, 1, Kind.STACK),\n+    IADD(Classfile.IADD, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LADD(Classfile.LADD, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FADD(Classfile.FADD, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DADD(Classfile.DADD, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    ISUB(Classfile.ISUB, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LSUB(Classfile.LSUB, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FSUB(Classfile.FSUB, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DSUB(Classfile.DSUB, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    IMUL(Classfile.IMUL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LMUL(Classfile.LMUL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FMUL(Classfile.FMUL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DMUL(Classfile.DMUL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    IDIV(Classfile.IDIV, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LDIV(Classfile.LDIV, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FDIV(Classfile.FDIV, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DDIV(Classfile.DDIV, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    IREM(Classfile.IREM, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LREM(Classfile.LREM, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FREM(Classfile.FREM, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DREM(Classfile.DREM, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    INEG(Classfile.INEG, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LNEG(Classfile.LNEG, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FNEG(Classfile.FNEG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DNEG(Classfile.DNEG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    ISHL(Classfile.ISHL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LSHL(Classfile.LSHL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    ISHR(Classfile.ISHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LSHR(Classfile.LSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    IUSHR(Classfile.IUSHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LUSHR(Classfile.LUSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    IAND(Classfile.IAND, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LAND(Classfile.LAND, 1, Kind.OPERATOR, TypeKind.LongType),\n+    IOR(Classfile.IOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LOR(Classfile.LOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    IXOR(Classfile.IXOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    LXOR(Classfile.LXOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    IINC(Classfile.IINC, 3, Kind.INCREMENT, TypeKind.IntType, -1),\n+    I2L(Classfile.I2L, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.LongType),\n+    I2F(Classfile.I2F, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.FloatType),\n+    I2D(Classfile.I2D, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.DoubleType),\n+    L2I(Classfile.L2I, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.IntType),\n+    L2F(Classfile.L2F, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.FloatType),\n+    L2D(Classfile.L2D, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.DoubleType),\n+    F2I(Classfile.F2I, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.IntType),\n+    F2L(Classfile.F2L, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.LongType),\n+    F2D(Classfile.F2D, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.DoubleType),\n+    D2I(Classfile.D2I, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.IntType),\n+    D2L(Classfile.D2L, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.LongType),\n+    D2F(Classfile.D2F, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.FloatType),\n+    I2B(Classfile.I2B, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ByteType),\n+    I2C(Classfile.I2C, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.CharType),\n+    I2S(Classfile.I2S, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ShortType),\n+    LCMP(Classfile.LCMP, 1, Kind.OPERATOR, TypeKind.LongType),\n+    FCMPL(Classfile.FCMPL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPG(Classfile.FCMPG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    DCMPL(Classfile.DCMPL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPG(Classfile.DCMPG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    IFEQ(Classfile.IFEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFNE(Classfile.IFNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLT(Classfile.IFLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGE(Classfile.IFGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGT(Classfile.IFGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLE(Classfile.IFLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPEQ(Classfile.IF_ICMPEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPNE(Classfile.IF_ICMPNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLT(Classfile.IF_ICMPLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGE(Classfile.IF_ICMPGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGT(Classfile.IF_ICMPGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLE(Classfile.IF_ICMPLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ACMPEQ(Classfile.IF_ACMPEQ, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPNE(Classfile.IF_ACMPNE, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    GOTO(Classfile.GOTO, 3, Kind.BRANCH, TypeKind.VoidType),\n+    JSR(Classfile.JSR, 3, Kind.UNSUPPORTED),\n+    RET(Classfile.RET, 2, Kind.UNSUPPORTED),\n+    TABLESWITCH(Classfile.TABLESWITCH, -1, Kind.TABLE_SWITCH),\n+    LOOKUPSWITCH(Classfile.LOOKUPSWITCH, -1, Kind.LOOKUP_SWITCH),\n+    IRETURN(Classfile.IRETURN, 1, Kind.RETURN, TypeKind.IntType),\n+    LRETURN(Classfile.LRETURN, 1, Kind.RETURN, TypeKind.LongType),\n+    FRETURN(Classfile.FRETURN, 1, Kind.RETURN, TypeKind.FloatType),\n+    DRETURN(Classfile.DRETURN, 1, Kind.RETURN, TypeKind.DoubleType),\n+    ARETURN(Classfile.ARETURN, 1, Kind.RETURN, TypeKind.ReferenceType),\n+    RETURN(Classfile.RETURN, 1, Kind.RETURN, TypeKind.VoidType),\n+    GETSTATIC(Classfile.GETSTATIC, 3, Kind.FIELD_ACCESS),\n+    PUTSTATIC(Classfile.PUTSTATIC, 3, Kind.FIELD_ACCESS),\n+    GETFIELD(Classfile.GETFIELD, 3, Kind.FIELD_ACCESS),\n+    PUTFIELD(Classfile.PUTFIELD, 3, Kind.FIELD_ACCESS),\n+    INVOKEVIRTUAL(Classfile.INVOKEVIRTUAL, 3, Kind.INVOKE),\n+    INVOKESPECIAL(Classfile.INVOKESPECIAL, 3, Kind.INVOKE),\n+    INVOKESTATIC(Classfile.INVOKESTATIC, 3, Kind.INVOKE),\n+    INVOKEINTERFACE(Classfile.INVOKEINTERFACE, 5, Kind.INVOKE),\n+    INVOKEDYNAMIC(Classfile.INVOKEDYNAMIC, 5, Kind.INVOKE_DYNAMIC),\n+    NEW(Classfile.NEW, 3, Kind.NEW_OBJECT),\n+    NEWARRAY(Classfile.NEWARRAY, 2, Kind.NEW_PRIMITIVE_ARRAY),\n+    ANEWARRAY(Classfile.ANEWARRAY, 3, Kind.NEW_REF_ARRAY),\n+    ARRAYLENGTH(Classfile.ARRAYLENGTH, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ATHROW(Classfile.ATHROW, 1, Kind.THROW_EXCEPTION),\n+    CHECKCAST(Classfile.CHECKCAST, 3, Kind.TYPE_CHECK),\n+    INSTANCEOF(Classfile.INSTANCEOF, 3, Kind.TYPE_CHECK),\n+    MONITORENTER(Classfile.MONITORENTER, 1, Kind.MONITOR),\n+    MONITOREXIT(Classfile.MONITOREXIT, 1, Kind.MONITOR),\n+    MULTIANEWARRAY(Classfile.MULTIANEWARRAY, 4, Kind.NEW_MULTI_ARRAY),\n+    IFNULL(Classfile.IFNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNONNULL(Classfile.IFNONNULL, 3, Kind.BRANCH, TypeKind.IntType),\n+    GOTO_W(Classfile.GOTO_W, 5, Kind.BRANCH, TypeKind.VoidType),\n+    JSR_W(Classfile.JSR_W, 5, Kind.UNSUPPORTED),\n+    ILOAD_W((Classfile.WIDE << 8) | Classfile.ILOAD, 4, Kind.LOAD, TypeKind.IntType, -1),\n+    LLOAD_W((Classfile.WIDE << 8) | Classfile.LLOAD, 4, Kind.LOAD, TypeKind.LongType, -1),\n+    FLOAD_W((Classfile.WIDE << 8) | Classfile.FLOAD, 4, Kind.LOAD, TypeKind.FloatType, -1),\n+    DLOAD_W((Classfile.WIDE << 8) | Classfile.DLOAD, 4, Kind.LOAD, TypeKind.DoubleType, -1),\n+    ALOAD_W((Classfile.WIDE << 8) | Classfile.ALOAD, 4, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ISTORE_W((Classfile.WIDE << 8) | Classfile.ISTORE, 4, Kind.STORE, TypeKind.IntType, -1),\n+    LSTORE_W((Classfile.WIDE << 8) | Classfile.LSTORE, 4, Kind.STORE, TypeKind.LongType, -1),\n+    FSTORE_W((Classfile.WIDE << 8) | Classfile.FSTORE, 4, Kind.STORE, TypeKind.FloatType, -1),\n+    DSTORE_W((Classfile.WIDE << 8) | Classfile.DSTORE, 4, Kind.STORE, TypeKind.DoubleType, -1),\n+    ASTORE_W((Classfile.WIDE << 8) | Classfile.ASTORE, 4, Kind.STORE, TypeKind.ReferenceType, -1),\n+    RET_W((Classfile.WIDE << 8) | Classfile.RET, 4, Kind.UNSUPPORTED),\n+    IINC_W((Classfile.WIDE << 8) | Classfile.IINC, 6, Kind.INCREMENT, TypeKind.IntType, -1);\n+\n+    \/**\n+     * Kinds of opcodes.\n+     *\/\n+    public static enum Kind {\n+        LOAD, STORE, INCREMENT, BRANCH, LOOKUP_SWITCH, TABLE_SWITCH, RETURN, THROW_EXCEPTION,\n+        FIELD_ACCESS, INVOKE, INVOKE_DYNAMIC,\n+        NEW_OBJECT, NEW_PRIMITIVE_ARRAY, NEW_REF_ARRAY, NEW_MULTI_ARRAY,\n+        TYPE_CHECK, ARRAY_LOAD, ARRAY_STORE, STACK, CONVERT, OPERATOR, CONSTANT,\n+        MONITOR, NOP, UNSUPPORTED;\n+    }\n+\n+    private final int bytecode;\n+    private final int sizeIfFixed;\n+    private final Kind kind;\n+    private final TypeKind primaryTypeKind;\n+    private final TypeKind secondaryTypeKind;\n+    private final int slot;\n+    private final ConstantDesc constantValue;\n+\n+    Opcode(int bytecode, int sizeIfFixed, Kind kind) {\n+        this(bytecode, sizeIfFixed, kind, null, null, 0, null);\n+    }\n+\n+    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind) {\n+        this(bytecode, sizeIfFixed, kind, typeKind, null, 0, null);\n+    }\n+\n+    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind, int slot) {\n+        this(bytecode, sizeIfFixed, kind, typeKind, null, slot, null);\n+    }\n+\n+    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind, int slot, ConstantDesc constantValue) {\n+        this(bytecode, sizeIfFixed, kind, typeKind, null, slot, constantValue);\n+    }\n+\n+    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind primaryTypeKind, TypeKind secondaryTypeKind) {\n+        this(bytecode, sizeIfFixed, kind, primaryTypeKind, secondaryTypeKind, 0, null);\n+    }\n+\n+    Opcode(int bytecode,\n+           int sizeIfFixed,\n+           Kind kind,\n+           TypeKind primaryTypeKind,\n+           TypeKind secondaryTypeKind,\n+           int slot,\n+           ConstantDesc constantValue) {\n+        this.bytecode = bytecode;\n+        this.sizeIfFixed = sizeIfFixed;\n+        this.kind = kind;\n+        this.primaryTypeKind = primaryTypeKind;\n+        this.secondaryTypeKind = secondaryTypeKind;\n+        this.slot = slot;\n+        this.constantValue = constantValue;\n+    }\n+\n+    public int bytecode() { return bytecode; }\n+\n+    public boolean isWide() { return bytecode > 255; }\n+\n+    public int sizeIfFixed() { return sizeIfFixed; }\n+\n+    public Kind kind() { return kind; }\n+\n+    public TypeKind primaryTypeKind() {\n+        return primaryTypeKind;\n+    }\n+\n+    public TypeKind secondaryTypeKind() {\n+        return secondaryTypeKind;\n+    }\n+\n+    public int slot() {\n+        return slot;\n+    }\n+\n+    public ConstantDesc constantValue() {\n+        return constantValue;\n+    }\n+\n+    public boolean isUnconditionalBranch() {\n+        return switch (this) {\n+            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n+            default -> kind() == Kind.RETURN;\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Opcode.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.instruction.CharacterRange;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+import jdk.internal.classfile.instruction.LineNumber;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+\n+\/**\n+ * Models metadata about a {@link CodeAttribute}, such as entries in the\n+ * exception table, line number table, local variable table, or the mapping\n+ * between instructions and labels.  Pseudo-instructions are delivered as part\n+ * of the element stream of a {@link CodeModel}.  Delivery of some\n+ * pseudo-instructions can be disabled by modifying the value of classfile\n+ * options (e.g., {@link Classfile.Option#processDebug(boolean)}).\n+ *\/\n+public sealed interface PseudoInstruction\n+        extends CodeElement\n+        permits CharacterRange, ExceptionCatch, LabelTarget, LineNumber, LocalVariable, LocalVariableType, AbstractPseudoInstruction {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/PseudoInstruction.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.impl.SignaturesImpl;\n+\n+import java.util.List;\n+import static java.util.Objects.requireNonNull;\n+import java.util.Optional;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models generic Java type signatures, as defined in {@jvms 4.7.9.1}.\n+ *\/\n+public sealed interface Signature {\n+\n+    \/** {@return the raw signature string} *\/\n+    String signatureString();\n+\n+    \/**\n+     * Parses generic Java type signature from raw string\n+     * @param javaTypeSignature raw Java type signature string\n+     * @return Java type signature\n+     *\/\n+    public static Signature parseFrom(String javaTypeSignature) {\n+        return new SignaturesImpl().parseSignature(requireNonNull(javaTypeSignature));\n+    }\n+\n+    \/**\n+     * @param classDesc the symbolic description of the Java type\n+     * @return Java type signature\n+     *\/\n+    public static Signature of(ClassDesc classDesc) {\n+        requireNonNull(classDesc);\n+        if (classDesc.isArray())\n+            return ArrayTypeSig.of(of(classDesc.componentType()));\n+        if (classDesc.isPrimitive())\n+            return BaseTypeSig.of(classDesc);\n+        return ClassTypeSig.of(classDesc);\n+    }\n+\n+    \/**\n+     * Models the signature of a primitive type or void\n+     *\/\n+    public sealed interface BaseTypeSig extends Signature\n+            permits SignaturesImpl.BaseTypeSigImpl {\n+\n+        \/** {@return the single-letter descriptor for the base type} *\/\n+        char baseType();\n+\n+        \/**\n+         * {@return the signature of a primitive type or void}\n+         * @param classDesc a symbolic descriptor for the base type, must correspond\n+         *                  to a primitive type\n+         *\/\n+        public static BaseTypeSig of(ClassDesc classDesc) {\n+            requireNonNull(classDesc);\n+            if (!classDesc.isPrimitive())\n+                throw new IllegalArgumentException(\"primitive class type required\");\n+            return new SignaturesImpl.BaseTypeSigImpl(classDesc.descriptorString().charAt(0));\n+        }\n+\n+        \/**\n+         * {@return the signature of a primitive type or void}\n+         * @param baseType the single-letter descriptor for the base type\n+         *\/\n+        public static BaseTypeSig of(char baseType) {\n+            if (\"VIJCSBFDZ\".indexOf(baseType) < 0)\n+                throw new IllegalArgumentException(\"invalid base type signature\");\n+            return new SignaturesImpl.BaseTypeSigImpl(baseType);\n+        }\n+    }\n+\n+    \/**\n+     * Models the signature of a reference type, which may be a class, interface,\n+     * type variable, or array type.\n+     *\/\n+    public sealed interface RefTypeSig\n+            extends Signature\n+            permits ArrayTypeSig, ClassTypeSig, TypeArg, TypeVarSig {\n+    }\n+\n+    \/**\n+     * Models the signature of a possibly-parameterized class or interface type.\n+     *\/\n+    public sealed interface ClassTypeSig\n+            extends RefTypeSig, ThrowableSig\n+            permits SignaturesImpl.ClassTypeSigImpl {\n+\n+        \/** {@return the signature of the outer type, if any} *\/\n+        Optional<ClassTypeSig> outerType();\n+\n+        \/** {@return the class name} *\/\n+        String className();\n+\n+        \/** {@return the class name, as a symbolic descriptor} *\/\n+        default ClassDesc classDesc() {\n+            return ClassDesc.ofInternalName(className());\n+        }\n+\n+        \/** {@return the type arguments of the class} *\/\n+        List<Signature> typeArgs();\n+\n+        \/**\n+         * {@return a class type signature}\n+         * @param className the name of the class\n+         * @param typeArgs signatures of the type arguments\n+         *\/\n+        public static ClassTypeSig of(ClassDesc className, Signature... typeArgs) {\n+            return of(null, className, typeArgs);\n+        }\n+\n+        \/**\n+         * {@return a class type signature for an inner class}\n+         * @param outerType signature of the outer type\n+         * @param className the name of the class\n+         * @param typeArgs signatures of the type arguments\n+         *\/\n+        public static ClassTypeSig of(ClassTypeSig outerType, ClassDesc className, Signature... typeArgs) {\n+            requireNonNull(className);\n+            return of(outerType, Util.toInternalName(className), typeArgs);\n+        }\n+\n+        \/**\n+         * {@return a class type signature}\n+         * @param className the name of the class\n+         * @param typeArgs signatures of the type arguments\n+         *\/\n+        public static ClassTypeSig of(String className, Signature... typeArgs) {\n+            return of(null, className, typeArgs);\n+        }\n+\n+        \/**\n+         * {@return a class type signature for an inner class}\n+         * @param outerType signature of the outer type\n+         * @param className the name of the class\n+         * @param typeArgs signatures of the type arguments\n+         *\/\n+        public static ClassTypeSig of(ClassTypeSig outerType, String className, Signature... typeArgs) {\n+            requireNonNull(className);\n+            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className.replace(\".\", \"\/\"), List.of(typeArgs));\n+        }\n+    }\n+\n+    \/**\n+     * Models the signature of a type argument.\n+     *\/\n+    public sealed interface TypeArg extends RefTypeSig\n+            permits SignaturesImpl.TypeArgImpl {\n+\n+        \/**\n+         * Indicator for whether a wildcard has no bound, an upper bound, or a lower bound\n+         *\/\n+        public enum WildcardIndicator {\n+            UNBOUNDED('*'), EXTENDS('+'), SUPER('-');\n+\n+            public final char indicator;\n+\n+            WildcardIndicator(char indicator) {\n+                this.indicator = indicator;\n+            }\n+        }\n+\n+        \/** {@return the wildcard indicator} *\/\n+        WildcardIndicator wildcardIndicator();\n+\n+        \/** {@return the signature of the type bound, if any} *\/\n+        Optional<RefTypeSig> boundType();\n+\n+        \/**\n+         * {@return a signature for an unbounded wildcard}\n+         *\/\n+        public static TypeArg unbounded() {\n+            return new SignaturesImpl.TypeArgImpl(WildcardIndicator.UNBOUNDED, Optional.empty());\n+        }\n+\n+        \/**\n+         * {@return a signature for an upper-bounded wildcard}\n+         * @param boundType the upper bound\n+         *\/\n+        public static TypeArg extendsOf(RefTypeSig boundType) {\n+            requireNonNull(boundType);\n+            return new SignaturesImpl.TypeArgImpl(WildcardIndicator.EXTENDS, Optional.of(boundType));\n+        }\n+\n+        \/**\n+         * {@return a signature for a lower-bounded wildcard}\n+         * @param boundType the lower bound\n+         *\/\n+        public static TypeArg superOf(RefTypeSig boundType) {\n+            requireNonNull(boundType);\n+            return new SignaturesImpl.TypeArgImpl(WildcardIndicator.SUPER, Optional.of(boundType));\n+        }\n+    }\n+\n+    \/**\n+     * Models the signature of a type variable.\n+     *\/\n+    public sealed interface TypeVarSig\n+            extends RefTypeSig, ThrowableSig\n+            permits SignaturesImpl.TypeVarSigImpl {\n+\n+        \/** {@return the name of the type variable} *\/\n+        String identifier();\n+\n+        \/**\n+         * {@return a signature for a type variable}\n+         * @param identifier the name of the type variable\n+         *\/\n+        public static TypeVarSig of(String identifier) {\n+            return new SignaturesImpl.TypeVarSigImpl(requireNonNull(identifier));\n+        }\n+    }\n+\n+    \/**\n+     * Models the signature of an array type.\n+     *\/\n+    public sealed interface ArrayTypeSig\n+            extends RefTypeSig\n+            permits SignaturesImpl.ArrayTypeSigImpl {\n+\n+        \/** {@return the signature of the component type} *\/\n+        Signature componentSignature();\n+\n+        \/**\n+         * {@return a signature for an array type}\n+         * @param componentSignature the component type\n+         *\/\n+        public static ArrayTypeSig of(Signature componentSignature) {\n+            return of(1, requireNonNull(componentSignature));\n+        }\n+\n+        \/**\n+         * {@return a signature for an array type}\n+         * @param dims the dimension of the array\n+         * @param componentSignature the component type\n+         *\/\n+        public static ArrayTypeSig of(int dims, Signature componentSignature) {\n+            requireNonNull(componentSignature);\n+            if (dims < 1 || dims > 255)\n+                throw new IllegalArgumentException(\"illegal array depth value\");\n+            if (componentSignature instanceof SignaturesImpl.ArrayTypeSigImpl arr)\n+                return new SignaturesImpl.ArrayTypeSigImpl(dims + arr.arrayDepth(), arr.elemType());\n+            return new SignaturesImpl.ArrayTypeSigImpl(dims, componentSignature);\n+        }\n+    }\n+\n+    \/**\n+     * Models a signature for a type parameter of a generic class or method.\n+     *\/\n+    public sealed interface TypeParam\n+            permits SignaturesImpl.TypeParamImpl {\n+\n+        \/** {@return the name of the type parameter} *\/\n+        String identifier();\n+\n+        \/** {@return the class bound of the type parameter} *\/\n+        Optional<RefTypeSig> classBound();\n+\n+        \/** {@return the interface bounds of the type parameter} *\/\n+        List<RefTypeSig> interfaceBounds();\n+\n+        \/**\n+         * {@return a signature for a type parameter}\n+         * @param identifier the name of the type parameter\n+         * @param classBound the class bound of the type parameter\n+         * @param interfaceBounds the interface bounds of the type parameter\n+         *\/\n+        public static TypeParam of(String identifier, RefTypeSig classBound, RefTypeSig... interfaceBounds) {\n+            return new SignaturesImpl.TypeParamImpl(\n+                    requireNonNull(identifier),\n+                    Optional.ofNullable(classBound),\n+                    List.of(interfaceBounds));\n+        }\n+\n+        \/**\n+         * {@return a signature for a type parameter}\n+         * @param identifier the name of the type parameter\n+         * @param classBound the class bound of the type parameter\n+         * @param interfaceBounds the interface bounds of the type parameter\n+         *\/\n+        public static TypeParam of(String identifier, Optional<RefTypeSig> classBound, RefTypeSig... interfaceBounds) {\n+            return new SignaturesImpl.TypeParamImpl(\n+                    requireNonNull(identifier),\n+                    requireNonNull(classBound),\n+                    List.of(interfaceBounds));\n+        }\n+    }\n+\n+    \/**\n+     * Models a signature for a throwable type.\n+     *\/\n+    public sealed interface ThrowableSig extends Signature {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Signature.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.SuperclassImpl;\n+\n+\/**\n+ * Models the superclass of a class.  Delivered as a {@link\n+ * jdk.internal.classfile.ClassElement} when traversing a {@link ClassModel}.\n+ *\/\n+public sealed interface Superclass\n+        extends ClassElement\n+        permits SuperclassImpl {\n+\n+    \/** {@return the superclass} *\/\n+    ClassEntry superclassEntry();\n+\n+    \/**\n+     * {@return a {@linkplain Superclass} element}\n+     * @param superclassEntry the superclass\n+     *\/\n+    static Superclass of(ClassEntry superclassEntry) {\n+        return new SuperclassImpl(superclassEntry);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Superclass.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.TargetInfoImpl;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+import static jdk.internal.classfile.Classfile.TAT_CAST;\n+import static jdk.internal.classfile.Classfile.TAT_CLASS_EXTENDS;\n+import static jdk.internal.classfile.Classfile.TAT_CLASS_TYPE_PARAMETER;\n+import static jdk.internal.classfile.Classfile.TAT_CLASS_TYPE_PARAMETER_BOUND;\n+import static jdk.internal.classfile.Classfile.TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT;\n+import static jdk.internal.classfile.Classfile.TAT_CONSTRUCTOR_REFERENCE;\n+import static jdk.internal.classfile.Classfile.TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT;\n+import static jdk.internal.classfile.Classfile.TAT_EXCEPTION_PARAMETER;\n+import static jdk.internal.classfile.Classfile.TAT_FIELD;\n+import static jdk.internal.classfile.Classfile.TAT_INSTANCEOF;\n+import static jdk.internal.classfile.Classfile.TAT_LOCAL_VARIABLE;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_FORMAL_PARAMETER;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_INVOCATION_TYPE_ARGUMENT;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_RECEIVER;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_REFERENCE;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_REFERENCE_TYPE_ARGUMENT;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_RETURN;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_TYPE_PARAMETER;\n+import static jdk.internal.classfile.Classfile.TAT_METHOD_TYPE_PARAMETER_BOUND;\n+import static jdk.internal.classfile.Classfile.TAT_NEW;\n+import static jdk.internal.classfile.Classfile.TAT_RESOURCE_VARIABLE;\n+import static jdk.internal.classfile.Classfile.TAT_THROWS;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+\/**\n+ * Models an annotation on a type use.\n+ *\n+ * @see RuntimeVisibleTypeAnnotationsAttribute\n+ * @see RuntimeInvisibleTypeAnnotationsAttribute\n+ *\/\n+public sealed interface TypeAnnotation\n+        extends Annotation\n+        permits UnboundAttribute.UnboundTypeAnnotation {\n+\n+    \/**\n+     * The kind of target on which the annotation appears.\n+     *\/\n+    public enum TargetType {\n+        \/** For annotations on a class type parameter declaration. *\/\n+        CLASS_TYPE_PARAMETER(TAT_CLASS_TYPE_PARAMETER, 1),\n+\n+        \/** For annotations on a method type parameter declaration. *\/\n+        METHOD_TYPE_PARAMETER(TAT_METHOD_TYPE_PARAMETER, 1),\n+\n+        \/** For annotations on the type of an \"extends\" or \"implements\" clause. *\/\n+        CLASS_EXTENDS(TAT_CLASS_EXTENDS, 2),\n+\n+        \/** For annotations on a bound of a type parameter of a class. *\/\n+        CLASS_TYPE_PARAMETER_BOUND(TAT_CLASS_TYPE_PARAMETER_BOUND, 2),\n+\n+        \/** For annotations on a bound of a type parameter of a method. *\/\n+        METHOD_TYPE_PARAMETER_BOUND(TAT_METHOD_TYPE_PARAMETER_BOUND, 2),\n+\n+        \/** For annotations on a field. *\/\n+        FIELD(TAT_FIELD, 0),\n+\n+        \/** For annotations on a method return type. *\/\n+        METHOD_RETURN(TAT_METHOD_RETURN, 0),\n+\n+        \/** For annotations on the method receiver. *\/\n+        METHOD_RECEIVER(TAT_METHOD_RECEIVER, 0),\n+\n+        \/** For annotations on a method parameter. *\/\n+        METHOD_FORMAL_PARAMETER(TAT_METHOD_FORMAL_PARAMETER, 1),\n+\n+        \/** For annotations on a throws clause in a method declaration. *\/\n+        THROWS(TAT_THROWS, 2),\n+\n+        \/** For annotations on a local variable. *\/\n+        LOCAL_VARIABLE(TAT_LOCAL_VARIABLE, -1),\n+\n+        \/** For annotations on a resource variable. *\/\n+        RESOURCE_VARIABLE(TAT_RESOURCE_VARIABLE, -1),\n+\n+        \/** For annotations on an exception parameter. *\/\n+        EXCEPTION_PARAMETER(TAT_EXCEPTION_PARAMETER, 2),\n+\n+        \/** For annotations on a type test. *\/\n+        INSTANCEOF(TAT_INSTANCEOF, 2),\n+\n+        \/** For annotations on an object creation expression. *\/\n+        NEW(TAT_NEW, 2),\n+\n+        \/** For annotations on a constructor reference receiver. *\/\n+        CONSTRUCTOR_REFERENCE(TAT_CONSTRUCTOR_REFERENCE, 2),\n+\n+        \/** For annotations on a method reference receiver. *\/\n+        METHOD_REFERENCE(TAT_METHOD_REFERENCE, 2),\n+\n+        \/** For annotations on a typecast. *\/\n+        CAST(TAT_CAST, 3),\n+\n+        \/** For annotations on a type argument of an object creation expression. *\/\n+        CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT(TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT, 3),\n+\n+        \/** For annotations on a type argument of a method call. *\/\n+        METHOD_INVOCATION_TYPE_ARGUMENT(TAT_METHOD_INVOCATION_TYPE_ARGUMENT, 3),\n+\n+        \/** For annotations on a type argument of a constructor reference. *\/\n+        CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT(TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT, 3),\n+\n+        \/** For annotations on a type argument of a method reference. *\/\n+        METHOD_REFERENCE_TYPE_ARGUMENT(TAT_METHOD_REFERENCE_TYPE_ARGUMENT, 3);\n+\n+        private final int targetTypeValue;\n+        private final int sizeIfFixed;\n+\n+        private TargetType(int targetTypeValue, int sizeIfFixed) {\n+            this.targetTypeValue = targetTypeValue;\n+            this.sizeIfFixed = sizeIfFixed;\n+        }\n+\n+        public int targetTypeValue() {\n+            return targetTypeValue;\n+        }\n+\n+        public int sizeIfFixed() {\n+            return sizeIfFixed;\n+        }\n+    }\n+\n+    \/**\n+     * {@return information describing precisely which type in a declaration or expression\n+     * is annotated}\n+     *\/\n+    TargetInfo targetInfo();\n+\n+    \/**\n+     * {@return which part of the type indicated by {@link #targetInfo()} is annotated}\n+     *\/\n+    List<TypePathComponent> targetPath();\n+\n+    \/**\n+     * {@return a type annotation}\n+     * @param targetInfo which type in a declaration or expression is annotated\n+     * @param targetPath which part of the type is annotated\n+     * @param annotationClassUtf8Entry the annotation class\n+     * @param annotationElements the annotation elements\n+     *\/\n+    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n+                             Utf8Entry annotationClassUtf8Entry,\n+                             List<AnnotationElement> annotationElements) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n+                annotationClassUtf8Entry, annotationElements);\n+    }\n+\n+    \/**\n+     * {@return a type annotation}\n+     * @param targetInfo which type in a declaration or expression is annotated\n+     * @param targetPath which part of the type is annotated\n+     * @param annotationClass the annotation class\n+     * @param annotationElements the annotation elements\n+     *\/\n+    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n+                             ClassDesc annotationClass,\n+                             AnnotationElement... annotationElements) {\n+        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n+    }\n+\n+    \/**\n+     * {@return a type annotation}\n+     * @param targetInfo which type in a declaration or expression is annotated\n+     * @param targetPath which part of the type is annotated\n+     * @param annotationClass the annotation class\n+     * @param annotationElements the annotation elements\n+     *\/\n+    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n+                             ClassDesc annotationClass,\n+                             List<AnnotationElement> annotationElements) {\n+        return of(targetInfo, targetPath,\n+                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n+    }\n+\n+    \/**\n+     * {@return a type annotation}\n+     * @param targetInfo which type in a declaration or expression is annotated\n+     * @param targetPath which part of the type is annotated\n+     * @param annotationClassUtf8Entry the annotation class\n+     * @param annotationElements the annotation elements\n+     *\/\n+    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n+                             Utf8Entry annotationClassUtf8Entry,\n+                             AnnotationElement... annotationElements) {\n+        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+    }\n+\n+    \/**\n+     * Specifies which type in a declaration or expression is being annotated.\n+     *\/\n+    sealed interface TargetInfo {\n+\n+        TargetType targetType();\n+\n+        default int size() {\n+            return targetType().sizeIfFixed;\n+        }\n+\n+        static TypeParameterTarget ofTypeParameter(TargetType targetType, int typeParameterIndex) {\n+            return new TargetInfoImpl.TypeParameterTargetImpl(targetType, typeParameterIndex);\n+        }\n+\n+        static TypeParameterTarget ofClassTypeParameter(int typeParameterIndex) {\n+            return ofTypeParameter(TargetType.CLASS_TYPE_PARAMETER, typeParameterIndex);\n+        }\n+\n+        static TypeParameterTarget ofMethodTypeParameter(int typeParameterIndex) {\n+            return ofTypeParameter(TargetType.METHOD_TYPE_PARAMETER, typeParameterIndex);\n+        }\n+\n+        static SupertypeTarget ofClassExtends(int supertypeIndex) {\n+            return new TargetInfoImpl.SupertypeTargetImpl(supertypeIndex);\n+        }\n+\n+        static TypeParameterBoundTarget ofTypeParameterBound(TargetType targetType, int typeParameterIndex, int boundIndex) {\n+            return new TargetInfoImpl.TypeParameterBoundTargetImpl(targetType, typeParameterIndex, boundIndex);\n+        }\n+\n+        static TypeParameterBoundTarget ofClassTypeParameterBound(int typeParameterIndex, int boundIndex) {\n+            return ofTypeParameterBound(TargetType.CLASS_TYPE_PARAMETER_BOUND, typeParameterIndex, boundIndex);\n+        }\n+\n+        static TypeParameterBoundTarget ofMethodTypeParameterBound(int typeParameterIndex, int boundIndex) {\n+            return ofTypeParameterBound(TargetType.METHOD_TYPE_PARAMETER_BOUND, typeParameterIndex, boundIndex);\n+        }\n+\n+        static EmptyTarget of(TargetType targetType) {\n+            return new TargetInfoImpl.EmptyTargetImpl(targetType);\n+        }\n+\n+        static EmptyTarget ofField() {\n+            return of(TargetType.FIELD);\n+        }\n+\n+        static EmptyTarget ofMethodReturn() {\n+            return of(TargetType.METHOD_RETURN);\n+        }\n+\n+        static EmptyTarget ofMethodReceiver() {\n+            return of(TargetType.METHOD_RECEIVER);\n+        }\n+\n+        static FormalParameterTarget ofMethodFormalParameter(int formalParameterIndex) {\n+            return new TargetInfoImpl.FormalParameterTargetImpl(formalParameterIndex);\n+        }\n+\n+        static ThrowsTarget ofThrows(int throwsTargetIndex) {\n+            return new TargetInfoImpl.ThrowsTargetImpl(throwsTargetIndex);\n+        }\n+\n+        static LocalVarTarget ofVariable(TargetType targetType, List<LocalVarTargetInfo> table) {\n+            return new TargetInfoImpl.LocalVarTargetImpl(targetType, table);\n+        }\n+\n+        static LocalVarTarget ofLocalVariable(List<LocalVarTargetInfo> table) {\n+            return ofVariable(TargetType.LOCAL_VARIABLE, table);\n+        }\n+\n+        static LocalVarTarget ofResourceVariable(List<LocalVarTargetInfo> table) {\n+            return ofVariable(TargetType.RESOURCE_VARIABLE, table);\n+        }\n+\n+        static CatchTarget ofExceptionParameter(int exceptionTableIndex) {\n+            return new TargetInfoImpl.CatchTargetImpl(exceptionTableIndex);\n+        }\n+\n+        static OffsetTarget ofOffset(TargetType targetType, Label target) {\n+            return new TargetInfoImpl.OffsetTargetImpl(targetType, target);\n+        }\n+\n+        static OffsetTarget ofInstanceofExpr(Label target) {\n+            return ofOffset(TargetType.INSTANCEOF, target);\n+        }\n+\n+        static OffsetTarget ofNewExpr(Label target) {\n+            return ofOffset(TargetType.NEW, target);\n+        }\n+\n+        static OffsetTarget ofConstructorReference(Label target) {\n+            return ofOffset(TargetType.CONSTRUCTOR_REFERENCE, target);\n+        }\n+\n+        static OffsetTarget ofMethodReference(Label target) {\n+            return ofOffset(TargetType.METHOD_REFERENCE, target);\n+        }\n+\n+        static TypeArgumentTarget ofTypeArgument(TargetType targetType, Label target, int typeArgumentIndex) {\n+            return new TargetInfoImpl.TypeArgumentTargetImpl(targetType, target, typeArgumentIndex);\n+        }\n+\n+        static TypeArgumentTarget ofCastExpr(Label target, int typeArgumentIndex) {\n+            return ofTypeArgument(TargetType.CAST, target, typeArgumentIndex);\n+        }\n+\n+        static TypeArgumentTarget ofConstructorInvocationTypeArgument(Label target, int typeArgumentIndex) {\n+            return ofTypeArgument(TargetType.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT, target, typeArgumentIndex);\n+        }\n+\n+        static TypeArgumentTarget ofMethodInvocationTypeArgument(Label target, int typeArgumentIndex) {\n+            return ofTypeArgument(TargetType.METHOD_INVOCATION_TYPE_ARGUMENT, target, typeArgumentIndex);\n+        }\n+\n+        static TypeArgumentTarget ofConstructorReferenceTypeArgument(Label target, int typeArgumentIndex) {\n+            return ofTypeArgument(TargetType.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT, target, typeArgumentIndex);\n+        }\n+\n+        static TypeArgumentTarget ofMethodReferenceTypeArgument(Label target, int typeArgumentIndex) {\n+            return ofTypeArgument(TargetType.METHOD_REFERENCE_TYPE_ARGUMENT, target, typeArgumentIndex);\n+        }\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on the declaration of the i'th type\n+     * parameter of a generic class, generic interface, generic method, or\n+     * generic constructor.\n+     *\/\n+    sealed interface TypeParameterTarget extends TargetInfo\n+            permits TargetInfoImpl.TypeParameterTargetImpl {\n+\n+        \/**\n+         * JVMS: The value of the type_parameter_index item specifies which type parameter declaration is annotated.\n+         * A type_parameter_index value of 0 specifies the first type parameter declaration.\n+         *\n+         * @return the index into the type parameters\n+         *\/\n+        int typeParameterIndex();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on a type in the extends or implements\n+     * clause of a class or interface declaration.\n+     *\/\n+    sealed interface SupertypeTarget extends TargetInfo\n+            permits TargetInfoImpl.SupertypeTargetImpl {\n+\n+        \/**\n+         * JVMS: A supertype_index value of 65535 specifies that the annotation appears on the superclass in an extends\n+         * clause of a class declaration.\n+         *\n+         * Any other supertype_index value is an index into the interfaces array of the enclosing ClassFile structure,\n+         * and specifies that the annotation appears on that superinterface in either the implements clause of a class\n+         * declaration or the extends clause of an interface declaration.\n+         *\n+         * @return the index into the interfaces array or 65535 to indicate it is the superclass\n+         *\/\n+        int supertypeIndex();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on the i'th bound of the j'th\n+     * type parameter declaration of a generic class, interface, method, or\n+     * constructor.\n+     *\/\n+    sealed interface TypeParameterBoundTarget extends TargetInfo\n+            permits TargetInfoImpl.TypeParameterBoundTargetImpl {\n+\n+        \/**\n+         * Which type parameter declaration has an annotated bound.\n+         *\n+         * @return the zero-origin index into the type parameters\n+         *\/\n+        int typeParameterIndex();\n+\n+        \/**\n+         * Which bound of the type parameter declaration is annotated.\n+         *\n+         * @return the zero-origin index into bounds on the type parameter\n+         *\/\n+        int boundIndex();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on either the type in a field\n+     * declaration, the return type of a method, the type of a newly constructed\n+     * object, or the receiver type of a method or constructor.\n+     *\/\n+    sealed interface EmptyTarget extends TargetInfo\n+            permits TargetInfoImpl.EmptyTargetImpl {\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on the type in a formal parameter\n+     * declaration of a method, constructor, or lambda expression.\n+     *\/\n+    sealed interface FormalParameterTarget extends TargetInfo\n+            permits TargetInfoImpl.FormalParameterTargetImpl {\n+\n+        \/**\n+         * Which formal parameter declaration has an annotated type.\n+         *\n+         * @return the index into the formal parameter declarations, in the order\n+         * declared in the source code\n+         *\/\n+        int formalParameterIndex();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on the i'th type in the throws\n+     * clause of a method or constructor declaration.\n+     *\/\n+    sealed interface ThrowsTarget extends TargetInfo\n+            permits TargetInfoImpl.ThrowsTargetImpl {\n+\n+        \/**\n+         * The index into the exception_index_table array of the\n+         * Exceptions attribute of the method_info structure enclosing the\n+         * RuntimeVisibleTypeAnnotations attribute.\n+         *\n+         * @return index into the list jdk.internal.classfile.attribute.ExceptionsAttribute.exceptions()\n+         *\/\n+        int throwsTargetIndex();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on the type in a local variable declaration,\n+     * including a variable declared as a resource in a try-with-resources statement.\n+     *\/\n+    sealed interface LocalVarTarget extends TargetInfo\n+            permits TargetInfoImpl.LocalVarTargetImpl {\n+\n+        \/**\n+         * @return the table of local variable location\/indicies.\n+         *\/\n+        List<LocalVarTargetInfo> table();\n+    }\n+\n+    \/**\n+     * Indicates a range of code array offsets within which a local variable\n+     * has a value, and the index into the local variable array of the current\n+     * frame at which that local variable can be found.\n+     *\/\n+    sealed interface LocalVarTargetInfo\n+            permits TargetInfoImpl.LocalVarTargetInfoImpl {\n+\n+        \/**\n+         * The given local variable has a value at indices into the code array in the interval\n+         * [start_pc, start_pc + length), that is, between start_pc inclusive and start_pc + length exclusive.\n+         *\n+         * @return the start of the bytecode section.\n+         *\/\n+        Label startLabel();\n+\n+\n+        \/**\n+         * The given local variable has a value at indices into the code array in the interval\n+         * [start_pc, start_pc + length), that is, between start_pc inclusive and start_pc + length exclusive.\n+         *\n+         * @return\n+         *\/\n+        Label endLabel();\n+\n+        \/**\n+         * The given local variable must be at index in the local variable array of the current frame.\n+         *\n+         * If the local variable at index is of type double or long, it occupies both index and index + 1.\n+         *\n+         * @return index into the local variables\n+         *\/\n+        int index();\n+\n+        static LocalVarTargetInfo of(Label startLabel, Label endLabel, int index) {\n+            return new TargetInfoImpl.LocalVarTargetInfoImpl(startLabel, endLabel, index);\n+        }\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on the i'th type in an exception parameter\n+     * declaration.\n+     *\/\n+    sealed interface CatchTarget extends TargetInfo\n+            permits TargetInfoImpl.CatchTargetImpl {\n+\n+        \/**\n+         * The index into the exception_table array of the Code\n+         * attribute enclosing the RuntimeVisibleTypeAnnotations attribute.\n+         *\n+         * @return the index into the exception table\n+         *\/\n+        int exceptionTableIndex();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears on either the type in an instanceof expression\n+     * or a new expression, or the type before the :: in a method reference expression.\n+     *\/\n+    sealed interface OffsetTarget extends TargetInfo\n+            permits TargetInfoImpl.OffsetTargetImpl {\n+\n+        \/**\n+         * The code array offset of either the bytecode instruction\n+         * corresponding to the instanceof expression, the new bytecode instruction corresponding to the new\n+         * expression, or the bytecode instruction corresponding to the method reference expression.\n+         *\n+         * @return\n+         *\/\n+        Label target();\n+    }\n+\n+    \/**\n+     * Indicates that an annotation appears either on the i'th type in a cast\n+     * expression, or on the i'th type argument in the explicit type argument list for any of the following: a new\n+     * expression, an explicit constructor invocation statement, a method invocation expression, or a method reference\n+     * expression.\n+     *\/\n+    sealed interface TypeArgumentTarget extends TargetInfo\n+            permits TargetInfoImpl.TypeArgumentTargetImpl {\n+\n+        \/**\n+         * The code array offset of either the bytecode instruction\n+         * corresponding to the cast expression, the new bytecode instruction corresponding to the new expression, the\n+         * bytecode instruction corresponding to the explicit constructor invocation statement, the bytecode\n+         * instruction corresponding to the method invocation expression, or the bytecode instruction corresponding to\n+         * the method reference expression.\n+         *\n+         * @return\n+         *\/\n+        Label target();\n+\n+        \/**\n+         * For a cast expression, the value of the type_argument_index item specifies which type in the cast\n+         * operator is annotated. A type_argument_index value of 0 specifies the first (or only) type in the cast\n+         * operator.\n+         *\n+         * The possibility of more than one type in a cast expression arises from a cast to an intersection type.\n+         *\n+         * For an explicit type argument list, the value of the type_argument_index item specifies which type argument\n+         * is annotated. A type_argument_index value of 0 specifies the first type argument.\n+         *\n+         * @return the index into the type arguments\n+         *\/\n+        int typeArgumentIndex();\n+    }\n+\n+    \/**\n+     * JVMS: Wherever a type is used in a declaration or expression, the type_path structure identifies which part of\n+     * the type is annotated. An annotation may appear on the type itself, but if the type is a reference type, then\n+     * there are additional locations where an annotation may appear:\n+     *\n+     * If an array type T[] is used in a declaration or expression, then an annotation may appear on any component type\n+     * of the array type, including the element type.\n+     *\n+     * If a nested type T1.T2 is used in a declaration or expression, then an annotation may appear on the name of the\n+     * innermost member type and any enclosing type for which a type annotation is admissible {@jls 9.7.4}.\n+     *\n+     * If a parameterized type {@literal T<A> or T<? extends A> or T<? super A>} is used in a declaration or expression, then an\n+     * annotation may appear on any type argument or on the bound of any wildcard type argument.\n+     *\n+     * JVMS: ...  each entry in the path array represents an iterative, left-to-right step towards the precise location\n+     * of the annotation in an array type, nested type, or parameterized type. (In an array type, the iteration visits\n+     * the array type itself, then its component type, then the component type of that component type, and so on,\n+     * until the element type is reached.)\n+     *\/\n+    sealed interface TypePathComponent\n+            permits UnboundAttribute.TypePathComponentImpl {\n+\n+        public enum Kind {\n+            ARRAY(0),\n+            INNER_TYPE(1),\n+            WILDCARD(2),\n+            TYPE_ARGUMENT(3);\n+\n+            private final int tag;\n+\n+            private Kind(int tag) {\n+                this.tag = tag;\n+            }\n+\n+            public int tag() {\n+                return tag;\n+            }\n+        }\n+\n+        TypePathComponent ARRAY = new UnboundAttribute.TypePathComponentImpl(Kind.ARRAY, 0);\n+        TypePathComponent INNER_TYPE = new UnboundAttribute.TypePathComponentImpl(Kind.INNER_TYPE, 0);\n+        TypePathComponent WILDCARD = new UnboundAttribute.TypePathComponentImpl(Kind.WILDCARD, 0);\n+\n+\n+        \/**\n+         * The type path kind items from JVMS Table 4.7.20.2-A.\n+         *\n+         * @return the kind of path element\n+         *\/\n+        Kind typePathKind();\n+\n+        \/**\n+         * JVMS: type_argument_index\n+         * If the value of the type_path_kind item is 0, 1, or 2, then the value of the type_argument_index item is 0.\n+         *\n+         * If the value of the type_path_kind item is 3, then the value of the type_argument_index item specifies which\n+         * type argument of a parameterized type is annotated, where 0 indicates the first type argument of a\n+         * parameterized type.\n+         *\n+         * @return the index within the type component\n+         *\/\n+        int typeArgumentIndex();\n+\n+        static TypePathComponent of(Kind typePathKind, int typeArgumentIndex) {\n+\n+            return switch (typePathKind) {\n+                case ARRAY -> ARRAY;\n+                case INNER_TYPE -> INNER_TYPE;\n+                case WILDCARD -> WILDCARD;\n+                case TYPE_ARGUMENT -> new UnboundAttribute.TypePathComponentImpl(Kind.TYPE_ARGUMENT, typeArgumentIndex);\n+            };\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/TypeAnnotation.java","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile;\n+\n+\/**\n+ * Describes the types that can be part of a field or method descriptor.\n+ *\/\n+public enum TypeKind {\n+    \/** the primitive type byte *\/\n+    ByteType(\"byte\", \"B\", 8),\n+    \/** the primitive type short *\/\n+    ShortType(\"short\", \"S\", 9),\n+    \/** the primitive type int *\/\n+    IntType(\"int\", \"I\", 10),\n+    \/** the primitive type float *\/\n+    FloatType(\"float\", \"F\", 6),\n+    \/** the primitive type long *\/\n+    LongType(\"long\", \"J\", 11),\n+    \/** the primitive type double *\/\n+    DoubleType(\"double\", \"D\", 7),\n+    \/** a reference type *\/\n+    ReferenceType(\"reference type\", \"A\", -1),\n+    \/** the primitive type char *\/\n+    CharType(\"char\", \"C\", 5),\n+    \/** the primitive type boolean *\/\n+    BooleanType(\"boolean\", \"Z\", 4),\n+    \/** void *\/\n+    VoidType(\"void\", \"V\", -1);\n+\n+    private static TypeKind[] newarraycodeToTypeTag;\n+\n+    private final String name;\n+    private final String descriptor;\n+    private final int newarraycode;\n+\n+    \/** {@return the human-readable name corresponding to this type} *\/\n+    public String typeName() { return name; }\n+\n+    \/** {@return the field descriptor character corresponding to this type} *\/\n+    public String descriptor() { return descriptor; }\n+\n+    \/** {@return the code used by the {@code newarray} opcode corresponding to this type} *\/\n+    public int newarraycode() {\n+        return newarraycode;\n+    }\n+\n+    \/**\n+     * {@return the number of local variable slots consumed by this type}\n+     *\/\n+    public int slotSize() {\n+        return switch (this) {\n+            case VoidType -> 0;\n+            case LongType, DoubleType -> 2;\n+            default -> 1;\n+        };\n+    }\n+\n+    \/**\n+     * Erase this type kind to the type which will be used for xLOAD, xSTORE,\n+     * and xRETURN bytecodes\n+     * @return the erased type kind\n+     *\/\n+    public TypeKind asLoadable() {\n+        return switch (this) {\n+            case BooleanType, ByteType, CharType, ShortType -> TypeKind.IntType;\n+            default -> this;\n+        };\n+    }\n+\n+    TypeKind(String name, String descriptor, int newarraycode) {\n+        this.name = name;\n+        this.descriptor = descriptor;\n+        this.newarraycode = newarraycode;\n+    }\n+\n+    \/**\n+     * {@return the type kind associated with the array type described by the\n+     * array code used as an operand to {@code newarray}}\n+     * @param newarraycode the operand of the {@code newarray} instruction\n+     *\/\n+    public static TypeKind fromNewArrayCode(int newarraycode) {\n+        if (newarraycodeToTypeTag == null) {\n+            newarraycodeToTypeTag = new TypeKind[12];\n+            for (TypeKind tag : TypeKind.values()) {\n+                if (tag.newarraycode > 0) newarraycodeToTypeTag[tag.newarraycode] = tag;\n+            }\n+        }\n+        return newarraycodeToTypeTag[newarraycode];\n+    }\n+\n+    \/**\n+     * {@return the type kind associated with the specified field descriptor}\n+     * @param s the field descriptor\n+     *\/\n+    public static TypeKind fromDescriptor(CharSequence s) {\n+        return switch (s.charAt(0)) {\n+            case '[', 'L' -> TypeKind.ReferenceType;\n+            case 'B' -> TypeKind.ByteType;\n+            case 'C' -> TypeKind.CharType;\n+            case 'Z' -> TypeKind.BooleanType;\n+            case 'S' -> TypeKind.ShortType;\n+            case 'I' -> TypeKind.IntType;\n+            case 'F' -> TypeKind.FloatType;\n+            case 'J' -> TypeKind.LongType;\n+            case 'D' -> TypeKind.DoubleType;\n+            case 'V' -> TypeKind.VoidType;\n+            default -> throw new IllegalStateException(\"Bad type: \" + s);\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/TypeKind.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile;\n+\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.impl.DirectFieldBuilder;\n+import jdk.internal.classfile.impl.DirectMethodBuilder;\n+\n+\/**\n+ * A classfile element that can encode itself as a stream of bytes in the\n+ * encoding expected by the classfile format.\n+ *\n+ * @param <T> the type of the entity\n+ *\/\n+public sealed interface WritableElement<T> extends ClassfileElement\n+        permits Annotation, AnnotationElement, AnnotationValue, Attribute,\n+                PoolEntry, BootstrapMethodEntry, FieldModel, MethodModel,\n+                ConstantPoolBuilder, DirectFieldBuilder, DirectMethodBuilder {\n+    \/**\n+     * Writes the element to the specified writer\n+     *\n+     * @param buf the writer\n+     *\/\n+    void writeTo(BufWriter buf);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/WritableElement.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code AnnotationDefault} attribute {@jvms 4.7.22}, which can\n+ * appear on methods of annotation types, and records the default value\n+ * {@jls 9.6.2} for the element corresponding to this method.  Delivered as a\n+ * {@link MethodElement} when traversing the elements of a {@link MethodModel}.\n+ *\/\n+public sealed interface AnnotationDefaultAttribute\n+        extends Attribute<AnnotationDefaultAttribute>, MethodElement\n+        permits BoundAttribute.BoundAnnotationDefaultAttr,\n+                UnboundAttribute.UnboundAnnotationDefaultAttribute {\n+\n+    \/**\n+     * {@return the default value of the annotation type element represented by\n+     * this method}\n+     *\/\n+    AnnotationValue defaultValue();\n+\n+    \/**\n+     * {@return an {@code AnnotationDefault} attribute}\n+     * @param annotationDefault the default value of the annotation type element\n+     *\/\n+    static AnnotationDefaultAttribute of(AnnotationValue annotationDefault) {\n+        return new UnboundAttribute.UnboundAnnotationDefaultAttribute(annotationDefault);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/AnnotationDefaultAttribute.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code BootstrapMethods} attribute {@jvms 4.7.23}, which serves as\n+ * an extension to the constant pool of a classfile.  Elements of the bootstrap\n+ * method table are accessed through {@link ConstantPool}.\n+ *\/\n+public sealed interface BootstrapMethodsAttribute\n+        extends Attribute<BootstrapMethodsAttribute>\n+        permits BoundAttribute.BoundBootstrapMethodsAttribute,\n+                UnboundAttribute.EmptyBootstrapAttribute {\n+\n+    \/**\n+     * {@return the elements of the bootstrap method table}\n+     *\/\n+    List<BootstrapMethodEntry> bootstrapMethods();\n+\n+    \/**\n+     * {@return the size of the bootstrap methods table}.  Calling this method\n+     * does not necessarily inflate the entire table.\n+     *\/\n+    int bootstrapMethodsSize();\n+\n+    \/\/ No factories; BMA is generated as part of constant pool\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/BootstrapMethodsAttribute.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a single character range in the {@link CharacterRangeTableAttribute}.\n+ *\/\n+public sealed interface CharacterRangeInfo\n+        permits UnboundAttribute.UnboundCharacterRangeInfo {\n+\n+    \/**\n+     * {@return the start of the character range region (inclusive)}  This is\n+     * the index into the code array at which the code for this character range\n+     * begins.\n+     *\/\n+    int startPc();\n+\n+    \/**\n+     * {@return the end of the character range region (exclusive)}  This is the\n+     * index into the code array after which the code for this character range\n+     * ends.\n+     *\/\n+    int endPc();\n+\n+    \/**\n+     * {@return the encoded start of the character range region (inclusive)}\n+     * The value is constructed from the line_number\/column_number pair as given\n+     * by {@code line_number << 10 + column_number}, where the source file is\n+     * viewed as an array of (possibly multi-byte) characters.\n+     *\/\n+    int characterRangeStart();\n+\n+    \/**\n+     * {@return the encoded end of the character range region (exclusive)}.\n+     * The value is constructed from the line_number\/column_number pair as given\n+     * by {@code line_number << 10 + column_number}, where the source file is\n+     * viewed as an array of (possibly multi-byte) characters.\n+     *\/\n+    int characterRangeEnd();\n+\n+    \/**\n+     * The value of the flags item describes the kind of range. Multiple flags\n+     * may be set within flags.\n+     * <ul>\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_STATEMENT} Range is a Statement\n+     * (except ExpressionStatement), StatementExpression {@jls 14.8}, as well as each\n+     * VariableDeclaratorId = VariableInitializer of\n+     * LocalVariableDeclarationStatement {@jls 14.4} or FieldDeclaration {@jls 8.3} in the\n+     * grammar.\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_BLOCK} Range is a Block in the\n+     * grammar.\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_ASSIGNMENT} Range is an assignment\n+     * expression - Expression1 AssignmentOperator Expression1 in the grammar as\n+     * well as increment and decrement expressions (both prefix and postfix).\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_FLOW_CONTROLLER} An expression\n+     * whose value will effect control flow. {@code Flowcon} in the following:\n+     * <pre>\n+     * if ( Flowcon ) Statement [else Statement]\n+     * for ( ForInitOpt ; [Flowcon] ; ForUpdateOpt ) Statement\n+     * while ( Flowcon ) Statement\n+     * do Statement while ( Flowcon ) ;\n+     * switch ( Flowcon ) { SwitchBlockStatementGroups }\n+     * Flowcon || Expression3\n+     * Flowcon &amp;&amp; Expression3\n+     * Flowcon ? Expression : Expression1\n+     * <\/pre>\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_FLOW_TARGET} Statement or\n+     * expression effected by a CRT_FLOW_CONTROLLER. {@code Flowtarg} in the following:\n+     * <pre>\n+     * if ( Flowcon ) Flowtarg [else Flowtarg]\n+     * for ( ForInitOpt ; [Flowcon] ; ForUpdateOpt ) Flowtarg\n+     * while ( Flowcon ) Flowtarg\n+     * do Flowtarg while ( Flowcon ) ;\n+     * Flowcon || Flowtarg\n+     * Flowcon &amp;&amp; Flowtarg\n+     * Flowcon ? Flowtarg : Flowtarg\n+     * <\/pre>\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_INVOKE} Method invocation. For\n+     * example: Identifier Arguments.\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_CREATE} New object creation. For\n+     * example: new Creator.\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_BRANCH_TRUE} A condition encoded\n+     * in the branch instruction immediately contained in the code range for\n+     * this item is not inverted towards the corresponding branch condition in\n+     * the source code. I.e. actual jump occurs if and only if the the source\n+     * code branch condition evaluates to true. Entries of this type are\n+     * produced only for conditions that are listed in the description of\n+     * CRT_FLOW_CONTROLLER flag. The source range for the entry contains flow\n+     * controlling expression. start_pc field for an entry of this type must\n+     * point to a branch instruction: if_acmp&lt;cond&gt;, if_icmp&lt;cond&gt;,\n+     * if&lt;cond&gt;, ifnonull, ifnull or goto. CRT_BRANCH_TRUE and\n+     * CRT_BRANCH_FALSE are special kinds of entries that can be used to\n+     * determine what branch of a condition was chosen during the runtime.\n+     * <li>{@link jdk.internal.classfile.Classfile#CRT_BRANCH_FALSE} A condition encoded\n+     * in the branch instruction immediately contained in the code range for\n+     * this item is inverted towards the corresponding branch condition in the\n+     * source code. I.e. actual jump occurs if and only if the the source code\n+     * branch condition evaluates to false. Entries of this type are produced\n+     * only for conditions that are listed in the description of\n+     * CRT_FLOW_CONTROLLER flag. The source range for the entry contains flow\n+     * controlling expression. start_pc field for an entry of this type must\n+     * point to a branch instruction: if_acmp&lt;cond&gt;, if_icmp&lt;cond&gt;,\n+     * if&lt;cond&gt;, ifnonull, ifnull or goto.\n+     * <\/ul>\n+     * <p>\n+     * All bits of the flags item not assigned above are reserved for future use. They should be set to zero in generated class files and should be ignored by Java virtual machine implementations.\n+     *\n+     * @return the flags\n+     *\/\n+    int flags();\n+\n+    \/**\n+     * {@return a character range description}\n+     * @param startPc the start of the bytecode range, inclusive\n+     * @param endPc the end of the bytecode range, exclusive\n+     * @param characterRangeStart the start of the character range, inclusive,\n+     *                            encoded as {@code line_number << 10 + column_number}\n+     * @param characterRangeEnd the end of the character range, exclusive,\n+     *                          encoded as {@code line_number << 10 + column_number}\n+     * @param flags the range flags\n+     *\/\n+    static CharacterRangeInfo of(int startPc,\n+                                 int endPc,\n+                                 int characterRangeStart,\n+                                 int characterRangeEnd,\n+                                 int flags) {\n+        return new UnboundAttribute.UnboundCharacterRangeInfo(startPc, endPc,\n+                                                              characterRangeStart, characterRangeEnd,\n+                                                              flags);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/CharacterRangeInfo.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * The CharacterRangeTable attribute is an optional variable-length attribute in\n+ * the attributes table of a {@code Code} attribute. It may be used by debuggers\n+ * to determine which part of the Java virtual machine code array corresponds to\n+ * a given position in the source file or to determine what section of source\n+ * code corresponds to a given index into the code array. The\n+ * CharacterRangeTable attribute consists of an array of character range entries.\n+ * Each character range entry within the table associates a range of indices in\n+ * the code array with a range of character indices in the source file. If the\n+ * source file is viewed as an array of characters, a character index is the\n+ * corresponding index into this array. Note that character indices are not the\n+ * same as byte indices as multi-byte characters may be present in the source\n+ * file. Each character range entry includes a flag which indicates what kind of\n+ * range is described: statement, assignment, method call, etc. Both code index\n+ * ranges and character ranges may nest within other ranges, but they may not\n+ * partially overlap. Thus, a given code index may correspond to several\n+ * character range entries and in turn several character ranges, but there will\n+ * be a smallest character range, and for each kind of range in which it is\n+ * enclosed there will be a smallest character range. Similarly, a given\n+ * character index may correspond to several character range entries and in turn\n+ * several code index ranges, but there will be a smallest code index range, and\n+ * for each kind of range in which it is enclosed there will be a smallest code\n+ * index range. The character range entries may appear in any order.\n+ *\/\n+public sealed interface CharacterRangeTableAttribute\n+        extends Attribute<CharacterRangeTableAttribute>\n+        permits BoundAttribute.BoundCharacterRangeTableAttribute,\n+                UnboundAttribute.UnboundCharacterRangeTableAttribute {\n+\n+    \/**\n+     * {@return the entries of the character range table}\n+     *\/\n+    List<CharacterRangeInfo> characterRangeTable();\n+\n+    \/**\n+     * {@return a {@code CharacterRangeTable} attribute}\n+     * @param ranges the descriptions of the character ranges\n+     *\/\n+    static CharacterRangeTableAttribute of(List<CharacterRangeInfo> ranges) {\n+        return new UnboundAttribute.UnboundCharacterRangeTableAttribute(ranges);\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/CharacterRangeTableAttribute.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+\n+\/**\n+ * Models the {@code Code} attribute {@jvms 4.7.3}, appears on non-native,\n+ * non-abstract methods and contains the bytecode of the method body.  Delivered\n+ * as a {@link jdk.internal.classfile.MethodElement} when traversing the elements of a\n+ * {@link jdk.internal.classfile.MethodModel}.\n+ *\/\n+public sealed interface CodeAttribute extends Attribute<CodeAttribute>, CodeModel\n+        permits BoundAttribute.BoundCodeAttribute {\n+\n+    \/**\n+     * {@return The length of the code array in bytes}\n+     *\/\n+    int codeLength();\n+\n+    \/**\n+     * {@return the bytes (bytecode) of the code array}\n+     *\/\n+    byte[] codeArray();\n+\n+    \/**\n+     *\n+     * @param label a marker for a position within this {@code CodeAttribute}\n+     * @return position of the {@code Label} in the {@code codeArray}\n+     *\/\n+    int labelToBci(Label label);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/CodeAttribute.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code CompilationID} attribute (@@@ need reference), which can\n+ * appear on classes and records the compilation time of the class.  Delivered\n+ * as a {@link jdk.internal.classfile.ClassElement} when traversing the elements of\n+ * a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface CompilationIDAttribute\n+        extends Attribute<CompilationIDAttribute>, ClassElement\n+        permits BoundAttribute.BoundCompilationIDAttribute,\n+                UnboundAttribute.UnboundCompilationIDAttribute {\n+\n+    \/**\n+     * {@return the compilation ID}  The compilation ID is the value of\n+     * {@link System#currentTimeMillis()} when the classfile is generated.\n+     *\/\n+    Utf8Entry compilationId();\n+\n+    \/**\n+     * {@return a {@code CompilationID} attribute}\n+     * @param id the compilation ID\n+     *\/\n+    static CompilationIDAttribute of(Utf8Entry id) {\n+        return new UnboundAttribute.UnboundCompilationIDAttribute(id);\n+    }\n+\n+    \/**\n+     * {@return a {@code CompilationID} attribute}\n+     * @param id the compilation ID\n+     *\/\n+    static CompilationIDAttribute of(String id) {\n+        return new UnboundAttribute.UnboundCompilationIDAttribute(TemporaryConstantPool.INSTANCE.utf8Entry(id));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/CompilationIDAttribute.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ConstantDesc;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.constantpool.ConstantValueEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code ConstantValue} attribute {@jvms 4.7.2}, which can appear on\n+ * fields and indicates that the field's value is a constant.  Delivered as a\n+ * {@link jdk.internal.classfile.FieldElement} when traversing the elements of a\n+ * {@link jdk.internal.classfile.FieldModel}.\n+ *\/\n+public sealed interface ConstantValueAttribute\n+        extends Attribute<ConstantValueAttribute>, FieldElement\n+        permits BoundAttribute.BoundConstantValueAttribute,\n+                UnboundAttribute.UnboundConstantValueAttribute {\n+\n+    \/**\n+     * {@return the constant value of the field}\n+     *\/\n+    ConstantValueEntry constant();\n+\n+    \/**\n+     * {@return a {@code ConstantValue} attribute}\n+     * @param value the constant value\n+     *\/\n+    static ConstantValueAttribute of(ConstantValueEntry value) {\n+        return new UnboundAttribute.UnboundConstantValueAttribute(value);\n+    }\n+\n+    \/**\n+     * {@return a {@code ConstantValue} attribute}\n+     * @param value the constant value\n+     *\/\n+    static ConstantValueAttribute of(ConstantDesc value) {\n+        return of(switch(value) {\n+            case Integer i -> TemporaryConstantPool.INSTANCE.intEntry(i);\n+            case Float f -> TemporaryConstantPool.INSTANCE.floatEntry(f);\n+            case Long l -> TemporaryConstantPool.INSTANCE.longEntry(l);\n+            case Double d -> TemporaryConstantPool.INSTANCE.doubleEntry(d);\n+            case String s -> TemporaryConstantPool.INSTANCE.stringEntry(s);\n+            default -> throw new IllegalArgumentException(\"Invalid ConstantValueAtrtibute value: \" + value);\n+        });\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ConstantValueAttribute.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code Deprecated} attribute {@jvms 4.7.15}, which can appear on\n+ * classes, methods, and fields.  Delivered as a  {@link ClassElement},\n+ * {@link MethodElement}, or  {@link FieldElement} when traversing the elements\n+ * of a corresponding model.\n+ *\/\n+public sealed interface DeprecatedAttribute\n+        extends Attribute<DeprecatedAttribute>,\n+                ClassElement, MethodElement, FieldElement\n+        permits BoundAttribute.BoundDeprecatedAttribute,\n+                UnboundAttribute.UnboundDeprecatedAttribute {\n+\n+    \/**\n+     * {@return a {@code Deprecated} attribute}\n+     *\/\n+    static DeprecatedAttribute of() {\n+        return new UnboundAttribute.UnboundDeprecatedAttribute();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/DeprecatedAttribute.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code EnclosingMethod} attribute {@jvms 4.7.7}, which can appear\n+ * on classes, and indicates that the class is a local or anonymous class.\n+ * Delivered as a {@link ClassElement} when traversing the elements of a {@link\n+ * jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface EnclosingMethodAttribute\n+        extends Attribute<EnclosingMethodAttribute>, ClassElement\n+        permits BoundAttribute.BoundEnclosingMethodAttribute,\n+                UnboundAttribute.UnboundEnclosingMethodAttribute {\n+\n+    \/**\n+     * {@return the innermost class that encloses the declaration of the current\n+     * class}\n+     *\/\n+    ClassEntry enclosingClass();\n+\n+    \/**\n+     * {@return the name and type of the enclosing method, if the class is\n+     * immediately enclosed by a method or constructor}\n+     *\/\n+    Optional<NameAndTypeEntry> enclosingMethod();\n+\n+    \/**\n+     * {@return the name of the enclosing method, if the class is\n+     * immediately enclosed by a method or constructor}\n+     *\/\n+    default Optional<Utf8Entry> enclosingMethodName() {\n+        return enclosingMethod().map(NameAndTypeEntry::name);\n+    }\n+\n+    \/**\n+     * {@return the type of the enclosing method, if the class is\n+     * immediately enclosed by a method or constructor}\n+     *\/\n+    default Optional<Utf8Entry> enclosingMethodType() {\n+        return enclosingMethod().map(NameAndTypeEntry::type);\n+    }\n+\n+    \/**\n+     * {@return the type of the enclosing method, if the class is\n+     * immediately enclosed by a method or constructor}\n+     *\/\n+    default Optional<MethodTypeDesc> enclosingMethodTypeSymbol() {\n+        return enclosingMethodType().map(n -> MethodTypeDesc.ofDescriptor(n.stringValue()));\n+    }\n+\n+    \/**\n+     * {@return an {@code EnclosingMethod} attribute}\n+     * @param className the class name\n+     * @param method the name and type of the enclosing method\n+     *\/\n+    static EnclosingMethodAttribute of(ClassEntry className,\n+                                       Optional<NameAndTypeEntry> method) {\n+        return new UnboundAttribute.UnboundEnclosingMethodAttribute(className, method.orElse(null));\n+    }\n+\n+    \/**\n+     * {@return an {@code EnclosingMethod} attribute}\n+     * @param className the class name\n+     * @param methodName the name of the enclosing method\n+     * @param methodType the type of the enclosing method\n+     *\/\n+    static EnclosingMethodAttribute of(ClassDesc className,\n+                                       Optional<String> methodName,\n+                                       Optional<MethodTypeDesc> methodType) {\n+        return new UnboundAttribute.UnboundEnclosingMethodAttribute(\n+                        TemporaryConstantPool.INSTANCE.classEntry(className),\n+                        methodName.isPresent() && methodType.isPresent()\n+                                ? TemporaryConstantPool.INSTANCE.natEntry(methodName.get(), methodType.get())\n+                                : null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the {@code Exceptions} attribute {@jvms 4.7.5}, which can appear on\n+ * methods, and records the exceptions declared to be thrown by this method.\n+ * Delivered as a {@link MethodElement} when traversing the elements of a\n+ * {@link jdk.internal.classfile.MethodModel}.\n+ *\/\n+public sealed interface ExceptionsAttribute\n+        extends Attribute<ExceptionsAttribute>, MethodElement\n+        permits BoundAttribute.BoundExceptionsAttribute,\n+                UnboundAttribute.UnboundExceptionsAttribute {\n+\n+    \/**\n+     * {@return the exceptions declared to be thrown by this method}\n+     *\/\n+    List<ClassEntry> exceptions();\n+\n+    \/**\n+     * {@return an {@code Exceptions} attribute}\n+     * @param exceptions the checked exceptions that may be thrown from this method\n+     *\/\n+    static ExceptionsAttribute of(List<ClassEntry> exceptions) {\n+        return new UnboundAttribute.UnboundExceptionsAttribute(exceptions);\n+    }\n+\n+    \/**\n+     * {@return an {@code Exceptions} attribute}\n+     * @param exceptions the checked exceptions that may be thrown from this method\n+     *\/\n+    static ExceptionsAttribute of(ClassEntry... exceptions) {\n+        return of(List.of(exceptions));\n+    }\n+\n+    \/**\n+     * {@return an {@code Exceptions} attribute}\n+     * @param exceptions the checked exceptions that may be thrown from this method\n+     *\/\n+    static ExceptionsAttribute ofSymbols(List<ClassDesc> exceptions) {\n+        return of(Util.entryList(exceptions));\n+    }\n+\n+    \/**\n+     * {@return an {@code Exceptions} attribute}\n+     * @param exceptions the checked exceptions that may be thrown from this method\n+     *\/\n+    static ExceptionsAttribute ofSymbols(ClassDesc... exceptions) {\n+        return ofSymbols(Arrays.asList(exceptions));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ExceptionsAttribute.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.AccessFlag;\n+\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a single inner class in the {@link InnerClassesAttribute}.\n+ *\/\n+public sealed interface InnerClassInfo\n+        permits UnboundAttribute.UnboundInnerClassInfo {\n+\n+    \/**\n+     * {@return the class described by this inner class description}\n+     *\/\n+    ClassEntry innerClass();\n+\n+    \/**\n+     * {@return the class or interface of which this class is a member, if it is a\n+     * member of a class or interface}\n+     *\/\n+    Optional<ClassEntry> outerClass();\n+\n+    \/**\n+     * {@return the name of the class or interface of which this class is a\n+     * member, if it is a member of a class or interface}\n+     *\/\n+    Optional<Utf8Entry> innerName();\n+\n+    \/**\n+     * {@return a bit mask of flags denoting access permissions and properties\n+     * of the inner class}\n+     *\/\n+    int flagsMask();\n+\n+    \/**\n+     * {@return a set of flag enums denoting access permissions and properties\n+     * of the inner class}\n+     *\/\n+    default Set<AccessFlag> flags() {\n+        return AccessFlag.maskToAccessFlags(flagsMask(), AccessFlag.Location.INNER_CLASS);\n+    }\n+\n+    \/**\n+     * {@return whether a specific access flag is set}\n+     * @param flag the access flag\n+     *\/\n+    default boolean has(AccessFlag flag) {\n+        return Util.has(AccessFlag.Location.INNER_CLASS, flagsMask(), flag);\n+    }\n+\n+    \/**\n+     * {@return an inner class description}\n+     * @param innerClass the inner class being described\n+     * @param outerClass the class containing the inner class, if any\n+     * @param innerName the name of the inner class, if it is not anonymous\n+     * @param flags the inner class access flags\n+     *\/\n+    static InnerClassInfo of(ClassEntry innerClass, Optional<ClassEntry> outerClass,\n+                             Optional<Utf8Entry> innerName, int flags) {\n+        return new UnboundAttribute.UnboundInnerClassInfo(innerClass, outerClass, innerName, flags);\n+    }\n+\n+    \/**\n+     * {@return an inner class description}\n+     * @param innerClass the inner class being described\n+     * @param outerClass the class containing the inner class, if any\n+     * @param innerName the name of the inner class, if it is not anonymous\n+     * @param flags the inner class access flags\n+     *\/\n+    static InnerClassInfo of(ClassDesc innerClass, Optional<ClassDesc> outerClass, Optional<String> innerName, int flags) {\n+        return new UnboundAttribute.UnboundInnerClassInfo(TemporaryConstantPool.INSTANCE.classEntry(innerClass),\n+                                                          outerClass.map(TemporaryConstantPool.INSTANCE::classEntry),\n+                                                          innerName.map(TemporaryConstantPool.INSTANCE::utf8Entry),\n+                                                          flags);\n+    }\n+\n+    \/**\n+     * {@return an inner class description}\n+     * @param innerClass the inner class being described\n+     * @param outerClass the class containing the inner class, if any\n+     * @param innerName the name of the inner class, if it is not anonymous\n+     * @param flags the inner class access flags\n+     *\/\n+    static InnerClassInfo of(ClassDesc innerClass, Optional<ClassDesc> outerClass, Optional<String> innerName, AccessFlag... flags) {\n+        return of(innerClass, outerClass, innerName, Util.flagsToBits(AccessFlag.Location.INNER_CLASS, flags));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/InnerClassInfo.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code InnerClasses} attribute {@jvms 4.7.6}, which can\n+ * appear on classes, and records which classes referenced by this classfile\n+ * are inner classes. Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface InnerClassesAttribute\n+        extends Attribute<InnerClassesAttribute>, ClassElement\n+        permits BoundAttribute.BoundInnerClassesAttribute,\n+                UnboundAttribute.UnboundInnerClassesAttribute {\n+\n+    \/**\n+     * {@return the inner classes used by this class}\n+     *\/\n+    List<InnerClassInfo> classes();\n+\n+    \/**\n+     * {@return an {@code InnerClasses} attribute}\n+     * @param innerClasses descriptions of the inner classes\n+     *\/\n+    static InnerClassesAttribute of(List<InnerClassInfo> innerClasses) {\n+        return new UnboundAttribute.UnboundInnerClassesAttribute(innerClasses);\n+    }\n+\n+    \/**\n+     * {@return an {@code InnerClasses} attribute}\n+     * @param innerClasses descriptions of the inner classes\n+     *\/\n+    static InnerClassesAttribute of(InnerClassInfo... innerClasses) {\n+        return new UnboundAttribute.UnboundInnerClassesAttribute(List.of(innerClasses));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/InnerClassesAttribute.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a single line number in the {@link LineNumberTableAttribute}.\n+ *\/\n+public sealed interface LineNumberInfo\n+        permits UnboundAttribute.UnboundLineNumberInfo {\n+\n+    \/**\n+     * {@return the index into the code array at which the code for this line\n+     * begins}\n+     *\/\n+    int startPc();\n+\n+    \/**\n+     * {@return the line number within the original source file}\n+     *\/\n+    int lineNumber();\n+\n+    \/**\n+     * {@return a line number description}\n+     * @param startPc the starting index of the code array for this line\n+     * @param lineNumber the line number within the original source file\n+     *\/\n+    public static LineNumberInfo of(int startPc, int lineNumber) {\n+        return new UnboundAttribute.UnboundLineNumberInfo(startPc, lineNumber);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LineNumberInfo.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code LineNumberTable} attribute {@jvms 4.7.12}, which can appear\n+ * on a {@code Code} attribute, and records the mapping between indexes into\n+ * the code table and line numbers in the source file.\n+ * Delivered as a {@link jdk.internal.classfile.instruction.LineNumber} when traversing the\n+ * elements of a {@link jdk.internal.classfile.CodeModel}, according to the setting of the\n+ * {@link jdk.internal.classfile.Classfile.Option#processLineNumbers(boolean)} option.\n+ *\/\n+public sealed interface LineNumberTableAttribute\n+        extends Attribute<LineNumberTableAttribute>\n+        permits BoundAttribute.BoundLineNumberTableAttribute,\n+                UnboundAttribute.UnboundLineNumberTableAttribute {\n+\n+    \/**\n+     * {@return the table mapping bytecode offsets to source line numbers}\n+     *\/\n+    List<LineNumberInfo> lineNumbers();\n+\n+    \/**\n+     * {@return a {@code LineNumberTable} attribute}\n+     * @param lines the line number descriptions\n+     *\/\n+    static LineNumberTableAttribute of(List<LineNumberInfo> lines) {\n+        return new UnboundAttribute.UnboundLineNumberTableAttribute(lines);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LineNumberTableAttribute.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundLocalVariable;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a single local variable in the {@link LocalVariableTableAttribute}.\n+ *\/\n+public sealed interface LocalVariableInfo\n+        permits UnboundAttribute.UnboundLocalVariableInfo, BoundLocalVariable {\n+\n+    \/**\n+     * {@return the index into the code array (inclusive) at which the scope of\n+     * this variable begins}\n+     *\/\n+    int startPc();\n+\n+    \/**\n+     * {@return the length of the region of the code array in which this\n+     * variable is in scope.}\n+     *\/\n+    int length();\n+\n+    \/**\n+     * {@return the name of the local variable}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the field descriptor of the local variable}\n+     *\/\n+    Utf8Entry type();\n+\n+    \/**\n+     * {@return the field descriptor of the local variable}\n+     *\/\n+    default ClassDesc typeSymbol() {\n+        return ClassDesc.ofDescriptor(type().stringValue());\n+    }\n+\n+    \/**\n+     * {@return the index into the local variable array of the current frame\n+     * which holds this local variable}\n+     *\/\n+    int slot();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LocalVariableInfo.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+import java.util.List;\n+\n+\/**\n+ * Models the {@code LocalVariableTable} attribute {@jvms 4.7.13}, which can appear\n+ * on a {@code Code} attribute, and records debug information about local\n+ * variables.\n+ * Delivered as a {@link jdk.internal.classfile.instruction.LocalVariable} when traversing the\n+ * elements of a {@link jdk.internal.classfile.CodeModel}, according to the setting of the\n+ * {@link jdk.internal.classfile.Classfile.Option#processDebug(boolean)} option.\n+ *\/\n+public sealed interface LocalVariableTableAttribute\n+        extends Attribute<LocalVariableTableAttribute>\n+        permits BoundAttribute.BoundLocalVariableTableAttribute, UnboundAttribute.UnboundLocalVariableTableAttribute {\n+\n+    \/**\n+     * {@return debug information for the local variables in this method}\n+     *\/\n+    List<LocalVariableInfo> localVariables();\n+\n+    \/**\n+     * {@return a {@code LocalVariableTable} attribute}\n+     * @param locals the local variable descriptions\n+     *\/\n+    static LocalVariableTableAttribute of(List<LocalVariableInfo> locals) {\n+        return new UnboundAttribute.UnboundLocalVariableTableAttribute(locals);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundLocalVariableType;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a single local variable in the {@link LocalVariableTypeTableAttribute}.\n+ *\/\n+public sealed interface LocalVariableTypeInfo\n+        permits UnboundAttribute.UnboundLocalVariableTypeInfo, BoundLocalVariableType {\n+\n+    \/**\n+     * {@return the index into the code array (inclusive) at which the scope of\n+     * this variable begins}\n+     *\/\n+    int startPc();\n+\n+    \/**\n+     * {@return the length of the region of the code array in which this\n+     * variable is in scope.}\n+     *\/\n+    int length();\n+\n+    \/**\n+     * {@return the name of the local variable}\n+     *\/\n+    Utf8Entry name();\n+\n+\n+    \/**\n+     * {@return the field signature of the local variable}\n+     *\/\n+    Utf8Entry signature();\n+\n+    \/**\n+     * {@return the index into the local variable array of the current frame\n+     * which holds this local variable}\n+     *\/\n+    int slot();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LocalVariableTypeInfo.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+import java.util.List;\n+\n+\/**\n+ * Models the {@code LocalVariableTypeTable} attribute {@jvms 4.7.14}, which can appear\n+ * on a {@code Code} attribute, and records debug information about local\n+ * variables.\n+ * Delivered as a {@link jdk.internal.classfile.instruction.LocalVariable} when traversing the\n+ * elements of a {@link jdk.internal.classfile.CodeModel}, according to the setting of the\n+ * {@link jdk.internal.classfile.Classfile.Option#processLineNumbers(boolean)} option.\n+ *\/\n+public sealed interface LocalVariableTypeTableAttribute\n+        extends Attribute<LocalVariableTypeTableAttribute>\n+        permits BoundAttribute.BoundLocalVariableTypeTableAttribute, UnboundAttribute.UnboundLocalVariableTypeTableAttribute {\n+\n+    \/**\n+     * {@return debug information for the local variables in this method}\n+     *\/\n+    List<LocalVariableTypeInfo> localVariableTypes();\n+\n+    \/**\n+     * {@return a {@code LocalVariableTypeTable} attribute}\n+     * @param locals the local variable descriptions\n+     *\/\n+    static LocalVariableTypeTableAttribute of(List<LocalVariableTypeInfo> locals) {\n+        return new UnboundAttribute.UnboundLocalVariableTypeTableAttribute(locals);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a single method parameter in the {@link MethodParametersAttribute}.\n+ *\/\n+public sealed interface MethodParameterInfo\n+        permits UnboundAttribute.UnboundMethodParameterInfo {\n+    \/**\n+     * The name of the method parameter, if there is one.\n+     *\n+     * @return the parameter name, if it has one\n+     *\/\n+    Optional<Utf8Entry> name();\n+\n+    \/**\n+     * Parameter access flags for this parameter, as a bit mask.  Valid\n+     * parameter flags include {@link Classfile#ACC_FINAL},\n+     * {@link Classfile#ACC_SYNTHETIC}, and {@link Classfile#ACC_MANDATED}.\n+     *\n+     * @return the access flags, as a bit mask\n+     *\/\n+    int flagsMask();\n+\n+    \/**\n+     * Parameter access flags for this parameter.\n+     *\n+     * @return the access flags, as a bit mask\n+     *\/\n+    default Set<AccessFlag> flags() {\n+        return AccessFlag.maskToAccessFlags(flagsMask(), AccessFlag.Location.METHOD_PARAMETER);\n+    }\n+\n+    \/**\n+     * {@return whether the method parameter has a specific flag set}\n+     * @param flag the method parameter flag\n+     *\/\n+    default boolean has(AccessFlag flag) {\n+        return Util.has(AccessFlag.Location.METHOD_PARAMETER, flagsMask(), flag);\n+    }\n+\n+    \/**\n+     * {@return a method parameter description}\n+     * @param name the method parameter name\n+     * @param flags the method parameter access flags\n+     *\/\n+    static MethodParameterInfo of(Optional<Utf8Entry> name, int flags) {\n+        return new UnboundAttribute.UnboundMethodParameterInfo(name, flags);\n+    }\n+\n+    \/**\n+     * {@return a method parameter description}\n+     * @param name the method parameter name\n+     * @param flags the method parameter access flags\n+     *\/\n+    static MethodParameterInfo of(Optional<String> name, AccessFlag... flags) {\n+        return of(name.map(TemporaryConstantPool.INSTANCE::utf8Entry), Util.flagsToBits(AccessFlag.Location.METHOD_PARAMETER, flags));\n+    }\n+\n+    \/**\n+     * {@return a method parameter description}\n+     * @param name the method parameter name\n+     * @param flags the method parameter access flags\n+     *\/\n+    static MethodParameterInfo ofParameter(Optional<String> name, int flags) {\n+        return of(name.map(TemporaryConstantPool.INSTANCE::utf8Entry), flags);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/MethodParameterInfo.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code MethodParameters} attribute {@jvms 4.7.24}, which can\n+ * appear on methods, and records optional information about the method's\n+ * parameters.  Delivered as a {@link jdk.internal.classfile.MethodElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.MethodModel}.\n+ *\/\n+public sealed interface MethodParametersAttribute\n+        extends Attribute<MethodParametersAttribute>, MethodElement\n+        permits BoundAttribute.BoundMethodParametersAttribute,\n+                UnboundAttribute.UnboundMethodParametersAttribute {\n+\n+    \/**\n+     * {@return information about the parameters of the method}  The i'th entry\n+     * in the list correponds to the i'th parameter in the method declaration.\n+     *\/\n+    List<MethodParameterInfo> parameters();\n+\n+    \/**\n+     * {@return a {@code MethodParameters} attribute}\n+     * @param parameters the method parameter descriptions\n+     *\/\n+    static MethodParametersAttribute of(List<MethodParameterInfo> parameters) {\n+        return new UnboundAttribute.UnboundMethodParametersAttribute(parameters);\n+    }\n+\n+    \/**\n+     * {@return a {@code MethodParameters} attribute}\n+     * @param parameters the method parameter descriptions\n+     *\/\n+    static MethodParametersAttribute of(MethodParameterInfo... parameters) {\n+        return of(List.of(parameters));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/MethodParametersAttribute.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Collection;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import jdk.internal.classfile.impl.ModuleAttributeBuilderImpl;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the {@code Module} attribute {@jvms 4.7.25}, which can\n+ * appear on classes that represent module descriptors.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+\n+public sealed interface ModuleAttribute\n+        extends Attribute<ModuleAttribute>, ClassElement\n+        permits BoundAttribute.BoundModuleAttribute, UnboundAttribute.UnboundModuleAttribute {\n+\n+    \/**\n+     * {@return the name of the module}\n+     *\/\n+    ModuleEntry moduleName();\n+\n+    \/**\n+     * {@return the the module flags of the module, as a bit mask}\n+     *\/\n+    int moduleFlagsMask();\n+\n+    \/**\n+     * {@return the the module flags of the module, as a set of enum constants}\n+     *\/\n+    default Set<AccessFlag> moduleFlags() {\n+        return AccessFlag.maskToAccessFlags(moduleFlagsMask(), AccessFlag.Location.MODULE);\n+    }\n+\n+    default boolean has(AccessFlag flag) {\n+        return Util.has(AccessFlag.Location.MODULE, moduleFlagsMask(), flag);\n+    }\n+\n+    \/**\n+     * {@return version of the module, if present}\n+     *\/\n+    Optional<Utf8Entry> moduleVersion();\n+\n+    \/**\n+     * {@return the modules required by this module}\n+     *\/\n+    List<ModuleRequireInfo> requires();\n+\n+    \/**\n+     * {@return the packages exported by this module}\n+     *\/\n+    List<ModuleExportInfo> exports();\n+\n+    \/**\n+     * {@return the packages opened by this module}\n+     *\/\n+    List<ModuleOpenInfo> opens();\n+\n+    \/**\n+     * {@return the services used by this module}  Services may be discovered via\n+     * {@link java.util.ServiceLoader}.\n+     *\/\n+    List<ClassEntry> uses();\n+\n+    \/**\n+     * {@return the service implementations provided by this module}\n+     *\/\n+    List<ModuleProvideInfo> provides();\n+\n+    \/**\n+     * {@return a {@code Module} attribute}\n+     *\n+     * @param moduleName the module name\n+     * @param moduleFlags the module flags\n+     * @param moduleVersion the module version\n+     * @param requires the required packages\n+     * @param exports the exported packages\n+     * @param opens the opened packages\n+     * @param uses the consumed services\n+     * @param provides the provided services\n+     *\/\n+    static ModuleAttribute of(ModuleEntry moduleName, int moduleFlags,\n+                              Utf8Entry moduleVersion,\n+                              Collection<ModuleRequireInfo> requires,\n+                              Collection<ModuleExportInfo> exports,\n+                              Collection<ModuleOpenInfo> opens,\n+                              Collection<ClassEntry> uses,\n+                              Collection<ModuleProvideInfo> provides) {\n+        return new UnboundAttribute.UnboundModuleAttribute(moduleName, moduleFlags, moduleVersion, requires, exports, opens, uses, provides);\n+    }\n+\n+    \/**\n+     * {@return a {@code Module} attribute}\n+     *\n+     * @param moduleName the module name\n+     * @param attrHandler a handler that receives a {@link ModuleAttributeBuilder}\n+     *\/\n+    static ModuleAttribute of(ModuleDesc moduleName,\n+                              Consumer<ModuleAttributeBuilder> attrHandler) {\n+        var mb = new ModuleAttributeBuilderImpl(moduleName);\n+        attrHandler.accept(mb);\n+        return  mb.build();\n+    }\n+\n+    public sealed interface ModuleAttributeBuilder\n+            permits ModuleAttributeBuilderImpl {\n+\n+        ModuleAttributeBuilder moduleName(ModuleDesc moduleName);\n+        ModuleAttributeBuilder moduleFlags(int flagsMask);\n+        default ModuleAttributeBuilder moduleFlags(AccessFlag... moduleFlags) {\n+            return moduleFlags(Util.flagsToBits(AccessFlag.Location.MODULE, moduleFlags));\n+        }\n+        ModuleAttributeBuilder moduleVersion(String version);\n+\n+        ModuleAttributeBuilder requires(ModuleDesc module, int requiresFlagsMask, String version);\n+        default ModuleAttributeBuilder requires(ModuleDesc module, Collection<AccessFlag> requiresFlags, String version) {\n+            return requires(module, Util.flagsToBits(AccessFlag.Location.MODULE_REQUIRES, requiresFlags), version);\n+        }\n+        ModuleAttributeBuilder requires(ModuleRequireInfo requires);\n+\n+        ModuleAttributeBuilder exports(PackageDesc pkge, int exportsFlagsMask, ModuleDesc... exportsToModules);\n+        default ModuleAttributeBuilder exports(PackageDesc pkge, Collection<AccessFlag> exportsFlags, ModuleDesc... exportsToModules) {\n+            return exports(pkge, Util.flagsToBits(AccessFlag.Location.MODULE_EXPORTS, exportsFlags), exportsToModules);\n+        }\n+        ModuleAttributeBuilder exports(ModuleExportInfo exports);\n+\n+        ModuleAttributeBuilder opens(PackageDesc pkge, int opensFlagsMask, ModuleDesc... opensToModules);\n+        default ModuleAttributeBuilder opens(PackageDesc pkge, Collection<AccessFlag> opensFlags, ModuleDesc... opensToModules) {\n+            return opens(pkge, Util.flagsToBits(AccessFlag.Location.MODULE_OPENS, opensFlags), opensToModules);\n+        }\n+        ModuleAttributeBuilder opens(ModuleOpenInfo opens);\n+\n+        ModuleAttributeBuilder uses(ClassDesc service);\n+        ModuleAttributeBuilder uses(ClassEntry uses);\n+\n+        ModuleAttributeBuilder provides(ClassDesc service, ClassDesc... implClasses);\n+        ModuleAttributeBuilder provides(ModuleProvideInfo provides);\n+\n+        ModuleAttribute build();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleAttribute.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import java.lang.reflect.AccessFlag;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a single \"exports\" declaration in the {@link jdk.internal.classfile.attribute.ModuleAttribute}.\n+ *\/\n+public sealed interface ModuleExportInfo\n+        permits UnboundAttribute.UnboundModuleExportInfo {\n+\n+    \/**\n+     * {@return the exported package}\n+     *\/\n+    PackageEntry exportedPackage();\n+\n+    \/**\n+     * {@return the flags associated with this export declaration, as a bit mask}\n+     * Valid flags include {@link Classfile#ACC_SYNTHETIC} and\n+     * {@link Classfile#ACC_MANDATED}.\n+     *\/\n+    int exportsFlagsMask();\n+\n+    \/**\n+     * {@return the flags associated with this export declaration, as a set of\n+     * flag values}\n+     *\/\n+    default Set<AccessFlag> exportsFlags() {\n+        return AccessFlag.maskToAccessFlags(exportsFlagsMask(), AccessFlag.Location.MODULE_EXPORTS);\n+    }\n+\n+    \/**\n+     * {@return the list of modules to which this package is exported, if it is a\n+     * qualified export}\n+     *\/\n+    List<ModuleEntry> exportsTo();\n+\n+    \/**\n+     * {@return whether the module has the specified access flag set}\n+     * @param flag the access flag\n+     *\/\n+    default boolean has(AccessFlag flag) {\n+        return Util.has(AccessFlag.Location.MODULE_EXPORTS, exportsFlagsMask(), flag);\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags, as a bitmask\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageEntry exports, int exportFlags,\n+                               List<ModuleEntry> exportsTo) {\n+        return new UnboundAttribute.UnboundModuleExportInfo(exports, exportFlags, exportsTo);\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageEntry exports, Collection<AccessFlag> exportFlags,\n+                               List<ModuleEntry> exportsTo) {\n+        return of(exports, Util.flagsToBits(AccessFlag.Location.MODULE_EXPORTS, exportFlags), exportsTo);\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags, as a bitmask\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageEntry exports,\n+                               int exportFlags,\n+                               ModuleEntry... exportsTo) {\n+        return of(exports, exportFlags, List.of(exportsTo));\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageEntry exports,\n+                               Collection<AccessFlag> exportFlags,\n+                               ModuleEntry... exportsTo) {\n+        return of(exports, Util.flagsToBits(AccessFlag.Location.MODULE_EXPORTS, exportFlags), exportsTo);\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags, as a bitmask\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageDesc exports, int exportFlags,\n+                               List<ModuleDesc> exportsTo) {\n+        return of(TemporaryConstantPool.INSTANCE.packageEntry(TemporaryConstantPool.INSTANCE.utf8Entry(exports.packageInternalName())),\n+                exportFlags,\n+                Util.moduleEntryList(exportsTo));\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageDesc exports, Collection<AccessFlag> exportFlags,\n+                               List<ModuleDesc> exportsTo) {\n+        return of(exports, Util.flagsToBits(AccessFlag.Location.MODULE_EXPORTS, exportFlags), exportsTo);\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags, as a bitmask\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageDesc exports,\n+                               int exportFlags,\n+                               ModuleDesc... exportsTo) {\n+        return of(exports, exportFlags, List.of(exportsTo));\n+    }\n+\n+    \/**\n+     * {@return a module export description}\n+     * @param exports the exported package\n+     * @param exportFlags the export flags\n+     * @param exportsTo the modules to which this package is exported\n+     *\/\n+    static ModuleExportInfo of(PackageDesc exports,\n+                               Collection<AccessFlag> exportFlags,\n+                               ModuleDesc... exportsTo) {\n+        return of(exports, Util.flagsToBits(AccessFlag.Location.MODULE_EXPORTS, exportFlags), exportsTo);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleExportInfo.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models hash information for a single module in the {@link jdk.internal.classfile.attribute.ModuleHashesAttribute}.\n+ *\/\n+public sealed interface ModuleHashInfo\n+        permits UnboundAttribute.UnboundModuleHashInfo {\n+\n+    \/**\n+     * {@return the name of the related module}\n+     *\/\n+    ModuleEntry moduleName();\n+\n+    \/**\n+     * {@return the hash of the related module}\n+     *\/\n+    byte[] hash();\n+\n+    \/**\n+     * {@return a module hash description}\n+     * @param moduleName the module name\n+     * @param hash the hash value\n+     *\/\n+    static ModuleHashInfo of(ModuleEntry moduleName, byte[] hash) {\n+        return new UnboundAttribute.UnboundModuleHashInfo(moduleName, hash);\n+    }\n+\n+    \/**\n+     * {@return a module hash description}\n+     * @param moduleDesc the module name\n+     * @param hash the hash value\n+     *\/\n+    static ModuleHashInfo of(ModuleDesc moduleDesc, byte[] hash) {\n+        return new UnboundAttribute.UnboundModuleHashInfo(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleDesc.moduleName())), hash);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleHashInfo.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code ModuleHashes} attribute, which can\n+ * appear on classes that represent module descriptors.  This is a JDK-specific\n+ * attribute, which captures the hashes of a set of co-delivered modules.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\n+ *  <p>The specification of the {@code ModuleHashes} attribute is:\n+ * <pre> {@code\n+ *\n+ * ModuleHashes_attribute {\n+ *   \/\/ index to CONSTANT_utf8_info structure in constant pool representing\n+ *   \/\/ the string \"ModuleHashes\"\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *\n+ *   \/\/ index to CONSTANT_utf8_info structure with algorithm name\n+ *   u2 algorithm_index;\n+ *\n+ *   \/\/ the number of entries in the hashes table\n+ *   u2 hashes_count;\n+ *   {   u2 module_name_index (index to CONSTANT_Module_info structure)\n+ *       u2 hash_length;\n+ *       u1 hash[hash_length];\n+ *   } hashes[hashes_count];\n+ *\n+ * }\n+ * } <\/pre>\n+ *\/\n+public sealed interface ModuleHashesAttribute\n+        extends Attribute<ModuleHashesAttribute>, ClassElement\n+        permits BoundAttribute.BoundModuleHashesAttribute, UnboundAttribute.UnboundModuleHashesAttribute {\n+\n+    \/**\n+     * {@return the algorithm name used to compute the hash}\n+     *\/\n+    Utf8Entry algorithm();\n+\n+    \/**\n+     * {@return the hash information about related modules}\n+     *\/\n+    List<ModuleHashInfo> hashes();\n+\n+    \/**\n+     * {@return a {@code ModuleHashes} attribute}\n+     * @param algorithm the hashing algorithm\n+     * @param hashes the hash descriptions\n+     *\/\n+    static ModuleHashesAttribute of(String algorithm,\n+                                    List<ModuleHashInfo> hashes) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(algorithm), hashes);\n+    }\n+\n+    \/**\n+     * {@return a {@code ModuleHashes} attribute}\n+     * @param algorithm the hashing algorithm\n+     * @param hashes the hash descriptions\n+     *\/\n+    static ModuleHashesAttribute of(String algorithm,\n+                                    ModuleHashInfo... hashes) {\n+        return of(algorithm, List.of(hashes));\n+    }\n+\n+    \/**\n+     * {@return a {@code ModuleHashes} attribute}\n+     * @param algorithm the hashing algorithm\n+     * @param hashes the hash descriptions\n+     *\/\n+    static ModuleHashesAttribute of(Utf8Entry algorithm,\n+                                    List<ModuleHashInfo> hashes) {\n+        return new UnboundAttribute.UnboundModuleHashesAttribute(algorithm, hashes);\n+    }\n+\n+    \/**\n+     * {@return a {@code ModuleHashes} attribute}\n+     * @param algorithm the hashing algorithm\n+     * @param hashes the hash descriptions\n+     *\/\n+    static ModuleHashesAttribute of(Utf8Entry algorithm,\n+                                    ModuleHashInfo... hashes) {\n+        return of(algorithm, List.of(hashes));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleHashesAttribute.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the {@code ModuleMainClass} attribute {@jvms 4.7.27}, which can\n+ * appear on classes that represent module descriptors.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface ModuleMainClassAttribute\n+        extends Attribute<ModuleMainClassAttribute>, ClassElement\n+        permits BoundAttribute.BoundModuleMainClassAttribute, UnboundAttribute.UnboundModuleMainClassAttribute {\n+\n+    \/**\n+     * {@return main class for this module}\n+     *\/\n+    ClassEntry mainClass();\n+\n+    \/**\n+     * {@return a {@code ModuleMainClass} attribute}\n+     * @param mainClass the main class\n+     *\/\n+    static ModuleMainClassAttribute of(ClassEntry mainClass) {\n+        return new UnboundAttribute.UnboundModuleMainClassAttribute(mainClass);\n+    }\n+\n+    \/**\n+     * {@return a {@code ModuleMainClass} attribute}\n+     * @param mainClass the main class\n+     *\/\n+    static ModuleMainClassAttribute of(ClassDesc mainClass) {\n+        return new UnboundAttribute.UnboundModuleMainClassAttribute(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(mainClass))));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleMainClassAttribute.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import java.lang.reflect.AccessFlag;\n+\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a single \"opens\" declaration in the {@link jdk.internal.classfile.attribute.ModuleAttribute}.\n+ *\/\n+public sealed interface ModuleOpenInfo\n+        permits UnboundAttribute.UnboundModuleOpenInfo {\n+\n+    \/**\n+     * {@return the package being opened}\n+     *\/\n+    PackageEntry openedPackage();\n+\n+    \/**\n+     * {@return the flags associated with this open declaration, as a bit mask}\n+     * Valid flags include {@link jdk.internal.classfile.Classfile#ACC_SYNTHETIC} and\n+     * {@link jdk.internal.classfile.Classfile#ACC_MANDATED}\n+     *\/\n+    int opensFlagsMask();\n+\n+    default Set<AccessFlag> opensFlags() {\n+        return AccessFlag.maskToAccessFlags(opensFlagsMask(), AccessFlag.Location.MODULE_OPENS);\n+    }\n+\n+    \/**\n+     * {@return whether the specified access flag is set}\n+     * @param flag the access flag\n+     *\/\n+    default boolean has(AccessFlag flag) {\n+        return Util.has(AccessFlag.Location.MODULE_OPENS, opensFlagsMask(), flag);\n+    }\n+\n+    \/**\n+     * The list of modules to which this package is opened, if it is a\n+     * qualified open.\n+     *\n+     * @return the modules to which this package is opened\n+     *\/\n+    List<ModuleEntry> opensTo();\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageEntry opens, int opensFlags,\n+                             List<ModuleEntry> opensTo) {\n+        return new UnboundAttribute.UnboundModuleOpenInfo(opens, opensFlags, opensTo);\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageEntry opens, Collection<AccessFlag> opensFlags,\n+                             List<ModuleEntry> opensTo) {\n+        return of(opens, Util.flagsToBits(AccessFlag.Location.MODULE_OPENS, opensFlags), opensTo);\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageEntry opens,\n+                             int opensFlags,\n+                             ModuleEntry... opensTo) {\n+        return of(opens, opensFlags, List.of(opensTo));\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageEntry opens,\n+                             Collection<AccessFlag> opensFlags,\n+                             ModuleEntry... opensTo) {\n+        return of(opens, Util.flagsToBits(AccessFlag.Location.MODULE_OPENS, opensFlags), opensTo);\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageDesc opens, int opensFlags,\n+                             List<ModuleDesc> opensTo) {\n+        return of(TemporaryConstantPool.INSTANCE.packageEntry(TemporaryConstantPool.INSTANCE.utf8Entry(opens.packageInternalName())),\n+                opensFlags,\n+                Util.moduleEntryList(opensTo));\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageDesc opens, Collection<AccessFlag> opensFlags,\n+                             List<ModuleDesc> opensTo) {\n+        return of(opens, Util.flagsToBits(AccessFlag.Location.MODULE_OPENS, opensFlags), opensTo);\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageDesc opens,\n+                             int opensFlags,\n+                             ModuleDesc... opensTo) {\n+        return of(opens, opensFlags, List.of(opensTo));\n+    }\n+\n+    \/**\n+     * {@return a module open description}\n+     * @param opens the package to open\n+     * @param opensFlags the open flags\n+     * @param opensTo the packages to which this package is opened, if it is a qualified open\n+     *\/\n+    static ModuleOpenInfo of(PackageDesc opens,\n+                             Collection<AccessFlag> opensFlags,\n+                             ModuleDesc... opensTo) {\n+        return of(opens, Util.flagsToBits(AccessFlag.Location.MODULE_OPENS, opensFlags), opensTo);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleOpenInfo.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code ModulePackages} attribute {@jvms 4.7.26}, which can\n+ * appear on classes that represent module descriptors.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface ModulePackagesAttribute\n+        extends Attribute<ModulePackagesAttribute>, ClassElement\n+        permits BoundAttribute.BoundModulePackagesAttribute,\n+                UnboundAttribute.UnboundModulePackagesAttribute {\n+\n+    \/**\n+     * {@return the packages that are opened or exported by this module}\n+     *\/\n+    List<PackageEntry> packages();\n+\n+    \/**\n+     * {@return a {@code ModulePackages} attribute}\n+     * @param packages the packages\n+     *\/\n+    static ModulePackagesAttribute of(List<PackageEntry> packages) {\n+        return new UnboundAttribute.UnboundModulePackagesAttribute(packages);\n+    }\n+\n+    \/**\n+     * {@return a {@code ModulePackages} attribute}\n+     * @param packages the packages\n+     *\/\n+    static ModulePackagesAttribute of(PackageEntry... packages) {\n+        return of(List.of(packages));\n+    }\n+\n+    \/**\n+     * {@return a {@code ModulePackages} attribute}\n+     * @param packages the packages\n+     *\/\n+    static ModulePackagesAttribute ofNames(List<PackageDesc> packages) {\n+        var p = new PackageEntry[packages.size()];\n+        for (int i = 0; i < packages.size(); i++) {\n+            p[i] = TemporaryConstantPool.INSTANCE.packageEntry(TemporaryConstantPool.INSTANCE.utf8Entry(packages.get(i).packageInternalName()));\n+        }\n+        return of(p);\n+    }\n+\n+    \/**\n+     * {@return a {@code ModulePackages} attribute}\n+     * @param packages the packages\n+     *\/\n+    static ModulePackagesAttribute ofNames(PackageDesc... packages) {\n+        \/\/ List view, since ref to packages is temporary\n+        return ofNames(Arrays.asList(packages));\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModulePackagesAttribute.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a single \"provides\" declaration in the {@link jdk.internal.classfile.attribute.ModuleAttribute}.\n+ *\/\n+public sealed interface ModuleProvideInfo\n+        permits UnboundAttribute.UnboundModuleProvideInfo {\n+\n+    \/**\n+     * {@return the service interface representing the provided service}\n+     *\/\n+    ClassEntry provides();\n+\n+    \/**\n+     * {@return the classes providing the service implementation}\n+     *\/\n+    List<ClassEntry> providesWith();\n+\n+    \/**\n+     * {@return a service provision description}\n+     * @param provides the service class interface\n+     * @param providesWith the service class implementations\n+     *\/\n+    static ModuleProvideInfo of(ClassEntry provides,\n+                                List<ClassEntry> providesWith) {\n+        return new UnboundAttribute.UnboundModuleProvideInfo(provides, providesWith);\n+    }\n+\n+    \/**\n+     * {@return a service provision description}\n+     * @param provides the service class interface\n+     * @param providesWith the service class implementations\n+     *\/\n+    static ModuleProvideInfo of(ClassEntry provides,\n+                                ClassEntry... providesWith) {\n+        return of(provides, List.of(providesWith));\n+    }\n+\n+    \/**\n+     * {@return a service provision description}\n+     * @param provides the service class interface\n+     * @param providesWith the service class implementations\n+     *\/\n+    static ModuleProvideInfo of(ClassDesc provides,\n+                                       List<ClassDesc> providesWith) {\n+        return of(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(provides))), Util.entryList(providesWith));\n+    }\n+\n+    \/**\n+     * {@return a service provision description}\n+     * @param provides the service class interface\n+     * @param providesWith the service class implementations\n+     *\/\n+    static ModuleProvideInfo of(ClassDesc provides,\n+                                       ClassDesc... providesWith) {\n+        \/\/ List view, since ref to providesWith is temporary\n+        return of(provides, Arrays.asList(providesWith));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleProvideInfo.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a single \"requires\" declaration in the {@link jdk.internal.classfile.attribute.ModuleAttribute}.\n+ *\/\n+public sealed interface ModuleRequireInfo\n+        permits UnboundAttribute.UnboundModuleRequiresInfo {\n+\n+    \/**\n+     * {@return The module on which the current module depends}\n+     *\/\n+    ModuleEntry requires();\n+\n+    \/**\n+     * {@return the flags associated with this require declaration, as a bit mask}\n+     * Valid flags include {@link jdk.internal.classfile.Classfile#ACC_TRANSITIVE},\n+     * {@link jdk.internal.classfile.Classfile#ACC_STATIC_PHASE},\n+     * {@link jdk.internal.classfile.Classfile#ACC_SYNTHETIC} and\n+     * {@link jdk.internal.classfile.Classfile#ACC_MANDATED}\n+     *\/\n+    int requiresFlagsMask();\n+\n+    default Set<AccessFlag> requiresFlags() {\n+        return AccessFlag.maskToAccessFlags(requiresFlagsMask(), AccessFlag.Location.MODULE_REQUIRES);\n+    }\n+\n+    \/**\n+     * {@return the required version of the required module, if present}\n+     *\/\n+    Optional<Utf8Entry> requiresVersion();\n+\n+    \/**\n+     * {@return whether the specific access flag is set}\n+     * @param flag the access flag\n+     *\/\n+    default boolean has(AccessFlag flag) {\n+        return Util.has(AccessFlag.Location.MODULE_REQUIRES, requiresFlagsMask(), flag);\n+    }\n+\n+    \/**\n+     * {@return a module requirement description}\n+     * @param requires the required module\n+     * @param requiresFlags the require-specific flags\n+     * @param requiresVersion the required version\n+     *\/\n+    static ModuleRequireInfo of(ModuleEntry requires, int requiresFlags, Utf8Entry requiresVersion) {\n+        return new UnboundAttribute.UnboundModuleRequiresInfo(requires, requiresFlags, Optional.ofNullable(requiresVersion));\n+    }\n+\n+    \/**\n+     * {@return a module requirement description}\n+     * @param requires the required module\n+     * @param requiresFlags the require-specific flags\n+     * @param requiresVersion the required version\n+     *\/\n+    static ModuleRequireInfo of(ModuleEntry requires, Collection<AccessFlag> requiresFlags, Utf8Entry requiresVersion) {\n+        return of(requires, Util.flagsToBits(AccessFlag.Location.MODULE_REQUIRES, requiresFlags), requiresVersion);\n+    }\n+\n+    \/**\n+     * {@return a module requirement description}\n+     * @param requires the required module\n+     * @param requiresFlags the require-specific flags\n+     * @param requiresVersion the required version\n+     *\/\n+    static ModuleRequireInfo of(ModuleDesc requires, int requiresFlags, String requiresVersion) {\n+        return new UnboundAttribute.UnboundModuleRequiresInfo(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(requires.moduleName())), requiresFlags, Optional.ofNullable(requiresVersion).map(s -> TemporaryConstantPool.INSTANCE.utf8Entry(s)));\n+    }\n+\n+    \/**\n+     * {@return a module requirement description}\n+     * @param requires the required module\n+     * @param requiresFlags the require-specific flags\n+     * @param requiresVersion the required version\n+     *\/\n+    static ModuleRequireInfo of(ModuleDesc requires, Collection<AccessFlag> requiresFlags, String requiresVersion) {\n+        return of(requires, Util.flagsToBits(AccessFlag.Location.MODULE_REQUIRES, requiresFlags), requiresVersion);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleRequireInfo.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code ModuleResolution} attribute, which can\n+ * appear on classes that represent module descriptors.  This is a JDK-specific\n+ *  * attribute, which captures resolution metadata for modules.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\n+ *  <p>The specification of the {@code ModuleResolution} attribute is:\n+ * <pre> {@code\n+ *  ModuleResolution_attribute {\n+ *    u2 attribute_name_index;    \/\/ \"ModuleResolution\"\n+ *    u4 attribute_length;        \/\/ 2\n+ *    u2 resolution_flags;\n+ *\n+ *  The value of the resolution_flags item is a mask of flags used to denote\n+ *  properties of module resolution. The flags are as follows:\n+ *\n+ *   \/\/ Optional\n+ *   0x0001 (DO_NOT_RESOLVE_BY_DEFAULT)\n+ *\n+ *   \/\/ At most one of:\n+ *   0x0002 (WARN_DEPRECATED)\n+ *   0x0004 (WARN_DEPRECATED_FOR_REMOVAL)\n+ *   0x0008 (WARN_INCUBATING)\n+ *  }\n+ * } <\/pre>\n+ *\/\n+public sealed interface ModuleResolutionAttribute\n+        extends Attribute<ModuleResolutionAttribute>, ClassElement\n+        permits BoundAttribute.BoundModuleResolutionAttribute, UnboundAttribute.UnboundModuleResolutionAttribute {\n+\n+    \/**\n+     *  The value of the resolution_flags item is a mask of flags used to denote\n+     *  properties of module resolution. The flags are as follows:\n+     *\n+     *   \/\/ Optional\n+     *   0x0001 (DO_NOT_RESOLVE_BY_DEFAULT)\n+     *\n+     *   \/\/ At most one of:\n+     *   0x0002 (WARN_DEPRECATED)\n+     *   0x0004 (WARN_DEPRECATED_FOR_REMOVAL)\n+     *   0x0008 (WARN_INCUBATING)\n+     *\/\n+    int resolutionFlags();\n+\n+    \/**\n+     * {@return a {@code ModuleResolution} attribute}\n+     * @param resolutionFlags the resolution falgs\n+     *\/\n+    static ModuleResolutionAttribute of(int resolutionFlags) {\n+        return new UnboundAttribute.UnboundModuleResolutionAttribute(resolutionFlags);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleResolutionAttribute.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code ModuleTarget} attribute, which can\n+ * appear on classes that represent module descriptors.  This is a JDK-specific\n+ * attribute, which captures constraints on the target platform.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\n+ * <p>The specification of the {@code ModuleTarget} attribute is:\n+ * <pre> {@code\n+ * TargetPlatform_attribute {\n+ *   \/\/ index to CONSTANT_utf8_info structure in constant pool representing\n+ *   \/\/ the string \"ModuleTarget\"\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *\n+ *   \/\/ index to CONSTANT_utf8_info structure with the target platform\n+ *   u2 target_platform_index;\n+ * }\n+ * } <\/pre>\n+ *\/\n+public sealed interface ModuleTargetAttribute\n+        extends Attribute<ModuleTargetAttribute>, ClassElement\n+        permits BoundAttribute.BoundModuleTargetAttribute, UnboundAttribute.UnboundModuleTargetAttribute {\n+\n+    \/**\n+     * {@return the target platform}\n+     *\/\n+    Utf8Entry targetPlatform();\n+\n+    \/**\n+     * {@return a {@code ModuleTarget} attribute}\n+     * @param targetPlatform the target platform\n+     *\/\n+    static ModuleTargetAttribute of(String targetPlatform) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(targetPlatform));\n+    }\n+\n+    \/**\n+     * {@return a {@code ModuleTarget} attribute}\n+     * @param targetPlatform the target platform\n+     *\/\n+    static ModuleTargetAttribute of(Utf8Entry targetPlatform) {\n+        return new UnboundAttribute.UnboundModuleTargetAttribute(targetPlatform);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/ModuleTargetAttribute.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code NestHost} attribute {@jvms 4.7.28}, which can\n+ * appear on classes to indicate that this class is a member of a nest.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface NestHostAttribute extends Attribute<NestHostAttribute>, ClassElement\n+        permits BoundAttribute.BoundNestHostAttribute,\n+                UnboundAttribute.UnboundNestHostAttribute {\n+\n+    \/**\n+     * {@return the host class of the nest to which this class belongs}\n+     *\/\n+    ClassEntry nestHost();\n+\n+    \/**\n+     * {@return a {@code NestHost} attribute}\n+     * @param nestHost the host class of the nest\n+     *\/\n+    static NestHostAttribute of(ClassEntry nestHost) {\n+        return new UnboundAttribute.UnboundNestHostAttribute(nestHost);\n+    }\n+\n+    \/**\n+     * {@return a {@code NestHost} attribute}\n+     * @param nestHost the host class of the nest\n+     *\/\n+    static NestHostAttribute of(ClassDesc nestHost) {\n+        return of(TemporaryConstantPool.INSTANCE.classEntry(nestHost));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/NestHostAttribute.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the {@code NestMembers} attribute {@jvms 4.7.29}, which can\n+ * appear on classes to indicate that this class is the host of a nest.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface NestMembersAttribute extends Attribute<NestMembersAttribute>, ClassElement\n+        permits BoundAttribute.BoundNestMembersAttribute, UnboundAttribute.UnboundNestMembersAttribute {\n+\n+    \/**\n+     * {@return the classes belonging to the nest hosted by this class}\n+     *\/\n+    List<ClassEntry> nestMembers();\n+\n+    \/**\n+     * {@return a {@code NestMembers} attribute}\n+     * @param nestMembers the member classes of the nest\n+     *\/\n+    static NestMembersAttribute of(List<ClassEntry> nestMembers) {\n+        return new UnboundAttribute.UnboundNestMembersAttribute(nestMembers);\n+    }\n+\n+    \/**\n+     * {@return a {@code NestMembers} attribute}\n+     * @param nestMembers the member classes of the nest\n+     *\/\n+    static NestMembersAttribute of(ClassEntry... nestMembers) {\n+        return of(List.of(nestMembers));\n+    }\n+\n+    \/**\n+     * {@return a {@code NestMembers} attribute}\n+     * @param nestMembers the member classes of the nest\n+     *\/\n+    static NestMembersAttribute ofSymbols(List<ClassDesc> nestMembers) {\n+        return of(Util.entryList(nestMembers));\n+    }\n+\n+    \/**\n+     * {@return a {@code NestMembers} attribute}\n+     * @param nestMembers the member classes of the nest\n+     *\/\n+    static NestMembersAttribute ofSymbols(ClassDesc... nestMembers) {\n+        \/\/ List view, since ref to nestMembers is temporary\n+        return ofSymbols(Arrays.asList(nestMembers));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/NestMembersAttribute.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models the {@code PermittedSubclasses} attribute {@jvms 4.7.31}, which can\n+ * appear on classes to indicate which classes may extend this class.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface PermittedSubclassesAttribute\n+        extends Attribute<PermittedSubclassesAttribute>, ClassElement\n+        permits BoundAttribute.BoundPermittedSubclassesAttribute, UnboundAttribute.UnboundPermittedSubclassesAttribute {\n+\n+    \/**\n+     * {@return the list of permitted subclasses}\n+     *\/\n+    List<ClassEntry> permittedSubclasses();\n+\n+    \/**\n+     * {@return a {@code PermittedSubclasses} attribute}\n+     * @param permittedSubclasses the permitted subclasses\n+     *\/\n+    static PermittedSubclassesAttribute of(List<ClassEntry> permittedSubclasses) {\n+        return new UnboundAttribute.UnboundPermittedSubclassesAttribute(permittedSubclasses);\n+    }\n+\n+    \/**\n+     * {@return a {@code PermittedSubclasses} attribute}\n+     * @param permittedSubclasses the permitted subclasses\n+     *\/\n+    static PermittedSubclassesAttribute of(ClassEntry... permittedSubclasses) {\n+        return of(List.of(permittedSubclasses));\n+    }\n+\n+    \/**\n+     * {@return a {@code PermittedSubclasses} attribute}\n+     * @param permittedSubclasses the permitted subclasses\n+     *\/\n+    static PermittedSubclassesAttribute ofSymbols(List<ClassDesc> permittedSubclasses) {\n+        return of(Util.entryList(permittedSubclasses));\n+    }\n+\n+    \/**\n+     * {@return a {@code PermittedSubclasses} attribute}\n+     * @param permittedSubclasses the permitted subclasses\n+     *\/\n+    static PermittedSubclassesAttribute ofSymbols(ClassDesc... permittedSubclasses) {\n+        \/\/ List view, since ref to nestMembers is temporary\n+        return ofSymbols(Arrays.asList(permittedSubclasses));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code Record} attribute {@jvms 4.7.30}, which can\n+ * appear on classes to indicate that this class is a record class.\n+ * Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing the elements of a {@link jdk.internal.classfile.ClassModel}.\n+ *\/\n+public sealed interface RecordAttribute extends Attribute<RecordAttribute>, ClassElement\n+        permits BoundAttribute.BoundRecordAttribute, UnboundAttribute.UnboundRecordAttribute {\n+\n+    \/**\n+     * {@return the components of this record class}\n+     *\/\n+    List<RecordComponentInfo> components();\n+\n+    \/**\n+     * {@return a {@code Record} attribute}\n+     * @param components the record components\n+     *\/\n+    static RecordAttribute of(List<RecordComponentInfo> components) {\n+        return new UnboundAttribute.UnboundRecordAttribute(components);\n+    }\n+\n+    \/**\n+     * {@return a {@code Record} attribute}\n+     * @param components the record components\n+     *\/\n+    static RecordAttribute of(RecordComponentInfo... components) {\n+        return of(List.of(components));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RecordAttribute.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.AttributedElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundRecordComponentInfo;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models a single record component in the {@link jdk.internal.classfile.attribute.RecordAttribute}.\n+ *\/\n+public sealed interface RecordComponentInfo\n+        extends AttributedElement\n+        permits BoundRecordComponentInfo, UnboundAttribute.UnboundRecordComponentInfo {\n+    \/**\n+     * {@return the name of this component}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the field descriptor of this component}\n+     *\/\n+    Utf8Entry descriptor();\n+\n+    \/**\n+     * {@return the field descriptor of this component, as a {@linkplain ClassDesc}}\n+     *\/\n+    default ClassDesc descriptorSymbol() {\n+        return ClassDesc.ofDescriptor(descriptor().stringValue());\n+    }\n+\n+    \/**\n+     * {@return a record component description}\n+     * @param name the component name\n+     * @param descriptor the component field descriptor\n+     * @param attributes the component attributes\n+     *\/\n+    static RecordComponentInfo of(Utf8Entry name,\n+                                  Utf8Entry descriptor,\n+                                  List<Attribute<?>> attributes) {\n+        return new UnboundAttribute.UnboundRecordComponentInfo(name, descriptor, attributes);\n+    }\n+\n+    \/**\n+     * {@return a record component description}\n+     * @param name the component name\n+     * @param descriptor the component field descriptor\n+     * @param attributes the component attributes\n+     *\/\n+    static RecordComponentInfo of(Utf8Entry name,\n+                                  Utf8Entry descriptor,\n+                                  Attribute<?>... attributes) {\n+        return of(name, descriptor, List.of(attributes));\n+    }\n+\n+    \/**\n+     * {@return a record component description}\n+     * @param name the component name\n+     * @param descriptor the component field descriptor\n+     * @param attributes the component attributes\n+     *\/\n+    static RecordComponentInfo of(String name,\n+                                  ClassDesc descriptor,\n+                                  List<Attribute<?>> attributes) {\n+        return new UnboundAttribute.UnboundRecordComponentInfo(TemporaryConstantPool.INSTANCE.utf8Entry(name),\n+                                                               TemporaryConstantPool.INSTANCE.utf8Entry(descriptor.descriptorString()),\n+                                                               attributes);\n+    }\n+\n+    \/**\n+     * {@return a record component description}\n+     * @param name the component name\n+     * @param descriptor the component field descriptor\n+     * @param attributes the component attributes\n+     *\/\n+    static RecordComponentInfo of(String name,\n+                                  ClassDesc descriptor,\n+                                  Attribute<?>... attributes) {\n+        return of(name, descriptor, List.of(attributes));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RecordComponentInfo.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * Models the {@code RuntimeInvisibleAnnotations} attribute {@jvms 4.7.17}, which\n+ * can appear on classes, methods, and fields. Delivered as a\n+ * {@link jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.FieldElement}, or\n+ * {@link jdk.internal.classfile.MethodElement} when traversing the corresponding model type.\n+ *\/\n+public sealed interface RuntimeInvisibleAnnotationsAttribute\n+        extends Attribute<RuntimeInvisibleAnnotationsAttribute>,\n+                ClassElement, MethodElement, FieldElement\n+        permits BoundAttribute.BoundRuntimeInvisibleAnnotationsAttribute,\n+                UnboundAttribute.UnboundRuntimeInvisibleAnnotationsAttribute {\n+\n+    \/**\n+     * {@return the non-runtime-visible annotations on this class, field, or method}\n+     *\/\n+    List<Annotation> annotations();\n+\n+    \/**\n+     * {@return a {@code RuntimeInvisibleAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeInvisibleAnnotationsAttribute of(List<Annotation> annotations) {\n+        return new UnboundAttribute.UnboundRuntimeInvisibleAnnotationsAttribute(annotations);\n+    }\n+\n+    \/**\n+     * {@return a {@code RuntimeInvisibleAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeInvisibleAnnotationsAttribute of(Annotation... annotations) {\n+        return of(List.of(annotations));\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code RuntimeInvisibleParameterAnnotations} attribute\n+ * {@jvms 4.7.19}, which can appear on methods. Delivered as a {@link\n+ * jdk.internal.classfile.MethodElement} when traversing a {@link MethodModel}.\n+ *\/\n+public sealed interface RuntimeInvisibleParameterAnnotationsAttribute\n+        extends Attribute<RuntimeInvisibleParameterAnnotationsAttribute>, MethodElement\n+        permits BoundAttribute.BoundRuntimeInvisibleParameterAnnotationsAttribute,\n+                UnboundAttribute.UnboundRuntimeInvisibleParameterAnnotationsAttribute {\n+\n+    \/**\n+     * {@return the list of annotations corresponding to each method parameter}\n+     * The element at the i'th index corresponds to the annotations on the i'th\n+     * parameter.\n+     *\/\n+    List<List<Annotation>> parameterAnnotations();\n+\n+    \/**\n+     * {@return a {@code RuntimeInvisibleParameterAnnotations} attribute}\n+     * @param parameterAnnotations a list of parameter annotations for each parameter\n+     *\/\n+    static RuntimeInvisibleParameterAnnotationsAttribute of(List<List<Annotation>> parameterAnnotations) {\n+        return new UnboundAttribute.UnboundRuntimeInvisibleParameterAnnotationsAttribute(parameterAnnotations);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code RuntimeInvisibleTypeAnnotations} attribute {@jvms 4.7.21}, which\n+ * can appear on classes, methods, fields, and code attributes. Delivered as a\n+ * {@link jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.FieldElement},\n+ * {@link jdk.internal.classfile.MethodElement}, or {@link CodeElement} when traversing\n+ * the corresponding model type.\n+ *\/\n+public sealed interface RuntimeInvisibleTypeAnnotationsAttribute\n+        extends Attribute<RuntimeInvisibleTypeAnnotationsAttribute>,\n+                ClassElement, MethodElement, FieldElement, CodeElement\n+        permits BoundAttribute.BoundRuntimeInvisibleTypeAnnotationsAttribute,\n+                UnboundAttribute.UnboundRuntimeInvisibleTypeAnnotationsAttribute {\n+\n+    \/**\n+     * {@return the non-runtime-visible type annotations on parts of this class, field, or method}\n+     *\/\n+    List<TypeAnnotation> annotations();\n+\n+    \/**\n+     * {@return a {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeInvisibleTypeAnnotationsAttribute of(List<TypeAnnotation> annotations) {\n+        return new UnboundAttribute.UnboundRuntimeInvisibleTypeAnnotationsAttribute(annotations);\n+    }\n+\n+    \/**\n+     * {@return a {@code RuntimeInvisibleTypeAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeInvisibleTypeAnnotationsAttribute of(TypeAnnotation... annotations) {\n+        return of(List.of(annotations));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * Models the {@code RuntimeVisibleAnnotations} attribute {@jvms 4.7.16}, which\n+ * can appear on classes, methods, and fields. Delivered as a\n+ * {@link jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.FieldElement}, or\n+ * {@link jdk.internal.classfile.MethodElement} when traversing the corresponding model type.\n+ *\/\n+public sealed interface RuntimeVisibleAnnotationsAttribute\n+        extends Attribute<RuntimeVisibleAnnotationsAttribute>,\n+                ClassElement, MethodElement, FieldElement\n+        permits BoundAttribute.BoundRuntimeVisibleAnnotationsAttribute,\n+                UnboundAttribute.UnboundRuntimeVisibleAnnotationsAttribute {\n+\n+    \/**\n+     * {@return the runtime-visible annotations on this class, field, or method}\n+     *\/\n+    List<Annotation> annotations();\n+\n+    \/**\n+     * {@return a {@code RuntimeVisibleAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeVisibleAnnotationsAttribute of(List<Annotation> annotations) {\n+        return new UnboundAttribute.UnboundRuntimeVisibleAnnotationsAttribute(annotations);\n+    }\n+\n+    \/**\n+     * {@return a {@code RuntimeVisibleAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeVisibleAnnotationsAttribute of(Annotation... annotations) {\n+        return of(List.of(annotations));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code RuntimeVisibleParameterAnnotations} attribute {@jvms 4.7.18}, which\n+ * can appear on methods. Delivered as a {@link jdk.internal.classfile.MethodElement}\n+ * when traversing a {@link MethodModel}.\n+ *\/\n+public sealed interface RuntimeVisibleParameterAnnotationsAttribute\n+        extends Attribute<RuntimeVisibleParameterAnnotationsAttribute>, MethodElement\n+        permits BoundAttribute.BoundRuntimeVisibleParameterAnnotationsAttribute,\n+                UnboundAttribute.UnboundRuntimeVisibleParameterAnnotationsAttribute {\n+\n+    \/**\n+     * {@return the list of annotations corresponding to each method parameter}\n+     * The element at the i'th index corresponds to the annotations on the i'th\n+     * parameter.\n+     *\/\n+    List<List<Annotation>> parameterAnnotations();\n+\n+    \/**\n+     * {@return a {@code RuntimeVisibleParameterAnnotations} attribute}\n+     * @param parameterAnnotations a list of parameter annotations for each parameter\n+     *\/\n+    static RuntimeVisibleParameterAnnotationsAttribute of(List<List<Annotation>> parameterAnnotations) {\n+        return new UnboundAttribute.UnboundRuntimeVisibleParameterAnnotationsAttribute(parameterAnnotations);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code RuntimeVisibleTypeAnnotations} attribute {@jvms 4.7.20}, which\n+ * can appear on classes, methods, fields, and code attributes. Delivered as a\n+ * {@link jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.FieldElement},\n+ * {@link jdk.internal.classfile.MethodElement}, or {@link CodeElement} when traversing\n+ * the corresponding model type.\n+ *\/\n+public sealed interface RuntimeVisibleTypeAnnotationsAttribute\n+        extends Attribute<RuntimeVisibleTypeAnnotationsAttribute>,\n+                ClassElement, MethodElement, FieldElement, CodeElement\n+        permits BoundAttribute.BoundRuntimeVisibleTypeAnnotationsAttribute,\n+                UnboundAttribute.UnboundRuntimeVisibleTypeAnnotationsAttribute {\n+\n+    \/**\n+     * {@return the runtime-visible type annotations on parts of this class, field, or method}\n+     *\/\n+    List<TypeAnnotation> annotations();\n+\n+    \/**\n+     * {@return a {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeVisibleTypeAnnotationsAttribute of(List<TypeAnnotation> annotations) {\n+        return new UnboundAttribute.UnboundRuntimeVisibleTypeAnnotationsAttribute(annotations);\n+    }\n+\n+    \/**\n+     * {@return a {@code RuntimeVisibleTypeAnnotations} attribute}\n+     * @param annotations the annotations\n+     *\/\n+    static RuntimeVisibleTypeAnnotationsAttribute of(TypeAnnotation... annotations) {\n+        return of(List.of(annotations));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code Signature} attribute {@jvms 4.7.9}, which\n+ * can appear on classes, methods, or fields. Delivered as a\n+ * {@link jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.FieldElement}, or\n+ * {@link jdk.internal.classfile.MethodElement} when traversing\n+ * the corresponding model type.\n+ *\/\n+public sealed interface SignatureAttribute\n+        extends Attribute<SignatureAttribute>,\n+                ClassElement, MethodElement, FieldElement\n+        permits BoundAttribute.BoundSignatureAttribute, UnboundAttribute.UnboundSignatureAttribute {\n+\n+    \/**\n+     * {@return the signature for the class, method, or field}\n+     *\/\n+    Utf8Entry signature();\n+\n+    \/**\n+     * Parse the siganture as a class signature.\n+     * @return the class signature\n+     *\/\n+    default ClassSignature asClassSignature() {\n+        return ClassSignature.parseFrom(signature().stringValue());\n+    }\n+\n+    \/**\n+     * Parse the signature as a method signature.\n+     * @return the method signature\n+     *\/\n+    default MethodSignature asMethodSignature() {\n+        return MethodSignature.parseFrom(signature().stringValue());\n+    }\n+\n+    \/**\n+     * Parse the siganture as a type signature.\n+     * @return the type signature\n+     *\/\n+    default Signature asTypeSignature() {\n+        return Signature.parseFrom(signature().stringValue());\n+    }\n+\n+    \/**\n+     * {@return a {@code Signature} attribute for a class}\n+     * @param classSignature the signature\n+     *\/\n+    static SignatureAttribute of(ClassSignature classSignature) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(classSignature.signatureString()));\n+    }\n+\n+    \/**\n+     * {@return a {@code Signature} attribute for a method}\n+     * @param methodSignature the signature\n+     *\/\n+    static SignatureAttribute of(MethodSignature methodSignature) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(methodSignature.signatureString()));\n+    }\n+\n+    \/**\n+     * {@return a {@code Signature} attribute}\n+     * @param signature the signature\n+     *\/\n+    static SignatureAttribute of(Signature signature) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(signature.signatureString()));\n+    }\n+\n+    \/**\n+     * {@return a {@code Signature} attribute}\n+     * @param signature the signature\n+     *\/\n+    static SignatureAttribute of(Utf8Entry signature) {\n+        return new UnboundAttribute.UnboundSignatureAttribute(signature);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/SignatureAttribute.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * SourceDebugExtensionAttribute.\n+ *\/\n+public sealed interface SourceDebugExtensionAttribute\n+        extends Attribute<SourceDebugExtensionAttribute>, ClassElement\n+        permits BoundAttribute.BoundSourceDebugExtensionAttribute, UnboundAttribute.UnboundSourceDebugExtensionAttribute {\n+\n+    \/**\n+     * {@return the debug extension payload}\n+     *\/\n+    byte[] contents();\n+\n+    \/**\n+     * {@return a {@code SourceDebugExtension} attribute}\n+     * @param contents the extension contents\n+     *\/\n+    static SourceDebugExtensionAttribute of(byte[] contents) {\n+        return new UnboundAttribute.UnboundSourceDebugExtensionAttribute(contents);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/SourceDebugExtensionAttribute.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code SourceFile} attribute {@jvms 4.7.10}, which\n+ * can appear on classes. Delivered as a {@link jdk.internal.classfile.ClassElement}\n+ * when traversing a {@link ClassModel}.\n+ *\/\n+public sealed interface SourceFileAttribute\n+        extends Attribute<SourceFileAttribute>, ClassElement\n+        permits BoundAttribute.BoundSourceFileAttribute, UnboundAttribute.UnboundSourceFileAttribute {\n+\n+    \/**\n+     * {@return the name of the source file from which this class was compiled}\n+     *\/\n+    Utf8Entry sourceFile();\n+\n+    static SourceFileAttribute of(String sourceFile) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(sourceFile));\n+    }\n+\n+    static SourceFileAttribute of(Utf8Entry sourceFile) {\n+        return new UnboundAttribute.UnboundSourceFileAttribute(sourceFile);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/SourceFileAttribute.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code SourceFile} attribute (@@@ reference needed), which can\n+ * appear on classes. Delivered as a {@link jdk.internal.classfile.ClassElement} when\n+ * traversing a {@link ClassModel}.\n+ *\/\n+public sealed interface SourceIDAttribute\n+        extends Attribute<SourceIDAttribute>, ClassElement\n+        permits BoundAttribute.BoundSourceIDAttribute, UnboundAttribute.UnboundSourceIDAttribute {\n+\n+    \/**\n+     * {@return the source id}  The source id is the last modified time of the\n+     * source file (as reported by the filesystem, in milliseconds) when the\n+     * classfile is compiled.\n+     *\/\n+    Utf8Entry sourceId();\n+\n+    \/**\n+     * {@return a {@code SourceID} attribute}\n+     * @param sourceId the source id\n+     *\/\n+    static SourceIDAttribute of(Utf8Entry sourceId) {\n+        return new UnboundAttribute.UnboundSourceIDAttribute(sourceId);\n+    }\n+\n+    \/**\n+     * {@return a {@code SourceID} attribute}\n+     * @param sourceId the source id\n+     *\/\n+    static SourceIDAttribute of(String sourceId) {\n+        return of(TemporaryConstantPool.INSTANCE.utf8Entry(sourceId));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/SourceIDAttribute.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.StackMapDecoder;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+\/**\n+ * Models the {@code StackMapTable} attribute {@jvms 4.7.4}, which can appear\n+ * on a {@code Code} attribute.\n+ *\/\n+public sealed interface StackMapTableAttribute\n+        extends Attribute<StackMapTableAttribute>, CodeElement\n+        permits BoundAttribute.BoundStackMapTableAttribute, UnboundAttribute.UnboundStackMapTableAttribute {\n+\n+    \/**\n+     * {@return the stack map frames}\n+     *\/\n+    List<StackMapFrameInfo> entries();\n+\n+    public static StackMapTableAttribute of(List<StackMapFrameInfo> entries) {\n+        return new UnboundAttribute.UnboundStackMapTableAttribute(entries);\n+    }\n+\n+    \/**\n+     * The type of a stack value.\n+     *\/\n+    sealed interface VerificationTypeInfo {\n+        int tag();\n+    }\n+\n+    \/**\n+     * A simple stack value.\n+     *\/\n+    public enum SimpleVerificationTypeInfo implements VerificationTypeInfo {\n+        ITEM_TOP(VT_TOP),\n+        ITEM_INTEGER(VT_INTEGER),\n+        ITEM_FLOAT(VT_FLOAT),\n+        ITEM_DOUBLE(VT_DOUBLE),\n+        ITEM_LONG(VT_LONG),\n+        ITEM_NULL(VT_NULL),\n+        ITEM_UNINITIALIZED_THIS(VT_UNINITIALIZED_THIS);\n+\n+\n+        private final int tag;\n+\n+        SimpleVerificationTypeInfo(int tag) {\n+            this.tag = tag;\n+        }\n+\n+        @Override\n+        public int tag() {\n+            return tag;\n+        }\n+    }\n+\n+    \/**\n+     * A stack value for an object type.\n+     *\/\n+    sealed interface ObjectVerificationTypeInfo extends VerificationTypeInfo\n+            permits StackMapDecoder.ObjectVerificationTypeInfoImpl {\n+\n+        public static ObjectVerificationTypeInfo of(ClassEntry className) {\n+            return new StackMapDecoder.ObjectVerificationTypeInfoImpl(className);\n+        }\n+\n+        public static ObjectVerificationTypeInfo of(ClassDesc classDesc) {\n+            return of(TemporaryConstantPool.INSTANCE.classEntry(classDesc));\n+        }\n+\n+        \/**\n+         * {@return the class of the value}\n+         *\/\n+        ClassEntry className();\n+\n+        default ClassDesc classSymbol() {\n+            return className().asSymbol();\n+        }\n+    }\n+\n+    \/**\n+     * An uninitialized stack value.\n+     *\/\n+    sealed interface UninitializedVerificationTypeInfo extends VerificationTypeInfo\n+            permits StackMapDecoder.UninitializedVerificationTypeInfoImpl {\n+        Label newTarget();\n+\n+        public static UninitializedVerificationTypeInfo of(Label newTarget) {\n+            return new StackMapDecoder.UninitializedVerificationTypeInfoImpl(newTarget);\n+        }\n+    }\n+\n+    \/**\n+     * A stack map frame.\n+     *\/\n+    sealed interface StackMapFrameInfo\n+            permits StackMapDecoder.StackMapFrameImpl {\n+\n+        int frameType();\n+        Label target();\n+        List<VerificationTypeInfo> locals();\n+        List<VerificationTypeInfo> stack();\n+\n+        public static StackMapFrameInfo of(Label target,\n+                List<VerificationTypeInfo> locals,\n+                List<VerificationTypeInfo> stack) {\n+\n+            return new StackMapDecoder.StackMapFrameImpl(255, target, locals, stack);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/StackMapTableAttribute.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+\n+\/**\n+ * Models the {@code Synthetic} attribute {@jvms 4.7.8}, which can appear on\n+ * classes, methods, and fields.  Delivered as a  {@link ClassElement},\n+ * {@link MethodElement}, or  {@link FieldElement} when traversing the elements\n+ * of a corresponding model.\n+ *\/\n+public sealed interface SyntheticAttribute\n+        extends Attribute<SyntheticAttribute>,\n+                ClassElement, MethodElement, FieldElement\n+        permits BoundAttribute.BoundSyntheticAttribute, UnboundAttribute.UnboundSyntheticAttribute {\n+\n+    \/**\n+     * {@return a {@code Synthetic} attribute}\n+     *\/\n+    static SyntheticAttribute of() {\n+        return new UnboundAttribute.UnboundSyntheticAttribute();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/SyntheticAttribute.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.attribute;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+\n+\/**\n+ * Models an unknown attribute on a class, method, or field.\n+ *\/\n+public sealed interface UnknownAttribute\n+        extends Attribute<UnknownAttribute>,\n+                ClassElement, MethodElement, FieldElement\n+        permits BoundAttribute.BoundUnknownAttribute {\n+\n+    \/**\n+     * {@return the uninterpreted contents of the attribute payload}\n+     *\/\n+    byte[] contents();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/UnknownAttribute.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.components;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CompoundElement;\n+\n+import jdk.internal.classfile.impl.ClassPrinterImpl;\n+\n+\/**\n+ * A printer of classfiles and its elements.\n+ * <p>\n+ * Any {@link ClassModel}, {@link FieldModel}, {@link MethodModel}, or {@link CodeModel}\n+ * can be printed to a human-readable structured text in JSON, XML, or YAML format.\n+ * Or it can be exported into a tree of traversable and printable nodes,\n+ * more exactly into a tree of {@link MapNode}, {@link ListNode}, and {@link LeafNode} instances.\n+ * <p>\n+ * Level of details to print or to export is driven by {@link Verbosity} option.\n+ * <p>\n+ * The most frequent use case is to simply print a class:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"printClass\"}\n+ * <p>\n+ * {@link ClassPrinter} allows to traverse tree of simple printable nodes to hook custom printer:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"customPrint\"}\n+ * <p>\n+ * Another use case for {@link ClassPrinter} is to simplify writing of automated tests:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"printNodesInTest\"}\n+ *\/\n+public final class ClassPrinter {\n+\n+    \/**\n+     * Level of detail to print or export.\n+     *\/\n+    public enum Verbosity {\n+\n+        \/**\n+         * Only top level class info, class members and attribute names are printed.\n+         *\/\n+        MEMBERS_ONLY,\n+\n+        \/**\n+         * Top level class info, class members, and critical attributes are printed.\n+         * <p>\n+         * Critical attributes are:\n+         * <ul>\n+         * <li>ConstantValue\n+         * <li>Code\n+         * <li>StackMapTable\n+         * <li>BootstrapMethods\n+         * <li>NestHost\n+         * <li>NestMembers\n+         * <li>PermittedSubclasses\n+         * <\/ul>\n+         * @jvms 4.7 Attributes\n+         *\/\n+        CRITICAL_ATTRIBUTES,\n+\n+        \/**\n+         * All class content is printed, including constant pool.\n+         *\/\n+        TRACE_ALL }\n+\n+    \/**\n+     * Named, traversable, and printable node parent.\n+     *\/\n+    public sealed interface Node {\n+\n+        \/**\n+         * Printable name of the node.\n+         * @return name of the node\n+         *\/\n+        ConstantDesc name();\n+\n+        \/**\n+         * Walks through the underlying tree.\n+         * @return ordered stream of nodes\n+         *\/\n+        Stream<Node> walk();\n+\n+        \/**\n+         * Prints the node and its sub-tree into JSON format.\n+         * @param out consumer of the printed fragments\n+         *\/\n+        default void toJson(Consumer<String> out) {\n+            ClassPrinterImpl.toJson(this, out);\n+        }\n+\n+        \/**\n+         * Prints the node and its sub-tree into XML format.\n+         * @param out consumer of the printed fragments\n+         *\/\n+        default void toXml(Consumer<String> out) {\n+            ClassPrinterImpl.toXml(this, out);\n+        }\n+\n+        \/**\n+         * Prints the node and its sub-tree into YAML format.\n+         * @param out consumer of the printed fragments\n+         *\/\n+        default void toYaml(Consumer<String> out) {\n+            ClassPrinterImpl.toYaml(this, out);\n+        }\n+    }\n+\n+    \/**\n+     * A leaf node holding single printable value.\n+     *\/\n+    public sealed interface LeafNode extends Node\n+            permits ClassPrinterImpl.LeafNodeImpl {\n+\n+        \/**\n+         * Printable node value\n+         * @return node value\n+         *\/\n+        ConstantDesc value();\n+    }\n+\n+    \/**\n+     * A tree node holding {@link List} of nested nodes.\n+     *\/\n+    public sealed interface ListNode extends Node, List<Node>\n+            permits ClassPrinterImpl.ListNodeImpl {\n+    }\n+\n+    \/**\n+     * A tree node holding {@link Map} of nested nodes.\n+     * <p>\n+     * Each {@link Map.Entry#getKey()} == {@link Map.Entry#getValue()}.{@link #name()}.\n+     *\/\n+    public sealed interface MapNode extends Node, Map<ConstantDesc, Node>\n+            permits ClassPrinterImpl.MapNodeImpl {\n+    }\n+\n+    \/**\n+     * Exports provided model into a tree of printable nodes.\n+     * @param model a {@link ClassModel}, {@link FieldModel}, {@link MethodModel}, or {@link CodeModel} to export\n+     * @param verbosity level of details to export\n+     * @return root node of the exported tree\n+     *\/\n+    public static MapNode toTree(CompoundElement<?> model, Verbosity verbosity) {\n+        return ClassPrinterImpl.modelToTree(model, verbosity);\n+    }\n+\n+    \/**\n+     * Prints provided model as structured text in JSON format.\n+     * @param model a {@link ClassModel}, {@link FieldModel}, {@link MethodModel}, or {@link CodeModel} to print\n+     * @param verbosity level of details to print\n+     * @param out consumer of the print fragments\n+     *\/\n+    public static void toJson(CompoundElement<?> model, Verbosity verbosity, Consumer<String> out) {\n+        toTree(model, verbosity).toJson(out);\n+    }\n+\n+    \/**\n+     * Prints provided model as structured text in XML format.\n+     * @param model a {@link ClassModel}, {@link FieldModel}, {@link MethodModel}, or {@link CodeModel} to print\n+     * @param verbosity level of details to print\n+     * @param out consumer of the print fragments\n+     *\/\n+    public static void toXml(CompoundElement<?> model, Verbosity verbosity, Consumer<String> out) {\n+        toTree(model, verbosity).toXml(out);\n+    }\n+\n+    \/**\n+     * Prints provided model as structured text in YAML format.\n+     * @param model a {@link ClassModel}, {@link FieldModel}, {@link MethodModel}, or {@link CodeModel} to print\n+     * @param verbosity level of details to print\n+     * @param out consumer of the print fragments\n+     *\/\n+    public static void toYaml(CompoundElement<?> model, Verbosity verbosity, Consumer<String> out) {\n+        toTree(model, verbosity).toYaml(out);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassPrinter.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,489 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.components;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.FieldTransform;\n+import jdk.internal.classfile.Interfaces;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.Superclass;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleProvideInfo;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.impl.Util;\n+import jdk.internal.classfile.instruction.ConstantInstruction.LoadConstantInstruction;\n+\n+\/**\n+ * {@code ClassRemapper} is a {@link ClassTransform}, {@link FieldTransform},\n+ * {@link MethodTransform} and {@link CodeTransform}\n+ * deeply re-mapping all class references in any form, according to given map or\n+ * map function.\n+ * <p>\n+ * The re-mapping is applied to superclass, interfaces, all kinds of descriptors\n+ * and signatures, all attributes referencing classes in any form (including all\n+ * types of annotations), and to all instructions referencing to classes.\n+ * <p>\n+ * Primitive types and arrays are never subjects of mapping and are not allowed\n+ * targets of mapping.\n+ * <p>\n+ * Arrays of reference types are always decomposed, mapped as the base reference\n+ * types and composed back to arrays.\n+ *\/\n+public sealed interface ClassRemapper extends ClassTransform {\n+\n+    \/**\n+     * Creates new instance of {@code ClassRemapper} instructed with a class map.\n+     * Map may contain only re-mapping entries, identity mapping is applied by default.\n+     * @param classMap class map\n+     * @return new instance of {@code ClassRemapper}\n+     *\/\n+    static ClassRemapper of(Map<ClassDesc, ClassDesc> classMap) {\n+        return of(desc -> classMap.getOrDefault(desc, desc));\n+    }\n+\n+    \/**\n+     * Creates new instance of {@code ClassRemapper} instructed with a map function.\n+     * Map function must return valid {@link java.lang.constant.ClassDesc} of an interface\n+     * or a class, even for identity mappings.\n+     * @param mapFunction class map function\n+     * @return new instance of {@code ClassRemapper}\n+     *\/\n+    static ClassRemapper of(Function<ClassDesc, ClassDesc> mapFunction) {\n+        return new ClassRemapperImpl(mapFunction);\n+    }\n+\n+    \/**\n+     * Access method to internal class mapping function.\n+     * @param desc source class\n+     * @return class target class\n+     *\/\n+    ClassDesc map(ClassDesc desc);\n+\n+    \/**\n+     * Returns this {@code ClassRemapper} as {@link FieldTransform} instance\n+     * @return this {@code ClassRemapper} as {@link FieldTransform} instance\n+     *\/\n+    FieldTransform asFieldTransform();\n+\n+    \/**\n+     * Returns this {@code ClassRemapper} as {@link MethodTransform} instance\n+     * @return this {@code ClassRemapper} as {@link MethodTransform} instance\n+     *\/\n+    MethodTransform asMethodTransform();\n+\n+    \/**\n+     * Returns this {@code ClassRemapper} as {@link CodeTransform} instance\n+     * @return this {@code ClassRemapper} as {@link CodeTransform} instance\n+     *\/\n+    CodeTransform asCodeTransform();\n+\n+    \/**\n+     * Remaps the whole ClassModel into a new class file, including the class name.\n+     * @param clm class model to re-map\n+     * @return re-mapped class file bytes\n+     *\/\n+    default byte[] remapClass(ClassModel clm) {\n+        return Classfile.build(map(clm.thisClass().asSymbol()),\n+                clb -> clm.forEachElement(resolve(clb).consumer()));\n+    }\n+\n+    record ClassRemapperImpl(Function<ClassDesc, ClassDesc> mapFunction) implements ClassRemapper {\n+\n+        @Override\n+        public void accept(ClassBuilder clb, ClassElement cle) {\n+            switch (cle) {\n+                case FieldModel fm ->\n+                    clb.withField(fm.fieldName().stringValue(), map(\n+                            fm.fieldTypeSymbol()), fb ->\n+                                    fm.forEachElement(asFieldTransform().resolve(fb).consumer()));\n+                case MethodModel mm ->\n+                    clb.withMethod(mm.methodName().stringValue(), mapMethodDesc(\n+                            mm.methodTypeSymbol()), mm.flags().flagsMask(), mb ->\n+                                    mm.forEachElement(asMethodTransform().resolve(mb).consumer()));\n+                case Superclass sc ->\n+                    clb.withSuperclass(map(sc.superclassEntry().asSymbol()));\n+                case Interfaces ins ->\n+                    clb.withInterfaceSymbols(Util.mappedList(ins.interfaces(), in ->\n+                            map(in.asSymbol())));\n+                case SignatureAttribute sa ->\n+                    clb.with(SignatureAttribute.of(mapClassSignature(sa.asClassSignature())));\n+                case InnerClassesAttribute ica ->\n+                    clb.with(InnerClassesAttribute.of(ica.classes().stream().map(ici ->\n+                            InnerClassInfo.of(map(ici.innerClass().asSymbol()),\n+                                    ici.outerClass().map(oc -> map(oc.asSymbol())),\n+                                    ici.innerName().map(Utf8Entry::stringValue),\n+                                    ici.flagsMask())).toList()));\n+                case EnclosingMethodAttribute ema ->\n+                    clb.with(EnclosingMethodAttribute.of(map(ema.enclosingClass().asSymbol()),\n+                            ema.enclosingMethodName().map(Utf8Entry::stringValue),\n+                            ema.enclosingMethodTypeSymbol().map(this::mapMethodDesc)));\n+                case RecordAttribute ra ->\n+                    clb.with(RecordAttribute.of(ra.components().stream()\n+                            .map(this::mapRecordComponent).toList()));\n+                case ModuleAttribute ma ->\n+                    clb.with(ModuleAttribute.of(ma.moduleName(), ma.moduleFlagsMask(),\n+                            ma.moduleVersion().orElse(null),\n+                            ma.requires(), ma.exports(), ma.opens(),\n+                            ma.uses().stream().map(ce ->\n+                                    clb.constantPool().classEntry(map(ce.asSymbol()))).toList(),\n+                            ma.provides().stream().map(mp ->\n+                                    ModuleProvideInfo.of(map(mp.provides().asSymbol()),\n+                                            mp.providesWith().stream().map(pw ->\n+                                                    map(pw.asSymbol())).toList())).toList()));\n+                case NestHostAttribute nha ->\n+                    clb.with(NestHostAttribute.of(map(nha.nestHost().asSymbol())));\n+                case NestMembersAttribute nma ->\n+                    clb.with(NestMembersAttribute.ofSymbols(nma.nestMembers().stream()\n+                            .map(nm -> map(nm.asSymbol())).toList()));\n+                case PermittedSubclassesAttribute psa ->\n+                    clb.with(PermittedSubclassesAttribute.ofSymbols(\n+                            psa.permittedSubclasses().stream().map(ps ->\n+                                    map(ps.asSymbol())).toList()));\n+                case RuntimeVisibleAnnotationsAttribute aa ->\n+                    clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeInvisibleAnnotationsAttribute aa ->\n+                    clb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                            mapAnnotations(aa.annotations())));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    clb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    clb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                            mapTypeAnnotations(aa.annotations())));\n+                default ->\n+                    clb.with(cle);\n+            }\n+        }\n+\n+        @Override\n+        public FieldTransform asFieldTransform() {\n+            return (FieldBuilder fb, FieldElement fe) -> {\n+                switch (fe) {\n+                    case SignatureAttribute sa ->\n+                        fb.with(SignatureAttribute.of(\n+                                mapSignature(sa.asTypeSignature())));\n+                    case RuntimeVisibleAnnotationsAttribute aa ->\n+                        fb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                                mapAnnotations(aa.annotations())));\n+                    case RuntimeInvisibleAnnotationsAttribute aa ->\n+                        fb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                                mapAnnotations(aa.annotations())));\n+                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                        fb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                mapTypeAnnotations(aa.annotations())));\n+                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                        fb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                mapTypeAnnotations(aa.annotations())));\n+                    default ->\n+                        fb.with(fe);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public MethodTransform asMethodTransform() {\n+            return (MethodBuilder mb, MethodElement me) -> {\n+                switch (me) {\n+                    case AnnotationDefaultAttribute ada ->\n+                        mb.with(AnnotationDefaultAttribute.of(\n+                                mapAnnotationValue(ada.defaultValue())));\n+                    case CodeModel com ->\n+                        mb.transformCode(com, asCodeTransform());\n+                    case ExceptionsAttribute ea ->\n+                        mb.with(ExceptionsAttribute.ofSymbols(\n+                                ea.exceptions().stream().map(ce ->\n+                                        map(ce.asSymbol())).toList()));\n+                    case SignatureAttribute sa ->\n+                        mb.with(SignatureAttribute.of(\n+                                mapMethodSignature(sa.asMethodSignature())));\n+                    case RuntimeVisibleAnnotationsAttribute aa ->\n+                        mb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                                mapAnnotations(aa.annotations())));\n+                    case RuntimeInvisibleAnnotationsAttribute aa ->\n+                        mb.with(RuntimeInvisibleAnnotationsAttribute.of(\n+                                mapAnnotations(aa.annotations())));\n+                    case RuntimeVisibleParameterAnnotationsAttribute paa ->\n+                        mb.with(RuntimeVisibleParameterAnnotationsAttribute.of(\n+                                paa.parameterAnnotations().stream()\n+                                        .map(this::mapAnnotations).toList()));\n+                    case RuntimeInvisibleParameterAnnotationsAttribute paa ->\n+                        mb.with(RuntimeInvisibleParameterAnnotationsAttribute.of(\n+                                paa.parameterAnnotations().stream()\n+                                        .map(this::mapAnnotations).toList()));\n+                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                        mb.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                mapTypeAnnotations(aa.annotations())));\n+                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                        mb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                mapTypeAnnotations(aa.annotations())));\n+                    default ->\n+                        mb.with(me);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public CodeTransform asCodeTransform() {\n+            return (CodeBuilder cob, CodeElement coe) -> {\n+                switch (coe) {\n+                    case FieldInstruction fai ->\n+                        cob.fieldInstruction(fai.opcode(), map(fai.owner().asSymbol()),\n+                                fai.name().stringValue(), map(fai.typeSymbol()));\n+                    case InvokeInstruction ii ->\n+                        cob.invokeInstruction(ii.opcode(), map(ii.owner().asSymbol()),\n+                                ii.name().stringValue(), mapMethodDesc(ii.typeSymbol()),\n+                                ii.isInterface());\n+                    case InvokeDynamicInstruction idi ->\n+                        cob.invokeDynamicInstruction(DynamicCallSiteDesc.of(\n+                                idi.bootstrapMethod(), idi.name().stringValue(),\n+                                mapMethodDesc(idi.typeSymbol())));\n+                    case NewObjectInstruction c ->\n+                        cob.newObjectInstruction(map(c.className().asSymbol()));\n+                    case NewReferenceArrayInstruction c ->\n+                        cob.anewarray(map(c.componentType().asSymbol()));\n+                    case NewMultiArrayInstruction c ->\n+                        cob.multianewarray(map(c.arrayType().asSymbol()), c.dimensions());\n+                    case TypeCheckInstruction c ->\n+                        cob.typeCheckInstruction(c.opcode(), map(c.type().asSymbol()));\n+                    case ExceptionCatch c ->\n+                        cob.exceptionCatch(c.tryStart(), c.tryEnd(), c.handler(),c.catchType()\n+                                .map(d -> TemporaryConstantPool.INSTANCE.classEntry(map(d.asSymbol()))));\n+                    case LocalVariable c ->\n+                        cob.localVariable(c.slot(), c.name().stringValue(), map(c.typeSymbol()),\n+                                c.startScope(), c.endScope());\n+                    case LocalVariableType c ->\n+                        cob.localVariableType(c.slot(), c.name().stringValue(),\n+                                mapSignature(c.signatureSymbol()), c.startScope(), c.endScope());\n+                    case LoadConstantInstruction ldc ->\n+                        cob.constantInstruction(ldc.opcode(),\n+                                mapConstantValue(ldc.constantValue()));\n+                    case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                        cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                mapTypeAnnotations(aa.annotations())));\n+                    case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                        cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                mapTypeAnnotations(aa.annotations())));\n+                    default ->\n+                        cob.with(coe);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public ClassDesc map(ClassDesc desc) {\n+            if (desc == null) return null;\n+            if (desc.isArray()) return map(desc.componentType()).arrayType();\n+            if (desc.isPrimitive()) return desc;\n+            return mapFunction.apply(desc);\n+        }\n+\n+        MethodTypeDesc mapMethodDesc(MethodTypeDesc desc) {\n+            return MethodTypeDesc.of(map(desc.returnType()),\n+                    desc.parameterList().stream().map(this::map).toArray(ClassDesc[]::new));\n+        }\n+\n+        ClassSignature mapClassSignature(ClassSignature signature) {\n+            return ClassSignature.of(mapTypeParams(signature.typeParameters()),\n+                    mapSignature(signature.superclassSignature()),\n+                    signature.superinterfaceSignatures().stream()\n+                            .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n+        }\n+\n+        MethodSignature mapMethodSignature(MethodSignature signature) {\n+            return MethodSignature.of(mapTypeParams(signature.typeParameters()),\n+                    signature.throwableSignatures().stream().map(this::mapSignature).toList(),\n+                    mapSignature(signature.result()),\n+                    signature.arguments().stream()\n+                            .map(this::mapSignature).toArray(Signature[]::new));\n+        }\n+\n+        RecordComponentInfo mapRecordComponent(RecordComponentInfo component) {\n+            return RecordComponentInfo.of(component.name().stringValue(),\n+                    map(component.descriptorSymbol()),\n+                    component.attributes().stream().map(atr ->\n+                        switch (atr) {\n+                            case SignatureAttribute sa ->\n+                                SignatureAttribute.of(\n+                                        mapSignature(sa.asTypeSignature()));\n+                            case RuntimeVisibleAnnotationsAttribute aa ->\n+                                RuntimeVisibleAnnotationsAttribute.of(\n+                                        mapAnnotations(aa.annotations()));\n+                            case RuntimeInvisibleAnnotationsAttribute aa ->\n+                                RuntimeInvisibleAnnotationsAttribute.of(\n+                                        mapAnnotations(aa.annotations()));\n+                            case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                                RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                        mapTypeAnnotations(aa.annotations()));\n+                            case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                                RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                        mapTypeAnnotations(aa.annotations()));\n+                            default -> atr;\n+                        }).toList());\n+        }\n+\n+        DirectMethodHandleDesc mapDirectMethodHandle(DirectMethodHandleDesc dmhd) {\n+            return switch (dmhd.kind()) {\n+                case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER ->\n+                    MethodHandleDesc.ofField(dmhd.kind(), map(dmhd.owner()),\n+                            dmhd.methodName(),\n+                            map(ClassDesc.ofDescriptor(dmhd.lookupDescriptor())));\n+                default ->\n+                    MethodHandleDesc.ofMethod(dmhd.kind(), map(dmhd.owner()),\n+                            dmhd.methodName(),\n+                            mapMethodDesc(MethodTypeDesc.ofDescriptor(dmhd.lookupDescriptor())));\n+            };\n+        }\n+\n+        ConstantDesc mapConstantValue(ConstantDesc value) {\n+            return switch (value) {\n+                case ClassDesc cd ->\n+                    map(cd);\n+                case DynamicConstantDesc<?> dcd ->\n+                    mapDynamicConstant(dcd);\n+                case DirectMethodHandleDesc dmhd ->\n+                    mapDirectMethodHandle(dmhd);\n+                case MethodTypeDesc mtd ->\n+                    mapMethodDesc(mtd);\n+                default -> value;\n+            };\n+        }\n+\n+        DynamicConstantDesc<?> mapDynamicConstant(DynamicConstantDesc<?> dcd) {\n+            return DynamicConstantDesc.ofNamed(mapDirectMethodHandle(dcd.bootstrapMethod()),\n+                    dcd.constantName(),\n+                    map(dcd.constantType()),\n+                    dcd.bootstrapArgsList().stream().map(this::mapConstantValue).toArray(ConstantDesc[]::new));\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <S extends Signature> S mapSignature(S signature) {\n+            return (S) switch (signature) {\n+                case Signature.ArrayTypeSig ats ->\n+                    Signature.ArrayTypeSig.of(mapSignature(ats.componentSignature()));\n+                case Signature.ClassTypeSig cts ->\n+                    Signature.ClassTypeSig.of(cts.outerType().map(this::mapSignature).orElse(null),\n+                            map(cts.classDesc()), cts.typeArgs().stream()\n+                                    .map(this::mapSignature).toArray(Signature[]::new));\n+                default -> signature;\n+            };\n+        }\n+\n+        List<Annotation> mapAnnotations(List<Annotation> annotations) {\n+            return annotations.stream().map(this::mapAnnotation).toList();\n+        }\n+\n+        Annotation mapAnnotation(Annotation a) {\n+            return Annotation.of(map(a.classSymbol()), a.elements().stream().map(el ->\n+                    AnnotationElement.of(el.name(), mapAnnotationValue(el.value()))).toList());\n+        }\n+\n+        AnnotationValue mapAnnotationValue(AnnotationValue val) {\n+            return switch (val) {\n+                case AnnotationValue.OfAnnotation oa ->\n+                    AnnotationValue.ofAnnotation(mapAnnotation(oa.annotation()));\n+                case AnnotationValue.OfArray oa ->\n+                    AnnotationValue.ofArray(oa.values().stream().map(this::mapAnnotationValue).toList());\n+                case AnnotationValue.OfConstant oc -> oc;\n+                case AnnotationValue.OfClass oc ->\n+                    AnnotationValue.ofClass(map(oc.classSymbol()));\n+                case AnnotationValue.OfEnum oe ->\n+                    AnnotationValue.ofEnum(map(oe.classSymbol()), oe.constantName().stringValue());\n+            };\n+        }\n+\n+        List<TypeAnnotation> mapTypeAnnotations(List<TypeAnnotation> typeAnnotations) {\n+            return typeAnnotations.stream().map(a -> TypeAnnotation.of(a.targetInfo(),\n+                    a.targetPath(), map(a.classSymbol()),\n+                    a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n+                            mapAnnotationValue(el.value()))).toList())).toList();\n+        }\n+\n+        List<Signature.TypeParam> mapTypeParams(List<Signature.TypeParam> typeParams) {\n+            return typeParams.stream().map(tp -> Signature.TypeParam.of(tp.identifier(),\n+                    tp.classBound().map(this::mapSignature),\n+                    tp.interfaceBounds().stream()\n+                            .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new))).toList();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassRemapper.java","additions":489,"deletions":0,"binary":false,"changes":489,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.components;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Arrays;\n+\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+\n+\/**\n+ * {@link CodeLocalsShifter} is a {@link CodeTransform} shifting locals to\n+ * newly allocated positions to avoid conflicts during code injection.\n+ * Locals pointing to the receiver or to method arguments slots are never shifted.\n+ * All locals pointing beyond the method arguments are re-indexed in order of appearance.\n+ *\/\n+public sealed interface CodeLocalsShifter extends CodeTransform {\n+\n+    \/**\n+     * Creates a new instance of {@link CodeLocalsShifter}\n+     * with fixed local slots calculated from provided method information\n+     * @param methodFlags flags of the method to construct {@link CodeLocalsShifter} for\n+     * @param methodDescriptor descriptor of the method to construct {@link CodeLocalsShifter} for\n+     * @return new instance of {@link CodeLocalsShifter}\n+     *\/\n+    static CodeLocalsShifter of(AccessFlags methodFlags, MethodTypeDesc methodDescriptor) {\n+        int fixed = methodFlags.has(AccessFlag.STATIC) ? 0 : 1;\n+        for (var param : methodDescriptor.parameterList())\n+            fixed += TypeKind.fromDescriptor(param.descriptorString()).slotSize();\n+        return new CodeLocalsShifterImpl(fixed);\n+    }\n+\n+    final static class CodeLocalsShifterImpl implements CodeLocalsShifter {\n+\n+        private int[] locals = new int[0];\n+        private final int fixed;\n+\n+        private CodeLocalsShifterImpl(int fixed) {\n+            this.fixed = fixed;\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case LoadInstruction li ->\n+                    cob.loadInstruction(\n+                            li.typeKind(),\n+                            shift(cob, li.slot(), li.typeKind()));\n+                case StoreInstruction si ->\n+                    cob.storeInstruction(\n+                            si.typeKind(),\n+                            shift(cob, si.slot(), si.typeKind()));\n+                case IncrementInstruction ii ->\n+                    cob.incrementInstruction(\n+                            shift(cob, ii.slot(), TypeKind.IntType),\n+                            ii.constant());\n+                case LocalVariable lv ->\n+                    cob.localVariable(\n+                            shift(cob, lv.slot(), TypeKind.fromDescriptor(lv.type().stringValue())),\n+                            lv.name(),\n+                            lv.type(),\n+                            lv.startScope(),\n+                            lv.endScope());\n+                case LocalVariableType lvt ->\n+                    cob.localVariableType(\n+                            shift(cob, lvt.slot(),\n+                                    (lvt.signatureSymbol() instanceof Signature.BaseTypeSig bsig)\n+                                            ? TypeKind.fromDescriptor(bsig.signatureString())\n+                                            : TypeKind.ReferenceType),\n+                            lvt.name(),\n+                            lvt.signature(),\n+                            lvt.startScope(),\n+                            lvt.endScope());\n+                default -> cob.with(coe);\n+            }\n+        }\n+\n+        private int shift(CodeBuilder cob, int slot, TypeKind tk) {\n+            if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n+            if (slot >= fixed) {\n+                int key = 2*slot - fixed + tk.slotSize() - 1;\n+                if (key >= locals.length) locals = Arrays.copyOf(locals, key + 20);\n+                slot = locals[key] - 1;\n+                if (slot < 0) {\n+                    slot = cob.allocateLocal(tk);\n+                    locals[key] = slot + 1;\n+                    if (tk.slotSize() == 2) locals[key - 1] = slot + 1;\n+                }\n+            }\n+            return slot;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeLocalsShifter.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.components;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.SwitchCase;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+\n+\/**\n+ * CodeRelabeler is a {@link jdk.internal.classfile.CodeTransform} replacing all occurrences\n+ * of {@link jdk.internal.classfile.Label} in the transformed code with new instances.\n+ * All {@link jdk.internal.classfile.instruction.LabelTarget} instructions are adjusted accordingly.\n+ * Relabeled code graph is identical to the original.\n+ * <p>\n+ * Primary purpose of CodeRelabeler is for repeated injections of the same code blocks.\n+ * Repeated injection of the same code block must be relabeled, so each instance of\n+ * {@link jdk.internal.classfile.Label} is bound in the target bytecode exactly once.\n+ *\/\n+public sealed interface CodeRelabeler extends CodeTransform {\n+\n+    \/**\n+     * Creates new instance of CodeRelabeler\n+     * @return new instance of CodeRelabeler\n+     *\/\n+    static CodeRelabeler of() {\n+        return of(new IdentityHashMap<>());\n+    }\n+\n+    \/**\n+     * Creates new instance of CodeRelabeler storing the label mapping into the provided map\n+     * @param map label map actively used for relabeling\n+     * @return new instance of CodeRelabeler\n+     *\/\n+    static CodeRelabeler of(Map<Label, Label> map) {\n+        return of((l, cob) -> map.computeIfAbsent(l, ll -> cob.newLabel()));\n+    }\n+\n+    \/**\n+     * Creates new instance of CodeRelabeler using provided {@link java.util.function.BiFunction}\n+     * to re-label the code.\n+     * @param mapFunction\n+     * @return\n+     *\/\n+    static CodeRelabeler of(BiFunction<Label, CodeBuilder, Label> mapFunction) {\n+        return new CodeRelabelerImpl(mapFunction);\n+    }\n+\n+    \/**\n+     * Access method to internal re-labeling function.\n+     * @param label source label\n+     * @param codeBuilder builder to create new labels\n+     * @return target label\n+     *\/\n+    Label relabel(Label label, CodeBuilder codeBuilder);\n+\n+    record CodeRelabelerImpl(BiFunction<Label, CodeBuilder, Label> mapFunction) implements  CodeRelabeler {\n+\n+        @Override\n+        public Label relabel(Label label, CodeBuilder cob) {\n+            return mapFunction.apply(label, cob);\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case BranchInstruction bi ->\n+                    cob.branchInstruction(\n+                            bi.opcode(),\n+                            relabel(bi.target(), cob));\n+                case LookupSwitchInstruction lsi ->\n+                    cob.lookupSwitchInstruction(\n+                            relabel(lsi.defaultTarget(), cob),\n+                            lsi.cases().stream().map(c ->\n+                                    SwitchCase.of(\n+                                            c.caseValue(),\n+                                            relabel(c.target(), cob))).toList());\n+                case TableSwitchInstruction tsi ->\n+                    cob.tableSwitchInstruction(\n+                            tsi.lowValue(),\n+                            tsi.highValue(),\n+                            relabel(tsi.defaultTarget(), cob),\n+                            tsi.cases().stream().map(c ->\n+                                    SwitchCase.of(\n+                                            c.caseValue(),\n+                                            relabel(c.target(), cob))).toList());\n+                case LabelTarget lt ->\n+                    cob.labelBinding(\n+                            relabel(lt.label(), cob));\n+                case ExceptionCatch ec ->\n+                    cob.exceptionCatch(\n+                            relabel(ec.tryStart(), cob),\n+                            relabel(ec.tryEnd(), cob),\n+                            relabel(ec.handler(), cob),\n+                            ec.catchType());\n+                case LocalVariable lv ->\n+                    cob.localVariable(\n+                            lv.slot(),\n+                            lv.name().stringValue(),\n+                            lv.typeSymbol(),\n+                            relabel(lv.startScope(), cob),\n+                            relabel(lv.endScope(), cob));\n+                case LocalVariableType lvt ->\n+                    cob.localVariableType(\n+                            lvt.slot(),\n+                            lvt.name().stringValue(),\n+                            lvt.signatureSymbol(),\n+                            relabel(lvt.startScope(), cob),\n+                            relabel(lvt.endScope(), cob));\n+                default ->\n+                    cob.with(coe);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeRelabeler.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.components;\n+\n+import java.util.AbstractCollection;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.*;\n+\n+\/**\n+ * {@link CodeStackTracker} is a {@link CodeTransform} tracking stack content\n+ * and calculating max stack size.\n+ * <p>\n+ * Sample use:\n+ * <p>\n+ * {@snippet lang=java :\n+ *     var stackTracker = CodeStackTracker.of();\n+ *     codeBuilder.transforming(stackTracker, trackedBuilder -> {\n+ *         trackedBuilder.aload(0);\n+ *         trackedBuilder.lconst_0();\n+ *         trackedBuilder.ifThen(...);\n+ *         ...\n+ *         var stack = stackTracker.stack().get();\n+ *         int maxStack = stackTracker.maxStackSize().get();\n+ *     });\n+ * }\n+ *\/\n+public sealed interface CodeStackTracker extends CodeTransform {\n+\n+    \/**\n+     * Creates new instance of {@link CodeStackTracker} initialized with provided stack items\n+     * @param initialStack initial stack content\n+     * @return new instance of {@link CodeStackTracker}\n+     *\/\n+    static CodeStackTracker of(TypeKind... initialStack) {\n+        return new CodeStackTrackerImpl(initialStack);\n+    }\n+\n+    \/**\n+      * Returns {@linkplain Collection} of {@linkplain TypeKind} representing current stack.\n+      * Returns an empty {@linkplain Optional} when the Stack content is unknown\n+      * (right after {@code xRETURN, ATHROW, GOTO, GOTO_W, LOOKUPSWITCH, TABLESWITCH} instructions).\n+      *\n+      * Temporary unknown stack content can be recovered by binding of a {@linkplain Label} used as\n+      * target of a branch instruction from existing code with known stack (forward branch target),\n+      * or by binding of a {@linkplain Label} defining an exception handler (exception handler code start).\n+      *\n+      * @return actual stack content, or an empty {@linkplain Optional} if unknown\n+      *\/\n+    Optional<Collection<TypeKind>> stack();\n+\n+    \/**\n+      * Returns tracked max stack size.\n+      * Returns an empty {@linkplain Optional} when max stack size tracking has been lost.\n+      *\n+      * Max stack size tracking is permanently lost when a stack instruction appears\n+      * and the actual stack content is unknown.\n+      *\n+      * @return tracked max stack size, or an empty {@linkplain Optional} if tracking has been lost\n+      *\/\n+    Optional<Integer> maxStackSize();\n+\n+    final static class CodeStackTrackerImpl implements CodeStackTracker {\n+\n+        private static record Item(TypeKind type, Item next) {\n+        }\n+\n+        private final class Stack extends AbstractCollection<TypeKind> {\n+\n+            private Item top;\n+            private int count, realSize;\n+\n+            Stack(Item top, int count, int realSize) {\n+                this.top = top;\n+                this.count = count;\n+                this.realSize = realSize;\n+            }\n+\n+            @Override\n+            public Iterator<TypeKind> iterator() {\n+                return new Iterator<TypeKind>() {\n+                    Item i = top;\n+\n+                    @Override\n+                    public boolean hasNext() {\n+                        return i != null;\n+                    }\n+\n+                    @Override\n+                    public TypeKind next() {\n+                        if (i == null) {\n+                            throw new NoSuchElementException();\n+                        }\n+                        var t = i.type;\n+                        i = i.next;\n+                        return t;\n+                    }\n+                };\n+            }\n+\n+            @Override\n+            public int size() {\n+                return count;\n+            }\n+\n+            private void push(TypeKind type) {\n+                top = new Item(type, top);\n+                realSize += type.slotSize();\n+                count++;\n+                if (maxSize != null && realSize > maxSize) maxSize = realSize;\n+            }\n+\n+            private TypeKind pop() {\n+                var t = top.type;\n+                realSize -= t.slotSize();\n+                count--;\n+                top = top.next;\n+                return t;\n+            }\n+        }\n+\n+        private Stack stack = new Stack(null, 0, 0);\n+        private Integer maxSize = 0;\n+\n+        CodeStackTrackerImpl(TypeKind... initialStack) {\n+            for (int i = initialStack.length - 1; i >= 0; i--)\n+                push(initialStack[i]);\n+        }\n+\n+        @Override\n+        public Optional<Collection<TypeKind>> stack() {\n+            return Optional.ofNullable(fork());\n+        }\n+\n+        @Override\n+        public Optional<Integer> maxStackSize() {\n+            return Optional.ofNullable(maxSize);\n+        }\n+\n+        private Map<Label, Stack> map = new HashMap<>();\n+\n+        private void push(TypeKind type) {\n+            if (stack != null) {\n+                if (type != TypeKind.VoidType) stack.push(type);\n+            } else {\n+                maxSize = null;\n+            }\n+        }\n+\n+        private void pop(int i) {\n+            if (stack != null) {\n+                while (i-- > 0) stack.pop();\n+            } else {\n+                maxSize = null;\n+            }\n+        }\n+\n+        private Stack fork() {\n+            return stack == null ? null : new Stack(stack.top, stack.count, stack.realSize);\n+        }\n+\n+        private void withStack(Consumer<Stack> c) {\n+            if (stack != null) c.accept(stack);\n+            else maxSize = null;\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder cb, CodeElement el) {\n+            cb.with(el);\n+            switch (el) {\n+                case ArrayLoadInstruction i -> {\n+                    pop(2);push(i.typeKind());\n+                }\n+                case ArrayStoreInstruction i ->\n+                    pop(3);\n+                case BranchInstruction i -> {\n+                    if (i.opcode() == Opcode.GOTO || i.opcode() == Opcode.GOTO_W) {\n+                        map.put(i.target(), stack);\n+                        stack = null;\n+                    } else {\n+                        pop(1);\n+                        map.put(i.target(), fork());\n+                    }\n+                }\n+                case ConstantInstruction i ->\n+                    push(i.typeKind());\n+                case ConvertInstruction i -> {\n+                    pop(1);push(i.toType());\n+                }\n+                case FieldInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case GETSTATIC ->\n+                            push(TypeKind.fromDescriptor(i.type().stringValue()));\n+                        case GETFIELD -> {\n+                            pop(1);push(TypeKind.fromDescriptor(i.type().stringValue()));\n+                        }\n+                        case PUTSTATIC ->\n+                            pop(1);\n+                        case PUTFIELD ->\n+                            pop(2);\n+                    }\n+                }\n+                case InvokeDynamicInstruction i -> {\n+                    var type = i.typeSymbol();\n+                    pop(type.parameterCount());\n+                    push(TypeKind.fromDescriptor(type.returnType().descriptorString()));\n+                }\n+                case InvokeInstruction i -> {\n+                    var type = i.typeSymbol();\n+                    pop(type.parameterCount());\n+                    if (i.opcode() != Opcode.INVOKESTATIC) pop(1);\n+                    push(TypeKind.fromDescriptor(type.returnType().descriptorString()));\n+                }\n+                case LoadInstruction i ->\n+                    push(i.typeKind());\n+                case StoreInstruction i ->\n+                    pop(1);\n+                case LookupSwitchInstruction i -> {\n+                    map.put(i.defaultTarget(), stack);\n+                    for (var c : i.cases()) map.put(c.target(), fork());\n+                    stack = null;\n+                }\n+                case MonitorInstruction i ->\n+                    pop(1);\n+                case NewMultiArrayInstruction i -> {\n+                    pop(i.dimensions());push(TypeKind.ReferenceType);\n+                }\n+                case NewObjectInstruction i ->\n+                    push(TypeKind.ReferenceType);\n+                case NewPrimitiveArrayInstruction i -> {\n+                    pop(1);push(TypeKind.ReferenceType);\n+                }\n+                case NewReferenceArrayInstruction i -> {\n+                    pop(1);push(TypeKind.ReferenceType);\n+                }\n+                case NopInstruction i -> {}\n+                case OperatorInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> pop(1);\n+                        default -> pop(2);\n+                    }\n+                    push(i.typeKind());\n+                }\n+                case ReturnInstruction i ->\n+                    stack = null;\n+                case StackInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case POP -> pop(1);\n+                        case POP2 -> withStack(s -> {\n+                            if (s.pop().slotSize() == 1) s.pop();\n+                        });\n+                        case DUP ->  withStack(s -> {\n+                            var v = s.pop();s.push(v);s.push(v);\n+                        });\n+                        case DUP2 -> withStack(s -> {\n+                            var v1 = s.pop();\n+                            if (v1.slotSize() == 1) {\n+                                var v2 = s.pop();\n+                                s.push(v2);s.push(v1);\n+                                s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v1);s.push(v1);\n+                            }\n+                        });\n+                        case DUP_X1 -> withStack(s -> {\n+                            var v1 = s.pop();\n+                            var v2 = s.pop();\n+                            s.push(v1);s.push(v2);s.push(v1);\n+                        });\n+                        case DUP_X2 -> withStack(s -> {\n+                            var v1 = s.pop();\n+                            var v2 = s.pop();\n+                            if (v2.slotSize() == 1) {\n+                                var v3 = s.pop();\n+                                s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v1);s.push(v2);s.push(v1);\n+                            }\n+                        });\n+                        case DUP2_X1 -> withStack(s -> {\n+                            var v1 = s.pop();\n+                            var v2 = s.pop();\n+                            if (v1.slotSize() == 1) {\n+                                var v3 = s.pop();\n+                                s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                            } else {\n+                                s.push(v1);s.push(v2);s.push(v1);\n+                            }\n+                        });\n+                        case DUP2_X2 -> withStack(s -> {\n+                            var v1 = s.pop();\n+                            var v2 = s.pop();\n+                            if (v1.slotSize() == 1) {\n+                                var v3 = s.pop();\n+                                if (v3.slotSize() == 1) {\n+                                    var v4 = s.pop();\n+                                    s.push(v2);s.push(v1);s.push(v4);s.push(v3);s.push(v2);s.push(v1);\n+                                } else {\n+                                    s.push(v2);s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                                }\n+                            } else {\n+                                if (v2.slotSize() == 1) {\n+                                    var v3 = s.pop();\n+                                    s.push(v1);s.push(v3);s.push(v2);s.push(v1);\n+                                } else {\n+                                    s.push(v1);s.push(v2);s.push(v1);\n+                                }\n+                            }\n+                        });\n+                        case SWAP -> withStack(s -> {\n+                            var v1 = s.pop();\n+                            var v2 = s.pop();\n+                            s.push(v1);s.push(v2);\n+                        });\n+                    }\n+                }\n+                case TableSwitchInstruction i -> {\n+                    map.put(i.defaultTarget(), stack);\n+                    for (var c : i.cases()) map.put(c.target(), fork());\n+                    stack = null;\n+                }\n+                case ThrowInstruction i ->\n+                    stack = null;\n+                case TypeCheckInstruction i -> {\n+                    switch (i.opcode()) {\n+                        case CHECKCAST -> {\n+                            pop(1);push(TypeKind.ReferenceType);\n+                        }\n+                        case INSTANCEOF -> {\n+                            pop(1);push(TypeKind.IntType);\n+                        }\n+                    }\n+                }\n+                case ExceptionCatch i ->\n+                    map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n+                case LabelTarget i ->\n+                    stack = map.getOrDefault(i.label(), stack);\n+                default -> {}\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/CodeStackTracker.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * <h2>Specific components, transformations, and tools built on top of the Classfile API<\/h2>\n+ *\n+ * The {@code jdk.internal.classfile.components} package contains specific transformation components\n+ * and utility classes helping to compose very complex tasks with minimal effort.\n+ *\n+ * <h3>{@link ClassPrinter}<\/h3>\n+ * <p>\n+ * {@link ClassPrinter} is a helper class providing seamless export of a {@link jdk.internal.classfile.ClassModel},\n+ * {@link jdk.internal.classfile.FieldModel}, {@link jdk.internal.classfile.MethodModel}, or {@link jdk.internal.classfile.CodeModel}\n+ * into human-readable structured text in JSON, XML, or YAML format, or into a tree of traversable and printable nodes.\n+ * <p>\n+ * Primary purpose of {@link ClassPrinter} is to provide human-readable class info for debugging,\n+ * exception handling and logging purposes. The printed class also conforms to a standard format\n+ * to support automated offline processing.\n+ * <p>\n+ * The most frequent use case is to simply print a class:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"printClass\"}\n+ * <p>\n+ * {@link ClassPrinter} allows to traverse tree of simple printable nodes to hook custom printer:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"customPrint\"}\n+ * <p>\n+ * Another use case for {@link ClassPrinter} is to simplify writing of automated tests:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"printNodesInTest\"}\n+ *\n+ * <h3>{@link ClassRemapper}<\/h3>\n+ * ClassRemapper is a {@link jdk.internal.classfile.ClassTransform}, {@link jdk.internal.classfile.FieldTransform},\n+ * {@link jdk.internal.classfile.MethodTransform} and {@link jdk.internal.classfile.CodeTransform}\n+ * deeply re-mapping all class references in any form, according to given map or map function.\n+ * <p>\n+ * The re-mapping is applied to superclass, interfaces, all kinds of descriptors and signatures,\n+ * all attributes referencing classes in any form (including all types of annotations),\n+ * and to all instructions referencing to classes.\n+ * <p>\n+ * Primitive types and arrays are never subjects of mapping and are not allowed targets of mapping.\n+ * <p>\n+ * Arrays of reference types are always decomposed, mapped as the base reference types and composed back to arrays.\n+ * <p>\n+ * Single class remappigng example:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"singleClassRemap\"}\n+ * <p>\n+ * Remapping of all classes under specific package:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"allPackageRemap\"}\n+ *\n+ * <h3>{@link CodeLocalsShifter}<\/h3>\n+ * {@link CodeLocalsShifter} is a {@link jdk.internal.classfile.CodeTransform} shifting locals to\n+ * newly allocated positions to avoid conflicts during code injection.\n+ * Locals pointing to the receiver or to method arguments slots are never shifted.\n+ * All locals pointing beyond the method arguments are re-indexed in order of appearance.\n+ * <p>\n+ * Sample of code transformation shifting all locals in all methods:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeLocalsShifting\"}\n+ *\n+ * <h3>{@link CodeRelabeler}<\/h3>\n+ * {@link CodeRelabeler} is a {@link jdk.internal.classfile.CodeTransform} replacing all occurences\n+ * of {@link jdk.internal.classfile.Label} in the transformed code with new instances.\n+ * All {@link jdk.internal.classfile.instruction.LabelTarget} instructions are adjusted accordingly.\n+ * Relabeled code graph is identical to the original.\n+ * <p>\n+ * Primary purpose of {@link CodeRelabeler} is for repeated injections of the same code blocks.\n+ * Repeated injection of the same code block must be relabeled, so each instance of\n+ * {@link jdk.internal.classfile.Label} is bound in the target bytecode exactly once.\n+ * <p>\n+ * Sample transformation relabeling all methods:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"codeRelabeling\"}\n+ *\n+ * <h3>Class Instrumentation Sample<\/h3>\n+ * Following snippet is sample composition of {@link ClassRemapper}, {@link CodeLocalsShifter}\n+ * and {@link CodeRelabeler} into fully functional class instrumenting transformation:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"classInstrumentation\"}\n+ *\/\n+package jdk.internal.classfile.components;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/package-info.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+\n+import java.lang.reflect.AccessFlag;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+\n+class PackageSnippets {\n+\n+    void printClass(ClassModel classModel) {\n+        \/\/ @start region=\"printClass\"\n+        ClassPrinter.toJson(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        \/\/ @end\n+    }\n+\n+    \/\/ @start region=\"customPrint\"\n+    void customPrint(ClassModel classModel) {\n+        print(ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL));\n+    }\n+\n+    void print(ClassPrinter.Node node) {\n+        switch (node) {\n+            case ClassPrinter.MapNode mn -> {\n+                \/\/ print map header\n+                mn.values().forEach(this::print);\n+            }\n+            case ClassPrinter.ListNode ln -> {\n+                \/\/ print list header\n+                ln.forEach(this::print);\n+            }\n+            case ClassPrinter.LeafNode n -> {\n+                \/\/ print leaf node\n+            }\n+        }\n+    }\n+    \/\/ @end\n+\n+    \/\/ @start region=\"printNodesInTest\"\n+    @Test\n+    void printNodesInTest(ClassModel classModel) {\n+        var classNode = ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL);\n+        assertContains(classNode, \"method name\", \"myFooMethod\");\n+        assertContains(classNode, \"field name\", \"myBarField\");\n+        assertContains(classNode, \"inner class\", \"MyInnerFooClass\");\n+    }\n+\n+    void assertContains(ClassPrinter.Node node, ConstantDesc key, ConstantDesc value) {\n+        if (!node.walk().anyMatch(n -> n instanceof ClassPrinter.LeafNode ln\n+                               && ln.name().equals(key)\n+                               && ln.value().equals(value))) {\n+            node.toYaml(System.out::print);\n+            throw new AssertionError(\"expected %s: %s\".formatted(key, value));\n+        }\n+    }\n+    \/\/ @end\n+    @interface Test{}\n+\n+    void singleClassRemap(ClassModel... allMyClasses) {\n+        \/\/ @start region=\"singleClassRemap\"\n+        var classRemapper = ClassRemapper.of(\n+                Map.of(ClassDesc.of(\"Foo\"), ClassDesc.of(\"Bar\")));\n+\n+        for (var classModel : allMyClasses) {\n+            byte[] newBytes = classRemapper.remapClass(classModel);\n+\n+        }\n+        \/\/ @end\n+    }\n+\n+    void allPackageRemap(ClassModel... allMyClasses) {\n+        \/\/ @start region=\"allPackageRemap\"\n+        var classRemapper = ClassRemapper.of(cd ->\n+                ClassDesc.ofDescriptor(cd.descriptorString().replace(\"Lcom\/oldpackage\/\", \"Lcom\/newpackage\/\")));\n+\n+        for (var classModel : allMyClasses) {\n+            byte[] newBytes = classRemapper.remapClass(classModel);\n+\n+        }\n+        \/\/ @end\n+    }\n+\n+    void codeLocalsShifting(ClassModel classModel) {\n+        \/\/ @start region=\"codeLocalsShifting\"\n+        byte[] newBytes = classModel.transform((classBuilder, classElement) -> {\n+                if (classElement instanceof MethodModel method)\n+                    classBuilder.transformMethod(method,\n+                            MethodTransform.transformingCode(\n+                                    CodeLocalsShifter.of(method.flags(), method.methodTypeSymbol())));\n+                else\n+                    classBuilder.accept(classElement);\n+            });\n+        \/\/ @end\n+    }\n+\n+    void codeRelabeling(ClassModel classModel) {\n+        \/\/ @start region=\"codeRelabeling\"\n+        byte[] newBytes = classModel.transform(\n+                ClassTransform.transformingMethodBodies(\n+                        CodeTransform.ofStateful(CodeRelabeler::of)));\n+        \/\/ @end\n+    }\n+\n+    \/\/ @start region=\"classInstrumentation\"\n+    byte[] classInstrumentation(ClassModel target, ClassModel instrumentor, Predicate<MethodModel> instrumentedMethodsFilter) {\n+        var instrumentorCodeMap = instrumentor.methods().stream()\n+                                              .filter(instrumentedMethodsFilter)\n+                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElse(null)));\n+        var targetFieldNames = target.fields().stream().map(f -> f.fieldName().stringValue()).collect(Collectors.toSet());\n+        var targetMethods = target.methods().stream().map(m -> m.methodName().stringValue() + m.methodType().stringValue()).collect(Collectors.toSet());\n+        var instrumentorClassRemapper = ClassRemapper.of(Map.of(instrumentor.thisClass().asSymbol(), target.thisClass().asSymbol()));\n+        return target.transform(\n+                ClassTransform.transformingMethods(\n+                        instrumentedMethodsFilter,\n+                        (mb, me) -> {\n+                            if (me instanceof CodeModel targetCodeModel) {\n+                                var mm = targetCodeModel.parent().get();\n+                                \/\/instrumented methods code is taken from instrumentor\n+                                mb.transformCode(instrumentorCodeMap.get(mm.methodName().stringValue() + mm.methodType().stringValue()),\n+                                        \/\/all references to the instrumentor class are remapped to target class\n+                                        instrumentorClassRemapper.asCodeTransform()\n+                                        .andThen((codeBuilder, instrumentorCodeElement) -> {\n+                                            \/\/all invocations of target methods from instrumentor are inlined\n+                                            if (instrumentorCodeElement instanceof InvokeInstruction inv\n+                                                && target.thisClass().asInternalName().equals(inv.owner().asInternalName())\n+                                                && mm.methodName().stringValue().equals(inv.name().stringValue())\n+                                                && mm.methodType().stringValue().equals(inv.type().stringValue())) {\n+\n+                                                \/\/store stacked method parameters into locals\n+                                                var storeStack = new LinkedList<StoreInstruction>();\n+                                                int slot = 0;\n+                                                if (!mm.flags().has(AccessFlag.STATIC))\n+                                                    storeStack.add(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                for (var pt : mm.methodTypeSymbol().parameterList()) {\n+                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    storeStack.addFirst(StoreInstruction.of(tk, slot));\n+                                                    slot += tk.slotSize();\n+                                                }\n+                                                storeStack.forEach(codeBuilder::with);\n+\n+                                                \/\/inlined target locals must be shifted based on the actual instrumentor locals\n+                                                codeBuilder.block(inlinedBlockBuilder -> inlinedBlockBuilder\n+                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                        .andThen(CodeRelabeler.of())\n+                                                        .andThen((innerBuilder, shiftedTargetCode) -> {\n+                                                            \/\/returns must be replaced with jump to the end of the inlined method\n+                                                            if (shiftedTargetCode instanceof ReturnInstruction)\n+                                                                innerBuilder.goto_(inlinedBlockBuilder.breakLabel());\n+                                                            else\n+                                                                innerBuilder.with(shiftedTargetCode);\n+                                                        })));\n+                                            } else\n+                                                codeBuilder.with(instrumentorCodeElement);\n+                                        }));\n+                            } else\n+                                mb.with(me);\n+                        })\n+                .andThen(ClassTransform.endHandler(clb ->\n+                    \/\/remaining instrumentor fields and methods are injected at the end\n+                    clb.transform(instrumentor,\n+                            ClassTransform.dropping(cle ->\n+                                    !(cle instanceof FieldModel fm\n+                                            && !targetFieldNames.contains(fm.fieldName().stringValue()))\n+                                    && !(cle instanceof MethodModel mm\n+                                            && !\"<init>\".equals(mm.methodName().stringValue())\n+                                            && !targetMethods.contains(mm.methodName().stringValue() + mm.methodType().stringValue())))\n+                            \/\/and instrumentor class references remapped to target class\n+                            .andThen(instrumentorClassRemapper)))));\n+    }\n+    \/\/ @end\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.ConstantDesc;\n+\n+\/**\n+ * A constant pool entry that may be used as an annotation constant,\n+ * which includes the four kinds of primitive constants, and UTF8 constants.\n+ *\/\n+public sealed interface AnnotationConstantValueEntry extends PoolEntry\n+        permits DoubleEntry, FloatEntry, IntegerEntry, LongEntry, Utf8Entry {\n+\n+    \/**\n+     * {@return the constant value}  The constant value will be an {@link Integer},\n+     * {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n+     *\/\n+    ConstantDesc constantValue();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/AnnotationConstantValueEntry.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.Util;\n+\n+\n+\/**\n+ * Models a {@code CONSTANT_Class_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface ClassEntry\n+        extends LoadableConstantEntry\n+        permits ConcreteEntry.ConcreteClassEntry {\n+\n+    @Override\n+    default ConstantDesc constantValue() {\n+        return asSymbol();\n+    }\n+\n+    \/**\n+     * {@return the UTF8 constant pool entry for the class name}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the class name, as an internal binary name}\n+     *\/\n+    String asInternalName();\n+\n+    \/**\n+     * {@return the class name, as a symbolic descriptor}\n+     *\/\n+    ClassDesc asSymbol();\n+\n+    \/**\n+     * Return a {@link List} composed by appending the additions to the base list.\n+     * @param base The base elements for the list, must not include null\n+     * @param additions The {@link ClassEntry} instances to add to the list, must not include null\n+     * @return the combined {@link List}\n+     *\/\n+    static List<ClassEntry> adding(List<ClassEntry> base, List<ClassEntry> additions) {\n+        ArrayList<ClassEntry> members = new ArrayList<>(base);\n+        members.addAll(additions);\n+        return List.copyOf(members);\n+    }\n+\n+    \/**\n+     * Return a {@link List} composed by appending the additions to the base list.\n+     * @param base The base elements for the list, must not include null\n+     * @param additions The {@link ClassEntry} instances to add to the list, must not include null\n+     * @return the combined {@link List}\n+     *\/\n+    static List<ClassEntry> adding(List<ClassEntry> base, ClassEntry... additions) {\n+        ArrayList<ClassEntry> members = new ArrayList<>(base);\n+        for (ClassEntry e : additions) {\n+            members.add(e);\n+        }\n+        return List.copyOf(members);\n+    }\n+\n+    \/**\n+     * Return a {@link List} composed by appending the additions to the base list.\n+     * @param base The base elements for the list, must not include null\n+     * @param additions The {@link ClassDesc} instances to add to the list, must not include null\n+     * @return the combined {@link List}\n+     *\/\n+    static List<ClassEntry> addingSymbols(List<ClassEntry> base, List<ClassDesc> additions) {\n+        ArrayList<ClassEntry> members = new ArrayList<>(base);\n+        members.addAll(Util.entryList(additions));\n+        return List.copyOf(members);\n+    }\n+\n+      \/**\n+     * Return a {@link List} composed by appending the additions to the base list.\n+     * @param base The base elements for the list, must not include null\n+     * @param additions The {@link ClassDesc} instances to add to the list, must not include null\n+     * @return the combined {@link List}\n+     *\/\n+    static List<ClassEntry> addingSymbols(List<ClassEntry> base, ClassDesc...additions) {\n+        ArrayList<ClassEntry> members = new ArrayList<>(base);\n+        for (ClassDesc e : additions) {\n+            members.add(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(e))));\n+        }\n+        return List.copyOf(members);\n+    }\n+\n+    \/**\n+     * Remove duplicate {@link ClassEntry} elements from the {@link List}.\n+     *\n+     * @param original The list to deduplicate\n+     * @return a {@link List} without any duplicate {@link ClassEntry}\n+     *\/\n+    static List<ClassEntry> deduplicate(List<ClassEntry> original) {\n+        ArrayList<ClassEntry> newList = new ArrayList<>(original.size());\n+        for (ClassEntry e : original) {\n+            if (!newList.contains(e)) {\n+                newList.add(e);\n+            }\n+        }\n+        return List.copyOf(newList);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ClassEntry.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_Dynamic_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface ConstantDynamicEntry\n+        extends DynamicConstantPoolEntry, LoadableConstantEntry\n+        permits ConcreteEntry.ConcreteConstantDynamicEntry {\n+\n+    \/**\n+     * {@return the symbolic descriptor for the {@code invokedynamic} constant}\n+     *\/\n+    default DynamicConstantDesc<?> asSymbol() {\n+        return DynamicConstantDesc.ofNamed(bootstrap().bootstrapMethod().asSymbol(),\n+                                           name().stringValue(),\n+                                           ClassDesc.ofDescriptor(type().stringValue()),\n+                                           bootstrap().arguments().stream()\n+                                                      .map(LoadableConstantEntry::constantValue)\n+                                                      .toArray(ConstantDesc[]::new));\n+    }\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    default TypeKind typeKind() {\n+        return TypeKind.fromDescriptor(type().stringValue());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.impl.ClassReaderImpl;\n+\n+import static jdk.internal.classfile.Classfile.TAG_CLASS;\n+import static jdk.internal.classfile.Classfile.TAG_CONSTANTDYNAMIC;\n+import static jdk.internal.classfile.Classfile.TAG_DOUBLE;\n+import static jdk.internal.classfile.Classfile.TAG_FIELDREF;\n+import static jdk.internal.classfile.Classfile.TAG_FLOAT;\n+import static jdk.internal.classfile.Classfile.TAG_INTEGER;\n+import static jdk.internal.classfile.Classfile.TAG_INTERFACEMETHODREF;\n+import static jdk.internal.classfile.Classfile.TAG_INVOKEDYNAMIC;\n+import static jdk.internal.classfile.Classfile.TAG_LONG;\n+import static jdk.internal.classfile.Classfile.TAG_METHODHANDLE;\n+import static jdk.internal.classfile.Classfile.TAG_METHODREF;\n+import static jdk.internal.classfile.Classfile.TAG_METHODTYPE;\n+import static jdk.internal.classfile.Classfile.TAG_MODULE;\n+import static jdk.internal.classfile.Classfile.TAG_NAMEANDTYPE;\n+import static jdk.internal.classfile.Classfile.TAG_PACKAGE;\n+import static jdk.internal.classfile.Classfile.TAG_STRING;\n+import static jdk.internal.classfile.Classfile.TAG_UTF8;\n+\n+\/**\n+ * Provides read access to the constant pool and bootstrap method table of a\n+ * classfile.\n+ *\/\n+public sealed interface ConstantPool\n+        permits ClassReader, ConstantPoolBuilder {\n+\n+    \/**\n+     * {@return the entry at the specified index}\n+     *\n+     * @param index the index within the pool of the desired entry\n+     *\/\n+    PoolEntry entryByIndex(int index);\n+\n+    \/**\n+     * {@return the number of entries in the constant pool}\n+     *\/\n+    int entryCount();\n+\n+    \/**\n+     * {@return the {@link BootstrapMethodEntry} at the specified index within\n+     * the bootstrap method table}\n+     *\n+     * @param index the index within the bootstrap method table of the desired\n+     *              entry\n+     *\/\n+    BootstrapMethodEntry bootstrapMethodEntry(int index);\n+\n+    \/**\n+     * {@return the number of entries in the bootstrap method table}\n+     *\/\n+    int bootstrapMethodCount();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPool.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,555 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.impl.ClassReaderImpl;\n+import jdk.internal.classfile.impl.Options;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import jdk.internal.classfile.WritableElement;\n+import jdk.internal.classfile.impl.SplitConstantPool;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Builder for the constant pool of a classfile.  Provides read and write access\n+ * to the constant pool that is being built.  Writing is append-only and idempotent\n+ * (entry-bearing methods will return an existing entry if there is one).\n+ *\n+ * A {@linkplain ConstantPoolBuilder} is associated with a {@link ClassBuilder}.\n+ * The {@linkplain ConstantPoolBuilder} also provides access to some of the\n+ * state of the {@linkplain ClassBuilder}, such as classfile processing options.\n+ *\/\n+public sealed interface ConstantPoolBuilder\n+        extends ConstantPool, WritableElement<ConstantPool>\n+        permits SplitConstantPool, TemporaryConstantPool {\n+\n+    \/**\n+     * {@return a new constant pool builder}  The new constant pool builder\n+     * will inherit the classfile processing options of the specified class.\n+     * If the processing options include {@link Classfile.Option#constantPoolSharing(boolean)},\n+     * (the default) the new constant pool builder will be also be pre-populated with the\n+     * contents of the constant pool associated with the class reader.\n+     *\n+     * @param classModel the class to copy from\n+     *\/\n+    static ConstantPoolBuilder of(ClassModel classModel) {\n+        ClassReaderImpl reader = (ClassReaderImpl) classModel.constantPool();\n+        return reader.options().cpSharing\n+          ? new SplitConstantPool(reader)\n+          : new SplitConstantPool(reader.options());\n+    }\n+\n+    \/**\n+     * {@return a new constant pool builder}  The new constant pool builder\n+     * will be empty and have the specified classfile processing options.\n+     *\n+     * @param options the processing options\n+     *\/\n+    static ConstantPoolBuilder of(Collection<Classfile.Option> options) {\n+        return new SplitConstantPool(new Options(options));\n+    }\n+\n+    \/**\n+     * {@return whether the provided constant pool is index-compatible with this\n+     * one}  This may be because they are the same constant pool, or because this\n+     * constant pool was copied from the other.\n+     *\n+     * @param constantPool the other constant pool\n+     *\/\n+    boolean canWriteDirect(ConstantPool constantPool);\n+\n+    \/**\n+     * Writes associated bootstrap method entries to the specified writer\n+     *\n+     * @param buf the writer\n+     * @return false when no bootstrap method entry has been written\n+     *\/\n+    boolean writeBootstrapMethods(BufWriter buf);\n+\n+    \/**\n+     * {@return A {@link Utf8Entry} describing the provided {@linkplain String}}\n+     * If a UTF8 entry in the pool already describes this string, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param s the string\n+     *\/\n+    Utf8Entry utf8Entry(String s);\n+\n+    \/**\n+     * {@return A {@link Utf8Entry} describing the field descriptor of the provided\n+     * {@linkplain ClassDesc}}\n+     * If a UTF8 entry in the pool already describes this field descriptor, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param desc the symbolic descriptor for the class\n+     *\/\n+    default Utf8Entry utf8Entry(ClassDesc desc) {\n+        return utf8Entry(desc.descriptorString());\n+    }\n+\n+    \/**\n+     * {@return A {@link Utf8Entry} describing the method descriptor of the provided\n+     * {@linkplain MethodTypeDesc}}\n+     * If a UTF8 entry in the pool already describes this field descriptor, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param desc the symbolic descriptor for the method type\n+     *\/\n+    default Utf8Entry utf8Entry(MethodTypeDesc desc) {\n+        return utf8Entry(desc.descriptorString());\n+    }\n+\n+    \/**\n+     * {@return A {@link ClassEntry} describing the class whose internal name\n+     * is encoded in the provided {@linkplain Utf8Entry}}\n+     * If a Class entry in the pool already describes this class,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param ne the constant pool entry describing the internal name of the class\n+     *\/\n+    ClassEntry classEntry(Utf8Entry ne);\n+\n+    \/**\n+     * {@return A {@link ClassEntry} describing the class described by\n+     * provided {@linkplain ClassDesc}}\n+     * If a Class entry in the pool already describes this class,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param classDesc the symbolic descriptor for the class\n+     *\/\n+    default ClassEntry classEntry(ClassDesc classDesc) {\n+        return classEntry(utf8Entry(Util.toInternalName(classDesc)));\n+    }\n+\n+    \/**\n+     * {@return A {@link PackageEntry} describing the class whose internal name\n+     * is encoded in the provided {@linkplain Utf8Entry}}\n+     * If a Package entry in the pool already describes this class,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param nameEntry the constant pool entry describing the internal name of\n+     *                  the package\n+     *\/\n+    PackageEntry packageEntry(Utf8Entry nameEntry);\n+\n+    \/**\n+     * {@return A {@link PackageEntry} describing the class described by\n+     * provided {@linkplain PackageDesc}}\n+     * If a Package entry in the pool already describes this class,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param packageDesc the symbolic descriptor for the class\n+     *\/\n+    default PackageEntry packageEntry(PackageDesc packageDesc) {\n+        return packageEntry(utf8Entry(packageDesc.packageInternalName()));\n+    }\n+\n+    \/**\n+     * {@return A {@link ModuleEntry} describing the module whose name\n+     * is encoded in the provided {@linkplain Utf8Entry}}\n+     * If a module entry in the pool already describes this class,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param moduleName the constant pool entry describing the module name\n+     *\/\n+    ModuleEntry moduleEntry(Utf8Entry moduleName);\n+\n+    \/**\n+     * {@return A {@link ModuleEntry} describing the module described by\n+     * provided {@linkplain ModuleDesc}}\n+     * If a module entry in the pool already describes this class,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param moduleDesc the symbolic descriptor for the class\n+     *\/\n+    default ModuleEntry moduleEntry(ModuleDesc moduleDesc) {\n+        return moduleEntry(utf8Entry(moduleDesc.moduleName()));\n+    }\n+\n+    \/**\n+     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n+     * If a NameAndType entry in the pool already describes this name and type,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param nameEntry the member name\n+     * @param typeEntry the member field or method descriptor\n+     *\/\n+    NameAndTypeEntry natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry);\n+\n+    \/**\n+     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n+     * If a NameAndType entry in the pool already describes this name and type,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param name the member name\n+     * @param type the symbolic descriptor for a field type\n+     *\/\n+    default NameAndTypeEntry natEntry(String name, ClassDesc type) {\n+        return natEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+    }\n+\n+    \/**\n+     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n+     * If a NameAndType entry in the pool already describes this name and type,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param name the member name\n+     * @param type the symbolic descriptor for a method type\n+     *\/\n+    default NameAndTypeEntry natEntry(String name, MethodTypeDesc type) {\n+        return natEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+    }\n+\n+    \/**\n+     * {@return A {@link FieldRefEntry} describing a field of a class}\n+     * If a FieldRef entry in the pool already describes this field,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param owner the class the field is a member of\n+     * @param nameAndType the name and type of the field\n+     *\/\n+    FieldRefEntry fieldRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType);\n+\n+    \/**\n+     * {@return A {@link FieldRefEntry} describing a field of a class}\n+     * If a FieldRef entry in the pool already describes this field,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param owner the class the field is a member of\n+     * @param name the name of the field\n+     * @param type the type of the field\n+     *\/\n+    default FieldRefEntry fieldRefEntry(ClassDesc owner, String name, ClassDesc type) {\n+        return fieldRefEntry(classEntry(owner), natEntry(name, type));\n+    }\n+\n+    \/**\n+     * {@return A {@link MethodRefEntry} describing a method of a class}\n+     * If a MethodRefEntry entry in the pool already describes this method,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param owner the class the method is a member of\n+     * @param nameAndType the name and type of the method\n+     *\/\n+    MethodRefEntry methodRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType);\n+\n+    \/**\n+     * {@return A {@link MethodRefEntry} describing a method of a class}\n+     * If a MethodRefEntry entry in the pool already describes this method,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param owner the class the method is a member of\n+     * @param name the name of the method\n+     * @param type the type of the method\n+     *\/\n+    default MethodRefEntry methodRefEntry(ClassDesc owner, String name, MethodTypeDesc type) {\n+        return methodRefEntry(classEntry(owner), natEntry(name, type));\n+    }\n+\n+    \/**\n+     * {@return A {@link InterfaceMethodRefEntry} describing a method of a class}\n+     * If a InterfaceMethodRefEntry entry in the pool already describes this method,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param owner the class the method is a member of\n+     * @param nameAndType the name and type of the method\n+     *\/\n+    InterfaceMethodRefEntry interfaceMethodRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType);\n+\n+    \/**\n+     * {@return A {@link InterfaceMethodRefEntry} describing a method of a class}\n+     * If a InterfaceMethodRefEntry entry in the pool already describes this method,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param owner the class the method is a member of\n+     * @param name the name of the method\n+     * @param type the type of the method\n+     *\/\n+    default InterfaceMethodRefEntry interfaceMethodRefEntry(ClassDesc owner, String name, MethodTypeDesc type) {\n+        return interfaceMethodRefEntry(classEntry(owner), natEntry(name, type));\n+    }\n+\n+    \/**\n+     * {@return A {@link MethodTypeEntry} describing a method type}\n+     * If a MethodType entry in the pool already describes this method type,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param descriptor the symbolic descriptor of the method type\n+     *\/\n+    MethodTypeEntry methodTypeEntry(MethodTypeDesc descriptor);\n+\n+    \/**\n+     * {@return A {@link MethodTypeEntry} describing a method type}\n+     * If a MethodType entry in the pool already describes this method type,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param descriptor the constant pool entry for the method type descriptor\n+     *\/\n+    MethodTypeEntry methodTypeEntry(Utf8Entry descriptor);\n+\n+    \/**\n+     * {@return A {@link MethodHandleEntry} describing a direct method handle}\n+     * If a MethodHandle entry in the pool already describes this method handle,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param descriptor the symbolic descriptor of the method handle\n+     *\/\n+    default MethodHandleEntry methodHandleEntry(DirectMethodHandleDesc descriptor) {\n+        var owner = classEntry(descriptor.owner());\n+        var nat = natEntry(utf8Entry(descriptor.methodName()), utf8Entry(descriptor.lookupDescriptor()));\n+        return methodHandleEntry(descriptor.refKind(), switch (descriptor.kind()) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER -> fieldRefEntry(owner, nat);\n+            case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> interfaceMethodRefEntry(owner, nat);\n+            case STATIC, VIRTUAL, SPECIAL, CONSTRUCTOR -> methodRefEntry(owner, nat);\n+        });\n+    }\n+\n+    \/**\n+     * {@return A {@link MethodHandleEntry} describing a field accessor or method}\n+     * If a MethodHandle entry in the pool already describes this method handle,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param refKind the reference kind of the method handle {@jvms 4.4.8}\n+     * @param reference the constant pool entry describing the field or method\n+     *\/\n+    MethodHandleEntry methodHandleEntry(int refKind, MemberRefEntry reference);\n+\n+    \/**\n+     * {@return An {@link InvokeDynamicEntry} describing a dynamic call site}\n+     * If an InvokeDynamic entry in the pool already describes this site,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param dcsd the symbolic descriptor of the method handle\n+     *\/\n+    default InvokeDynamicEntry invokeDynamicEntry(DynamicCallSiteDesc dcsd) {\n+        return invokeDynamicEntry(bsmEntry((DirectMethodHandleDesc)dcsd.bootstrapMethod(), List.of(dcsd.bootstrapArgs())), natEntry(dcsd.invocationName(), dcsd.invocationType()));\n+    }\n+\n+    \/**\n+     * {@return An {@link InvokeDynamicEntry} describing a dynamic call site}\n+     * If an InvokeDynamic entry in the pool already describes this site,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param bootstrapMethodEntry the entry in the bootstrap method table\n+     * @param nameAndType the invocation name and type\n+     *\/\n+    InvokeDynamicEntry invokeDynamicEntry(BootstrapMethodEntry bootstrapMethodEntry,\n+                                          NameAndTypeEntry nameAndType);\n+\n+    \/**\n+     * {@return A {@link ConstantDynamicEntry} describing a dynamic constant}\n+     * If a ConstantDynamic entry in the pool already describes this site,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param dcd the symbolic descriptor of the constant\n+     *\/\n+    default ConstantDynamicEntry constantDynamicEntry(DynamicConstantDesc<?> dcd) {\n+        return constantDynamicEntry(bsmEntry(dcd.bootstrapMethod(), List.of(dcd.bootstrapArgs())), natEntry(dcd.constantName(), dcd.constantType()));\n+    }\n+\n+    \/**\n+     * {@return A {@link ConstantDynamicEntry} describing a dynamic constant}\n+     * If a ConstantDynamic entry in the pool already describes this site,\n+     * it is returned; otherwise, a new entry is added and the new entry is\n+     * returned.\n+     *\n+     * @param bootstrapMethodEntry the entry in the bootstrap method table\n+     * @param nameAndType the invocation name and type\n+     *\/\n+    ConstantDynamicEntry constantDynamicEntry(BootstrapMethodEntry bootstrapMethodEntry, NameAndTypeEntry nameAndType);\n+\n+    \/**\n+     * {@return An {@link IntegerEntry} describing the provided value}\n+     * If an integer entry in the pool already describes this value, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param value the value\n+     *\/\n+    IntegerEntry intEntry(int value);\n+\n+    \/**\n+     * {@return A {@link FloatEntry} describing the provided value}\n+     * If a float entry in the pool already describes this value, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param value the value\n+     *\/\n+    FloatEntry floatEntry(float value);\n+\n+    \/**\n+     * {@return A {@link LongEntry} describing the provided value}\n+     * If a long entry in the pool already describes this value, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param value the value\n+     *\/\n+    LongEntry longEntry(long value);\n+\n+    \/**\n+     * {@return A {@link DoubleEntry} describing the provided value}\n+     * If a double entry in the pool already describes this value, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param value the value\n+     *\/\n+    DoubleEntry doubleEntry(double value);\n+\n+    \/**\n+     * {@return A {@link StringEntry} referencing the provided UTF8 entry}\n+     * If a String entry in the pool already describes this value, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param utf8 the UTF8 entry describing the string\n+     *\/\n+    StringEntry stringEntry(Utf8Entry utf8);\n+\n+    \/**\n+     * {@return A {@link StringEntry} describing the provided value}\n+     * If a string entry in the pool already describes this value, it is returned;\n+     * otherwise, a new entry is added and the new entry is returned.\n+     *\n+     * @param value the value\n+     *\/\n+    default StringEntry stringEntry(String value) {\n+        return stringEntry(utf8Entry(value));\n+    }\n+\n+    \/**\n+     * {@return A {@link ConstantValueEntry} descripbing the provided\n+     * Integer, Long, Float, Double, or String constant}\n+     *\n+     * @param c the constant\n+     *\/\n+    default ConstantValueEntry constantValueEntry(ConstantDesc c) {\n+        if (c instanceof Integer i) return intEntry(i);\n+        if (c instanceof String s) return stringEntry(s);\n+        if (c instanceof Long l) return longEntry(l);\n+        if (c instanceof Float f) return floatEntry(f);\n+        if (c instanceof Double d) return doubleEntry(d);\n+        throw new IllegalArgumentException(\"Illegal type: \" + c.getClass());\n+    }\n+\n+    \/**\n+     * {@return A {@link LoadableConstantEntry} describing the provided\n+     * constant}  The constant should be an Integer, String, Long, Float,\n+     * Double, ClassDesc (for a Class constant), MethodTypeDesc (for a MethodType\n+     * constant), DirectMethodHandleDesc (for a MethodHandle constant), or\n+     * a DynamicConstantDesc (for a dynamic constant.)\n+     *\n+     * @param c the constant\n+     *\/\n+    default LoadableConstantEntry loadableConstantEntry(ConstantDesc c) {\n+        if (c instanceof Integer i) return intEntry(i);\n+        if (c instanceof String s) return stringEntry(s);\n+        if (c instanceof Long l) return longEntry(l);\n+        if (c instanceof Float f) return floatEntry(f);\n+        if (c instanceof Double d) return doubleEntry(d);\n+        if (c instanceof ClassDesc cd) return classEntry(cd);\n+        if (c instanceof MethodTypeDesc mtd) return methodTypeEntry(mtd);\n+        if (c instanceof DirectMethodHandleDesc dmhd) return methodHandleEntry(dmhd);\n+        if (c instanceof DynamicConstantDesc<?> dcd) return constantDynamicEntry(dcd);\n+        throw new IllegalArgumentException(\"Illegal type: \" + c.getClass());\n+    }\n+\n+    \/**\n+     * {@return An {@link AnnotationConstantValueEntry} describing the provided\n+     * constant}  The constant should be an Integer, String, Long, Float,\n+     * Double, ClassDesc (for a Class constant), or MethodTypeDesc (for a MethodType\n+     * constant.)\n+     *\n+     * @param c the constant\n+     *\/\n+    default AnnotationConstantValueEntry annotationConstantValueEntry(ConstantDesc c) {\n+        if (c instanceof Integer i) return intEntry(i);\n+        if (c instanceof String s) return utf8Entry(s);\n+        if (c instanceof Long l) return longEntry(l);\n+        if (c instanceof Float f) return floatEntry(f);\n+        if (c instanceof Double d) return doubleEntry(d);\n+        if (c instanceof ClassDesc cd) return utf8Entry(cd);\n+        if (c instanceof MethodTypeDesc mtd) return utf8Entry(mtd);\n+        throw new IllegalArgumentException(\"Illegal type: \" + c.getClass());\n+    }\n+\n+    \/**\n+     * {@return a {@link BootstrapMethodEntry} describing the provided\n+     * bootstrap method and static arguments}\n+     *\n+     * @param methodReference the bootstrap method\n+     * @param arguments the bootstrap arguments\n+     *\/\n+    default BootstrapMethodEntry bsmEntry(DirectMethodHandleDesc methodReference,\n+                                          List<ConstantDesc> arguments) {\n+        return bsmEntry(methodHandleEntry(methodReference),\n+                arguments.stream().map(this::loadableConstantEntry).toList());\n+    }\n+\n+    \/**\n+     * {@return a {@link BootstrapMethodEntry} describing the provided\n+     * bootstrap method and static arguments}\n+     *\n+     * @param methodReference the bootstrap method\n+     * @param arguments the bootstrap arguments\n+     *\/\n+    BootstrapMethodEntry bsmEntry(MethodHandleEntry methodReference,\n+                                  List<LoadableConstantEntry> arguments);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":555,"deletions":0,"binary":false,"changes":555,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.ConstantDesc;\n+\n+\/**\n+ * Models a constant pool entry that can be used as the constant in a\n+ * {@code ConstantValue} attribute; this includes the four primitive constant\n+ * types and {@linkplain String} constants.\n+ *\/\n+public sealed interface ConstantValueEntry extends LoadableConstantEntry\n+        permits DoubleEntry, FloatEntry, IntegerEntry, LongEntry, StringEntry {\n+\n+    \/**\n+     * {@return the constant value}  The constant value will be an {@link Integer},\n+     * {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n+     *\/\n+    ConstantDesc constantValue();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantValueEntry.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_Double_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface DoubleEntry\n+        extends AnnotationConstantValueEntry, ConstantValueEntry\n+        permits ConcreteEntry.ConcreteDoubleEntry {\n+\n+    \/**\n+     * {@return the double value}\n+     *\/\n+    double doubleValue();\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    default TypeKind typeKind() {\n+        return TypeKind.DoubleType;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/DoubleEntry.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+\n+\/**\n+ * Models a dynamic constant pool entry, which is either {@link ConstantDynamicEntry}\n+ * or {@link InvokeDynamicEntry}.\n+ *\/\n+public sealed interface DynamicConstantPoolEntry extends PoolEntry\n+        permits ConstantDynamicEntry, InvokeDynamicEntry {\n+\n+    \/**\n+     * {@return the entry in the bootstrap method table for this constant}\n+     *\/\n+    BootstrapMethodEntry bootstrap();\n+\n+    \/**\n+     * {@return the invocation name and type}\n+     *\/\n+    NameAndTypeEntry nameAndType();\n+\n+    \/**\n+     * {@return the invocation name}\n+     *\/\n+    default Utf8Entry name() {\n+        return nameAndType().name();\n+    }\n+\n+    \/**\n+     * {@return the invocation type}\n+     *\/\n+    default Utf8Entry type() {\n+        return nameAndType().type();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/DynamicConstantPoolEntry.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_Fieldref_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface FieldRefEntry extends MemberRefEntry\n+        permits ConcreteEntry.ConcreteFieldRefEntry {\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/FieldRefEntry.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_Float_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface FloatEntry\n+        extends AnnotationConstantValueEntry, ConstantValueEntry\n+        permits ConcreteEntry.ConcreteFloatEntry {\n+\n+    \/**\n+     * {@return the float value}\n+     *\/\n+\n+    float floatValue();\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    default TypeKind typeKind() {\n+        return TypeKind.FloatType;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/FloatEntry.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_Integer_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface IntegerEntry\n+        extends AnnotationConstantValueEntry, ConstantValueEntry\n+        permits ConcreteEntry.ConcreteIntegerEntry {\n+\n+    \/**\n+     * {@return the integer value}\n+     *\/\n+    int intValue();\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    default TypeKind typeKind() {\n+        return TypeKind.IntType;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/IntegerEntry.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_InterfaceMethodRef_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface InterfaceMethodRefEntry\n+        extends MemberRefEntry\n+        permits ConcreteEntry.ConcreteInterfaceMethodRefEntry {\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/InterfaceMethodRefEntry.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a constant pool entry for a dynamic call site.\n+ *\/\n+public sealed interface InvokeDynamicEntry\n+        extends DynamicConstantPoolEntry\n+        permits ConcreteEntry.ConcreteInvokeDynamicEntry {\n+\n+    \/**\n+     * {@return a symbolic descriptor for the dynamic call site}\n+     *\/\n+    default DynamicCallSiteDesc asSymbol() {\n+        return DynamicCallSiteDesc.of(bootstrap().bootstrapMethod().asSymbol(),\n+                                      name().stringValue(),\n+                                      MethodTypeDesc.ofDescriptor(type().stringValue()),\n+                                      bootstrap().arguments().stream()\n+                                                 .map(LoadableConstantEntry::constantValue)\n+                                                 .toArray(ConstantDesc[]::new));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/InvokeDynamicEntry.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.ConstantDesc;\n+import jdk.internal.classfile.TypeKind;\n+\n+\/**\n+ * Marker interface for constant pool entries suitable for loading via the\n+ * {@code LDC} instructions.\n+ *\/\n+public sealed interface LoadableConstantEntry extends PoolEntry\n+        permits ClassEntry, ConstantDynamicEntry, ConstantValueEntry, MethodHandleEntry, MethodTypeEntry {\n+\n+    \/**\n+     * {@return the constant described by this entry}\n+     *\/\n+    ConstantDesc constantValue();\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    default TypeKind typeKind() {\n+        return TypeKind.ReferenceType;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/LoadableConstantEntry.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_Long_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface LongEntry\n+        extends AnnotationConstantValueEntry, ConstantValueEntry\n+        permits ConcreteEntry.ConcreteLongEntry {\n+\n+    \/**\n+     * {@return the long value}\n+     *\/\n+    long longValue();\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    default TypeKind typeKind() {\n+        return TypeKind.LongType;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/LongEntry.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a member reference constant in the constant pool of a classfile,\n+ * which includes references to fields, methods, and interface methods.\n+ *\/\n+public sealed interface MemberRefEntry extends PoolEntry\n+        permits FieldRefEntry, InterfaceMethodRefEntry, MethodRefEntry, ConcreteEntry.MemberRefEntry {\n+    \/**\n+     * {@return the class in which this member ref lives}\n+     *\/\n+    ClassEntry owner();\n+\n+    \/**\n+     * {@return the name and type of the member}\n+     *\/\n+    NameAndTypeEntry nameAndType();\n+\n+    \/**\n+     * {@return the name of the member}\n+     *\/\n+    default Utf8Entry name() {\n+        return nameAndType().name();\n+    }\n+\n+    \/**\n+     * {@return the type of the member}\n+     *\/\n+    default Utf8Entry type() {\n+        return nameAndType().type();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MemberRefEntry.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.DirectMethodHandleDesc;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_MethodHandle_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface MethodHandleEntry\n+        extends LoadableConstantEntry\n+        permits ConcreteEntry.ConcreteMethodHandleEntry {\n+\n+    \/**\n+     * {@return the reference kind of this method handle {@jvms 4.4.8}}\n+     * @see java.lang.invoke.MethodHandleInfo\n+     *\/\n+    int kind();\n+\n+    \/**\n+     * {@return the constant pool entry describing the method}\n+     *\/\n+    MemberRefEntry reference();\n+\n+    \/**\n+     * {@return a symbolic descriptor for this method handle}\n+     *\/\n+    DirectMethodHandleDesc asSymbol();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodHandleEntry.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_MethodRef_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface MethodRefEntry extends MemberRefEntry\n+        permits ConcreteEntry.ConcreteMethodRefEntry {\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodRefEntry.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_MethodType_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface MethodTypeEntry\n+        extends LoadableConstantEntry\n+        permits ConcreteEntry.ConcreteMethodTypeEntry {\n+\n+    \/**\n+     * {@return the constant pool entry describing the method type}\n+     *\/\n+    Utf8Entry descriptor();\n+\n+    \/**\n+     * {@return a symbolic descriptor for the method type}\n+     *\/\n+    default MethodTypeDesc asSymbol() {\n+        return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodTypeEntry.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+\n+\/**\n+ * Models a {@code CONSTANT_Module_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface ModuleEntry extends PoolEntry\n+        permits ConcreteEntry.ConcreteModuleEntry {\n+    \/**\n+     * {@return the name of the module}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return a symbolic descriptor for the module}\n+     *\/\n+    ModuleDesc asSymbol();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ModuleEntry.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_NameAndType_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface NameAndTypeEntry extends PoolEntry\n+        permits ConcreteEntry.ConcreteNameAndTypeEntry {\n+\n+    \/**\n+     * {@return the field or method name}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the field or method descriptor}\n+     *\/\n+    Utf8Entry type();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/NameAndTypeEntry.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+\n+\/**\n+ * Models a {@code CONSTANT_Package_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface PackageEntry extends PoolEntry\n+        permits ConcreteEntry.ConcretePackageEntry {\n+    \/**\n+     * {@return the package name}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return a symbolic descriptor for the package name}\n+     *\/\n+    PackageDesc asSymbol();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/PackageEntry.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.WritableElement;\n+\n+\/**\n+ * Models an entry in the constant pool of a classfile.\n+ *\/\n+public sealed interface PoolEntry extends WritableElement<PoolEntry>\n+        permits AnnotationConstantValueEntry, DynamicConstantPoolEntry,\n+                LoadableConstantEntry, MemberRefEntry, ModuleEntry, NameAndTypeEntry,\n+                PackageEntry {\n+\n+    \/**\n+     * {@return the constant pool this entry is from}\n+     *\/\n+    ConstantPool constantPool();\n+\n+    \/**\n+     * {@return the constant pool tag that describes the type of this entry}\n+     *\/\n+    byte tag();\n+\n+    \/**\n+     * {@return the index within the constant pool corresponding to this entry}\n+     *\/\n+    int index();\n+\n+    \/**\n+     * {@return the number of constant pool slots this entry consumes}\n+     *\/\n+    int width();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/PoolEntry.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_String_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface StringEntry\n+        extends ConstantValueEntry\n+        permits ConcreteEntry.ConcreteStringEntry {\n+    \/**\n+     * {@return the UTF constant pool entry describing the string contents}\n+     *\/\n+    Utf8Entry utf8();\n+\n+    \/**\n+     * {@return the string value for this entry}\n+     *\/\n+    String stringValue();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/StringEntry.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.constantpool;\n+\n+import jdk.internal.classfile.impl.ConcreteEntry;\n+\n+\/**\n+ * Models a {@code CONSTANT_UTF8_info} constant in the constant pool of a\n+ * classfile.\n+ *\/\n+public sealed interface Utf8Entry\n+        extends CharSequence, AnnotationConstantValueEntry\n+        permits ConcreteEntry.ConcreteUtf8Entry {\n+\n+    \/**\n+     * {@return the string value for this entry}\n+     *\/\n+    String stringValue();\n+\n+    \/**\n+     * {@return whether this entry describes the same string as the provided string}\n+     *\n+     * @param s the string to compare to\n+     *\/\n+    boolean equalsString(String s);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/Utf8Entry.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Set;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.AttributeMapper;\n+import jdk.internal.classfile.AttributedElement;\n+import jdk.internal.classfile.BufWriter;\n+\n+import static jdk.internal.classfile.Classfile.JAVA_1_VERSION;\n+\n+\/**\n+ * AbstractAttributeMapper\n+ *\/\n+public abstract class AbstractAttributeMapper<T extends Attribute<T>>\n+        implements AttributeMapper<T> {\n+\n+    private final String name;\n+    private final boolean allowMultiple;\n+    private final int majorVersion;\n+\n+    protected abstract void writeBody(BufWriter buf, T attr);\n+\n+    public AbstractAttributeMapper(String name) {\n+        this(name, false);\n+    }\n+\n+    public AbstractAttributeMapper(String name,\n+                                   boolean allowMultiple) {\n+        this(name, allowMultiple, JAVA_1_VERSION);\n+    }\n+\n+    public AbstractAttributeMapper(String name,\n+                                   int majorVersion) {\n+        this(name, false, majorVersion);\n+    }\n+\n+    public AbstractAttributeMapper(String name,\n+                                   boolean allowMultiple,\n+                                   int majorVersion) {\n+        this.name = name;\n+        this.allowMultiple = allowMultiple;\n+        this.majorVersion = majorVersion;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public void writeAttribute(BufWriter buf, T attr) {\n+        buf.writeIndex(buf.constantPool().utf8Entry(name));\n+        buf.writeInt(0);\n+        int start = buf.size();\n+        writeBody(buf, attr);\n+        int written = buf.size() - start;\n+        buf.patchInt(start - 4, 4, written);\n+    }\n+\n+    @Override\n+    public boolean allowMultiple() {\n+        return allowMultiple;\n+    }\n+\n+    @Override\n+    public int validSince() {\n+        return majorVersion;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"AttributeMapper[name=%s, allowMultiple=%b, validSince=%d]\",\n+                name, allowMultiple, majorVersion);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+\/**\n+ * AbstractLocalVariableImpl\n+ *\/\n+public class AbstractBoundLocalVariable\n+        extends AbstractElement {\n+    protected final CodeImpl code;\n+    protected final int offset;\n+    private Utf8Entry nameEntry;\n+    private Utf8Entry secondaryEntry;\n+\n+    public AbstractBoundLocalVariable(CodeImpl code, int offset) {\n+        this.code = code;\n+        this.offset = offset;\n+    }\n+\n+    protected int nameIndex() {\n+        return code.classReader.readU2(offset + 4);\n+    }\n+\n+    public Utf8Entry name() {\n+        if (nameEntry == null)\n+            nameEntry = (Utf8Entry) code.constantPool().entryByIndex(nameIndex());\n+        return nameEntry;\n+    }\n+\n+    protected int secondaryIndex() {\n+        return code.classReader.readU2(offset + 6);\n+    }\n+\n+    protected Utf8Entry secondaryEntry() {\n+        if (secondaryEntry == null)\n+            secondaryEntry = (Utf8Entry) code.constantPool().entryByIndex(secondaryIndex());\n+        return secondaryEntry;\n+    }\n+\n+    public Label startScope() {\n+        return code.getLabel(startPc());\n+    }\n+\n+    public Label endScope() {\n+        return code.getLabel(startPc() + length());\n+    }\n+\n+    public int startPc() {\n+        return code.classReader.readU2(offset);\n+    }\n+\n+    public int length() {\n+        return code.classReader.readU2(offset+2);\n+    }\n+\n+    public int slot() {\n+        return code.classReader.readU2(offset + 8);\n+    }\n+\n+    public boolean writeTo(BufWriter b) {\n+        var lc = ((BufWriterImpl)b).labelContext();\n+        int startBci = lc.labelToBci(startScope());\n+        int endBci = lc.labelToBci(endScope());\n+        if (startBci == -1 || endBci == -1) {\n+            return false;\n+        }\n+        int length = endBci - startBci;\n+        b.writeU2(startBci);\n+        b.writeU2(length);\n+        if (b.canWriteDirect(code.constantPool())) {\n+            b.writeU2(nameIndex());\n+            b.writeU2(secondaryIndex());\n+        }\n+        else {\n+            b.writeIndex(name());\n+            b.writeIndex(secondaryEntry());\n+        }\n+        b.writeU2(slot());\n+        return true;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractBoundLocalVariable.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+\n+\/**\n+ * AbstractDirectBuilder\n+ *\/\n+public class AbstractDirectBuilder<B, M> {\n+    protected final SplitConstantPool constantPool;\n+    protected final AttributeHolder attributes = new AttributeHolder();\n+    protected M original;\n+\n+    public AbstractDirectBuilder(SplitConstantPool constantPool) {\n+        this.constantPool = constantPool;\n+    }\n+\n+    public SplitConstantPool constantPool() {\n+        return constantPool;\n+    }\n+\n+    public Optional<M> original() {\n+        return Optional.ofNullable(original);\n+    }\n+\n+    public void setOriginal(M original) {\n+        this.original = original;\n+    }\n+\n+    public void writeAttribute(Attribute<?> a) {\n+        attributes.withAttribute(a);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+\/**\n+ * AbstractElement\n+ *\/\n+public abstract class AbstractElement {\n+    public AbstractElement() { }\n+\n+    public void writeTo(DirectCodeBuilder builder) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void writeTo(DirectClassBuilder builder) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void writeTo(DirectMethodBuilder builder) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void writeTo(DirectFieldBuilder builder) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractElement.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,1308 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.instruction.SwitchCase;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n+import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.ConvertInstruction;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.MonitorInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StackInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.instruction.ThrowInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+\n+\n+\/**\n+ * AbstractInstruction.\n+ *\/\n+public abstract sealed class AbstractInstruction\n+        extends AbstractElement\n+        implements Instruction {\n+    final Opcode op;\n+    final int size;\n+\n+    public Opcode opcode() {\n+        return op;\n+    }\n+\n+    public int sizeInBytes() {\n+        return size;\n+    }\n+\n+    public AbstractInstruction(Opcode op, int size) {\n+        this.op = op;\n+        this.size = size;\n+    }\n+\n+    public abstract void writeTo(DirectCodeBuilder writer);\n+\n+    public static abstract sealed class BoundInstruction extends AbstractInstruction {\n+        final CodeImpl code;\n+        final int pos;\n+\n+        protected BoundInstruction(Opcode op, int size, CodeImpl code, int pos) {\n+            super(op, size);\n+            this.code = code;\n+            this.pos = pos;\n+        }\n+\n+        protected Label offsetToLabel(int offset) {\n+            return code.getLabel(pos - code.codeStart + offset);\n+        }\n+\n+        public void writeTo(DirectCodeBuilder writer) {\n+            \/\/ Override this if the instruction has any CP references or labels!\n+            code.classReader.copyBytesTo(writer.bytecodesBufWriter, pos, size);\n+        }\n+    }\n+\n+    public static final class BoundLoadInstruction\n+            extends BoundInstruction implements LoadInstruction {\n+\n+        public BoundLoadInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Load[OP=%s, slot=%d]\", this.opcode(), slot());\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return switch (size) {\n+                case 2 -> code.classReader.readU1(pos + 1);\n+                case 4 -> code.classReader.readU2(pos + 2);\n+                default -> throw new IllegalArgumentException(\"Unexpected op size: \" + op.sizeIfFixed() + \" -- \" + op);\n+            };\n+        }\n+\n+    }\n+\n+    public static final class BoundStoreInstruction\n+            extends BoundInstruction implements StoreInstruction {\n+\n+        public BoundStoreInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Store[OP=%s, slot=%d]\", this.opcode(), slot());\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return switch (size) {\n+                case 2 -> code.classReader.readU1(pos + 1);\n+                case 4 -> code.classReader.readU2(pos + 2);\n+                default -> throw new IllegalArgumentException(\"Unexpected op size: \" + size + \" -- \" + op);\n+            };\n+        }\n+\n+    }\n+\n+    public static final class BoundIncrementInstruction\n+            extends BoundInstruction implements IncrementInstruction {\n+\n+        public BoundIncrementInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return size == 6 ? code.classReader.readU2(pos + 2) : code.classReader.readU1(pos + 1);\n+        }\n+\n+        @Override\n+        public int constant() {\n+            return size == 6 ? code.classReader.readS2(pos + 4) : (byte) code.classReader.readS1(pos + 2);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Inc[OP=%s, slot=%d, val=%d]\", this.opcode(), slot(), constant());\n+        }\n+\n+    }\n+\n+    public static final class BoundBranchInstruction\n+            extends BoundInstruction implements BranchInstruction {\n+\n+        public BoundBranchInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public Label target() {\n+            return offsetToLabel(branchByteOffset());\n+        }\n+\n+        public int branchByteOffset() {\n+            return size == 3\n+                   ? (int) (short) code.classReader.readU2(pos + 1)\n+                   : code.classReader.readInt(pos + 1);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBranch(opcode(), target());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Branch[OP=%s]\", this.opcode());\n+        }\n+\n+    }\n+\n+    public record SwitchCaseImpl(int caseValue, Label target)\n+            implements SwitchCase {\n+    }\n+\n+    public static final class BoundLookupSwitchInstruction\n+            extends BoundInstruction implements LookupSwitchInstruction {\n+\n+        \/\/ will always need size, cache everything to there\n+        private final int afterPad;\n+        private final int npairs;\n+\n+        BoundLookupSwitchInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, size(code, code.codeStart, pos), code, pos);\n+\n+            this.afterPad = pos + 1 + ((4 - ((pos + 1 - code.codeStart) & 3)) & 3);\n+            this.npairs = code.classReader.readInt(afterPad + 4);\n+        }\n+\n+        static int size(CodeImpl code, int codeStart, int pos) {\n+            int afterPad = pos + 1 + ((4 - ((pos + 1 - codeStart) & 3)) & 3);\n+            int pad = afterPad - (pos + 1);\n+            int npairs = code.classReader.readInt(afterPad + 4);\n+            return 1 + pad + 8 + npairs * 8;\n+        }\n+\n+        private int defaultOffset() {\n+            return code.classReader.readInt(afterPad);\n+        }\n+\n+        @Override\n+        public List<SwitchCase> cases() {\n+            var cases = new SwitchCase[npairs];\n+            for (int i = 0; i < npairs; ++i) {\n+                int z = afterPad + 8 + 8 * i;\n+                cases[i] = SwitchCase.of(code.classReader.readInt(z), offsetToLabel(code.classReader.readInt(z + 4)));\n+            }\n+            return List.of(cases);\n+        }\n+\n+        @Override\n+        public Label defaultTarget() {\n+            return offsetToLabel(defaultOffset());\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeLookupSwitch(defaultTarget(), cases());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LookupSwitch[OP=%s]\", this.opcode());\n+        }\n+\n+    }\n+\n+    public static final class BoundTableSwitchInstruction\n+            extends BoundInstruction implements TableSwitchInstruction {\n+\n+        BoundTableSwitchInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, size(code, code.codeStart, pos), code, pos);\n+        }\n+\n+        static int size(CodeImpl code, int codeStart, int pos) {\n+            int ap = pos + 1 + ((4 - ((pos + 1 - codeStart) & 3)) & 3);\n+            int pad = ap - (pos + 1);\n+            int low = code.classReader.readInt(ap + 4);\n+            int high = code.classReader.readInt(ap + 8);\n+            int cnt = high - low + 1;\n+            return 1 + pad + 12 + cnt * 4;\n+        }\n+\n+        private int afterPadding() {\n+            int p = pos;\n+            return p + 1 + ((4 - ((p + 1 - code.codeStart) & 3)) & 3);\n+        }\n+\n+        @Override\n+        public Label defaultTarget() {\n+            return offsetToLabel(defaultOffset());\n+        }\n+\n+        @Override\n+        public int lowValue() {\n+            return code.classReader.readInt(afterPadding() + 4);\n+        }\n+\n+        @Override\n+        public int highValue() {\n+            return code.classReader.readInt(afterPadding() + 8);\n+        }\n+\n+        @Override\n+        public List<SwitchCase> cases() {\n+            int low = lowValue();\n+            int high = highValue();\n+            int defOff = defaultOffset();\n+            var cases = new ArrayList<SwitchCase>(high - low + 1);\n+            int z = afterPadding() + 12;\n+            for (int i = lowValue(); i <= high; ++i) {\n+                int off = code.classReader.readInt(z);\n+                if (defOff != off) {\n+                    cases.add(SwitchCase.of(i, offsetToLabel(off)));\n+                }\n+                z += 4;\n+            }\n+            return Collections.unmodifiableList(cases);\n+        }\n+\n+        private int defaultOffset() {\n+            return code.classReader.readInt(afterPadding());\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeTableSwitch(lowValue(), highValue(), defaultTarget(), cases());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"TableSwitch[OP=%s]\", this.opcode());\n+        }\n+\n+    }\n+\n+    public static final class BoundFieldInstruction\n+            extends BoundInstruction implements FieldInstruction {\n+\n+        private FieldRefEntry fieldEntry;\n+\n+        public BoundFieldInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public FieldRefEntry field() {\n+            if (fieldEntry == null)\n+                fieldEntry = (FieldRefEntry) code.classReader.readEntry(pos + 1);\n+            return fieldEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeFieldAccess(op, field());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Field[OP=%s, field=%s.%s:%s]\", this.opcode(), owner().asInternalName(), name().stringValue(), type().stringValue());\n+        }\n+\n+    }\n+\n+    public static final class BoundInvokeInstruction\n+            extends BoundInstruction implements InvokeInstruction {\n+        MemberRefEntry methodEntry;\n+\n+        public BoundInvokeInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public MemberRefEntry method() {\n+            if (methodEntry == null)\n+                methodEntry = (MemberRefEntry) code.classReader.readEntry(pos + 1);\n+            return methodEntry;\n+        }\n+\n+        @Override\n+        public boolean isInterface() {\n+            return method().tag() == Classfile.TAG_INTERFACEMETHODREF;\n+        }\n+\n+        @Override\n+        public int count() {\n+            return Util.parameterSlots(type().stringValue());\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeInvokeNormal(op, method());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Invoke[OP=%s, m=%s.%s%s]\", this.opcode(), owner().asInternalName(), name().stringValue(), type().stringValue());\n+        }\n+\n+    }\n+\n+    public static final class BoundInvokeInterfaceInstruction\n+            extends BoundInstruction implements InvokeInstruction {\n+        InterfaceMethodRefEntry methodEntry;\n+\n+        public BoundInvokeInterfaceInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public MemberRefEntry method() {\n+            if (methodEntry == null)\n+                methodEntry = (InterfaceMethodRefEntry) code.classReader.readEntry(pos + 1);\n+            return methodEntry;\n+        }\n+\n+        @Override\n+        public int count() {\n+            return code.classReader.readU1(pos + 3);\n+        }\n+\n+        @Override\n+        public boolean isInterface() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeInvokeInterface(op, (InterfaceMethodRefEntry) method(), count());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"InvokeInterface[OP=%s, m=%s.%s%s]\", this.opcode(), owner().asInternalName(), name().stringValue(), type().stringValue());\n+        }\n+\n+    }\n+\n+    public static final class BoundInvokeDynamicInstruction\n+            extends BoundInstruction implements InvokeDynamicInstruction {\n+        InvokeDynamicEntry indyEntry;\n+\n+        BoundInvokeDynamicInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public InvokeDynamicEntry invokedynamic() {\n+            if (indyEntry == null)\n+                indyEntry = (InvokeDynamicEntry) code.classReader.readEntry(pos + 1);\n+            return indyEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeInvokeDynamic(invokedynamic());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"InvokeDynamic[OP=%s, bsm=%s %s]\", this.opcode(), bootstrapMethod(), bootstrapArgs());\n+        }\n+\n+    }\n+\n+    public static final class BoundNewObjectInstruction\n+            extends BoundInstruction implements NewObjectInstruction {\n+        ClassEntry classEntry;\n+\n+        BoundNewObjectInstruction(CodeImpl code, int pos) {\n+            super(Opcode.NEW, Opcode.NEW.sizeIfFixed(), code, pos);\n+        }\n+\n+        public ClassEntry className() {\n+            if (classEntry == null)\n+                classEntry = code.classReader.readClassEntry(pos + 1);\n+            return classEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeNewObject(className());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewObj[OP=%s, type=%s]\", this.opcode(), className().asInternalName());\n+        }\n+\n+    }\n+\n+    public static final class BoundNewPrimitiveArrayInstruction\n+            extends BoundInstruction implements NewPrimitiveArrayInstruction {\n+\n+        public BoundNewPrimitiveArrayInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public TypeKind typeKind() {\n+            return TypeKind.fromNewArrayCode(code.classReader.readU1(pos + 1));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewPrimitiveArray[OP=%s, type=%s]\", this.opcode(), typeKind());\n+        }\n+\n+    }\n+\n+    public static final class BoundNewReferenceArrayInstruction\n+            extends BoundInstruction implements NewReferenceArrayInstruction {\n+\n+        public BoundNewReferenceArrayInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public ClassEntry componentType() {\n+            return code.classReader.readClassEntry(pos + 1);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeNewReferenceArray(componentType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewRefArray[OP=%s, type=%s]\", this.opcode(), componentType().asInternalName());\n+        }\n+    }\n+\n+    public static final class BoundNewMultidimensionalArrayInstruction\n+            extends BoundInstruction implements NewMultiArrayInstruction {\n+\n+        public BoundNewMultidimensionalArrayInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public int dimensions() {\n+            return code.classReader.readU1(pos + 3);\n+        }\n+\n+        public ClassEntry arrayType() {\n+            return code.classReader.readClassEntry(pos + 1);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeNewMultidimensionalArray(dimensions(), arrayType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewMultiArray[OP=%s, type=%s[%d]]\", this.opcode(), arrayType().asInternalName(), dimensions());\n+        }\n+\n+    }\n+\n+    public static final class BoundTypeCheckInstruction\n+            extends BoundInstruction implements TypeCheckInstruction {\n+        ClassEntry typeEntry;\n+\n+        public BoundTypeCheckInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        public ClassEntry type() {\n+            if (typeEntry == null)\n+                typeEntry = code.classReader.readClassEntry(pos + 1);\n+            return typeEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeTypeCheck(op, type());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"TypeCheck[OP=%s, type=%s]\", this.opcode(), type().asInternalName());\n+        }\n+\n+    }\n+\n+    public static final class BoundArgumentConstantInstruction\n+            extends BoundInstruction implements ConstantInstruction.ArgumentConstantInstruction {\n+\n+        public BoundArgumentConstantInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public Integer constantValue() {\n+            return constantInt();\n+        }\n+\n+        public int constantInt() {\n+            return size == 3 ? code.classReader.readS2(pos + 1) : code.classReader.readS1(pos + 1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"ArgumentConstant[OP=%s, val=%s]\", this.opcode(), constantValue());\n+        }\n+\n+    }\n+\n+    public static final class BoundLoadConstantInstruction\n+            extends BoundInstruction implements ConstantInstruction.LoadConstantInstruction {\n+\n+        public BoundLoadConstantInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, op.sizeIfFixed(), code, pos);\n+        }\n+\n+        @Override\n+        public LoadableConstantEntry constantEntry() {\n+            return (LoadableConstantEntry)\n+                    code.classReader.entryByIndex(op == Opcode.LDC\n+                                                  ? code.classReader.readU1(pos + 1)\n+                                                  : code.classReader.readU2(pos + 1));\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return constantEntry().constantValue();\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (writer.canWriteDirect(code.constantPool()))\n+                super.writeTo(writer);\n+            else\n+                writer.writeLoadConstant(op, constantEntry());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LoadConstant[OP=%s, val=%s]\", this.opcode(), constantValue());\n+        }\n+\n+    }\n+\n+    public static abstract sealed class UnboundInstruction extends AbstractInstruction {\n+        UnboundInstruction(Opcode op) {\n+            super(op, op.sizeIfFixed());\n+        }\n+\n+        public UnboundInstruction(Opcode op, int size) {\n+            super(op, size);\n+        }\n+\n+        @Override\n+        \/\/ Override this if there is anything more that just the bytecode\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBytecode(op);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s[op=%s]\", this.getClass().getSimpleName(), op);\n+        }\n+    }\n+\n+    public static final class UnboundLoadInstruction\n+            extends UnboundInstruction implements LoadInstruction {\n+        final int slot;\n+\n+        public UnboundLoadInstruction(Opcode op, int slot) {\n+            super(op);\n+            this.slot = slot;\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return slot;\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeLoad(op, slot);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Load[OP=%s, slot=%d]\", this.opcode(), slot());\n+        }\n+\n+    }\n+\n+    public static final class UnboundStoreInstruction\n+            extends UnboundInstruction implements StoreInstruction {\n+        final int slot;\n+\n+        public UnboundStoreInstruction(Opcode op, int slot) {\n+            super(op);\n+            this.slot = slot;\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return slot;\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeStore(op, slot);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Store[OP=%s, slot=%d]\", this.opcode(), slot());\n+        }\n+\n+    }\n+\n+    public static final class UnboundIncrementInstruction\n+            extends UnboundInstruction implements IncrementInstruction {\n+        final int slot;\n+        final int constant;\n+\n+        public UnboundIncrementInstruction(int slot, int constant) {\n+            super(slot <= 255 && constant < 128 && constant > -127\n+                  ? Opcode.IINC\n+                  : Opcode.IINC_W);\n+            this.slot = slot;\n+            this.constant = constant;\n+        }\n+\n+        @Override\n+        public int slot() {\n+            return slot;\n+        }\n+\n+        @Override\n+        public int constant() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeIncrement(slot, constant);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Increment[OP=%s, slot=%d, constant=%d]\", this.opcode(), slot(), constant());\n+        }\n+    }\n+\n+    public static final class UnboundBranchInstruction\n+            extends UnboundInstruction implements BranchInstruction {\n+        final Label target;\n+\n+        public UnboundBranchInstruction(Opcode op, Label target) {\n+            super(op);\n+            this.target = target;\n+        }\n+\n+        @Override\n+        public Label target() {\n+            return target;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeBranch(op, target);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Branch[OP=%s]\", this.opcode());\n+        }\n+    }\n+\n+    public static final class UnboundLookupSwitchInstruction\n+            extends UnboundInstruction implements LookupSwitchInstruction {\n+\n+        private final Label defaultTarget;\n+        private final List<SwitchCase> cases;\n+\n+        public UnboundLookupSwitchInstruction(Label defaultTarget, List<SwitchCase> cases) {\n+            super(Opcode.LOOKUPSWITCH);\n+            this.defaultTarget = defaultTarget;\n+            this.cases = List.copyOf(cases);\n+        }\n+\n+        @Override\n+        public List<SwitchCase> cases() {\n+            return cases;\n+        }\n+\n+        @Override\n+        public Label defaultTarget() {\n+            return defaultTarget;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeLookupSwitch(defaultTarget, cases);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LookupSwitch[OP=%s]\", this.opcode());\n+        }\n+    }\n+\n+    public static final class UnboundTableSwitchInstruction\n+            extends UnboundInstruction implements TableSwitchInstruction {\n+\n+        private final int lowValue, highValue;\n+        private final Label defaultTarget;\n+        private final List<SwitchCase> cases;\n+\n+        public UnboundTableSwitchInstruction(int lowValue, int highValue, Label defaultTarget, List<SwitchCase> cases) {\n+            super(Opcode.TABLESWITCH);\n+            this.lowValue = lowValue;\n+            this.highValue = highValue;\n+            this.defaultTarget = defaultTarget;\n+            this.cases = List.copyOf(cases);\n+        }\n+\n+        @Override\n+        public int lowValue() {\n+            return lowValue;\n+        }\n+\n+        @Override\n+        public int highValue() {\n+            return highValue;\n+        }\n+\n+        @Override\n+        public Label defaultTarget() {\n+            return defaultTarget;\n+        }\n+\n+        @Override\n+        public List<SwitchCase> cases() {\n+            return cases;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeTableSwitch(lowValue, highValue, defaultTarget, cases);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LookupSwitch[OP=%s]\", this.opcode());\n+        }\n+    }\n+\n+    public static final class UnboundReturnInstruction\n+            extends UnboundInstruction implements ReturnInstruction {\n+\n+        public UnboundReturnInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Return[OP=%s]\", this.opcode());\n+        }\n+\n+    }\n+\n+    public static final class UnboundThrowInstruction\n+            extends UnboundInstruction implements ThrowInstruction {\n+\n+        public UnboundThrowInstruction() {\n+            super(Opcode.ATHROW);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Throw[OP=%s]\", this.opcode());\n+        }\n+\n+    }\n+\n+    public static final class UnboundFieldInstruction\n+            extends UnboundInstruction implements FieldInstruction {\n+        final FieldRefEntry fieldEntry;\n+\n+        public UnboundFieldInstruction(Opcode op,\n+                                       FieldRefEntry fieldEntry) {\n+            super(op);\n+            this.fieldEntry = fieldEntry;\n+        }\n+\n+        @Override\n+        public FieldRefEntry field() {\n+            return fieldEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeFieldAccess(op, fieldEntry);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"FieldAccess[OP=%s, field=%s.%s:%s]\", this.opcode(), this.owner().asInternalName(), this.name().stringValue(), this.type().stringValue());\n+        }\n+    }\n+\n+    public static final class UnboundInvokeInstruction\n+            extends UnboundInstruction implements InvokeInstruction {\n+        final MemberRefEntry methodEntry;\n+\n+        public UnboundInvokeInstruction(Opcode op, MemberRefEntry methodEntry) {\n+            super(op);\n+            this.methodEntry = methodEntry;\n+        }\n+\n+        @Override\n+        public MemberRefEntry method() {\n+            return methodEntry;\n+        }\n+\n+        @Override\n+        public boolean isInterface() {\n+            return op == Opcode.INVOKEINTERFACE || methodEntry instanceof InterfaceMethodRefEntry;\n+        }\n+\n+        @Override\n+        public int count() {\n+            return op == Opcode.INVOKEINTERFACE\n+                   ? Util.parameterSlots(methodEntry.nameAndType().type().stringValue()) + 1\n+                   : 0;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            if (op == Opcode.INVOKEINTERFACE)\n+                writer.writeInvokeInterface(op, (InterfaceMethodRefEntry) method(), count());\n+            else\n+                writer.writeInvokeNormal(op, method());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"Invoke[OP=%s, m=%s.%s%s]\", this.opcode(), owner().asInternalName(), name().stringValue(), type().stringValue());\n+        }\n+    }\n+\n+    public static final class UnboundInvokeDynamicInstruction\n+            extends UnboundInstruction implements InvokeDynamicInstruction {\n+        final InvokeDynamicEntry indyEntry;\n+\n+        public UnboundInvokeDynamicInstruction(InvokeDynamicEntry indyEntry) {\n+            super(Opcode.INVOKEDYNAMIC);\n+            this.indyEntry = indyEntry;\n+        }\n+\n+        @Override\n+        public InvokeDynamicEntry invokedynamic() {\n+            return indyEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeInvokeDynamic(invokedynamic());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"InvokeDynamic[OP=%s, bsm=%s %s]\", this.opcode(), bootstrapMethod(), bootstrapArgs());\n+        }\n+    }\n+\n+    public static final class UnboundNewObjectInstruction\n+            extends UnboundInstruction implements NewObjectInstruction {\n+        final ClassEntry classEntry;\n+\n+        public UnboundNewObjectInstruction(ClassEntry classEntry) {\n+            super(Opcode.NEW);\n+            this.classEntry = classEntry;\n+        }\n+\n+        public ClassEntry className() {\n+            return classEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeNewObject(className());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewObj[OP=%s, type=%s]\", this.opcode(), className().asInternalName());\n+        }\n+    }\n+\n+    public static final class UnboundNewPrimitiveArrayInstruction\n+            extends UnboundInstruction implements NewPrimitiveArrayInstruction {\n+        final TypeKind typeKind;\n+\n+        public UnboundNewPrimitiveArrayInstruction(TypeKind typeKind) {\n+            super(Opcode.NEWARRAY);\n+            this.typeKind = typeKind;\n+        }\n+\n+        public TypeKind typeKind() {\n+            return typeKind;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeNewPrimitiveArray(typeKind.newarraycode());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewPrimitiveArray[OP=%s, type=%s]\", this.opcode(), typeKind());\n+        }\n+    }\n+\n+    public static final class UnboundNewReferenceArrayInstruction\n+            extends UnboundInstruction implements NewReferenceArrayInstruction {\n+        final ClassEntry componentTypeEntry;\n+\n+        public UnboundNewReferenceArrayInstruction(ClassEntry componentTypeEntry) {\n+            super(Opcode.ANEWARRAY);\n+            this.componentTypeEntry = componentTypeEntry;\n+        }\n+\n+        public ClassEntry componentType() {\n+            return componentTypeEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeNewReferenceArray(componentType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewRefArray[OP=%s, type=%s]\", this.opcode(), componentType().asInternalName());\n+        }\n+    }\n+\n+    public static final class UnboundNewMultidimensionalArrayInstruction\n+            extends UnboundInstruction implements NewMultiArrayInstruction {\n+        final ClassEntry arrayTypeEntry;\n+        final int dimensions;\n+\n+        public UnboundNewMultidimensionalArrayInstruction(ClassEntry arrayTypeEntry,\n+                                                          int dimensions) {\n+            super(Opcode.MULTIANEWARRAY);\n+            this.arrayTypeEntry = arrayTypeEntry;\n+            this.dimensions = dimensions;\n+        }\n+\n+        @Override\n+        public int dimensions() {\n+            return dimensions;\n+        }\n+\n+        public ClassEntry arrayType() {\n+            return arrayTypeEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeNewMultidimensionalArray(dimensions(), arrayType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"NewMultiArray[OP=%s, type=%s[%d]]\", this.opcode(), arrayType().asInternalName(), dimensions());\n+        }\n+\n+    }\n+\n+    public static final class UnboundArrayLoadInstruction\n+            extends UnboundInstruction implements ArrayLoadInstruction {\n+\n+        public UnboundArrayLoadInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+    }\n+\n+    public static final class UnboundArrayStoreInstruction\n+            extends UnboundInstruction implements ArrayStoreInstruction {\n+\n+        public UnboundArrayStoreInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+    }\n+\n+    public static final class UnboundTypeCheckInstruction\n+            extends UnboundInstruction implements TypeCheckInstruction {\n+        final ClassEntry typeEntry;\n+\n+        public UnboundTypeCheckInstruction(Opcode op, ClassEntry typeEntry) {\n+            super(op);\n+            this.typeEntry = typeEntry;\n+        }\n+\n+        public ClassEntry type() {\n+            return typeEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeTypeCheck(op, type());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"TypeCheck[OP=%s, type=%s]\", this.opcode(), type().asInternalName());\n+        }\n+    }\n+\n+    public static final class UnboundStackInstruction\n+            extends UnboundInstruction implements StackInstruction {\n+\n+        public UnboundStackInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+    }\n+\n+    public static final class UnboundConvertInstruction\n+            extends UnboundInstruction implements ConvertInstruction {\n+\n+        public UnboundConvertInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+        @Override\n+        public TypeKind fromType() {\n+            return op.primaryTypeKind();\n+        }\n+\n+        @Override\n+        public TypeKind toType() {\n+            return op.secondaryTypeKind();\n+        }\n+    }\n+\n+    public static final class UnboundOperatorInstruction\n+            extends UnboundInstruction implements OperatorInstruction {\n+\n+        public UnboundOperatorInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+        @Override\n+        public TypeKind typeKind() {\n+            return op.primaryTypeKind();\n+        }\n+    }\n+\n+    public static final class UnboundIntrinsicConstantInstruction\n+            extends UnboundInstruction implements ConstantInstruction.IntrinsicConstantInstruction {\n+        final ConstantDesc constant;\n+\n+        public UnboundIntrinsicConstantInstruction(Opcode op) {\n+            super(op);\n+            constant = op.constantValue();\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            super.writeTo(writer);\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return constant;\n+        }\n+    }\n+\n+    public static final class UnboundArgumentConstantInstruction\n+            extends UnboundInstruction implements ConstantInstruction.ArgumentConstantInstruction {\n+        final int value;\n+\n+        public UnboundArgumentConstantInstruction(Opcode op, int value) {\n+            super(op);\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public Integer constantValue() {\n+            return value;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeArgumentConstant(op, value);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"ArgumentConstant[OP=%s, val=%s]\", this.opcode(), constantValue());\n+        }\n+    }\n+\n+    public static final class UnboundLoadConstantInstruction\n+            extends UnboundInstruction implements ConstantInstruction.LoadConstantInstruction {\n+        final LoadableConstantEntry constant;\n+\n+        public UnboundLoadConstantInstruction(Opcode op, LoadableConstantEntry constant) {\n+            super(op);\n+            this.constant = constant;\n+        }\n+\n+        @Override\n+        public LoadableConstantEntry constantEntry() {\n+            return constant;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return constant.constantValue();\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.writeLoadConstant(op, constant);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LoadConstant[OP=%s, val=%s]\", this.opcode(), constantValue());\n+        }\n+    }\n+\n+    public static final class UnboundMonitorInstruction\n+            extends UnboundInstruction implements MonitorInstruction {\n+\n+        public UnboundMonitorInstruction(Opcode op) {\n+            super(op);\n+        }\n+\n+    }\n+\n+    public static final class UnboundNopInstruction\n+            extends UnboundInstruction implements NopInstruction {\n+\n+        public UnboundNopInstruction() {\n+            super(Opcode.NOP);\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":1308,"deletions":0,"binary":false,"changes":1308,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.CharacterRange;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.PseudoInstruction;\n+\n+\n+\/**\n+ * AbstractInstruction.\n+ *\/\n+public abstract sealed class AbstractPseudoInstruction\n+        extends AbstractElement\n+        implements PseudoInstruction {\n+\n+    public abstract void writeTo(DirectCodeBuilder writer);\n+\n+    public static final class ExceptionCatchImpl\n+            extends AbstractPseudoInstruction\n+            implements ExceptionCatch {\n+\n+        public final ClassEntry catchTypeEntry;\n+        public final Label handler;\n+        public final Label tryStart;\n+        public final Label tryEnd;\n+\n+        public ExceptionCatchImpl(Label handler, Label tryStart, Label tryEnd,\n+                                  ClassEntry catchTypeEntry) {\n+            this.catchTypeEntry = catchTypeEntry;\n+            this.handler = handler;\n+            this.tryStart = tryStart;\n+            this.tryEnd = tryEnd;\n+        }\n+\n+        public ExceptionCatchImpl(Label handler, Label tryStart, Label tryEnd,\n+                                  Optional<ClassEntry> catchTypeEntry) {\n+            this.catchTypeEntry = catchTypeEntry.orElse(null);\n+            this.handler = handler;\n+            this.tryStart = tryStart;\n+            this.tryEnd = tryEnd;\n+        }\n+\n+        @Override\n+        public Label tryStart() {\n+            return tryStart;\n+        }\n+\n+        @Override\n+        public Label handler() {\n+            return handler;\n+        }\n+\n+        @Override\n+        public Label tryEnd() {\n+            return tryEnd;\n+        }\n+\n+        @Override\n+        public Optional<ClassEntry> catchType() {\n+            return Optional.ofNullable(catchTypeEntry);\n+        }\n+\n+        ClassEntry catchTypeEntry() {\n+            return catchTypeEntry;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.addHandler(this);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"ExceptionCatch[catchType=%s]\", catchTypeEntry == null ? \"<any>\" : catchTypeEntry.name().stringValue());\n+        }\n+    }\n+\n+    public static final class UnboundCharacterRange\n+            extends AbstractPseudoInstruction\n+            implements CharacterRange {\n+\n+        public final Label startScope;\n+        public final Label endScope;\n+        public final int characterRangeStart;\n+        public final int characterRangeEnd;\n+        public final int flags;\n+\n+        public UnboundCharacterRange(Label startScope, Label endScope, int characterRangeStart,\n+                                     int characterRangeEnd, int flags) {\n+            this.startScope = startScope;\n+            this.endScope = endScope;\n+            this.characterRangeStart = characterRangeStart;\n+            this.characterRangeEnd = characterRangeEnd;\n+            this.flags = flags;\n+        }\n+\n+        @Override\n+        public Label startScope() {\n+            return startScope;\n+        }\n+\n+        @Override\n+        public Label endScope() {\n+            return endScope;\n+        }\n+\n+        @Override\n+        public int characterRangeStart() {\n+            return characterRangeStart;\n+        }\n+\n+        @Override\n+        public int characterRangeEnd() {\n+            return characterRangeEnd;\n+        }\n+\n+        @Override\n+        public int flags() {\n+            return flags;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.addCharacterRange(this);\n+        }\n+\n+    }\n+\n+    private static abstract sealed class AbstractLocalPseudo extends AbstractPseudoInstruction {\n+        protected final int slot;\n+        protected final Utf8Entry name;\n+        protected final Utf8Entry descriptor;\n+        protected final Label startScope;\n+        protected final Label endScope;\n+\n+        public AbstractLocalPseudo(int slot, Utf8Entry name, Utf8Entry descriptor, Label startScope, Label endScope) {\n+            this.slot = slot;\n+            this.name = name;\n+            this.descriptor = descriptor;\n+            this.startScope = startScope;\n+            this.endScope = endScope;\n+        }\n+\n+        public int slot() {\n+            return slot;\n+        }\n+\n+        public Utf8Entry name() {\n+            return name;\n+        }\n+\n+        public String nameString() {\n+            return name.stringValue();\n+        }\n+\n+        public Label startScope() {\n+            return startScope;\n+        }\n+\n+        public Label endScope() {\n+            return endScope;\n+        }\n+\n+        public boolean writeTo(BufWriter b) {\n+            var lc = ((BufWriterImpl)b).labelContext();\n+            int startBci = lc.labelToBci(startScope());\n+            int endBci = lc.labelToBci(endScope());\n+            if (startBci == -1 || endBci == -1) {\n+                return false;\n+            }\n+            int length = endBci - startBci;\n+            b.writeU2(startBci);\n+            b.writeU2(length);\n+            b.writeIndex(name);\n+            b.writeIndex(descriptor);\n+            b.writeU2(slot());\n+            return true;\n+        }\n+    }\n+\n+    public static final class UnboundLocalVariable extends AbstractLocalPseudo\n+            implements LocalVariable {\n+\n+        public UnboundLocalVariable(int slot, Utf8Entry name, Utf8Entry descriptor, Label startScope, Label endScope) {\n+            super(slot, name, descriptor, startScope, endScope);\n+        }\n+\n+        @Override\n+        public Utf8Entry type() {\n+            return descriptor;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.addLocalVariable(this);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LocalVariable[Slot=\" + slot()\n+                   + \", name=\" + nameString()\n+                   + \", descriptor='\" + type().stringValue()\n+                   + \"']\";\n+        }\n+    }\n+\n+    public static final class UnboundLocalVariableType extends AbstractLocalPseudo\n+            implements LocalVariableType {\n+\n+        public UnboundLocalVariableType(int slot, Utf8Entry name, Utf8Entry signature, Label startScope, Label endScope) {\n+            super(slot, name, signature, startScope, endScope);\n+        }\n+\n+        @Override\n+        public Utf8Entry signature() {\n+            return descriptor;\n+        }\n+\n+        @Override\n+        public void writeTo(DirectCodeBuilder writer) {\n+            writer.addLocalVariableType(this);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LocalVariableType[Slot=\" + slot()\n+                   + \", name=\" + nameString()\n+                   + \", signature='\" + signature().stringValue()\n+                   + \"']\";\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.AttributedElement;\n+import jdk.internal.classfile.ClassfileElement;\n+import jdk.internal.classfile.CompoundElement;\n+\n+\/**\n+ * AbstractUnboundModel\n+ *\/\n+public abstract sealed class AbstractUnboundModel<E extends ClassfileElement>\n+        extends AbstractElement\n+        implements CompoundElement<E>, AttributedElement\n+        permits BufferedCodeBuilder.Model, BufferedFieldBuilder.Model, BufferedMethodBuilder.Model {\n+    private final List<E> elements;\n+    private List<Attribute<?>> attributes;\n+\n+    public AbstractUnboundModel(List<E> elements) {\n+        this.elements = elements;\n+    }\n+\n+    @Override\n+    public void forEachElement(Consumer<E> consumer) {\n+        elements.forEach(consumer);\n+    }\n+\n+    @Override\n+    public Stream<E> elementStream() {\n+        return elements.stream();\n+    }\n+\n+    @Override\n+    public List<E> elementList() {\n+        return elements;\n+    }\n+\n+    @Override\n+    public List<Attribute<?>> attributes() {\n+        if (attributes == null)\n+            attributes = elements.stream()\n+                                 .filter(e -> e instanceof Attribute)\n+                                 .<Attribute<?>>map(e -> (Attribute<?>) e)\n+                                 .toList();\n+        return attributes;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractUnboundModel.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Set;\n+import jdk.internal.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+\/**\n+ * AccessFlagsImpl\n+ *\/\n+public final class AccessFlagsImpl extends AbstractElement\n+        implements AccessFlags {\n+\n+    private final AccessFlag.Location location;\n+    private final int flagsMask;\n+    private Set<AccessFlag> flags;\n+\n+    public  AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n+        this.location = location;\n+        this.flagsMask = Util.flagsToBits(location, flags);\n+        this.flags = Set.of(flags);\n+    }\n+\n+    public AccessFlagsImpl(AccessFlag.Location location, int mask) {\n+        this.location = location;\n+        this.flagsMask = mask;\n+    }\n+\n+    @Override\n+    public int flagsMask() {\n+        return flagsMask;\n+    }\n+\n+    @Override\n+    public Set<AccessFlag> flags() {\n+        if (flags == null)\n+            flags = AccessFlag.maskToAccessFlags(flagsMask, location);\n+        return flags;\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        builder.setFlags(flagsMask);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectMethodBuilder builder) {\n+        builder.setFlags(flagsMask);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectFieldBuilder builder) {\n+        builder.setFlags(flagsMask);\n+    }\n+\n+    @Override\n+    public AccessFlag.Location location() {\n+        return location;\n+    }\n+\n+    @Override\n+    public boolean has(AccessFlag flag) {\n+        return Util.has(location, flagsMask, flag);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"AccessFlags[flags=%d]\", flagsMask);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.util.List;\n+\n+public final class AnnotationImpl implements Annotation {\n+    private final Utf8Entry className;\n+    private final List<AnnotationElement> elements;\n+\n+    public AnnotationImpl(Utf8Entry className,\n+                          List<AnnotationElement> elems) {\n+        this.className = className;\n+        this.elements = List.copyOf(elems);\n+    }\n+\n+    @Override\n+    public Utf8Entry className() {\n+        return className;\n+    }\n+\n+    @Override\n+    public List<AnnotationElement> elements() {\n+        return elements;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter buf) {\n+        buf.writeIndex(className());\n+        buf.writeList(elements());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(\"Annotation[\");\n+        sb.append(className().stringValue());\n+        List<AnnotationElement> evps = elements();\n+        if (!evps.isEmpty())\n+            sb.append(\" [\");\n+        for (AnnotationElement evp : evps) {\n+            sb.append(evp.name().stringValue())\n+                    .append(\"=\")\n+                    .append(evp.value().toString())\n+                    .append(\", \");\n+        }\n+        if (!evps.isEmpty()) {\n+            sb.delete(sb.length()-1, sb.length());\n+            sb.append(\"]\");\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    public record AnnotationElementImpl(Utf8Entry name,\n+                                        AnnotationValue value)\n+            implements AnnotationElement {\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            buf.writeIndex(name());\n+            value().writeTo(buf);\n+        }\n+    }\n+\n+    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant\n+            permits AnnotationImpl.OfStringImpl, AnnotationImpl.OfDoubleImpl,\n+                    AnnotationImpl.OfFloatImpl, AnnotationImpl.OfLongImpl,\n+                    AnnotationImpl.OfIntegerImpl, AnnotationImpl.OfShortImpl,\n+                    AnnotationImpl.OfCharacterImpl, AnnotationImpl.OfByteImpl,\n+                    AnnotationImpl.OfBooleanImpl {\n+\n+        @Override\n+        default void writeTo(BufWriter buf) {\n+            buf.writeU1(tag());\n+            buf.writeIndex(constant());\n+        }\n+\n+        @Override\n+        default ConstantDesc constantValue() {\n+            return constant().constantValue();\n+        }\n+\n+    }\n+\n+    public record OfStringImpl(Utf8Entry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfString {\n+\n+        @Override\n+        public char tag() {\n+            return 's';\n+        }\n+\n+        @Override\n+        public String stringValue() {\n+            return constant().stringValue();\n+        }\n+    }\n+\n+    public record OfDoubleImpl(DoubleEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfDouble {\n+\n+        @Override\n+        public char tag() {\n+            return 'D';\n+        }\n+\n+        @Override\n+        public double doubleValue() {\n+            return constant().doubleValue();\n+        }\n+    }\n+\n+    public record OfFloatImpl(FloatEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfFloat {\n+\n+        @Override\n+        public char tag() {\n+            return 'F';\n+        }\n+\n+        @Override\n+        public float floatValue() {\n+            return constant().floatValue();\n+        }\n+    }\n+\n+    public record OfLongImpl(LongEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfLong {\n+\n+        @Override\n+        public char tag() {\n+            return 'J';\n+        }\n+\n+        @Override\n+        public long longValue() {\n+            return constant().longValue();\n+        }\n+    }\n+\n+    public record OfIntegerImpl(IntegerEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfInteger {\n+\n+        @Override\n+        public char tag() {\n+            return 'I';\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return constant().intValue();\n+        }\n+    }\n+\n+    public record OfShortImpl(IntegerEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfShort {\n+\n+        @Override\n+        public char tag() {\n+            return 'S';\n+        }\n+\n+        @Override\n+        public short shortValue() {\n+            return (short)constant().intValue();\n+        }\n+    }\n+\n+    public record OfCharacterImpl(IntegerEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfCharacter {\n+\n+        @Override\n+        public char tag() {\n+            return 'C';\n+        }\n+\n+        @Override\n+        public char charValue() {\n+            return (char)constant().intValue();\n+        }\n+    }\n+\n+    public record OfByteImpl(IntegerEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfByte {\n+\n+        @Override\n+        public char tag() {\n+            return 'B';\n+        }\n+\n+        @Override\n+        public byte byteValue() {\n+            return (byte)constant().intValue();\n+        }\n+    }\n+\n+    public record OfBooleanImpl(IntegerEntry constant)\n+            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfBoolean {\n+\n+        @Override\n+        public char tag() {\n+            return 'Z';\n+        }\n+\n+        @Override\n+        public boolean booleanValue() {\n+            return constant().intValue() == 1;\n+        }\n+    }\n+\n+    public record OfArrayImpl(List<AnnotationValue> values)\n+            implements AnnotationValue.OfArray {\n+\n+        public OfArrayImpl(List<AnnotationValue> values) {\n+            this.values = List.copyOf(values);;\n+        }\n+\n+        @Override\n+        public char tag() {\n+            return '[';\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            buf.writeU1(tag());\n+            buf.writeList(values);\n+        }\n+\n+    }\n+\n+    public record OfEnumImpl(Utf8Entry className, Utf8Entry constantName)\n+            implements AnnotationValue.OfEnum {\n+        @Override\n+        public char tag() {\n+            return 'e';\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            buf.writeU1(tag());\n+            buf.writeIndex(className);\n+            buf.writeIndex(constantName);\n+        }\n+\n+    }\n+\n+    public record OfAnnotationImpl(Annotation annotation)\n+            implements AnnotationValue.OfAnnotation {\n+        @Override\n+        public char tag() {\n+            return '@';\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            buf.writeU1(tag());\n+            annotation.writeTo(buf);\n+        }\n+\n+    }\n+\n+    public record OfClassImpl(Utf8Entry className)\n+            implements AnnotationValue.OfClass {\n+        @Override\n+        public char tag() {\n+            return 'c';\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            buf.writeU1(tag());\n+            buf.writeIndex(className);\n+        }\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.TypeAnnotation;\n+import static jdk.internal.classfile.Classfile.*;\n+import static jdk.internal.classfile.TypeAnnotation.TargetInfo.*;\n+\n+import java.util.List;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.access.SharedSecrets;\n+\n+class AnnotationReader {\n+    private AnnotationReader() { }\n+\n+    public static List<Annotation> readAnnotations(ClassReader classReader, int p) {\n+        int pos = p;\n+        int numAnnotations = classReader.readU2(pos);\n+        var annos = new Object[numAnnotations];\n+        pos += 2;\n+        for (int i = 0; i < numAnnotations; ++i) {\n+            annos[i] = readAnnotation(classReader, pos);\n+            pos = skipAnnotation(classReader, pos);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(annos);\n+    }\n+\n+    public static AnnotationValue readElementValue(ClassReader classReader, int p) {\n+        char tag = (char) classReader.readU1(p);\n+        ++p;\n+        return switch (tag) {\n+            case 'B' -> new AnnotationImpl.OfByteImpl((IntegerEntry)classReader.readEntry(p));\n+            case 'C' -> new AnnotationImpl.OfCharacterImpl((IntegerEntry)classReader.readEntry(p));\n+            case 'D' -> new AnnotationImpl.OfDoubleImpl((DoubleEntry)classReader.readEntry(p));\n+            case 'F' -> new AnnotationImpl.OfFloatImpl((FloatEntry)classReader.readEntry(p));\n+            case 'I' -> new AnnotationImpl.OfIntegerImpl((IntegerEntry)classReader.readEntry(p));\n+            case 'J' -> new AnnotationImpl.OfLongImpl((LongEntry)classReader.readEntry(p));\n+            case 'S' -> new AnnotationImpl.OfShortImpl((IntegerEntry)classReader.readEntry(p));\n+            case 'Z' -> new AnnotationImpl.OfBooleanImpl((IntegerEntry)classReader.readEntry(p));\n+            case 's' -> new AnnotationImpl.OfStringImpl(classReader.readUtf8Entry(p));\n+            case 'e' -> new AnnotationImpl.OfEnumImpl(classReader.readUtf8Entry(p), classReader.readUtf8Entry(p + 2));\n+            case 'c' -> new AnnotationImpl.OfClassImpl(classReader.readUtf8Entry(p));\n+            case '@' -> new AnnotationImpl.OfAnnotationImpl(readAnnotation(classReader, p));\n+            case '[' -> {\n+                int numValues = classReader.readU2(p);\n+                p += 2;\n+                var values = new Object[numValues];\n+                for (int i = 0; i < numValues; ++i) {\n+                    values[i] = readElementValue(classReader, p);\n+                    p = skipElementValue(classReader, p);\n+                }\n+                yield new AnnotationImpl.OfArrayImpl(SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(values));\n+            }\n+            default -> throw new IllegalArgumentException(\n+                    \"Unexpected tag '%s' in AnnotationValue, pos = %d\".formatted(tag, p - 1));\n+        };\n+    }\n+\n+    public static List<TypeAnnotation> readTypeAnnotations(ClassReader classReader, int p, LabelContext lc) {\n+        int numTypeAnnotations = classReader.readU2(p);\n+        p += 2;\n+        var annotations = new Object[numTypeAnnotations];\n+        for (int i = 0; i < numTypeAnnotations; ++i) {\n+            annotations[i] = readTypeAnnotation(classReader, p, lc);\n+            p = skipTypeAnnotation(classReader, p);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(annotations);\n+    }\n+\n+    public static List<List<Annotation>> readParameterAnnotations(ClassReader classReader, int p, boolean isVisible) {\n+        int cnt = classReader.readU1(p++);\n+        var pas = new Object[cnt];\n+        for (int i = 0; i < cnt; ++i) {\n+            pas[i] = readAnnotations(classReader, p);\n+            p = skipAnnotations(classReader, p);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(pas);\n+    }\n+\n+    private static int skipElementValue(ClassReader classReader, int p) {\n+        char tag = (char) classReader.readU1(p);\n+        ++p;\n+        return switch (tag) {\n+            case 'B', 'C', 'D', 'F', 'I', 'J', 'S', 'Z', 's', 'c' -> p + 2;\n+            case 'e' -> p + 4;\n+            case '@' -> skipAnnotation(classReader, p);\n+            case '[' -> {\n+                int numValues = classReader.readU2(p);\n+                p += 2;\n+                for (int i = 0; i < numValues; ++i) {\n+                    p = skipElementValue(classReader, p);\n+                }\n+                yield p;\n+            }\n+            default -> throw new IllegalArgumentException(\n+                    \"Unexpected tag '%s' in AnnotationValue, pos = %d\".formatted(tag, p - 1));\n+        };\n+    }\n+\n+    private static Annotation readAnnotation(ClassReader classReader, int p) {\n+        Utf8Entry annotationClass = classReader.utf8EntryByIndex(classReader.readU2(p));\n+        p += 2;\n+        List<AnnotationElement> elems = readAnnotationElementValuePairs(classReader, p);\n+        return new AnnotationImpl(annotationClass, elems);\n+    }\n+\n+    private static int skipAnnotations(ClassReader classReader, int p) {\n+        int numAnnotations = classReader.readU2(p);\n+        p += 2;\n+        for (int i = 0; i < numAnnotations; ++i)\n+            p = skipAnnotation(classReader, p);\n+        return p;\n+    }\n+\n+    private static int skipAnnotation(ClassReader classReader, int p) {\n+        return skipElementValuePairs(classReader, p + 2);\n+    }\n+\n+    private static List<AnnotationElement> readAnnotationElementValuePairs(ClassReader classReader, int p) {\n+        int numElementValuePairs = classReader.readU2(p);\n+        p += 2;\n+        var annotationElements = new Object[numElementValuePairs];\n+        for (int i = 0; i < numElementValuePairs; ++i) {\n+            Utf8Entry elementName = classReader.readUtf8Entry(p);\n+            p += 2;\n+            AnnotationValue value = readElementValue(classReader, p);\n+            annotationElements[i] = new AnnotationImpl.AnnotationElementImpl(elementName, value);\n+            p = skipElementValue(classReader, p);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(annotationElements);\n+    }\n+\n+    private static int skipElementValuePairs(ClassReader classReader, int p) {\n+        int numElementValuePairs = classReader.readU2(p);\n+        p += 2;\n+        for (int i = 0; i < numElementValuePairs; ++i) {\n+            p = skipElementValue(classReader, p + 2);\n+        }\n+        return p;\n+    }\n+\n+    private static Label getLabel(LabelContext lc, int bciOffset, int targetType, int p) {\n+        \/\/helper method to avoid NPE\n+        if (lc == null) throw new IllegalArgumentException(\"Unexpected targetType '%d' in TypeAnnotation outside of Code attribute, pos = %d\".formatted(targetType, p - 1));\n+        return lc.getLabel(bciOffset);\n+    }\n+\n+    private static TypeAnnotation readTypeAnnotation(ClassReader classReader, int p, LabelContext lc) {\n+        int targetType = classReader.readU1(p++);\n+        var targetInfo = switch (targetType) {\n+            case TAT_CLASS_TYPE_PARAMETER ->\n+                ofClassTypeParameter(classReader.readU1(p));\n+            case TAT_METHOD_TYPE_PARAMETER ->\n+                ofMethodTypeParameter(classReader.readU1(p));\n+            case TAT_CLASS_EXTENDS ->\n+                ofClassExtends(classReader.readU2(p));\n+            case TAT_CLASS_TYPE_PARAMETER_BOUND ->\n+                ofClassTypeParameterBound(classReader.readU1(p), classReader.readU1(p + 1));\n+            case TAT_METHOD_TYPE_PARAMETER_BOUND ->\n+                ofMethodTypeParameterBound(classReader.readU1(p), classReader.readU1(p + 1));\n+            case TAT_FIELD ->\n+                ofField();\n+            case TAT_METHOD_RETURN ->\n+                ofMethodReturn();\n+            case TAT_METHOD_RECEIVER ->\n+                ofMethodReceiver();\n+            case TAT_METHOD_FORMAL_PARAMETER ->\n+                ofMethodFormalParameter(classReader.readU1(p));\n+            case TAT_THROWS ->\n+                ofThrows(classReader.readU2(p));\n+            case TAT_LOCAL_VARIABLE ->\n+                ofLocalVariable(readLocalVarEntries(classReader, p, lc, targetType));\n+            case TAT_RESOURCE_VARIABLE ->\n+                ofResourceVariable(readLocalVarEntries(classReader, p, lc, targetType));\n+            case TAT_EXCEPTION_PARAMETER ->\n+                ofExceptionParameter(classReader.readU2(p));\n+            case TAT_INSTANCEOF ->\n+                ofInstanceofExpr(getLabel(lc, classReader.readU2(p), targetType, p));\n+            case TAT_NEW ->\n+                ofNewExpr(getLabel(lc, classReader.readU2(p), targetType, p));\n+            case TAT_CONSTRUCTOR_REFERENCE ->\n+                ofConstructorReference(getLabel(lc, classReader.readU2(p), targetType, p));\n+            case TAT_METHOD_REFERENCE ->\n+                ofMethodReference(getLabel(lc, classReader.readU2(p), targetType, p));\n+            case TAT_CAST ->\n+                ofCastExpr(getLabel(lc, classReader.readU2(p), targetType, p), classReader.readU1(p + 2));\n+            case TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT ->\n+                ofConstructorInvocationTypeArgument(getLabel(lc, classReader.readU2(p), targetType, p), classReader.readU1(p + 2));\n+            case TAT_METHOD_INVOCATION_TYPE_ARGUMENT ->\n+                ofMethodInvocationTypeArgument(getLabel(lc, classReader.readU2(p), targetType, p), classReader.readU1(p + 2));\n+            case TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT ->\n+                ofConstructorReferenceTypeArgument(getLabel(lc, classReader.readU2(p), targetType, p), classReader.readU1(p + 2));\n+            case TAT_METHOD_REFERENCE_TYPE_ARGUMENT ->\n+                ofMethodReferenceTypeArgument(getLabel(lc, classReader.readU2(p), targetType, p), classReader.readU1(p + 2));\n+            default ->\n+                throw new IllegalArgumentException(\"Unexpected targetType '%d' in TypeAnnotation, pos = %d\".formatted(targetType, p - 1));\n+        };\n+        p += targetInfo.size();\n+        int pathLength = classReader.readU1(p++);\n+        TypeAnnotation.TypePathComponent[] typePath = new TypeAnnotation.TypePathComponent[pathLength];\n+        for (int i = 0; i < pathLength; ++i) {\n+            int typePathKindTag = classReader.readU1(p++);\n+            int typeArgumentIndex = classReader.readU1(p++);\n+            typePath[i] = switch (typePathKindTag) {\n+                case 0 -> TypeAnnotation.TypePathComponent.ARRAY;\n+                case 1 -> TypeAnnotation.TypePathComponent.INNER_TYPE;\n+                case 2 -> TypeAnnotation.TypePathComponent.WILDCARD;\n+                case 3 -> new UnboundAttribute.TypePathComponentImpl(TypeAnnotation.TypePathComponent.Kind.TYPE_ARGUMENT, typeArgumentIndex);\n+                default -> throw new IllegalArgumentException(\"Unknown type annotation path component kind: \" + typePathKindTag);\n+            };\n+        }\n+        \/\/ the annotation info for this annotation\n+        Utf8Entry type = classReader.readUtf8Entry(p);\n+        p += 2;\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n+                                 readAnnotationElementValuePairs(classReader, p));\n+    }\n+\n+    private static List<TypeAnnotation.LocalVarTargetInfo> readLocalVarEntries(ClassReader classReader, int p, LabelContext lc, int targetType) {\n+        int tableLength = classReader.readU2(p);\n+        p += 2;\n+        var entries = new Object[tableLength];\n+        for (int i = 0; i < tableLength; ++i) {\n+            int startPc = classReader.readU2(p);\n+            entries[i] = TypeAnnotation.LocalVarTargetInfo.of(\n+                    getLabel(lc, startPc, targetType, p),\n+                    getLabel(lc, startPc + classReader.readU2(p + 2), targetType, p - 2),\n+                    classReader.readU2(p + 4));\n+            p += 6;\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(entries);\n+    }\n+\n+    private static int skipTypeAnnotation(ClassReader classReader, int p) {\n+        int targetType = classReader.readU1(p++);\n+        p += switch (targetType) {\n+            case 0x13, 0x14, 0x15 -> 0;\n+            case 0x00, 0x01, 0x16 -> 1;\n+            case 0x10, 0x11, 0x12, 0x17, 0x42, 0x43, 0x44, 0x45, 0x46 -> 2;\n+            case 0x47, 0x48, 0x49, 0x4A, 0x4B -> 3;\n+            case 0x40, 0x41 -> 2 + classReader.readU2(p) * 6;\n+            default -> throw new IllegalArgumentException(\n+                    \"Unexpected targetType '%d' in TypeAnnotation, pos = %d\".formatted(targetType, p - 1));\n+        };\n+        int pathLength = classReader.readU1(p++);\n+        p += pathLength * 2;\n+\n+        \/\/ the annotation info for this annotation\n+        p += 2;\n+        p = skipElementValuePairs(classReader, p);\n+        return p;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.AttributeMapper;\n+import jdk.internal.classfile.BufWriter;\n+\n+public class AttributeHolder {\n+    private final List<Attribute<?>> attributes = new ArrayList<>();\n+\n+    public AttributeHolder() {\n+    }\n+\n+    public <A extends Attribute<A>> void withAttribute(Attribute<?> a) {\n+        if (a == null)\n+            return;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        AttributeMapper<A> am = (AttributeMapper<A>) a.attributeMapper();\n+        if (!am.allowMultiple() && isPresent(am)) {\n+            remove(am);\n+        }\n+        attributes.add(a);\n+    }\n+\n+    public int size() {\n+        return attributes.size();\n+    }\n+\n+    public void writeTo(BufWriter buf) {\n+        buf.writeU2(attributes.size());\n+        for (Attribute<?> a : attributes)\n+            a.writeTo(buf);\n+    }\n+\n+    boolean isPresent(AttributeMapper<?> am) {\n+        for (Attribute<?> a : attributes)\n+            if (a.attributeMapper() == am)\n+                return true;\n+        return false;\n+    }\n+\n+    private void remove(AttributeMapper<?> am) {\n+        for (ListIterator<Attribute<?>> iterator = attributes.listIterator();\n+             iterator.hasNext(); ) {\n+            Attribute<?> a = iterator.next();\n+            if (a.attributeMapper() == am)\n+                iterator.remove();\n+        }\n+    }\n+\n+    List<? extends Attribute<?>> attributes() {\n+        return attributes;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+\n+import java.util.Objects;\n+import jdk.internal.classfile.Instruction;\n+\n+\/**\n+ * BlockCodeBuilder\n+ *\/\n+public final class BlockCodeBuilderImpl\n+        extends NonterminalCodeBuilder\n+        implements CodeBuilder.BlockCodeBuilder {\n+    private final Label startLabel, endLabel, breakLabel;\n+    private boolean reachable = true;\n+    private boolean hasInstructions = false;\n+    private int topLocal;\n+    private int terminalMaxLocals;\n+\n+    public BlockCodeBuilderImpl(CodeBuilder parent, Label breakLabel) {\n+        super(parent);\n+        this.startLabel = parent.newLabel();\n+        this.endLabel = parent.newLabel();\n+        this.breakLabel = Objects.requireNonNull(breakLabel);\n+    }\n+\n+    public void start() {\n+        topLocal = topLocal(parent);\n+        terminalMaxLocals = topLocal(terminal);\n+        terminal.with((LabelTarget) startLabel);\n+    }\n+\n+    public void end() {\n+        terminal.with((LabelTarget) endLabel);\n+        if (terminalMaxLocals != topLocal(terminal)) {\n+            throw new IllegalStateException(\"Interference in local variable slot management\");\n+        }\n+    }\n+\n+    public boolean reachable() {\n+        return reachable;\n+    }\n+\n+    public boolean isEmpty() {\n+        return !hasInstructions;\n+    }\n+\n+    private int topLocal(CodeBuilder parent) {\n+        return switch (parent) {\n+            case BlockCodeBuilderImpl b -> b.topLocal;\n+            case ChainedCodeBuilder b -> topLocal(b.terminal);\n+            case DirectCodeBuilder b -> b.curTopLocal();\n+            case BufferedCodeBuilder b -> b.curTopLocal();\n+            case TransformingCodeBuilder b -> topLocal(b.delegate);\n+        };\n+    }\n+\n+    @Override\n+    public CodeBuilder with(CodeElement element) {\n+        parent.with(element);\n+\n+        hasInstructions |= element instanceof Instruction;\n+\n+        if (reachable) {\n+            if (element instanceof Instruction i && i.opcode().isUnconditionalBranch())\n+                reachable = false;\n+        }\n+        else if (element instanceof LabelTarget) {\n+            reachable = true;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Label startLabel() {\n+        return startLabel;\n+    }\n+\n+    @Override\n+    public Label endLabel() {\n+        return endLabel;\n+    }\n+\n+    @Override\n+    public int allocateLocal(TypeKind typeKind) {\n+        int retVal = topLocal;\n+        topLocal += typeKind.slotSize();\n+        return retVal;\n+    }\n+\n+    @Override\n+    public Label breakLabel() {\n+        return breakLabel;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,1010 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantValueEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * BoundAttribute\n+ *\/\n+public abstract sealed class BoundAttribute<T extends Attribute<T>>\n+        extends AbstractElement\n+        implements Attribute<T> {\n+\n+    static final int NAME_AND_LENGTH_PREFIX = 6;\n+    private final AttributeMapper<T> mapper;\n+    final ClassReader classReader;\n+    final int payloadStart;\n+\n+    BoundAttribute(ClassReader classReader, AttributeMapper<T> mapper, int payloadStart) {\n+        this.mapper = mapper;\n+        this.classReader = classReader;\n+        this.payloadStart = payloadStart;\n+    }\n+\n+    public int payloadLen() {\n+        return classReader.readInt(payloadStart - 4);\n+    }\n+\n+    @Override\n+    public String attributeName() {\n+        return mapper.name();\n+    }\n+\n+    @Override\n+    public AttributeMapper<T> attributeMapper() {\n+        return mapper;\n+    }\n+\n+    public byte[] contents() {\n+        return classReader.readBytes(payloadStart, payloadLen());\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectMethodBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectFieldBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void writeTo(BufWriter buf) {\n+        if (!buf.canWriteDirect(classReader))\n+            attributeMapper().writeAttribute(buf, (T) this);\n+        else\n+            classReader.copyBytesTo(buf, payloadStart - NAME_AND_LENGTH_PREFIX, payloadLen() + NAME_AND_LENGTH_PREFIX);\n+    }\n+\n+    public ConstantPool constantPool() {\n+        return classReader;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Attribute[name=%s]\", mapper.name());\n+    }\n+\n+    <E> List<E> readEntryList(int p) {\n+        int cnt = classReader.readU2(p);\n+        p += 2;\n+        var entries = new Object[cnt];\n+        int end = p + (cnt * 2);\n+        for (int i = 0; p < end; i++, p += 2) {\n+            entries[i] = classReader.readEntry(p);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(entries);\n+    }\n+\n+    public static List<Attribute<?>> readAttributes(AttributedElement enclosing, ClassReader reader, int pos,\n+                                                                  Function<Utf8Entry, AttributeMapper<?>> customAttributes) {\n+        int size = reader.readU2(pos);\n+        var filled = new Object[size];\n+        int p = pos + 2;\n+        for (int i = 0; i < size; ++i) {\n+            Utf8Entry name = reader.readUtf8Entry(p);\n+            int len = reader.readInt(p + 2);\n+            p += 6;\n+\n+            var mapper = Attributes.standardAttribute(name);\n+            if (mapper == null) {\n+                mapper = customAttributes.apply(name);\n+            }\n+            if (mapper != null) {\n+                filled[i] = mapper.readAttribute(enclosing, reader, p);\n+            } else if (((ClassReaderImpl)reader).options().processUnknownAttributes) {\n+                AttributeMapper<UnknownAttribute> fakeMapper = new AttributeMapper<>() {\n+                    @Override\n+                    public String name() {\n+                        return name.stringValue();\n+                    }\n+\n+                    @Override\n+                    public UnknownAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                        \/\/ Will never get called\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n+                    @Override\n+                    public void writeAttribute(BufWriter buf, UnknownAttribute attr) {\n+                        throw new UnsupportedOperationException(\"Write of unknown attribute \" + name() + \" not supported\");\n+                    }\n+\n+                    @Override\n+                    public boolean allowMultiple() {\n+                        return true;\n+                    }\n+                };\n+                filled[i] = new BoundUnknownAttribute(reader, fakeMapper, p);\n+            }\n+            p += len;\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(filled);\n+    }\n+\n+    public static final class BoundUnknownAttribute extends BoundAttribute<UnknownAttribute>\n+            implements UnknownAttribute {\n+        public BoundUnknownAttribute(ClassReader cf, AttributeMapper<UnknownAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectClassBuilder builder) {\n+            checkWriteSupported(builder::canWriteDirect);\n+            super.writeTo(builder);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectMethodBuilder builder) {\n+            checkWriteSupported(builder::canWriteDirect);\n+            super.writeTo(builder);\n+        }\n+\n+        @Override\n+        public void writeTo(DirectFieldBuilder builder) {\n+            checkWriteSupported(builder::canWriteDirect);\n+            super.writeTo(builder);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            checkWriteSupported(buf::canWriteDirect);\n+            super.writeTo(buf);\n+        }\n+\n+        private void checkWriteSupported(Function<ConstantPool, Boolean> condition) {\n+            if (!condition.apply(classReader))\n+                throw new UnsupportedOperationException(\"Write of unknown attribute \" + attributeName() + \" not supported to alien constant pool\");\n+        }\n+    }\n+\n+    public static final class BoundStackMapTableAttribute\n+            extends BoundAttribute<StackMapTableAttribute>\n+            implements StackMapTableAttribute {\n+        final MethodModel method;\n+        final LabelContext ctx;\n+        List<StackMapFrameInfo> entries = null;\n+\n+        public BoundStackMapTableAttribute(CodeImpl code, ClassReader cf, AttributeMapper<StackMapTableAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            method = code.parent().orElseThrow();\n+            ctx = code;\n+        }\n+\n+        @Override\n+        public List<StackMapFrameInfo> entries() {\n+            if (entries == null) {\n+                entries = new StackMapDecoder(classReader, payloadStart, ctx, StackMapDecoder.initFrameLocals(method)).entries();\n+            }\n+            return entries;\n+        }\n+    }\n+\n+    public static final class BoundSyntheticAttribute extends BoundAttribute<SyntheticAttribute>\n+            implements SyntheticAttribute {\n+        public BoundSyntheticAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<SyntheticAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+    }\n+\n+    public static final class BoundLineNumberTableAttribute\n+            extends BoundAttribute<LineNumberTableAttribute>\n+            implements LineNumberTableAttribute {\n+        private List<LineNumberInfo> lineNumbers = null;\n+\n+        public BoundLineNumberTableAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<LineNumberTableAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<LineNumberInfo> lineNumbers() {\n+            if (lineNumbers == null) {\n+                int nLn = classReader.readU2(payloadStart);\n+                LineNumberInfo[] elements = new LineNumberInfo[nLn];\n+                int p = payloadStart + 2;\n+                int pEnd = p + (nLn * 4);\n+                for (int i = 0; p < pEnd; p += 4, i++) {\n+                    int startPc = classReader.readU2(p);\n+                    int lineNumber = classReader.readU2(p + 2);\n+                    elements[i] = LineNumberInfo.of(startPc, lineNumber);\n+                }\n+                lineNumbers = List.of(elements);\n+            }\n+            return lineNumbers;\n+        }\n+    }\n+\n+    public static final class BoundCharacterRangeTableAttribute extends BoundAttribute<CharacterRangeTableAttribute> implements CharacterRangeTableAttribute {\n+        private List<CharacterRangeInfo> characterRangeTable = null;\n+\n+        public BoundCharacterRangeTableAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<CharacterRangeTableAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<CharacterRangeInfo> characterRangeTable() {\n+            if (characterRangeTable == null) {\n+                int nLn = classReader.readU2(payloadStart);\n+                CharacterRangeInfo[] elements = new CharacterRangeInfo[nLn];\n+                int p = payloadStart + 2;\n+                int pEnd = p + (nLn * 14);\n+                for (int i = 0; p < pEnd; p += 14, i++) {\n+                    int startPc = classReader.readU2(p);\n+                    int endPc = classReader.readU2(p + 2);\n+                    int characterRangeStart = classReader.readInt(p + 4);\n+                    int characterRangeEnd = classReader.readInt(p + 8);\n+                    int flags = classReader.readU2(p + 12);\n+                    elements[i] = CharacterRangeInfo.of(startPc, endPc, characterRangeStart, characterRangeEnd, flags);\n+                }\n+                characterRangeTable = List.of(elements);\n+            }\n+            return characterRangeTable;\n+        }\n+    }\n+\n+    public static final class BoundLocalVariableTableAttribute\n+            extends BoundAttribute<LocalVariableTableAttribute>\n+            implements LocalVariableTableAttribute {\n+        private final CodeImpl codeAttribute;\n+        private List<LocalVariableInfo> localVars = null;\n+\n+        public BoundLocalVariableTableAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<LocalVariableTableAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            codeAttribute = (CodeImpl) enclosing;\n+        }\n+\n+        @Override\n+        public List<LocalVariableInfo> localVariables() {\n+            if (localVars == null) {\n+                int cnt = classReader.readU2(payloadStart);\n+                BoundLocalVariable[] elements = new BoundLocalVariable[cnt];\n+                int p = payloadStart + 2;\n+                int pEnd = p + (cnt * 10);\n+                for (int i = 0; p < pEnd; p += 10, i++) {\n+                    elements[i] = new BoundLocalVariable(codeAttribute, p);\n+                }\n+                localVars = List.of(elements);\n+            }\n+            return localVars;\n+        }\n+    }\n+\n+    public static final class BoundLocalVariableTypeTableAttribute\n+            extends BoundAttribute<LocalVariableTypeTableAttribute>\n+            implements LocalVariableTypeTableAttribute {\n+        private final CodeImpl codeAttribute;\n+        private List<LocalVariableTypeInfo> localVars = null;\n+\n+        public BoundLocalVariableTypeTableAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<LocalVariableTypeTableAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            this.codeAttribute = (CodeImpl) enclosing;\n+        }\n+\n+        @Override\n+        public List<LocalVariableTypeInfo> localVariableTypes() {\n+            if (localVars == null) {\n+                final int cnt = classReader.readU2(payloadStart);\n+                BoundLocalVariableType[] elements = new BoundLocalVariableType[cnt];\n+                int p = payloadStart + 2;\n+                int pEnd = p + (cnt * 10);\n+                for (int i = 0; p < pEnd; p += 10, i++) {\n+                    elements[i] = new BoundLocalVariableType(codeAttribute, p);\n+                }\n+                localVars = List.of(elements);\n+            }\n+            return localVars;\n+        }\n+    }\n+\n+    public static final class BoundMethodParametersAttribute extends BoundAttribute<MethodParametersAttribute>\n+            implements MethodParametersAttribute {\n+        private List<MethodParameterInfo> parameters = null;\n+\n+        public BoundMethodParametersAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<MethodParametersAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<MethodParameterInfo> parameters() {\n+            if (parameters == null) {\n+                final int cnt = classReader.readU1(payloadStart);\n+                MethodParameterInfo[] elements = new MethodParameterInfo[cnt];\n+                int p = payloadStart + 1;\n+                int pEnd = p + (cnt * 4);\n+                for (int i = 0; p < pEnd; p += 4, i++) {\n+                    Utf8Entry name = classReader.readUtf8Entry(p);\n+                    int accessFlags = classReader.readU2(p + 2);\n+                    elements[i] = MethodParameterInfo.of(Optional.ofNullable(name), accessFlags);\n+                }\n+                parameters = List.of(elements);\n+            }\n+            return parameters;\n+        }\n+    }\n+\n+    public static final class BoundModuleHashesAttribute extends BoundAttribute<ModuleHashesAttribute>\n+            implements ModuleHashesAttribute {\n+        private List<ModuleHashInfo> hashes = null;\n+\n+        public BoundModuleHashesAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ModuleHashesAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public Utf8Entry algorithm() {\n+            return classReader.readUtf8Entry(payloadStart);\n+        }\n+\n+        @Override\n+        public List<ModuleHashInfo> hashes() {\n+            if (hashes == null) {\n+                final int cnt = classReader.readU2(payloadStart + 2);\n+                ModuleHashInfo[] elements = new ModuleHashInfo[cnt];\n+                int p = payloadStart + 4;\n+                \/\/System.err.printf(\"%5d: ModuleHashesAttr alg = %s, cnt = %d%n\", pos, algorithm(), cnt);\n+                for (int i = 0; i < cnt; ++i) {\n+                    ModuleEntry module = classReader.readModuleEntry(p);\n+                    int hashLength = classReader.readU2(p + 2);\n+                    \/\/System.err.printf(\"%5d:     [%d] module = %s, hashLength = %d%n\", p, i, module, hashLength);\n+                    p += 4;\n+                    elements[i] = ModuleHashInfo.of(module, classReader.readBytes(p, hashLength));\n+                    p += hashLength;\n+                }\n+                hashes = List.of(elements);\n+            }\n+            return hashes;\n+        }\n+    }\n+\n+    public static final class BoundRecordAttribute extends BoundAttribute<RecordAttribute>\n+            implements RecordAttribute {\n+        private List<RecordComponentInfo> components = null;\n+\n+        public BoundRecordAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<RecordAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<RecordComponentInfo> components() {\n+            if (components == null) {\n+                final int cnt = classReader.readU2(payloadStart);\n+                RecordComponentInfo[] elements = new RecordComponentInfo[cnt];\n+                int p = payloadStart + 2;\n+                for (int i = 0; i < cnt; i++) {\n+                    int endP = classReader.skipAttributeHolder(p + 4);\n+                    elements[i] = new BoundRecordComponentInfo(classReader, p, endP);\n+                    p = endP;\n+                }\n+                components = List.of(elements);\n+            }\n+            return components;\n+        }\n+    }\n+\n+    public static final class BoundDeprecatedAttribute extends BoundAttribute<DeprecatedAttribute>\n+            implements DeprecatedAttribute {\n+        public BoundDeprecatedAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<DeprecatedAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+    }\n+\n+    public static final class BoundSignatureAttribute extends BoundAttribute<SignatureAttribute>\n+            implements SignatureAttribute {\n+        public BoundSignatureAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<SignatureAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public Utf8Entry signature() {\n+            return classReader.readUtf8Entry(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundSourceFileAttribute extends BoundAttribute<SourceFileAttribute>\n+            implements SourceFileAttribute {\n+        public BoundSourceFileAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<SourceFileAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public Utf8Entry sourceFile() {\n+            return classReader.readUtf8Entry(payloadStart);\n+        }\n+\n+    }\n+\n+    public static final class BoundModuleMainClassAttribute extends BoundAttribute<ModuleMainClassAttribute> implements ModuleMainClassAttribute {\n+        public BoundModuleMainClassAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ModuleMainClassAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public ClassEntry mainClass() {\n+            return classReader.readClassEntry(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundNestHostAttribute extends BoundAttribute<NestHostAttribute>\n+            implements NestHostAttribute {\n+        public BoundNestHostAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<NestHostAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public ClassEntry nestHost() {\n+            return classReader.readClassEntry(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundSourceDebugExtensionAttribute extends BoundAttribute<SourceDebugExtensionAttribute>\n+            implements SourceDebugExtensionAttribute {\n+        public BoundSourceDebugExtensionAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<SourceDebugExtensionAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+    }\n+\n+    public static final class BoundConstantValueAttribute extends BoundAttribute<ConstantValueAttribute>\n+            implements ConstantValueAttribute {\n+        public BoundConstantValueAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ConstantValueAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public ConstantValueEntry constant() {\n+            return (ConstantValueEntry) classReader.readEntry(payloadStart);\n+        }\n+\n+    }\n+\n+    public static final class BoundModuleTargetAttribute extends BoundAttribute<ModuleTargetAttribute>\n+            implements ModuleTargetAttribute {\n+        public BoundModuleTargetAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ModuleTargetAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public Utf8Entry targetPlatform() {\n+            return classReader.readUtf8Entry(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundCompilationIDAttribute extends BoundAttribute<CompilationIDAttribute>\n+            implements CompilationIDAttribute {\n+        public BoundCompilationIDAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<CompilationIDAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public Utf8Entry compilationId() {\n+            return classReader.readUtf8Entry(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundSourceIDAttribute extends BoundAttribute<SourceIDAttribute>\n+            implements SourceIDAttribute {\n+        public BoundSourceIDAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<SourceIDAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public Utf8Entry sourceId() {\n+            return classReader.readUtf8Entry(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundModuleResolutionAttribute extends BoundAttribute<ModuleResolutionAttribute>\n+            implements ModuleResolutionAttribute {\n+        public BoundModuleResolutionAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ModuleResolutionAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public int resolutionFlags() {\n+            return classReader.readU2(payloadStart);\n+        }\n+    }\n+\n+    public static final class BoundExceptionsAttribute extends BoundAttribute<ExceptionsAttribute>\n+            implements ExceptionsAttribute {\n+        private List<ClassEntry> exceptions = null;\n+\n+        public BoundExceptionsAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ExceptionsAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> exceptions() {\n+            if (exceptions == null) {\n+                exceptions = readEntryList(payloadStart);\n+            }\n+            return exceptions;\n+        }\n+    }\n+\n+    public static final class BoundModuleAttribute extends BoundAttribute<ModuleAttribute>\n+            implements ModuleAttribute {\n+        private List<ModuleRequireInfo> requires = null;\n+        private List<ModuleExportInfo> exports = null;\n+        private List<ModuleOpenInfo> opens = null;\n+        private List<ClassEntry> uses = null;\n+        private List<ModuleProvideInfo> provides = null;\n+\n+        public BoundModuleAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ModuleAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public ModuleEntry moduleName() {\n+            return classReader.readModuleEntry(payloadStart);\n+        }\n+\n+        @Override\n+        public int moduleFlagsMask() {\n+            return classReader.readU2(payloadStart + 2);\n+        }\n+\n+        @Override\n+        public Optional<Utf8Entry> moduleVersion() {\n+            return Optional.ofNullable(classReader.readUtf8EntryOrNull(payloadStart + 4));\n+        }\n+\n+        @Override\n+        public List<ModuleRequireInfo> requires() {\n+            if (requires == null) {\n+                structure();\n+            }\n+            return requires;\n+        }\n+\n+        @Override\n+        public List<ModuleExportInfo> exports() {\n+            if (exports == null) {\n+                structure();\n+            }\n+            return exports;\n+        }\n+\n+        @Override\n+        public List<ModuleOpenInfo> opens() {\n+            if (opens == null) {\n+                structure();\n+            }\n+            return opens;\n+        }\n+\n+        @Override\n+        public List<ClassEntry> uses() {\n+            if (uses == null) {\n+                structure();\n+            }\n+            return uses;\n+        }\n+\n+        @Override\n+        public List<ModuleProvideInfo> provides() {\n+            if (provides == null) {\n+                structure();\n+            }\n+            return provides;\n+        }\n+\n+        private void structure() {\n+            int p = payloadStart + 8;\n+\n+            {\n+                int cnt = classReader.readU2(payloadStart + 6);\n+                ModuleRequireInfo[] elements = new ModuleRequireInfo[cnt];\n+                int end = p + (cnt * 6);\n+                for (int i = 0; p < end; p += 6, i++) {\n+                    elements[i] = ModuleRequireInfo.of(classReader.readModuleEntry(p),\n+                            classReader.readU2(p + 2),\n+                            (Utf8Entry) classReader.readEntryOrNull(p + 4));\n+                }\n+                requires = List.of(elements);\n+            }\n+\n+            {\n+                int cnt = classReader.readU2(p);\n+                p += 2;\n+                ModuleExportInfo[] elements = new ModuleExportInfo[cnt];\n+                for (int i = 0; i < cnt; i++) {\n+                    PackageEntry pe = classReader.readPackageEntry(p);\n+                    int exportFlags = classReader.readU2(p + 2);\n+                    p += 4;\n+                    List<ModuleEntry> exportsTo = readEntryList(p);\n+                    p += 2 + exportsTo.size() * 2;\n+                    elements[i] = ModuleExportInfo.of(pe, exportFlags, exportsTo);\n+                }\n+                exports = List.of(elements);\n+            }\n+\n+            {\n+                int cnt = classReader.readU2(p);\n+                p += 2;\n+                ModuleOpenInfo[] elements = new ModuleOpenInfo[cnt];\n+                for (int i = 0; i < cnt; i++) {\n+                    PackageEntry po = classReader.readPackageEntry(p);\n+                    int opensFlags = classReader.readU2(p + 2);\n+                    p += 4;\n+                    List<ModuleEntry> opensTo = readEntryList(p);\n+                    p += 2 + opensTo.size() * 2;\n+                    elements[i] = ModuleOpenInfo.of(po, opensFlags, opensTo);\n+                }\n+                opens = List.of(elements);\n+            }\n+\n+            {\n+                uses = readEntryList(p);\n+                p += 2 + uses.size() * 2;\n+                int cnt = classReader.readU2(p);\n+                p += 2;\n+                ModuleProvideInfo[] elements = new ModuleProvideInfo[cnt];\n+                provides = new ArrayList<>(cnt);\n+                for (int i = 0; i < cnt; i++) {\n+                    ClassEntry c = classReader.readClassEntry(p);\n+                    p += 2;\n+                    List<ClassEntry> providesWith = readEntryList(p);\n+                    p += 2 + providesWith.size() * 2;\n+                    elements[i] = ModuleProvideInfo.of(c, providesWith);\n+                }\n+                provides = List.of(elements);\n+            }\n+        }\n+    }\n+\n+    public static final class BoundModulePackagesAttribute extends BoundAttribute<ModulePackagesAttribute>\n+            implements ModulePackagesAttribute {\n+        private List<PackageEntry> packages = null;\n+\n+        public BoundModulePackagesAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<ModulePackagesAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<PackageEntry> packages() {\n+            if (packages == null) {\n+                packages = readEntryList(payloadStart);\n+            }\n+            return packages;\n+        }\n+    }\n+\n+    public static final class BoundNestMembersAttribute extends BoundAttribute<NestMembersAttribute>\n+            implements NestMembersAttribute {\n+\n+        private List<ClassEntry> members = null;\n+\n+        public BoundNestMembersAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<NestMembersAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> nestMembers() {\n+            if (members == null) {\n+                members = readEntryList(payloadStart);\n+            }\n+            return members;\n+        }\n+    }\n+\n+    public static final class BoundBootstrapMethodsAttribute extends BoundAttribute<BootstrapMethodsAttribute>\n+            implements BootstrapMethodsAttribute {\n+\n+        private List<BootstrapMethodEntry> bootstraps = null;\n+        private final int size;\n+\n+        public BoundBootstrapMethodsAttribute(AttributedElement enclosing, ClassReader reader, AttributeMapper<BootstrapMethodsAttribute> mapper, int pos) {\n+            super(reader, mapper, pos);\n+            size = classReader.readU2(pos);\n+        }\n+\n+        @Override\n+        public int bootstrapMethodsSize() {\n+            return size;\n+        }\n+\n+        @Override\n+        public List<BootstrapMethodEntry> bootstrapMethods() {\n+            if (bootstraps == null) {\n+                BootstrapMethodEntry[] bs = new BootstrapMethodEntry[size];\n+                int p = payloadStart + 2;\n+                for (int i = 0; i < size; ++i) {\n+                    final ConcreteEntry.ConcreteMethodHandleEntry handle\n+                            = (ConcreteEntry.ConcreteMethodHandleEntry) classReader.readMethodHandleEntry(p);\n+                    final List<LoadableConstantEntry> args = readEntryList(p + 2);\n+                    p += 4 + args.size() * 2;\n+                    int hash = ConcreteBootstrapMethodEntry.computeHashCode(handle, args);\n+                    bs[i] = new ConcreteBootstrapMethodEntry(classReader, i, hash, handle, args);\n+                }\n+                bootstraps = List.of(bs);\n+            }\n+            return bootstraps;\n+        }\n+    }\n+\n+    public static final class BoundInnerClassesAttribute extends BoundAttribute<InnerClassesAttribute>\n+            implements InnerClassesAttribute {\n+        private List<InnerClassInfo> classes;\n+\n+        public BoundInnerClassesAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<InnerClassesAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<InnerClassInfo> classes() {\n+            if (classes == null) {\n+                final int cnt = classReader.readU2(payloadStart);\n+                int p = payloadStart + 2;\n+                InnerClassInfo[] elements = new InnerClassInfo[cnt];\n+                for (int i = 0; i < cnt; i++) {\n+                    ClassEntry innerClass = classReader.readClassEntry(p); \/\/ TODO FIXME\n+                    int outerClassIndex = classReader.readU2(p + 2);\n+                    ClassEntry outerClass = outerClassIndex == 0\n+                            ? null\n+                            : (ClassEntry) classReader.entryByIndex(outerClassIndex);\n+                    int innerNameIndex = classReader.readU2(p + 4);\n+                    Utf8Entry innerName = innerNameIndex == 0\n+                            ? null\n+                            : (Utf8Entry) classReader.entryByIndex(innerNameIndex);\n+                    int flags = classReader.readU2(p + 6);\n+                    p += 8;\n+                    elements[i] = InnerClassInfo.of(innerClass, Optional.ofNullable(outerClass), Optional.ofNullable(innerName), flags);\n+                }\n+                classes = List.of(elements);\n+            }\n+            return classes;\n+        }\n+    }\n+\n+    public static final class BoundEnclosingMethodAttribute extends BoundAttribute<EnclosingMethodAttribute>\n+            implements EnclosingMethodAttribute {\n+        public BoundEnclosingMethodAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<EnclosingMethodAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public ClassEntry enclosingClass() {\n+            return classReader.readClassEntry(payloadStart);\n+        }\n+\n+        @Override\n+        public Optional<NameAndTypeEntry> enclosingMethod() {\n+            return Optional.ofNullable((NameAndTypeEntry) classReader.readEntryOrNull(payloadStart + 2));\n+        }\n+    }\n+\n+    public static final class BoundAnnotationDefaultAttr\n+            extends BoundAttribute<AnnotationDefaultAttribute>\n+            implements AnnotationDefaultAttribute {\n+        private AnnotationValue annotationValue;\n+\n+        public BoundAnnotationDefaultAttr(AttributedElement enclosing, ClassReader cf, AttributeMapper<AnnotationDefaultAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public AnnotationValue defaultValue() {\n+            if (annotationValue == null)\n+                annotationValue = AnnotationReader.readElementValue(classReader, payloadStart);\n+            return annotationValue;\n+        }\n+    }\n+\n+    public static final class BoundRuntimeVisibleTypeAnnotationsAttribute extends BoundAttribute<RuntimeVisibleTypeAnnotationsAttribute>\n+            implements RuntimeVisibleTypeAnnotationsAttribute {\n+\n+        private final LabelContext labelContext;\n+\n+        public BoundRuntimeVisibleTypeAnnotationsAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<RuntimeVisibleTypeAnnotationsAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            this.labelContext = (enclosing instanceof LabelContext lc) ? lc : null;\n+        }\n+\n+        @Override\n+        public List<TypeAnnotation> annotations() {\n+            return AnnotationReader.readTypeAnnotations(classReader, payloadStart, labelContext);\n+        }\n+    }\n+\n+    public static final class BoundRuntimeInvisibleTypeAnnotationsAttribute\n+            extends BoundAttribute<RuntimeInvisibleTypeAnnotationsAttribute>\n+            implements RuntimeInvisibleTypeAnnotationsAttribute {\n+        public BoundRuntimeInvisibleTypeAnnotationsAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<RuntimeInvisibleTypeAnnotationsAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            this.labelContext = (enclosing instanceof LabelContext lc) ? lc : null;\n+        }\n+\n+        private final LabelContext labelContext;\n+\n+        @Override\n+        public List<TypeAnnotation> annotations() {\n+            return AnnotationReader.readTypeAnnotations(classReader, payloadStart, labelContext);\n+        }\n+    }\n+\n+    public static final class BoundRuntimeVisibleParameterAnnotationsAttribute\n+            extends BoundAttribute<RuntimeVisibleParameterAnnotationsAttribute>\n+            implements RuntimeVisibleParameterAnnotationsAttribute {\n+        private final AttributedElement enclosing;\n+\n+        public BoundRuntimeVisibleParameterAnnotationsAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<RuntimeVisibleParameterAnnotationsAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            this.enclosing = enclosing;\n+        }\n+\n+        @Override\n+        public List<List<Annotation>> parameterAnnotations() {\n+            return AnnotationReader.readParameterAnnotations(classReader, payloadStart, true);\n+        }\n+    }\n+\n+    public static final class BoundRuntimeInvisibleParameterAnnotationsAttribute\n+            extends BoundAttribute<RuntimeInvisibleParameterAnnotationsAttribute>\n+            implements RuntimeInvisibleParameterAnnotationsAttribute {\n+        private final AttributedElement enclosing;\n+\n+        public BoundRuntimeInvisibleParameterAnnotationsAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<RuntimeInvisibleParameterAnnotationsAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+            this.enclosing = enclosing;\n+        }\n+\n+        @Override\n+        public List<List<Annotation>> parameterAnnotations() {\n+            return AnnotationReader.readParameterAnnotations(classReader, payloadStart, false);\n+        }\n+    }\n+\n+    public static final class BoundRuntimeInvisibleAnnotationsAttribute\n+            extends BoundAttribute<RuntimeInvisibleAnnotationsAttribute>\n+            implements RuntimeInvisibleAnnotationsAttribute {\n+        private List<Annotation> inflated;\n+\n+        public BoundRuntimeInvisibleAnnotationsAttribute(ClassReader cf,\n+                                                         int payloadStart) {\n+            super(cf, Attributes.RUNTIME_INVISIBLE_ANNOTATIONS, payloadStart);\n+        }\n+\n+        @Override\n+        public List<Annotation> annotations() {\n+            if (inflated == null)\n+                inflated = AnnotationReader.readAnnotations(classReader, payloadStart);\n+            return inflated;\n+        }\n+    }\n+\n+    public static final class BoundRuntimeVisibleAnnotationsAttribute\n+            extends BoundAttribute<RuntimeVisibleAnnotationsAttribute>\n+            implements RuntimeVisibleAnnotationsAttribute {\n+        private List<Annotation> inflated;\n+\n+        public BoundRuntimeVisibleAnnotationsAttribute(ClassReader cf,\n+                                                       int payloadStart) {\n+            super(cf, Attributes.RUNTIME_VISIBLE_ANNOTATIONS, payloadStart);\n+        }\n+\n+        @Override\n+        public List<Annotation> annotations() {\n+            if (inflated == null)\n+                inflated = AnnotationReader.readAnnotations(classReader, payloadStart);\n+            return inflated;\n+        }\n+    }\n+\n+    public static final class BoundPermittedSubclassesAttribute extends BoundAttribute<PermittedSubclassesAttribute>\n+            implements PermittedSubclassesAttribute {\n+        private List<ClassEntry> permittedSubclasses = null;\n+\n+        public BoundPermittedSubclassesAttribute(AttributedElement enclosing, ClassReader cf, AttributeMapper<PermittedSubclassesAttribute> mapper, int pos) {\n+            super(cf, mapper, pos);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> permittedSubclasses() {\n+            if (permittedSubclasses == null) {\n+                permittedSubclasses = readEntryList(payloadStart);\n+            }\n+            return permittedSubclasses;\n+        }\n+    }\n+\n+    public static abstract sealed class BoundCodeAttribute\n+            extends BoundAttribute<CodeAttribute>\n+            implements CodeAttribute\n+            permits CodeImpl {\n+        protected final int codeStart;\n+        protected final int codeLength;\n+        protected final int codeEnd;\n+        protected final int attributePos;\n+        protected final int exceptionHandlerPos;\n+        protected final int exceptionHandlerCnt;\n+        protected final MethodModel enclosingMethod;\n+\n+        public BoundCodeAttribute(AttributedElement enclosing,\n+                                  ClassReader reader,\n+                                  AttributeMapper<CodeAttribute> mapper,\n+                                  int payloadStart) {\n+            super(reader, mapper, payloadStart);\n+            this.codeLength = classReader.readInt(payloadStart + 4);\n+            this.enclosingMethod = (MethodModel) enclosing;\n+            this.codeStart = payloadStart + 8;\n+            this.codeEnd = codeStart + codeLength;\n+            this.exceptionHandlerPos = codeEnd;\n+            this.exceptionHandlerCnt = classReader.readU2(exceptionHandlerPos);\n+            this.attributePos = exceptionHandlerPos + 2 + exceptionHandlerCnt * 8;\n+        }\n+\n+        \/\/ CodeAttribute\n+\n+        @Override\n+        public int maxStack() {\n+            return classReader.readU2(payloadStart);\n+        }\n+\n+        @Override\n+        public int maxLocals() {\n+            return classReader.readU2(payloadStart + 2);\n+        }\n+\n+        @Override\n+        public int codeLength() {\n+            return codeLength;\n+        }\n+\n+        @Override\n+        public byte[] codeArray() {\n+            return classReader.readBytes(payloadStart + 8, codeLength());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1010,"deletions":0,"binary":false,"changes":1010,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.instruction.CharacterRange;\n+\n+public final class BoundCharacterRange\n+        extends AbstractElement\n+        implements CharacterRange {\n+\n+    private final CodeImpl code;\n+    private final int offset;\n+\n+    public BoundCharacterRange(CodeImpl code, int offset) {\n+        this.code = code;\n+        this.offset = offset;\n+    }\n+\n+    int startPc() {\n+        return code.classReader.readU2(offset);\n+    }\n+\n+    int endPc() {\n+        return code.classReader.readU2(offset + 2);\n+    }\n+\n+    @Override\n+    public int characterRangeStart() {\n+        return code.classReader.readInt(offset + 4);\n+    }\n+\n+    @Override\n+    public int characterRangeEnd() {\n+        return code.classReader.readInt(offset + 8);\n+    }\n+\n+    @Override\n+    public int flags() {\n+        return code.classReader.readU2(offset + 12);\n+    }\n+\n+    @Override\n+    public Label startScope() {\n+        return code.getLabel(startPc());\n+    }\n+\n+    @Override\n+    public Label endScope() {\n+        return code.getLabel(endPc() + 1);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder builder) {\n+        builder.addCharacterRange(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CharacterRange[startScope=%s, endScope=%s, characterRangeStart=%s, characterRangeEnd=%s, flags=%d]\",\n+                startScope(), endScope(), characterRangeStart(), characterRangeEnd(), flags());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundCharacterRange.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.attribute.LocalVariableInfo;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+\n+\/**\n+ * LocalVariableImpl\n+ *\/\n+public final class BoundLocalVariable\n+        extends AbstractBoundLocalVariable\n+        implements LocalVariableInfo,\n+                   LocalVariable {\n+\n+    public BoundLocalVariable(CodeImpl code, int offset) {\n+        super(code, offset);\n+    }\n+\n+    @Override\n+    public Utf8Entry type() {\n+        return secondaryEntry();\n+    }\n+\n+    @Override\n+    public ClassDesc typeSymbol() {\n+        return ClassDesc.ofDescriptor(type().stringValue());\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder writer) {\n+        writer.addLocalVariable(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"LocalVariable[name=%s, slot=%d, type=%s]\", name().stringValue(), slot(), type().stringValue());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundLocalVariable.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+\n+\/**\n+ * LocalVariableTypeImpl\n+ *\/\n+public final class BoundLocalVariableType\n+        extends AbstractBoundLocalVariable\n+        implements LocalVariableTypeInfo,\n+                   LocalVariableType {\n+\n+    public BoundLocalVariableType(CodeImpl code, int offset) {\n+        super(code, offset);\n+    }\n+\n+    @Override\n+    public Utf8Entry signature() {\n+        return secondaryEntry();\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder writer) {\n+        writer.addLocalVariableType(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"LocalVariableType[name=%s, slot=%d, signature=%s]\", name().stringValue(), slot(), signature().stringValue());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundLocalVariableType.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+public final class BoundRecordComponentInfo\n+        implements RecordComponentInfo {\n+\n+    private final ClassReader reader;\n+    private final int startPos, endPos, attributesPos;\n+    private List<Attribute<?>> attributes;\n+\n+    public BoundRecordComponentInfo(ClassReader reader, int startPos, int endPos) {\n+        this.reader = reader;\n+        this.startPos = startPos;\n+        this.endPos = endPos;\n+        attributesPos = startPos + 4;\n+    }\n+\n+    @Override\n+    public Utf8Entry name() {\n+        return reader.readUtf8Entry(startPos);\n+    }\n+\n+    @Override\n+    public Utf8Entry descriptor() {\n+        return reader.readUtf8Entry(startPos + 2);\n+    }\n+\n+    @Override\n+    public List<Attribute<?>> attributes() {\n+        if (attributes == null) {\n+            attributes = BoundAttribute.readAttributes(null, reader, attributesPos, reader.customAttributes());\n+        }\n+        return attributes;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundRecordComponentInfo.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.WritableElement;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+public final class BufWriterImpl implements BufWriter {\n+\n+    private final ConstantPoolBuilder constantPool;\n+    private LabelContext labelContext;\n+    private ClassEntry thisClass;\n+    byte[] elems;\n+    int offset = 0;\n+\n+    public BufWriterImpl(ConstantPoolBuilder constantPool) {\n+        this(constantPool, 64);\n+    }\n+\n+    public BufWriterImpl(ConstantPoolBuilder constantPool, int initialSize) {\n+        this.constantPool = constantPool;\n+        elems = new byte[initialSize];\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return constantPool;\n+    }\n+\n+    public LabelContext labelContext() {\n+        return labelContext;\n+    }\n+\n+    public void setLabelContext(LabelContext labelContext) {\n+        this.labelContext = labelContext;\n+    }\n+    @Override\n+    public boolean canWriteDirect(ConstantPool other) {\n+        return constantPool.canWriteDirect(other);\n+    }\n+\n+    public ClassEntry thisClass() {\n+        return thisClass;\n+    }\n+\n+    public void setThisClass(ClassEntry thisClass) {\n+        this.thisClass = thisClass;\n+    }\n+\n+    @Override\n+    public void writeU1(int x) {\n+        writeIntBytes(1, x);\n+    }\n+\n+    @Override\n+    public void writeU2(int x) {\n+        writeIntBytes(2, x);\n+    }\n+\n+    @Override\n+    public void writeInt(int x) {\n+        writeIntBytes(4, x);\n+    }\n+\n+    @Override\n+    public void writeFloat(float x) {\n+        writeInt(Float.floatToIntBits(x));\n+    }\n+\n+    @Override\n+    public void writeLong(long x) {\n+        writeIntBytes(8, x);\n+    }\n+\n+    @Override\n+    public void writeDouble(double x) {\n+        writeLong(Double.doubleToLongBits(x));\n+    }\n+\n+    @Override\n+    public void writeBytes(byte[] arr) {\n+        writeBytes(arr, 0, arr.length);\n+    }\n+\n+    @Override\n+    public void writeBytes(BufWriter other) {\n+        BufWriterImpl o = (BufWriterImpl) other;\n+        writeBytes(o.elems, 0, o.offset);\n+    }\n+\n+    @Override\n+    public void writeBytes(byte[] arr, int start, int length) {\n+        reserveSpace(length);\n+        System.arraycopy(arr, start, elems, offset, length);\n+        offset += length;\n+    }\n+\n+    @Override\n+    public void patchInt(int offset, int size, int value) {\n+        int prevOffset = this.offset;\n+        this.offset = offset;\n+        writeIntBytes(size, value);\n+        this.offset = prevOffset;\n+    }\n+\n+    @Override\n+    public void writeIntBytes(int intSize, long intValue) {\n+        reserveSpace(intSize);\n+        for (int i = 0; i < intSize; i++) {\n+            elems[offset++] = (byte) ((intValue >> 8 * (intSize - i - 1)) & 0xFF);\n+        }\n+    }\n+\n+    @Override\n+    public void reserveSpace(int freeBytes) {\n+        if (offset + freeBytes > elems.length) {\n+            int newsize = elems.length * 2;\n+            while (offset + freeBytes > newsize) {\n+                newsize *= 2;\n+            }\n+            elems = Arrays.copyOf(elems, newsize);\n+        }\n+    }\n+\n+    @Override\n+    public int size() {\n+        return offset;\n+    }\n+\n+    @Override\n+    public ByteBuffer asByteBuffer() {\n+        return ByteBuffer.wrap(elems, 0, offset);\n+    }\n+\n+    @Override\n+    public void copyTo(byte[] array, int bufferOffset) {\n+        System.arraycopy(elems, 0, array, bufferOffset, size());\n+    }\n+\n+    \/\/ writeIndex methods ensure that any CP info written\n+    \/\/ is relative to the correct constant pool\n+\n+    @Override\n+    public void writeIndex(PoolEntry entry) {\n+        int idx = ConcreteEntry.maybeClone(constantPool, entry).index();\n+        if (idx < 1 || idx > Character.MAX_VALUE)\n+            throw new IllegalArgumentException(idx + \" is not a valid index. Entry: \" + entry);\n+        writeU2(idx);\n+    }\n+\n+    @Override\n+    public void writeIndexOrZero(PoolEntry entry) {\n+        if (entry == null || entry.index() == 0)\n+            writeU2(0);\n+        else\n+            writeIndex(entry);\n+    }\n+\n+    @Override\n+    public<T extends WritableElement<?>> void writeList(List<T> list) {\n+        writeU2(list.size());\n+        for (T t : list) {\n+            t.writeTo(this);\n+        }\n+    }\n+\n+    @Override\n+    public void writeListIndices(List<? extends PoolEntry> list) {\n+        writeU2(list.size());\n+        for (PoolEntry info : list) {\n+            writeIndex(info);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * BufferedCodeBuilder\n+ *\/\n+public final class BufferedCodeBuilder\n+        implements TerminalCodeBuilder, LabelContext {\n+    private final SplitConstantPool constantPool;\n+    private final List<CodeElement> elements = new ArrayList<>();\n+    private final LabelImpl startLabel, endLabel;\n+    private final CodeModel original;\n+    private final MethodInfo methodInfo;\n+    private boolean finished;\n+    private int maxLocals;\n+\n+    public BufferedCodeBuilder(MethodInfo methodInfo,\n+                               SplitConstantPool constantPool,\n+                               CodeModel original) {\n+        this.constantPool = constantPool;\n+        this.startLabel = new LabelImpl(this, -1);\n+        this.endLabel = new LabelImpl(this, -1);\n+        this.original = original;\n+        this.methodInfo = methodInfo;\n+        this.maxLocals = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodType().stringValue());\n+        if (original != null)\n+            this.maxLocals = Math.max(this.maxLocals, original.maxLocals());\n+\n+        elements.add(startLabel);\n+    }\n+\n+    @Override\n+    public Optional<CodeModel> original() {\n+        return Optional.ofNullable(original);\n+    }\n+\n+    @Override\n+    public Label newLabel() {\n+        return new LabelImpl(this, -1);\n+    }\n+\n+    @Override\n+    public Label startLabel() {\n+        return startLabel;\n+    }\n+\n+    @Override\n+    public Label endLabel() {\n+        return endLabel;\n+    }\n+\n+    @Override\n+    public int receiverSlot() {\n+        return methodInfo.receiverSlot();\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        return methodInfo.parameterSlot(paramNo);\n+    }\n+\n+    public int curTopLocal() {\n+        return maxLocals;\n+    }\n+\n+    @Override\n+    public int allocateLocal(TypeKind typeKind) {\n+        int retVal = maxLocals;\n+        maxLocals += typeKind.slotSize();\n+        return retVal;\n+    }\n+\n+    @Override\n+    public Label getLabel(int bci) {\n+        throw new UnsupportedOperationException(\"Lookup by BCI not supported by BufferedCodeBuilder\");\n+    }\n+\n+    @Override\n+    public int labelToBci(Label label) {\n+        throw new UnsupportedOperationException(\"Label mapping not supported by BufferedCodeBuilder\");\n+    }\n+\n+    @Override\n+    public void setLabelTarget(Label label, int bci) {\n+        throw new UnsupportedOperationException(\"Label mapping not supported by BufferedCodeBuilder\");\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return constantPool;\n+    }\n+\n+    @Override\n+    public CodeBuilder with(CodeElement element) {\n+        if (finished)\n+            throw new IllegalStateException(\"Can't add elements after traversal\");\n+        elements.add(element);\n+        return this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CodeModel[id=%d]\", System.identityHashCode(this));\n+    }\n+\n+    public BufferedCodeBuilder run(Consumer<? super CodeBuilder> handler) {\n+        handler.accept(this);\n+        return this;\n+    }\n+\n+    public CodeModel toModel() {\n+        if (!finished) {\n+            elements.add(endLabel);\n+            finished = true;\n+        }\n+        return new Model();\n+    }\n+\n+    public final class Model\n+            extends AbstractUnboundModel<CodeElement>\n+            implements CodeModel {\n+\n+        private Model() {\n+            super(elements);\n+        }\n+\n+        @Override\n+        public List<ExceptionCatch> exceptionHandlers() {\n+            return elements.stream()\n+                           .filter(x -> x instanceof ExceptionCatch)\n+                           .map(x -> (ExceptionCatch) x)\n+                           .toList();\n+        }\n+\n+        @Override\n+        public int maxLocals() {\n+            for (CodeElement element : elements) {\n+                if (element instanceof LoadInstruction i)\n+                    maxLocals = Math.max(maxLocals, i.slot() + i.typeKind().slotSize());\n+                else if (element instanceof StoreInstruction i)\n+                    maxLocals = Math.max(maxLocals, i.slot() + i.typeKind().slotSize());\n+                else if (element instanceof IncrementInstruction i)\n+                    maxLocals = Math.max(maxLocals, i.slot() + 1);\n+            }\n+            return maxLocals;\n+        }\n+\n+        @Override\n+        public int maxStack() {\n+            throw new UnsupportedOperationException(\"nyi\");\n+        }\n+\n+        @Override\n+        public Optional<MethodModel> parent() {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public void writeTo(DirectMethodBuilder builder) {\n+            builder.withCode(new Consumer<>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    forEachElement(cb);\n+                }\n+            });\n+        }\n+\n+        public void writeTo(BufWriter buf) {\n+            DirectCodeBuilder.build(methodInfo, cb -> elements.forEach(cb), constantPool, null).writeTo(buf);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"CodeModel[id=%s]\", Integer.toHexString(System.identityHashCode(this)));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+\/**\n+ * BufferedFieldBuilder\n+ *\/\n+public final class BufferedFieldBuilder\n+        implements TerminalFieldBuilder {\n+    private final SplitConstantPool constantPool;\n+    private final Utf8Entry name;\n+    private final Utf8Entry desc;\n+    private final List<FieldElement> elements = new ArrayList<>();\n+    private AccessFlags flags;\n+    private final FieldModel original;\n+\n+    public BufferedFieldBuilder(SplitConstantPool constantPool,\n+                                Utf8Entry name,\n+                                Utf8Entry type,\n+                                FieldModel original) {\n+        this.constantPool = constantPool;\n+        this.name = name;\n+        this.desc = type;\n+        this.flags = AccessFlags.ofField();\n+        this.original = original;\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return constantPool;\n+    }\n+\n+    @Override\n+    public Optional<FieldModel> original() {\n+        return Optional.ofNullable(original);\n+    }\n+\n+    @Override\n+    public FieldBuilder with(FieldElement element) {\n+        elements.add(element);\n+        if (element instanceof AccessFlags f) this.flags = f;\n+        return this;\n+    }\n+\n+    public BufferedFieldBuilder run(Consumer<? super FieldBuilder> handler) {\n+        handler.accept(this);\n+        return this;\n+    }\n+\n+    public FieldModel toModel() {\n+        return new Model();\n+    }\n+\n+    public final class Model\n+            extends AbstractUnboundModel<FieldElement>\n+            implements FieldModel {\n+        public Model() {\n+            super(elements);\n+        }\n+\n+        @Override\n+        public Optional<ClassModel> parent() {\n+            FieldModel fm = original().orElse(null);\n+            return fm == null? Optional.empty() : fm.parent();\n+        }\n+\n+        @Override\n+        public AccessFlags flags() {\n+            return flags;\n+        }\n+\n+        @Override\n+        public Utf8Entry fieldName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public Utf8Entry fieldType() {\n+            return desc;\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            DirectFieldBuilder fb = new DirectFieldBuilder(constantPool, name, desc, null);\n+            elements.forEach(fb);\n+            fb.writeTo(buf);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"FieldModel[fieldName=%s, fieldType=%s, flags=%d]\", name.stringValue(), desc.stringValue(), flags.flagsMask());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.AccessFlags;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+\n+\/**\n+ * BufferedMethodBuilder\n+ *\/\n+public final class BufferedMethodBuilder\n+        implements TerminalMethodBuilder, MethodInfo {\n+    private final List<MethodElement> elements = new ArrayList<>();\n+    private final SplitConstantPool constantPool;\n+    private final ClassEntry thisClass;\n+    private final Utf8Entry name;\n+    private final Utf8Entry desc;\n+    private AccessFlags flags;\n+    private final MethodModel original;\n+    private int[] parameterSlots;\n+\n+    public BufferedMethodBuilder(SplitConstantPool constantPool,\n+                                 ClassEntry thisClass,\n+                                 Utf8Entry nameInfo,\n+                                 Utf8Entry typeInfo,\n+                                 MethodModel original) {\n+        this.constantPool = constantPool;\n+        this.thisClass = thisClass;\n+        this.name = nameInfo;\n+        this.desc = typeInfo;\n+        this.flags = AccessFlags.ofMethod();\n+        this.original = original;\n+    }\n+\n+    @Override\n+    public MethodBuilder with(MethodElement element) {\n+        elements.add(element);\n+        if (element instanceof AccessFlags f) this.flags = f;\n+        return this;\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return constantPool;\n+    }\n+\n+    @Override\n+    public Optional<MethodModel> original() {\n+        return Optional.ofNullable(original);\n+    }\n+\n+    @Override\n+    public Utf8Entry methodName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Utf8Entry methodType() {\n+        return desc;\n+    }\n+\n+    @Override\n+    public int methodFlags() {\n+        return flags.flagsMask();\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        if (parameterSlots == null)\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+        return parameterSlots[paramNo];\n+    }\n+\n+    @Override\n+    public MethodBuilder withCode(Consumer<? super CodeBuilder> handler) {\n+        return with(new BufferedCodeBuilder(this, constantPool, null)\n+                            .run(handler)\n+                            .toModel());\n+    }\n+\n+    @Override\n+    public MethodBuilder transformCode(CodeModel code, CodeTransform transform) {\n+        BufferedCodeBuilder builder = new BufferedCodeBuilder(this, constantPool, code);\n+        builder.transform(code, transform);\n+        return with(builder.toModel());\n+    }\n+\n+    @Override\n+    public BufferedCodeBuilder bufferedCodeBuilder(CodeModel original) {\n+        return new BufferedCodeBuilder(this, constantPool, original);\n+    }\n+\n+    public BufferedMethodBuilder run(Consumer<? super MethodBuilder> handler) {\n+        handler.accept(this);\n+        return this;\n+    }\n+\n+    public MethodModel toModel() {\n+        return new Model();\n+    }\n+\n+    public final class Model\n+            extends AbstractUnboundModel<MethodElement>\n+            implements MethodModel, MethodInfo {\n+        public Model() {\n+            super(elements);\n+        }\n+\n+        @Override\n+        public AccessFlags flags() {\n+            return flags;\n+        }\n+\n+        @Override\n+        public Optional<ClassModel> parent() {\n+            return original().flatMap(MethodModel::parent);\n+        }\n+\n+        @Override\n+        public Utf8Entry methodName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public Utf8Entry methodType() {\n+            return desc;\n+        }\n+\n+        @Override\n+        public int methodFlags() {\n+            return flags.flagsMask();\n+        }\n+\n+        @Override\n+        public int parameterSlot(int paramNo) {\n+            return BufferedMethodBuilder.this.parameterSlot(paramNo);\n+        }\n+\n+        @Override\n+        public Optional<CodeModel> code() {\n+            throw new UnsupportedOperationException(\"nyi\");\n+        }\n+\n+        @Override\n+        public void writeTo(DirectClassBuilder builder) {\n+            builder.withMethod(methodName(), methodType(), methodFlags(), new Consumer<>() {\n+                @Override\n+                public void accept(MethodBuilder mb) {\n+                    forEachElement(mb);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            DirectMethodBuilder mb = new DirectMethodBuilder(constantPool, name, desc, methodFlags(), null);\n+            elements.forEach(mb);\n+            mb.writeTo(buf);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"MethodModel[methodName=%s, methodType=%s, flags=%d]\",\n+                    name.stringValue(), desc.stringValue(), flags.flagsMask());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandleInfo;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+\n+\/**\n+ * BytecodeHelpers\n+ *\/\n+public class BytecodeHelpers {\n+\/\/    public static Map<ConstantDesc, Opcode> constantsToOpcodes = new HashMap<>(16);\n+\n+    public BytecodeHelpers() {\n+    }\n+\n+    public static Opcode loadOpcode(TypeKind tk, int slot) {\n+        return switch (tk) {\n+            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n+                case 0 -> Opcode.ILOAD_0;\n+                case 1 -> Opcode.ILOAD_1;\n+                case 2 -> Opcode.ILOAD_2;\n+                case 3 -> Opcode.ILOAD_3;\n+                default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n+            };\n+            case LongType -> switch (slot) {\n+                case 0 -> Opcode.LLOAD_0;\n+                case 1 -> Opcode.LLOAD_1;\n+                case 2 -> Opcode.LLOAD_2;\n+                case 3 -> Opcode.LLOAD_3;\n+                default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n+            };\n+            case DoubleType -> switch (slot) {\n+                case 0 -> Opcode.DLOAD_0;\n+                case 1 -> Opcode.DLOAD_1;\n+                case 2 -> Opcode.DLOAD_2;\n+                case 3 -> Opcode.DLOAD_3;\n+                default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n+            };\n+            case FloatType -> switch (slot) {\n+                case 0 -> Opcode.FLOAD_0;\n+                case 1 -> Opcode.FLOAD_1;\n+                case 2 -> Opcode.FLOAD_2;\n+                case 3 -> Opcode.FLOAD_3;\n+                default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n+            };\n+            case ReferenceType -> switch (slot) {\n+                case 0 -> Opcode.ALOAD_0;\n+                case 1 -> Opcode.ALOAD_1;\n+                case 2 -> Opcode.ALOAD_2;\n+                case 3 -> Opcode.ALOAD_3;\n+                default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n+            };\n+            case VoidType -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode storeOpcode(TypeKind tk, int slot) {\n+        return switch (tk) {\n+            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n+                case 0 -> Opcode.ISTORE_0;\n+                case 1 -> Opcode.ISTORE_1;\n+                case 2 -> Opcode.ISTORE_2;\n+                case 3 -> Opcode.ISTORE_3;\n+                default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n+            };\n+            case LongType -> switch (slot) {\n+                case 0 -> Opcode.LSTORE_0;\n+                case 1 -> Opcode.LSTORE_1;\n+                case 2 -> Opcode.LSTORE_2;\n+                case 3 -> Opcode.LSTORE_3;\n+                default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n+            };\n+            case DoubleType -> switch (slot) {\n+                case 0 -> Opcode.DSTORE_0;\n+                case 1 -> Opcode.DSTORE_1;\n+                case 2 -> Opcode.DSTORE_2;\n+                case 3 -> Opcode.DSTORE_3;\n+                default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n+            };\n+            case FloatType -> switch (slot) {\n+                case 0 -> Opcode.FSTORE_0;\n+                case 1 -> Opcode.FSTORE_1;\n+                case 2 -> Opcode.FSTORE_2;\n+                case 3 -> Opcode.FSTORE_3;\n+                default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n+            };\n+            case ReferenceType -> switch (slot) {\n+                case 0 -> Opcode.ASTORE_0;\n+                case 1 -> Opcode.ASTORE_1;\n+                case 2 -> Opcode.ASTORE_2;\n+                case 3 -> Opcode.ASTORE_3;\n+                default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n+            };\n+            case VoidType -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode returnOpcode(TypeKind tk) {\n+        return switch (tk) {\n+            case ByteType, ShortType, IntType, CharType, BooleanType -> Opcode.IRETURN;\n+            case FloatType -> Opcode.FRETURN;\n+            case LongType -> Opcode.LRETURN;\n+            case DoubleType -> Opcode.DRETURN;\n+            case ReferenceType -> Opcode.ARETURN;\n+            case VoidType -> Opcode.RETURN;\n+        };\n+    }\n+\n+    public static Opcode arrayLoadOpcode(TypeKind tk) {\n+        return switch (tk) {\n+            case ByteType, BooleanType -> Opcode.BALOAD;\n+            case ShortType -> Opcode.SALOAD;\n+            case IntType -> Opcode.IALOAD;\n+            case FloatType -> Opcode.FALOAD;\n+            case LongType -> Opcode.LALOAD;\n+            case DoubleType -> Opcode.DALOAD;\n+            case ReferenceType -> Opcode.AALOAD;\n+            case CharType -> Opcode.CALOAD;\n+            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+        };\n+    }\n+\n+    public static Opcode arrayStoreOpcode(TypeKind tk) {\n+        return switch (tk) {\n+            case ByteType, BooleanType -> Opcode.BASTORE;\n+            case ShortType -> Opcode.SASTORE;\n+            case IntType -> Opcode.IASTORE;\n+            case FloatType -> Opcode.FASTORE;\n+            case LongType -> Opcode.LASTORE;\n+            case DoubleType -> Opcode.DASTORE;\n+            case ReferenceType -> Opcode.AASTORE;\n+            case CharType -> Opcode.CASTORE;\n+            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+        };\n+    }\n+\n+    public static Opcode reverseBranchOpcode(Opcode op) {\n+        return switch (op) {\n+            case IFEQ -> Opcode.IFNE;\n+            case IFNE -> Opcode.IFEQ;\n+            case IFLT -> Opcode.IFGE;\n+            case IFGE -> Opcode.IFLT;\n+            case IFGT -> Opcode.IFLE;\n+            case IFLE -> Opcode.IFGT;\n+            case IF_ICMPEQ -> Opcode.IF_ICMPNE;\n+            case IF_ICMPNE -> Opcode.IF_ICMPEQ;\n+            case IF_ICMPLT -> Opcode.IF_ICMPGE;\n+            case IF_ICMPGE -> Opcode.IF_ICMPLT;\n+            case IF_ICMPGT -> Opcode.IF_ICMPLE;\n+            case IF_ICMPLE -> Opcode.IF_ICMPGT;\n+            case IF_ACMPEQ -> Opcode.IF_ACMPNE;\n+            case IF_ACMPNE -> Opcode.IF_ACMPEQ;\n+            case IFNULL -> Opcode.IFNONNULL;\n+            case IFNONNULL -> Opcode.IFNULL;\n+            default -> throw new IllegalArgumentException(\"Unknown branch instruction: \" + op);\n+        };\n+    }\n+\n+    public static Opcode convertOpcode(TypeKind from, TypeKind to) {\n+        return switch (from) {\n+            case IntType ->\n+                    switch (to) {\n+                        case LongType -> Opcode.I2L;\n+                        case FloatType -> Opcode.I2F;\n+                        case DoubleType -> Opcode.I2D;\n+                        case ByteType -> Opcode.I2B;\n+                        case CharType -> Opcode.I2C;\n+                        case ShortType -> Opcode.I2S;\n+                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                    };\n+            case LongType ->\n+                    switch (to) {\n+                        case FloatType -> Opcode.L2F;\n+                        case DoubleType -> Opcode.L2D;\n+                        case IntType -> Opcode.L2I;\n+                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                    };\n+            case DoubleType ->\n+                    switch (to) {\n+                        case FloatType -> Opcode.D2F;\n+                        case LongType -> Opcode.D2L;\n+                        case IntType -> Opcode.D2I;\n+                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                    };\n+            case FloatType ->\n+                    switch (to) {\n+                        case LongType -> Opcode.F2L;\n+                        case DoubleType -> Opcode.F2D;\n+                        case IntType -> Opcode.F2I;\n+                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                    };\n+            default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+        };\n+    }\n+\n+    static void validateSIPUSH(ConstantDesc d) {\n+        if (d instanceof Integer iVal && Short.MIN_VALUE <= iVal && iVal <= Short.MAX_VALUE)\n+            return;\n+\n+        if (d instanceof Long lVal && Short.MIN_VALUE <= lVal && Short.MAX_VALUE <= lVal)\n+            return;\n+\n+        throw new IllegalArgumentException(\"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE\"\n+                                           + \", found: \" + d);\n+    }\n+\n+    static void validateBIPUSH(ConstantDesc d) {\n+        if (d instanceof Integer iVal && Byte.MIN_VALUE <= iVal && iVal <= Byte.MAX_VALUE)\n+            return;\n+\n+        if (d instanceof Long lVal && Byte.MIN_VALUE <= lVal && Byte.MAX_VALUE <= lVal)\n+            return;\n+\n+        throw new IllegalArgumentException(\"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE\"\n+                                           + \", found: \" + d);\n+    }\n+\n+    public static MethodHandleEntry handleDescToHandleInfo(ConstantPoolBuilder constantPool, DirectMethodHandleDesc bootstrapMethod) {\n+        ClassEntry bsOwner = constantPool.classEntry(bootstrapMethod.owner());\n+        NameAndTypeEntry bsNameAndType = constantPool.natEntry(constantPool.utf8Entry(bootstrapMethod.methodName()),\n+                                                               constantPool.utf8Entry(bootstrapMethod.lookupDescriptor()));\n+        int bsRefKind = bootstrapMethod.refKind();\n+        MemberRefEntry bsReference = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapMethod.isOwnerInterface());\n+\n+        return constantPool.methodHandleEntry(bsRefKind, bsReference);\n+    }\n+\n+    static MemberRefEntry toBootstrapMemberRef(ConstantPoolBuilder constantPool, int bsRefKind, ClassEntry owner, NameAndTypeEntry nat, boolean isOwnerInterface) {\n+        return isOwnerInterface\n+               ? constantPool.interfaceMethodRefEntry(owner, nat)\n+               : bsRefKind <= MethodHandleInfo.REF_putStatic\n+                 ? constantPool.fieldRefEntry(owner, nat)\n+                 : constantPool.methodRefEntry(owner, nat);\n+    }\n+\n+    static ConstantDynamicEntry handleConstantDescToHandleInfo(ConstantPoolBuilder constantPool, DynamicConstantDesc<?> desc) {\n+        ConstantDesc[] bootstrapArgs = desc.bootstrapArgs();\n+        List<LoadableConstantEntry> staticArgs = new ArrayList<>(bootstrapArgs.length);\n+        for (ConstantDesc bootstrapArg : bootstrapArgs)\n+            staticArgs.add(constantPool.loadableConstantEntry(bootstrapArg));\n+\n+        var bootstrapDesc = desc.bootstrapMethod();\n+        ClassEntry bsOwner = constantPool.classEntry(bootstrapDesc.owner());\n+        NameAndTypeEntry bsNameAndType = constantPool.natEntry(bootstrapDesc.methodName(),\n+                                                               bootstrapDesc.invocationType());\n+        int bsRefKind = bootstrapDesc.refKind();\n+\n+        MemberRefEntry memberRefEntry = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapDesc.isOwnerInterface());\n+        MethodHandleEntry methodHandleEntry = constantPool.methodHandleEntry(bsRefKind, memberRefEntry);\n+        BootstrapMethodEntry bme = constantPool.bsmEntry(methodHandleEntry, staticArgs);\n+        return constantPool.constantDynamicEntry(bme,\n+                                                 constantPool.natEntry(desc.constantName(),\n+                                                                       desc.constantType()));\n+    }\n+\n+    public static void validateValue(Opcode opcode, ConstantDesc v) {\n+        switch (opcode) {\n+            case ACONST_NULL -> {\n+                if (v != null && v != ConstantDescs.NULL)\n+                    throw new IllegalArgumentException(\"value must be null or ConstantDescs.NULL with opcode ACONST_NULL\");\n+            }\n+            case SIPUSH ->\n+                    validateSIPUSH(v);\n+            case BIPUSH ->\n+                    validateBIPUSH(v);\n+            case LDC, LDC_W, LDC2_W -> {\n+                if (v == null)\n+                    throw new IllegalArgumentException(\"`null` must use ACONST_NULL\");\n+            }\n+            default -> {\n+                var exp = opcode.constantValue();\n+                if (exp == null)\n+                    throw new IllegalArgumentException(\"Can not use Opcode: \" + opcode + \" with constant()\");\n+                if (v == null || !(v.equals(exp) || (exp instanceof Long l && v.equals(l.intValue())))) {\n+                    var t = (exp instanceof Long) ? \"L\" : (exp instanceof Float) ? \"f\" : (exp instanceof Double) ? \"d\" : \"\";\n+                    throw new IllegalArgumentException(\"value must be \" + exp + t + \" with opcode \" + opcode.name());\n+                }\n+            }\n+        }\n+    }\n+\n+    public static LoadableConstantEntry constantEntry(ConstantPoolBuilder constantPool,\n+                                                      ConstantDesc constantValue) {\n+        \/\/ this method is invoked during JVM bootstrap - cannot use pattern switch\n+        if (constantValue instanceof Integer value) {\n+            return constantPool.intEntry(value);\n+        }\n+        if (constantValue instanceof String value) {\n+            return constantPool.stringEntry(value);\n+        }\n+        if (constantValue instanceof ClassDesc value) {\n+            return constantPool.classEntry(value);\n+        }\n+        if (constantValue instanceof Long value) {\n+            return constantPool.longEntry(value);\n+        }\n+        if (constantValue instanceof Float value) {\n+            return constantPool.floatEntry(value);\n+        }\n+        if (constantValue instanceof Double value) {\n+            return constantPool.doubleEntry(value);\n+        }\n+        if (constantValue instanceof MethodTypeDesc value) {\n+            return constantPool.methodTypeEntry(value);\n+        }\n+        if (constantValue instanceof DirectMethodHandleDesc value) {\n+            return handleDescToHandleInfo(constantPool, value);\n+        } if (constantValue instanceof DynamicConstantDesc<?> value) {\n+            return handleConstantDescToHandleInfo(constantPool, value);\n+        }\n+        throw new UnsupportedOperationException(\"not yet: \" + constantValue);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public final class CatchBuilderImpl implements CodeBuilder.CatchBuilder {\n+    final CodeBuilder b;\n+    final BlockCodeBuilderImpl tryBlock;\n+    final Label tryCatchEnd;\n+    final Set<ConstantDesc> catchTypes;\n+    BlockCodeBuilderImpl catchBlock;\n+\n+    public CatchBuilderImpl(CodeBuilder b, BlockCodeBuilderImpl tryBlock, Label tryCatchEnd) {\n+        this.b = b;\n+        this.tryBlock = tryBlock;\n+        this.tryCatchEnd = tryCatchEnd;\n+        this.catchTypes = new HashSet<>();\n+    }\n+\n+    @Override\n+    public CodeBuilder.CatchBuilder catching(ClassDesc exceptionType, Consumer<CodeBuilder.BlockCodeBuilder> catchHandler) {\n+        return catchingMulti(exceptionType == null ? List.of() : List.of(exceptionType), catchHandler);\n+    }\n+\n+    @Override\n+    public CodeBuilder.CatchBuilder catchingMulti(List<ClassDesc> exceptionTypes, Consumer<CodeBuilder.BlockCodeBuilder> catchHandler) {\n+        Objects.requireNonNull(exceptionTypes);\n+        Objects.requireNonNull(catchHandler);\n+\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branchInstruction(Opcode.GOTO, tryCatchEnd);\n+            }\n+        }\n+\n+        for (var exceptionType : exceptionTypes) {\n+            if (!catchTypes.add(exceptionType)) {\n+                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+            }\n+        }\n+\n+        \/\/ Finish prior catch block\n+        if (catchBlock != null) {\n+            catchBlock.end();\n+            if (catchBlock.reachable()) {\n+                b.branchInstruction(Opcode.GOTO, tryCatchEnd);\n+            }\n+        }\n+\n+        catchBlock = new BlockCodeBuilderImpl(b, tryCatchEnd);\n+        Label tryStart = tryBlock.startLabel();\n+        Label tryEnd = tryBlock.endLabel();\n+        if (exceptionTypes.isEmpty()) {\n+            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n+        }\n+        else {\n+            for (var exceptionType : exceptionTypes) {\n+                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n+            }\n+        }\n+        catchBlock.start();\n+        catchHandler.accept(catchBlock);\n+\n+        return this;\n+    }\n+\n+    @Override\n+    public void catchingAll(Consumer<CodeBuilder.BlockCodeBuilder> catchAllHandler) {\n+        catchingMulti(List.of(), catchAllHandler);\n+    }\n+\n+    public void finish() {\n+        if (catchBlock != null) {\n+            catchBlock.end();\n+        }\n+        b.labelBinding(tryCatchEnd);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+\/**\n+ * ChainedClassBuilder\n+ *\/\n+public final class ChainedClassBuilder\n+        implements ClassBuilder, Consumer<ClassElement> {\n+    private final ClassBuilder downstream;\n+    private final DirectClassBuilder terminal;\n+    private final Consumer<ClassElement> consumer;\n+\n+    public ChainedClassBuilder(ClassBuilder downstream,\n+                               Consumer<ClassElement> consumer) {\n+        this.downstream = downstream;\n+        this.consumer = consumer;\n+        ClassBuilder b = downstream;\n+        while (b instanceof ChainedClassBuilder cb)\n+            b = cb.downstream;\n+        terminal = (DirectClassBuilder) b;\n+    }\n+\n+    @Override\n+    public ClassBuilder with(ClassElement element) {\n+        consumer.accept(element);\n+        return this;\n+    }\n+\n+    @Override\n+    public Optional<ClassModel> original() {\n+        return terminal.original();\n+    }\n+\n+    @Override\n+    public ClassBuilder withField(Utf8Entry name, Utf8Entry descriptor, Consumer<? super FieldBuilder> handler) {\n+        return downstream.with(new BufferedFieldBuilder(terminal.constantPool,\n+                                                        name, descriptor, null)\n+                                       .run(handler)\n+                                       .toModel());\n+    }\n+\n+    @Override\n+    public ClassBuilder transformField(FieldModel field, FieldTransform transform) {\n+        BufferedFieldBuilder builder = new BufferedFieldBuilder(terminal.constantPool,\n+                                                                field.fieldName(), field.fieldType(),\n+                                                                field);\n+        builder.transform(field, transform);\n+        return downstream.with(builder.toModel());\n+    }\n+\n+    @Override\n+    public ClassBuilder withMethod(Utf8Entry name, Utf8Entry descriptor, int flags,\n+                                   Consumer<? super MethodBuilder> handler) {\n+        return downstream.with(new BufferedMethodBuilder(terminal.constantPool, terminal.thisClassEntry,\n+                                                         name, descriptor, null)\n+                                       .run(handler)\n+                                       .toModel());\n+    }\n+\n+    @Override\n+    public ClassBuilder transformMethod(MethodModel method, MethodTransform transform) {\n+        BufferedMethodBuilder builder = new BufferedMethodBuilder(terminal.constantPool, terminal.thisClassEntry,\n+                                                                  method.methodName(), method.methodType(), method);\n+        builder.transform(method, transform);\n+        return downstream.with(builder.toModel());\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return terminal.constantPool();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.Label;\n+\n+import java.util.function.Consumer;\n+\n+\/**\n+ * PipedCodeBuilder\n+ *\/\n+public final class ChainedCodeBuilder\n+        extends NonterminalCodeBuilder\n+        implements CodeBuilder {\n+    private final Consumer<CodeElement> consumer;\n+\n+    public ChainedCodeBuilder(CodeBuilder downstream,\n+                              Consumer<CodeElement> consumer) {\n+        super(downstream);\n+        this.consumer = consumer;\n+    }\n+\n+    @Override\n+    public Label startLabel() {\n+        return terminal.startLabel();\n+    }\n+\n+    @Override\n+    public Label endLabel() {\n+        return terminal.endLabel();\n+    }\n+\n+    @Override\n+    public int allocateLocal(TypeKind typeKind) {\n+        return parent.allocateLocal(typeKind);\n+    }\n+\n+    @Override\n+    public CodeBuilder with(CodeElement element) {\n+        consumer.accept(element);\n+        return this;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedCodeBuilder.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+\n+\/**\n+ * ChainedFieldBuilder\n+ *\/\n+public final class ChainedFieldBuilder implements FieldBuilder {\n+    private final FieldBuilder downstream;\n+    private final TerminalFieldBuilder terminal;\n+    private final Consumer<FieldElement> consumer;\n+\n+    public ChainedFieldBuilder(FieldBuilder downstream,\n+                               Consumer<FieldElement> consumer) {\n+        this.downstream = downstream;\n+        this.consumer = consumer;\n+        FieldBuilder b = downstream;\n+        while (b instanceof ChainedFieldBuilder cb)\n+            b = cb.downstream;\n+        terminal = (TerminalFieldBuilder) b;\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return terminal.constantPool();\n+    }\n+\n+    @Override\n+    public Optional<FieldModel> original() {\n+        return terminal.original();\n+    }\n+\n+    @Override\n+    public FieldBuilder with(FieldElement element) {\n+        consumer.accept(element);\n+        return this;\n+    }\n+\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedFieldBuilder.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+\n+\/**\n+ * ChainedMethodBuilder\n+ *\/\n+public final class ChainedMethodBuilder implements MethodBuilder {\n+    final MethodBuilder downstream;\n+    final TerminalMethodBuilder terminal;\n+    final Consumer<MethodElement> consumer;\n+\n+    public ChainedMethodBuilder(MethodBuilder downstream,\n+                                Consumer<MethodElement> consumer) {\n+        this.downstream = downstream;\n+        this.consumer = consumer;\n+        MethodBuilder b = downstream;\n+        while (b instanceof ChainedMethodBuilder cb)\n+            b = cb.downstream;\n+        terminal = (TerminalMethodBuilder) b;\n+    }\n+\n+    @Override\n+    public MethodBuilder with(MethodElement element) {\n+        consumer.accept(element);\n+        return this;\n+    }\n+\n+    @Override\n+    public MethodBuilder withCode(Consumer<? super CodeBuilder> handler) {\n+        return downstream.with(terminal.bufferedCodeBuilder(null)\n+                                       .run(handler)\n+                                       .toModel());\n+    }\n+\n+    @Override\n+    public MethodBuilder transformCode(CodeModel code, CodeTransform transform) {\n+        BufferedCodeBuilder builder = terminal.bufferedCodeBuilder(code);\n+        builder.transform(code, transform);\n+        return downstream.with(builder.toModel());\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return terminal.constantPool();\n+    }\n+\n+    @Override\n+    public Optional<MethodModel> original() {\n+        return terminal.original();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.InputStream;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+\n+\/**\n+ * Class hierarchy resolution framework is answering questions about classes assignability, common classes ancestor and whether the class represents an interface.\n+ * All the requests are handled without class loading nor full verification, optionally with incomplete dependencies and with focus on maximum performance.\n+ *\n+ *\/\n+public final class ClassHierarchyImpl {\n+\n+    private final ClassHierarchyResolver resolver;\n+\n+    \/\/defer initialization of logging until needed\n+    private static System.Logger logger;\n+\n+    \/**\n+     * Public constructor of <code>ClassHierarchyImpl<\/code> accepting instances of <code>ClassHierarchyInfoResolver<\/code> to resolve individual class streams.\n+     * @param classHierarchyResolver <code>ClassHierarchyInfoResolver<\/code> instance\n+     *\/\n+    public ClassHierarchyImpl(ClassHierarchyResolver classHierarchyResolver) {\n+        this.resolver = classHierarchyResolver;\n+    }\n+\n+    private ClassHierarchyResolver.ClassHierarchyInfo resolve(ClassDesc classDesc) {\n+        var res = resolver.getClassInfo(classDesc);\n+        if (res != null) return res;\n+        \/\/maybe throw an exception here to avoid construction of potentially invalid stack maps\n+        if (logger == null)\n+            logger = System.getLogger(\"jdk.internal.classfile\");\n+        if (logger.isLoggable(System.Logger.Level.DEBUG))\n+            logger.log(System.Logger.Level.DEBUG, \"Could not resolve class \" + classDesc.displayName());\n+        return new ClassHierarchyResolver.ClassHierarchyInfo(classDesc, false, null);\n+    }\n+\n+    \/**\n+     * Method answering question whether given class is an interface,\n+     * responding without the class stream resolution and parsing is preferred in case the interface status is known from previous activities.\n+     * @param classDesc class path in form of &lt;package&gt;\/&lt;class_name&gt;.class\n+     * @return true if the given class name represents an interface\n+     *\/\n+    public boolean isInterface(ClassDesc classDesc) {\n+        return resolve(classDesc).isInterface();\n+    }\n+\n+    \/**\n+     * Method resolving common ancestor of two classes\n+     * @param symbol1 first class descriptor\n+     * @param symbol2 second class descriptor\n+     * @return common ancestor class name or <code>null<\/code> if it could not be identified\n+     *\/\n+    public ClassDesc commonAncestor(ClassDesc symbol1, ClassDesc symbol2) {\n+        \/\/calculation of common ancestor is a robust (yet fast) way to decide about assignability in incompletely resolved class hierarchy\n+        \/\/exact order of symbol loops is critical for performance of the above isAssignableFrom method, so standard situations are resolved in linear time\n+        \/\/this method returns null if common ancestor could not be identified\n+        if (isInterface(symbol1) || isInterface(symbol2)) return ConstantDescs.CD_Object;\n+        for (var s1 = symbol1; s1 != null; s1 = resolve(s1).superClass()) {\n+            for (var s2 = symbol2; s2 != null; s2 = resolve(s2).superClass()) {\n+                if (s1.equals(s2)) return s1;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public boolean isAssignableFrom(ClassDesc thisClass, ClassDesc fromClass) {\n+        \/\/extra check if fromClass is an interface is necessay to handle situation when thisClass might not been fully resolved and so it is potentially an unidentified interface\n+        \/\/this special corner-case handling has been added based on better success rate of constructing stack maps with simulated broken resulution of classes and interfaces\n+        if (isInterface(fromClass)) return resolve(thisClass).superClass() == null;\n+        \/\/regular calculation of assignability is based on common ancestor calculation\n+        var anc = commonAncestor(thisClass, fromClass);\n+        \/\/if common ancestor does not exist (as the class hierarchy could not be fully resolved) we optimistically assume the classes might be accessible\n+        \/\/if common ancestor is equal to thisClass then the classes are clearly accessible\n+        \/\/if other common ancestor is calculated (which works even when their grand-parents could not be resolved) then it is clear that thisClass could not be asigned from fromClass\n+        return anc == null || thisClass.equals(anc);\n+    }\n+\n+    public static final class CachedClassHierarchyResolver implements ClassHierarchyResolver {\n+\n+        private final Function<ClassDesc, InputStream> streamProvider;\n+        private final Map<ClassDesc, ClassHierarchyResolver.ClassHierarchyInfo> resolvedCache;\n+\n+        public CachedClassHierarchyResolver(Function<ClassDesc, InputStream> classStreamProvider) {\n+            this.streamProvider = classStreamProvider;\n+            this.resolvedCache = Collections.synchronizedMap(new HashMap<>());\n+        }\n+\n+\n+        \/\/ resolve method looks for the class file using <code>ClassStreamResolver<\/code> instance and tries to briefly scan it just for minimal information necessary\n+        \/\/ minimal information includes: identification of the class as interface, obtaining its superclass name and identification of all potential interfaces (to avoid unnecessary future resolutions of them)\n+        \/\/ empty ClInfo is stored in case of an exception to avoid repeated scanning failures\n+        @Override\n+        public ClassHierarchyResolver.ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+            var res = resolvedCache.get(classDesc);\n+            \/\/additional test for null value is important to avoid repeated resolution attempts\n+            if (res == null && !resolvedCache.containsKey(classDesc)) {\n+                var ci = streamProvider.apply(classDesc);\n+                if (ci != null) {\n+                    try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n+                        in.skipBytes(8);\n+                        int cpLength = in.readUnsignedShort();\n+                        String[] cpStrings = new String[cpLength];\n+                        int[] cpClasses = new int[cpLength];\n+                        for (int i=1; i<cpLength; i++) {\n+                            switch (in.readUnsignedByte()) {\n+                                case 1 -> cpStrings[i] = in.readUTF();\n+                                case 7 -> cpClasses[i] = in.readUnsignedShort();\n+                                case 8, 16, 19, 20 -> in.skipBytes(2);\n+                                case 15 -> in.skipBytes(3);\n+                                case 3, 4, 9, 10, 11, 12, 17, 18 -> in.skipBytes(4);\n+                                case 5, 6 -> {in.skipBytes(8); i++;}\n+                            }\n+                        }\n+                        boolean isInterface = (in.readUnsignedShort() & 0x0200) != 0;\n+                        in.skipBytes(2);\n+                        int superIndex = in.readUnsignedShort();\n+                        var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n+                        res = new ClassHierarchyInfo(classDesc, isInterface, superClass);\n+                        int interfCount = in.readUnsignedShort();\n+                        for (int i=0; i<interfCount; i++) {\n+                            \/\/all listed interfaces are cached without resolution\n+                            var intDesc = ClassDesc.ofInternalName(cpStrings[cpClasses[in.readUnsignedShort()]]);\n+                            resolvedCache.put(intDesc, new ClassHierarchyResolver.ClassHierarchyInfo(intDesc, true, null));\n+                        }\n+                    } catch (Exception ignore) {\n+                        \/\/ignore\n+                    }\n+                }\n+                \/\/null ClassHierarchyInfo value is also cached to avoid repeated resolution attempts\n+                resolvedCache.put(classDesc, res);\n+            }\n+            return res;\n+        }\n+    }\n+\n+    public static final class StaticClassHierarchyResolver implements ClassHierarchyResolver {\n+        private final Map<ClassDesc, ClassHierarchyInfo> map;\n+\n+        public StaticClassHierarchyResolver(Collection<ClassDesc> interfaceNames, Map<ClassDesc, ClassDesc> classToSuperClass) {\n+            map = new HashMap<>(interfaceNames.size() + classToSuperClass.size());\n+            for (var e : classToSuperClass.entrySet())\n+                map.put(e.getKey(), new ClassHierarchyInfo(e.getKey(), false, e.getValue()));\n+            for (var i : interfaceNames)\n+                map.put(i, new ClassHierarchyInfo(i, true, null));\n+        }\n+\n+        @Override\n+        public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+            return map.get(classDesc);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.AttributeMapper;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassfileVersion;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.Interfaces;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Superclass;\n+import jdk.internal.access.SharedSecrets;\n+\n+public final class ClassImpl\n+        extends AbstractElement\n+        implements ClassModel {\n+\n+    final ClassReader reader;\n+    private final int attributesPos;\n+    private final List<MethodModel> methods;\n+    private final List<FieldModel> fields;\n+    private List<Attribute<?>> attributes;\n+    private List<ClassEntry> interfaces;\n+\n+    public ClassImpl(byte[] cfbytes,\n+                     Collection<Classfile.Option> options) {\n+        this.reader = new ClassReaderImpl(cfbytes, options);\n+        ClassReaderImpl reader = (ClassReaderImpl) this.reader;\n+        int p = reader.interfacesPos;\n+        int icnt = reader.readU2(p);\n+        p += 2 + icnt * 2;\n+        int fcnt = reader.readU2(p);\n+        FieldImpl[] fields = new FieldImpl[fcnt];\n+        p += 2;\n+        for (int i = 0; i < fcnt; ++i) {\n+            int startPos = p;\n+            int attrStart = p + 6;\n+            p = reader.skipAttributeHolder(attrStart);\n+            fields[i] = new FieldImpl(reader, startPos, p, attrStart);\n+        }\n+        this.fields = List.of(fields);\n+        int mcnt = reader.readU2(p);\n+        MethodImpl[] methods = new MethodImpl[mcnt];\n+        p += 2;\n+        for (int i = 0; i < mcnt; ++i) {\n+            int startPos = p;\n+            int attrStart = p + 6;\n+            p = reader.skipAttributeHolder(attrStart);\n+            methods[i] = new MethodImpl(reader, startPos, p, attrStart);\n+        }\n+        this.methods = List.of(methods);\n+        this.attributesPos = p;\n+        reader.setContainedClass(this);\n+    }\n+\n+    @Override\n+    public AccessFlags flags() {\n+        return AccessFlags.ofClass(reader.flags());\n+    }\n+\n+    @Override\n+    public int majorVersion() {\n+        return reader.readU2(6);\n+    }\n+\n+    @Override\n+    public int minorVersion() {\n+        return reader.readU2(4);\n+    }\n+\n+    @Override\n+    public ConstantPool constantPool() {\n+        return reader;\n+    }\n+\n+    @Override\n+    public ClassEntry thisClass() {\n+        return reader.thisClassEntry();\n+    }\n+\n+    @Override\n+    public Optional<ClassEntry> superclass() {\n+        return reader.superclassEntry();\n+    }\n+\n+    @Override\n+    public List<ClassEntry> interfaces() {\n+        if (interfaces == null) {\n+            int pos = reader.thisClassPos() + 4;\n+            int cnt = reader.readU2(pos);\n+            pos += 2;\n+            var arr = new Object[cnt];\n+            for (int i = 0; i < cnt; ++i) {\n+                arr[i] = reader.readClassEntry(pos);\n+                pos += 2;\n+            }\n+            this.interfaces = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(arr);\n+        }\n+        return interfaces;\n+    }\n+\n+    @Override\n+    public List<Attribute<?>> attributes() {\n+        if (attributes == null) {\n+            attributes = BoundAttribute.readAttributes(this, reader, attributesPos, reader.customAttributes());\n+        }\n+        return attributes;\n+    }\n+\n+    \/\/ ClassModel\n+\n+    @Override\n+    public void forEachElement(Consumer<ClassElement> consumer) {\n+        consumer.accept(flags());\n+        consumer.accept(ClassfileVersion.of(majorVersion(), minorVersion()));\n+        superclass().ifPresent(new Consumer<ClassEntry>() {\n+            @Override\n+            public void accept(ClassEntry entry) {\n+                consumer.accept(Superclass.of(entry));\n+            }\n+        });\n+        consumer.accept(Interfaces.of(interfaces()));\n+        fields().forEach(consumer);\n+        methods().forEach(consumer);\n+        for (Attribute<?> attr : attributes()) {\n+            if (attr instanceof ClassElement e)\n+                consumer.accept(e);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] transform(ClassTransform transform) {\n+        ConstantPoolBuilder constantPool = ConstantPoolBuilder.of(this);\n+        return Classfile.build(thisClass(), constantPool,\n+                               new Consumer<ClassBuilder>() {\n+                                   @Override\n+                                   public void accept(ClassBuilder builder) {\n+                                       ((DirectClassBuilder) builder).setOriginal(ClassImpl.this);\n+                                       ((DirectClassBuilder) builder).setSizeHint(reader.classfileLength());\n+                                       builder.transform(ClassImpl.this, transform);\n+                                   }\n+                               });\n+    }\n+\n+    @Override\n+    public List<FieldModel> fields() {\n+        return fields;\n+    }\n+\n+    @Override\n+    public List<MethodModel> methods() {\n+        return methods;\n+    }\n+\n+    @Override\n+    public boolean isModuleInfo() {\n+        AccessFlags flags = flags();\n+        \/\/ move to where?\n+        return flags.has(AccessFlag.MODULE)\n+               && majorVersion() >= Classfile.JAVA_9_VERSION\n+               && thisClass().asInternalName().equals(\"module-info\")\n+               && (superclass().isEmpty())\n+               && interfaces().isEmpty()\n+               && fields().isEmpty()\n+               && methods().isEmpty()\n+               && verifyModuleAttributes();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassModel[thisClass=%s, flags=%d]\", thisClass().name().stringValue(), flags().flagsMask());\n+    }\n+\n+    private boolean verifyModuleAttributes() {\n+        if (findAttribute(Attributes.MODULE).isEmpty())\n+            return false;\n+\n+        Set<AttributeMapper<?>> found = attributes().stream()\n+                                                    .map(Attribute::attributeMapper)\n+                                                    .collect(Collectors.toSet());\n+\n+        found.removeAll(allowedModuleAttributes);\n+        found.retainAll(Attributes.PREDEFINED_ATTRIBUTES);\n+        return found.isEmpty();\n+    }\n+\n+    private static final Set<AttributeMapper<?>> allowedModuleAttributes\n+            = Set.of(Attributes.MODULE,\n+                     Attributes.MODULE_HASHES,\n+                     Attributes.MODULE_MAIN_CLASS,\n+                     Attributes.MODULE_PACKAGES,\n+                     Attributes.MODULE_RESOLUTION,\n+                     Attributes.MODULE_TARGET,\n+                     Attributes.INNER_CLASSES,\n+                     Attributes.SOURCE_FILE,\n+                     Attributes.SOURCE_DEBUG_EXTENSION,\n+                     Attributes.RUNTIME_VISIBLE_ANNOTATIONS,\n+                     Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassImpl.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,1059 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.AbstractList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.internal.classfile.Annotation;\n+\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.AnnotationValue.*;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.components.ClassPrinter.*;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.*;\n+\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.CompoundElement;\n+import jdk.internal.classfile.FieldModel;\n+import static jdk.internal.classfile.impl.ClassPrinterImpl.Style.*;\n+\n+\/**\n+ * ClassPrinterImpl\n+ *\/\n+public final class ClassPrinterImpl {\n+\n+    public enum Style { BLOCK, FLOW }\n+\n+    public record LeafNodeImpl(ConstantDesc name, ConstantDesc value) implements LeafNode {\n+\n+        @Override\n+        public Stream<Node> walk() {\n+            return Stream.of(this);\n+        }\n+    }\n+\n+    public static final class ListNodeImpl extends AbstractList<Node> implements ListNode {\n+\n+        private final Style style;\n+        private final ConstantDesc name;\n+        private final Node[] nodes;\n+\n+        public ListNodeImpl(Style style, ConstantDesc name, Stream<Node> nodes) {\n+            this.style = style;\n+            this.name = name;\n+            this.nodes = nodes.toArray(Node[]::new);\n+        }\n+\n+        @Override\n+        public ConstantDesc name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public Stream<Node> walk() {\n+            return Stream.concat(Stream.of(this), stream().flatMap(Node::walk));\n+        }\n+\n+        public Style style() {\n+            return style;\n+        }\n+\n+        @Override\n+        public Node get(int index) {\n+            Objects.checkIndex(index, nodes.length);\n+            return nodes[index];\n+        }\n+\n+        @Override\n+        public int size() {\n+            return nodes.length;\n+        }\n+    }\n+\n+    public static final class MapNodeImpl implements MapNode {\n+\n+        private final Style style;\n+        private final ConstantDesc name;\n+        private final Map<ConstantDesc, Node> map;\n+\n+        public MapNodeImpl(Style style, ConstantDesc name) {\n+            this.style = style;\n+            this.name = name;\n+            this.map = new LinkedHashMap<>();\n+        }\n+\n+        @Override\n+        public ConstantDesc name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public Stream<Node> walk() {\n+            return Stream.concat(Stream.of(this), values().stream().flatMap(Node::walk));\n+        }\n+\n+        public Style style() {\n+            return style;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return map.size();\n+        }\n+        @Override\n+        public boolean isEmpty() {\n+            return map.isEmpty();\n+        }\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return map.containsKey(key);\n+        }\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return map.containsValue(value);\n+        }\n+\n+        @Override\n+        public Node get(Object key) {\n+            return map.get(key);\n+        }\n+\n+        @Override\n+        public Node put(ConstantDesc key, Node value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Node remove(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void putAll(Map<? extends ConstantDesc, ? extends Node> m) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Set<ConstantDesc> keySet() {\n+            return Collections.unmodifiableSet(map.keySet());\n+        }\n+\n+        @Override\n+        public Collection<Node> values() {\n+            return Collections.unmodifiableCollection(map.values());\n+        }\n+\n+        @Override\n+        public Set<Entry<ConstantDesc, Node>> entrySet() {\n+            return Collections.unmodifiableSet(map.entrySet());\n+        }\n+\n+\n+        MapNodeImpl with(Node... nodes) {\n+            for (var n : nodes)\n+                if (n != null && map.put(n.name(), n) != null)\n+                    throw new AssertionError(\"Double entry of \" + n.name() + \" into \" + name);\n+            return this;\n+        }\n+    }\n+\n+    private static Node leaf(ConstantDesc name, ConstantDesc value) {\n+        return new LeafNodeImpl(name, value);\n+    }\n+\n+    private static Node[] leafs(ConstantDesc... namesAndValues) {\n+        if ((namesAndValues.length & 1) > 0)\n+            throw new AssertionError(\"Odd number of arguments: \" + Arrays.toString(namesAndValues));\n+        var nodes = new Node[namesAndValues.length >> 1];\n+        for (int i = 0, j = 0; i < nodes.length; i ++) {\n+            nodes[i] = leaf(namesAndValues[j++], namesAndValues[j++]);\n+        }\n+        return nodes;\n+    }\n+\n+    private static Node list(ConstantDesc listName, ConstantDesc itemsName, Stream<ConstantDesc> values) {\n+        return new ListNodeImpl(FLOW, listName, values.map(v -> leaf(itemsName, v)));\n+    }\n+\n+    private static Node map(ConstantDesc mapName, ConstantDesc... keysAndValues) {\n+        return new MapNodeImpl(FLOW, mapName).with(leafs(keysAndValues));\n+    }\n+\n+    private static final String NL = System.lineSeparator();\n+\n+    private static final char[] DIGITS = \"0123456789ABCDEF\".toCharArray();\n+\n+    private static void escape(int c, StringBuilder sb) {\n+        switch (c) {\n+            case '\\\\'  -> sb.append('\\\\').append('\\\\');\n+            case '\"' -> sb.append('\\\\').append('\"');\n+            case '\\b' -> sb.append('\\\\').append('b');\n+            case '\\n' -> sb.append('\\\\').append('n');\n+            case '\\t' -> sb.append('\\\\').append('t');\n+            case '\\f' -> sb.append('\\\\').append('f');\n+            case '\\r' -> sb.append('\\\\').append('r');\n+            default -> {\n+                if (c >= 0x20 && c < 0x7f) {\n+                    sb.append((char)c);\n+                } else {\n+                    sb.append('\\\\').append('u').append(DIGITS[(c >> 12) & 0xf])\n+                            .append(DIGITS[(c >> 8) & 0xf]).append(DIGITS[(c >> 4) & 0xf]).append(DIGITS[(c) & 0xf]);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void toYaml(Node node, Consumer<String> out) {\n+        toYaml(0, false, new ListNodeImpl(BLOCK, null, Stream.of(node)), out);\n+        out.accept(NL);\n+    }\n+\n+    private static void toYaml(int indent, boolean skipFirstIndent, Node node, Consumer<String> out) {\n+        switch (node) {\n+            case LeafNode leaf -> {\n+                out.accept(quoteAndEscapeYaml(leaf.value()));\n+            }\n+            case ListNodeImpl list -> {\n+                switch (list.style()) {\n+                    case FLOW -> {\n+                        out.accept(\"[\");\n+                        boolean first = true;\n+                        for (var n : list) {\n+                            if (first) first = false;\n+                            else out.accept(\", \");\n+                            toYaml(0, false, n, out);\n+                        }\n+                        out.accept(\"]\");\n+                    }\n+                    case BLOCK -> {\n+                        for (var n : list) {\n+                            out.accept(NL + \"    \".repeat(indent) + \"  - \");\n+                            toYaml(indent + 1, true, n, out);\n+                        }\n+                    }\n+                }\n+            }\n+            case MapNodeImpl map -> {\n+                switch (map.style()) {\n+                    case FLOW -> {\n+                        out.accept(\"{\");\n+                        boolean first = true;\n+                        for (var n : map.values()) {\n+                            if (first) first = false;\n+                            else out.accept(\", \");\n+                            out.accept(quoteAndEscapeYaml(n.name()) + \": \");\n+                            toYaml(0, false, n, out);\n+                        }\n+                        out.accept(\"}\");\n+                    }\n+                    case BLOCK -> {\n+                        for (var n : map.values()) {\n+                            if (skipFirstIndent) {\n+                                skipFirstIndent = false;\n+                            } else {\n+                                out.accept(NL + \"    \".repeat(indent));\n+                            }\n+                            out.accept(quoteAndEscapeYaml(n.name()) + \": \");\n+                            toYaml(n instanceof ListNodeImpl pl && pl.style() == BLOCK ? indent : indent + 1, false, n, out);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String quoteAndEscapeYaml(ConstantDesc value) {\n+        String s = String.valueOf(value);\n+        if (value instanceof Number) return s;\n+        if (s.length() == 0) return \"''\";\n+        var sb = new StringBuilder(s.length() << 1);\n+        s.chars().forEach(c -> {\n+            switch (c) {\n+                case '\\''  -> sb.append(\"''\");\n+                default -> escape(c, sb);\n+            }});\n+        String esc = sb.toString();\n+        if (esc.length() != s.length()) return \"'\" + esc + \"'\";\n+        switch (esc.charAt(0)) {\n+            case '-', '?', ':', ',', '[', ']', '{', '}', '#', '&', '*', '!', '|', '>', '\\'', '\"', '%', '@', '`':\n+                return \"'\" + esc + \"'\";\n+        }\n+        for (int i = 1; i < esc.length(); i++) {\n+            switch (esc.charAt(i)) {\n+                case ',', '[', ']', '{', '}':\n+                    return \"'\" + esc + \"'\";\n+            }\n+        }\n+        return esc;\n+    }\n+\n+    public static void toJson(Node node, Consumer<String> out) {\n+        toJson(1, true, node, out);\n+        out.accept(NL);\n+    }\n+\n+    private static void toJson(int indent, boolean skipFirstIndent, Node node, Consumer<String> out) {\n+        switch (node) {\n+            case LeafNode leaf -> {\n+                out.accept(quoteAndEscapeJson(leaf.value()));\n+            }\n+            case ListNodeImpl list -> {\n+                out.accept(\"[\");\n+                boolean first = true;\n+                switch (list.style()) {\n+                    case FLOW -> {\n+                        for (var n : list) {\n+                            if (first) first = false;\n+                            else out.accept(\", \");\n+                            toJson(0, false, n, out);\n+                        }\n+                    }\n+                    case BLOCK -> {\n+                        for (var n : list) {\n+                            if (first) first = false;\n+                            else out.accept(\",\");\n+                            out.accept(NL + \"    \".repeat(indent));\n+                            toJson(indent + 1, true, n, out);\n+                        }\n+                    }\n+                }\n+                out.accept(\"]\");\n+            }\n+            case MapNodeImpl map -> {\n+                switch (map.style()) {\n+                    case FLOW -> {\n+                        out.accept(\"{\");\n+                        boolean first = true;\n+                        for (var n : map.values()) {\n+                            if (first) first = false;\n+                            else out.accept(\", \");\n+                            out.accept(quoteAndEscapeJson(n.name().toString()) + \": \");\n+                            toJson(0, false, n, out);\n+                        }\n+                    }\n+                    case BLOCK -> {\n+                        if (skipFirstIndent) out.accept(\"  { \");\n+                        else out.accept(\"{\");\n+                        boolean first = true;\n+                        for (var n : map.values()) {\n+                            if (first) first = false;\n+                            else out.accept(\",\");\n+                            if (skipFirstIndent) skipFirstIndent = false;\n+                            else out.accept(NL + \"    \".repeat(indent));\n+                            out.accept(quoteAndEscapeJson(n.name().toString()) + \": \");\n+                            toJson(indent + 1, false, n, out);\n+                        }\n+                    }\n+                }\n+                out.accept(\"}\");\n+            }\n+        }\n+    }\n+\n+    private static String quoteAndEscapeJson(ConstantDesc value) {\n+        String s = String.valueOf(value);\n+        if (value instanceof Number) return s;\n+        var sb = new StringBuilder(s.length() << 1);\n+        sb.append('\"');\n+        s.chars().forEach(c -> escape(c, sb));\n+        sb.append('\"');\n+        return sb.toString();\n+    }\n+\n+    public static void toXml(Node node, Consumer<String> out) {\n+        out.accept(\"<?xml version = '1.0'?>\");\n+        toXml(0, false, node, out);\n+        out.accept(NL);\n+    }\n+\n+    private static void toXml(int indent, boolean skipFirstIndent, Node node, Consumer<String> out) {\n+        var name = toXmlName(node.name().toString());\n+        switch (node) {\n+            case LeafNode leaf -> {\n+                out.accept(\"<\" + name + \">\");\n+                out.accept(xmlEscape(leaf.value()));\n+            }\n+            case ListNodeImpl list -> {\n+                switch (list.style()) {\n+                    case FLOW -> {\n+                        out.accept(\"<\" + name + \">\");\n+                        for (var n : list) {\n+                            toXml(0, false, n, out);\n+                        }\n+                    }\n+                    case BLOCK -> {\n+                        if (!skipFirstIndent)\n+                            out.accept(NL + \"    \".repeat(indent));\n+                        out.accept(\"<\" + name + \">\");\n+                        for (var n : list) {\n+                            out.accept(NL + \"    \".repeat(indent + 1));\n+                            toXml(indent + 1, true, n, out);\n+                        }\n+                    }\n+                }\n+            }\n+            case MapNodeImpl map -> {\n+                switch (map.style()) {\n+                    case FLOW -> {\n+                        out.accept(\"<\" + name + \">\");\n+                        for (var n : map.values()) {\n+                            toXml(0, false, n, out);\n+                        }\n+                    }\n+                    case BLOCK -> {\n+                        if (!skipFirstIndent)\n+                            out.accept(NL + \"    \".repeat(indent));\n+                        out.accept(\"<\" + name + \">\");\n+                        for (var n : map.values()) {\n+                            out.accept(NL + \"    \".repeat(indent + 1));\n+                            toXml(indent + 1, true, n, out);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        out.accept(\"<\/\" + name + \">\");\n+    }\n+\n+    private static String xmlEscape(ConstantDesc value) {\n+        var s = String.valueOf(value);\n+        var sb = new StringBuilder(s.length() << 1);\n+        s.chars().forEach(c -> {\n+        switch (c) {\n+            case '<'  -> sb.append(\"&lt;\");\n+            case '>'  -> sb.append(\"&gt;\");\n+            case '\"'  -> sb.append(\"&quot;\");\n+            case '&'  -> sb.append(\"&amp;\");\n+            case '\\''  -> sb.append(\"&apos;\");\n+            default -> escape(c, sb);\n+        }});\n+        return sb.toString();\n+    }\n+\n+    private static String toXmlName(String name) {\n+        if (Character.isDigit(name.charAt(0)))\n+            name = \"_\" + name;\n+        return name.replaceAll(\"[^A-Za-z_0-9]\", \"_\");\n+    }\n+\n+    private static Node[] elementValueToTree(AnnotationValue v) {\n+        return switch (v) {\n+            case OfString cv -> leafs(\"string\", String.valueOf(cv.constantValue()));\n+            case OfDouble cv -> leafs(\"double\", String.valueOf(cv.constantValue()));\n+            case OfFloat cv -> leafs(\"float\", String.valueOf(cv.constantValue()));\n+            case OfLong cv -> leafs(\"long\", String.valueOf(cv.constantValue()));\n+            case OfInteger cv -> leafs(\"int\", String.valueOf(cv.constantValue()));\n+            case OfShort cv -> leafs(\"short\", String.valueOf(cv.constantValue()));\n+            case OfCharacter cv -> leafs(\"char\", String.valueOf(cv.constantValue()));\n+            case OfByte cv -> leafs(\"byte\", String.valueOf(cv.constantValue()));\n+            case OfBoolean cv -> leafs(\"boolean\", String.valueOf((int)cv.constantValue() != 0));\n+            case OfClass clv -> leafs(\"class\", clv.className().stringValue());\n+            case OfEnum ev -> leafs(\"enum class\", ev.className().stringValue(),\n+                                    \"contant name\", ev.constantName().stringValue());\n+            case OfAnnotation av -> leafs(\"annotation class\", av.annotation().className().stringValue());\n+            case OfArray av -> new Node[]{new ListNodeImpl(FLOW, \"array\", av.values().stream().map(\n+                    ev -> new MapNodeImpl(FLOW, \"value\").with(elementValueToTree(ev))))};\n+        };\n+    }\n+\n+    private static Node elementValuePairsToTree(List<AnnotationElement> evps) {\n+        return new ListNodeImpl(FLOW, \"values\", evps.stream().map(evp -> new MapNodeImpl(FLOW, \"pair\").with(\n+                leaf(\"name\", evp.name().stringValue()),\n+                new MapNodeImpl(FLOW, \"value\").with(elementValueToTree(evp.value())))));\n+    }\n+\n+    private static Stream<ConstantDesc> convertVTIs(CodeAttribute lr, List<StackMapTableAttribute.VerificationTypeInfo> vtis) {\n+        return vtis.stream().mapMulti((vti, ret) -> {\n+            switch (vti) {\n+                case SimpleVerificationTypeInfo s -> {\n+                    switch (s) {\n+                        case ITEM_DOUBLE -> {\n+                            ret.accept(\"double\");\n+                            ret.accept(\"double2\");\n+                        }\n+                        case ITEM_FLOAT ->\n+                            ret.accept(\"float\");\n+                        case ITEM_INTEGER ->\n+                            ret.accept(\"int\");\n+                        case ITEM_LONG ->  {\n+                            ret.accept(\"long\");\n+                            ret.accept(\"long2\");\n+                        }\n+                        case ITEM_NULL -> ret.accept(\"null\");\n+                        case ITEM_TOP -> ret.accept(\"?\");\n+                        case ITEM_UNINITIALIZED_THIS -> ret.accept(\"THIS\");\n+                    }\n+                }\n+                case ObjectVerificationTypeInfo o ->\n+                    ret.accept(o.className().name().stringValue());\n+                case UninitializedVerificationTypeInfo u ->\n+                    ret.accept(\"UNITIALIZED @\" + lr.labelToBci(u.newTarget()));\n+            }\n+        });\n+    }\n+\n+    private record ExceptionHandler(int start, int end, int handler, String catchType) {}\n+\n+    public static MapNode modelToTree(CompoundElement<?> model, Verbosity verbosity) {\n+        return switch(model) {\n+            case ClassModel cm -> classToTree(cm, verbosity);\n+            case FieldModel fm -> fieldToTree(fm, verbosity);\n+            case MethodModel mm -> methodToTree(mm, verbosity);\n+            case CodeModel com -> codeToTree((CodeAttribute)com, verbosity);\n+        };\n+    }\n+\n+    private static MapNode classToTree(ClassModel clm, Verbosity verbosity) {\n+        return new MapNodeImpl(BLOCK, \"class\")\n+                .with(leaf(\"class name\", clm.thisClass().asInternalName()),\n+                      leaf(\"version\", clm.majorVersion() + \".\" + clm.minorVersion()),\n+                      list(\"flags\", \"flag\", clm.flags().flags().stream().map(AccessFlag::name)),\n+                      leaf(\"superclass\", clm.superclass().map(ClassEntry::asInternalName).orElse(\"\")),\n+                      list(\"interfaces\", \"interface\", clm.interfaces().stream().map(ClassEntry::asInternalName)),\n+                      list(\"attributes\", \"attribute\", clm.attributes().stream().map(Attribute::attributeName)))\n+                .with(constantPoolToTree(clm.constantPool(), verbosity))\n+                .with(attributesToTree(clm.attributes(), verbosity))\n+                .with(new ListNodeImpl(BLOCK, \"fields\", clm.fields().stream().map(f ->\n+                    fieldToTree(f, verbosity))))\n+                .with(new ListNodeImpl(BLOCK, \"methods\", clm.methods().stream().map(mm ->\n+                    (Node)methodToTree(mm, verbosity))));\n+    }\n+\n+    private static Node[] constantPoolToTree(ConstantPool cp, Verbosity verbosity) {\n+        if (verbosity == Verbosity.TRACE_ALL) {\n+            var cpNode = new MapNodeImpl(BLOCK, \"constant pool\");\n+            for (int i = 1; i < cp.entryCount();) {\n+                var e = cp.entryByIndex(i);\n+                cpNode.with(new MapNodeImpl(FLOW, i)\n+                        .with(leaf(\"tag\", switch (e.tag()) {\n+                            case TAG_UTF8 -> \"Utf8\";\n+                            case TAG_INTEGER -> \"Integer\";\n+                            case TAG_FLOAT -> \"Float\";\n+                            case TAG_LONG -> \"Long\";\n+                            case TAG_DOUBLE -> \"Double\";\n+                            case TAG_CLASS -> \"Class\";\n+                            case TAG_STRING -> \"String\";\n+                            case TAG_FIELDREF -> \"Fieldref\";\n+                            case TAG_METHODREF -> \"Methodref\";\n+                            case TAG_INTERFACEMETHODREF -> \"InterfaceMethodref\";\n+                            case TAG_NAMEANDTYPE -> \"NameAndType\";\n+                            case TAG_METHODHANDLE -> \"MethodHandle\";\n+                            case TAG_METHODTYPE -> \"MethodType\";\n+                            case TAG_CONSTANTDYNAMIC -> \"Dynamic\";\n+                            case TAG_INVOKEDYNAMIC -> \"InvokeDynamic\";\n+                            case TAG_MODULE -> \"Module\";\n+                            case TAG_PACKAGE -> \"Package\";\n+                            default -> throw new AssertionError(\"Unknown CP tag: \" + e.tag());\n+                        }))\n+                        .with(switch (e) {\n+                            case ClassEntry ce -> leafs(\n+                                \"class name index\", ce.name().index(),\n+                                \"class internal name\", ce.asInternalName());\n+                            case ModuleEntry me -> leafs(\n+                                \"module name index\", me.name().index(),\n+                                \"module name\", me.name().stringValue());\n+                            case PackageEntry pe -> leafs(\n+                                \"package name index\", pe.name().index(),\n+                                \"package name\", pe.name().stringValue());\n+                            case StringEntry se -> leafs(\n+                                    \"value index\", se.utf8().index(),\n+                                    \"value\", se.stringValue());\n+                            case MemberRefEntry mre -> leafs(\n+                                    \"owner index\", mre.owner().index(),\n+                                    \"name and type index\", mre.nameAndType().index(),\n+                                    \"owner\", mre.owner().name().stringValue(),\n+                                    \"name\", mre.name().stringValue(),\n+                                    \"type\", mre.type().stringValue());\n+                            case NameAndTypeEntry nte -> leafs(\n+                                    \"name index\", nte.name().index(),\n+                                    \"type index\", nte.type().index(),\n+                                    \"name\", nte.name().stringValue(),\n+                                    \"type\", nte.type().stringValue());\n+                            case MethodHandleEntry mhe -> leafs(\n+                                    \"reference kind\", DirectMethodHandleDesc.Kind.valueOf(mhe.kind()).name(),\n+                                    \"reference index\", mhe.reference().index(),\n+                                    \"owner\", mhe.reference().owner().asInternalName(),\n+                                    \"name\", mhe.reference().name().stringValue(),\n+                                    \"type\", mhe.reference().type().stringValue());\n+                            case MethodTypeEntry mte -> leafs(\n+                                    \"descriptor index\", mte.descriptor().index(),\n+                                    \"descriptor\", mte.descriptor().stringValue());\n+                            case DynamicConstantPoolEntry dcpe -> new Node[] {\n+                                leaf(\"bootstrap method handle index\", dcpe.bootstrap().bootstrapMethod().index()),\n+                                list(\"bootstrap method arguments indexes\",\n+                                        \"index\", dcpe.bootstrap().arguments().stream().map(en -> en.index())),\n+                                leaf(\"name and type index\", dcpe.nameAndType().index()),\n+                                leaf(\"name\", dcpe.name().stringValue()),\n+                                leaf(\"type\", dcpe.type().stringValue())};\n+                            case AnnotationConstantValueEntry ve -> leafs(\n+                                \"value\", String.valueOf(ve.constantValue())\n+                            );\n+                        }));\n+                i += e.width();\n+            }\n+            return new Node[]{cpNode};\n+        } else {\n+            return new Node[0];\n+        }\n+    }\n+\n+    private static Node frameToTree(ConstantDesc name, CodeAttribute lr, StackMapFrameInfo f) {\n+        return new MapNodeImpl(FLOW, name).with(\n+                list(\"locals\", \"item\", convertVTIs(lr, f.locals())),\n+                list(\"stack\", \"item\", convertVTIs(lr, f.stack())));\n+    }\n+\n+    private static MapNode fieldToTree(FieldModel f, Verbosity verbosity) {\n+        return new MapNodeImpl(BLOCK, \"field\")\n+                            .with(leaf(\"field name\", f.fieldName().stringValue()),\n+                                  list(\"flags\",\n+                                          \"flag\", f.flags().flags().stream().map(AccessFlag::name)),\n+                                  leaf(\"field type\", f.fieldType().stringValue()),\n+                                  list(\"attributes\",\n+                                          \"attribute\", f.attributes().stream().map(Attribute::attributeName)))\n+                            .with(attributesToTree(f.attributes(), verbosity));\n+    }\n+\n+    public static MapNode methodToTree(MethodModel m, Verbosity verbosity) {\n+        return new MapNodeImpl(BLOCK, \"method\")\n+                .with(leaf(\"method name\", m.methodName().stringValue()),\n+                      list(\"flags\",\n+                              \"flag\", m.flags().flags().stream().map(AccessFlag::name)),\n+                      leaf(\"method type\", m.methodType().stringValue()),\n+                      list(\"attributes\",\n+                              \"attribute\", m.attributes().stream().map(Attribute::attributeName)))\n+                .with(attributesToTree(m.attributes(), verbosity))\n+                .with(codeToTree((CodeAttribute)m.code().orElse(null), verbosity));\n+    }\n+\n+    private static MapNode codeToTree(CodeAttribute com, Verbosity verbosity) {\n+        if (verbosity != Verbosity.MEMBERS_ONLY && com != null) {\n+            var codeNode = new MapNodeImpl(BLOCK, \"code\");\n+            codeNode.with(leaf(\"max stack\", com.maxStack()));\n+            codeNode.with(leaf(\"max locals\", com.maxLocals()));\n+            codeNode.with(list(\"attributes\",\n+                    \"attribute\", com.attributes().stream().map(Attribute::attributeName)));\n+            var stackMap = new MapNodeImpl(BLOCK, \"stack map frames\");\n+            var visibleTypeAnnos = new LinkedHashMap<Integer, List<TypeAnnotation>>();\n+            var invisibleTypeAnnos = new LinkedHashMap<Integer, List<TypeAnnotation>>();\n+            List<LocalVariableInfo> locals = List.of();\n+            for (var attr : com.attributes()) {\n+                if (attr instanceof StackMapTableAttribute smta) {\n+                    codeNode.with(stackMap);\n+                    for (var smf : smta.entries()) {\n+                        stackMap.with(frameToTree(com.labelToBci(smf.target()), com, smf));\n+                    }\n+                } else if (verbosity == Verbosity.TRACE_ALL) switch (attr) {\n+                    case LocalVariableTableAttribute lvta -> {\n+                        locals = lvta.localVariables();\n+                        codeNode.with(new ListNodeImpl(BLOCK, \"local variables\",\n+                                IntStream.range(0, locals.size()).mapToObj(i -> {\n+                                    var lv = lvta.localVariables().get(i);\n+                                    return map(i + 1,\n+                                        \"start\", lv.startPc(),\n+                                        \"end\", lv.startPc() + lv.length(),\n+                                        \"slot\", lv.slot(),\n+                                        \"name\", lv.name().stringValue(),\n+                                        \"type\", lv.type().stringValue());\n+                                })));\n+                    }\n+                    case LocalVariableTypeTableAttribute lvtta -> {\n+                        codeNode.with(new ListNodeImpl(BLOCK, \"local variable types\",\n+                                IntStream.range(0, lvtta.localVariableTypes().size()).mapToObj(i -> {\n+                                    var lvt = lvtta.localVariableTypes().get(i);\n+                                    return map(i + 1,\n+                                        \"start\", lvt.startPc(),\n+                                        \"end\", lvt.startPc() + lvt.length(),\n+                                        \"slot\", lvt.slot(),\n+                                        \"name\", lvt.name().stringValue(),\n+                                        \"signature\", lvt.signature().stringValue());\n+                                })));\n+                    }\n+                    case LineNumberTableAttribute lnta -> {\n+                        codeNode.with(new ListNodeImpl(BLOCK, \"line numbers\",\n+                                IntStream.range(0, lnta.lineNumbers().size()).mapToObj(i -> {\n+                                    var ln = lnta.lineNumbers().get(i);\n+                                    return map(i + 1,\n+                                        \"start\", ln.startPc(),\n+                                        \"line number\", ln.lineNumber());\n+                                })));\n+                    }\n+                    case CharacterRangeTableAttribute crta -> {\n+                        codeNode.with(new ListNodeImpl(BLOCK, \"character ranges\",\n+                                IntStream.range(0, crta.characterRangeTable().size()).mapToObj(i -> {\n+                                    var cr = crta.characterRangeTable().get(i);\n+                                    return map(i + 1,\n+                                        \"start\", cr.startPc(),\n+                                        \"end\", cr.endPc(),\n+                                        \"range start\", cr.characterRangeStart(),\n+                                        \"range end\", cr.characterRangeEnd(),\n+                                        \"flags\", cr.flags());\n+                                })));\n+                    }\n+                    case RuntimeVisibleTypeAnnotationsAttribute rvtaa ->\n+                        rvtaa.annotations().forEach(a -> forEachOffset(a, com, (off, an) ->\n+                                visibleTypeAnnos.computeIfAbsent(off, o -> new LinkedList<>()).add(an)));\n+                    case RuntimeInvisibleTypeAnnotationsAttribute ritaa ->\n+                        ritaa.annotations().forEach(a -> forEachOffset(a, com, (off, an) ->\n+                                invisibleTypeAnnos.computeIfAbsent(off, o -> new LinkedList<>()).add(an)));\n+                    case Object o -> {}\n+                }\n+            }\n+            codeNode.with(attributesToTree(com.attributes(), verbosity));\n+            if (!stackMap.containsKey(0)) {\n+                codeNode.with(new MapNodeImpl(FLOW, \"\/\/stack map frame @0\").with(\n+                    list(\"locals\", \"item\", convertVTIs(com, StackMapDecoder.initFrameLocals(com.parent().get()))),\n+                    list(\"stack\", \"item\", Stream.of())));\n+            }\n+            var excHandlers = com.exceptionHandlers().stream().map(exc -> new ExceptionHandler(\n+                    com.labelToBci(exc.tryStart()),\n+                    com.labelToBci(exc.tryEnd()),\n+                    com.labelToBci(exc.handler()),\n+                    exc.catchType().map(ct -> ct.name().stringValue()).orElse(null))).toList();\n+            int bci = 0;\n+            for (var coe : com) {\n+                if (coe instanceof Instruction ins) {\n+                    var frame = stackMap.get(bci);\n+                    if (frame != null) {\n+                        codeNode.with(new MapNodeImpl(FLOW, \"\/\/stack map frame @\" + bci)\n+                                .with(((MapNodeImpl)frame).values().toArray(new Node[2])));\n+                    }\n+                    var annos = invisibleTypeAnnos.get(bci);\n+                    if (annos != null) {\n+                        codeNode.with(typeAnnotationsToTree(FLOW, \"\/\/invisible type annotations @\" + bci, annos));\n+                    }\n+                    annos = visibleTypeAnnos.get(bci);\n+                    if (annos != null) {\n+                        codeNode.with(typeAnnotationsToTree(FLOW, \"\/\/visible type annotations @\" + bci, annos));\n+                    }\n+                    for (int i = 0; i < excHandlers.size(); i++) {\n+                        var exc = excHandlers.get(i);\n+                        if (exc.start() == bci) {\n+                            codeNode.with(map(\"\/\/try block \" + (i + 1) + \" start\",\n+                                    \"start\", exc.start(),\n+                                    \"end\", exc.end(),\n+                                    \"handler\", exc.handler(),\n+                                    \"catch type\", exc.catchType()));\n+                        }\n+                        if (exc.end() == bci) {\n+                            codeNode.with(map(\"\/\/try block \" + (i + 1) + \" end\",\n+                                    \"start\", exc.start(),\n+                                    \"end\", exc.end(),\n+                                    \"handler\", exc.handler(),\n+                                    \"catch type\", exc.catchType()));\n+                        }\n+                        if (exc.handler() == bci) {\n+                            codeNode.with(map(\"\/\/exception handler \" + (i + 1) + \" start\",\n+                                    \"start\", exc.start(),\n+                                    \"end\", exc.end(),\n+                                    \"handler\", exc.handler(),\n+                                    \"catch type\", exc.catchType()));\n+                        }\n+                    }\n+                    var in = new MapNodeImpl(FLOW, bci).with(leaf(\"opcode\", ins.opcode().name()));\n+                    codeNode.with(in);\n+                    switch (coe) {\n+                        case IncrementInstruction inc ->  in.with(leafs(\n+                                \"slot\", inc.slot(),\n+                                \"const\", inc.constant()))\n+                                .with(localInfoToTree(locals, inc.slot(), bci));\n+                        case LoadInstruction lv ->  in.with(leaf(\n+                                \"slot\", lv.slot()))\n+                                .with(localInfoToTree(locals, lv.slot(), bci));\n+                        case StoreInstruction lv ->  in.with(leaf(\n+                                \"slot\", lv.slot()))\n+                                .with(localInfoToTree(locals, lv.slot(), bci));\n+                        case FieldInstruction fa -> in.with(leafs(\n+                                \"owner\", fa.owner().name().stringValue(),\n+                                \"field name\", fa.name().stringValue(),\n+                                \"field type\", fa.type().stringValue()));\n+                        case InvokeInstruction inv -> in.with(leafs(\n+                                \"owner\", inv.owner().name().stringValue(),\n+                                \"method name\", inv.name().stringValue(),\n+                                \"method type\", inv.type().stringValue()));\n+                        case InvokeDynamicInstruction invd -> in.with(leafs(\n+                                \"name\", invd.name().stringValue(),\n+                                \"descriptor\", invd.type().stringValue(),\n+                                \"kind\", invd.bootstrapMethod().kind().name(),\n+                                \"owner\", invd.bootstrapMethod().owner().descriptorString(),\n+                                \"method name\", invd.bootstrapMethod().methodName(),\n+                                \"invocation type\", invd.bootstrapMethod().invocationType().descriptorString()));\n+                        case NewObjectInstruction newo -> in.with(leaf(\n+                                \"type\", newo.className().name().stringValue()));\n+                        case NewPrimitiveArrayInstruction newa -> in.with(leafs(\n+                                \"dimensions\", 1,\n+                                \"descriptor\", newa.typeKind().typeName()));\n+                        case NewReferenceArrayInstruction newa -> in.with(leafs(\n+                                \"dimensions\", 1,\n+                                \"descriptor\", newa.componentType().name().stringValue()));\n+                        case NewMultiArrayInstruction newa -> in.with(leafs(\n+                                \"dimensions\", newa.dimensions(),\n+                                \"descriptor\", newa.arrayType().name().stringValue()));\n+                        case TypeCheckInstruction tch -> in.with(leaf(\n+                                \"type\", tch.type().name().stringValue()));\n+                        case ConstantInstruction cons -> in.with(leaf(\n+                                \"constant value\", cons.constantValue()));\n+                        case BranchInstruction br -> in.with(leaf(\n+                                \"target\", com.labelToBci(br.target())));\n+                        case LookupSwitchInstruction si -> in.with(list(\n+                                \"targets\", \"target\", Stream.concat(Stream.of(si.defaultTarget())\n+                                        .map(com::labelToBci), si.cases().stream()\n+                                                .map(sc -> com.labelToBci(sc.target())))));\n+                        case TableSwitchInstruction si -> in.with(list(\n+                                \"targets\", \"target\", Stream.concat(Stream.of(si.defaultTarget())\n+                                        .map(com::labelToBci), si.cases().stream()\n+                                                .map(sc -> com.labelToBci(sc.target())))));\n+                        default -> {}\n+                    }\n+                    bci += ins.sizeInBytes();\n+                }\n+            }\n+            if (!excHandlers.isEmpty()) {\n+                var handlersNode = new MapNodeImpl(BLOCK, \"exception handlers\");\n+                codeNode.with(handlersNode);\n+                for (int i = 0; i < excHandlers.size(); i++) {\n+                    var exc = excHandlers.get(i);\n+                    handlersNode.with(map(\"handler \" + (i + 1),\n+                            \"start\", exc.start(),\n+                            \"end\", exc.end(),\n+                            \"handler\", exc.handler(),\n+                            \"type\", exc.catchType()));\n+                }\n+            }\n+            return codeNode;\n+        }\n+        return null;\n+    }\n+\n+    private static Node[] attributesToTree(List<Attribute<?>> attributes, Verbosity verbosity) {\n+        var nodes = new LinkedList<Node>();\n+        if (verbosity != Verbosity.MEMBERS_ONLY) for (var attr : attributes) {\n+            switch (attr) {\n+                case BootstrapMethodsAttribute bma ->\n+                    nodes.add(new ListNodeImpl(BLOCK, \"bootstrap methods\", bma.bootstrapMethods().stream().map(\n+                    bm -> {\n+                        var mh = bm.bootstrapMethod();\n+                        var mref = mh.reference();\n+                        return map(\"bm\",\n+                                \"kind\", DirectMethodHandleDesc.Kind.valueOf(mh.kind(),\n+                                        mref instanceof InterfaceMethodRefEntry).name(),\n+                                \"owner\", mref.owner().name().stringValue(),\n+                                \"name\", mref.nameAndType().name().stringValue(),\n+                                \"type\", mref.nameAndType().type().stringValue());\n+                    })));\n+                case ConstantValueAttribute cva ->\n+                    nodes.add(leaf(\"constant value\", cva.constant().constantValue()));\n+                case NestHostAttribute nha ->\n+                    nodes.add(leaf(\"nest host\", nha.nestHost().name().stringValue()));\n+                case NestMembersAttribute nma ->\n+                    nodes.add(list(\"nest members\", \"member\", nma.nestMembers().stream()\n+                            .map(mp -> mp.name().stringValue())));\n+                case PermittedSubclassesAttribute psa ->\n+                    nodes.add(list(\"permitted subclasses\", \"subclass\", psa.permittedSubclasses().stream()\n+                            .map(e -> e.name().stringValue())));\n+                default -> {}\n+            }\n+            if (verbosity == Verbosity.TRACE_ALL) switch (attr) {\n+                case EnclosingMethodAttribute ema ->\n+                    nodes.add(map(\"enclosing method\",\n+                            \"class\", ema.enclosingClass().name().stringValue(),\n+                            \"method name\", ema.enclosingMethodName()\n+                                    .map(Utf8Entry::stringValue).orElse(\"null\"),\n+                            \"method type\", ema.enclosingMethodType()\n+                                    .map(Utf8Entry::stringValue).orElse(\"null\")));\n+                case ExceptionsAttribute exa ->\n+                    nodes.add(list(\"excceptions\", \"exc\", exa.exceptions().stream()\n+                            .map(e -> e.name().stringValue())));\n+                case InnerClassesAttribute ica ->\n+                    nodes.add(new ListNodeImpl(BLOCK, \"inner classes\", ica.classes().stream()\n+                            .map(ic -> new MapNodeImpl(FLOW, \"cls\").with(\n+                                leaf(\"inner class\", ic.innerClass().name().stringValue()),\n+                                leaf(\"outer class\", ic.outerClass()\n+                                        .map(cle -> cle.name().stringValue()).orElse(\"null\")),\n+                                leaf(\"inner name\", ic.innerName().map(Utf8Entry::stringValue).orElse(\"null\")),\n+                                list(\"flags\", \"flag\", ic.flags().stream().map(AccessFlag::name))))));\n+                case MethodParametersAttribute mpa -> {\n+                    var n = new MapNodeImpl(BLOCK, \"method parameters\");\n+                    for (int i = 0; i < mpa.parameters().size(); i++) {\n+                        var p = mpa.parameters().get(i);\n+                        n.with(new MapNodeImpl(FLOW, i + 1).with(\n+                                leaf(\"name\", p.name().map(Utf8Entry::stringValue).orElse(\"null\")),\n+                                list(\"flags\", \"flag\", p.flags().stream().map(AccessFlag::name))));\n+                    }\n+                }\n+                case ModuleAttribute ma ->\n+                    nodes.add(new MapNodeImpl(BLOCK, \"module\")\n+                            .with(leaf(\"name\", ma.moduleName().name().stringValue()),\n+                                  list(\"flags\",\"flag\", ma.moduleFlags().stream().map(AccessFlag::name)),\n+                                  leaf(\"version\", ma.moduleVersion().map(Utf8Entry::stringValue).orElse(\"null\")),\n+                                  list(\"uses\", \"class\", ma.uses().stream().map(ce -> ce.name().stringValue())),\n+                                  new ListNodeImpl(BLOCK, \"requires\", ma.requires().stream().map(req ->\n+                                    new MapNodeImpl(FLOW, \"req\").with(\n+                                            leaf(\"name\", req.requires().name().stringValue()),\n+                                            list(\"flags\", \"flag\", req.requiresFlags().stream()\n+                                                    .map(AccessFlag::name)),\n+                                            leaf(\"version\", req.requiresVersion()\n+                                                    .map(Utf8Entry::stringValue).orElse(null))))),\n+                                  new ListNodeImpl(BLOCK, \"exports\", ma.exports().stream().map(exp ->\n+                                    new MapNodeImpl(FLOW, \"exp\").with(\n+                                            leaf(\"package\", exp.exportedPackage().asSymbol().packageName()),\n+                                            list(\"flags\", \"flag\", exp.exportsFlags().stream()\n+                                                    .map(AccessFlag::name)),\n+                                            list(\"to\", \"module\", exp.exportsTo().stream()\n+                                                    .map(me -> me.name().stringValue()))))),\n+                                  new ListNodeImpl(BLOCK, \"opens\", ma.opens().stream().map(opn ->\n+                                    new MapNodeImpl(FLOW, \"opn\").with(\n+                                            leaf(\"package\", opn.openedPackage().asSymbol().packageName()),\n+                                            list(\"flags\", \"flag\", opn.opensFlags().stream()\n+                                                    .map(AccessFlag::name)),\n+                                            list(\"to\", \"module\", opn.opensTo().stream()\n+                                                    .map(me -> me.name().stringValue()))))),\n+                                  new ListNodeImpl(BLOCK, \"provides\", ma.provides().stream()\n+                                          .map(prov -> new MapNodeImpl(FLOW, \"prov\").with(\n+                                                  leaf(\"class\", prov.provides().name().stringValue()),\n+                                                  list(\"with\", \"cls\", prov.providesWith().stream()\n+                                                          .map(ce -> ce.name().stringValue())))))));\n+                case ModulePackagesAttribute mopa ->\n+                    nodes.add(list(\"module packages\", \"subclass\", mopa.packages().stream()\n+                            .map(mp -> mp.asSymbol().packageName())));\n+                case ModuleMainClassAttribute mmca ->\n+                    nodes.add(leaf(\"module main class\", mmca.mainClass().name().stringValue()));\n+                case RecordAttribute ra ->\n+                    nodes.add(new ListNodeImpl(BLOCK, \"record components\", ra.components().stream()\n+                            .map(rc -> new MapNodeImpl(BLOCK, \"record\")\n+                                    .with(leafs(\n+                                        \"name\", rc.name().stringValue(),\n+                                        \"type\", rc.descriptor().stringValue()))\n+                                    .with(list(\"attributes\", \"attribute\", rc.attributes().stream()\n+                                            .map(Attribute::attributeName)))\n+                                    .with(attributesToTree(rc.attributes(), verbosity)))));\n+                case AnnotationDefaultAttribute ada ->\n+                    nodes.add(new MapNodeImpl(FLOW, \"annotation default\").with(elementValueToTree(ada.defaultValue())));\n+                case RuntimeInvisibleAnnotationsAttribute aa ->\n+                    nodes.add(annotationsToTree(\"invisible annotations\", aa.annotations()));\n+                case RuntimeVisibleAnnotationsAttribute aa ->\n+                    nodes.add(annotationsToTree(\"visible annotations\", aa.annotations()));\n+                case RuntimeInvisibleParameterAnnotationsAttribute aa ->\n+                    nodes.add(parameterAnnotationsToTree(\"invisible parameter annotations\", aa.parameterAnnotations()));\n+                case RuntimeVisibleParameterAnnotationsAttribute aa ->\n+                    nodes.add(parameterAnnotationsToTree(\"visible parameter annotations\", aa.parameterAnnotations()));\n+                case RuntimeInvisibleTypeAnnotationsAttribute aa ->\n+                    nodes.add(typeAnnotationsToTree(BLOCK, \"invisible type annotations\", aa.annotations()));\n+                case RuntimeVisibleTypeAnnotationsAttribute aa ->\n+                    nodes.add(typeAnnotationsToTree(BLOCK, \"visible type annotations\", aa.annotations()));\n+                case SignatureAttribute sa ->\n+                    nodes.add(leaf(\"signature\", sa.signature().stringValue()));\n+                case SourceFileAttribute sfa ->\n+                    nodes.add(leaf(\"source file\", sfa.sourceFile().stringValue()));\n+                default -> {}\n+            }\n+        }\n+        return nodes.toArray(Node[]::new);\n+    }\n+\n+    private static Node annotationsToTree(String name, List<Annotation> annos) {\n+        return new ListNodeImpl(BLOCK, name, annos.stream().map(a ->\n+                new MapNodeImpl(FLOW, \"anno\")\n+                        .with(leaf(\"annotation class\", a.className().stringValue()))\n+                        .with(elementValuePairsToTree(a.elements()))));\n+\n+    }\n+\n+    private static Node typeAnnotationsToTree(Style style, String name, List<TypeAnnotation> annos) {\n+        return new ListNodeImpl(style, name, annos.stream().map(a ->\n+                new MapNodeImpl(FLOW, \"anno\")\n+                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                              leaf(\"target info\", a.targetInfo().targetType().name()))\n+                        .with(elementValuePairsToTree(a.elements()))));\n+\n+    }\n+\n+    private static MapNodeImpl parameterAnnotationsToTree(String name, List<List<Annotation>> paramAnnotations) {\n+        var node = new MapNodeImpl(BLOCK, name);\n+        for (int i = 0; i < paramAnnotations.size(); i++) {\n+            var annos = paramAnnotations.get(i);\n+            if (!annos.isEmpty()) {\n+                node.with(new ListNodeImpl(FLOW, \"parameter \" + (i + 1), annos.stream().map(a ->\n+                                new MapNodeImpl(FLOW, \"anno\")\n+                                        .with(leaf(\"annotation class\", a.className().stringValue()))\n+                                        .with(elementValuePairsToTree(a.elements())))));\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static Node[] localInfoToTree(List<LocalVariableInfo> locals, int slot, int bci) {\n+        if (locals != null) {\n+            for (var l : locals) {\n+                if (l.slot() == slot && l.startPc() <= bci && l.length() + l.startPc() >= bci) {\n+                    return leafs(\"type\", l.type().stringValue(),\n+                                 \"variable name\", l.name().stringValue());\n+                }\n+            }\n+        }\n+        return new Node[0];\n+    }\n+\n+    private static void forEachOffset(TypeAnnotation ta, CodeAttribute lr, BiConsumer<Integer, TypeAnnotation> consumer) {\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.OffsetTarget ot ->\n+                consumer.accept(lr.labelToBci(ot.target()), ta);\n+            case TypeAnnotation.TypeArgumentTarget tat ->\n+                consumer.accept(lr.labelToBci(tat.target()), ta);\n+            case TypeAnnotation.LocalVarTarget lvt ->\n+                lvt.table().forEach(lvti -> consumer.accept(lr.labelToBci(lvti.startLabel()), ta));\n+            default -> {}\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":1059,"deletions":0,"binary":false,"changes":1059,"status":"added"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import static jdk.internal.classfile.Classfile.TAG_CLASS;\n+import static jdk.internal.classfile.Classfile.TAG_CONSTANTDYNAMIC;\n+import static jdk.internal.classfile.Classfile.TAG_DOUBLE;\n+import static jdk.internal.classfile.Classfile.TAG_FIELDREF;\n+import static jdk.internal.classfile.Classfile.TAG_FLOAT;\n+import static jdk.internal.classfile.Classfile.TAG_INTEGER;\n+import static jdk.internal.classfile.Classfile.TAG_INTERFACEMETHODREF;\n+import static jdk.internal.classfile.Classfile.TAG_INVOKEDYNAMIC;\n+import static jdk.internal.classfile.Classfile.TAG_LONG;\n+import static jdk.internal.classfile.Classfile.TAG_METHODHANDLE;\n+import static jdk.internal.classfile.Classfile.TAG_METHODREF;\n+import static jdk.internal.classfile.Classfile.TAG_METHODTYPE;\n+import static jdk.internal.classfile.Classfile.TAG_MODULE;\n+import static jdk.internal.classfile.Classfile.TAG_NAMEANDTYPE;\n+import static jdk.internal.classfile.Classfile.TAG_PACKAGE;\n+import static jdk.internal.classfile.Classfile.TAG_STRING;\n+import static jdk.internal.classfile.Classfile.TAG_UTF8;\n+\n+\/**\n+ * ClassReaderImpl\n+ *\/\n+public final class ClassReaderImpl\n+        implements ClassReader {\n+    static final int CP_ITEM_START = 10;\n+\n+    private final byte[] buffer;\n+    private final int metadataStart;\n+    private final int classfileLength;\n+    private final Function<Utf8Entry, AttributeMapper<?>> attributeMapper;\n+    private final int flags;\n+    private final int thisClassPos;\n+    private ClassEntry thisClass;\n+    private Optional<ClassEntry> superclass;\n+    private final int constantPoolCount;\n+    private final int[] cpOffset;\n+\n+    final Options options;\n+    final int interfacesPos;\n+    final PoolEntry[] cp;\n+\n+    private ClassModel containedClass;\n+    private List<ConcreteBootstrapMethodEntry> bsmEntries;\n+    private BootstrapMethodsAttribute bootstrapMethodsAttribute;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    ClassReaderImpl(byte[] classfileBytes,\n+                    Collection<Classfile.Option> options) {\n+        this.buffer = classfileBytes;\n+        this.classfileLength = classfileBytes.length;\n+        this.options = new Options(options);\n+        this.attributeMapper = this.options.attributeMapper;\n+        if (classfileLength < 4 || readInt(0) != 0xCAFEBABE) {\n+            throw new IllegalStateException(\"Bad magic number\");\n+        }\n+        int constantPoolCount = readU2(8);\n+        int[] cpOffset = new int[constantPoolCount];\n+        int p = CP_ITEM_START;\n+        for (int i = 1; i < cpOffset.length; ++i) {\n+            cpOffset[i] = p;\n+            int tag = readU1(p);\n+            ++p;\n+            switch (tag) {\n+                \/\/ 2\n+                case TAG_CLASS, TAG_METHODTYPE, TAG_MODULE, TAG_STRING, TAG_PACKAGE -> p += 2;\n+\n+                \/\/ 3\n+                case TAG_METHODHANDLE -> p += 3;\n+\n+                \/\/ 4\n+                case TAG_CONSTANTDYNAMIC, TAG_FIELDREF, TAG_FLOAT, TAG_INTEGER, TAG_INTERFACEMETHODREF, TAG_INVOKEDYNAMIC, TAG_METHODREF, TAG_NAMEANDTYPE -> p += 4;\n+\n+                \/\/ 8\n+                case TAG_DOUBLE, TAG_LONG -> {\n+                    p += 8;\n+                    ++i;\n+                }\n+                case TAG_UTF8 -> p += 2 + readU2(p);\n+                default -> throw new IllegalStateException(\n+                        \"Bad tag (\" + tag + \") at index (\" + i + \") position (\" + p + \")\");\n+            }\n+        }\n+        this.metadataStart = p;\n+        this.cpOffset = cpOffset;\n+        this.constantPoolCount = constantPoolCount;\n+        this.cp = new PoolEntry[constantPoolCount];\n+\n+        p = metadataStart;\n+        this.flags = readU2(p);\n+        this.thisClassPos = p + 2;\n+        p += 6;\n+        this.interfacesPos = p;\n+    }\n+\n+    public Options options() {\n+        return options;\n+    }\n+\n+    @Override\n+    public Function<Utf8Entry, AttributeMapper<?>> customAttributes() {\n+        return attributeMapper;\n+    }\n+\n+    @Override\n+    public int entryCount() {\n+        return constantPoolCount;\n+    }\n+\n+    @Override\n+    public int flags() {\n+        return flags;\n+    }\n+\n+    @Override\n+    public ClassEntry thisClassEntry() {\n+        if (thisClass == null) {\n+            thisClass = readClassEntry(thisClassPos);\n+        }\n+        return thisClass;\n+    }\n+\n+    @Override\n+    public Optional<ClassEntry> superclassEntry() {\n+        if (superclass == null) {\n+            int scIndex = readU2(thisClassPos + 2);\n+            superclass = Optional.ofNullable(scIndex == 0 ? null : (ClassEntry) entryByIndex(scIndex));\n+        }\n+        return superclass;\n+    }\n+\n+    @Override\n+    public int thisClassPos() {\n+        return thisClassPos;\n+    }\n+\n+    @Override\n+    public int classfileLength() {\n+        return classfileLength;\n+    }\n+\n+    \/\/------ Bootstrap Method Table handling\n+\n+    @Override\n+    public int bootstrapMethodCount() {\n+        return bootstrapMethodsAttribute().bootstrapMethodsSize();\n+    }\n+\n+    @Override\n+    public ConcreteBootstrapMethodEntry bootstrapMethodEntry(int index) {\n+        return bsmEntries().get(index);\n+    }\n+\n+    public int readU1(int p) {\n+        return buffer[p] & 0xFF;\n+    }\n+\n+    public int readU2(int p) {\n+        int b1 = buffer[p] & 0xFF;\n+        int b2 = buffer[p + 1] & 0xFF;\n+        return (b1 << 8) + b2;\n+    }\n+\n+    public int readS1(int p) {\n+        return buffer[p];\n+    }\n+\n+    public int readS2(int p) {\n+        int b1 = buffer[p];\n+        int b2 = buffer[p + 1] & 0xFF;\n+        return (b1 << 8) + b2;\n+    }\n+\n+    public int readInt(int p) {\n+        int ch1 = buffer[p] & 0xFF;\n+        int ch2 = buffer[p + 1] & 0xFF;\n+        int ch3 = buffer[p + 2] & 0xFF;\n+        int ch4 = buffer[p + 3] & 0xFF;\n+        return (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0);\n+    }\n+\n+    public long readLong(int p) {\n+        return ((long) buffer[p + 0] << 56) + ((long) (buffer[p + 1] & 255) << 48) +\n+               ((long) (buffer[p + 2] & 255) << 40) + ((long) (buffer[p + 3] & 255) << 32) +\n+               ((long) (buffer[p + 4] & 255) << 24) + ((buffer[p + 5] & 255) << 16) + ((buffer[p + 6] & 255) << 8) +\n+               ((buffer[p + 7] & 255) << 0);\n+    }\n+\n+    public float readFloat(int p) {\n+        return Float.intBitsToFloat(readInt(p));\n+    }\n+\n+    public double readDouble(int p) {\n+        return Double.longBitsToDouble(readLong(p));\n+    }\n+\n+    public byte[] readBytes(int p, int len) {\n+        return Arrays.copyOfRange(buffer, p, p + len);\n+    }\n+\n+    public void copyBytesTo(BufWriter buf, int p, int len) {\n+        buf.writeBytes(buffer, p, len);\n+    }\n+\n+    BootstrapMethodsAttribute bootstrapMethodsAttribute() {\n+\n+        if (bootstrapMethodsAttribute == null) {\n+            bootstrapMethodsAttribute\n+                    = containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS)\n+                                    .orElse(new UnboundAttribute.EmptyBootstrapAttribute());\n+        }\n+\n+        return bootstrapMethodsAttribute;\n+    }\n+\n+    List<ConcreteBootstrapMethodEntry> bsmEntries() {\n+        if (bsmEntries == null) {\n+            bsmEntries = new ArrayList<>();\n+            BootstrapMethodsAttribute attr = bootstrapMethodsAttribute();\n+            List<BootstrapMethodEntry> list = attr.bootstrapMethods();\n+            if (list.size() > 0) {\n+                for (BootstrapMethodEntry bm : list) {\n+                    ConcreteEntry.ConcreteMethodHandleEntry handle = (ConcreteEntry.ConcreteMethodHandleEntry) bm.bootstrapMethod();\n+                    List<LoadableConstantEntry> args = bm.arguments();\n+                    int hash = ConcreteBootstrapMethodEntry.computeHashCode(handle, args);\n+                    bsmEntries.add(new ConcreteBootstrapMethodEntry(this, bsmEntries.size(), hash, handle, args));\n+                }\n+            }\n+        }\n+        return bsmEntries;\n+    }\n+\n+    void setContainedClass(ClassModel containedClass) {\n+        this.containedClass = containedClass;\n+    }\n+\n+    ClassModel getContainedClass() {\n+        return containedClass;\n+    }\n+\n+    boolean writeBootstrapMethods(BufWriter buf) {\n+        Optional<BootstrapMethodsAttribute> a\n+                = containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS);\n+        if (a.isEmpty())\n+            return false;\n+        a.get().writeTo(buf);\n+        return true;\n+    }\n+\n+    WritableElement<BootstrapMethodsAttribute> bootstrapMethodsWriter() {\n+        return containedClass.findAttribute(Attributes.BOOTSTRAP_METHODS)\n+                             .orElse(null);\n+    }\n+\n+    void writeConstantPoolEntries(BufWriter buf) {\n+        copyBytesTo(buf, ClassReaderImpl.CP_ITEM_START,\n+                    metadataStart - ClassReaderImpl.CP_ITEM_START);\n+    }\n+\n+    \/\/ Constantpool\n+    public PoolEntry entryByIndex(int index) {\n+        if (index <= 0 || index >= constantPoolCount) {\n+            throw new IndexOutOfBoundsException(\"Bad CP index: \" + index);\n+        }\n+        PoolEntry info = cp[index];\n+        if (info == null) {\n+            int offset = cpOffset[index];\n+            int tag = readU1(offset);\n+            final int q = offset + 1;\n+            info = switch (tag) {\n+                case TAG_UTF8 -> new ConcreteEntry.ConcreteUtf8Entry(this, index, buffer, q + 2, readU2(q));\n+                case TAG_INTEGER -> new ConcreteEntry.ConcreteIntegerEntry(this, index, readInt(q));\n+                case TAG_FLOAT -> new ConcreteEntry.ConcreteFloatEntry(this, index, readFloat(q));\n+                case TAG_LONG -> new ConcreteEntry.ConcreteLongEntry(this, index, readLong(q));\n+                case TAG_DOUBLE -> new ConcreteEntry.ConcreteDoubleEntry(this, index, readDouble(q));\n+                case TAG_CLASS -> new ConcreteEntry.ConcreteClassEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n+                case TAG_STRING -> new ConcreteEntry.ConcreteStringEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n+                case TAG_FIELDREF -> new ConcreteEntry.ConcreteFieldRefEntry(this, index, (ConcreteEntry.ConcreteClassEntry) readClassEntry(q),\n+                                                                             (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n+                case TAG_METHODREF -> new ConcreteEntry.ConcreteMethodRefEntry(this, index, (ConcreteEntry.ConcreteClassEntry) readClassEntry(q),\n+                                                                               (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n+                case TAG_INTERFACEMETHODREF -> new ConcreteEntry.ConcreteInterfaceMethodRefEntry(this, index, (ConcreteEntry.ConcreteClassEntry) readClassEntry(q),\n+                                                                                                 (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n+                case TAG_NAMEANDTYPE -> new ConcreteEntry.ConcreteNameAndTypeEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q),\n+                                                                                   (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q + 2));\n+                case TAG_METHODHANDLE -> new ConcreteEntry.ConcreteMethodHandleEntry(this, index, readU1(q),\n+                                                                                     (ConcreteEntry.MemberRefEntry) readEntry(q + 1));\n+                case TAG_METHODTYPE -> new ConcreteEntry.ConcreteMethodTypeEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n+                case TAG_CONSTANTDYNAMIC -> new ConcreteEntry.ConcreteConstantDynamicEntry(this, index, readU2(q), (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n+                case TAG_INVOKEDYNAMIC -> new ConcreteEntry.ConcreteInvokeDynamicEntry(this, index, readU2(q), (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n+                case TAG_MODULE -> new ConcreteEntry.ConcreteModuleEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n+                case TAG_PACKAGE -> new ConcreteEntry.ConcretePackageEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n+                default -> throw new IllegalStateException(\n+                        \"Bad tag (\" + tag + \") at index (\" + index + \") position (\" + offset + \")\");\n+            };\n+            cp[index] = info;\n+        }\n+        return info;\n+    }\n+\n+    @Override\n+    public ConcreteEntry.ConcreteUtf8Entry utf8EntryByIndex(int index) {\n+        if (index <= 0 || index >= constantPoolCount) {\n+            throw new IndexOutOfBoundsException(\"Bad CP UTF8 index: \" + index);\n+        }\n+        PoolEntry info = cp[index];\n+        if (info == null) {\n+            int offset = cpOffset[index];\n+            int tag = readU1(offset);\n+            final int q = offset + 1;\n+            if (tag != TAG_UTF8) throw new IllegalArgumentException(\"Not a UTF8 - index: \" + index);\n+            ConcreteEntry.ConcreteUtf8Entry uinfo\n+                    = new ConcreteEntry.ConcreteUtf8Entry(this, index, buffer, q + 2, readU2(q));\n+            cp[index] = uinfo;\n+            return uinfo;\n+        }\n+        return (ConcreteEntry.ConcreteUtf8Entry) info;\n+    }\n+\n+    @Override\n+    public int skipAttributeHolder(int offset) {\n+        int p = offset;\n+        int cnt = readU2(p);\n+        p += 2;\n+        for (int i = 0; i < cnt; ++i) {\n+            int len = readInt(p + 2);\n+            p += 6 + len;\n+        }\n+        return p;\n+    }\n+\n+    @Override\n+    public PoolEntry readEntry(int pos) {\n+        return entryByIndex(readU2(pos));\n+    }\n+\n+    @Override\n+    public PoolEntry readEntryOrNull(int pos) {\n+        int index = readU2(pos);\n+        if (index == 0) {\n+            return null;\n+        }\n+        return entryByIndex(index);\n+    }\n+\n+    @Override\n+    public Utf8Entry readUtf8Entry(int pos) {\n+        int index = readU2(pos);\n+        return utf8EntryByIndex(index);\n+    }\n+\n+    @Override\n+    public Utf8Entry readUtf8EntryOrNull(int pos) {\n+        int index = readU2(pos);\n+        if (index == 0) {\n+            return null;\n+        }\n+        return utf8EntryByIndex(index);\n+    }\n+\n+    @Override\n+    public ModuleEntry readModuleEntry(int pos) {\n+        return (ModuleEntry) readEntry(pos);\n+    }\n+\n+    @Override\n+    public PackageEntry readPackageEntry(int pos) {\n+        return (PackageEntry) readEntry(pos);\n+    }\n+\n+    @Override\n+    public ClassEntry readClassEntry(int pos) {\n+        return (ClassEntry) readEntry(pos);\n+    }\n+\n+    @Override\n+    public NameAndTypeEntry readNameAndTypeEntry(int pos) {\n+        return (NameAndTypeEntry) readEntry(pos);\n+    }\n+\n+    @Override\n+    public MethodHandleEntry readMethodHandleEntry(int pos) {\n+        return (MethodHandleEntry) readEntry(pos);\n+    }\n+\n+    @Override\n+    public boolean compare(BufWriter bufWriter,\n+                           int bufWriterOffset,\n+                           int classReaderOffset,\n+                           int length) {\n+        return Arrays.equals(((BufWriterImpl) bufWriter).elems,\n+                             bufWriterOffset, bufWriterOffset + length,\n+                             buffer, classReaderOffset, classReaderOffset + length);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.ClassfileVersion;\n+\n+\/**\n+ * ClassfileVersionImpl\n+ *\/\n+public final class ClassfileVersionImpl\n+        extends AbstractElement\n+        implements ClassfileVersion {\n+    private final int majorVersion, minorVersion;\n+\n+    public ClassfileVersionImpl(int majorVersion, int minorVersion) {\n+        this.majorVersion = majorVersion;\n+        this.minorVersion = minorVersion;\n+    }\n+\n+    @Override\n+    public int majorVersion() {\n+        return majorVersion;\n+    }\n+\n+    @Override\n+    public int minorVersion() {\n+        return minorVersion;\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        builder.setVersion(majorVersion, minorVersion);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassfileVersion[majorVersion=%d, minorVersion=%d]\", majorVersion, minorVersion);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassfileVersionImpl.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,503 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+\n+import static jdk.internal.classfile.Classfile.ALOAD;\n+import static jdk.internal.classfile.Classfile.ANEWARRAY;\n+import static jdk.internal.classfile.Classfile.ASTORE;\n+import static jdk.internal.classfile.Classfile.BIPUSH;\n+import static jdk.internal.classfile.Classfile.CHECKCAST;\n+import static jdk.internal.classfile.Classfile.DLOAD;\n+import static jdk.internal.classfile.Classfile.DSTORE;\n+import static jdk.internal.classfile.Classfile.FLOAD;\n+import static jdk.internal.classfile.Classfile.FSTORE;\n+import static jdk.internal.classfile.Classfile.GETFIELD;\n+import static jdk.internal.classfile.Classfile.GETSTATIC;\n+import static jdk.internal.classfile.Classfile.GOTO;\n+import static jdk.internal.classfile.Classfile.GOTO_W;\n+import static jdk.internal.classfile.Classfile.IFEQ;\n+import static jdk.internal.classfile.Classfile.IFGE;\n+import static jdk.internal.classfile.Classfile.IFGT;\n+import static jdk.internal.classfile.Classfile.IFLE;\n+import static jdk.internal.classfile.Classfile.IFLT;\n+import static jdk.internal.classfile.Classfile.IFNE;\n+import static jdk.internal.classfile.Classfile.IFNONNULL;\n+import static jdk.internal.classfile.Classfile.IFNULL;\n+import static jdk.internal.classfile.Classfile.IF_ACMPEQ;\n+import static jdk.internal.classfile.Classfile.IF_ACMPNE;\n+import static jdk.internal.classfile.Classfile.IF_ICMPEQ;\n+import static jdk.internal.classfile.Classfile.IF_ICMPGE;\n+import static jdk.internal.classfile.Classfile.IF_ICMPGT;\n+import static jdk.internal.classfile.Classfile.IF_ICMPLE;\n+import static jdk.internal.classfile.Classfile.IF_ICMPLT;\n+import static jdk.internal.classfile.Classfile.IF_ICMPNE;\n+import static jdk.internal.classfile.Classfile.IINC;\n+import static jdk.internal.classfile.Classfile.ILOAD;\n+import static jdk.internal.classfile.Classfile.INSTANCEOF;\n+import static jdk.internal.classfile.Classfile.INVOKEDYNAMIC;\n+import static jdk.internal.classfile.Classfile.INVOKEINTERFACE;\n+import static jdk.internal.classfile.Classfile.INVOKESPECIAL;\n+import static jdk.internal.classfile.Classfile.INVOKESTATIC;\n+import static jdk.internal.classfile.Classfile.INVOKEVIRTUAL;\n+import static jdk.internal.classfile.Classfile.ISTORE;\n+import static jdk.internal.classfile.Classfile.JSR;\n+import static jdk.internal.classfile.Classfile.JSR_W;\n+import static jdk.internal.classfile.Classfile.LDC;\n+import static jdk.internal.classfile.Classfile.LDC2_W;\n+import static jdk.internal.classfile.Classfile.LDC_W;\n+import static jdk.internal.classfile.Classfile.LLOAD;\n+import static jdk.internal.classfile.Classfile.LOOKUPSWITCH;\n+import static jdk.internal.classfile.Classfile.LSTORE;\n+import static jdk.internal.classfile.Classfile.MULTIANEWARRAY;\n+import static jdk.internal.classfile.Classfile.NEW;\n+import static jdk.internal.classfile.Classfile.NEWARRAY;\n+import static jdk.internal.classfile.Classfile.PUTFIELD;\n+import static jdk.internal.classfile.Classfile.PUTSTATIC;\n+import static jdk.internal.classfile.Classfile.RET;\n+import static jdk.internal.classfile.Classfile.SIPUSH;\n+import static jdk.internal.classfile.Classfile.TABLESWITCH;\n+import static jdk.internal.classfile.Classfile.WIDE;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+\n+\/**\n+ * CodeAttr\n+ *\/\n+public final class CodeImpl\n+        extends BoundAttribute.BoundCodeAttribute\n+        implements CodeModel, LabelContext {\n+    List<ExceptionCatch> exceptionTable;\n+    List<Attribute<?>> attributes;\n+\n+    \/\/ Inflated for iteration\n+    LabelImpl[] labels;\n+    int[] lineNumbers;\n+    boolean inflated;\n+\n+    public CodeImpl(AttributedElement enclosing,\n+                    ClassReader reader,\n+                    AttributeMapper<CodeAttribute> mapper,\n+                    int payloadStart) {\n+        super(enclosing, reader, mapper, payloadStart);\n+    }\n+\n+    \/\/ LabelContext\n+\n+    @Override\n+    public Label newLabel() {\n+        throw new UnsupportedOperationException(\"CodeAttribute only supports fixed labels\");\n+    }\n+\n+    @Override\n+    public void setLabelTarget(Label label, int bci) {\n+        throw new UnsupportedOperationException(\"CodeAttribute only supports fixed labels\");\n+    }\n+\n+    @Override\n+    public Label getLabel(int bci) {\n+        if (labels == null)\n+            labels = new LabelImpl[codeLength + 1];\n+        LabelImpl l = labels[bci];\n+        if (l == null)\n+            l = labels[bci] = new LabelImpl(this, bci);\n+        return l;\n+    }\n+\n+    @Override\n+    public int labelToBci(Label label) {\n+        LabelImpl lab = (LabelImpl) label;\n+        if (lab.labelContext() != this)\n+            throw new IllegalArgumentException(String.format(\"Illegal label reuse; context=%s, label=%s\",\n+                                                             this, lab.labelContext()));\n+        return lab.getContextInfo();\n+    }\n+\n+    private void inflateMetadata() {\n+        if (!inflated) {\n+            if (labels == null)\n+                labels = new LabelImpl[codeLength + 1];\n+            if (((ClassReaderImpl)classReader).options().processLineNumbers)\n+                inflateLineNumbers();\n+            inflateJumpTargets();\n+            inflateTypeAnnotations();\n+            inflated = true;\n+        }\n+    }\n+\n+    \/\/ CodeAttribute\n+\n+    @Override\n+    public List<Attribute<?>> attributes() {\n+        if (attributes == null) {\n+            attributes = BoundAttribute.readAttributes(this, classReader, attributePos, classReader.customAttributes());\n+        }\n+        return attributes;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter buf) {\n+        if (buf.canWriteDirect(classReader)) {\n+            super.writeTo(buf);\n+        }\n+        else {\n+            DirectCodeBuilder.build((MethodInfo) enclosingMethod,\n+                                    new Consumer<CodeBuilder>() {\n+                                        @Override\n+                                        public void accept(CodeBuilder cb) {\n+                                            forEachElement(cb);\n+                                        }\n+                                    },\n+                                    (SplitConstantPool)buf.constantPool(),\n+                                    null).writeTo(buf);\n+        }\n+    }\n+\n+    \/\/ CodeModel\n+\n+    @Override\n+    public Optional<MethodModel> parent() {\n+        return Optional.of(enclosingMethod);\n+    }\n+\n+    @Override\n+    public void forEachElement(Consumer<CodeElement> consumer) {\n+        inflateMetadata();\n+        boolean doLineNumbers = (lineNumbers != null);\n+        generateCatchTargets(consumer);\n+        if (((ClassReaderImpl)classReader).options().processDebug)\n+            generateDebugElements(consumer);\n+        for (int pos=codeStart; pos<codeEnd; ) {\n+            if (labels[pos - codeStart] != null)\n+                consumer.accept(labels[pos - codeStart]);\n+            if (doLineNumbers && lineNumbers[pos - codeStart] != 0)\n+                consumer.accept(LineNumberImpl.of(lineNumbers[pos - codeStart]));\n+            int bc = classReader.readU1(pos);\n+            Instruction instr = bcToInstruction(bc, pos);\n+            consumer.accept(instr);\n+            pos += instr.sizeInBytes();\n+        }\n+        \/\/ There might be labels pointing to the bci at codeEnd\n+        if (labels[codeEnd-codeStart] != null)\n+            consumer.accept(labels[codeEnd - codeStart]);\n+        if (doLineNumbers && lineNumbers[codeEnd - codeStart] != 0)\n+            consumer.accept(LineNumberImpl.of(lineNumbers[codeEnd - codeStart]));\n+    }\n+\n+    @Override\n+    public List<ExceptionCatch> exceptionHandlers() {\n+        if (exceptionTable == null) {\n+            inflateMetadata();\n+            exceptionTable = new ArrayList<>(exceptionHandlerCnt);\n+            iterateExceptionHandlers(new ExceptionHandlerAction() {\n+                @Override\n+                public void accept(int s, int e, int h, int c) {\n+                    ClassEntry catchTypeEntry = c == 0\n+                                                             ? null\n+                                                             : (ClassEntry) constantPool().entryByIndex(c);\n+                    exceptionTable.add(new AbstractPseudoInstruction.ExceptionCatchImpl(getLabel(h), getLabel(s), getLabel(e), catchTypeEntry));\n+                }\n+            });\n+            exceptionTable = Collections.unmodifiableList(exceptionTable);\n+        }\n+        return exceptionTable;\n+    }\n+\n+    public boolean compareCodeBytes(BufWriter buf, int offset, int len) {\n+        return codeLength == len\n+               && classReader.compare(buf, offset, codeStart, codeLength);\n+    }\n+\n+    private int adjustForObjectOrUninitialized(int bci) {\n+        int vt = classReader.readU1(bci);\n+        \/\/inflate newTarget labels from Uninitialized VTIs\n+        if (vt == 8) inflateLabel(classReader.readU2(bci + 1));\n+        return (vt == 7 || vt == 8) ? bci + 3 : bci + 1;\n+    }\n+\n+    private void inflateLabel(int bci) {\n+        if (labels[bci] == null)\n+            labels[bci] = new LabelImpl(this, bci);\n+    }\n+\n+    private void inflateLineNumbers() {\n+        for (Attribute<?> a : attributes()) {\n+            if (a.attributeMapper() == Attributes.LINE_NUMBER_TABLE) {\n+                BoundLineNumberTableAttribute attr = (BoundLineNumberTableAttribute) a;\n+                if (lineNumbers == null)\n+                    lineNumbers = new int[codeLength + 1];\n+\n+                int nLn = classReader.readU2(attr.payloadStart);\n+                int p = attr.payloadStart + 2;\n+                int pEnd = p + (nLn * 4);\n+                for (; p < pEnd; p += 4) {\n+                    int startPc = classReader.readU2(p);\n+                    int lineNumber = classReader.readU2(p + 2);\n+                    lineNumbers[startPc] = lineNumber;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void inflateJumpTargets() {\n+        Optional<StackMapTableAttribute> a = findAttribute(Attributes.STACK_MAP_TABLE);\n+        if (a.isEmpty())\n+            return;\n+        @SuppressWarnings(\"unchecked\")\n+        int stackMapPos = ((BoundAttribute<StackMapTableAttribute>) a.get()).payloadStart;\n+\n+        int bci = -1; \/\/compensate for offsetDelta + 1\n+        int nEntries = classReader.readU2(stackMapPos);\n+        int p = stackMapPos + 2;\n+        for (int i = 0; i < nEntries; ++i) {\n+            int frameType = classReader.readU1(p);\n+            int offsetDelta;\n+            if (frameType < 64) {\n+                offsetDelta = frameType;\n+                ++p;\n+            }\n+            else if (frameType < 128) {\n+                offsetDelta = frameType & 0x3f;\n+                p = adjustForObjectOrUninitialized(p + 1);\n+            }\n+            else\n+                switch (frameType) {\n+                    case 247 -> {\n+                        offsetDelta = classReader.readU2(p + 1);\n+                        p = adjustForObjectOrUninitialized(p + 3);\n+                    }\n+                    case 248, 249, 250, 251 -> {\n+                        offsetDelta = classReader.readU2(p + 1);\n+                        p += 3;\n+                    }\n+                    case 252, 253, 254 -> {\n+                        offsetDelta = classReader.readU2(p + 1);\n+                        int k = frameType - 251;\n+                        p += 3;\n+                        for (int c = 0; c < k; ++c) {\n+                            p = adjustForObjectOrUninitialized(p);\n+                        }\n+                    }\n+                    case 255 -> {\n+                        offsetDelta = classReader.readU2(p + 1);\n+                        p += 3;\n+                        int k = classReader.readU2(p);\n+                        p += 2;\n+                        for (int c = 0; c < k; ++c) {\n+                            p = adjustForObjectOrUninitialized(p);\n+                        }\n+                        k = classReader.readU2(p);\n+                        p += 2;\n+                        for (int c = 0; c < k; ++c) {\n+                            p = adjustForObjectOrUninitialized(p);\n+                        }\n+                    }\n+                    default -> throw new IllegalArgumentException(\"Bad frame type: \" + frameType);\n+                }\n+            bci += offsetDelta + 1;\n+            inflateLabel(bci);\n+        }\n+    }\n+\n+    private void inflateTypeAnnotations() {\n+        findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS).ifPresent(RuntimeVisibleTypeAnnotationsAttribute::annotations);\n+        findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS).ifPresent(RuntimeInvisibleTypeAnnotationsAttribute::annotations);\n+    }\n+\n+    private void generateCatchTargets(Consumer<CodeElement> consumer) {\n+        \/\/ We attach all catch targets to bci zero, because trying to attach them\n+        \/\/ to their range could subtly affect the order of exception processing\n+        iterateExceptionHandlers(new ExceptionHandlerAction() {\n+            @Override\n+            public void accept(int s, int e, int h, int c) {\n+                ClassEntry catchType = c == 0\n+                                                    ? null\n+                                                    : (ClassEntry) classReader.entryByIndex(c);\n+                consumer.accept(new AbstractPseudoInstruction.ExceptionCatchImpl(getLabel(h), getLabel(s), getLabel(e), catchType));\n+            }\n+        });\n+    }\n+\n+    private void generateDebugElements(Consumer<CodeElement> consumer) {\n+        for (Attribute<?> a : attributes()) {\n+            if (a.attributeMapper() == Attributes.CHARACTER_RANGE_TABLE) {\n+                var attr = (BoundCharacterRangeTableAttribute) a;\n+                int cnt = classReader.readU2(attr.payloadStart);\n+                int p = attr.payloadStart + 2;\n+                int pEnd = p + (cnt * 14);\n+                for (; p < pEnd; p += 14) {\n+                    var instruction = new BoundCharacterRange(this, p);\n+                    inflateLabel(instruction.startPc());\n+                    inflateLabel(instruction.endPc() + 1);\n+                    consumer.accept(instruction);\n+                }\n+            }\n+            else if (a.attributeMapper() == Attributes.LOCAL_VARIABLE_TABLE) {\n+                var attr = (BoundLocalVariableTableAttribute) a;\n+                int cnt = classReader.readU2(attr.payloadStart);\n+                int p = attr.payloadStart + 2;\n+                int pEnd = p + (cnt * 10);\n+                for (; p < pEnd; p += 10) {\n+                    BoundLocalVariable instruction = new BoundLocalVariable(this, p);\n+                    inflateLabel(instruction.startPc());\n+                    inflateLabel(instruction.startPc() + instruction.length());\n+                    consumer.accept(instruction);\n+                }\n+            }\n+            else if (a.attributeMapper() == Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                var attr = (BoundLocalVariableTypeTableAttribute) a;\n+                int cnt = classReader.readU2(attr.payloadStart);\n+                int p = attr.payloadStart + 2;\n+                int pEnd = p + (cnt * 10);\n+                for (; p < pEnd; p += 10) {\n+                    BoundLocalVariableType instruction = new BoundLocalVariableType(this, p);\n+                    inflateLabel(instruction.startPc());\n+                    inflateLabel(instruction.startPc() + instruction.length());\n+                    consumer.accept(instruction);\n+                }\n+            }\n+            else if (a.attributeMapper() == Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS) {\n+                consumer.accept((BoundRuntimeVisibleTypeAnnotationsAttribute) a);\n+            }\n+            else if (a.attributeMapper() == Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS) {\n+                consumer.accept((BoundRuntimeInvisibleTypeAnnotationsAttribute) a);\n+            }\n+        }\n+    }\n+\n+    public interface ExceptionHandlerAction {\n+        void accept(int start, int end, int handler, int catchTypeIndex);\n+    }\n+\n+    public void iterateExceptionHandlers(ExceptionHandlerAction a) {\n+        int p = exceptionHandlerPos + 2;\n+        for (int i = 0; i < exceptionHandlerCnt; ++i) {\n+            a.accept(classReader.readU2(p), classReader.readU2(p + 2), classReader.readU2(p + 4), classReader.readU2(p + 6));\n+            p += 8;\n+        }\n+    }\n+\n+    private Instruction bcToInstruction(int bc, int pos) {\n+        return switch (bc) {\n+            case BIPUSH -> new AbstractInstruction.BoundArgumentConstantInstruction(Opcode.BIPUSH, CodeImpl.this, pos);\n+            case SIPUSH -> new AbstractInstruction.BoundArgumentConstantInstruction(Opcode.SIPUSH, CodeImpl.this, pos);\n+            case LDC -> new AbstractInstruction.BoundLoadConstantInstruction(Opcode.LDC, CodeImpl.this, pos);\n+            case LDC_W -> new AbstractInstruction.BoundLoadConstantInstruction(Opcode.LDC_W, CodeImpl.this, pos);\n+            case LDC2_W -> new AbstractInstruction.BoundLoadConstantInstruction(Opcode.LDC2_W, CodeImpl.this, pos);\n+            case ILOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.ILOAD, CodeImpl.this, pos);\n+            case LLOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.LLOAD, CodeImpl.this, pos);\n+            case FLOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.FLOAD, CodeImpl.this, pos);\n+            case DLOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.DLOAD, CodeImpl.this, pos);\n+            case ALOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.ALOAD, CodeImpl.this, pos);\n+            case ISTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.ISTORE, CodeImpl.this, pos);\n+            case LSTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.LSTORE, CodeImpl.this, pos);\n+            case FSTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.FSTORE, CodeImpl.this, pos);\n+            case DSTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.DSTORE, CodeImpl.this, pos);\n+            case ASTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.ASTORE, CodeImpl.this, pos);\n+            case IINC -> new AbstractInstruction.BoundIncrementInstruction(Opcode.IINC, CodeImpl.this, pos);\n+            case IFEQ -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFEQ, CodeImpl.this, pos);\n+            case IFNE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFNE, CodeImpl.this, pos);\n+            case IFLT -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFLT, CodeImpl.this, pos);\n+            case IFGE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFGE, CodeImpl.this, pos);\n+            case IFGT -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFGT, CodeImpl.this, pos);\n+            case IFLE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFLE, CodeImpl.this, pos);\n+            case IF_ICMPEQ -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ICMPEQ, CodeImpl.this, pos);\n+            case IF_ICMPNE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ICMPNE, CodeImpl.this, pos);\n+            case IF_ICMPLT -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ICMPLT, CodeImpl.this, pos);\n+            case IF_ICMPGE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ICMPGE, CodeImpl.this, pos);\n+            case IF_ICMPGT -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ICMPGT, CodeImpl.this, pos);\n+            case IF_ICMPLE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ICMPLE, CodeImpl.this, pos);\n+            case IF_ACMPEQ -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ACMPEQ, CodeImpl.this, pos);\n+            case IF_ACMPNE -> new AbstractInstruction.BoundBranchInstruction(Opcode.IF_ACMPNE, CodeImpl.this, pos);\n+            case GOTO -> new AbstractInstruction.BoundBranchInstruction(Opcode.GOTO, CodeImpl.this, pos);\n+            case TABLESWITCH -> new AbstractInstruction.BoundTableSwitchInstruction(Opcode.TABLESWITCH, CodeImpl.this, pos);\n+            case LOOKUPSWITCH -> new AbstractInstruction.BoundLookupSwitchInstruction(Opcode.LOOKUPSWITCH, CodeImpl.this, pos);\n+            case GETSTATIC -> new AbstractInstruction.BoundFieldInstruction(Opcode.GETSTATIC, CodeImpl.this, pos);\n+            case PUTSTATIC -> new AbstractInstruction.BoundFieldInstruction(Opcode.PUTSTATIC, CodeImpl.this, pos);\n+            case GETFIELD -> new AbstractInstruction.BoundFieldInstruction(Opcode.GETFIELD, CodeImpl.this, pos);\n+            case PUTFIELD -> new AbstractInstruction.BoundFieldInstruction(Opcode.PUTFIELD, CodeImpl.this, pos);\n+            case INVOKEVIRTUAL -> new AbstractInstruction.BoundInvokeInstruction(Opcode.INVOKEVIRTUAL, CodeImpl.this, pos);\n+            case INVOKESPECIAL -> new AbstractInstruction.BoundInvokeInstruction(Opcode.INVOKESPECIAL, CodeImpl.this, pos);\n+            case INVOKESTATIC -> new AbstractInstruction.BoundInvokeInstruction(Opcode.INVOKESTATIC, CodeImpl.this, pos);\n+            case INVOKEINTERFACE -> new AbstractInstruction.BoundInvokeInterfaceInstruction(Opcode.INVOKEINTERFACE, CodeImpl.this, pos);\n+            case INVOKEDYNAMIC -> new AbstractInstruction.BoundInvokeDynamicInstruction(Opcode.INVOKEDYNAMIC, CodeImpl.this, pos);\n+            case NEW -> new AbstractInstruction.BoundNewObjectInstruction(CodeImpl.this, pos);\n+            case NEWARRAY -> new AbstractInstruction.BoundNewPrimitiveArrayInstruction(Opcode.NEWARRAY, CodeImpl.this, pos);\n+            case ANEWARRAY -> new AbstractInstruction.BoundNewReferenceArrayInstruction(Opcode.ANEWARRAY, CodeImpl.this, pos);\n+            case CHECKCAST -> new AbstractInstruction.BoundTypeCheckInstruction(Opcode.CHECKCAST, CodeImpl.this, pos);\n+            case INSTANCEOF -> new AbstractInstruction.BoundTypeCheckInstruction(Opcode.INSTANCEOF, CodeImpl.this, pos);\n+\n+            case WIDE -> {\n+                int bclow = classReader.readU1(pos + 1);\n+                yield switch (bclow) {\n+                    case ILOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.ILOAD_W, this, pos);\n+                    case LLOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.LLOAD_W, this, pos);\n+                    case FLOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.FLOAD_W, this, pos);\n+                    case DLOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.DLOAD_W, this, pos);\n+                    case ALOAD -> new AbstractInstruction.BoundLoadInstruction(Opcode.ALOAD_W, this, pos);\n+                    case ISTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.ISTORE_W, this, pos);\n+                    case LSTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.LSTORE_W, this, pos);\n+                    case FSTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.FSTORE_W, this, pos);\n+                    case DSTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.DSTORE_W, this, pos);\n+                    case ASTORE -> new AbstractInstruction.BoundStoreInstruction(Opcode.ASTORE_W, this, pos);\n+                    case IINC -> new AbstractInstruction.BoundIncrementInstruction(Opcode.IINC_W, this, pos);\n+                    case RET -> throw new UnsupportedOperationException(\"RET_W instruction not supported\");\n+                    default -> throw new UnsupportedOperationException(\"unknown wide instruction: \" + bclow);\n+                };\n+            }\n+\n+            case MULTIANEWARRAY -> new AbstractInstruction.BoundNewMultidimensionalArrayInstruction(Opcode.MULTIANEWARRAY, CodeImpl.this, pos);\n+            case IFNULL -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFNULL, CodeImpl.this, pos);\n+            case IFNONNULL -> new AbstractInstruction.BoundBranchInstruction(Opcode.IFNONNULL, CodeImpl.this, pos);\n+            case GOTO_W -> new AbstractInstruction.BoundBranchInstruction(Opcode.GOTO_W, CodeImpl.this, pos);\n+\n+            case JSR -> throw new UnsupportedOperationException(\"JSR instruction not supported\");\n+            case RET -> throw new UnsupportedOperationException(\"RET instruction not supported\");\n+            case JSR_W -> throw new UnsupportedOperationException(\"JSR_W instruction not supported\");\n+            default -> {\n+                Instruction instr = InstructionData.singletonInstructions[bc];\n+                if (instr == null)\n+                    throw new UnsupportedOperationException(\"unknown instruction: \" + bc);\n+                yield instr;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CodeModel[id=%d]\", System.identityHashCode(this));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":503,"deletions":0,"binary":false,"changes":503,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+\n+import static jdk.internal.classfile.impl.ConcreteEntry.ConcreteMethodHandleEntry;\n+\n+public final class ConcreteBootstrapMethodEntry implements BootstrapMethodEntry {\n+\n+    final int index;\n+    final int hash;\n+    private final ConstantPool constantPool;\n+    private final ConcreteMethodHandleEntry handle;\n+    private final List<LoadableConstantEntry> arguments;\n+\n+    ConcreteBootstrapMethodEntry(ConstantPool constantPool, int bsmIndex, int hash,\n+                                 ConcreteMethodHandleEntry handle,\n+                                 List<LoadableConstantEntry> arguments) {\n+        this.index = bsmIndex;\n+        this.hash = hash;\n+        this.constantPool = constantPool;\n+        this.handle = handle;\n+        this.arguments = List.copyOf(arguments);\n+    }\n+\n+    @Override\n+    public ConstantPool constantPool() {\n+        return constantPool;\n+    }\n+\n+    @Override\n+    public MethodHandleEntry bootstrapMethod() {\n+        return handle;\n+    }\n+\n+    @Override\n+    public List<LoadableConstantEntry> arguments() {\n+        return arguments;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BootstrapMethodEntry e\n+            && e.bootstrapMethod() == handle\n+            && e.arguments().size() == arguments.size()) {\n+                for (int i = 0; i < arguments.size(); ++i) {\n+                    if (e.arguments().get(i) != arguments.get(i)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        else\n+            return false;\n+    }\n+\n+    static int computeHashCode(ConcreteMethodHandleEntry handle,\n+                               List<? extends LoadableConstantEntry> arguments) {\n+        int hash = handle.hashCode();\n+        for (LoadableConstantEntry a : arguments) {\n+            hash = 31 * hash + a.hashCode();\n+        }\n+        return ConcreteEntry.phiMix(hash);\n+    }\n+\n+    @Override\n+    public int bsmIndex() { return index; }\n+\n+    @Override\n+    public int hashCode() {\n+        return hash;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter writer) {\n+        writer.writeIndex(bootstrapMethod());\n+        writer.writeListIndices(arguments());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ConcreteBootstrapMethodEntry.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,1172 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.FloatEntry;\n+import jdk.internal.classfile.constantpool.IntegerEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.MethodTypeEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+\n+public abstract sealed class ConcreteEntry {\n+    \/*\n+    Invariant: a {CP,BSM} entry for pool P refer only to {CP,BSM} entries\n+    from P or P's parent.  This is enforced by the various xxxEntry methods\n+    in SplitConstantPool.  As a result, code in this file can use writeU2\n+    instead of writeIndex.\n+\n+    Cloning of entries may be a no-op if the entry is already on the right pool\n+    (which implies that the referenced entries will also be on the right pool.)\n+     *\/\n+\n+    private static final int TAG_SMEAR = 0x13C4B2D1;\n+    private static final int INT_PHI = 0x9E3779B9;\n+\n+    public static int hash1(int tag, int x1) {\n+        return phiMix(tag * TAG_SMEAR + x1);\n+    }\n+\n+    public static int hash2(int tag, int x1, int x2) {\n+        return phiMix(tag * TAG_SMEAR + x1 + 31*x2);\n+    }\n+\n+    \/\/ Ensure that hash is never zero\n+    public static int hashString(int stringHash) {\n+        return phiMix(stringHash | (1 << 30));\n+    }\n+\n+    public static int phiMix(int x) {\n+        int h = x * INT_PHI;\n+        return h ^ (h >> 16);\n+    }\n+\n+    public static Utf8Entry rawUtf8EntryFromStandardAttributeName(String name) {\n+        \/\/assuming standard attribute names are all US_ASCII\n+        var raw = name.getBytes(StandardCharsets.US_ASCII);\n+        return new ConcreteUtf8Entry(null, 0, raw, 0, raw.length);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends PoolEntry> T maybeClone(ConstantPoolBuilder cp, T entry) {\n+        return (T)((ConcreteEntry)entry).clone(cp);\n+    }\n+\n+    final ConstantPool constantPool;\n+    public final byte tag;\n+    private final int index;\n+    private final int hash;\n+\n+    private ConcreteEntry(ConstantPool constantPool, int tag, int index, int hash) {\n+        this.tag = (byte) tag;\n+        this.index = index;\n+        this.hash = hash;\n+        this.constantPool = constantPool;\n+    }\n+\n+    public ConstantPool constantPool() { return constantPool; }\n+\n+    public int index() { return index; }\n+\n+    public int hashCode() {\n+        return hash;\n+    }\n+\n+    public byte tag() {\n+        return tag;\n+    }\n+\n+    public int width() {\n+        return (tag == Classfile.TAG_LONG || tag == Classfile.TAG_DOUBLE) ? 2 : 1;\n+    }\n+\n+    abstract PoolEntry clone(ConstantPoolBuilder cp);\n+\n+    public static final class ConcreteUtf8Entry extends ConcreteEntry implements Utf8Entry {\n+        \/\/ Processing UTF8 from the constant pool is one of the more expensive\n+        \/\/ operations, and often, we don't actually need access to the constant\n+        \/\/ as a string.  So there are multiple layers of laziness in UTF8\n+        \/\/ constants.  In the first stage, all we do is record the range of\n+        \/\/ bytes in the classfile.  If the size or hashCode is needed, then we\n+        \/\/ process the raw bytes into a byte[] or char[], but do not inflate\n+        \/\/ a String.  If a string is needed, it too is inflated lazily.\n+        \/\/ If we construct a Utf8Entry from a string, we generate the encoding\n+        \/\/ at write time.\n+\n+        enum State { RAW, BYTE, CHAR, STRING }\n+\n+        private State state;\n+        private final byte[] rawBytes; \/\/ null if initialized directly from a string\n+        private final int offset;\n+        private final int rawLen;\n+        \/\/ Set in any state other than RAW\n+        private int hash;\n+        private int charLen;\n+        \/\/ Set in CHAR state\n+        private char[] chars;\n+        \/\/ Only set in STRING state\n+        private String stringValue;\n+\n+        ConcreteUtf8Entry(ConstantPool cpm, int index,\n+                          byte[] rawBytes, int offset, int rawLen) {\n+            super(cpm, Classfile.TAG_UTF8, index, 0);\n+            this.rawBytes = rawBytes;\n+            this.offset = offset;\n+            this.rawLen = rawLen;\n+            this.state = State.RAW;\n+        }\n+\n+        ConcreteUtf8Entry(ConstantPool cpm, int index, String s) {\n+            super(cpm, Classfile.TAG_UTF8, index, 0);\n+            this.rawBytes = null;\n+            this.offset = 0;\n+            this.rawLen = 0;\n+            this.state = State.STRING;\n+            this.stringValue = s;\n+            this.charLen = s.length();\n+            this.hash = hashString(s.hashCode());\n+        }\n+\n+        ConcreteUtf8Entry(ConstantPool cpm, int index, ConcreteUtf8Entry u) {\n+            super(cpm, Classfile.TAG_UTF8, index, 0);\n+            this.rawBytes = u.rawBytes;\n+            this.offset = u.offset;\n+            this.rawLen = u.rawLen;\n+            this.state = u.state;\n+            this.hash = u.hash;\n+            this.charLen = u.charLen;\n+            this.chars = u.chars;\n+            this.stringValue = u.stringValue;\n+        }\n+\n+        \/**\n+         * {@jvms 4.4.7} String content is encoded in modified UTF-8.\n+         *\n+         * Modified UTF-8 strings are encoded so that code point sequences that\n+         * contain only non-null ASCII characters can be represented using only 1\n+         * byte per code point, but all code points in the Unicode codespace can be\n+         * represented.\n+         *\n+         * Modified UTF-8 strings are not null-terminated.\n+         *\n+         * Code points in the range '\\u0001' to '\\u007F' are represented by a single\n+         * byte.\n+         *\n+         * The null code point ('\\u0000') and code points in the range '\\u0080' to\n+         * '\\u07FF' are represented by a pair of bytes.\n+         *\n+         * Code points in the range '\\u0800' to '\\uFFFF' are represented by 3 bytes.\n+         *\n+         * Characters with code points above U+FFFF (so-called supplementary\n+         * characters) are represented by separately encoding the two surrogate code\n+         * units of their UTF-16 representation. Each of the surrogate code units is\n+         * represented by three bytes. This means supplementary characters are\n+         * represented by six bytes.\n+         *\n+         * The bytes of multibyte characters are stored in the class file in\n+         * big-endian (high byte first) order.\n+         *\n+         * There are two differences between this format and the \"standard\" UTF-8\n+         * format. First, the null character (char)0 is encoded using the 2-byte\n+         * format rather than the 1-byte format, so that modified UTF-8 strings\n+         * never have embedded nulls. Second, only the 1-byte, 2-byte, and 3-byte\n+         * formats of standard UTF-8 are used. The Java Virtual Machine does not\n+         * recognize the four-byte format of standard UTF-8; it uses its own\n+         * two-times-three-byte format instead.\n+         *\/\n+        private void inflate() {\n+            int hash = 0;\n+            boolean foundHigh = false;\n+\n+            int px = offset;\n+            int utfend = px + rawLen;\n+            while (px < utfend) {\n+                int c = (int) rawBytes[px] & 0xff;\n+                if (c > 127) {\n+                    foundHigh = true;\n+                    break;\n+                }\n+                hash = 31 * hash + c;\n+                px++;\n+            }\n+\n+            if (!foundHigh) {\n+                this.hash = hashString(hash);\n+                charLen = rawLen;\n+                state = State.BYTE;\n+            }\n+            else {\n+                char[] chararr = new char[rawLen];\n+                int chararr_count = 0;\n+                \/\/ Inflate prefix of bytes to characters\n+                for (int i = offset; i < px; i++) {\n+                    int c = (int) rawBytes[i] & 0xff;\n+                    chararr[chararr_count++] = (char) c;\n+                }\n+                while (px < utfend) {\n+                    int c = (int) rawBytes[px] & 0xff;\n+                    switch (c >> 4) {\n+                        case 0, 1, 2, 3, 4, 5, 6, 7: {\n+                            \/\/ 0xxx xxxx\n+                            px++;\n+                            chararr[chararr_count++] = (char) c;\n+                            hash = 31 * hash + c;\n+                            break;\n+                        }\n+                        case 12, 13: {\n+                            \/\/ 110x xxxx  10xx xxxx\n+                            px += 2;\n+                            if (px > utfend) {\n+                                throw new CpException(\"malformed input: partial character at end\");\n+                            }\n+                            int char2 = rawBytes[px - 1];\n+                            if ((char2 & 0xC0) != 0x80) {\n+                                throw new CpException(\"malformed input around byte \" + px);\n+                            }\n+                            char v = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));\n+                            chararr[chararr_count++] = v;\n+                            hash = 31 * hash + v;\n+                            break;\n+                        }\n+                        case 14: {\n+                            \/\/ 1110 xxxx  10xx xxxx  10xx xxxx\n+                            px += 3;\n+                            if (px > utfend) {\n+                                throw new CpException(\"malformed input: partial character at end\");\n+                            }\n+                            int char2 = rawBytes[px - 2];\n+                            int char3 = rawBytes[px - 1];\n+                            if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {\n+                                throw new CpException(\"malformed input around byte \" + (px - 1));\n+                            }\n+                            char v = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));\n+                            chararr[chararr_count++] = v;\n+                            hash = 31 * hash + v;\n+                            break;\n+                        }\n+                        default:\n+                            \/\/ 10xx xxxx,  1111 xxxx\n+                            throw new CpException(\"malformed input around byte \" + px);\n+                    }\n+                }\n+                this.hash = hashString(hash);\n+                charLen = chararr_count;\n+                this.chars = chararr;\n+                state = State.CHAR;\n+            }\n+\n+        }\n+\n+        @Override\n+        public ConcreteUtf8Entry clone(ConstantPoolBuilder cp) {\n+            if (cp.canWriteDirect(constantPool))\n+                return this;\n+            return (state == State.STRING && rawBytes == null)\n+                   ? (ConcreteUtf8Entry) cp.utf8Entry(stringValue)\n+                   : ((SplitConstantPool) cp).maybeCloneUtf8Entry(this);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (state == State.RAW)\n+                inflate();\n+            return hash;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (state == State.RAW)\n+                inflate();\n+            if (state != State.STRING) {\n+                stringValue = (chars != null)\n+                              ? new String(chars, 0, charLen)\n+                              : new String(rawBytes, offset, charLen, StandardCharsets.UTF_8);\n+                state = State.STRING;\n+            }\n+            return stringValue;\n+        }\n+\n+        @Override\n+        public String stringValue() {\n+            return toString();\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return stringValue();\n+        }\n+\n+        @Override\n+        public int length() {\n+            if (state == State.RAW)\n+                inflate();\n+            return charLen;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            if (state == State.STRING)\n+                return stringValue.charAt(index);\n+            if (state == State.RAW)\n+                inflate();\n+            return (chars != null)\n+                   ? chars[index]\n+                   : (char) rawBytes[index + offset];\n+        }\n+\n+        @Override\n+        public CharSequence subSequence(int start, int end) {\n+            return toString().subSequence(start, end);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ConcreteUtf8Entry u) {\n+                return equalsUtf8(u);\n+            } else if (o instanceof Utf8Entry u) {\n+                return equalsString(u.stringValue());\n+            }\n+            return false;\n+        }\n+\n+        public boolean equalsUtf8(ConcreteUtf8Entry u) {\n+            if (hashCode() != u.hashCode()\n+                || length() != u.length())\n+                return false;\n+            if (rawBytes != null && u.rawBytes != null)\n+                return Arrays.equals(rawBytes, offset, offset + rawLen,\n+                                     u.rawBytes, u.offset, u.offset + u.rawLen);\n+            else if ((state == State.STRING && u.state == State.STRING))\n+                return stringValue.equals(u.stringValue);\n+            else\n+                return stringValue().equals(u.stringValue());\n+        }\n+\n+        @Override\n+        public boolean equalsString(String s) {\n+            if (state == State.RAW)\n+                inflate();\n+            switch (state) {\n+                case STRING:\n+                    return stringValue.equals(s);\n+                case CHAR:\n+                    if (charLen != s.length() || hash != hashString(s.hashCode()))\n+                        return false;\n+                    for (int i=0; i<charLen; i++)\n+                        if (chars[i] != s.charAt(i))\n+                            return false;\n+                    stringValue = s;\n+                    state = State.STRING;\n+                    return true;\n+                case BYTE:\n+                    if (rawLen != s.length() || hash != hashString(s.hashCode()))\n+                        return false;\n+                    for (int i=0; i<rawLen; i++)\n+                        if (rawBytes[offset+i] != s.charAt(i))\n+                            return false;\n+                    stringValue = s;\n+                    state = State.STRING;\n+                    return true;\n+            }\n+            throw new IllegalStateException(\"cannot reach here\");\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            if (rawBytes != null) {\n+                pool.writeU1(tag);\n+                pool.writeU2(rawLen);\n+                pool.writeBytes(rawBytes, offset, rawLen);\n+            }\n+            else {\n+                \/\/ state == STRING and no raw bytes\n+                if (stringValue.length() > 65535) {\n+                    throw new IllegalArgumentException(\"string too long\");\n+                }\n+                pool.writeU1(tag);\n+                pool.writeU2(charLen);\n+                for (int i = 0; i < charLen; ++i) {\n+                    char c = stringValue.charAt(i);\n+                    if (c >= '\\001' && c <= '\\177') {\n+                        \/\/ Optimistic writing -- hope everything is bytes\n+                        \/\/ If not, we bail out, and alternate path patches the length\n+                        pool.writeU1((byte) c);\n+                    }\n+                    else {\n+                        int charLength = stringValue.length();\n+                        int byteLength = i;\n+                        char c1;\n+                        for (int j = i; j < charLength; ++j) {\n+                            c1 = (stringValue).charAt(j);\n+                            if (c1 >= '\\001' && c1 <= '\\177') {\n+                                byteLength++;\n+                            } else if (c1 > '\\u07FF') {\n+                                byteLength += 3;\n+                            } else {\n+                                byteLength += 2;\n+                            }\n+                        }\n+                        if (byteLength > 65535) {\n+                            throw new IllegalArgumentException();\n+                        }\n+                        int byteLengthFinal = byteLength;\n+                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n+                        for (int j = i; j < charLength; ++j) {\n+                            c1 = (stringValue).charAt(j);\n+                            if (c1 >= '\\001' && c1 <= '\\177') {\n+                                pool.writeU1((byte) c1);\n+                            } else if (c1 > '\\u07FF') {\n+                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n+                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n+                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n+                            } else {\n+                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n+                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static abstract sealed class RefEntry<T extends PoolEntry> extends ConcreteEntry {\n+        protected final T ref1;\n+\n+        public RefEntry(ConstantPool constantPool, int tag, int index, T ref1) {\n+            super(constantPool, tag, index, hash1(tag, ref1.index()));\n+            this.ref1 = ref1;\n+        }\n+\n+        public T ref1() {\n+            return ref1;\n+        }\n+\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU2(ref1.index());\n+        }\n+\n+        public String toString() {\n+            return tag() + \" \" + ref1();\n+        }\n+    }\n+\n+    static abstract sealed class RefsEntry<T extends PoolEntry, U extends PoolEntry>\n+            extends ConcreteEntry {\n+        protected final T ref1;\n+        protected final U ref2;\n+\n+        public RefsEntry(ConstantPool constantPool, int tag, int index, T ref1, U ref2) {\n+            super(constantPool, tag, index, hash2(tag, ref1.index(), ref2.index()));\n+            this.ref1 = ref1;\n+            this.ref2 = ref2;\n+        }\n+\n+        public T ref1() {\n+            return ref1;\n+        }\n+\n+        public U ref2() {\n+            return ref2;\n+        }\n+\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU2(ref1.index());\n+            pool.writeU2(ref2.index());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + ref1 + \"-\" + ref2;\n+        }\n+    }\n+\n+    static abstract sealed class NamedEntry extends RefEntry<ConcreteUtf8Entry> {\n+\n+        public NamedEntry(ConstantPool constantPool, int tag, int index, ConcreteUtf8Entry ref1) {\n+            super(constantPool, tag, index, ref1);\n+        }\n+\n+        public Utf8Entry name() {\n+            return ref1;\n+        }\n+\n+        public String asInternalName() {\n+            return ref1.stringValue();\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this) { return true; }\n+            if (o instanceof NamedEntry ne) {\n+                return tag == ne.tag() && name().equals(ref1());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteClassEntry extends NamedEntry implements ClassEntry {\n+\n+        ConcreteClassEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name) {\n+            super(cpm, Classfile.TAG_CLASS, index, name);\n+        }\n+\n+        @Override\n+        public ClassEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n+        }\n+\n+        @Override\n+        public ClassDesc asSymbol() {\n+            return Util.toClassDesc(asInternalName());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ConcreteClassEntry cce) {\n+                return cce.name().equals(this.name());\n+            } else if (o instanceof ClassEntry c) {\n+                return c.asSymbol().equals(this.asSymbol());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcretePackageEntry extends NamedEntry implements PackageEntry {\n+\n+        ConcretePackageEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name) {\n+            super(cpm, Classfile.TAG_PACKAGE, index, name);\n+        }\n+\n+        @Override\n+        public PackageEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.packageEntry(ref1);\n+        }\n+\n+        @Override\n+        public PackageDesc asSymbol() {\n+            return PackageDesc.ofInternalName(asInternalName());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof PackageEntry p) {\n+                return name().equals(p.name());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteModuleEntry extends NamedEntry implements ModuleEntry {\n+\n+        ConcreteModuleEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name) {\n+            super(cpm, Classfile.TAG_MODULE, index, name);\n+        }\n+\n+        @Override\n+        public ModuleEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.moduleEntry(ref1);\n+        }\n+\n+        @Override\n+        public ModuleDesc asSymbol() {\n+            return ModuleDesc.of(asInternalName());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ConcreteModuleEntry m) {\n+                return name().equals(m.name());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteNameAndTypeEntry extends RefsEntry<ConcreteUtf8Entry, ConcreteUtf8Entry>\n+            implements NameAndTypeEntry {\n+\n+        ConcreteNameAndTypeEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name, ConcreteUtf8Entry type) {\n+            super(cpm, Classfile.TAG_NAMEANDTYPE, index, name, type);\n+        }\n+\n+        @Override\n+        public Utf8Entry name() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public Utf8Entry type() {\n+            return ref2;\n+        }\n+\n+        @Override\n+        public NameAndTypeEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.natEntry(ref1, ref2);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ConcreteNameAndTypeEntry nat) {\n+                return name().equals(nat.name()) && type().equals(nat.type());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static abstract sealed class MemberRefEntry\n+            extends RefsEntry<ConcreteClassEntry, ConcreteNameAndTypeEntry>\n+            implements jdk.internal.classfile.constantpool.MemberRefEntry {\n+\n+        MemberRefEntry(ConstantPool cpm, int tag, int index, ConcreteClassEntry owner,\n+                       ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, tag, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public ConcreteClassEntry owner() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public ConcreteNameAndTypeEntry nameAndType() {\n+            return ref2;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + owner().asInternalName() + \".\" + nameAndType().name().stringValue()\n+                   + \"-\" + nameAndType().type().stringValue();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof MemberRefEntry m) {\n+                return tag == m.tag()\n+                && owner().equals(m.owner())\n+                && nameAndType().equals(m.nameAndType());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteFieldRefEntry extends MemberRefEntry implements FieldRefEntry {\n+\n+        ConcreteFieldRefEntry(ConstantPool cpm, int index,\n+                              ConcreteClassEntry owner, ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_FIELDREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public FieldRefEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.fieldRefEntry(ref1, ref2);\n+        }\n+    }\n+\n+    public static final class ConcreteMethodRefEntry extends MemberRefEntry implements MethodRefEntry {\n+\n+        ConcreteMethodRefEntry(ConstantPool cpm, int index,\n+                               ConcreteClassEntry owner, ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_METHODREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public MethodRefEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.methodRefEntry(ref1, ref2);\n+        }\n+    }\n+\n+    public static final class ConcreteInterfaceMethodRefEntry extends MemberRefEntry implements InterfaceMethodRefEntry {\n+\n+        ConcreteInterfaceMethodRefEntry(ConstantPool cpm, int index, ConcreteClassEntry owner,\n+                                        ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_INTERFACEMETHODREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public InterfaceMethodRefEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.interfaceMethodRefEntry(ref1, ref2);\n+        }\n+    }\n+\n+    public static abstract sealed class AbstractDynamicConstantPoolEntry extends ConcreteEntry {\n+\n+        private final int bsmIndex;\n+        private ConcreteBootstrapMethodEntry bootstrapMethod;\n+        private final ConcreteNameAndTypeEntry nameAndType;\n+\n+        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, ConcreteBootstrapMethodEntry bootstrapMethod,\n+                                         ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, tag, index, hash);\n+            this.bsmIndex = bootstrapMethod.bsmIndex();\n+            this.bootstrapMethod = bootstrapMethod;\n+            this.nameAndType = nameAndType;\n+        }\n+\n+        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, int bsmIndex,\n+                                         ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, tag, index, hash);\n+            this.bsmIndex = bsmIndex;\n+            this.bootstrapMethod = null;\n+            this.nameAndType = nameAndType;\n+        }\n+\n+        \/**\n+         * @return the bootstrapMethod\n+         *\/\n+        public ConcreteBootstrapMethodEntry bootstrap() {\n+            if (bootstrapMethod == null) {\n+                bootstrapMethod = (ConcreteBootstrapMethodEntry) constantPool.bootstrapMethodEntry(bsmIndex);\n+            }\n+            return bootstrapMethod;\n+        }\n+\n+        \/**\n+         * @return the nameAndType\n+         *\/\n+        public ConcreteNameAndTypeEntry nameAndType() {\n+            return nameAndType;\n+        }\n+\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU2(bsmIndex);\n+            pool.writeU2(nameAndType.index());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + bootstrap() + \".\" + nameAndType().name().stringValue()\n+                   + \"-\" + nameAndType().type().stringValue();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof AbstractDynamicConstantPoolEntry d) {\n+                return this.tag() == d.tag()\n+                && bootstrap().equals(d.bootstrap())\n+                && nameAndType.equals(d.nameAndType());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteInvokeDynamicEntry\n+            extends AbstractDynamicConstantPoolEntry\n+            implements InvokeDynamicEntry {\n+\n+        ConcreteInvokeDynamicEntry(ConstantPool cpm, int index, int hash, ConcreteBootstrapMethodEntry bootstrapMethod,\n+                                   ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_INVOKEDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n+        }\n+\n+        ConcreteInvokeDynamicEntry(ConstantPool cpm, int index, int bsmIndex,\n+                                   ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_INVOKEDYNAMIC, index, hash2(Classfile.TAG_INVOKEDYNAMIC, bsmIndex, nameAndType.index()),\n+                  bsmIndex, nameAndType);\n+        }\n+\n+        @Override\n+        public InvokeDynamicEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.invokeDynamicEntry(bootstrap(), nameAndType());\n+        }\n+    }\n+\n+    public static final class ConcreteConstantDynamicEntry extends AbstractDynamicConstantPoolEntry\n+            implements ConstantDynamicEntry {\n+\n+        ConcreteConstantDynamicEntry(ConstantPool cpm, int index, int hash, ConcreteBootstrapMethodEntry bootstrapMethod,\n+                                     ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_CONSTANTDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n+        }\n+\n+        ConcreteConstantDynamicEntry(ConstantPool cpm, int index, int bsmIndex,\n+                                     ConcreteNameAndTypeEntry nameAndType) {\n+            super(cpm, Classfile.TAG_CONSTANTDYNAMIC, index, hash2(Classfile.TAG_CONSTANTDYNAMIC, bsmIndex, nameAndType.index()),\n+                  bsmIndex, nameAndType);\n+        }\n+\n+        @Override\n+        public ConstantDynamicEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.constantDynamicEntry(bootstrap(), nameAndType());\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            List<LoadableConstantEntry> args = bootstrap().arguments();\n+            int argsSize =  args.size();\n+            ConstantDesc[] staticArgs = new ConstantDesc[argsSize];\n+            for (int i = 0; i < argsSize; i++)\n+                staticArgs[i] = args.get(i).constantValue();\n+\n+            return DynamicConstantDesc.ofCanonical(bootstrap().bootstrapMethod().asSymbol(),\n+                                                   nameAndType().name().stringValue(), ClassDesc.ofDescriptor(nameAndType().type().stringValue()), staticArgs);\n+        }\n+    }\n+\n+    public static final class ConcreteMethodHandleEntry extends ConcreteEntry\n+            implements MethodHandleEntry {\n+\n+        private final int refKind;\n+        private final ConcreteEntry.MemberRefEntry reference;\n+\n+        ConcreteMethodHandleEntry(ConstantPool cpm, int index, int hash, int refKind, ConcreteEntry.MemberRefEntry\n+                reference) {\n+            super(cpm, Classfile.TAG_METHODHANDLE, index, hash);\n+            this.refKind = refKind;\n+            this.reference = reference;\n+        }\n+\n+        ConcreteMethodHandleEntry(ConstantPool cpm, int index, int refKind, ConcreteEntry.MemberRefEntry\n+                reference) {\n+            super(cpm, Classfile.TAG_METHODHANDLE, index, hash2(Classfile.TAG_METHODHANDLE, refKind, reference.index()));\n+            this.refKind = refKind;\n+            this.reference = reference;\n+        }\n+\n+        @Override\n+        public int kind() {\n+            return refKind;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return asSymbol();\n+        }\n+\n+        @Override\n+        public ConcreteEntry.MemberRefEntry reference() {\n+            return reference;\n+        }\n+\n+        @Override\n+        public DirectMethodHandleDesc asSymbol() {\n+            return MethodHandleDesc.of(\n+                    DirectMethodHandleDesc.Kind.valueOf(kind(), reference() instanceof InterfaceMethodRefEntry),\n+                    ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).owner().asSymbol(),\n+                    ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().name().stringValue(),\n+                    ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().type().stringValue());\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU1(refKind);\n+            pool.writeU2(reference.index());\n+        }\n+\n+        @Override\n+        public MethodHandleEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.methodHandleEntry(refKind, reference);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + kind() + \":\" + ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).owner().asInternalName() + \".\" + ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().name().stringValue()\n+                   + \"-\" + ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().type().stringValue();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ConcreteMethodHandleEntry m) {\n+                return kind() == m.kind()\n+                && reference.equals(m.reference());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteMethodTypeEntry\n+            extends RefEntry<ConcreteUtf8Entry>\n+            implements MethodTypeEntry {\n+\n+        ConcreteMethodTypeEntry(ConstantPool cpm, int index, ConcreteUtf8Entry descriptor) {\n+            super(cpm, Classfile.TAG_METHODTYPE, index, descriptor);\n+        }\n+\n+        public Utf8Entry descriptor() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n+        }\n+\n+        @Override\n+        public MethodTypeEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.methodTypeEntry(ref1);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ConcreteMethodTypeEntry m) {\n+                return descriptor().equals(m.descriptor());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteStringEntry\n+            extends RefEntry<ConcreteUtf8Entry>\n+            implements StringEntry {\n+\n+        ConcreteStringEntry(ConstantPool cpm, int index, ConcreteUtf8Entry utf8) {\n+            super(cpm, Classfile.TAG_STRING, index, utf8);\n+        }\n+\n+        @Override\n+        public ConcreteUtf8Entry utf8() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public String stringValue() {\n+            return ref1.toString();\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return stringValue();\n+        }\n+\n+        @Override\n+        public StringEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.stringEntry(ref1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \\\"\" + stringValue() + \"\\\"\";\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ConcreteStringEntry s) {\n+                \/\/ check utf8 rather allocating a string\n+                return utf8().equals(s.utf8());\n+            }\n+            return false;\n+        }\n+\n+\n+    }\n+\n+    static abstract sealed class PrimitiveEntry<T extends ConstantDesc>\n+            extends ConcreteEntry {\n+        protected final T val;\n+\n+        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n+            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n+            this.val = val;\n+        }\n+\n+        public T value() {\n+            return val;\n+        }\n+\n+        public ConstantDesc constantValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"\" + tag() + value();\n+        }\n+    }\n+\n+    public static final class ConcreteIntegerEntry extends PrimitiveEntry<Integer>\n+            implements IntegerEntry {\n+\n+        ConcreteIntegerEntry(ConstantPool cpm, int index, int i) {\n+            super(cpm, Classfile.TAG_INTEGER, index, i);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeInt(val);\n+        }\n+\n+        @Override\n+        public IntegerEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.intEntry(val);\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ConcreteIntegerEntry e) {\n+                return intValue() == e.intValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteFloatEntry extends PrimitiveEntry<Float>\n+            implements FloatEntry {\n+\n+        ConcreteFloatEntry(ConstantPool cpm, int index, float f) {\n+            super(cpm, Classfile.TAG_FLOAT, index, f);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeFloat(val);\n+        }\n+\n+        @Override\n+        public FloatEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.floatEntry(val);\n+        }\n+\n+        @Override\n+        public float floatValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ConcreteFloatEntry e) {\n+                return floatValue() == e.floatValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteLongEntry extends PrimitiveEntry<Long> implements LongEntry {\n+\n+        ConcreteLongEntry(ConstantPool cpm, int index, long l) {\n+            super(cpm, Classfile.TAG_LONG, index, l);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeLong(val);\n+        }\n+\n+        @Override\n+        public LongEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.longEntry(val);\n+        }\n+\n+        @Override\n+        public long longValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ConcreteLongEntry e) {\n+                return longValue() == e.longValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ConcreteDoubleEntry extends PrimitiveEntry<Double> implements DoubleEntry {\n+\n+        ConcreteDoubleEntry(ConstantPool cpm, int index, double d) {\n+            super(cpm, Classfile.TAG_DOUBLE, index, d);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeDouble(val);\n+        }\n+\n+        @Override\n+        public DoubleEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.doubleEntry(val);\n+        }\n+\n+        @Override\n+        public double doubleValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof ConcreteDoubleEntry e) {\n+                return doubleValue() == e.doubleValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static class CpException extends RuntimeException {\n+        static final long serialVersionUID = 32L;\n+\n+        CpException(String s) {\n+            super(s);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ConcreteEntry.java","additions":1172,"deletions":0,"binary":false,"changes":1172,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.FieldTransform;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.WritableElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+public final class DirectClassBuilder\n+        extends AbstractDirectBuilder<ClassBuilder, ClassModel>\n+        implements ClassBuilder {\n+\n+    final ClassEntry thisClassEntry;\n+    private final List<WritableElement<FieldModel>> fields = new ArrayList<>();\n+    private final List<WritableElement<MethodModel>> methods = new ArrayList<>();\n+    private ClassEntry superclassEntry;\n+    private List<ClassEntry> interfaceEntries;\n+    private int majorVersion;\n+    private int minorVersion;\n+    private int flags;\n+    private int sizeHint;\n+\n+    public DirectClassBuilder(SplitConstantPool constantPool,\n+                              ClassEntry thisClass) {\n+        super(constantPool);\n+        this.thisClassEntry = ConcreteEntry.maybeClone(constantPool, thisClass);\n+        this.flags = Classfile.DEFAULT_CLASS_FLAGS;\n+        this.superclassEntry = null;\n+        this.interfaceEntries = Collections.emptyList();\n+        this.majorVersion = Classfile.LATEST_MAJOR_VERSION;\n+        this.minorVersion = Classfile.LATEST_MINOR_VERSION;\n+    }\n+\n+    @Override\n+    public ClassBuilder with(ClassElement element) {\n+        ((AbstractElement) element).writeTo(this);\n+        return this;\n+    }\n+\n+    @Override\n+    public ClassBuilder withField(Utf8Entry name,\n+                                  Utf8Entry descriptor,\n+                                  Consumer<? super FieldBuilder> handler) {\n+        return withField(new DirectFieldBuilder(constantPool, name, descriptor, null)\n+                                 .run(handler));\n+    }\n+\n+    @Override\n+    public ClassBuilder transformField(FieldModel field, FieldTransform transform) {\n+        DirectFieldBuilder builder = new DirectFieldBuilder(constantPool, field.fieldName(),\n+                                                            field.fieldType(), field);\n+        builder.transform(field, transform);\n+        return withField(builder);\n+    }\n+\n+    @Override\n+    public ClassBuilder withMethod(Utf8Entry name,\n+                                   Utf8Entry descriptor,\n+                                   int flags,\n+                                   Consumer<? super MethodBuilder> handler) {\n+        return withMethod(new DirectMethodBuilder(constantPool, name, descriptor, flags, null)\n+                                  .run(handler));\n+    }\n+\n+    @Override\n+    public ClassBuilder transformMethod(MethodModel method, MethodTransform transform) {\n+        DirectMethodBuilder builder = new DirectMethodBuilder(constantPool, method.methodName(),\n+                                                              method.methodType(),\n+                                                              method.flags().flagsMask(),\n+                                                              method);\n+        builder.transform(method, transform);\n+        return withMethod(builder);\n+    }\n+\n+    \/\/ internal \/ for use by elements\n+\n+    public ClassBuilder withField(WritableElement<FieldModel> field) {\n+        fields.add(field);\n+        return this;\n+    }\n+\n+    public ClassBuilder withMethod(WritableElement<MethodModel> method) {\n+        methods.add(method);\n+        return this;\n+    }\n+\n+    void setSuperclass(ClassEntry superclassEntry) {\n+        this.superclassEntry = superclassEntry;\n+    }\n+\n+    void setInterfaces(List<ClassEntry> interfaces) {\n+        this.interfaceEntries = interfaces;\n+    }\n+\n+    void setVersion(int major, int minor) {\n+        this.majorVersion = major;\n+        this.minorVersion = minor;\n+    }\n+\n+    void setFlags(int flags) {\n+        this.flags = flags;\n+    }\n+\n+    void setSizeHint(int sizeHint) {\n+        this.sizeHint = sizeHint;\n+    }\n+\n+\n+    public byte[] build() {\n+\n+        \/\/ The logic of this is very carefully ordered.  We want to avoid\n+        \/\/ repeated buffer copyings, so we accumulate lists of writers which\n+        \/\/ all get written later into the same buffer.  But, writing can often\n+        \/\/ trigger CP \/ BSM insertions, so we cannot run the CP writer or\n+        \/\/ BSM writers until everything else is written.\n+\n+        \/\/ Do this early because it might trigger CP activity\n+        ClassEntry superclass = superclassEntry;\n+        if (superclass != null)\n+            superclass = ConcreteEntry.maybeClone(constantPool, superclass);\n+        else if ((flags & Classfile.ACC_MODULE) == 0 && !\"java\/lang\/Object\".equals(thisClassEntry.asInternalName()))\n+            superclass = constantPool.classEntry(ConstantDescs.CD_Object);\n+        List<ClassEntry> ies = new ArrayList<>(interfaceEntries.size());\n+        for (ClassEntry ce : interfaceEntries)\n+            ies.add(ConcreteEntry.maybeClone(constantPool, ce));\n+\n+        \/\/ We maintain two writers, and then we join them at the end\n+        int size = sizeHint == 0 ? 256 : sizeHint;\n+        BufWriter head = new BufWriterImpl(constantPool, size);\n+        BufWriterImpl tail = new BufWriterImpl(constantPool, size);\n+        tail.setThisClass(thisClassEntry);\n+\n+        \/\/ The tail consists of fields and methods, and attributes\n+        \/\/ This should trigger all the CP\/BSM mutation\n+        tail.writeList(fields);\n+        tail.writeList(methods);\n+        int attributesOffset = tail.size();\n+        attributes.writeTo(tail);\n+\n+        \/\/ Now we have to append the BSM, if there is one\n+        boolean written = constantPool.writeBootstrapMethods(tail);\n+        if (written) {\n+            \/\/ Update attributes count\n+            tail.patchInt(attributesOffset, 2, attributes.size() + 1);\n+        }\n+\n+        \/\/ Now we can make the head\n+        head.writeInt(Classfile.MAGIC_NUMBER);\n+        head.writeU2(minorVersion);\n+        head.writeU2(majorVersion);\n+        constantPool.writeTo(head);\n+        head.writeU2(flags);\n+        head.writeIndex(thisClassEntry);\n+        head.writeIndexOrZero(superclass);\n+        head.writeListIndices(ies);\n+\n+        \/\/ Join head and tail into an exact-size buffer\n+        byte[] result = new byte[head.size() + tail.size()];\n+        head.copyTo(result, 0);\n+        tail.copyTo(result, head.size());\n+        return result;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.SwitchCase;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.instruction.CharacterRange;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+\n+import static jdk.internal.classfile.Opcode.GOTO;\n+import static jdk.internal.classfile.Opcode.GOTO_W;\n+import static jdk.internal.classfile.Opcode.IINC;\n+import static jdk.internal.classfile.Opcode.IINC_W;\n+import static jdk.internal.classfile.Opcode.LDC2_W;\n+import static jdk.internal.classfile.Opcode.LDC_W;\n+\n+\/**\n+ * CodeWriter\n+ *\/\n+public final class DirectCodeBuilder\n+        extends AbstractDirectBuilder<CodeBuilder, CodeModel>\n+        implements TerminalCodeBuilder, LabelContext {\n+    private final List<CharacterRange> characterRanges = new ArrayList<>();\n+    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers = new ArrayList<>();\n+    private final List<LocalVariable> localVariables = new ArrayList<>();\n+    private final List<LocalVariableType> localVariableTypes = new ArrayList<>();\n+    private final boolean transformFwdJumps, transformBackJumps;\n+    private final Label startLabel, endLabel;\n+    private final MethodInfo methodInfo;\n+    final BufWriter bytecodesBufWriter;\n+    private CodeAttribute mruParent;\n+    private int[] mruParentTable;\n+    private Map<CodeAttribute, int[]> parentMap;\n+    private DedupLineNumberTableAttribute lineNumberWriter;\n+    private int topLocal;\n+\n+    List<DeferredLabel> deferredLabels;\n+\n+    \/* Locals management\n+       lazily computed maxLocal = -1\n+       first time: derive count from methodType descriptor (for new methods) & ACC_STATIC,\n+       or model maxLocals (for transformation)\n+       block builders inherit parent count\n+       allocLocal(TypeKind) bumps by nSlots\n+     *\/\n+\n+    public static Attribute<CodeAttribute> build(MethodInfo methodInfo,\n+                                                 Consumer<? super CodeBuilder> handler,\n+                                                 SplitConstantPool constantPool,\n+                                                 CodeModel original) {\n+        DirectCodeBuilder cb;\n+        try {\n+            handler.accept(cb = new DirectCodeBuilder(methodInfo, constantPool, original, false));\n+            cb.buildContent();\n+        } catch (LabelOverflowException loe) {\n+            if (constantPool.options().fixJumps) {\n+                handler.accept(cb = new DirectCodeBuilder(methodInfo, constantPool, original, true));\n+                cb.buildContent();\n+            }\n+            else\n+                throw loe;\n+        }\n+        return cb.content;\n+    }\n+\n+    private DirectCodeBuilder(MethodInfo methodInfo,\n+                              SplitConstantPool constantPool,\n+                              CodeModel original,\n+                              boolean transformFwdJumps) {\n+        super(constantPool);\n+        setOriginal(original);\n+        this.methodInfo = methodInfo;\n+        this.transformFwdJumps = transformFwdJumps;\n+        this.transformBackJumps = constantPool.options().fixJumps;\n+        bytecodesBufWriter = (original instanceof CodeImpl cai) ? new BufWriterImpl(constantPool, cai.codeLength())\n+                                                               : new BufWriterImpl(constantPool);\n+        this.startLabel = new LabelImpl(this, 0);\n+        this.endLabel = new LabelImpl(this, -1);\n+        this.topLocal = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodType().stringValue());\n+        if (original != null)\n+            this.topLocal = Math.max(this.topLocal, original.maxLocals());\n+    }\n+\n+    @Override\n+    public CodeBuilder with(CodeElement element) {\n+        ((AbstractElement) element).writeTo(this);\n+        return this;\n+    }\n+\n+    @Override\n+    public Label newLabel() {\n+        return new LabelImpl(this, -1);\n+    }\n+\n+    @Override\n+    public Label startLabel() {\n+        return startLabel;\n+    }\n+\n+    @Override\n+    public Label endLabel() {\n+        return endLabel;\n+    }\n+\n+    @Override\n+    public int receiverSlot() {\n+        return methodInfo.receiverSlot();\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        return methodInfo.parameterSlot(paramNo);\n+    }\n+\n+    public int curTopLocal() {\n+        return topLocal;\n+    }\n+\n+    @Override\n+    public int allocateLocal(TypeKind typeKind) {\n+        int retVal = topLocal;\n+        topLocal += typeKind.slotSize();\n+        return retVal;\n+    }\n+\n+    public int curPc() {\n+        return bytecodesBufWriter.size();\n+    }\n+\n+    public MethodInfo methodInfo() {\n+        return methodInfo;\n+    }\n+\n+    private Attribute<CodeAttribute> content = null;\n+\n+    private void writeExceptionHandlers(BufWriter buf) {\n+        int pos = buf.size();\n+        int handlersSize = handlers.size();\n+        buf.writeU2(handlersSize);\n+        for (AbstractPseudoInstruction.ExceptionCatchImpl h : handlers) {\n+            int startPc = labelToBci(h.tryStart());\n+            int endPc = labelToBci(h.tryEnd());\n+            int handlerPc = labelToBci(h.handler());\n+            if (startPc == -1 || endPc == -1 || handlerPc == -1) {\n+                if (constantPool.options().filterDeadLabels) {\n+                    handlersSize--;\n+                } else {\n+                    throw new IllegalStateException(\"Unbound label in exception handler\");\n+                }\n+            } else {\n+                buf.writeU2(startPc);\n+                buf.writeU2(endPc);\n+                buf.writeU2(handlerPc);\n+                buf.writeIndexOrZero(h.catchTypeEntry());\n+                handlersSize++;\n+            }\n+        }\n+        if (handlersSize < handlers.size())\n+            buf.patchInt(pos, 2, handlersSize);\n+    }\n+\n+    private void buildContent() {\n+        if (content != null) return;\n+        setLabelTarget(endLabel);\n+\n+        \/\/ Backfill branches for which Label didn't have position yet\n+        processDeferredLabels();\n+\n+        if (constantPool.options().processDebug) {\n+            if (!characterRanges.isEmpty()) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.CHARACTER_RANGE_TABLE) {\n+\n+                    @Override\n+                    public void writeBody(BufWriter b) {\n+                        int pos = b.size();\n+                        int crSize = characterRanges.size();\n+                        b.writeU2(crSize);\n+                        for (CharacterRange cr : characterRanges) {\n+                            var start = labelToBci(cr.startScope());\n+                            var end = labelToBci(cr.endScope());\n+                            if (start == -1 || end == -1) {\n+                                if (constantPool.options().filterDeadLabels) {\n+                                    crSize--;\n+                                } else {\n+                                    throw new IllegalStateException(\"Unbound label in character range\");\n+                                }\n+                            } else {\n+                                b.writeU2(start);\n+                                b.writeU2(end - 1);\n+                                b.writeInt(cr.characterRangeStart());\n+                                b.writeInt(cr.characterRangeEnd());\n+                                b.writeU2(cr.flags());\n+                            }\n+                        }\n+                        if (crSize < characterRanges.size())\n+                            b.patchInt(pos, 2, crSize);\n+                    }\n+                };\n+                attributes.withAttribute(a);\n+            }\n+\n+            if (!localVariables.isEmpty()) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TABLE) {\n+                    @Override\n+                    public void writeBody(BufWriter b) {\n+                        int pos = b.size();\n+                        int lvSize = localVariables.size();\n+                        b.writeU2(lvSize);\n+                        for (LocalVariable l : localVariables) {\n+                            if (!l.writeTo(b)) {\n+                                if (constantPool.options().filterDeadLabels) {\n+                                    lvSize--;\n+                                } else {\n+                                    throw new IllegalStateException(\"Unbound label in local variable type\");\n+                                }\n+                            }\n+                        }\n+                        if (lvSize < localVariables.size())\n+                            b.patchInt(pos, 2, lvSize);\n+                    }\n+                };\n+                attributes.withAttribute(a);\n+            }\n+\n+            if (!localVariableTypes.isEmpty()) {\n+                Attribute<?> a = new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                    @Override\n+                    public void writeBody(BufWriter b) {\n+                        int pos = b.size();\n+                        int lvtSize = localVariableTypes.size();\n+                        b.writeU2(localVariableTypes.size());\n+                        for (LocalVariableType l : localVariableTypes) {\n+                            if (!l.writeTo(b)) {\n+                                if (constantPool.options().filterDeadLabels) {\n+                                    lvtSize--;\n+                                } else {\n+                                    throw new IllegalStateException(\"Unbound label in local variable type\");\n+                                }\n+                            }\n+                        }\n+                        if (lvtSize < localVariableTypes.size())\n+                            b.patchInt(pos, 2, lvtSize);\n+                    }\n+                };\n+                attributes.withAttribute(a);\n+            }\n+        }\n+\n+        if (lineNumberWriter != null) {\n+            attributes.withAttribute(lineNumberWriter);\n+        }\n+\n+        content = new UnboundAttribute.AdHocAttribute<>(Attributes.CODE) {\n+            @Override\n+            public void writeBody(BufWriter b) {\n+                BufWriterImpl buf = (BufWriterImpl) b;\n+                buf.setLabelContext(DirectCodeBuilder.this);\n+\n+                int codeLength = curPc();\n+                int maxStack, maxLocals;\n+                Attribute<? extends StackMapTableAttribute> stackMapAttr;\n+                boolean canReuseStackmaps = codeAndExceptionsMatch(codeLength);\n+\n+                if (!constantPool.options().generateStackmaps) {\n+                    maxStack = maxLocals = 255;\n+                    stackMapAttr = null;\n+                }\n+                else if (canReuseStackmaps) {\n+                    maxLocals = original.maxLocals();\n+                    maxStack = original.maxStack();\n+                    stackMapAttr = original.findAttribute(Attributes.STACK_MAP_TABLE).orElse(null);\n+                }\n+                else {\n+                    \/\/new instance of generator immediately calculates maxStack, maxLocals, all frames,\n+                    \/\/ patches dead bytecode blocks and removes them from exception table\n+                    StackMapGenerator gen = new StackMapGenerator(DirectCodeBuilder.this,\n+                                                  buf.thisClass().asSymbol(),\n+                                                  methodInfo.methodName().stringValue(),\n+                                                  MethodTypeDesc.ofDescriptor(methodInfo.methodType().stringValue()),\n+                                                  (methodInfo.methodFlags() & Classfile.ACC_STATIC) != 0,\n+                                                  bytecodesBufWriter.asByteBuffer().slice(0, codeLength),\n+                                                  constantPool,\n+                                                  handlers);\n+                    maxStack = gen.maxStack();\n+                    maxLocals = gen.maxLocals();\n+                    stackMapAttr = gen.stackMapTableAttribute();\n+                }\n+                attributes.withAttribute(stackMapAttr);\n+\n+                buf.writeU2(maxStack);\n+                buf.writeU2(maxLocals);\n+                buf.writeInt(codeLength);\n+                buf.writeBytes(bytecodesBufWriter);\n+                writeExceptionHandlers(b);\n+                attributes.writeTo(b);\n+                buf.setLabelContext(null);\n+            }\n+        };\n+    }\n+\n+    private static class DedupLineNumberTableAttribute extends UnboundAttribute.AdHocAttribute<LineNumberTableAttribute> {\n+        private final BufWriterImpl buf;\n+        private int lastPc, lastLine, writtenLine;\n+\n+        public DedupLineNumberTableAttribute(ConstantPoolBuilder constantPool) {\n+            super(Attributes.LINE_NUMBER_TABLE);\n+            buf = new BufWriterImpl(constantPool);\n+            lastPc = -1;\n+            writtenLine = -1;\n+        }\n+\n+        private void push() {\n+            \/\/subsequent identical line numbers are skipped\n+            if (lastPc >= 0 && lastLine != writtenLine) {\n+                buf.writeU2(lastPc);\n+                buf.writeU2(lastLine);\n+                writtenLine = lastLine;\n+            }\n+        }\n+\n+        \/\/writes are expected ordered by pc in ascending sequence\n+        public void writeLineNumber(int pc, int lineNo) {\n+            \/\/for each pc only the latest line number is written\n+            if (lastPc != pc && lastLine != lineNo) {\n+                push();\n+                lastPc = pc;\n+            }\n+            lastLine = lineNo;\n+        }\n+\n+        @Override\n+        public void writeBody(BufWriter b) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter b) {\n+            b.writeIndex(b.constantPool().utf8Entry(Attributes.NAME_LINE_NUMBER_TABLE));\n+            push();\n+            b.writeInt(buf.size() + 2);\n+            b.writeU2(buf.size() \/ 4);\n+            b.writeBytes(buf);\n+        }\n+    }\n+\n+    private boolean codeAndExceptionsMatch(int codeLength) {\n+        boolean codeAttributesMatch;\n+        if (original instanceof CodeImpl cai && canWriteDirect(cai.constantPool())) {\n+            codeAttributesMatch = cai.codeLength == curPc()\n+                                  && cai.compareCodeBytes(bytecodesBufWriter, 0, codeLength);\n+            if (codeAttributesMatch) {\n+                BufWriter bw = new BufWriterImpl(constantPool);\n+                writeExceptionHandlers(bw);\n+                codeAttributesMatch = cai.classReader.compare(bw, 0, cai.exceptionHandlerPos, bw.size());\n+            }\n+        }\n+        else\n+            codeAttributesMatch = false;\n+        return codeAttributesMatch;\n+    }\n+\n+    \/\/ Writing support\n+\n+    private record DeferredLabel(int labelPc, int size, int instructionPc, Label label) { }\n+\n+    private void writeLabelOffset(int nBytes, int instructionPc, Label label) {\n+        int targetBci = labelToBci(label);\n+        if (targetBci == -1) {\n+            int pc = curPc();\n+            bytecodesBufWriter.writeIntBytes(nBytes, 0);\n+            if (deferredLabels == null)\n+                deferredLabels = new ArrayList<>();\n+            deferredLabels.add(new DeferredLabel(pc, nBytes, instructionPc, label));\n+        }\n+        else {\n+            int branchOffset = targetBci - instructionPc;\n+            if (nBytes == 2 && (short)branchOffset != branchOffset) throw new LabelOverflowException();\n+            bytecodesBufWriter.writeIntBytes(nBytes, branchOffset);\n+        }\n+    }\n+\n+    private void processDeferredLabels() {\n+        if (deferredLabels != null) {\n+            for (DeferredLabel dl : deferredLabels) {\n+                int branchOffset = labelToBci(dl.label) - dl.instructionPc;\n+                if (dl.size == 2 && (short)branchOffset != branchOffset) throw new LabelOverflowException();\n+                bytecodesBufWriter.patchInt(dl.labelPc, dl.size, branchOffset);\n+            }\n+        }\n+    }\n+\n+    \/\/ Instruction writing\n+\n+    public void writeBytecode(Opcode opcode) {\n+        if (opcode.isWide())\n+            bytecodesBufWriter.writeU1(Classfile.WIDE);\n+        bytecodesBufWriter.writeU1(opcode.bytecode() & 0xFF);\n+    }\n+\n+    public void writeLoad(Opcode opcode, int localVar) {\n+        writeBytecode(opcode);\n+        switch (opcode.sizeIfFixed()) {\n+            case 1 -> { }\n+            case 2 -> bytecodesBufWriter.writeU1(localVar);\n+            case 4 -> bytecodesBufWriter.writeU2(localVar);\n+            default -> throw new IllegalArgumentException(\"Unexpected instruction size: \" + opcode);\n+        }\n+    }\n+\n+    public void writeStore(Opcode opcode, int localVar) {\n+        writeBytecode(opcode);\n+        switch (opcode.sizeIfFixed()) {\n+            case 1 -> { }\n+            case 2 -> bytecodesBufWriter.writeU1(localVar);\n+            case 4 -> bytecodesBufWriter.writeU2(localVar);\n+            default -> throw new IllegalArgumentException(\"Unexpected instruction size: \" + opcode);\n+        }\n+    }\n+\n+    public void writeIncrement(int slot, int val) {\n+        Opcode opcode = (slot < 256 && val < 128 && val > -127)\n+                        ? IINC\n+                        : IINC_W;\n+        writeBytecode(opcode);\n+        if (opcode.isWide()) {\n+            bytecodesBufWriter.writeU2(slot);\n+            bytecodesBufWriter.writeU2(val);\n+        } else {\n+            bytecodesBufWriter.writeU1(slot);\n+            bytecodesBufWriter.writeU1(val);\n+        }\n+    }\n+\n+    public void writeBranch(Opcode op, Label target) {\n+        int instructionPc = curPc();\n+        int targetBci = labelToBci(target);\n+        \/\/transform short-opcode forward jumps if enforced, and backward jumps if enabled and overflowing\n+        if (op.sizeIfFixed() == 3 && (targetBci == -1\n+                                      ? transformFwdJumps\n+                                      : (transformBackJumps\n+                                         && targetBci - instructionPc < Short.MIN_VALUE))) {\n+            if (op == GOTO) {\n+                writeBytecode(GOTO_W);\n+                writeLabelOffset(4, instructionPc, target);\n+            } else {\n+                writeBytecode(BytecodeHelpers.reverseBranchOpcode(op));\n+                Label bypassJump = newLabel();\n+                writeLabelOffset(2, instructionPc, bypassJump);\n+                writeBytecode(GOTO_W);\n+                writeLabelOffset(4, instructionPc + 3, target);\n+                labelBinding(bypassJump);\n+            }\n+        } else {\n+            writeBytecode(op);\n+            writeLabelOffset(op.sizeIfFixed() == 3 ? 2 : 4, instructionPc, target);\n+        }\n+    }\n+\n+    public void writeLookupSwitch(Label defaultTarget, List<SwitchCase> cases) {\n+        int instructionPc = curPc();\n+        writeBytecode(Opcode.LOOKUPSWITCH);\n+        int pad = 4 - (curPc() % 4);\n+        if (pad != 4)\n+            bytecodesBufWriter.writeIntBytes(pad, 0);\n+        writeLabelOffset(4, instructionPc, defaultTarget);\n+        bytecodesBufWriter.writeInt(cases.size());\n+        cases = new ArrayList<>(cases);\n+        cases.sort(new Comparator<SwitchCase>() {\n+            @Override\n+            public int compare(SwitchCase c1, SwitchCase c2) {\n+                return Integer.compare(c1.caseValue(), c2.caseValue());\n+            }\n+        });\n+        for (var c : cases) {\n+            bytecodesBufWriter.writeInt(c.caseValue());\n+            writeLabelOffset(4, instructionPc, c.target());\n+        }\n+    }\n+\n+    public void writeTableSwitch(int low, int high, Label defaultTarget, List<SwitchCase> cases) {\n+        int instructionPc = curPc();\n+        writeBytecode(Opcode.TABLESWITCH);\n+        int pad = 4 - (curPc() % 4);\n+        if (pad != 4)\n+            bytecodesBufWriter.writeIntBytes(pad, 0);\n+        writeLabelOffset(4, instructionPc, defaultTarget);\n+        bytecodesBufWriter.writeInt(low);\n+        bytecodesBufWriter.writeInt(high);\n+        var caseMap = new HashMap<Integer, Label>(cases.size());\n+        for (var c : cases) {\n+            caseMap.put(c.caseValue(), c.target());\n+        }\n+        for (long l = low; l<=high; l++) {\n+            writeLabelOffset(4, instructionPc, caseMap.getOrDefault((int)l, defaultTarget));\n+        }\n+    }\n+\n+    public void writeFieldAccess(Opcode opcode, FieldRefEntry ref) {\n+        writeBytecode(opcode);\n+        bytecodesBufWriter.writeIndex(ref);\n+    }\n+\n+    public void writeInvokeNormal(Opcode opcode, MemberRefEntry ref) {\n+        writeBytecode(opcode);\n+        bytecodesBufWriter.writeIndex(ref);\n+    }\n+\n+    public void writeInvokeInterface(Opcode opcode,\n+                                     InterfaceMethodRefEntry ref,\n+                                     int count) {\n+        writeBytecode(opcode);\n+        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeU1(count);\n+        bytecodesBufWriter.writeU1(0);\n+    }\n+\n+    public void writeInvokeDynamic(InvokeDynamicEntry ref) {\n+        writeBytecode(Opcode.INVOKEDYNAMIC);\n+        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeU2(0);\n+    }\n+\n+    public void writeNewObject(ClassEntry type) {\n+        writeBytecode(Opcode.NEW);\n+        bytecodesBufWriter.writeIndex(type);\n+    }\n+\n+    public void writeNewPrimitiveArray(int newArrayCode) {\n+        writeBytecode(Opcode.NEWARRAY);\n+        bytecodesBufWriter.writeU1(newArrayCode);\n+    }\n+\n+    public void writeNewReferenceArray(ClassEntry type) {\n+        writeBytecode(Opcode.ANEWARRAY);\n+        bytecodesBufWriter.writeIndex(type);\n+    }\n+\n+    public void writeNewMultidimensionalArray(int dimensions, ClassEntry type) {\n+        writeBytecode(Opcode.MULTIANEWARRAY);\n+        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeU1(dimensions);\n+    }\n+\n+    public void writeTypeCheck(Opcode opcode, ClassEntry type) {\n+        writeBytecode(opcode);\n+        bytecodesBufWriter.writeIndex(type);\n+    }\n+\n+    public void writeArgumentConstant(Opcode opcode, int value) {\n+        writeBytecode(opcode);\n+        if (opcode.sizeIfFixed() == 3) {\n+            bytecodesBufWriter.writeU2(value);\n+        } else {\n+            bytecodesBufWriter.writeU1(value);\n+        }\n+    }\n+\n+    public void writeLoadConstant(Opcode opcode, LoadableConstantEntry value) {\n+        \/\/ Make sure Long and Double have LDC2_W and\n+        \/\/ rewrite to _W if index is > 256\n+        int index = ConcreteEntry.maybeClone(constantPool, value).index();\n+        Opcode op = opcode;\n+        if (value instanceof LongEntry || value instanceof DoubleEntry) {\n+            op = LDC2_W;\n+        } else if (index >= 256)\n+            op = LDC_W;\n+\n+        writeBytecode(op);\n+        if (op.sizeIfFixed() == 3) {\n+            bytecodesBufWriter.writeU2(index);\n+        } else {\n+            bytecodesBufWriter.writeU1(index);\n+        }\n+    }\n+\n+    @Override\n+    public Label getLabel(int bci) {\n+        throw new UnsupportedOperationException(\"Lookup by BCI not supported by CodeBuilder\");\n+    }\n+\n+    @Override\n+    public int labelToBci(Label label) {\n+        LabelImpl lab = (LabelImpl) label;\n+        LabelContext context = lab.labelContext();\n+        if (context == this) {\n+            return lab.getContextInfo();\n+        }\n+        else if (context == mruParent) {\n+            return mruParentTable[lab.getContextInfo()] - 1;\n+        }\n+        else if (context instanceof CodeAttribute parent) {\n+            if (parentMap == null)\n+                parentMap = new IdentityHashMap<>();\n+            \/\/critical JDK bootstrap path, cannot use lambda here\n+            int[] table = parentMap.computeIfAbsent(parent, new Function<CodeAttribute, int[]>() {\n+                @Override\n+                public int[] apply(CodeAttribute x) {\n+                    return new int[parent.codeLength() + 1];\n+                }\n+            });\n+\n+            mruParent = parent;\n+            mruParentTable = table;\n+            return mruParentTable[lab.getContextInfo()] - 1;\n+        }\n+        else if (context instanceof BufferedCodeBuilder) {\n+            \/\/ Hijack the label\n+            return lab.getContextInfo();\n+        }\n+        else {\n+            throw new IllegalStateException(String.format(\"Unexpected label context %s in =%s\", context, this));\n+        }\n+    }\n+\n+    public void setLineNumber(int lineNo) {\n+        if (lineNumberWriter == null)\n+            lineNumberWriter = new DedupLineNumberTableAttribute(constantPool);\n+        lineNumberWriter.writeLineNumber(curPc(), lineNo);\n+    }\n+\n+    public void setLabelTarget(Label label) {\n+        setLabelTarget(label, curPc());\n+    }\n+\n+    @Override\n+    public void setLabelTarget(Label label, int bci) {\n+        LabelImpl lab = (LabelImpl) label;\n+        LabelContext context = lab.labelContext();\n+\n+        if (context == this) {\n+            if (lab.getContextInfo() != -1)\n+                throw new IllegalStateException(\"Setting label target for already-set label\");\n+            lab.setContextInfo(bci);\n+        }\n+        else if (context == mruParent) {\n+            mruParentTable[lab.getContextInfo()] = bci + 1;\n+        }\n+        else if (context instanceof CodeAttribute parent) {\n+            if (parentMap == null)\n+                parentMap = new IdentityHashMap<>();\n+            int[] table = parentMap.computeIfAbsent(parent, new Function<CodeAttribute, int[]>() {\n+                @Override\n+                public int[] apply(CodeAttribute x) {\n+                    return new int[parent.codeLength() + 1];\n+                }\n+            });\n+\n+            mruParent = parent;\n+            mruParentTable = table;\n+            mruParentTable[lab.getContextInfo()] = bci + 1;\n+        }\n+        else if (context instanceof BufferedCodeBuilder) {\n+            \/\/ Hijack the label\n+            lab.setContextInfo(bci);\n+        }\n+        else {\n+            throw new IllegalStateException(String.format(\"Unexpected label context %s in =%s\", context, this));\n+        }\n+    }\n+\n+    public void addCharacterRange(CharacterRange element) {\n+        characterRanges.add(element);\n+    }\n+\n+    public void addHandler(ExceptionCatch element) {\n+        AbstractPseudoInstruction.ExceptionCatchImpl el = (AbstractPseudoInstruction.ExceptionCatchImpl) element;\n+        ClassEntry type = el.catchTypeEntry();\n+        if (type != null && !constantPool.canWriteDirect(type.constantPool()))\n+            el = new AbstractPseudoInstruction.ExceptionCatchImpl(element.handler(), element.tryStart(), element.tryEnd(), ConcreteEntry.maybeClone(constantPool, type));\n+        handlers.add(el);\n+    }\n+\n+    public void addLocalVariable(LocalVariable element) {\n+        localVariables.add(element);\n+    }\n+\n+    public void addLocalVariableType(LocalVariableType element) {\n+        localVariableTypes.add(element);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CodeBuilder[id=%d]\", System.identityHashCode(this));\n+    }\n+\n+    \/\/ToDo: consolidate and open all exceptions\n+    private static final class LabelOverflowException extends IllegalStateException {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        public LabelOverflowException() {\n+            super(\"Label target offset overflow\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.WritableElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+public final class DirectFieldBuilder\n+        extends AbstractDirectBuilder<FieldBuilder, FieldModel>\n+        implements TerminalFieldBuilder, WritableElement<FieldModel> {\n+    private final Utf8Entry name;\n+    private final Utf8Entry desc;\n+    private int flags;\n+\n+    public DirectFieldBuilder(SplitConstantPool constantPool,\n+                              Utf8Entry name,\n+                              Utf8Entry type,\n+                              FieldModel original) {\n+        super(constantPool);\n+        setOriginal(original);\n+        this.name = name;\n+        this.desc = type;\n+        this.flags = 0;\n+    }\n+\n+    @Override\n+    public FieldBuilder with(FieldElement element) {\n+        ((AbstractElement) element).writeTo(this);\n+        return this;\n+    }\n+\n+    public DirectFieldBuilder run(Consumer<? super FieldBuilder> handler) {\n+        handler.accept(this);\n+        return this;\n+    }\n+\n+    void setFlags(int flags) {\n+        this.flags = flags;\n+    }\n+\n+    public void writeTo(BufWriter buf) {\n+        buf.writeU2(flags);\n+        buf.writeIndex(name);\n+        buf.writeIndex(desc);\n+        attributes.writeTo(buf);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.WritableElement;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+public final class DirectMethodBuilder\n+        extends AbstractDirectBuilder<MethodBuilder, MethodModel>\n+        implements TerminalMethodBuilder, WritableElement<MethodModel>, MethodInfo {\n+\n+    final Utf8Entry name;\n+    final Utf8Entry desc;\n+    int flags;\n+    int[] parameterSlots;\n+\n+    public DirectMethodBuilder(SplitConstantPool constantPool,\n+                               Utf8Entry nameInfo,\n+                               Utf8Entry typeInfo,\n+                               int flags,\n+                               MethodModel original) {\n+        super(constantPool);\n+        setOriginal(original);\n+        this.name = nameInfo;\n+        this.desc = typeInfo;\n+        this.flags = flags;\n+    }\n+\n+    void setFlags(int flags) {\n+        boolean wasStatic = (this.flags & Classfile.ACC_STATIC) != 0;\n+        boolean isStatic = (flags & Classfile.ACC_STATIC) != 0;\n+        if (wasStatic != isStatic)\n+            throw new IllegalArgumentException(\"Cannot change ACC_STATIC flag of method\");\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public Utf8Entry methodName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Utf8Entry methodType() {\n+        return desc;\n+    }\n+\n+    @Override\n+    public int methodFlags() {\n+        return flags;\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        if (parameterSlots == null)\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+        return parameterSlots[paramNo];\n+    }\n+\n+    @Override\n+    public BufferedCodeBuilder bufferedCodeBuilder(CodeModel original) {\n+        return new BufferedCodeBuilder(this, constantPool, original);\n+    }\n+\n+    @Override\n+    public MethodBuilder with(MethodElement element) {\n+        ((AbstractElement) element).writeTo(this);\n+        return this;\n+    }\n+\n+    private MethodBuilder withCode(CodeModel original,\n+                                  Consumer<? super CodeBuilder> handler) {\n+        var cb = DirectCodeBuilder.build(this, handler, constantPool, original);\n+        writeAttribute(cb);\n+        return this;\n+    }\n+\n+    @Override\n+    public MethodBuilder withCode(Consumer<? super CodeBuilder> handler) {\n+        return withCode(null, handler);\n+    }\n+\n+    @Override\n+    public MethodBuilder transformCode(CodeModel code, CodeTransform transform) {\n+        return withCode(code, new Consumer<>() {\n+            @Override\n+            public void accept(CodeBuilder builder) {\n+                builder.transform(code, transform);\n+            }\n+        });\n+    }\n+\n+    public DirectMethodBuilder run(Consumer<? super MethodBuilder> handler) {\n+        handler.accept(this);\n+        return this;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter b) {\n+        BufWriterImpl buf = (BufWriterImpl) b;\n+        buf.writeU2(flags);\n+        buf.writeIndex(name);\n+        buf.writeIndex(desc);\n+        attributes.writeTo(buf);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+\/**\n+ * An open-chain multimap used to map nonzero hashes to indexes (of either CP\n+ * elements or BSM entries).  Code transformed from public domain implementation\n+ * (http:\/\/java-performance.info\/implementing-world-fastest-java-int-to-int-hash-map\/).\n+ *\n+ * The internal data structure is an array of 2N int elements, where the first\n+ * element is the hash and the second is the mapped index.  To look something up\n+ * in the map, provide a hash value and an index to map it to, and invoke\n+ * firstToken(hash).  This returns an opaque token that can be provided to\n+ * nextToken(hash, token) to get the next candidate, or to getElementByToken(token)\n+ * or getIndexByToken to get the mapped element or index.\n+ *\/\n+public abstract class EntryMap<T> {\n+    public static final int NO_VALUE = -1;\n+\n+    \/**\n+     * Keys and values\n+     *\/\n+    private int[] data;\n+\n+    \/**\n+     * Fill factor, must be between (0 and 1)\n+     *\/\n+    private final float fillFactor;\n+    \/**\n+     * We will resize a map once it reaches this size\n+     *\/\n+    private int resizeThreshold;\n+    \/**\n+     * Current map size\n+     *\/\n+    private int size;\n+\n+    \/**\n+     * Mask to calculate the original position\n+     *\/\n+    private int mask1;\n+    private int mask2;\n+\n+    public EntryMap(int size, float fillFactor) {\n+        if (fillFactor <= 0 || fillFactor >= 1)\n+            throw new IllegalArgumentException(\"FillFactor must be in (0, 1)\");\n+        if (size <= 0)\n+            throw new IllegalArgumentException(\"Size must be positive!\");\n+\n+        int capacity = arraySize(size, fillFactor);\n+        this.fillFactor = fillFactor;\n+        this.resizeThreshold = (int) (capacity * fillFactor);\n+        this.mask1 = capacity - 1;\n+        this.mask2 = capacity * 2 - 1;\n+        data = new int[capacity * 2];\n+    }\n+\n+    protected abstract T fetchElement(int index);\n+\n+    public int firstToken(int hash) {\n+        if (hash == 0)\n+            throw new IllegalArgumentException(\"hash must be nonzero\");\n+\n+        int ix = (hash & mask1) << 1;\n+        int k = data[ix];\n+\n+        if (k == 0)\n+            return NO_VALUE;  \/\/end of chain already\n+        else if (k == hash)\n+            return ix;\n+        else\n+            return nextToken(hash, ix);\n+    }\n+\n+    public int nextToken(int hash, int token) {\n+        int ix = token;\n+        while (true) {\n+            ix = (ix + 2) & mask2; \/\/ next index\n+            int k = data[ix];\n+            if (k == 0)\n+                return NO_VALUE;\n+            else if (k == hash)\n+                return ix;\n+        }\n+    }\n+\n+    public int getIndexByToken(int token) {\n+        return data[token + 1];\n+    }\n+\n+    public T getElementByToken(int token) {\n+        return fetchElement(data[token + 1]);\n+    }\n+\n+    public void put(int hash, int index) {\n+        if (hash == 0)\n+            throw new IllegalArgumentException(\"hash must be nonzero\");\n+\n+        int ptr = (hash & mask1) << 1;\n+        int k = data[ptr];\n+        if (k == 0) {\n+            data[ptr] = hash;\n+            data[ptr + 1] = index;\n+            if (size >= resizeThreshold)\n+                rehash(data.length * 2); \/\/size is set inside\n+            else\n+                ++size;\n+            return;\n+        }\n+        else if (k == hash && data[ptr + 1] == index) {\n+            return;\n+        }\n+\n+        while (true) {\n+            ptr = (ptr + 2) & mask2; \/\/ next index\n+            k = data[ptr];\n+            if (k == 0) {\n+                data[ptr] = hash;\n+                data[ptr + 1] = index;\n+                if (size >= resizeThreshold)\n+                    rehash(data.length * 2); \/\/size is set inside\n+                else\n+                    ++size;\n+                return;\n+            }\n+            else if (k == hash && data[ptr + 1] == index) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    public int size() {\n+        return size;\n+    }\n+\n+    private void rehash(final int newCapacity) {\n+        resizeThreshold = (int) (newCapacity \/ 2 * fillFactor);\n+        mask1 = newCapacity \/ 2 - 1;\n+        mask2 = newCapacity - 1;\n+\n+        final int oldCapacity = data.length;\n+        final int[] oldData = data;\n+\n+        data = new int[newCapacity];\n+        size = 0;\n+\n+        for (int i = 0; i < oldCapacity; i += 2) {\n+            final int oldHash = oldData[i];\n+            if (oldHash != 0)\n+                put(oldHash, oldData[i + 1]);\n+        }\n+    }\n+\n+    public static long nextPowerOfTwo( long x ) {\n+        if ( x == 0 ) return 1;\n+        x--;\n+        x |= x >> 1;\n+        x |= x >> 2;\n+        x |= x >> 4;\n+        x |= x >> 8;\n+        x |= x >> 16;\n+        return ( x | x >> 32 ) + 1;\n+    }\n+\n+    public static int arraySize( final int expected, final float f ) {\n+        final long s = Math.max( 2, nextPowerOfTwo( (long)Math.ceil( expected \/ f ) ) );\n+        if ( s > (1 << 30) ) throw new IllegalArgumentException( \"Too large (\" + expected + \" expected elements with load factor \" + f + \")\" );\n+        return (int)s;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/EntryMap.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+\/**\n+ * FieldImpl -- merged implementation of FieldLow and FieldModel\n+ *\/\n+public final class FieldImpl\n+        extends AbstractElement\n+        implements FieldModel {\n+\n+    private final ClassReader reader;\n+    private final int startPos, endPos, attributesPos;\n+    private List<Attribute<?>> attributes;\n+\n+    public FieldImpl(ClassReader reader, int startPos, int endPos, int attributesPos) {\n+        this.reader = reader;\n+        this.startPos = startPos;\n+        this.endPos = endPos;\n+        this.attributesPos = attributesPos;\n+    }\n+\n+    @Override\n+    public AccessFlags flags() {\n+        return AccessFlags.ofField(reader.readU2(startPos));\n+    }\n+\n+    @Override\n+    public Optional<ClassModel> parent() {\n+        if (reader instanceof ClassReaderImpl cri)\n+            return Optional.of(cri.getContainedClass());\n+        else\n+            return Optional.empty();\n+    }\n+\n+    @Override\n+    public Utf8Entry fieldName() {\n+        return reader.readUtf8Entry(startPos + 2);\n+    }\n+\n+    @Override\n+    public Utf8Entry fieldType() {\n+        return reader.readUtf8Entry(startPos + 4);\n+    }\n+\n+    @Override\n+    public List<Attribute<?>> attributes() {\n+        if (attributes == null) {\n+            attributes = BoundAttribute.readAttributes(this, reader, attributesPos, reader.customAttributes());\n+        }\n+        return attributes;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter buf) {\n+        if (buf.canWriteDirect(reader)) {\n+            reader.copyBytesTo(buf, startPos, endPos - startPos);\n+        }\n+        else {\n+            buf.writeU2(flags().flagsMask());\n+            buf.writeIndex(fieldName());\n+            buf.writeIndex(fieldType());\n+            buf.writeList(attributes());\n+        }\n+    }\n+\n+    \/\/ FieldModel\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        if (builder.canWriteDirect(reader)) {\n+            builder.withField(this);\n+        }\n+        else {\n+            builder.withField(fieldName(), fieldType(), new Consumer<>() {\n+                @Override\n+                public void accept(FieldBuilder fb) {\n+                    FieldImpl.this.forEachElement(fb);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void forEachElement(Consumer<FieldElement> consumer) {\n+        consumer.accept(flags());\n+        for (Attribute<?> attr : attributes()) {\n+            if (attr instanceof FieldElement e)\n+                consumer.accept(e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"FieldModel[fieldName=%s, fieldType=%s, flags=%d]\",\n+                fieldName().stringValue(), fieldType().stringValue(), flags().flagsMask());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n+import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.ConvertInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.MonitorInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StackInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.ThrowInstruction;\n+\n+\/**\n+ * InstructionData\n+ *\/\n+public class InstructionData {\n+    static final Instruction[] singletonInstructions = new Instruction[256];\n+\n+    static {\n+        for (Opcode o : List.of(Opcode.NOP))\n+            singletonInstructions[o.bytecode()] = NopInstruction.of();\n+        for (Opcode o : List.of(Opcode.ACONST_NULL,\n+                                Opcode.ICONST_M1,\n+                                Opcode.ICONST_0, Opcode.ICONST_1, Opcode.ICONST_2, Opcode.ICONST_3, Opcode.ICONST_4, Opcode.ICONST_5,\n+                                Opcode.LCONST_0, Opcode.LCONST_1,\n+                                Opcode.FCONST_0, Opcode.FCONST_1, Opcode.FCONST_2,\n+                                Opcode.DCONST_0, Opcode.DCONST_1))\n+            singletonInstructions[o.bytecode()] = ConstantInstruction.ofIntrinsic(o);\n+        for (Opcode o : List.of(Opcode.ILOAD_0, Opcode.ILOAD_1, Opcode.ILOAD_2, Opcode.ILOAD_3,\n+                                Opcode.LLOAD_0, Opcode.LLOAD_1, Opcode.LLOAD_2, Opcode.LLOAD_3,\n+                                Opcode.FLOAD_0, Opcode.FLOAD_1, Opcode.FLOAD_2, Opcode.FLOAD_3,\n+                                Opcode.DLOAD_0, Opcode.DLOAD_1, Opcode.DLOAD_2, Opcode.DLOAD_3,\n+                                Opcode.ALOAD_0, Opcode.ALOAD_1, Opcode.ALOAD_2, Opcode.ALOAD_3))\n+            singletonInstructions[o.bytecode()] = LoadInstruction.of(o, o.slot());\n+        for (Opcode o : List.of(Opcode.ISTORE_0, Opcode.ISTORE_1, Opcode.ISTORE_2, Opcode.ISTORE_3,\n+                                Opcode.LSTORE_0, Opcode.LSTORE_1, Opcode.LSTORE_2, Opcode.LSTORE_3,\n+                                Opcode.FSTORE_0, Opcode.FSTORE_1, Opcode.FSTORE_2, Opcode.FSTORE_3,\n+                                Opcode.DSTORE_0, Opcode.DSTORE_1, Opcode.DSTORE_2, Opcode.DSTORE_3,\n+                                Opcode.ASTORE_0, Opcode.ASTORE_1, Opcode.ASTORE_2, Opcode.ASTORE_3))\n+            singletonInstructions[o.bytecode()] = StoreInstruction.of(o, o.slot());\n+        for (Opcode o : List.of(Opcode.IALOAD, Opcode.LALOAD, Opcode.FALOAD, Opcode.DALOAD, Opcode.AALOAD, Opcode.BALOAD, Opcode.CALOAD, Opcode.SALOAD))\n+            singletonInstructions[o.bytecode()] = ArrayLoadInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.IASTORE, Opcode.LASTORE, Opcode.FASTORE, Opcode.DASTORE, Opcode.AASTORE, Opcode.BASTORE, Opcode.CASTORE, Opcode.SASTORE))\n+            singletonInstructions[o.bytecode()] = ArrayStoreInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.POP, Opcode.POP2, Opcode.DUP, Opcode.DUP_X1, Opcode.DUP_X2, Opcode.DUP2, Opcode.DUP2_X1, Opcode.DUP2_X2, Opcode.SWAP))\n+            singletonInstructions[o.bytecode()] = StackInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.IADD, Opcode.LADD, Opcode.FADD, Opcode.DADD, Opcode.ISUB,\n+                                Opcode.LSUB, Opcode.FSUB, Opcode.DSUB,\n+                                Opcode.IMUL, Opcode.LMUL, Opcode.FMUL, Opcode.DMUL,\n+                                Opcode.IDIV, Opcode.LDIV, Opcode.FDIV, Opcode.DDIV,\n+                                Opcode.IREM, Opcode.LREM, Opcode.FREM, Opcode.DREM,\n+                                Opcode.INEG, Opcode.LNEG, Opcode.FNEG, Opcode.DNEG,\n+                                Opcode.ISHL, Opcode.LSHL, Opcode.ISHR, Opcode.LSHR, Opcode.IUSHR, Opcode.LUSHR,\n+                                Opcode.IAND, Opcode.LAND, Opcode.IOR, Opcode.LOR, Opcode.IXOR, Opcode.LXOR,\n+                                Opcode.LCMP, Opcode.FCMPL, Opcode.FCMPG, Opcode.DCMPL, Opcode.DCMPG,\n+                                Opcode.ARRAYLENGTH))\n+            singletonInstructions[o.bytecode()] = OperatorInstruction.of(o);\n+\n+        for (Opcode o : List.of(Opcode.I2L, Opcode.I2F, Opcode.I2D,\n+                                Opcode.L2I, Opcode.L2F, Opcode.L2D,\n+                                Opcode.F2I, Opcode.F2L, Opcode.F2D,\n+                                Opcode.D2I, Opcode.D2L, Opcode.D2F,\n+                                Opcode.I2B, Opcode.I2C, Opcode.I2S))\n+            singletonInstructions[o.bytecode()] = ConvertInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.IRETURN, Opcode.LRETURN, Opcode.FRETURN, Opcode.DRETURN, Opcode.ARETURN, Opcode.RETURN))\n+            singletonInstructions[o.bytecode()] = ReturnInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.ATHROW))\n+            singletonInstructions[o.bytecode()] = ThrowInstruction.of();\n+        for (Opcode o : List.of(Opcode.MONITORENTER, Opcode.MONITOREXIT))\n+            singletonInstructions[o.bytecode()] = MonitorInstruction.of(o);\n+    }\n+\n+    private InstructionData() {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/InstructionData.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Interfaces;\n+\n+\/**\n+ * InterfacesImpl\n+ *\/\n+public final class InterfacesImpl\n+        extends AbstractElement\n+        implements Interfaces {\n+    private final List<ClassEntry> interfaces;\n+\n+    public InterfacesImpl(List<ClassEntry> interfaces) {\n+        this.interfaces = List.copyOf(interfaces);\n+    }\n+\n+    @Override\n+    public List<ClassEntry> interfaces() {\n+        return interfaces;\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        builder.setInterfaces(interfaces);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Interfaces[interfaces=%s]\", interfaces.stream()\n+                .map(iface -> iface.name().stringValue())\n+                .collect(Collectors.joining(\", \")));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/InterfacesImpl.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.Label;\n+\n+\/**\n+ * LabelContext\n+ *\/\n+public sealed interface LabelContext\n+        permits BufferedCodeBuilder, CodeImpl, DirectCodeBuilder {\n+    Label newLabel();\n+    Label getLabel(int bci);\n+    void setLabelTarget(Label label, int bci);\n+    int labelToBci(Label label);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelContext.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Objects;\n+\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.instruction.LabelTarget;\n+\n+\/**\n+ * Labels are created with a parent context, which is either a code attribute\n+ * or a code builder.  A label originating in a code attribute context may be\n+ * reused in a code builder context, but only labels from a single code\n+ * attribute may be reused by a single code builder.  Mappings to and from\n+ * BCI are the responsibility of the context in which it is used; a single\n+ * word of mutable state is provided, for the exclusive use of the owning\n+ * context.\n+ *\n+ * In practice, this means that labels created in a code attribute can simply\n+ * store the BCI in the state on creation, and labels created in in a code\n+ * builder can store the BCI in the state when the label is eventually set; if\n+ * a code attribute label is reused in a builder, the original BCI can be used\n+ * as an index into an array.\n+ *\/\n+public final class LabelImpl\n+        extends AbstractElement\n+        implements Label, LabelTarget {\n+\n+    private final LabelContext labelContext;\n+    private int contextInfo;\n+\n+    public LabelImpl(LabelContext labelContext, int contextInfo) {\n+        this.labelContext = Objects.requireNonNull(labelContext);\n+        this.contextInfo = contextInfo;\n+    }\n+\n+    public LabelContext labelContext() {\n+        return labelContext;\n+    }\n+\n+    public int getContextInfo() {\n+        return contextInfo;\n+    }\n+\n+    public void setContextInfo(int contextInfo) {\n+        this.contextInfo = contextInfo;\n+    }\n+\n+    @Override\n+    public Label label() {\n+        return this;\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder builder) {\n+        builder.setLabelTarget(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Label[context=%s, contextInfo=%d]\", labelContext, contextInfo);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.instruction.LineNumber;\n+\n+\/**\n+ * LineNumberImpl\n+ *\/\n+public final class LineNumberImpl\n+        extends AbstractElement\n+        implements LineNumber {\n+    private static final int INTERN_LIMIT = 1000;\n+    private static final LineNumber[] internCache = new LineNumber[INTERN_LIMIT];\n+    static {\n+        for (int i=0; i<INTERN_LIMIT; i++)\n+            internCache[i] = new LineNumberImpl(i);\n+    }\n+\n+    private final int line;\n+\n+    private LineNumberImpl(int line) {\n+        this.line = line;\n+    }\n+\n+    public static LineNumber of(int line) {\n+        return (line < INTERN_LIMIT)\n+               ? internCache[line]\n+               : new LineNumberImpl(line);\n+    }\n+\n+    @Override\n+    public int line() {\n+        return line;\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder writer) {\n+        writer.setLineNumber(line);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"LineNumber[line=%d]\", line);\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LineNumberImpl.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Merged implementation of MethodLow and MethodModel\n+ *\/\n+public final class MethodImpl\n+        extends AbstractElement\n+        implements MethodModel, MethodInfo {\n+\n+    private final ClassReader reader;\n+    private final int startPos, endPos, attributesPos;\n+    private List<Attribute<?>> attributes;\n+    private int[] parameterSlots;\n+\n+    public MethodImpl(ClassReader reader, int startPos, int endPos, int attrStart) {\n+        this.reader = reader;\n+        this.startPos = startPos;\n+        this.endPos = endPos;\n+        this.attributesPos = attrStart;\n+    }\n+\n+    @Override\n+    public AccessFlags flags() {\n+        return AccessFlags.ofMethod(reader.readU2(startPos));\n+    }\n+\n+    @Override\n+    public Optional<ClassModel> parent() {\n+        if (reader instanceof ClassReaderImpl cri)\n+            return Optional.of(cri.getContainedClass());\n+        else\n+            return Optional.empty();\n+    }\n+\n+    @Override\n+    public Utf8Entry methodName() {\n+        return reader.readUtf8Entry(startPos + 2);\n+    }\n+\n+    @Override\n+    public Utf8Entry methodType() {\n+        return reader.readUtf8Entry(startPos + 4);\n+    }\n+\n+    @Override\n+    public int methodFlags() {\n+        return reader.readU2(startPos);\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        if (parameterSlots == null)\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+        return parameterSlots[paramNo];\n+    }\n+\n+    @Override\n+    public List<Attribute<?>> attributes() {\n+        if (attributes == null) {\n+            attributes = BoundAttribute.readAttributes(this, reader, attributesPos, reader.customAttributes());\n+        }\n+        return attributes;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter b) {\n+        BufWriterImpl buf = (BufWriterImpl) b;\n+        if (buf.canWriteDirect(reader)) {\n+            reader.copyBytesTo(buf, startPos, endPos - startPos);\n+        }\n+        else {\n+            buf.writeU2(flags().flagsMask());\n+            buf.writeIndex(methodName());\n+            buf.writeIndex(methodType());\n+            buf.writeList(attributes());\n+        }\n+    }\n+\n+    \/\/ MethodModel\n+\n+    @Override\n+    public Optional<CodeModel> code() {\n+        return findAttribute(Attributes.CODE).map(a -> (CodeModel) a);\n+    }\n+\n+    @Override\n+    public void forEachElement(Consumer<MethodElement> consumer) {\n+        consumer.accept(flags());\n+        for (Attribute<?> attr : attributes()) {\n+            if (attr instanceof MethodElement e)\n+                consumer.accept(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        if (builder.canWriteDirect(reader)) {\n+            builder.withMethod(this);\n+        }\n+        else {\n+            builder.withMethod(methodName(), methodType(), methodFlags(),\n+                               new Consumer<>() {\n+                @Override\n+                public void accept(MethodBuilder mb) {\n+                    MethodImpl.this.forEachElement(mb);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"MethodModel[methodName=%s, methodType=%s, flags=%d]\",\n+                methodName().stringValue(), methodType().stringValue(), flags().flagsMask());\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+\n+\/**\n+ * MethodInfo\n+ *\/\n+public interface MethodInfo {\n+    Utf8Entry methodName();\n+    Utf8Entry methodType();\n+    int methodFlags();\n+\n+    default int receiverSlot() {\n+        if ((methodFlags() & ACC_STATIC) != 0)\n+            throw new IllegalStateException(\"not an instance method\");\n+        return 0;\n+    }\n+\n+    int parameterSlot(int paramNo);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodInfo.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.attribute.ModuleAttribute.ModuleAttributeBuilder;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+\n+public final class ModuleAttributeBuilderImpl\n+        implements ModuleAttributeBuilder {\n+\n+    private ModuleEntry moduleEntry;\n+    private Utf8Entry moduleVersion;\n+    private int moduleFlags;\n+\n+    private final Set<ModuleRequireInfo> requires = new LinkedHashSet<>();\n+    private final Set<ModuleExportInfo> exports = new LinkedHashSet<>();\n+    private final Set<ModuleOpenInfo> opens = new LinkedHashSet<>();\n+    private final Set<ClassEntry> uses = new LinkedHashSet<>();\n+    private final Set<ModuleProvideInfo> provides = new LinkedHashSet<>();\n+\n+    public ModuleAttributeBuilderImpl(ModuleDesc moduleName) {\n+        this.moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName()));\n+        this.moduleFlags = 0;\n+    }\n+\n+    @Override\n+    public ModuleAttribute build() {\n+        return new UnboundAttribute.UnboundModuleAttribute(moduleEntry, moduleFlags, moduleVersion,\n+                                                            requires, exports, opens, uses, provides);\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder moduleName(ModuleDesc moduleName) {\n+        Objects.requireNonNull(moduleName);\n+        moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(moduleName.moduleName()));\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder moduleFlags(int flags) {\n+        this.moduleFlags = flags;\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder moduleVersion(String version) {\n+        moduleVersion = version == null ? null : TemporaryConstantPool.INSTANCE.utf8Entry(version);\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder requires(ModuleDesc module, int flags, String version) {\n+        Objects.requireNonNull(module);\n+        return requires(ModuleRequireInfo.of(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(module.moduleName())), flags, version == null ? null : TemporaryConstantPool.INSTANCE.utf8Entry(version)));\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder requires(ModuleRequireInfo requires) {\n+        Objects.requireNonNull(requires);\n+        this.requires.add(requires);\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder exports(PackageDesc pkge, int flags, ModuleDesc... exportsToModules) {\n+        Objects.requireNonNull(pkge);\n+        var exportsTo = new ArrayList<ModuleEntry>(exportsToModules.length);\n+        for (var e : exportsToModules)\n+            exportsTo.add(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(e.moduleName())));\n+        return exports(ModuleExportInfo.of(TemporaryConstantPool.INSTANCE.packageEntry(TemporaryConstantPool.INSTANCE.utf8Entry(pkge.packageInternalName())), flags, exportsTo));\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder exports(ModuleExportInfo exports) {\n+        Objects.requireNonNull(exports);\n+        this.exports.add(exports);\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder opens(PackageDesc pkge, int flags, ModuleDesc... opensToModules) {\n+        Objects.requireNonNull(pkge);\n+        var opensTo = new ArrayList<ModuleEntry>(opensToModules.length);\n+        for (var e : opensToModules)\n+            opensTo.add(TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(e.moduleName())));\n+        return opens(ModuleOpenInfo.of(TemporaryConstantPool.INSTANCE.packageEntry(TemporaryConstantPool.INSTANCE.utf8Entry(pkge.packageInternalName())), flags, opensTo));\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder opens(ModuleOpenInfo opens) {\n+        Objects.requireNonNull(opens);\n+        this.opens.add(opens);\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder uses(ClassDesc service) {\n+        Objects.requireNonNull(service);\n+        return uses(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(service))));\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder uses(ClassEntry uses) {\n+        Objects.requireNonNull(uses);\n+        this.uses.add(uses);\n+        return this;\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder provides(ClassDesc service, ClassDesc... implClasses) {\n+        Objects.requireNonNull(service);\n+        var impls = new ArrayList<ClassEntry>(implClasses.length);\n+        for (var seq : implClasses)\n+            impls.add(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(seq))));\n+        return provides(ModuleProvideInfo.of(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(service))), impls));\n+    }\n+\n+    @Override\n+    public ModuleAttributeBuilder provides(ModuleProvideInfo provides) {\n+        Objects.requireNonNull(provides);\n+        this.provides.add(provides);\n+        return this;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+\n+public record ModuleDescImpl(String moduleName) implements ModuleDesc {\n+\n+    \/**\n+     * Validates the correctness of a module name. In particular checks for the presence of\n+     * invalid characters in the name.\n+     *\n+     * {@jvms 4.2.3} Module and Package Names\n+     *\n+     * @param name the module name\n+     * @return the module name passed if valid\n+     * @throws IllegalArgumentException if the module name is invalid\n+     *\/\n+    public static String validateModuleName(String name) {\n+        for (int i=name.length() - 1; i >= 0; i--) {\n+            char ch = name.charAt(i);\n+            if ((ch >= '\\u0000' && ch <= '\\u001F')\n+            || ((ch == '\\\\' || ch == ':' || ch =='@') && (i == 0 || name.charAt(--i) != '\\\\')))\n+                throw new IllegalArgumentException(\"Invalid module name: \" + name);\n+        }\n+        return name;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleDescImpl.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+\n+\/**\n+ * NonterminalCodeBuilder\n+ *\/\n+public abstract sealed class NonterminalCodeBuilder implements CodeBuilder\n+    permits ChainedCodeBuilder, BlockCodeBuilderImpl {\n+    protected final TerminalCodeBuilder terminal;\n+    protected final CodeBuilder parent;\n+\n+    public NonterminalCodeBuilder(CodeBuilder parent) {\n+        this.parent = parent;\n+        this.terminal = switch (parent) {\n+            case ChainedCodeBuilder cb -> cb.terminal;\n+            case BlockCodeBuilderImpl cb -> cb.terminal;\n+            case TerminalCodeBuilder cb -> cb;\n+        };\n+    }\n+\n+    @Override\n+    public int receiverSlot() {\n+        return terminal.receiverSlot();\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        return terminal.parameterSlot(paramNo);\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return terminal.constantPool();\n+    }\n+\n+    @Override\n+    public Optional<CodeModel> original() {\n+        return terminal.original();\n+    }\n+\n+    @Override\n+    public Label newLabel() {\n+        return terminal.newLabel();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/NonterminalCodeBuilder.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Collection;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.AttributeMapper;\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import static jdk.internal.classfile.ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER;\n+\n+\/**\n+ * Options\n+ *\/\n+public class Options {\n+\n+    public enum Key {\n+        GENERATE_STACK_MAPS, PROCESS_DEBUG, PROCESS_LINE_NUMBERS, PROCESS_UNKNOWN_ATTRIBUTES,\n+        CP_SHARING, FIX_SHORT_JUMPS, PATCH_DEAD_CODE, HIERARCHY_RESOLVER, ATTRIBUTE_MAPPER,\n+        FILTER_DEAD_LABELS;\n+    }\n+\n+    public record OptionValue(Key key, Object value) implements Classfile.Option { }\n+\n+    public Boolean generateStackmaps = true;\n+    public Boolean processDebug = true;\n+    public Boolean processLineNumbers = true;\n+    public Boolean processUnknownAttributes = true;\n+    public Boolean cpSharing = true;\n+    public Boolean fixJumps = true;\n+    public Boolean patchCode = true;\n+    public Boolean filterDeadLabels = false;\n+    public ClassHierarchyResolver classHierarchyResolver = DEFAULT_CLASS_HIERARCHY_RESOLVER;\n+    public Function<Utf8Entry, AttributeMapper<?>> attributeMapper = new Function<>() {\n+        @Override\n+        public AttributeMapper<?> apply(Utf8Entry k) {\n+            return null;\n+        }\n+    };\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Options(Collection<Classfile.Option> options) {\n+        for (var o : options) {\n+            var ov = ((OptionValue)o);\n+            var v = ov.value();\n+            switch (ov.key()) {\n+                case GENERATE_STACK_MAPS -> generateStackmaps = (Boolean) v;\n+                case PROCESS_DEBUG -> processDebug = (Boolean) v;\n+                case PROCESS_LINE_NUMBERS -> processLineNumbers = (Boolean) v;\n+                case PROCESS_UNKNOWN_ATTRIBUTES -> processUnknownAttributes = (Boolean) v;\n+                case CP_SHARING -> cpSharing = (Boolean) v;\n+                case FIX_SHORT_JUMPS -> fixJumps = (Boolean) v;\n+                case PATCH_DEAD_CODE -> patchCode = (Boolean) v;\n+                case HIERARCHY_RESOLVER -> classHierarchyResolver = (ClassHierarchyResolver) v;\n+                case ATTRIBUTE_MAPPER -> attributeMapper = (Function<Utf8Entry, AttributeMapper<?>>) v;\n+                case FILTER_DEAD_LABELS -> filterDeadLabels = (Boolean) v;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Options.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+\n+public record PackageDescImpl(String packageInternalName) implements PackageDesc {\n+\n+    \/**\n+     * Validates the correctness of a binary package name. In particular checks for the presence of\n+     * invalid characters in the name.\n+     *\n+     * @param name the package name\n+     * @return the package name passed if valid\n+     * @throws IllegalArgumentException if the package name is invalid\n+     *\/\n+    public static String validateBinaryPackageName(String name) {\n+        for (int i=0; i<name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '\/')\n+                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    \/**\n+     * Validates the correctness of an internal package name.\n+     * In particular checks for the presence of invalid characters in the name.\n+     *\n+     * @param name the package name\n+     * @return the package name passed if valid\n+     * @throws IllegalArgumentException if the package name is invalid\n+     *\/\n+    public static String validateInternalPackageName(String name) {\n+        for (int i=0; i<name.length(); i++) {\n+            char ch = name.charAt(i);\n+            if (ch == ';' || ch == '[' || ch == '.')\n+                throw new IllegalArgumentException(\"Invalid package name: \" + name);\n+        }\n+        return name;\n+    }\n+\n+    public static String internalToBinary(String name) {\n+        return name.replace('\/', '.');\n+    }\n+\n+    public static String binaryToInternal(String name) {\n+        return name.replace('.', '\/');\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/PackageDescImpl.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.nio.ByteBuffer;\n+import static jdk.internal.classfile.Classfile.ASTORE_3;\n+import static jdk.internal.classfile.Classfile.ISTORE;\n+import static jdk.internal.classfile.Classfile.LOOKUPSWITCH;\n+import static jdk.internal.classfile.Classfile.TABLESWITCH;\n+import static jdk.internal.classfile.Classfile.WIDE;\n+\n+public final class RawBytecodeHelper {\n+\n+    public static final int ILLEGAL = -1;\n+\n+    private static final byte[] LENGTHS = new byte[] {\n+        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 3, 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+        2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 | (6 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 | (4 << 4), 0, 0, 1, 1, 1,\n+        1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 4, 4, 4, 2, 4, 3, 3, 0, 0, 1, 3, 2, 3, 3, 3, 1, 2, 1,\n+        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n+    };\n+\n+    public static boolean isStoreIntoLocal(int code) {\n+        return (ISTORE <= code && code <= ASTORE_3);\n+    }\n+\n+    public static int align(int n) {\n+        return (n + 3) & ~3;\n+    }\n+\n+    private final ByteBuffer bytecode;\n+    public int bci, nextBci, endBci;\n+    public int rawCode;\n+    public boolean isWide;\n+\n+    public RawBytecodeHelper(ByteBuffer bytecode) {\n+        this.bytecode = bytecode;\n+        this.bci = 0;\n+        this.nextBci = 0;\n+        this.endBci = bytecode.capacity();\n+    }\n+\n+    public boolean isLastBytecode() {\n+        return nextBci >= endBci;\n+    }\n+\n+    public int getShort(int bci) {\n+        return bytecode.getShort(bci);\n+    }\n+\n+    public int dest() {\n+        return bci + getShort(bci + 1);\n+    }\n+\n+    public int getInt(int bci) {\n+        return bytecode.getInt(bci);\n+    }\n+\n+    public int destW() {\n+        return bci + getInt(bci + 1);\n+    }\n+\n+    public int getIndexU1() {\n+        return bytecode.get(bci + 1) & 0xff;\n+    }\n+\n+    public int getU1(int bci) {\n+        return bytecode.get(bci) & 0xff;\n+    }\n+\n+    public int rawNext(int jumpTo) {\n+        this.nextBci = jumpTo;\n+        return rawNext();\n+    }\n+\n+    public int rawNext() {\n+        bci = nextBci;\n+        int code = bytecode.get(bci) & 0xff;\n+        int len = LENGTHS[code] & 0xf;\n+        if (len > 0 && (bci <= endBci - len)) {\n+            isWide = false;\n+            nextBci += len;\n+            if (nextBci <= bci) {\n+                code = ILLEGAL;\n+            }\n+            rawCode = code;\n+            return code;\n+        } else {\n+            len = switch (bytecode.get(bci) & 0xff) {\n+                case WIDE -> {\n+                    if (bci + 1 >= endBci) {\n+                        yield -1;\n+                    }\n+                    yield LENGTHS[bytecode.get(bci + 1) & 0xff] >> 4;\n+                }\n+                case TABLESWITCH -> {\n+                    int aligned_bci = align(bci + 1);\n+                    if (aligned_bci + 3 * 4 >= endBci) {\n+                        yield -1;\n+                    }\n+                    int lo = bytecode.getInt(aligned_bci + 1 * 4);\n+                    int hi = bytecode.getInt(aligned_bci + 2 * 4);\n+                    int l = aligned_bci - bci + (3 + hi - lo + 1) * 4;\n+                    if (l > 0) yield l; else yield -1;\n+                }\n+                case LOOKUPSWITCH -> {\n+                    int aligned_bci = align(bci + 1);\n+                    if (aligned_bci + 2 * 4 >= endBci) {\n+                        yield -1;\n+                    }\n+                    int npairs = bytecode.getInt(aligned_bci + 4);\n+                    int l = aligned_bci - bci + (2 + 2 * npairs) * 4;\n+                    if (l > 0) yield l; else yield -1;\n+                }\n+                default ->\n+                    0;\n+            };\n+            if (len <= 0 || (bci > endBci - len) || (bci - len >= nextBci)) {\n+                code = ILLEGAL;\n+            } else {\n+                nextBci += len;\n+                isWide = false;\n+                if (code == WIDE) {\n+                    if (bci + 1 >= endBci) {\n+                        code = ILLEGAL;\n+                    } else {\n+                        code = bytecode.get(bci + 1) & 0xff;\n+                        isWide = true;\n+                    }\n+                }\n+            }\n+            rawCode = code;\n+            return code;\n+        }\n+    }\n+\n+    public int getIndex() {\n+        return (isWide) ? getIndexU2Raw(bci + 2) : getIndexU1();\n+    }\n+\n+    public int getIndexU2() {\n+        return getIndexU2Raw(bci + 1);\n+    }\n+\n+    public int getIndexU2Raw(int bci) {\n+        return bytecode.getShort(bci) & 0xffff;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Collections;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.Signature.*;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class SignaturesImpl {\n+\n+    public SignaturesImpl() {\n+    }\n+\n+    private String sig;\n+    private int sigp;\n+\n+    public ClassSignature parseClassSignature(String signature) {\n+        this.sig = signature;\n+        sigp = 0;\n+        List<TypeParam> typeParamTypes = parseParamTypes();\n+        RefTypeSig superclass = referenceTypeSig();\n+        ArrayList<RefTypeSig> superinterfaces = null;\n+        while (sigp < sig.length()) {\n+            if (superinterfaces == null)\n+                superinterfaces = new ArrayList<>();\n+            superinterfaces.add(referenceTypeSig());\n+        }\n+        return new ClassSignatureImpl(typeParamTypes, superclass, null2Empty(superinterfaces));\n+    }\n+\n+    public MethodSignature parseMethodSignature(String signature) {\n+        this.sig = signature;\n+        sigp = 0;\n+        List<TypeParam> typeParamTypes = parseParamTypes();\n+        assert sig.charAt(sigp) == '(';\n+        sigp++;\n+        ArrayList<Signature> paramTypes = null;\n+        while (sig.charAt(sigp) != ')') {\n+            if (paramTypes == null)\n+                 paramTypes = new ArrayList<>();\n+            paramTypes.add(typeSig());\n+        }\n+        sigp++;\n+        Signature returnType = typeSig();\n+        ArrayList<ThrowableSig> throwsTypes = null;\n+        while (sigp < sig.length() && sig.charAt(sigp) == '^') {\n+            sigp++;\n+            if (throwsTypes == null)\n+                throwsTypes = new ArrayList<>();\n+            var t = typeSig();\n+            if (t instanceof ThrowableSig ts)\n+                throwsTypes.add(ts);\n+            else\n+                throw new IllegalStateException(\"not a valid type signature: \" + sig);\n+        }\n+        return new MethodSignatureImpl(typeParamTypes, null2Empty(throwsTypes), returnType, null2Empty(paramTypes));\n+    }\n+\n+    public Signature parseSignature(String signature) {\n+        this.sig = signature;\n+        sigp = 0;\n+        return typeSig();\n+    }\n+\n+    private List<TypeParam> parseParamTypes() {\n+        ArrayList<TypeParam> typeParamTypes = null;\n+        if (sig.charAt(sigp) == '<') {\n+            sigp++;\n+            typeParamTypes = new ArrayList<>();\n+            while (sig.charAt(sigp) != '>') {\n+                int sep = sig.indexOf(\":\", sigp);\n+                String name = sig.substring(sigp, sep);\n+                RefTypeSig classBound = null;\n+                ArrayList<RefTypeSig> interfaceBounds = null;\n+                sigp = sep + 1;\n+                if (sig.charAt(sigp) != ':')\n+                    classBound = referenceTypeSig();\n+                while (sig.charAt(sigp) == ':') {\n+                    sigp++;\n+                    if (interfaceBounds == null)\n+                        interfaceBounds = new ArrayList<>();\n+                    interfaceBounds.add(referenceTypeSig());\n+                }\n+                typeParamTypes.add(new TypeParamImpl(name, Optional.ofNullable(classBound), null2Empty(interfaceBounds)));\n+            }\n+            sigp++;\n+        }\n+        return null2Empty(typeParamTypes);\n+    }\n+\n+    private Signature typeSig() {\n+        char c = sig.charAt(sigp++);\n+        switch (c) {\n+            case 'B','C','D','F','I','J','V','S','Z': return Signature.BaseTypeSig.of(c);\n+            default:\n+                sigp--;\n+                return referenceTypeSig();\n+        }\n+    }\n+\n+    private RefTypeSig referenceTypeSig() {\n+        char c = sig.charAt(sigp++);\n+        switch (c) {\n+            case 'L':\n+                StringBuilder sb = new StringBuilder();\n+                ArrayList<Signature> argTypes = null;\n+                Signature.ClassTypeSig t = null;\n+                char sigch ;\n+                do {\n+                    switch  (sigch = sig.charAt(sigp++)) {\n+                        case '<' -> {\n+                            argTypes = new ArrayList<>();\n+                            while (sig.charAt(sigp) != '>')\n+                                argTypes.add(typeSig());\n+                            sigp++;\n+                        }\n+                        case '.',';' -> {\n+                            t = new ClassTypeSigImpl(Optional.ofNullable(t), sb.toString(), null2Empty(argTypes));\n+                            sb.setLength(0);\n+                            argTypes = null;\n+                        }\n+                        default -> sb.append(sigch);\n+                    }\n+                } while (sigch != ';');\n+                return t;\n+            case 'T':\n+                int sep = sig.indexOf(';', sigp);\n+                var ty = Signature.TypeVarSig.of(sig.substring(sigp, sep));\n+                sigp = sep + 1;\n+                return ty;\n+            case '[': return ArrayTypeSig.of(typeSig());\n+            case '*': return TypeArg.unbounded();\n+            case '+': return TypeArg.extendsOf(referenceTypeSig());\n+            case '-': return TypeArg.superOf(referenceTypeSig());\n+        }\n+        throw new IllegalStateException(\"not a valid type signature: \" + sig);\n+    }\n+\n+    public static record BaseTypeSigImpl(char baseType) implements Signature.BaseTypeSig {\n+\n+        @Override\n+        public String signatureString() {\n+            return \"\" + baseType;\n+        }\n+    }\n+\n+    public static record TypeVarSigImpl(String identifier) implements Signature.TypeVarSig {\n+\n+        @Override\n+        public String signatureString() {\n+            return \"T\" + identifier + ';';\n+        }\n+    }\n+\n+    public static record ArrayTypeSigImpl(int arrayDepth, Signature elemType) implements Signature.ArrayTypeSig {\n+\n+        @Override\n+        public Signature componentSignature() {\n+            return arrayDepth > 1 ? new ArrayTypeSigImpl(arrayDepth - 1, elemType) : elemType;\n+        }\n+\n+        @Override\n+        public String signatureString() {\n+            return \"[\".repeat(arrayDepth) + elemType.signatureString();\n+        }\n+    }\n+\n+    public static record ClassTypeSigImpl(Optional<ClassTypeSig> outerType, String className, List<Signature> typeArgs)\n+            implements Signature.ClassTypeSig {\n+\n+        @Override\n+        public String signatureString() {\n+            String prefix = \"L\";\n+            if (outerType.isPresent()) {\n+                prefix = outerType.get().signatureString();\n+                assert prefix.charAt(prefix.length() - 1) == ';';\n+                prefix = prefix.substring(0, prefix.length() - 1) + '.';\n+            }\n+            String suffix = \";\";\n+            if (!typeArgs.isEmpty()) {\n+                var sb = new StringBuilder();\n+                sb.append('<');\n+                for (var ta : typeArgs)\n+                    sb.append(ta.signatureString());\n+                suffix = sb.append(\">;\").toString();\n+            }\n+            return prefix + className + suffix;\n+        }\n+    }\n+\n+    public static record TypeArgImpl(WildcardIndicator wildcardIndicator, Optional<RefTypeSig> boundType) implements Signature.TypeArg {\n+\n+        @Override\n+        public String signatureString() {\n+            return switch (wildcardIndicator) {\n+                case EXTENDS, SUPER -> wildcardIndicator.indicator + boundType.get().signatureString();\n+                case UNBOUNDED -> \"*\";\n+            };\n+        }\n+    }\n+\n+    public static record TypeParamImpl(String identifier, Optional<RefTypeSig> classBound, List<RefTypeSig> interfaceBounds)\n+            implements TypeParam {\n+    }\n+\n+    private static StringBuilder printTypeParameters(List<TypeParam> typeParameters) {\n+        var sb = new StringBuilder();\n+        if (typeParameters != null && !typeParameters.isEmpty()) {\n+            sb.append('<');\n+            for (var tp : typeParameters) {\n+                sb.append(tp.identifier()).append(':');\n+                if (tp.classBound().isPresent())\n+                    sb.append(tp.classBound().get().signatureString());\n+                if (tp.interfaceBounds() != null) for (var is : tp.interfaceBounds())\n+                    sb.append(':').append(is.signatureString());\n+            }\n+            sb.append('>');\n+        }\n+        return sb;\n+    }\n+\n+    public static record ClassSignatureImpl(List<TypeParam> typeParameters, RefTypeSig superclassSignature,\n+            List<RefTypeSig> superinterfaceSignatures) implements ClassSignature {\n+\n+        @Override\n+        public String signatureString() {\n+            var sb = printTypeParameters(typeParameters);\n+            sb.append(superclassSignature.signatureString());\n+            if (superinterfaceSignatures != null) for (var in : superinterfaceSignatures)\n+                sb.append(in.signatureString());\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static record MethodSignatureImpl(\n+            List<TypeParam> typeParameters,\n+            List<ThrowableSig> throwableSignatures,\n+            Signature result,\n+            List<Signature> arguments) implements MethodSignature {\n+\n+        @Override\n+        public String signatureString() {\n+            var sb = printTypeParameters(typeParameters);\n+            sb.append('(');\n+            for (var a : arguments)\n+                sb.append(a.signatureString());\n+            sb.append(')').append(result.signatureString());\n+            if (!throwableSignatures.isEmpty())\n+                for (var t : throwableSignatures)\n+                    sb.append('^').append(t.signatureString());\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static <T> List<T> null2Empty(ArrayList<T> l) {\n+        return l == null ? List.of() : Collections.unmodifiableList(l);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"},{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.FloatEntry;\n+import jdk.internal.classfile.constantpool.IntegerEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.MethodTypeEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import static jdk.internal.classfile.Classfile.TAG_CLASS;\n+import static jdk.internal.classfile.Classfile.TAG_CONSTANTDYNAMIC;\n+import static jdk.internal.classfile.Classfile.TAG_DOUBLE;\n+import static jdk.internal.classfile.Classfile.TAG_FIELDREF;\n+import static jdk.internal.classfile.Classfile.TAG_FLOAT;\n+import static jdk.internal.classfile.Classfile.TAG_INTEGER;\n+import static jdk.internal.classfile.Classfile.TAG_INTERFACEMETHODREF;\n+import static jdk.internal.classfile.Classfile.TAG_INVOKEDYNAMIC;\n+import static jdk.internal.classfile.Classfile.TAG_LONG;\n+import static jdk.internal.classfile.Classfile.TAG_METHODHANDLE;\n+import static jdk.internal.classfile.Classfile.TAG_METHODREF;\n+import static jdk.internal.classfile.Classfile.TAG_METHODTYPE;\n+import static jdk.internal.classfile.Classfile.TAG_MODULE;\n+import static jdk.internal.classfile.Classfile.TAG_NAMEANDTYPE;\n+import static jdk.internal.classfile.Classfile.TAG_PACKAGE;\n+import static jdk.internal.classfile.Classfile.TAG_STRING;\n+\n+\/**\n+ * ConstantPool.\n+ *\/\n+public final class SplitConstantPool implements ConstantPoolBuilder {\n+\n+    private final ClassReaderImpl parent;\n+    private final int parentSize, parentBsmSize;\n+    final Options options;\n+\n+    private int size, bsmSize;\n+    private PoolEntry[] myEntries;\n+    private ConcreteBootstrapMethodEntry[] myBsmEntries;\n+    private boolean doneFullScan;\n+    private EntryMap<PoolEntry> map;\n+    private EntryMap<ConcreteBootstrapMethodEntry> bsmMap;\n+\n+    public SplitConstantPool() {\n+        this(new Options(Collections.emptyList()));\n+    }\n+\n+    public SplitConstantPool(Options options) {\n+        this.size = 1;\n+        this.bsmSize = 0;\n+        this.myEntries = new PoolEntry[1024];\n+        this.myBsmEntries = new ConcreteBootstrapMethodEntry[8];\n+        this.parent = null;\n+        this.parentSize = 0;\n+        this.parentBsmSize = 0;\n+        this.options = options;\n+    }\n+\n+    public SplitConstantPool(ClassReader parent) {\n+        this.options = ((ClassReaderImpl) parent).options;\n+        this.parent = (ClassReaderImpl) parent;\n+        this.parentSize = parent.entryCount();\n+        this.parentBsmSize = parent.bootstrapMethodCount();\n+        this.size = parentSize;\n+        this.bsmSize = parentBsmSize;\n+        this.myEntries = new PoolEntry[8];\n+        this.myBsmEntries = new ConcreteBootstrapMethodEntry[8];\n+    }\n+\n+    @Override\n+    public int entryCount() {\n+        return size;\n+    }\n+\n+    @Override\n+    public int bootstrapMethodCount() {\n+        return bsmSize;\n+    }\n+\n+    @Override\n+    public PoolEntry entryByIndex(int index) {\n+        return (index < parentSize)\n+               ? parent.entryByIndex(index)\n+               : myEntries[index - parentSize];\n+    }\n+\n+    @Override\n+    public ConcreteBootstrapMethodEntry bootstrapMethodEntry(int index) {\n+        return (index < parentBsmSize)\n+               ? parent.bootstrapMethodEntry(index)\n+               : myBsmEntries[index - parentBsmSize];\n+    }\n+\n+    public Options options() {\n+        return options;\n+    }\n+\n+    @Override\n+    public boolean canWriteDirect(ConstantPool other) {\n+        return this == other || parent == other;\n+    }\n+\n+    @Override\n+    public boolean writeBootstrapMethods(BufWriter buf) {\n+        if (bsmSize == 0)\n+            return false;\n+        int pos = buf.size();\n+        if (parent != null && parentBsmSize != 0) {\n+            parent.writeBootstrapMethods(buf);\n+            for (int i = parentBsmSize; i < bsmSize; i++)\n+                bootstrapMethodEntry(i).writeTo(buf);\n+            int attrLen = buf.size() - pos;\n+            buf.patchInt(pos + 2, 4, attrLen - 6);\n+            buf.patchInt(pos + 6, 2, bsmSize);\n+            return true;\n+        }\n+        else {\n+            Attribute<BootstrapMethodsAttribute> a\n+                    = new UnboundAttribute.AdHocAttribute<>(Attributes.BOOTSTRAP_METHODS) {\n+\n+                @Override\n+                public void writeBody(BufWriter b) {\n+                    buf.writeU2(bsmSize);\n+                    for (int i = 0; i < bsmSize; i++)\n+                        bootstrapMethodEntry(i).writeTo(buf);\n+                }\n+            };\n+            a.writeTo(buf);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter buf) {\n+        int writeFrom = 1;\n+        buf.writeU2(entryCount());\n+        if (parent != null && buf.constantPool().canWriteDirect(this)) {\n+            parent.writeConstantPoolEntries(buf);\n+            writeFrom = parent.entryCount();\n+        }\n+        for (int i = writeFrom; i < entryCount(); ) {\n+            PoolEntry info = entryByIndex(i);\n+            info.writeTo(buf);\n+            i += info.width();\n+        }\n+    }\n+\n+    private EntryMap<PoolEntry> map() {\n+        if (map == null) {\n+            map = new EntryMap<>(Math.max(size, 1024), .75f) {\n+                @Override\n+                protected PoolEntry fetchElement(int index) {\n+                    return entryByIndex(index);\n+                }\n+            };\n+            \/\/ Doing a full scan here yields fall-off-the-cliff performance results,\n+            \/\/ especially if we only need a few entries that are already\n+            \/\/ inflated (such as attribute names).\n+            \/\/ So we inflate the map with whatever we've got from the parent, and\n+            \/\/ later, if we miss, we do a one-time full inflation before creating\n+            \/\/ a new entry.\n+            for (int i=1; i<parentSize; i++) {\n+                PoolEntry cpi = parent.cp[i];\n+                if (cpi != null)\n+                    map.put(cpi.hashCode(), cpi.index());\n+            }\n+            for (int i = Math.max(parentSize, 1); i < size; ) {\n+                PoolEntry cpi = myEntries[i - parentSize];\n+                map.put(cpi.hashCode(), cpi.index());\n+                i += cpi.width();\n+            }\n+        }\n+        return map;\n+    }\n+\n+    private void fullScan() {\n+        for (int i=1; i<parentSize;) {\n+            PoolEntry cpi = parent.entryByIndex(i);\n+            map.put(cpi.hashCode(), cpi.index());\n+            i += cpi.width();\n+        }\n+        doneFullScan = true;\n+    }\n+\n+    private EntryMap<ConcreteBootstrapMethodEntry> bsmMap() {\n+        if (bsmMap == null) {\n+            bsmMap = new EntryMap<>(Math.max(bsmSize, 16), .75f) {\n+                @Override\n+                protected ConcreteBootstrapMethodEntry fetchElement(int index) {\n+                    return bootstrapMethodEntry(index);\n+                }\n+            };\n+            for (int i=0; i<parentBsmSize; i++) {\n+                ConcreteBootstrapMethodEntry bsm = parent.bootstrapMethodEntry(i);\n+                bsmMap.put(bsm.hash, bsm.index);\n+            }\n+            for (int i = parentBsmSize; i < bsmSize; ++i) {\n+                ConcreteBootstrapMethodEntry bsm = myBsmEntries[i - parentBsmSize];\n+                bsmMap.put(bsm.hash, bsm.index);\n+            }\n+        }\n+        return bsmMap;\n+    }\n+\n+    private <E extends PoolEntry> E internalAdd(E cpi) {\n+        return internalAdd(cpi, cpi.hashCode());\n+    }\n+\n+    private <E extends PoolEntry> E internalAdd(E cpi, int hash) {\n+        int newIndex = size-parentSize;\n+        if (newIndex + 2 > myEntries.length) {\n+            myEntries = Arrays.copyOf(myEntries, 2 * newIndex, PoolEntry[].class);\n+        }\n+        myEntries[newIndex] = cpi;\n+        size += cpi.width();\n+        map().put(hash, cpi.index());\n+        return cpi;\n+    }\n+\n+    private ConcreteBootstrapMethodEntry internalAdd(ConcreteBootstrapMethodEntry bsm, int hash) {\n+        int newIndex = bsmSize-parentBsmSize;\n+        if (newIndex + 2 > myBsmEntries.length) {\n+            myBsmEntries = Arrays.copyOf(myBsmEntries, 2 * newIndex, ConcreteBootstrapMethodEntry[].class);\n+        }\n+        myBsmEntries[newIndex] = bsm;\n+        bsmSize += 1;\n+        bsmMap().put(hash, bsm.index);\n+        return bsm;\n+    }\n+\n+    private <T extends ConstantDesc> PoolEntry findPrimitiveEntry(int tag, T val) {\n+        int hash = ConcreteEntry.hash1(tag, val.hashCode());\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == tag\n+                && e instanceof ConcreteEntry.PrimitiveEntry<?> ce\n+                && ce.value().equals(val))\n+                return e;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findPrimitiveEntry(tag, val);\n+        }\n+        return null;\n+    }\n+\n+    private<T extends ConcreteEntry> ConcreteEntry findEntry(int tag, T ref1) {\n+        \/\/ invariant: canWriteDirect(ref1.constantPool())\n+        int hash = ConcreteEntry.hash1(tag, ref1.index());\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == tag\n+                && e instanceof ConcreteEntry.RefEntry<?> re\n+                && re.ref1 == ref1)\n+                return re;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findEntry(tag, ref1);\n+        }\n+        return null;\n+    }\n+\n+    private <T extends ConcreteEntry, U extends ConcreteEntry>\n+            ConcreteEntry findEntry(int tag, T ref1, U ref2) {\n+        \/\/ invariant: canWriteDirect(ref1.constantPool()), canWriteDirect(ref2.constantPool())\n+        int hash = ConcreteEntry.hash2(tag, ref1.index(), ref2.index());\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == tag\n+                    && e instanceof ConcreteEntry.RefsEntry<?, ?> re\n+                    && re.ref1 == ref1\n+                    && re.ref2 == ref2) {\n+                return re;\n+            }\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findEntry(tag, ref1, ref2);\n+        }\n+        return null;\n+    }\n+\n+    private<T> ConcreteEntry.ConcreteUtf8Entry tryFindUtf8(int hash, String target) {\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1;\n+             token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == Classfile.TAG_UTF8\n+                && e instanceof ConcreteEntry.ConcreteUtf8Entry ce\n+                && ce.hashCode() == hash\n+                && target.equals(ce.stringValue()))\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return tryFindUtf8(hash, target);\n+        }\n+        return null;\n+    }\n+\n+    private ConcreteEntry.ConcreteUtf8Entry tryFindUtf8(int hash, ConcreteEntry.ConcreteUtf8Entry target) {\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == Classfile.TAG_UTF8\n+                && e instanceof ConcreteEntry.ConcreteUtf8Entry ce\n+                && target.equalsUtf8(ce))\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return tryFindUtf8(hash, target);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ConcreteEntry.ConcreteUtf8Entry utf8Entry(String s) {\n+        var ce = tryFindUtf8(ConcreteEntry.hashString(s.hashCode()), s);\n+        return ce == null ? internalAdd(new ConcreteEntry.ConcreteUtf8Entry(this, size, s)) : ce;\n+    }\n+\n+    ConcreteEntry.ConcreteUtf8Entry maybeCloneUtf8Entry(Utf8Entry entry) {\n+        ConcreteEntry.ConcreteUtf8Entry e = (ConcreteEntry.ConcreteUtf8Entry) entry;\n+        if (e.constantPool == this || e.constantPool == parent)\n+            return e;\n+        ConcreteEntry.ConcreteUtf8Entry ce = tryFindUtf8(e.hashCode(), e);\n+        return ce == null ? internalAdd(new ConcreteEntry.ConcreteUtf8Entry(this, size, e)) : ce;\n+    }\n+\n+    @Override\n+    public ConcreteEntry.ConcreteClassEntry classEntry(Utf8Entry nameEntry) {\n+        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n+        var e = (ConcreteEntry.ConcreteClassEntry) findEntry(TAG_CLASS, ne);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteClassEntry(this, size, ne)) : e;\n+    }\n+\n+    @Override\n+    public PackageEntry packageEntry(Utf8Entry nameEntry) {\n+        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n+        var e = (ConcreteEntry.ConcretePackageEntry) findEntry(TAG_PACKAGE, ne);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcretePackageEntry(this, size, ne)) : e;\n+    }\n+\n+    @Override\n+    public ModuleEntry moduleEntry(Utf8Entry nameEntry) {\n+        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n+        var e = (ConcreteEntry.ConcreteModuleEntry) findEntry(TAG_MODULE, ne);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteModuleEntry(this, size, ne)) : e;\n+    }\n+\n+    @Override\n+    public ConcreteEntry.ConcreteNameAndTypeEntry natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n+        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n+        ConcreteEntry.ConcreteUtf8Entry te = maybeCloneUtf8Entry(typeEntry);\n+        var e = (ConcreteEntry.ConcreteNameAndTypeEntry) findEntry(TAG_NAMEANDTYPE, ne, te);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteNameAndTypeEntry(this, size, ne, te)) : e;\n+    }\n+\n+    @Override\n+    public FieldRefEntry fieldRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType) {\n+        ConcreteEntry.ConcreteClassEntry oe = (ConcreteEntry.ConcreteClassEntry) owner;\n+        ConcreteEntry.ConcreteNameAndTypeEntry ne = (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType;\n+        if (!canWriteDirect(oe.constantPool))\n+            oe = classEntry(owner.name());\n+        if (!canWriteDirect(ne.constantPool))\n+            ne = natEntry(nameAndType.name(), nameAndType.type());\n+        var e = (ConcreteEntry.ConcreteFieldRefEntry) findEntry(TAG_FIELDREF, oe, ne);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteFieldRefEntry(this, size, oe, ne)) : e;\n+    }\n+\n+    @Override\n+    public MethodRefEntry methodRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType) {\n+        ConcreteEntry.ConcreteClassEntry oe = (ConcreteEntry.ConcreteClassEntry) owner;\n+        ConcreteEntry.ConcreteNameAndTypeEntry ne = (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType;\n+        if (!canWriteDirect(oe.constantPool))\n+            oe = classEntry(owner.name());\n+        if (!canWriteDirect(ne.constantPool))\n+            ne = natEntry(nameAndType.name(), nameAndType.type());\n+        var e = (ConcreteEntry.ConcreteMethodRefEntry) findEntry(TAG_METHODREF, oe, ne);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteMethodRefEntry(this, size, oe, ne)) : e;\n+    }\n+\n+    @Override\n+    public InterfaceMethodRefEntry interfaceMethodRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType) {\n+        ConcreteEntry.ConcreteClassEntry oe = (ConcreteEntry.ConcreteClassEntry) owner;\n+        ConcreteEntry.ConcreteNameAndTypeEntry ne = (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType;\n+        if (!canWriteDirect(oe.constantPool))\n+            oe = classEntry(owner.name());\n+        if (!canWriteDirect(ne.constantPool))\n+            ne = natEntry(nameAndType.name(), nameAndType.type());\n+        var e = (ConcreteEntry.ConcreteInterfaceMethodRefEntry) findEntry(TAG_INTERFACEMETHODREF, oe, ne);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteInterfaceMethodRefEntry(this, size, oe, ne)) : e;\n+    }\n+\n+    @Override\n+    public MethodTypeEntry methodTypeEntry(MethodTypeDesc descriptor) {\n+        return methodTypeEntry(utf8Entry(descriptor.descriptorString()));\n+    }\n+\n+    @Override\n+    public MethodTypeEntry methodTypeEntry(Utf8Entry descriptor) {\n+        ConcreteEntry.ConcreteUtf8Entry de = maybeCloneUtf8Entry(descriptor);\n+        var e = (ConcreteEntry.ConcreteMethodTypeEntry) findEntry(TAG_METHODTYPE, de);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteMethodTypeEntry(this, size, de)) : e;\n+    }\n+\n+    @Override\n+    public MethodHandleEntry methodHandleEntry(int refKind, MemberRefEntry reference) {\n+        if (!canWriteDirect(reference.constantPool())) {\n+            reference = switch (reference.tag()) {\n+                case TAG_FIELDREF -> fieldRefEntry(reference.owner(), reference.nameAndType());\n+                case TAG_METHODREF -> methodRefEntry(reference.owner(), reference.nameAndType());\n+                case TAG_INTERFACEMETHODREF -> interfaceMethodRefEntry(reference.owner(), reference.nameAndType());\n+                default -> throw new IllegalStateException(String.format(\"Bad tag %d\", reference.tag()));\n+            };\n+        }\n+\n+        int hash = ConcreteEntry.hash2(TAG_METHODHANDLE, refKind, reference.index());\n+        EntryMap<PoolEntry> map1 = map();\n+        for (int token = map1.firstToken(hash); token != -1; token = map1.nextToken(hash, token)) {\n+            PoolEntry e = map1.getElementByToken(token);\n+            if (e.tag() == TAG_METHODHANDLE\n+                && e instanceof ConcreteEntry.ConcreteMethodHandleEntry ce\n+                && ce.kind() == refKind && ce.reference() == reference)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return methodHandleEntry(refKind, reference);\n+        }\n+        return internalAdd(new ConcreteEntry.ConcreteMethodHandleEntry(this, size, hash, refKind, (ConcreteEntry.MemberRefEntry) reference), hash);\n+    }\n+\n+    @Override\n+    public InvokeDynamicEntry invokeDynamicEntry(BootstrapMethodEntry bootstrapMethodEntry,\n+                                                 NameAndTypeEntry nameAndType) {\n+        if (!canWriteDirect(bootstrapMethodEntry.constantPool()))\n+            bootstrapMethodEntry = bsmEntry(bootstrapMethodEntry.bootstrapMethod(),\n+                                            bootstrapMethodEntry.arguments());\n+        if (!canWriteDirect(nameAndType.constantPool()))\n+            nameAndType = natEntry(nameAndType.name(), nameAndType.type());\n+        int hash = ConcreteEntry.hash2(TAG_INVOKEDYNAMIC, bootstrapMethodEntry.bsmIndex(), nameAndType.index());\n+        EntryMap<PoolEntry> map1 = map();\n+        for (int token = map1.firstToken(hash); token != -1; token = map1.nextToken(hash, token)) {\n+            PoolEntry e = map1.getElementByToken(token);\n+            if (e.tag() == TAG_INVOKEDYNAMIC\n+                && e instanceof ConcreteEntry.ConcreteInvokeDynamicEntry ce\n+                && ce.bootstrap() == bootstrapMethodEntry && ce.nameAndType() == nameAndType)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return invokeDynamicEntry(bootstrapMethodEntry, nameAndType);\n+        }\n+\n+        ConcreteEntry.ConcreteInvokeDynamicEntry ce = new ConcreteEntry.ConcreteInvokeDynamicEntry(this, size, hash, (ConcreteBootstrapMethodEntry) bootstrapMethodEntry, (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        internalAdd(ce, hash);\n+        return ce;\n+    }\n+\n+    @Override\n+    public ConstantDynamicEntry constantDynamicEntry(BootstrapMethodEntry bootstrapMethodEntry,\n+                                                     NameAndTypeEntry nameAndType) {\n+        if (!canWriteDirect(bootstrapMethodEntry.constantPool()))\n+            bootstrapMethodEntry = bsmEntry(bootstrapMethodEntry.bootstrapMethod(),\n+                                            bootstrapMethodEntry.arguments());\n+        if (!canWriteDirect(nameAndType.constantPool()))\n+            nameAndType = natEntry(nameAndType.name(), nameAndType.type());\n+        int hash = ConcreteEntry.hash2(TAG_CONSTANTDYNAMIC, bootstrapMethodEntry.bsmIndex(), nameAndType.index());\n+        EntryMap<PoolEntry> map1 = map();\n+        for (int token = map1.firstToken(hash); token != -1; token = map1.nextToken(hash, token)) {\n+            PoolEntry e = map1.getElementByToken(token);\n+            if (e.tag() == TAG_CONSTANTDYNAMIC\n+                && e instanceof ConcreteEntry.ConcreteConstantDynamicEntry ce\n+                && ce.bootstrap() == bootstrapMethodEntry && ce.nameAndType() == nameAndType)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return constantDynamicEntry(bootstrapMethodEntry, nameAndType);\n+        }\n+\n+        ConcreteEntry.ConcreteConstantDynamicEntry ce = new ConcreteEntry.ConcreteConstantDynamicEntry(this, size, hash, (ConcreteBootstrapMethodEntry) bootstrapMethodEntry, (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        internalAdd(ce, hash);\n+        return ce;\n+    }\n+\n+    @Override\n+    public IntegerEntry intEntry(int value) {\n+        var e = (IntegerEntry) findPrimitiveEntry(TAG_INTEGER, value);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteIntegerEntry(this, size, value)) : e;\n+    }\n+\n+    @Override\n+    public FloatEntry floatEntry(float value) {\n+        var e = (FloatEntry) findPrimitiveEntry(TAG_FLOAT, value);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteFloatEntry(this, size, value)) : e;\n+    }\n+\n+    @Override\n+    public LongEntry longEntry(long value) {\n+        var e = (LongEntry) findPrimitiveEntry(TAG_LONG, value);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteLongEntry(this, size, value)) : e;\n+    }\n+\n+    @Override\n+    public DoubleEntry doubleEntry(double value) {\n+        var e = (DoubleEntry) findPrimitiveEntry(TAG_DOUBLE, value);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteDoubleEntry(this, size, value)) : e;\n+    }\n+\n+    @Override\n+    public StringEntry stringEntry(Utf8Entry utf8) {\n+        ConcreteEntry.ConcreteUtf8Entry ue = maybeCloneUtf8Entry(utf8);\n+        var e = (ConcreteEntry.ConcreteStringEntry) findEntry(TAG_STRING, ue);\n+        return e == null ? internalAdd(new ConcreteEntry.ConcreteStringEntry(this, size, ue)) : e;\n+    }\n+\n+    @Override\n+    public BootstrapMethodEntry bsmEntry(MethodHandleEntry methodReference,\n+                                         List<LoadableConstantEntry> arguments) {\n+        if (!canWriteDirect(methodReference.constantPool()))\n+            methodReference = methodHandleEntry(methodReference.kind(), methodReference.reference());\n+        for (LoadableConstantEntry a : arguments) {\n+            if (!canWriteDirect(a.constantPool())) {\n+                \/\/ copy args list\n+                LoadableConstantEntry[] arr = arguments.toArray(new LoadableConstantEntry[0]);\n+                for (int i = 0; i < arr.length; i++)\n+                    arr[i] = ConcreteEntry.maybeClone(this, arr[i]);\n+                arguments = List.of(arr);\n+\n+                break;\n+            }\n+        }\n+        ConcreteEntry.ConcreteMethodHandleEntry mre = (ConcreteEntry.ConcreteMethodHandleEntry) methodReference;\n+        int hash = ConcreteBootstrapMethodEntry.computeHashCode(mre, arguments);\n+        EntryMap<ConcreteBootstrapMethodEntry> map = bsmMap();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            ConcreteBootstrapMethodEntry e = map.getElementByToken(token);\n+            if (e.bootstrapMethod() == mre && e.arguments().equals(arguments)) {\n+                return e;\n+            }\n+        }\n+        ConcreteBootstrapMethodEntry ne = new ConcreteBootstrapMethodEntry(this, bsmSize, hash, mre, arguments);\n+        return internalAdd(ne, hash);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.List;\n+import java.util.TreeMap;\n+import jdk.internal.classfile.BufWriter;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute.*;\n+import jdk.internal.classfile.ClassReader;\n+\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.MethodModel;\n+\n+public class StackMapDecoder {\n+\n+    private static final int\n+                    SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247,\n+                    SAME_EXTENDED = 251;\n+\n+    private final ClassReader classReader;\n+    private final int pos;\n+    private final LabelContext ctx;\n+    private final List<VerificationTypeInfo> initFrameLocals;\n+    private int p;\n+\n+    StackMapDecoder(ClassReader classReader, int pos, LabelContext ctx, List<VerificationTypeInfo> initFrameLocals) {\n+        this.classReader = classReader;\n+        this.pos = pos;\n+        this.ctx = ctx;\n+        this.initFrameLocals = initFrameLocals;\n+    }\n+\n+    static List<VerificationTypeInfo> initFrameLocals(MethodModel method) {\n+        return initFrameLocals(method.parent().orElseThrow().thisClass(),\n+                method.methodName().stringValue(),\n+                method.methodType().stringValue(),\n+                method.flags().has(AccessFlag.STATIC));\n+    }\n+\n+    public static List<VerificationTypeInfo> initFrameLocals(ClassEntry thisClass, String methodName, String methodType, boolean isStatic) {\n+        var mdesc = MethodTypeDesc.ofDescriptor(methodType);\n+        VerificationTypeInfo vtis[];\n+        int i = 0;\n+        if (!isStatic) {\n+            vtis = new VerificationTypeInfo[mdesc.parameterCount() + 1];\n+            if (\"<init>\".equals(methodName) && !ConstantDescs.CD_Object.equals(thisClass.asSymbol())) {\n+                vtis[i++] = SimpleVerificationTypeInfo.ITEM_UNINITIALIZED_THIS;\n+            } else {\n+                vtis[i++] = new StackMapDecoder.ObjectVerificationTypeInfoImpl(thisClass);\n+            }\n+        } else {\n+            vtis = new VerificationTypeInfo[mdesc.parameterCount()];\n+        }\n+        for(var arg : mdesc.parameterList()) {\n+            vtis[i++] = switch (arg.descriptorString()) {\n+                case \"I\", \"S\", \"C\" ,\"B\", \"Z\" ->  SimpleVerificationTypeInfo.ITEM_INTEGER;\n+                case \"J\" -> SimpleVerificationTypeInfo.ITEM_LONG;\n+                case \"F\" -> SimpleVerificationTypeInfo.ITEM_FLOAT;\n+                case \"D\" -> SimpleVerificationTypeInfo.ITEM_DOUBLE;\n+                case \"V\" -> throw new IllegalArgumentException(\"Illegal method argument type: \" + arg);\n+                default -> new StackMapDecoder.ObjectVerificationTypeInfoImpl(TemporaryConstantPool.INSTANCE.classEntry(arg));\n+            };\n+        }\n+        return List.of(vtis);\n+    }\n+\n+    public static void writeFrames(BufWriter b, List<StackMapFrameInfo> entries) {\n+        var buf = (BufWriterImpl)b;\n+        var dcb = (DirectCodeBuilder)buf.labelContext();\n+        var mi = dcb.methodInfo();\n+        var prevLocals = StackMapDecoder.initFrameLocals(buf.thisClass(),\n+                mi.methodName().stringValue(),\n+                mi.methodType().stringValue(),\n+                (mi.methodFlags() & ACC_STATIC) != 0);\n+        int prevOffset = -1;\n+        var map = new TreeMap<Integer, StackMapFrameInfo>();\n+        \/\/sort by resolved label offsets first to allow unordered entries\n+        for (var fr : entries) {\n+            map.put(dcb.labelToBci(fr.target()), fr);\n+        }\n+        b.writeU2(map.size());\n+        for (var me : map.entrySet()) {\n+            int offset = me.getKey();\n+            var fr = me.getValue();\n+            writeFrame(buf, offset - prevOffset - 1, prevLocals, fr);\n+            prevOffset = offset;\n+            prevLocals = fr.locals();\n+        }\n+    }\n+\n+    private static void writeFrame(BufWriterImpl out, int offsetDelta, List<VerificationTypeInfo> prevLocals, StackMapFrameInfo fr) {\n+        if (offsetDelta < 0) throw new IllegalArgumentException(\"Invalid stack map frames order\");\n+        if (fr.stack().isEmpty()) {\n+            int commonLocalsSize = Math.min(prevLocals.size(), fr.locals().size());\n+            int diffLocalsSize = fr.locals().size() - prevLocals.size();\n+            if (-3 <= diffLocalsSize && diffLocalsSize <= 3 && equals(fr.locals(), prevLocals, commonLocalsSize)) {\n+                if (diffLocalsSize == 0 && offsetDelta < 64) { \/\/same frame\n+                    out.writeU1(offsetDelta);\n+                } else {   \/\/chop, same extended or append frame\n+                    out.writeU1(251 + diffLocalsSize);\n+                    out.writeU2(offsetDelta);\n+                    for (int i=commonLocalsSize; i<fr.locals().size(); i++) writeTypeInfo(out, fr.locals().get(i));\n+                }\n+                return;\n+            }\n+        } else if (fr.stack().size() == 1 && fr.locals().equals(prevLocals)) {\n+            if (offsetDelta < 64) {  \/\/same locals 1 stack item frame\n+                out.writeU1(64 + offsetDelta);\n+            } else {  \/\/same locals 1 stack item extended frame\n+                out.writeU1(247);\n+                out.writeU2(offsetDelta);\n+            }\n+            writeTypeInfo(out, fr.stack().get(0));\n+            return;\n+        }\n+        \/\/full frame\n+        out.writeU1(255);\n+        out.writeU2(offsetDelta);\n+        out.writeU2(fr.locals().size());\n+        for (var l : fr.locals()) writeTypeInfo(out, l);\n+        out.writeU2(fr.stack().size());\n+        for (var s : fr.stack()) writeTypeInfo(out, s);\n+    }\n+\n+    private static boolean equals(List<VerificationTypeInfo> l1, List<VerificationTypeInfo> l2, int compareSize) {\n+        for (int i = 0; i < compareSize; i++) {\n+            if (!l1.get(i).equals(l2.get(i))) return false;\n+        }\n+        return true;\n+    }\n+\n+    private static void writeTypeInfo(BufWriterImpl bw, VerificationTypeInfo vti) {\n+        bw.writeU1(vti.tag());\n+        switch (vti) {\n+            case SimpleVerificationTypeInfo svti ->\n+                {}\n+            case ObjectVerificationTypeInfo ovti ->\n+                bw.writeIndex(ovti.className());\n+            case UninitializedVerificationTypeInfo uvti ->\n+                bw.writeU2(bw.labelContext().labelToBci(uvti.newTarget()));\n+        }\n+    }\n+\n+    List<StackMapFrameInfo> entries() {\n+        p = pos;\n+        List<VerificationTypeInfo> locals = initFrameLocals, stack = List.of();\n+        int bci = -1;\n+        var entries = new StackMapFrameInfo[u2()];\n+        for (int ei = 0; ei < entries.length; ei++) {\n+            int frameType = classReader.readU1(p++);\n+            if (frameType < 64) {\n+                bci += frameType + 1;\n+                stack = List.of();\n+            } else if (frameType < 128) {\n+                bci += frameType - 63;\n+                stack = List.of(readVerificationTypeInfo(bci));\n+            } else {\n+                if (frameType < SAME_LOCALS_1_STACK_ITEM_EXTENDED)\n+                    throw new IllegalArgumentException(\"Invalid stackmap frame type: \" + frameType);\n+                bci += u2() + 1;\n+                if (frameType == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+                    stack = List.of(readVerificationTypeInfo(bci));\n+                } else if (frameType < SAME_EXTENDED) {\n+                    locals = locals.subList(0, locals.size() + frameType - SAME_EXTENDED);\n+                    stack = List.of();\n+                } else if (frameType == SAME_EXTENDED) {\n+                    stack = List.of();\n+                } else if (frameType < SAME_EXTENDED + 4) {\n+                    int actSize = locals.size();\n+                    var newLocals = locals.toArray(new VerificationTypeInfo[actSize + frameType - SAME_EXTENDED]);\n+                    for (int i = actSize; i < newLocals.length; i++)\n+                        newLocals[i] = readVerificationTypeInfo(bci);\n+                    locals = List.of(newLocals);\n+                    stack = List.of();\n+                } else {\n+                    var newLocals = new VerificationTypeInfo[u2()];\n+                    for (int i=0; i<newLocals.length; i++)\n+                        newLocals[i] = readVerificationTypeInfo(bci);\n+                    var newStack = new VerificationTypeInfo[u2()];\n+                    for (int i=0; i<newStack.length; i++)\n+                        newStack[i] = readVerificationTypeInfo(bci);\n+                    locals = List.of(newLocals);\n+                    stack = List.of(newStack);\n+                }\n+            }\n+            entries[ei] = new StackMapFrameImpl(frameType,\n+                        ctx.getLabel(bci),\n+                        locals,\n+                        stack);\n+        }\n+        return List.of(entries);\n+    }\n+\n+    private VerificationTypeInfo readVerificationTypeInfo(int bci) {\n+        int tag = classReader.readU1(p++);\n+        return switch (tag) {\n+            case VT_TOP -> SimpleVerificationTypeInfo.ITEM_TOP;\n+            case VT_INTEGER -> SimpleVerificationTypeInfo.ITEM_INTEGER;\n+            case VT_FLOAT -> SimpleVerificationTypeInfo.ITEM_FLOAT;\n+            case VT_DOUBLE -> SimpleVerificationTypeInfo.ITEM_DOUBLE;\n+            case VT_LONG -> SimpleVerificationTypeInfo.ITEM_LONG;\n+            case VT_NULL -> SimpleVerificationTypeInfo.ITEM_NULL;\n+            case VT_UNINITIALIZED_THIS -> SimpleVerificationTypeInfo.ITEM_UNINITIALIZED_THIS;\n+            case VT_OBJECT -> new ObjectVerificationTypeInfoImpl((ClassEntry)classReader.entryByIndex(u2()));\n+            case VT_UNINITIALIZED -> new UninitializedVerificationTypeInfoImpl(ctx.getLabel(u2()));\n+            default -> throw new IllegalArgumentException(\"Invalid verification type tag: \" + tag);\n+        };\n+    }\n+\n+    public static record ObjectVerificationTypeInfoImpl(\n+            ClassEntry className) implements ObjectVerificationTypeInfo {\n+\n+        @Override\n+        public int tag() { return VT_OBJECT; }\n+\n+        @Override\n+        public String toString() {\n+            return className.asInternalName();\n+        }\n+    }\n+\n+    public static record UninitializedVerificationTypeInfoImpl(Label newTarget) implements UninitializedVerificationTypeInfo {\n+\n+        @Override\n+        public int tag() { return VT_UNINITIALIZED; }\n+\n+        @Override\n+        public String toString() {\n+            return \"UNINIT(\" + newTarget +\")\";\n+        }\n+    }\n+\n+    private int u2() {\n+        int v = classReader.readU2(p);\n+        p += 2;\n+        return v;\n+    }\n+\n+    public static record StackMapFrameImpl(int frameType,\n+                                           Label target,\n+                                           List<VerificationTypeInfo> locals,\n+                                           List<VerificationTypeInfo> stack)\n+            implements StackMapFrameInfo {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,1424 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.DynamicConstantPoolEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.Attribute;\n+\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+\n+\/**\n+ * StackMapGenerator is responsible for stack map frames generation.\n+ * <p>\n+ * Stack map frames are computed from serialized bytecode similar way they are verified during class loading process.\n+ * <p>\n+ * The {@linkplain #generate() frames computation} consists of following steps:\n+ * <ol>\n+ * <li>{@linkplain #detectFrameOffsets() Detection} of mandatory stack map frames offsets:<ul>\n+ *      <li>Mandatory stack map frame offsets include all jump and switch instructions targets,\n+ *          offsets immediately following {@linkplain #noControlFlow(int) \"no control flow\"}\n+ *          and all exception table handlers.\n+ *      <li>Detection is performed in a single fast pass through the bytecode,\n+ *          with no auxiliary structures construction nor further instructions processing.\n+ * <\/ul>\n+ * <li>Generator loop {@linkplain #processMethod() processing bytecode instructions}:<ul>\n+ *      <li>Generator loop simulates sequence instructions {@linkplain #processBlock(RawBytecodeHelper) processing effect on the actual stack and locals}.\n+ *      <li>All mandatory {@linkplain Frame frames} detected in the step #1 are {@linkplain Frame#checkAssignableTo(Frame) retro-filled}\n+ *          (or {@linkplain Frame#merge(Type, Type[], int, Frame) reverse-merged} in subsequent processing)\n+ *          with the actual stack and locals for all matching jump, switch and exception handler targets.\n+ *      <li>All frames modified by reverse merges are marked as {@linkplain Frame#dirty dirty} for further processing.\n+ *      <li>Code blocks with not yet known entry frame content are skipped and related frames are also marked as dirty.\n+ *      <li>Generator loop process is repeated until all mandatory frames are cleared or until an error state is reached.\n+ *      <li>Generator loop always passes all instructions at least once to calculate {@linkplain #maxStack max stack}\n+ *          and {@linkplain #maxLocals max locals} code attributes.\n+ *      <li>More than one pass is usually not necessary, except for more complex bytecode sequences.<br>\n+ *          <i>(Note: experimental measurements showed that more than 99% of the cases required only single pass to clear all frames,\n+ *          less than 1% of the cases required second pass and remaining 0,01% of the cases required third pass to clear all frames.)<\/i>.\n+ * <\/ul>\n+ * <li>Dead code patching to pass class loading verification:<ul>\n+ *      <li>Dead code blocks are indicated by frames remaining without content after leaving the Generator loop.\n+ *      <li>Each dead code block is filled with <code>NOP<\/code> instructions, terminated with\n+ *          <code>ATHROW<\/code> instruction, and removed from exception handlers table.\n+ *      <li>Dead code block entry frame is set to <code>java.lang.Throwable<\/code> single stack item and no locals.\n+ * <\/ul>\n+ * <\/ol>\n+ * <p>\n+ * {@linkplain Frame#merge(Type, Type[], int, Frame) Reverse-merge} of the stack map frames\n+ * may in some situations require to determine {@linkplain ClassHierarchyImpl class hierarchy} relations.\n+ * <p>\n+ * Reverse-merge of individual {@linkplain Type types} is performed when a target frame has already been retro-filled\n+ * and it is necessary to adjust its existing stack entries and locals to also match actual stack map frame conditions.\n+ * Following tables describe how new target stack entry or local type is calculated, based on the actual frame stack entry or local (\"from\")\n+ * and actual value of the target stack entry or local (\"to\").\n+ *\n+ * <table border=\"1\">\n+ * <caption>Reverse-merge of general type categories<\/caption>\n+ * <tr><th>to \\ from<th>TOP<th>PRIMITIVE<th>UNINITIALIZED<th>REFERENCE\n+ * <tr><th>TOP<td>TOP<td>TOP<td>TOP<td>TOP\n+ * <tr><th>PRIMITIVE<td>TOP<td><a href=\"#primitives\">Reverse-merge of primitive types<\/a><td>TOP<td>TOP\n+ * <tr><th>UNINITIALIZED<td>TOP<td>TOP<td>Is NEW offset matching ? UNINITIALIZED : TOP<td>TOP\n+ * <tr><th>REFERENCE<td>TOP<td>TOP<td>TOP<td><a href=\"#references\">Reverse-merge of reference types<\/a>\n+ * <\/table>\n+ * <p>\n+ * <table id=\"primitives\" border=\"1\">\n+ * <caption>Reverse-merge of primitive types<\/caption>\n+ * <tr><th>to \\ from<th>SHORT<th>BYTE<th>BOOLEAN<th>LONG<th>DOUBLE<th>FLOAT<th>INTEGER\n+ * <tr><th>SHORT<td>SHORT<td>TOP<td>TOP<td>TOP<td>TOP<td>TOP<td>SHORT\n+ * <tr><th>BYTE<td>TOP<td>BYTE<td>TOP<td>TOP<td>TOP<td>TOP<td>BYTE\n+ * <tr><th>BOOLEAN<td>TOP<td>TOP<td>BOOLEAN<td>TOP<td>TOP<td>TOP<td>BOOLEAN\n+ * <tr><th>LONG<td>TOP<td>TOP<td>TOP<td>LONG<td>TOP<td>TOP<td>TOP\n+ * <tr><th>DOUBLE<td>TOP<td>TOP<td>TOP<td>TOP<td>DOUBLE<td>TOP<td>TOP\n+ * <tr><th>FLOAT<td>TOP<td>TOP<td>TOP<td>TOP<td>TOP<td>FLOAT<td>TOP\n+ * <tr><th>INTEGER<td>TOP<td>TOP<td>TOP<td>TOP<td>TOP<td>TOP<td>INTEGER\n+ * <\/table>\n+ * <p>\n+ * <table id=\"references\" border=\"1\">\n+ * <caption>Reverse merge of reference types<\/caption>\n+ * <tr><th>to \\ from<th>NULL<th>j.l.Object<th>j.l.Cloneable<th>j.i.Serializable<th>ARRAY<th>INTERFACE*<th>OBJECT**\n+ * <tr><th>NULL<td>NULL<td>j.l.Object<td>j.l.Cloneable<td>j.i.Serializable<td>ARRAY<td>INTERFACE<td>OBJECT\n+ * <tr><th>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object\n+ * <tr><th>j.l.Cloneable<td>j.l.Cloneable<td>j.l.Cloneable<td>j.l.Cloneable<td>j.l.Cloneable<td>j.l.Object<td>j.l.Cloneable<td>j.l.Cloneable\n+ * <tr><th>j.i.Serializable<td>j.i.Serializable<td>j.i.Serializable<td>j.i.Serializable<td>j.i.Serializable<td>j.l.Object<td>j.i.Serializable<td>j.i.Serializable\n+ * <tr><th>ARRAY<td>ARRAY<td>j.l.Object<td>j.l.Object<td>j.l.Object<td><a href=\"#arrays\">Reverse merge of arrays<\/a><td>j.l.Object<td>j.l.Object\n+ * <tr><th>INTERFACE*<td>INTERFACE<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object\n+ * <tr><th>OBJECT**<td>OBJECT<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>j.l.Object<td>Resolved common ancestor\n+ * <tr><td colspan=\"8\">*any interface reference except for j.l.Cloneable and j.i.Serializable<br>**any object reference except for j.l.Object\n+ * <\/table>\n+ * <p id=\"arrays\">\n+ * Array types are reverse-merged as reference to array type constructed from reverse-merged components.\n+ * Reference to j.l.Object is an alternate result when construction of the array type is not possible (when reverse-merge of components returned TOP or other non-reference and non-primitive type).\n+ * <p>\n+ * Custom class hierarchy resolver has been implemented as a part of the library to avoid heavy class loading\n+ * and to allow stack maps generation even for code with incomplete dependency classpath.\n+ * However stack maps generated with {@linkplain ClassHierarchyImpl#resolve(java.lang.constant.ClassDesc) warnings of unresolved dependencies} may later fail to verify during class loading process.\n+ * <p>\n+ * Focus of the whole algorithm is on high performance and low memory footprint:<ul>\n+ *      <li>It does not produce, collect nor visit any complex intermediate structures\n+ *          <i>(beside {@linkplain RawBytecodeHelper traversing} the {@linkplain #bytecode bytecode in binary form}).<\/i>\n+ *      <li>It works with only minimal mandatory stack map frames.\n+ *      <li>It does not spend time on any non-essential verifications.\n+ * <\/ul>\n+ * <p>\n+ * In case of an exception during the Generator loop there is just minimal information available in the exception message.\n+ * <p>\n+ * To determine root cause of the exception it is recommended to enable debug logging of the Generator in one of the two modes\n+ * using following <code>java.lang.System<\/code> properties:<dl>\n+ * <dt><code>-Djdk.internal.classfile.impl.StackMapGenerator.DEBUG=true<\/code>\n+ *      <dd>Activates debug logging with basic information + generated stack map frames in case of success.\n+ *          It also re-runs with enabled full trace logging in case of an error or exception.\n+ * <dt><code>-Djdk.internal.classfile.impl.StackMapGenerator.TRACE=true<\/code>\n+ *      <dd>Activates full detailed tracing of the generator process for all invocations.\n+ * <\/dl>\n+ *\/\n+\n+public final class StackMapGenerator {\n+\n+    private static final String OBJECT_INITIALIZER_NAME = \"<init>\";\n+    private static final int FLAG_THIS_UNINIT = 0x01;\n+    private static final int FRAME_DEFAULT_CAPACITY = 10;\n+    private static final int T_BOOLEAN = 4, T_LONG = 11;\n+\n+    private static final int ITEM_TOP = 0,\n+            ITEM_INTEGER = 1,\n+            ITEM_FLOAT = 2,\n+            ITEM_DOUBLE = 3,\n+            ITEM_LONG = 4,\n+            ITEM_NULL = 5,\n+            ITEM_UNINITIALIZED_THIS = 6,\n+            ITEM_OBJECT = 7,\n+            ITEM_UNINITIALIZED = 8,\n+            ITEM_BOOLEAN = 9,\n+            ITEM_BYTE = 10,\n+            ITEM_SHORT = 11,\n+            ITEM_CHAR = 12,\n+            ITEM_LONG_2ND = 13,\n+            ITEM_DOUBLE_2ND = 14;\n+\n+    private static final Type[] ARRAY_FROM_BASIC_TYPE = {null, null, null, null,\n+        Type.BOOLEAN_ARRAY_TYPE, Type.CHAR_ARRAY_TYPE, Type.FLOAT_ARRAY_TYPE, Type.DOUBLE_ARRAY_TYPE,\n+        Type.BYTE_ARRAY_TYPE, Type.SHORT_ARRAY_TYPE, Type.INT_ARRAY_TYPE, Type.LONG_ARRAY_TYPE};\n+\n+    private final Type thisType;\n+    private final String methodName;\n+    private final MethodTypeDesc methodDesc;\n+    private final ByteBuffer bytecode;\n+    private final SplitConstantPool cp;\n+    private final boolean isStatic;\n+    private final LabelContext labelContext;\n+    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> exceptionTable;\n+    private final ClassHierarchyImpl classHierarchy;\n+    private final boolean patchDeadCode;\n+    private List<Frame> frames;\n+    private final Frame currentFrame;\n+    private int maxStack, maxLocals;\n+\n+    \/**\n+     * Primary constructor of the <code>Generator<\/code> class.\n+     * New <code>Generator<\/code> instance must be created for each individual class\/method.\n+     * Instance contains only immutable results, all the calculations are processed during instance construction.\n+     *\n+     * @param labelContext <code>LableContext<\/code> instance used to resolve or patch <code>ExceptionHandler<\/code>\n+     * labels to bytecode offsets (or vice versa)\n+     * @param thisClass class to generate stack maps for\n+     * @param methodName method name to generate stack maps for\n+     * @param methodDesc method descriptor to generate stack maps for\n+     * @param isStatic information whether the method is static\n+     * @param bytecode R\/W <code>ByteBuffer<\/code> wrapping method bytecode, the content is altered in case <code>Generator<\/code> detects  and patches dead code\n+     * @param cp R\/W <code>ConstantPoolBuilder<\/code> instance used to resolve all involved CP entries and also generate new entries referenced from the generted stack maps\n+     * @param handlers R\/W <code>ExceptionHandler<\/code> list used to detect mandatory frame offsets as well as to determine stack maps in exception handlers\n+     * and also to be altered when dead code is detected and must be excluded from exception handlers\n+     *\/\n+    public StackMapGenerator(LabelContext labelContext,\n+                     ClassDesc thisClass,\n+                     String methodName,\n+                     MethodTypeDesc methodDesc,\n+                     boolean isStatic,\n+                     ByteBuffer bytecode,\n+                     SplitConstantPool cp,\n+                     List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {\n+        this.thisType = Type.referenceType(thisClass);\n+        this.methodName = methodName;\n+        this.methodDesc = methodDesc;\n+        this.isStatic = isStatic;\n+        this.bytecode = bytecode;\n+        this.cp = cp;\n+        this.labelContext = labelContext;\n+        this.exceptionTable = handlers;\n+        this.classHierarchy = new ClassHierarchyImpl(cp.options().classHierarchyResolver);\n+        this.patchDeadCode = cp.options().patchCode;\n+        this.currentFrame = new Frame(classHierarchy);\n+        generate();\n+    }\n+\n+    \/**\n+     * Calculated maximum number of the locals required\n+     * @return maximum number of the locals required\n+     *\/\n+    public int maxLocals() {\n+        return maxLocals;\n+    }\n+\n+    \/**\n+     * Calculated maximum stack size required\n+     * @return maximum stack size required\n+     *\/\n+    public int maxStack() {\n+        return maxStack;\n+    }\n+\n+    private int getFrameIndexFromOffset(int offset) {\n+        int i = 0;\n+        for (; i < frames.size(); i++) {\n+            if (frames.get(i).offset == offset) {\n+                return i;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    private void checkJumpTarget(Frame frame, int target) {\n+        int index = getFrameIndexFromOffset(target);\n+        frame.checkAssignableTo(frames.get(index));\n+    }\n+\n+    private int exMin, exMax;\n+\n+    private boolean isAnyFrameDirty() {\n+        for (var f : frames) {\n+            if (f.dirty) return true;\n+        }\n+        return false;\n+    }\n+\n+    private void generate() {\n+        exMin = bytecode.capacity();\n+        exMax = -1;\n+        for (var exhandler : exceptionTable) {\n+            int start_pc = labelContext.labelToBci(exhandler.tryStart());\n+            int end_pc = labelContext.labelToBci(exhandler.tryEnd());\n+            if (start_pc < exMin) exMin = start_pc;\n+            if (end_pc > exMax) exMax = end_pc;\n+        }\n+        BitSet frameOffsets = detectFrameOffsets();\n+        int framesCount = frameOffsets.cardinality();\n+        frames = new ArrayList<>(framesCount);\n+        int offset = -1;\n+        for (int i = 0; i < framesCount; i++) {\n+            offset = frameOffsets.nextSetBit(offset + 1);\n+            frames.add(new Frame(offset, classHierarchy));\n+        }\n+        do {\n+            processMethod();\n+        } while (isAnyFrameDirty());\n+        maxLocals = currentFrame.frameMaxLocals;\n+        maxStack = currentFrame.frameMaxStack;\n+\n+        \/\/dead code patching\n+        for (int i = 0; i < framesCount; i++) {\n+            var frame = frames.get(i);\n+            if (frame.flags == -1) {\n+                if (!patchDeadCode) generatorError(\"Unable to generate stack map frame for dead code\", frame.offset);\n+                \/\/patch frame\n+                frame.pushStack(Type.THROWABLE_TYPE);\n+                if (maxStack < 1) maxStack = 1;\n+                int blockSize = (i < framesCount - 1 ? frames.get(i + 1).offset : bytecode.limit()) - frame.offset;\n+                \/\/patch bytecode\n+                bytecode.position(frame.offset);\n+                for (int n=1; n<blockSize; n++) {\n+                    bytecode.put((byte) Classfile.NOP);\n+                }\n+                bytecode.put((byte) Classfile.ATHROW);\n+                \/\/patch handlers\n+                removeRangeFromExcTable(frame.offset, frame.offset + blockSize);\n+            }\n+        }\n+    }\n+\n+    private void removeRangeFromExcTable(int rangeStart, int rangeEnd) {\n+        var it = exceptionTable.listIterator();\n+        while (it.hasNext()) {\n+            var e = it.next();\n+            int handlerStart = labelContext.labelToBci(e.tryStart());\n+            int handlerEnd = labelContext.labelToBci(e.tryEnd());\n+            if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) {\n+                \/\/out of range\n+                continue;\n+            }\n+            if (rangeStart <= handlerStart) {\n+              if (rangeEnd >= handlerEnd) {\n+                  \/\/complete removal\n+                  it.remove();\n+              } else {\n+                  \/\/cut from left\n+                  Label newStart = labelContext.newLabel();\n+                  labelContext.setLabelTarget(newStart, rangeEnd);\n+                  it.set(new AbstractPseudoInstruction.ExceptionCatchImpl(e.handler(), newStart, e.tryEnd(), e.catchType()));\n+              }\n+            } else if (rangeEnd >= handlerEnd) {\n+                \/\/cut from right\n+                Label newEnd = labelContext.newLabel();\n+                labelContext.setLabelTarget(newEnd, rangeStart);\n+                it.set(new AbstractPseudoInstruction.ExceptionCatchImpl(e.handler(), e.tryStart(), newEnd, e.catchType()));\n+            } else {\n+                \/\/split\n+                Label newStart = labelContext.newLabel();\n+                labelContext.setLabelTarget(newStart, rangeEnd);\n+                Label newEnd = labelContext.newLabel();\n+                labelContext.setLabelTarget(newEnd, rangeStart);\n+                it.set(new AbstractPseudoInstruction.ExceptionCatchImpl(e.handler(), e.tryStart(), newEnd, e.catchType()));\n+                it.add(new AbstractPseudoInstruction.ExceptionCatchImpl(e.handler(), newStart, e.tryEnd(), e.catchType()));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Getter of the generated <code>StackMapTableAttribute<\/code> or null if stack map is empty\n+     * @return <code>StackMapTableAttribute<\/code> or null if stack map is empty\n+     *\/\n+    public Attribute<? extends StackMapTableAttribute> stackMapTableAttribute() {\n+        return frames.isEmpty() ? null : new UnboundAttribute.AdHocAttribute<>(Attributes.STACK_MAP_TABLE) {\n+            @Override\n+            public void writeBody(BufWriter b) {\n+                b.writeU2(frames.size());\n+                Frame prevFrame =  new Frame(classHierarchy);\n+                prevFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n+                prevFrame.trimAndCompress();\n+                for (var fr : frames) {\n+                    fr.trimAndCompress();\n+                    fr.writeTo(b, prevFrame, cp);\n+                    prevFrame = fr;\n+                }\n+            }\n+        };\n+    }\n+\n+    private static Type cpIndexToType(int index, ConstantPoolBuilder cp) {\n+        return Type.referenceType(((ClassEntry)cp.entryByIndex(index)).asSymbol());\n+    }\n+\n+    private static boolean isDoubleSlot(ClassDesc desc) {\n+        return CD_double.equals(desc) || CD_long.equals(desc);\n+    }\n+\n+    private void processMethod() {\n+        currentFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n+        currentFrame.stackSize = 0;\n+        currentFrame.flags = 0;\n+        currentFrame.offset = -1;\n+        int stackmapIndex = 0;\n+        RawBytecodeHelper bcs = new RawBytecodeHelper(bytecode);\n+        boolean ncf = false;\n+        while (!bcs.isLastBytecode()) {\n+            bcs.rawNext();\n+            currentFrame.offset = bcs.bci;\n+            if (stackmapIndex < frames.size()) {\n+                int thisOffset = frames.get(stackmapIndex).offset;\n+                if (ncf && thisOffset > bcs.bci) {\n+                    generatorError(\"Expecting a stack map frame\");\n+                }\n+                if (thisOffset == bcs.bci) {\n+                    if (!ncf) {\n+                        currentFrame.checkAssignableTo(frames.get(stackmapIndex));\n+                    }\n+                    Frame nextFrame = frames.get(stackmapIndex++);\n+                    while (!nextFrame.dirty) { \/\/skip unmatched frames\n+                        if (stackmapIndex == frames.size()) return; \/\/skip the rest of this round\n+                        nextFrame = frames.get(stackmapIndex++);\n+                    }\n+                    bcs.rawNext(nextFrame.offset); \/\/skip code up-to the next frame\n+                    currentFrame.offset = bcs.bci;\n+                    currentFrame.copyFrom(nextFrame);\n+                    nextFrame.dirty = false;\n+                } else if (thisOffset < bcs.bci) {\n+                    throw new ClassFormatError(String.format(\"Bad stack map offset %d\", thisOffset));\n+                }\n+            } else if (ncf) {\n+                generatorError(\"Expecting a stack map frame\");\n+            }\n+            ncf = processBlock(bcs);\n+        }\n+    }\n+\n+    private boolean processBlock(RawBytecodeHelper bcs) {\n+        int opcode = bcs.rawCode;\n+        boolean ncf = false;\n+        boolean this_uninit = false;\n+        boolean verified_exc_handlers = false;\n+        int bci = bcs.bci;\n+        Type type1, type2, type3, type4;\n+        if (RawBytecodeHelper.isStoreIntoLocal(opcode) && bci >= exMin && bci < exMax) {\n+            processExceptionHandlerTargets(bci, this_uninit);\n+            verified_exc_handlers = true;\n+        }\n+        switch (opcode) {\n+            case Classfile.NOP -> {}\n+            case Classfile.RETURN -> {\n+                ncf = true;\n+            }\n+            case Classfile.ACONST_NULL ->\n+                currentFrame.pushStack(Type.NULL_TYPE);\n+            case Classfile.ICONST_M1, Classfile.ICONST_0, Classfile.ICONST_1, Classfile.ICONST_2, Classfile.ICONST_3, Classfile.ICONST_4, Classfile.ICONST_5, Classfile.SIPUSH, Classfile.BIPUSH ->\n+                currentFrame.pushStack(Type.INTEGER_TYPE);\n+            case Classfile.LCONST_0, Classfile.LCONST_1 ->\n+                currentFrame.pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.FCONST_0, Classfile.FCONST_1, Classfile.FCONST_2 ->\n+                currentFrame.pushStack(Type.FLOAT_TYPE);\n+            case Classfile.DCONST_0, Classfile.DCONST_1 ->\n+                currentFrame.pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.LDC ->\n+                processLdc(bcs.getIndexU1());\n+            case Classfile.LDC_W, Classfile.LDC2_W ->\n+                processLdc(bcs.getIndexU2());\n+            case Classfile.ILOAD ->\n+                currentFrame.checkLocal(bcs.getIndex()).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.ILOAD_0, Classfile.ILOAD_1, Classfile.ILOAD_2, Classfile.ILOAD_3 ->\n+                currentFrame.checkLocal(opcode - Classfile.ILOAD_0).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.LLOAD ->\n+                currentFrame.checkLocal(bcs.getIndex() + 1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.LLOAD_0, Classfile.LLOAD_1, Classfile.LLOAD_2, Classfile.LLOAD_3 ->\n+                currentFrame.checkLocal(opcode - Classfile.LLOAD_0 + 1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.FLOAD ->\n+                currentFrame.checkLocal(bcs.getIndex()).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.FLOAD_0, Classfile.FLOAD_1, Classfile.FLOAD_2, Classfile.FLOAD_3 ->\n+                currentFrame.checkLocal(opcode - Classfile.FLOAD_0).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.DLOAD ->\n+                currentFrame.checkLocal(bcs.getIndex() + 1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.DLOAD_0, Classfile.DLOAD_1, Classfile.DLOAD_2, Classfile.DLOAD_3 ->\n+                currentFrame.checkLocal(opcode - Classfile.DLOAD_0 + 1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.ALOAD ->\n+                currentFrame.pushStack(currentFrame.getLocal(bcs.getIndex()));\n+            case Classfile.ALOAD_0, Classfile.ALOAD_1, Classfile.ALOAD_2, Classfile.ALOAD_3 ->\n+                currentFrame.pushStack(currentFrame.getLocal(opcode - Classfile.ALOAD_0));\n+            case Classfile.IALOAD, Classfile.BALOAD, Classfile.CALOAD, Classfile.SALOAD ->\n+                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.LALOAD ->\n+                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.FALOAD ->\n+                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.DALOAD ->\n+                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.AALOAD ->\n+                currentFrame.pushStack((type1 = currentFrame.decStack(1).popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n+            case Classfile.ISTORE ->\n+                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n+            case Classfile.ISTORE_0, Classfile.ISTORE_1, Classfile.ISTORE_2, Classfile.ISTORE_3 ->\n+                currentFrame.decStack(1).setLocal(opcode - Classfile.ISTORE_0, Type.INTEGER_TYPE);\n+            case Classfile.LSTORE ->\n+                currentFrame.decStack(2).setLocal2(bcs.getIndex(), Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.LSTORE_0, Classfile.LSTORE_1, Classfile.LSTORE_2, Classfile.LSTORE_3 ->\n+                currentFrame.decStack(2).setLocal2(opcode - Classfile.LSTORE_0, Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.FSTORE ->\n+                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n+            case Classfile.FSTORE_0, Classfile.FSTORE_1, Classfile.FSTORE_2, Classfile.FSTORE_3 ->\n+                currentFrame.decStack(1).setLocal(opcode - Classfile.FSTORE_0, Type.FLOAT_TYPE);\n+            case Classfile.DSTORE ->\n+                currentFrame.decStack(2).setLocal2(bcs.getIndex(), Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.DSTORE_0, Classfile.DSTORE_1, Classfile.DSTORE_2, Classfile.DSTORE_3 ->\n+                currentFrame.decStack(2).setLocal2(opcode - Classfile.DSTORE_0, Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.ASTORE ->\n+                currentFrame.setLocal(bcs.getIndex(), currentFrame.popStack());\n+            case Classfile.ASTORE_0, Classfile.ASTORE_1, Classfile.ASTORE_2, Classfile.ASTORE_3 ->\n+                currentFrame.setLocal(opcode - Classfile.ASTORE_0, currentFrame.popStack());\n+            case Classfile.LASTORE, Classfile.DASTORE ->\n+                currentFrame.decStack(4);\n+            case Classfile.IASTORE, Classfile.BASTORE, Classfile.CASTORE, Classfile.SASTORE, Classfile.FASTORE, Classfile.AASTORE ->\n+                currentFrame.decStack(3);\n+            case Classfile.POP, Classfile.MONITORENTER, Classfile.MONITOREXIT ->\n+                currentFrame.decStack(1);\n+            case Classfile.POP2 ->\n+                currentFrame.decStack(2);\n+            case Classfile.DUP ->\n+                currentFrame.pushStack(type1 = currentFrame.popStack()).pushStack(type1);\n+            case Classfile.DUP_X1 -> {\n+                type1 = currentFrame.popStack();\n+                type2 = currentFrame.popStack();\n+                currentFrame.pushStack(type1).pushStack(type2).pushStack(type1);\n+            }\n+            case Classfile.DUP_X2 -> {\n+                type1 = currentFrame.popStack();\n+                type2 = currentFrame.popStack();\n+                type3 = currentFrame.popStack();\n+                currentFrame.pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n+            }\n+            case Classfile.DUP2 -> {\n+                type1 = currentFrame.popStack();\n+                type2 = currentFrame.popStack();\n+                currentFrame.pushStack(type2).pushStack(type1).pushStack(type2).pushStack(type1);\n+            }\n+            case Classfile.DUP2_X1 -> {\n+                type1 = currentFrame.popStack();\n+                type2 = currentFrame.popStack();\n+                type3 = currentFrame.popStack();\n+                currentFrame.pushStack(type2).pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n+            }\n+            case Classfile.DUP2_X2 -> {\n+                type1 = currentFrame.popStack();\n+                type2 = currentFrame.popStack();\n+                type3 = currentFrame.popStack();\n+                type4 = currentFrame.popStack();\n+                currentFrame.pushStack(type2).pushStack(type1).pushStack(type4).pushStack(type3).pushStack(type2).pushStack(type1);\n+            }\n+            case Classfile.SWAP -> {\n+                type1 = currentFrame.popStack();\n+                type2 = currentFrame.popStack();\n+                currentFrame.pushStack(type1);\n+                currentFrame.pushStack(type2);\n+            }\n+            case Classfile.IADD, Classfile.ISUB, Classfile.IMUL, Classfile.IDIV, Classfile.IREM, Classfile.ISHL, Classfile.ISHR, Classfile.IUSHR, Classfile.IOR, Classfile.IXOR, Classfile.IAND ->\n+                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.INEG, Classfile.ARRAYLENGTH, Classfile.INSTANCEOF ->\n+                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.LADD, Classfile.LSUB, Classfile.LMUL, Classfile.LDIV, Classfile.LREM, Classfile.LAND, Classfile.LOR, Classfile.LXOR ->\n+                currentFrame.decStack(4).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.LNEG ->\n+                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.LSHL, Classfile.LSHR, Classfile.LUSHR ->\n+                currentFrame.decStack(3).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.FADD, Classfile.FSUB, Classfile.FMUL, Classfile.FDIV, Classfile.FREM ->\n+                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.FNEG ->\n+                currentFrame.decStack(1).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.DADD, Classfile.DSUB, Classfile.DMUL, Classfile.DDIV, Classfile.DREM ->\n+                currentFrame.decStack(4).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.DNEG ->\n+                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.IINC ->\n+                currentFrame.checkLocal(bcs.getIndex());\n+            case Classfile.I2L ->\n+                currentFrame.decStack(1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.L2I ->\n+                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.I2F ->\n+                currentFrame.decStack(1).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.I2D ->\n+                currentFrame.decStack(1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.L2F ->\n+                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.L2D ->\n+                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.F2I ->\n+                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.F2L ->\n+                currentFrame.decStack(1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.F2D ->\n+                currentFrame.decStack(1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case Classfile.D2L ->\n+                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case Classfile.D2F ->\n+                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+            case Classfile.I2B, Classfile.I2C, Classfile.I2S ->\n+                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.LCMP, Classfile.DCMPL, Classfile.DCMPG ->\n+                currentFrame.decStack(4).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.FCMPL, Classfile.FCMPG, Classfile.D2I ->\n+                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+            case Classfile.IF_ICMPEQ, Classfile.IF_ICMPNE, Classfile.IF_ICMPLT, Classfile.IF_ICMPGE, Classfile.IF_ICMPGT, Classfile.IF_ICMPLE, Classfile.IF_ACMPEQ, Classfile.IF_ACMPNE ->\n+                checkJumpTarget(currentFrame.decStack(2), bcs.dest());\n+            case Classfile.IFEQ, Classfile.IFNE, Classfile.IFLT, Classfile.IFGE, Classfile.IFGT, Classfile.IFLE, Classfile.IFNULL, Classfile.IFNONNULL ->\n+                checkJumpTarget(currentFrame.decStack(1), bcs.dest());\n+            case Classfile.GOTO -> {\n+                checkJumpTarget(currentFrame, bcs.dest());\n+                ncf = true;\n+            }\n+            case Classfile.GOTO_W -> {\n+                checkJumpTarget(currentFrame, bcs.destW());\n+                ncf = true;\n+            }\n+            case Classfile.TABLESWITCH, Classfile.LOOKUPSWITCH -> {\n+                processSwitch(bcs);\n+                ncf = true;\n+            }\n+            case Classfile.LRETURN, Classfile.DRETURN -> {\n+                currentFrame.decStack(2);\n+                ncf = true;\n+            }\n+            case Classfile.IRETURN, Classfile.FRETURN, Classfile.ARETURN, Classfile.ATHROW -> {\n+                currentFrame.decStack(1);\n+                ncf = true;\n+            }\n+            case Classfile.GETSTATIC, Classfile.PUTSTATIC, Classfile.GETFIELD, Classfile.PUTFIELD ->\n+                processFieldInstructions(bcs);\n+            case Classfile.INVOKEVIRTUAL, Classfile.INVOKESPECIAL, Classfile.INVOKESTATIC, Classfile.INVOKEINTERFACE, Classfile.INVOKEDYNAMIC ->\n+                this_uninit = processInvokeInstructions(bcs, (bci >= exMin && bci < exMax), this_uninit);\n+            case Classfile.NEW ->\n+                currentFrame.pushStack(Type.uninitializedType(bci));\n+            case Classfile.NEWARRAY ->\n+                currentFrame.decStack(1).pushStack(getNewarrayType(bcs.getIndex()));\n+            case Classfile.ANEWARRAY ->\n+                processAnewarray(bcs.getIndexU2());\n+            case Classfile.CHECKCAST ->\n+                currentFrame.decStack(1).pushStack(cpIndexToType(bcs.getIndexU2(), cp));\n+            case Classfile.MULTIANEWARRAY -> {\n+                type1 = cpIndexToType(bcs.getIndexU2(), cp);\n+                int dim = bcs.getU1(bcs.bci + 3);\n+                for (int i = 0; i < dim; i++) {\n+                    currentFrame.popStack();\n+                }\n+                currentFrame.pushStack(type1);\n+            }\n+            default ->\n+                generatorError(String.format(\"Bad instruction: %02x\", opcode));\n+        }\n+        if (!verified_exc_handlers && bci >= exMin && bci < exMax) {\n+            processExceptionHandlerTargets(bci, this_uninit);\n+        }\n+        return ncf;\n+    }\n+\n+    private void processExceptionHandlerTargets(int bci, boolean this_uninit) {\n+        for (var exhandler : exceptionTable) {\n+            if (bci >= labelContext.labelToBci(exhandler.tryStart()) && bci < labelContext.labelToBci(exhandler.tryEnd())) {\n+                int flags = currentFrame.flags;\n+                if (this_uninit) flags |= FLAG_THIS_UNINIT;\n+                Frame newFrame = currentFrame.frameInExceptionHandler(flags);\n+                var catchType = exhandler.catchType();\n+                newFrame.pushStack(catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp) : Type.THROWABLE_TYPE);\n+                int handler = labelContext.labelToBci(exhandler.handler());\n+                if (handler != -1) checkJumpTarget(newFrame, handler);\n+            }\n+        }\n+    }\n+\n+    private void processLdc(int index) {\n+        switch (cp.entryByIndex(index).tag()) {\n+            case TAG_UTF8 ->\n+                currentFrame.pushStack(Type.OBJECT_TYPE);\n+            case TAG_STRING ->\n+                currentFrame.pushStack(Type.STRING_TYPE);\n+            case TAG_CLASS ->\n+                currentFrame.pushStack(Type.CLASS_TYPE);\n+            case TAG_INTEGER ->\n+                currentFrame.pushStack(Type.INTEGER_TYPE);\n+            case TAG_FLOAT ->\n+                currentFrame.pushStack(Type.FLOAT_TYPE);\n+            case TAG_DOUBLE ->\n+                currentFrame.pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            case TAG_LONG ->\n+                currentFrame.pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            case TAG_METHODHANDLE ->\n+                currentFrame.pushStack(Type.METHOD_HANDLE_TYPE);\n+            case TAG_METHODTYPE ->\n+                currentFrame.pushStack(Type.METHOD_TYPE);\n+            case TAG_CONSTANTDYNAMIC ->\n+                currentFrame.pushStack(((ConstantDynamicEntry)cp.entryByIndex(index)).asSymbol().constantType());\n+            default ->\n+                generatorError(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+        }\n+    }\n+\n+    private void processSwitch(RawBytecodeHelper bcs) {\n+        int bci = bcs.bci;\n+        int alignedBci = RawBytecodeHelper.align(bci + 1);\n+        int defaultOfset = bcs.getInt(alignedBci);\n+        int keys, delta;\n+        currentFrame.popStack();\n+        if (bcs.rawCode == Classfile.TABLESWITCH) {\n+            int low = bcs.getInt(alignedBci + 4);\n+            int high = bcs.getInt(alignedBci + 2 * 4);\n+            if (low > high) {\n+                generatorError(\"low must be less than or equal to high in tableswitch\");\n+            }\n+            keys = high - low + 1;\n+            if (keys < 0) {\n+                generatorError(\"too many keys in tableswitch\");\n+            }\n+            delta = 1;\n+        } else {\n+            keys = bcs.getInt(alignedBci + 4);\n+            if (keys < 0) {\n+                generatorError(\"number of keys in lookupswitch less than 0\");\n+            }\n+            delta = 2;\n+            for (int i = 0; i < (keys - 1); i++) {\n+                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n+                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                if (this_key >= next_key) {\n+                    generatorError(\"Bad lookupswitch instruction\");\n+                }\n+            }\n+        }\n+        int target = bci + defaultOfset;\n+        checkJumpTarget(currentFrame, target);\n+        for (int i = 0; i < keys; i++) {\n+            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n+            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+            checkJumpTarget(currentFrame, target);\n+        }\n+    }\n+\n+    private void processFieldInstructions(RawBytecodeHelper bcs) {\n+        var desc = ClassDesc.ofDescriptor(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType().type().stringValue());\n+        switch (bcs.rawCode) {\n+            case Classfile.GETSTATIC ->\n+                currentFrame.pushStack(desc);\n+            case Classfile.PUTSTATIC -> {\n+                currentFrame.popStack();\n+                if (isDoubleSlot(desc)) currentFrame.popStack();\n+            }\n+            case Classfile.GETFIELD -> {\n+                currentFrame.popStack();\n+                currentFrame.pushStack(desc);\n+            }\n+            case Classfile.PUTFIELD -> {\n+                currentFrame.popStack();\n+                currentFrame.popStack();\n+                if (isDoubleSlot(desc)) currentFrame.popStack();\n+            }\n+            default -> throw new AssertionError(\"Should not reach here\");\n+        }\n+    }\n+\n+    private boolean processInvokeInstructions(RawBytecodeHelper bcs, boolean inTryBlock, boolean thisUninit) {\n+        int index = bcs.getIndexU2();\n+        int opcode = bcs.rawCode;\n+        var cpe = cp.entryByIndex(index);\n+        var nameAndType = opcode == Classfile.INVOKEDYNAMIC ? ((DynamicConstantPoolEntry)cpe).nameAndType() : ((MemberRefEntry)cpe).nameAndType();\n+        String invokeMethodName = nameAndType.name().stringValue();\n+\n+        var mDesc = nameAndType.type().stringValue();\n+        \/\/faster counting of method descriptor argument slots instead of full parsing\n+        int nargs = 0, pos = 0, descLen = mDesc.length();\n+        if (descLen < 3 || mDesc.charAt(0) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n+        char ch;\n+        while (++pos < descLen && (ch = mDesc.charAt(pos)) != ')') {\n+            switch (ch) {\n+                case '[' -> {\n+                    nargs++;\n+                    while (++pos < descLen && mDesc.charAt(pos) == '[');\n+                    if (mDesc.charAt(pos) == 'L')\n+                        while (++pos < descLen && mDesc.charAt(pos) != ';');\n+                }\n+                case 'D', 'J' -> nargs += 2;\n+                case 'B', 'C', 'F', 'I', 'S', 'Z' -> nargs++;\n+                case 'L' -> {\n+                    nargs++;\n+                    while (++pos < descLen && mDesc.charAt(pos) != ';');\n+                }\n+                default ->\n+                    throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n+            }\n+        }\n+        if (++pos >= descLen)\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n+\n+        int bci = bcs.bci;\n+        currentFrame.decStack(nargs);\n+        if (opcode != Classfile.INVOKESTATIC && opcode != Classfile.INVOKEDYNAMIC) {\n+            if (OBJECT_INITIALIZER_NAME.equals(invokeMethodName)) {\n+                Type type = currentFrame.popStack();\n+                if (type == Type.UNITIALIZED_THIS_TYPE) {\n+                    if (inTryBlock) {\n+                        processExceptionHandlerTargets(bci, true);\n+                    }\n+                    currentFrame.initializeObject(type, thisType);\n+                    thisUninit = true;\n+                } else if (type.tag == ITEM_UNINITIALIZED) {\n+                    int new_offset = type.bci;\n+                    int new_class_index = bcs.getIndexU2Raw(new_offset + 1);\n+                    Type new_class_type = cpIndexToType(new_class_index, cp);\n+                    if (inTryBlock) {\n+                        processExceptionHandlerTargets(bci, thisUninit);\n+                    }\n+                    currentFrame.initializeObject(type, new_class_type);\n+                } else {\n+                    generatorError(\"Bad operand type when invoking <init>\");\n+                }\n+            } else {\n+                currentFrame.popStack();\n+            }\n+        }\n+        currentFrame.pushStack(ClassDesc.ofDescriptor(mDesc.substring(pos)));\n+        return thisUninit;\n+    }\n+\n+    private Type getNewarrayType(int index) {\n+        if (index < T_BOOLEAN || index > T_LONG) generatorError(\"Illegal newarray instruction type %d\".formatted(index));\n+        return ARRAY_FROM_BASIC_TYPE[index];\n+    }\n+\n+    private void processAnewarray(int index) {\n+        currentFrame.popStack();\n+        currentFrame.pushStack(cpIndexToType(index, cp).toArray());\n+    }\n+\n+    \/**\n+     * Throws <code>java.lang.VerifyError<\/code> with given error message\n+     * @param msg error message\n+     *\/\n+    private void generatorError(String msg) {\n+        generatorError(msg, currentFrame.offset);\n+    }\n+\n+        \/**\n+     * Throws <code>java.lang.VerifyError<\/code> with given error message\n+     * @param msg error message\n+     * @param offset bytecode offset where the error occured\n+     *\/\n+    private void generatorError(String msg, int offset) {\n+        var sb = new StringBuilder(\"%s at bytecode offset %d of method %s(%s)\".formatted(\n+                msg,\n+                offset,\n+                methodName,\n+                methodDesc.parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"))));\n+        \/\/try to attach debug info about corrupted bytecode to the message\n+        try {\n+            cp.options.generateStackmaps = false;\n+            var clb = new DirectClassBuilder(cp, cp.classEntry(ClassDesc.of(\"FakeClass\")));\n+            clb.withMethod(methodName, methodDesc, isStatic ? ACC_STATIC : 0, mb ->\n+                    ((DirectMethodBuilder)mb).writeAttribute(new UnboundAttribute.AdHocAttribute<CodeAttribute>(Attributes.CODE) {\n+                        @Override\n+                        public void writeBody(BufWriter b) {\n+                            b.writeU2(-1);\/\/max stack\n+                            b.writeU2(-1);\/\/max locals\n+                            b.writeInt(bytecode.limit());\n+                            b.writeBytes(bytecode.array(), 0, bytecode.limit());\n+                            b.writeU2(0);\/\/exception handlers\n+                            b.writeU2(0);\/\/attributes\n+                        }\n+                    }));\n+            ClassPrinter.toYaml(Classfile.parse(clb.build()).methods().get(0).code().get(), ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n+        } catch (Error | Exception suppresed) {\n+            \/\/fallback to bytecode hex dump\n+            bytecode.rewind();\n+            while (bytecode.position() < bytecode.limit()) {\n+                sb.append(\"%n%04x:\".formatted(bytecode.position()));\n+                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n+                    sb.append(\" %02x\".formatted(bytecode.get()));\n+                }\n+            }\n+            var err = new VerifyError(sb.toString());\n+            err.addSuppressed(suppresed);\n+            throw err;\n+        }\n+        throw new IllegalStateException(sb.toString());\n+    }\n+\n+    \/**\n+     * Performs detection of mandatory stack map frames offsets\n+     * in a single bytecode traversing pass\n+     * @return <code>java.lang.BitSet<\/code> of detected frames offsets\n+     *\/\n+    private BitSet detectFrameOffsets() {\n+        var offsets = new BitSet() {\n+            @Override\n+            public void set(int i) {\n+                if (i < 0 || i >= bytecode.capacity()) throw new IllegalArgumentException();\n+                super.set(i);\n+            }\n+        };\n+        RawBytecodeHelper bcs = new RawBytecodeHelper(bytecode);\n+        boolean no_control_flow = false;\n+        int opcode, bci = 0;\n+        while (!bcs.isLastBytecode()) try {\n+            opcode = bcs.rawNext();\n+            bci = bcs.bci;\n+            if (no_control_flow) {\n+                offsets.set(bci);\n+            }\n+            no_control_flow = switch (opcode) {\n+                case Classfile.GOTO -> {\n+                            offsets.set(bcs.dest());\n+                            yield true;\n+                        }\n+                case Classfile.GOTO_W -> {\n+                            offsets.set(bcs.destW());\n+                            yield true;\n+                        }\n+                case Classfile.IF_ICMPEQ, Classfile.IF_ICMPNE, Classfile.IF_ICMPLT, Classfile.IF_ICMPGE,\n+                     Classfile.IF_ICMPGT, Classfile.IF_ICMPLE, Classfile.IFEQ, Classfile.IFNE,\n+                     Classfile.IFLT, Classfile.IFGE, Classfile.IFGT, Classfile.IFLE, Classfile.IF_ACMPEQ,\n+                     Classfile.IF_ACMPNE , Classfile.IFNULL , Classfile.IFNONNULL -> {\n+                            offsets.set(bcs.dest());\n+                            yield false;\n+                        }\n+                case Classfile.TABLESWITCH, Classfile.LOOKUPSWITCH -> {\n+                            int aligned_bci = RawBytecodeHelper.align(bci + 1);\n+                            int default_ofset = bcs.getInt(aligned_bci);\n+                            int keys, delta;\n+                            if (bcs.rawCode == Classfile.TABLESWITCH) {\n+                                int low = bcs.getInt(aligned_bci + 4);\n+                                int high = bcs.getInt(aligned_bci + 2 * 4);\n+                                keys = high - low + 1;\n+                                delta = 1;\n+                            } else {\n+                                keys = bcs.getInt(aligned_bci + 4);\n+                                delta = 2;\n+                            }\n+                            offsets.set(bci + default_ofset);\n+                            for (int i = 0; i < keys; i++) {\n+                                offsets.set(bci + bcs.getInt(aligned_bci + (3 + i * delta) * 4));\n+                            }\n+                            yield true;\n+                        }\n+                case Classfile.IRETURN, Classfile.LRETURN, Classfile.FRETURN, Classfile.DRETURN,\n+                     Classfile.ARETURN, Classfile.RETURN, Classfile.ATHROW -> true;\n+                default -> false;\n+            };\n+        } catch (IllegalArgumentException iae) {\n+            generatorError(\"Detected branch target out of bytecode range\", bci);\n+        }\n+        for (var exhandler : exceptionTable) try {\n+            offsets.set(labelContext.labelToBci(exhandler.handler()));\n+        } catch (IllegalArgumentException iae) {\n+            if (!cp.options().filterDeadLabels)\n+                generatorError(\"Detected exception handler out of bytecode range\");\n+        }\n+        return offsets;\n+    }\n+\n+    private final class Frame {\n+\n+        int offset;\n+        int localsSize, stackSize;\n+        int flags;\n+        int frameMaxStack = 0, frameMaxLocals = 0;\n+        boolean dirty = false;\n+\n+        private final ClassHierarchyImpl classHierarchy;\n+\n+        private Type[] locals, stack;\n+\n+        Frame(ClassHierarchyImpl classHierarchy) {\n+            this(-1, 0, 0, 0, null, null, classHierarchy);\n+        }\n+\n+        Frame(int offset, ClassHierarchyImpl classHierarchy) {\n+            this(offset, -1, 0, 0, null, null, classHierarchy);\n+        }\n+\n+        Frame(int offset, int flags, int locals_size, int stack_size, Type[] locals, Type[] stack, ClassHierarchyImpl classHierarchy) {\n+            this.offset = offset;\n+            this.localsSize = locals_size;\n+            this.stackSize = stack_size;\n+            this.flags = flags;\n+            this.locals = locals;\n+            this.stack = stack;\n+            this.classHierarchy = classHierarchy;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return (dirty ? \"frame* @\" : \"frame @\") + offset + \" with locals \" + (locals == null ? \"[]\" : Arrays.asList(locals).subList(0, localsSize)) + \" and stack \" + (stack == null ? \"[]\" : Arrays.asList(stack).subList(0, stackSize));\n+        }\n+\n+        Frame pushStack(ClassDesc desc) {\n+            return switch (desc.descriptorString()) {\n+                case \"J\" ->\n+                    pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                case \"D\" ->\n+                    pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                    pushStack(Type.INTEGER_TYPE);\n+                case \"F\" ->\n+                    pushStack(Type.FLOAT_TYPE);\n+                case \"V\" ->\n+                    this;\n+                default ->\n+                    pushStack(Type.referenceType(desc));\n+            };\n+        }\n+\n+        Frame pushStack(Type type) {\n+            checkStack(stackSize);\n+            stack[stackSize++] = type;\n+            return this;\n+        }\n+\n+        Frame pushStack(Type type1, Type type2) {\n+            checkStack(stackSize + 1);\n+            stack[stackSize++] = type1;\n+            stack[stackSize++] = type2;\n+            return this;\n+        }\n+\n+        Type popStack() {\n+            if (stackSize < 1) generatorError(\"Operand stack underflow\");\n+            return stack[--stackSize];\n+        }\n+\n+        Frame decStack(int size) {\n+            stackSize -= size;\n+            if (stackSize < 0) generatorError(\"Operand stack underflow\");\n+            return this;\n+        }\n+\n+        Frame frameInExceptionHandler(int flags) {\n+            return new Frame(offset, flags, localsSize, 0, locals, new Type[] {Type.TOP_TYPE}, classHierarchy);\n+        }\n+\n+        void initializeObject(Type old_object, Type new_object) {\n+            int i;\n+            for (i = 0; i < localsSize; i++) {\n+                if (locals[i].equals(old_object)) {\n+                    locals[i] = new_object;\n+                }\n+            }\n+            for (i = 0; i < stackSize; i++) {\n+                if (stack[i].equals(old_object)) {\n+                    stack[i] = new_object;\n+                }\n+            }\n+            if (old_object == Type.UNITIALIZED_THIS_TYPE) {\n+                flags = 0;\n+            }\n+        }\n+\n+        Frame checkLocal(int index) {\n+            if (index >= frameMaxLocals) frameMaxLocals = index + 1;\n+            if (locals == null) {\n+                locals = new Type[index + FRAME_DEFAULT_CAPACITY];\n+                Arrays.fill(locals, Type.TOP_TYPE);\n+            } else if (index >= locals.length) {\n+                int current = locals.length;\n+                locals = Arrays.copyOf(locals, index + FRAME_DEFAULT_CAPACITY);\n+                Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n+            }\n+            return this;\n+        }\n+\n+        private void checkStack(int index) {\n+            if (index >= frameMaxStack) frameMaxStack = index + 1;\n+            if (stack == null) {\n+                stack = new Type[index + FRAME_DEFAULT_CAPACITY];\n+                Arrays.fill(stack, Type.TOP_TYPE);\n+            } else if (index >= stack.length) {\n+                int current = stack.length;\n+                stack = Arrays.copyOf(stack, index + FRAME_DEFAULT_CAPACITY);\n+                Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n+            }\n+        }\n+\n+        private void setLocalRawInternal(int index, Type type) {\n+            checkLocal(index);\n+            locals[index] = type;\n+        }\n+\n+        void setLocalsFromArg(String name, MethodTypeDesc methodDesc, boolean isStatic, Type thisKlass) {\n+            localsSize = 0;\n+            if (!isStatic) {\n+                localsSize++;\n+                if (OBJECT_INITIALIZER_NAME.equals(name) && !CD_Object.equals(thisKlass.sym)) {\n+                    setLocal(0, Type.UNITIALIZED_THIS_TYPE);\n+                    flags |= FLAG_THIS_UNINIT;\n+                } else {\n+                    setLocalRawInternal(0, thisKlass);\n+                }\n+            }\n+            for (int i = 0; i < methodDesc.parameterCount(); i++) {\n+                var desc = methodDesc.parameterType(i);\n+                if (desc.isClassOrInterface() || desc.isArray()) {\n+                    setLocalRawInternal(localsSize++, Type.referenceType(desc));\n+                } else switch (desc.descriptorString()) {\n+                    case \"J\" -> {\n+                        setLocalRawInternal(localsSize++, Type.LONG_TYPE);\n+                        setLocalRawInternal(localsSize++, Type.LONG2_TYPE);\n+                    }\n+                    case \"D\" -> {\n+                        setLocalRawInternal(localsSize++, Type.DOUBLE_TYPE);\n+                        setLocalRawInternal(localsSize++, Type.DOUBLE2_TYPE);\n+                    }\n+                    case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                        setLocalRawInternal(localsSize++, Type.INTEGER_TYPE);\n+                    case \"F\" ->\n+                        setLocalRawInternal(localsSize++, Type.FLOAT_TYPE);\n+                    default -> throw new AssertionError(\"Should not reach here\");\n+                }\n+            }\n+        }\n+\n+        void copyFrom(Frame src) {\n+            if (locals != null && src.localsSize < locals.length) Arrays.fill(locals, src.localsSize, locals.length, Type.TOP_TYPE);\n+            localsSize = src.localsSize;\n+            checkLocal(src.localsSize - 1);\n+            if (src.localsSize > 0) System.arraycopy(src.locals, 0, locals, 0, src.localsSize);\n+            if (stack != null && src.stackSize < stack.length) Arrays.fill(stack, src.stackSize, stack.length, Type.TOP_TYPE);\n+            stackSize = src.stackSize;\n+            checkStack(src.stackSize - 1);\n+            if (src.stackSize > 0) System.arraycopy(src.stack, 0, stack, 0, src.stackSize);\n+            flags = src.flags;\n+        }\n+\n+        void checkAssignableTo(Frame target) {\n+            if (target.flags == -1) {\n+                target.locals = locals == null ? null : Arrays.copyOf(locals, localsSize);\n+                target.localsSize = localsSize;\n+                target.stack = stack == null ? null : Arrays.copyOf(stack, stackSize);\n+                target.stackSize = stackSize;\n+                target.flags = flags;\n+                target.dirty = true;\n+            } else {\n+                if (target.localsSize > localsSize) {\n+                    target.localsSize = localsSize;\n+                    target.dirty = true;\n+                }\n+                for (int i = 0; i < target.localsSize; i++) {\n+                    merge(locals[i], target.locals, i, target);\n+                }\n+                for (int i = 0; i < target.stackSize; i++) {\n+                    merge(stack[i], target.stack, i, target);\n+                }\n+            }\n+        }\n+\n+        private Type getLocalRawInternal(int index) {\n+            checkLocal(index);\n+            return locals[index];\n+        }\n+\n+        Type getLocal(int index) {\n+            Type ret = getLocalRawInternal(index);\n+            if (index >= localsSize) {\n+                localsSize = index + 1;\n+            }\n+            return ret;\n+        }\n+\n+        void setLocal(int index, Type type) {\n+            Type old = getLocalRawInternal(index);\n+            if (old == Type.DOUBLE_TYPE || old == Type.LONG_TYPE) {\n+                setLocalRawInternal(index + 1, Type.TOP_TYPE);\n+            }\n+            if (old == Type.DOUBLE2_TYPE || old == Type.LONG2_TYPE) {\n+                setLocalRawInternal(index - 1, Type.TOP_TYPE);\n+            }\n+            setLocalRawInternal(index, type);\n+            if (index >= localsSize) {\n+                localsSize = index + 1;\n+            }\n+        }\n+\n+        void setLocal2(int index, Type type1, Type type2) {\n+            Type old = getLocalRawInternal(index + 1);\n+            if (old == Type.DOUBLE_TYPE || old == Type.LONG_TYPE) {\n+                setLocalRawInternal(index + 2, Type.TOP_TYPE);\n+            }\n+            old = getLocalRawInternal(index);\n+            if (old == Type.DOUBLE2_TYPE || old == Type.LONG2_TYPE) {\n+                setLocalRawInternal(index - 1, Type.TOP_TYPE);\n+            }\n+            setLocalRawInternal(index, type1);\n+            setLocalRawInternal(index + 1, type2);\n+            if (index >= localsSize - 1) {\n+                localsSize = index + 2;\n+            }\n+        }\n+\n+        private void merge(Type me, Type[] toTypes, int i, Frame target) {\n+            var to = toTypes[i];\n+            var newTo = to.mergeFrom(me, classHierarchy);\n+            if (to != newTo && !to.equals(newTo)) {\n+                toTypes[i] = newTo;\n+                target.dirty = true;\n+            }\n+        }\n+\n+        private static int trimAndCompress(Type[] types, int count) {\n+            while (count > 0 && types[count - 1] == Type.TOP_TYPE) count--;\n+            int compressed = 0;\n+            for (int i = 0; i < count; i++) {\n+                if (!types[i].isCategory2_2nd()) {\n+                    types[compressed++] = types[i];\n+                }\n+            }\n+            return compressed;\n+        }\n+\n+        void trimAndCompress() {\n+            localsSize = trimAndCompress(locals, localsSize);\n+            stackSize = trimAndCompress(stack, stackSize);\n+        }\n+\n+        private static boolean equals(Type[] l1, Type[] l2, int commonSize) {\n+            if (l1 == null || l2 == null) return commonSize == 0;\n+            return Arrays.equals(l1, 0, commonSize, l2, 0, commonSize);\n+        }\n+\n+        void writeTo(BufWriter out, Frame prevFrame, ConstantPoolBuilder cp) {\n+            int offsetDelta = offset - prevFrame.offset - 1;\n+            if (stackSize == 0) {\n+                int commonLocalsSize = localsSize > prevFrame.localsSize ? prevFrame.localsSize : localsSize;\n+                int diffLocalsSize = localsSize - prevFrame.localsSize;\n+                if (-3 <= diffLocalsSize && diffLocalsSize <= 3 && equals(locals, prevFrame.locals, commonLocalsSize)) {\n+                    if (diffLocalsSize == 0 && offsetDelta < 64) { \/\/same frame\n+                        out.writeU1(offsetDelta);\n+                    } else {   \/\/chop, same extended or append frame\n+                        out.writeU1(251 + diffLocalsSize);\n+                        out.writeU2(offsetDelta);\n+                        for (int i=commonLocalsSize; i<localsSize; i++) locals[i].writeTo(out, cp);\n+                    }\n+                    return;\n+                }\n+            } else if (stackSize == 1 && localsSize == prevFrame.localsSize && equals(locals, prevFrame.locals, localsSize)) {\n+                if (offsetDelta < 64) {  \/\/same locals 1 stack item frame\n+                    out.writeU1(64 + offsetDelta);\n+                } else {  \/\/same locals 1 stack item extended frame\n+                    out.writeU1(247);\n+                    out.writeU2(offsetDelta);\n+                }\n+                stack[0].writeTo(out, cp);\n+                return;\n+            }\n+            \/\/full frame\n+            out.writeU1(255);\n+            out.writeU2(offsetDelta);\n+            out.writeU2(localsSize);\n+            for (int i=0; i<localsSize; i++) locals[i].writeTo(out, cp);\n+            out.writeU2(stackSize);\n+            for (int i=0; i<stackSize; i++) stack[i].writeTo(out, cp);\n+        }\n+    }\n+\n+    private static record Type(int tag, ClassDesc sym, int bci) {\n+\n+        \/\/singleton types\n+        static final Type TOP_TYPE = simpleType(ITEM_TOP),\n+                NULL_TYPE = simpleType(ITEM_NULL),\n+                INTEGER_TYPE = simpleType(ITEM_INTEGER),\n+                FLOAT_TYPE = simpleType(ITEM_FLOAT),\n+                LONG_TYPE = simpleType(ITEM_LONG),\n+                LONG2_TYPE = simpleType(ITEM_LONG_2ND),\n+                DOUBLE_TYPE = simpleType(ITEM_DOUBLE),\n+                BOOLEAN_TYPE = simpleType(ITEM_BOOLEAN),\n+                BYTE_TYPE = simpleType(ITEM_BYTE),\n+                CHAR_TYPE = simpleType(ITEM_CHAR),\n+                SHORT_TYPE = simpleType(ITEM_SHORT),\n+                DOUBLE2_TYPE = simpleType(ITEM_DOUBLE_2ND),\n+                UNITIALIZED_THIS_TYPE = simpleType(ITEM_UNINITIALIZED_THIS);\n+\n+        \/\/frequently used types to reduce footprint\n+        static final Type OBJECT_TYPE = referenceType(CD_Object),\n+            THROWABLE_TYPE = referenceType(CD_Throwable),\n+            INT_ARRAY_TYPE = referenceType(CD_int.arrayType()),\n+            BOOLEAN_ARRAY_TYPE = referenceType(CD_boolean.arrayType()),\n+            BYTE_ARRAY_TYPE = referenceType(CD_byte.arrayType()),\n+            CHAR_ARRAY_TYPE = referenceType(CD_char.arrayType()),\n+            SHORT_ARRAY_TYPE = referenceType(CD_short.arrayType()),\n+            LONG_ARRAY_TYPE = referenceType(CD_long.arrayType()),\n+            DOUBLE_ARRAY_TYPE = referenceType(CD_double.arrayType()),\n+            FLOAT_ARRAY_TYPE = referenceType(CD_float.arrayType()),\n+            STRING_TYPE = referenceType(CD_String),\n+            CLASS_TYPE = referenceType(CD_Class),\n+            METHOD_HANDLE_TYPE = referenceType(CD_MethodHandle),\n+            METHOD_TYPE = referenceType(CD_MethodType);\n+\n+        private static Type simpleType(int tag) {\n+            return new Type(tag, null, 0);\n+        }\n+\n+        static Type referenceType(ClassDesc desc) {\n+            return new Type(ITEM_OBJECT, desc, 0);\n+        }\n+\n+        static Type uninitializedType(int bci) {\n+            return new Type(ITEM_UNINITIALIZED, null, bci);\n+        }\n+\n+        @Override \/\/mandatory overrride to avoid use of method reference during JDK bootstrap\n+        public boolean equals(Object o) {\n+            return (o instanceof Type t) && t.tag == tag && t.bci == bci && Objects.equals(sym, t.sym);\n+        }\n+\n+        boolean isCategory2_2nd() {\n+            return this == DOUBLE2_TYPE || this == LONG2_TYPE;\n+        }\n+\n+        boolean isReference() {\n+            return tag == ITEM_OBJECT || this == NULL_TYPE;\n+        }\n+\n+        boolean isObject() {\n+            return tag == ITEM_OBJECT && sym.isClassOrInterface();\n+        }\n+\n+        boolean isArray() {\n+            return tag == ITEM_OBJECT && sym.isArray();\n+        }\n+\n+        Type mergeFrom(Type from, ClassHierarchyImpl context) {\n+            if (this == TOP_TYPE || this == from || equals(from)) {\n+                return this;\n+            } else {\n+                return switch (tag) {\n+                    case ITEM_BOOLEAN, ITEM_BYTE, ITEM_CHAR, ITEM_SHORT ->\n+                        from == INTEGER_TYPE ? this : TOP_TYPE;\n+                    default ->\n+                        isReference() && from.isReference() ? mergeReferenceFrom(from, context) : TOP_TYPE;\n+                };\n+            }\n+        }\n+\n+        Type mergeComponentFrom(Type from, ClassHierarchyImpl context) {\n+            if (this == TOP_TYPE || this == from || equals(from)) {\n+                return this;\n+            } else {\n+                return switch (tag) {\n+                    case ITEM_BOOLEAN, ITEM_BYTE, ITEM_CHAR, ITEM_SHORT ->\n+                        TOP_TYPE;\n+                    default ->\n+                        isReference() && from.isReference() ? mergeReferenceFrom(from, context) : TOP_TYPE;\n+                };\n+            }\n+        }\n+\n+        private static final ClassDesc CD_Cloneable = ClassDesc.of(\"java.lang.Cloneable\");\n+        private static final ClassDesc CD_Serializable = ClassDesc.of(\"java.io.Serializable\");\n+\n+        private Type mergeReferenceFrom(Type from, ClassHierarchyImpl context) {\n+            if (from == NULL_TYPE) {\n+                return this;\n+            } else if (this == NULL_TYPE) {\n+                return from;\n+            } else if (sym.equals(from.sym)) {\n+                return this;\n+            } else if (isObject()) {\n+                if (CD_Object.equals(sym)) {\n+                    return this;\n+                }\n+                if (context.isInterface(sym)) {\n+                    if (!from.isArray() || CD_Cloneable.equals(sym) || CD_Serializable.equals(sym)) {\n+                        return this;\n+                    }\n+                } else if (from.isObject()) {\n+                    var anc = context.commonAncestor(sym, from.sym);\n+                    return anc == null ? this : Type.referenceType(anc);\n+                }\n+            } else if (isArray() && from.isArray()) {\n+                Type compThis = getComponent();\n+                Type compFrom = from.getComponent();\n+                if (compThis != TOP_TYPE && compFrom != TOP_TYPE) {\n+                    return  compThis.mergeComponentFrom(compFrom, context).toArray();\n+                }\n+            }\n+            return OBJECT_TYPE;\n+        }\n+\n+        Type toArray() {\n+            return switch (tag) {\n+                case ITEM_BOOLEAN -> BOOLEAN_ARRAY_TYPE;\n+                case ITEM_BYTE -> BYTE_ARRAY_TYPE;\n+                case ITEM_CHAR -> CHAR_ARRAY_TYPE;\n+                case ITEM_SHORT -> SHORT_ARRAY_TYPE;\n+                case ITEM_INTEGER -> INT_ARRAY_TYPE;\n+                case ITEM_LONG -> LONG_ARRAY_TYPE;\n+                case ITEM_FLOAT -> FLOAT_ARRAY_TYPE;\n+                case ITEM_DOUBLE -> DOUBLE_ARRAY_TYPE;\n+                case ITEM_OBJECT -> Type.referenceType(sym.arrayType());\n+                default -> OBJECT_TYPE;\n+            };\n+        }\n+\n+        Type getComponent() {\n+            if (sym.isArray()) {\n+                var comp = sym.componentType();\n+                if (comp.isPrimitive()) {\n+                    return switch (comp.descriptorString().charAt(0)) {\n+                        case 'Z' -> Type.BOOLEAN_TYPE;\n+                        case 'B' -> Type.BYTE_TYPE;\n+                        case 'C' -> Type.CHAR_TYPE;\n+                        case 'S' -> Type.SHORT_TYPE;\n+                        case 'I' -> Type.INTEGER_TYPE;\n+                        case 'J' -> Type.LONG_TYPE;\n+                        case 'F' -> Type.FLOAT_TYPE;\n+                        case 'D' -> Type.DOUBLE_TYPE;\n+                        default -> Type.TOP_TYPE;\n+                    };\n+                }\n+                return Type.referenceType(comp);\n+            }\n+            return Type.TOP_TYPE;\n+        }\n+\n+        void writeTo(BufWriter bw, ConstantPoolBuilder cp) {\n+            bw.writeU1(tag);\n+            switch (tag) {\n+                case ITEM_OBJECT ->\n+                    bw.writeU2(cp.classEntry(sym).index());\n+                case ITEM_UNINITIALIZED ->\n+                    bw.writeU2(bci);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1424,"deletions":0,"binary":false,"changes":1424,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Superclass;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * SuperclassImpl\n+ *\/\n+public final class SuperclassImpl\n+        extends AbstractElement\n+        implements Superclass {\n+    private final ClassEntry superclassEntry;\n+\n+    public SuperclassImpl(ClassEntry superclassEntry) {\n+        requireNonNull(superclassEntry);\n+        this.superclassEntry = superclassEntry;\n+    }\n+\n+    @Override\n+    public ClassEntry superclassEntry() {\n+        return superclassEntry;\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        builder.setSuperclass(superclassEntry);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Superclass[superclassEntry=%s]\", superclassEntry.name().stringValue());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SuperclassImpl.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.TypeAnnotation.*;\n+import static jdk.internal.classfile.Classfile.*;\n+\n+\/**\n+ *\n+ *\/\n+public final class TargetInfoImpl {\n+\n+    private TargetInfoImpl() {\n+    }\n+\n+    private static TargetType checkValid(TargetType targetType, int rangeFrom, int rangeTo) {\n+        Objects.requireNonNull(targetType);\n+        if (targetType.targetTypeValue() < rangeFrom || targetType.targetTypeValue() > rangeTo)\n+            throw new IllegalArgumentException(\"Wrong target type specified \" + targetType);\n+        return targetType;\n+    }\n+\n+    public record TypeParameterTargetImpl(TargetType targetType, int typeParameterIndex)\n+            implements TypeParameterTarget {\n+\n+        public TypeParameterTargetImpl(TargetType targetType, int typeParameterIndex) {\n+            this.targetType = checkValid(targetType, TAT_CLASS_TYPE_PARAMETER, TAT_METHOD_TYPE_PARAMETER);\n+            this.typeParameterIndex = typeParameterIndex;\n+        }\n+    }\n+\n+    public record SupertypeTargetImpl(int supertypeIndex) implements SupertypeTarget {\n+        @Override\n+        public TargetType targetType() {\n+            return TargetType.CLASS_EXTENDS;\n+        }\n+    }\n+\n+    public record TypeParameterBoundTargetImpl(TargetType targetType, int typeParameterIndex, int boundIndex)\n+            implements TypeParameterBoundTarget {\n+\n+        public TypeParameterBoundTargetImpl(TargetType targetType, int typeParameterIndex, int boundIndex) {\n+            this.targetType = checkValid(targetType, TAT_CLASS_TYPE_PARAMETER_BOUND, TAT_METHOD_TYPE_PARAMETER_BOUND);\n+            this.typeParameterIndex = typeParameterIndex;\n+            this.boundIndex = boundIndex;\n+        }\n+    }\n+\n+    public record EmptyTargetImpl(TargetType targetType) implements EmptyTarget {\n+\n+        public EmptyTargetImpl(TargetType targetType) {\n+            this.targetType = checkValid(targetType, TAT_FIELD, TAT_METHOD_RECEIVER);\n+        }\n+    }\n+\n+    public record FormalParameterTargetImpl(int formalParameterIndex) implements FormalParameterTarget {\n+        @Override\n+        public TargetType targetType() {\n+            return TargetType.METHOD_FORMAL_PARAMETER;\n+        }\n+    }\n+\n+    public record ThrowsTargetImpl(int throwsTargetIndex) implements ThrowsTarget {\n+        @Override\n+        public TargetType targetType() {\n+            return TargetType.THROWS;\n+        }\n+    }\n+\n+    public record LocalVarTargetImpl(TargetType targetType, List<LocalVarTargetInfo> table)\n+            implements LocalVarTarget {\n+\n+        public LocalVarTargetImpl(TargetType targetType, List<LocalVarTargetInfo> table) {\n+            this.targetType = checkValid(targetType, TAT_LOCAL_VARIABLE, TAT_RESOURCE_VARIABLE);\n+            this.table = List.copyOf(table);\n+        }\n+        @Override\n+        public int size() {\n+            return 2 + 6 * table.size();\n+        }\n+    }\n+\n+    public record LocalVarTargetInfoImpl(Label startLabel, Label endLabel, int index)\n+            implements LocalVarTargetInfo {\n+    }\n+\n+    public record CatchTargetImpl(int exceptionTableIndex) implements CatchTarget {\n+        @Override\n+        public TargetType targetType() {\n+            return TargetType.EXCEPTION_PARAMETER;\n+        }\n+    }\n+\n+    public record OffsetTargetImpl(TargetType targetType, Label target) implements OffsetTarget {\n+\n+        public OffsetTargetImpl(TargetType targetType, Label target) {\n+            this.targetType = checkValid(targetType, TAT_INSTANCEOF, TAT_METHOD_REFERENCE);\n+            this.target = target;\n+        }\n+    }\n+\n+    public record TypeArgumentTargetImpl(TargetType targetType, Label target, int typeArgumentIndex)\n+            implements TypeArgumentTarget {\n+\n+        public TypeArgumentTargetImpl(TargetType targetType, Label target, int typeArgumentIndex) {\n+            this.targetType = checkValid(targetType, TAT_CAST, TAT_METHOD_REFERENCE_TYPE_ARGUMENT);\n+            this.target = target;\n+            this.typeArgumentIndex = typeArgumentIndex;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.FloatEntry;\n+import jdk.internal.classfile.constantpool.IntegerEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.MethodTypeEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static jdk.internal.classfile.Classfile.TAG_METHODTYPE;\n+\n+public final class TemporaryConstantPool implements ConstantPoolBuilder {\n+\n+    private TemporaryConstantPool() {};\n+\n+    public static final TemporaryConstantPool INSTANCE = new TemporaryConstantPool();\n+\n+    @Override\n+    public Utf8Entry utf8Entry(String s) {\n+        return new ConcreteEntry.ConcreteUtf8Entry(this, -1, s);\n+    }\n+\n+    @Override\n+    public IntegerEntry intEntry(int value) {\n+        return new ConcreteEntry.ConcreteIntegerEntry(this, -1, value);\n+    }\n+\n+    @Override\n+    public FloatEntry floatEntry(float value) {\n+        return new ConcreteEntry.ConcreteFloatEntry(this, -1, value);\n+    }\n+\n+    @Override\n+    public LongEntry longEntry(long value) {\n+        return new ConcreteEntry.ConcreteLongEntry(this, -1, value);\n+    }\n+\n+    @Override\n+    public DoubleEntry doubleEntry(double value) {\n+        return new ConcreteEntry.ConcreteDoubleEntry(this, -1, value);\n+    }\n+\n+    @Override\n+    public ClassEntry classEntry(Utf8Entry name) {\n+        return new ConcreteEntry.ConcreteClassEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) name);\n+    }\n+\n+    @Override\n+    public PackageEntry packageEntry(Utf8Entry name) {\n+        return new ConcreteEntry.ConcretePackageEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) name);\n+    }\n+\n+    @Override\n+    public ModuleEntry moduleEntry(Utf8Entry name) {\n+        return new ConcreteEntry.ConcreteModuleEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) name);\n+    }\n+\n+    @Override\n+    public NameAndTypeEntry natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n+        return new ConcreteEntry.ConcreteNameAndTypeEntry(this, -3,\n+                                                          (ConcreteEntry.ConcreteUtf8Entry) nameEntry,\n+                                                          (ConcreteEntry.ConcreteUtf8Entry) typeEntry);\n+    }\n+\n+    @Override\n+    public FieldRefEntry fieldRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType) {\n+        return new ConcreteEntry.ConcreteFieldRefEntry(this, -3,\n+                                                       (ConcreteEntry.ConcreteClassEntry) owner,\n+                                                       (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+    }\n+\n+    @Override\n+    public MethodRefEntry methodRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType) {\n+        return new ConcreteEntry.ConcreteMethodRefEntry(this, -3,\n+                                                        (ConcreteEntry.ConcreteClassEntry) owner,\n+                                                        (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+    }\n+\n+    @Override\n+    public InterfaceMethodRefEntry interfaceMethodRefEntry(ClassEntry owner, NameAndTypeEntry nameAndType) {\n+        return new ConcreteEntry.ConcreteInterfaceMethodRefEntry(this, -3,\n+                                                                 (ConcreteEntry.ConcreteClassEntry) owner,\n+                                                                 (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+    }\n+\n+    @Override\n+    public MethodTypeEntry methodTypeEntry(MethodTypeDesc descriptor) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public MethodTypeEntry methodTypeEntry(Utf8Entry descriptor) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public MethodHandleEntry methodHandleEntry(int refKind, MemberRefEntry reference) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InvokeDynamicEntry invokeDynamicEntry(BootstrapMethodEntry bootstrapMethodEntry, NameAndTypeEntry nameAndType) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public ConstantDynamicEntry constantDynamicEntry(BootstrapMethodEntry bootstrapMethodEntry, NameAndTypeEntry nameAndType) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public StringEntry stringEntry(Utf8Entry utf8) {\n+        return new ConcreteEntry.ConcreteStringEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) utf8);\n+    }\n+\n+    @Override\n+    public BootstrapMethodEntry bsmEntry(MethodHandleEntry methodReference, List<LoadableConstantEntry> arguments) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public PoolEntry entryByIndex(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int entryCount() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public BootstrapMethodEntry bootstrapMethodEntry(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int bootstrapMethodCount() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean canWriteDirect(ConstantPool constantPool) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean writeBootstrapMethods(BufWriter buf) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter buf) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+\n+\/**\n+ * TerminalCodeBuilder\n+ *\/\n+public sealed interface TerminalCodeBuilder extends CodeBuilder\n+        permits DirectCodeBuilder, BufferedCodeBuilder, TransformingCodeBuilder {\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.FieldBuilder;\n+\n+\/**\n+ * TerminalFieldBuilder\n+ *\/\n+public sealed interface TerminalFieldBuilder\n+        extends FieldBuilder\n+        permits DirectFieldBuilder, BufferedFieldBuilder {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalFieldBuilder.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.MethodBuilder;\n+\n+\/**\n+ * TerminalMethodBuilder\n+ *\/\n+public sealed interface TerminalMethodBuilder\n+        extends MethodBuilder\n+        permits BufferedMethodBuilder, DirectMethodBuilder {\n+    BufferedCodeBuilder bufferedCodeBuilder(CodeModel original);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalMethodBuilder.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.ClassfileTransform;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldBuilder;\n+import jdk.internal.classfile.FieldElement;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.FieldTransform;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodTransform;\n+\n+\/**\n+ * TransformImpl\n+ *\/\n+public class TransformImpl {\n+    \/\/ ClassTransform\n+\n+    private TransformImpl() {\n+    }\n+\n+    private static Runnable chainRunnable(Runnable a, Runnable b) {\n+        return () -> { a.run(); b.run(); };\n+    }\n+\n+    private static final Runnable NOTHING = () -> { };\n+\n+    interface FakeClassTransform extends ClassTransform {\n+        @Override\n+        default void accept(ClassBuilder builder, ClassElement element) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atEnd(ClassBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atStart(ClassBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+    }\n+\n+    public record ClassTransformImpl(Consumer<ClassElement> consumer,\n+                                     Runnable endHandler,\n+                                     Runnable startHandler)\n+            implements ClassfileTransform.ResolvedTransform<ClassElement> {\n+\n+        public ClassTransformImpl(Consumer<ClassElement> consumer) {\n+            this(consumer, NOTHING, NOTHING);\n+        }\n+    }\n+\n+    public record ChainedClassTransform(ClassTransform t,\n+                                        ClassTransform next)\n+            implements FakeClassTransform {\n+        @Override\n+        public ClassTransformImpl resolve(ClassBuilder builder) {\n+            ResolvedTransform<ClassElement> downstream = next.resolve(builder);\n+            ClassBuilder chainedBuilder = new ChainedClassBuilder(builder, downstream.consumer());\n+            ResolvedTransform<ClassElement> upstream = t.resolve(chainedBuilder);\n+            return new ClassTransformImpl(upstream.consumer(),\n+                                          chainRunnable(upstream.endHandler(), downstream.endHandler()),\n+                                          chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+        }\n+    }\n+\n+    public record SupplierClassTransform(Supplier<ClassTransform> supplier)\n+            implements FakeClassTransform {\n+        @Override\n+        public ResolvedTransform<ClassElement> resolve(ClassBuilder builder) {\n+            return supplier.get().resolve(builder);\n+        }\n+    }\n+\n+    public record ClassMethodTransform(MethodTransform transform,\n+                                       Predicate<MethodModel> filter)\n+            implements FakeClassTransform {\n+        @Override\n+        public ClassTransformImpl resolve(ClassBuilder builder) {\n+            return new ClassTransformImpl(ce -> {\n+                if (ce instanceof MethodModel mm && filter.test(mm))\n+                    builder.transformMethod(mm, transform);\n+                else\n+                    builder.with(ce);\n+            });\n+        }\n+\n+        @Override\n+        public ClassTransform andThen(ClassTransform next) {\n+            if (next instanceof ClassMethodTransform cmt)\n+                return new ClassMethodTransform(transform.andThen(cmt.transform),\n+                                                mm -> filter.test(mm) && cmt.filter.test(mm));\n+            else\n+                return FakeClassTransform.super.andThen(next);\n+        }\n+    }\n+\n+    public record ClassFieldTransform(FieldTransform transform,\n+                                      Predicate<FieldModel> filter)\n+            implements FakeClassTransform {\n+        @Override\n+        public ClassTransformImpl resolve(ClassBuilder builder) {\n+            return new ClassTransformImpl(ce -> {\n+                if (ce instanceof FieldModel fm && filter.test(fm))\n+                    builder.transformField(fm, transform);\n+                else\n+                    builder.with(ce);\n+            });\n+        }\n+\n+        @Override\n+        public ClassTransform andThen(ClassTransform next) {\n+            if (next instanceof ClassFieldTransform cft)\n+                return new ClassFieldTransform(transform.andThen(cft.transform),\n+                                               mm -> filter.test(mm) && cft.filter.test(mm));\n+            else\n+                return FakeClassTransform.super.andThen(next);\n+        }\n+    }\n+\n+    \/\/ MethodTransform\n+\n+    interface FakeMethodTransform extends MethodTransform {\n+        @Override\n+        default void accept(MethodBuilder builder, MethodElement element) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atEnd(MethodBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atStart(MethodBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+    }\n+\n+    public record MethodTransformImpl(Consumer<MethodElement> consumer,\n+                                      Runnable endHandler,\n+                                      Runnable startHandler)\n+            implements ClassfileTransform.ResolvedTransform<MethodElement> {\n+    }\n+\n+    public record ChainedMethodTransform(MethodTransform t,\n+                                         MethodTransform next)\n+            implements TransformImpl.FakeMethodTransform {\n+        @Override\n+        public ResolvedTransform<MethodElement> resolve(MethodBuilder builder) {\n+            ResolvedTransform<MethodElement> downstream = next.resolve(builder);\n+            MethodBuilder chainedBuilder = new ChainedMethodBuilder(builder, downstream.consumer());\n+            ResolvedTransform<MethodElement> upstream = t.resolve(chainedBuilder);\n+            return new MethodTransformImpl(upstream.consumer(),\n+                                           chainRunnable(upstream.endHandler(), downstream.endHandler()),\n+                                           chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+        }\n+    }\n+\n+    public record SupplierMethodTransform(Supplier<MethodTransform> supplier)\n+            implements TransformImpl.FakeMethodTransform {\n+        @Override\n+        public ResolvedTransform<MethodElement> resolve(MethodBuilder builder) {\n+            return supplier.get().resolve(builder);\n+        }\n+    }\n+\n+    public record MethodCodeTransform(CodeTransform xform)\n+            implements TransformImpl.FakeMethodTransform {\n+        @Override\n+        public ResolvedTransform<MethodElement> resolve(MethodBuilder builder) {\n+            return new MethodTransformImpl(me -> {\n+                if (me instanceof CodeModel cm) {\n+                    builder.transformCode(cm, xform);\n+                }\n+                else {\n+                    builder.with(me);\n+                }\n+            }, NOTHING, NOTHING);\n+        }\n+\n+        @Override\n+        public MethodTransform andThen(MethodTransform next) {\n+            return (next instanceof TransformImpl.MethodCodeTransform mct)\n+                   ? new TransformImpl.MethodCodeTransform(xform.andThen(mct.xform))\n+                   : FakeMethodTransform.super.andThen(next);\n+\n+        }\n+    }\n+\n+    \/\/ FieldTransform\n+\n+    interface FakeFieldTransform extends FieldTransform {\n+        @Override\n+        default void accept(FieldBuilder builder, FieldElement element) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atEnd(FieldBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atStart(FieldBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+    }\n+\n+    public record FieldTransformImpl(Consumer<FieldElement> consumer,\n+                                     Runnable endHandler,\n+                                     Runnable startHandler)\n+            implements ClassfileTransform.ResolvedTransform<FieldElement> {\n+    }\n+\n+    public record ChainedFieldTransform(FieldTransform t, FieldTransform next)\n+            implements FakeFieldTransform {\n+        @Override\n+        public FieldTransformImpl resolve(FieldBuilder builder) {\n+            ResolvedTransform<FieldElement> downstream = next.resolve(builder);\n+            FieldBuilder chainedBuilder = new ChainedFieldBuilder(builder, downstream.consumer());\n+            ResolvedTransform<FieldElement> upstream = t.resolve(chainedBuilder);\n+            return new FieldTransformImpl(upstream.consumer(),\n+                                           chainRunnable(upstream.endHandler(), downstream.endHandler()),\n+                                           chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+        }\n+    }\n+\n+    public record SupplierFieldTransform(Supplier<FieldTransform> supplier)\n+            implements FakeFieldTransform {\n+        @Override\n+        public ResolvedTransform<FieldElement> resolve(FieldBuilder builder) {\n+            return supplier.get().resolve(builder);\n+        }\n+    }\n+\n+    \/\/ CodeTransform\n+\n+    interface FakeCodeTransform extends CodeTransform {\n+        @Override\n+        default void accept(CodeBuilder builder, CodeElement element) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atEnd(CodeBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+\n+        @Override\n+        default void atStart(CodeBuilder builder) {\n+            throw new UnsupportedOperationException(\"transforms must be resolved before running\");\n+        }\n+    }\n+\n+    public record CodeTransformImpl(Consumer<CodeElement> consumer,\n+                                    Runnable endHandler,\n+                                    Runnable startHandler)\n+            implements ClassfileTransform.ResolvedTransform<CodeElement> {\n+    }\n+\n+    public record ChainedCodeTransform(CodeTransform t, CodeTransform next)\n+            implements FakeCodeTransform {\n+        @Override\n+        public CodeTransformImpl resolve(CodeBuilder builder) {\n+            ResolvedTransform<CodeElement> downstream = next.resolve(builder);\n+            CodeBuilder chainedBuilder = new ChainedCodeBuilder(builder, downstream.consumer());\n+            ResolvedTransform<CodeElement> upstream = t.resolve(chainedBuilder);\n+            return new CodeTransformImpl(upstream.consumer(),\n+                                         chainRunnable(upstream.endHandler(), downstream.endHandler()),\n+                                         chainRunnable(upstream.startHandler(), downstream.startHandler()));\n+        }\n+    }\n+\n+    public record SupplierCodeTransform(Supplier<CodeTransform> supplier)\n+            implements FakeCodeTransform {\n+        @Override\n+        public ResolvedTransform<CodeElement> resolve(CodeBuilder builder) {\n+            return supplier.get().resolve(builder);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeModel;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+\n+\/**\n+ * TransformingCodeBuilder\n+ *\/\n+public final class TransformingCodeBuilder implements TerminalCodeBuilder {\n+\n+    final CodeBuilder delegate;\n+    final Consumer<CodeElement> consumer;\n+\n+    public TransformingCodeBuilder(CodeBuilder delegate, Consumer<CodeElement> consumer) {\n+        this.delegate = delegate;\n+        this.consumer = consumer;\n+    }\n+\n+    @Override\n+    public CodeBuilder with(CodeElement e) {\n+        consumer.accept(e);\n+        return this;\n+    }\n+\n+    @Override\n+    public Optional<CodeModel> original() {\n+        return delegate.original();\n+    }\n+\n+    @Override\n+    public Label newLabel() {\n+        return delegate.newLabel();\n+    }\n+\n+    @Override\n+    public Label startLabel() {\n+        return delegate.startLabel();\n+    }\n+\n+    @Override\n+    public Label endLabel() {\n+        return delegate.endLabel();\n+    }\n+\n+    @Override\n+    public int receiverSlot() {\n+        return delegate.receiverSlot();\n+    }\n+\n+    @Override\n+    public int parameterSlot(int paramNo) {\n+        return delegate.parameterSlot(paramNo);\n+    }\n+\n+    @Override\n+    public int allocateLocal(TypeKind typeKind) {\n+        return delegate.allocateLocal(typeKind);\n+    }\n+\n+    @Override\n+    public ConstantPoolBuilder constantPool() {\n+        return delegate.constantPool();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformingCodeBuilder.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,950 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.AttributeMapper;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.BootstrapMethodsAttribute;\n+import jdk.internal.classfile.attribute.CharacterRangeInfo;\n+import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n+import jdk.internal.classfile.attribute.CompilationIDAttribute;\n+import jdk.internal.classfile.attribute.ConstantValueAttribute;\n+import jdk.internal.classfile.attribute.DeprecatedAttribute;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.attribute.LineNumberInfo;\n+import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableInfo;\n+import jdk.internal.classfile.attribute.LocalVariableTableAttribute;\n+import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n+import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n+import jdk.internal.classfile.attribute.MethodParameterInfo;\n+import jdk.internal.classfile.attribute.MethodParametersAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleHashInfo;\n+import jdk.internal.classfile.attribute.ModuleHashesAttribute;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModuleOpenInfo;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleProvideInfo;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+import jdk.internal.classfile.attribute.ModuleResolutionAttribute;\n+import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n+import jdk.internal.classfile.attribute.NestHostAttribute;\n+import jdk.internal.classfile.attribute.NestMembersAttribute;\n+import jdk.internal.classfile.attribute.PermittedSubclassesAttribute;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleTypeAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.attribute.SourceDebugExtensionAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.attribute.SourceIDAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute.StackMapFrameInfo;\n+import jdk.internal.classfile.attribute.SyntheticAttribute;\n+import jdk.internal.classfile.constantpool.ConstantValueEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+\/**\n+ * UnboundAttribute\n+ *\/\n+public abstract sealed class UnboundAttribute<T extends Attribute<T>>\n+        extends AbstractElement\n+        implements Attribute<T> {\n+    protected final AttributeMapper<T> mapper;\n+\n+    public UnboundAttribute(AttributeMapper<T> mapper) {\n+        this.mapper = mapper;\n+    }\n+\n+    @Override\n+    public AttributeMapper<T> attributeMapper() {\n+        return mapper;\n+    }\n+\n+    @Override\n+    public String attributeName() {\n+        return mapper.name();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void writeTo(BufWriter buf) {\n+        mapper.writeAttribute(buf, (T) this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectClassBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectCodeBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectMethodBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public void writeTo(DirectFieldBuilder builder) {\n+        builder.writeAttribute(this);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Attribute[name=%s]\", mapper.name());\n+    }\n+    public static final class UnboundConstantValueAttribute\n+            extends UnboundAttribute<ConstantValueAttribute>\n+            implements ConstantValueAttribute {\n+\n+        private final ConstantValueEntry entry;\n+\n+        public UnboundConstantValueAttribute(ConstantValueEntry entry) {\n+            super(Attributes.CONSTANT_VALUE);\n+            this.entry = entry;\n+        }\n+\n+        @Override\n+        public ConstantValueEntry constant() {\n+            return entry;\n+        }\n+\n+    }\n+\n+    public static final class UnboundDeprecatedAttribute\n+            extends UnboundAttribute<DeprecatedAttribute>\n+            implements DeprecatedAttribute {\n+        public UnboundDeprecatedAttribute() {\n+            super(Attributes.DEPRECATED);\n+        }\n+    }\n+\n+    public static final class UnboundSyntheticAttribute\n+            extends UnboundAttribute<SyntheticAttribute>\n+            implements SyntheticAttribute {\n+        public UnboundSyntheticAttribute() {\n+            super(Attributes.SYNTHETIC);\n+        }\n+    }\n+\n+    public static final class UnboundSignatureAttribute\n+            extends UnboundAttribute<SignatureAttribute>\n+            implements SignatureAttribute {\n+        private final Utf8Entry signature;\n+\n+        public UnboundSignatureAttribute(Utf8Entry signature) {\n+            super(Attributes.SIGNATURE);\n+            this.signature = signature;\n+        }\n+\n+        @Override\n+        public Utf8Entry signature() {\n+            return signature;\n+        }\n+    }\n+\n+    public static final class UnboundExceptionsAttribute\n+            extends UnboundAttribute<ExceptionsAttribute>\n+            implements ExceptionsAttribute {\n+        private final List<ClassEntry> exceptions;\n+\n+        public UnboundExceptionsAttribute(List<ClassEntry> exceptions) {\n+            super(Attributes.EXCEPTIONS);\n+            this.exceptions = List.copyOf(exceptions);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> exceptions() {\n+            return exceptions;\n+        }\n+    }\n+\n+    public static final class UnboundAnnotationDefaultAttribute\n+            extends UnboundAttribute<AnnotationDefaultAttribute>\n+            implements AnnotationDefaultAttribute {\n+        private final AnnotationValue annotationDefault;\n+\n+        public UnboundAnnotationDefaultAttribute(AnnotationValue annotationDefault) {\n+            super(Attributes.ANNOTATION_DEFAULT);\n+            this.annotationDefault = annotationDefault;\n+        }\n+\n+        @Override\n+        public AnnotationValue defaultValue() {\n+            return annotationDefault;\n+        }\n+    }\n+\n+    public static final class UnboundSourceFileAttribute extends UnboundAttribute<SourceFileAttribute>\n+            implements SourceFileAttribute {\n+        private final Utf8Entry sourceFile;\n+\n+        public UnboundSourceFileAttribute(Utf8Entry sourceFile) {\n+            super(Attributes.SOURCE_FILE);\n+            this.sourceFile = sourceFile;\n+        }\n+\n+        @Override\n+        public Utf8Entry sourceFile() {\n+            return sourceFile;\n+        }\n+\n+    }\n+\n+    public static final class UnboundStackMapTableAttribute extends UnboundAttribute<StackMapTableAttribute>\n+            implements StackMapTableAttribute {\n+        private final List<StackMapFrameInfo> entries;\n+\n+        public UnboundStackMapTableAttribute(List<StackMapFrameInfo> entries) {\n+            super(Attributes.STACK_MAP_TABLE);\n+            this.entries = List.copyOf(entries);\n+        }\n+\n+        @Override\n+        public List<StackMapFrameInfo> entries() {\n+            return entries;\n+        }\n+    }\n+\n+    public static final class UnboundInnerClassesAttribute\n+            extends UnboundAttribute<InnerClassesAttribute>\n+            implements InnerClassesAttribute {\n+        private final List<InnerClassInfo> innerClasses;\n+\n+        public UnboundInnerClassesAttribute(List<InnerClassInfo> innerClasses) {\n+            super(Attributes.INNER_CLASSES);\n+            this.innerClasses = List.copyOf(innerClasses);\n+        }\n+\n+        @Override\n+        public List<InnerClassInfo> classes() {\n+            return innerClasses;\n+        }\n+    }\n+\n+    public static final class UnboundRecordAttribute\n+            extends UnboundAttribute<RecordAttribute>\n+            implements RecordAttribute {\n+        private final List<RecordComponentInfo> components;\n+\n+        public UnboundRecordAttribute(List<RecordComponentInfo> components) {\n+            super(Attributes.RECORD);\n+            this.components = List.copyOf(components);\n+        }\n+\n+        @Override\n+        public List<RecordComponentInfo> components() {\n+            return components;\n+        }\n+    }\n+\n+    public static final class UnboundEnclosingMethodAttribute\n+            extends UnboundAttribute<EnclosingMethodAttribute>\n+            implements EnclosingMethodAttribute {\n+        private final ClassEntry classEntry;\n+        private final NameAndTypeEntry method;\n+\n+        public UnboundEnclosingMethodAttribute(ClassEntry classEntry, NameAndTypeEntry method) {\n+            super(Attributes.ENCLOSING_METHOD);\n+            this.classEntry = classEntry;\n+            this.method = method;\n+        }\n+\n+        @Override\n+        public ClassEntry enclosingClass() {\n+            return classEntry;\n+        }\n+\n+        @Override\n+        public Optional<NameAndTypeEntry> enclosingMethod() {\n+            return Optional.ofNullable(method);\n+        }\n+    }\n+\n+    public static final class UnboundMethodParametersAttribute\n+            extends UnboundAttribute<MethodParametersAttribute>\n+            implements MethodParametersAttribute {\n+        private final List<MethodParameterInfo> parameters;\n+\n+        public UnboundMethodParametersAttribute(List<MethodParameterInfo> parameters) {\n+            super(Attributes.METHOD_PARAMETERS);\n+            this.parameters = List.copyOf(parameters);\n+        }\n+\n+        @Override\n+        public List<MethodParameterInfo> parameters() {\n+            return parameters;\n+        }\n+    }\n+\n+    public static final class UnboundModuleTargetAttribute\n+            extends UnboundAttribute<ModuleTargetAttribute>\n+            implements ModuleTargetAttribute {\n+        final Utf8Entry moduleTarget;\n+\n+        public UnboundModuleTargetAttribute(Utf8Entry moduleTarget) {\n+            super(Attributes.MODULE_TARGET);\n+            this.moduleTarget = moduleTarget;\n+        }\n+\n+        @Override\n+        public Utf8Entry targetPlatform() {\n+            return moduleTarget;\n+        }\n+    }\n+\n+    public static final class UnboundModuleMainClassAttribute\n+            extends UnboundAttribute<ModuleMainClassAttribute>\n+            implements ModuleMainClassAttribute {\n+        final ClassEntry mainClass;\n+\n+        public UnboundModuleMainClassAttribute(ClassEntry mainClass) {\n+            super(Attributes.MODULE_MAIN_CLASS);\n+            this.mainClass = mainClass;\n+        }\n+\n+        @Override\n+        public ClassEntry mainClass() {\n+            return mainClass;\n+        }\n+    }\n+\n+    public static final class UnboundModuleHashesAttribute\n+            extends UnboundAttribute<ModuleHashesAttribute>\n+            implements ModuleHashesAttribute {\n+        private final Utf8Entry algorithm;\n+        private final List<ModuleHashInfo> hashes;\n+\n+        public UnboundModuleHashesAttribute(Utf8Entry algorithm, List<ModuleHashInfo> hashes) {\n+            super(Attributes.MODULE_HASHES);\n+            this.algorithm = algorithm;\n+            this.hashes = List.copyOf(hashes);\n+        }\n+\n+        @Override\n+        public Utf8Entry algorithm() {\n+            return algorithm;\n+        }\n+\n+        @Override\n+        public List<ModuleHashInfo> hashes() {\n+            return hashes;\n+        }\n+    }\n+\n+    public static final class UnboundModulePackagesAttribute\n+            extends UnboundAttribute<ModulePackagesAttribute>\n+            implements ModulePackagesAttribute {\n+        private final Collection<PackageEntry> packages;\n+\n+        public UnboundModulePackagesAttribute(Collection<PackageEntry> packages) {\n+            super(Attributes.MODULE_PACKAGES);\n+            this.packages = List.copyOf(packages);\n+        }\n+\n+        @Override\n+        public List<PackageEntry> packages() {\n+            return List.copyOf(packages);\n+        }\n+    }\n+\n+    public static final class UnboundModuleResolutionAttribute\n+            extends UnboundAttribute<ModuleResolutionAttribute>\n+            implements ModuleResolutionAttribute {\n+        private final int resolutionFlags;\n+\n+        public UnboundModuleResolutionAttribute(int flags) {\n+            super(Attributes.MODULE_RESOLUTION);\n+            resolutionFlags = flags;\n+        }\n+\n+        @Override\n+        public int resolutionFlags() {\n+            return resolutionFlags;\n+        }\n+    }\n+\n+    public static final class UnboundPermittedSubclassesAttribute\n+            extends UnboundAttribute<PermittedSubclassesAttribute>\n+            implements PermittedSubclassesAttribute {\n+        private final List<ClassEntry> permittedSubclasses;\n+\n+        public UnboundPermittedSubclassesAttribute(List<ClassEntry> permittedSubclasses) {\n+            super(Attributes.PERMITTED_SUBCLASSES);\n+            this.permittedSubclasses = List.copyOf(permittedSubclasses);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> permittedSubclasses() {\n+            return permittedSubclasses;\n+        }\n+    }\n+\n+    public static final class UnboundNestMembersAttribute\n+            extends UnboundAttribute<NestMembersAttribute>\n+            implements NestMembersAttribute {\n+        private final List<ClassEntry> memberEntries;\n+\n+        public UnboundNestMembersAttribute(List<ClassEntry> memberEntries) {\n+            super(Attributes.NEST_MEMBERS);\n+            this.memberEntries = List.copyOf(memberEntries);\n+        }\n+\n+        @Override\n+        public List<ClassEntry> nestMembers() {\n+            return memberEntries;\n+        }\n+    }\n+\n+    public static final class UnboundNestHostAttribute\n+            extends UnboundAttribute<NestHostAttribute>\n+            implements NestHostAttribute {\n+        private final ClassEntry hostEntry;\n+\n+        public UnboundNestHostAttribute(ClassEntry hostEntry) {\n+            super(Attributes.NEST_HOST);\n+            this.hostEntry = hostEntry;\n+        }\n+\n+        @Override\n+        public ClassEntry nestHost() {\n+            return hostEntry;\n+        }\n+    }\n+\n+    public static final class UnboundCompilationIDAttribute\n+            extends UnboundAttribute<CompilationIDAttribute>\n+            implements CompilationIDAttribute {\n+        private final Utf8Entry idEntry;\n+\n+        public UnboundCompilationIDAttribute(Utf8Entry idEntry) {\n+            super(Attributes.COMPILATION_ID);\n+            this.idEntry = idEntry;\n+        }\n+\n+        @Override\n+        public Utf8Entry compilationId() {\n+            return idEntry;\n+        }\n+    }\n+\n+    public static final class UnboundSourceIDAttribute\n+            extends UnboundAttribute<SourceIDAttribute>\n+            implements SourceIDAttribute {\n+        private final Utf8Entry idEntry;\n+\n+        public UnboundSourceIDAttribute(Utf8Entry idEntry) {\n+            super(Attributes.SOURCE_ID);\n+            this.idEntry = idEntry;\n+        }\n+\n+        @Override\n+        public Utf8Entry sourceId() {\n+            return idEntry;\n+        }\n+    }\n+\n+    public static final class UnboundSourceDebugExtensionAttribute\n+        extends UnboundAttribute<SourceDebugExtensionAttribute>\n+            implements SourceDebugExtensionAttribute {\n+        private final byte[] contents;\n+\n+        public UnboundSourceDebugExtensionAttribute(byte[] contents) {\n+            super(Attributes.SOURCE_DEBUG_EXTENSION);\n+            this.contents = contents;\n+        }\n+\n+        @Override\n+        public byte[] contents() {\n+            return contents;\n+        }\n+    }\n+\n+    public static final class UnboundCharacterRangeTableAttribute\n+        extends UnboundAttribute<CharacterRangeTableAttribute>\n+            implements CharacterRangeTableAttribute {\n+        private final List<CharacterRangeInfo> ranges;\n+\n+        public UnboundCharacterRangeTableAttribute(List<CharacterRangeInfo> ranges) {\n+            super(Attributes.CHARACTER_RANGE_TABLE);\n+            this.ranges = List.copyOf(ranges);\n+        }\n+\n+        @Override\n+        public List<CharacterRangeInfo> characterRangeTable() {\n+            return ranges;\n+        }\n+    }\n+\n+    public static final class UnboundLineNumberTableAttribute\n+        extends UnboundAttribute<LineNumberTableAttribute>\n+            implements LineNumberTableAttribute {\n+        private final List<LineNumberInfo> lines;\n+\n+        public UnboundLineNumberTableAttribute(List<LineNumberInfo> lines) {\n+            super(Attributes.LINE_NUMBER_TABLE);\n+            this.lines = List.copyOf(lines);\n+        }\n+\n+        @Override\n+        public List<LineNumberInfo> lineNumbers() {\n+            return lines;\n+        }\n+    }\n+\n+    public static final class UnboundLocalVariableTableAttribute\n+        extends UnboundAttribute<LocalVariableTableAttribute>\n+            implements LocalVariableTableAttribute {\n+        private final List<LocalVariableInfo> locals;\n+\n+        public UnboundLocalVariableTableAttribute(List<LocalVariableInfo> locals) {\n+            super(Attributes.LOCAL_VARIABLE_TABLE);\n+            this.locals = List.copyOf(locals);\n+        }\n+\n+        @Override\n+        public List<LocalVariableInfo> localVariables() {\n+            return locals;\n+        }\n+    }\n+\n+    public static final class UnboundLocalVariableTypeTableAttribute\n+        extends UnboundAttribute<LocalVariableTypeTableAttribute>\n+            implements LocalVariableTypeTableAttribute {\n+        private final List<LocalVariableTypeInfo> locals;\n+\n+        public UnboundLocalVariableTypeTableAttribute(List<LocalVariableTypeInfo> locals) {\n+            super(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+            this.locals = List.copyOf(locals);\n+        }\n+\n+        @Override\n+        public List<LocalVariableTypeInfo> localVariableTypes() {\n+            return locals;\n+        }\n+    }\n+\n+    public static final class UnboundRuntimeVisibleAnnotationsAttribute\n+            extends UnboundAttribute<RuntimeVisibleAnnotationsAttribute>\n+            implements RuntimeVisibleAnnotationsAttribute {\n+        private final List<Annotation> elements;\n+\n+        public UnboundRuntimeVisibleAnnotationsAttribute(List<Annotation> elements) {\n+            super(Attributes.RUNTIME_VISIBLE_ANNOTATIONS);\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        @Override\n+        public List<Annotation> annotations() {\n+            return elements;\n+        }\n+    }\n+\n+    public static final class UnboundRuntimeInvisibleAnnotationsAttribute\n+            extends UnboundAttribute<RuntimeInvisibleAnnotationsAttribute>\n+            implements RuntimeInvisibleAnnotationsAttribute {\n+        private final List<Annotation> elements;\n+\n+        public UnboundRuntimeInvisibleAnnotationsAttribute(List<Annotation> elements) {\n+            super(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS);\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        @Override\n+        public List<Annotation> annotations() {\n+            return elements;\n+        }\n+    }\n+\n+    public static final class UnboundRuntimeVisibleParameterAnnotationsAttribute\n+            extends UnboundAttribute<RuntimeVisibleParameterAnnotationsAttribute>\n+            implements RuntimeVisibleParameterAnnotationsAttribute {\n+        private final List<List<Annotation>> elements;\n+\n+        public UnboundRuntimeVisibleParameterAnnotationsAttribute(List<List<Annotation>> elements) {\n+            super(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS);\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        @Override\n+        public List<List<Annotation>> parameterAnnotations() {\n+            return elements;\n+        }\n+    }\n+\n+    public static final class UnboundRuntimeInvisibleParameterAnnotationsAttribute\n+            extends UnboundAttribute<RuntimeInvisibleParameterAnnotationsAttribute>\n+            implements RuntimeInvisibleParameterAnnotationsAttribute {\n+        private final List<List<Annotation>> elements;\n+\n+        public UnboundRuntimeInvisibleParameterAnnotationsAttribute(List<List<Annotation>> elements) {\n+            super(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS);\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        @Override\n+        public List<List<Annotation>> parameterAnnotations() {\n+            return elements;\n+        }\n+    }\n+\n+    public static final class UnboundRuntimeVisibleTypeAnnotationsAttribute\n+            extends UnboundAttribute<RuntimeVisibleTypeAnnotationsAttribute>\n+            implements RuntimeVisibleTypeAnnotationsAttribute {\n+        private final List<TypeAnnotation> elements;\n+\n+        public UnboundRuntimeVisibleTypeAnnotationsAttribute(List<TypeAnnotation> elements) {\n+            super(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        @Override\n+        public List<TypeAnnotation> annotations() {\n+            return elements;\n+        }\n+    }\n+\n+    public static final class UnboundRuntimeInvisibleTypeAnnotationsAttribute\n+            extends UnboundAttribute<RuntimeInvisibleTypeAnnotationsAttribute>\n+            implements RuntimeInvisibleTypeAnnotationsAttribute {\n+        private final List<TypeAnnotation> elements;\n+\n+        public UnboundRuntimeInvisibleTypeAnnotationsAttribute(List<TypeAnnotation> elements) {\n+            super(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        @Override\n+        public List<TypeAnnotation> annotations() {\n+            return elements;\n+        }\n+    }\n+\n+    public record UnboundCharacterRangeInfo(int startPc, int endPc,\n+                                            int characterRangeStart,\n+                                            int characterRangeEnd,\n+                                            int flags)\n+            implements CharacterRangeInfo { }\n+\n+    public record UnboundInnerClassInfo(ClassEntry innerClass,\n+                                        Optional<ClassEntry> outerClass,\n+                                        Optional<Utf8Entry> innerName,\n+                                        int flagsMask)\n+            implements InnerClassInfo {}\n+\n+    public record UnboundLineNumberInfo(int startPc, int lineNumber)\n+            implements LineNumberInfo { }\n+\n+    public record UnboundLocalVariableInfo(int startPc, int length,\n+                                           Utf8Entry name,\n+                                           Utf8Entry type,\n+                                           int slot)\n+            implements LocalVariableInfo { }\n+\n+    public record UnboundLocalVariableTypeInfo(int startPc, int length,\n+                                               Utf8Entry name,\n+                                               Utf8Entry signature,\n+                                               int slot)\n+            implements LocalVariableTypeInfo { }\n+\n+    public record UnboundMethodParameterInfo(Optional<Utf8Entry> name, int flagsMask)\n+            implements MethodParameterInfo {}\n+\n+    public record UnboundModuleExportInfo(PackageEntry exportedPackage,\n+                                          int exportsFlagsMask,\n+                                          List<ModuleEntry> exportsTo)\n+            implements ModuleExportInfo {\n+        public UnboundModuleExportInfo(PackageEntry exportedPackage, int exportsFlagsMask,\n+                                       List<ModuleEntry> exportsTo) {\n+            this.exportedPackage = exportedPackage;\n+            this.exportsFlagsMask = exportsFlagsMask;\n+            this.exportsTo = List.copyOf(exportsTo);\n+        }\n+    }\n+\n+    public record UnboundModuleHashInfo(ModuleEntry moduleName,\n+                                        byte[] hash) implements ModuleHashInfo { }\n+\n+    public record UnboundModuleOpenInfo(PackageEntry openedPackage, int opensFlagsMask,\n+                                        List<ModuleEntry> opensTo)\n+            implements ModuleOpenInfo {\n+        public UnboundModuleOpenInfo(PackageEntry openedPackage, int opensFlagsMask,\n+                                     List<ModuleEntry> opensTo) {\n+            this.openedPackage = openedPackage;\n+            this.opensFlagsMask = opensFlagsMask;\n+            this.opensTo = List.copyOf(opensTo);\n+        }\n+    }\n+\n+    public record UnboundModuleProvideInfo(ClassEntry provides,\n+                                           List<ClassEntry> providesWith)\n+            implements ModuleProvideInfo {\n+        public UnboundModuleProvideInfo(ClassEntry provides, List<ClassEntry> providesWith) {\n+            this.provides = provides;\n+            this.providesWith = List.copyOf(providesWith);\n+        }\n+    }\n+\n+    public record UnboundModuleRequiresInfo(ModuleEntry requires, int requiresFlagsMask,\n+                                            Optional<Utf8Entry> requiresVersion)\n+            implements ModuleRequireInfo {}\n+\n+    public record UnboundRecordComponentInfo(Utf8Entry name,\n+                                             Utf8Entry descriptor,\n+                                             List<Attribute<?>> attributes)\n+            implements RecordComponentInfo {\n+        public UnboundRecordComponentInfo(Utf8Entry name, Utf8Entry descriptor, List<Attribute<?>> attributes) {\n+            this.name = name;\n+            this.descriptor = descriptor;\n+            this.attributes = List.copyOf(attributes);\n+        }\n+    }\n+\n+    public record UnboundTypeAnnotation(TargetInfo targetInfo,\n+                                        List<TypePathComponent> targetPath,\n+                                        Utf8Entry className,\n+                                        List<AnnotationElement> elements) implements TypeAnnotation {\n+\n+        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n+                                     Utf8Entry className, List<AnnotationElement> elements) {\n+            this.targetInfo = targetInfo;\n+            this.targetPath = List.copyOf(targetPath);\n+            this.className = className;\n+            this.elements = List.copyOf(elements);\n+        }\n+\n+        private int labelToBci(LabelContext lr, Label label) {\n+            \/\/helper method to avoid NPE\n+            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n+            return lr.labelToBci(label);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter buf) {\n+            LabelContext lr = ((BufWriterImpl) buf).labelContext();\n+            \/\/ target_type\n+            buf.writeU1(targetInfo.targetType().targetTypeValue());\n+\n+            \/\/ target_info\n+            switch (targetInfo) {\n+                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+                case TypeParameterBoundTarget tpbt -> {\n+                    buf.writeU1(tpbt.typeParameterIndex());\n+                    buf.writeU1(tpbt.boundIndex());\n+                }\n+                case EmptyTarget et -> {\n+                    \/\/ nothing to write\n+                }\n+                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+                case LocalVarTarget lvt -> {\n+                    buf.writeU2(lvt.table().size());\n+                    for (var e : lvt.table()) {\n+                        int startPc = labelToBci(lr, e.startLabel());\n+                        buf.writeU2(startPc);\n+                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n+                        buf.writeU2(e.index());\n+                    }\n+                }\n+                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n+                case TypeArgumentTarget tat -> {\n+                    buf.writeU2(labelToBci(lr, tat.target()));\n+                    buf.writeU1(tat.typeArgumentIndex());\n+                }\n+            }\n+\n+            \/\/ target_path\n+            buf.writeU1(targetPath().size());\n+            for (TypePathComponent component : targetPath()) {\n+                buf.writeU1(component.typePathKind().tag());\n+                buf.writeU1(component.typeArgumentIndex());\n+            }\n+\n+            \/\/ type_index\n+            buf.writeIndex(className);\n+\n+            \/\/ element_value_pairs\n+            buf.writeU2(elements.size());\n+            for (AnnotationElement pair : elements()) {\n+                buf.writeIndex(pair.name());\n+                pair.value().writeTo(buf);\n+            }\n+        }\n+    }\n+\n+    public record TypePathComponentImpl(TypeAnnotation.TypePathComponent.Kind typePathKind, int typeArgumentIndex)\n+            implements TypeAnnotation.TypePathComponent {}\n+\n+    public static final class UnboundModuleAttribute extends UnboundAttribute<ModuleAttribute> implements ModuleAttribute {\n+        private final ModuleEntry moduleName;\n+        private final int moduleFlags;\n+        private final Utf8Entry moduleVersion;\n+        private final List<ModuleRequireInfo> requires;\n+        private final List<ModuleExportInfo> exports;\n+        private final List<ModuleOpenInfo> opens;\n+        private final List<ClassEntry> uses;\n+        private final List<ModuleProvideInfo> provides;\n+\n+        public UnboundModuleAttribute(ModuleEntry moduleName,\n+                                      int moduleFlags,\n+                                      Utf8Entry moduleVersion,\n+                                      Collection<ModuleRequireInfo> requires,\n+                                      Collection<ModuleExportInfo> exports,\n+                                      Collection<ModuleOpenInfo> opens,\n+                                      Collection<ClassEntry> uses,\n+                                      Collection<ModuleProvideInfo> provides)\n+        {\n+            super(Attributes.MODULE);\n+            this.moduleName = moduleName;\n+            this.moduleFlags = moduleFlags;\n+            this.moduleVersion = moduleVersion;\n+            this.requires = List.copyOf(requires);\n+            this.exports = List.copyOf(exports);\n+            this.opens = List.copyOf(opens);\n+            this.uses = List.copyOf(uses);\n+            this.provides = List.copyOf(provides);\n+        }\n+\n+        @Override\n+        public ModuleEntry moduleName() {\n+            return moduleName;\n+        }\n+\n+        @Override\n+        public int moduleFlagsMask() {\n+            return moduleFlags;\n+        }\n+\n+        @Override\n+        public Optional<Utf8Entry> moduleVersion() {\n+            return Optional.ofNullable(moduleVersion);\n+        }\n+\n+        @Override\n+        public List<ModuleRequireInfo> requires() {\n+            return requires;\n+        }\n+\n+        @Override\n+        public List<ModuleExportInfo> exports() {\n+            return exports;\n+        }\n+\n+        @Override\n+        public List<ModuleOpenInfo> opens() {\n+            return opens;\n+        }\n+\n+        @Override\n+        public List<ClassEntry> uses() {\n+            return uses;\n+        }\n+\n+        @Override\n+        public List<ModuleProvideInfo> provides() {\n+            return provides;\n+        }\n+    }\n+\n+    public static abstract non-sealed class AdHocAttribute<T extends Attribute<T>>\n+            extends UnboundAttribute<T> {\n+\n+        public AdHocAttribute(AttributeMapper<T> mapper) {\n+            super(mapper);\n+        }\n+\n+        public abstract void writeBody(BufWriter b);\n+\n+        @Override\n+        public void writeTo(BufWriter b) {\n+            b.writeIndex(b.constantPool().utf8Entry(mapper.name()));\n+            b.writeInt(0);\n+            int start = b.size();\n+            writeBody(b);\n+            int written = b.size() - start;\n+            b.patchInt(start - 4, 4, written);\n+        }\n+    }\n+\n+    public static final class EmptyBootstrapAttribute\n+            extends UnboundAttribute<BootstrapMethodsAttribute>\n+            implements BootstrapMethodsAttribute {\n+        public EmptyBootstrapAttribute() {\n+            super(Attributes.BOOTSTRAP_METHODS);\n+        }\n+\n+        @Override\n+        public int bootstrapMethodsSize() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public List<BootstrapMethodEntry> bootstrapMethods() {\n+            return List.of();\n+        }\n+    }\n+\n+    public static abstract sealed class CustomAttribute<T extends CustomAttribute<T>>\n+            extends UnboundAttribute<T>\n+            permits jdk.internal.classfile.CustomAttribute {\n+\n+        public CustomAttribute(AttributeMapper<T> mapper) {\n+            super(mapper);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":950,"deletions":0,"binary":false,"changes":950,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.AbstractList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import java.lang.reflect.AccessFlag;\n+\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * Helper to create and manipulate type descriptors, where type descriptors are\n+ * represented as JVM type descriptor strings and symbols are represented as\n+ * name strings\n+ *\/\n+public class Util {\n+\n+    private Util() {\n+    }\n+\n+    public static String arrayOf(CharSequence s) {\n+        return \"[\" + s;\n+    }\n+\n+    public static BitSet findParams(String type) {\n+        BitSet bs = new BitSet();\n+        if (type.charAt(0) != '(')\n+            throw new IllegalArgumentException();\n+        for (int i = 1; i < type.length(); ++i) {\n+            switch (type.charAt(i)) {\n+                case '[':\n+                    bs.set(i);\n+                    while (type.charAt(++i) == '[')\n+                        ;\n+                    if (type.charAt(i) == 'L') {\n+                        while (type.charAt(++i) != ';')\n+                            ;\n+                    }\n+                    break;\n+                case ')':\n+                    i = type.length();\n+                    break;\n+                default:\n+                    bs.set(i);\n+                    if (type.charAt(i) == 'L') {\n+                        while (type.charAt(++i) != ';')\n+                            ;\n+                    }\n+            }\n+        }\n+        return bs;\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    public static int parameterSlots(String type) {\n+        BitSet bs = findParams(type);\n+        int count = 0;\n+        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n+            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        }\n+        return count;\n+    }\n+\n+    public static int[] parseParameterSlots(int flags, String type) {\n+        BitSet bs = findParams(type);\n+        int[] result = new int[bs.cardinality()];\n+        int index = 0;\n+        int count = ((flags & ACC_STATIC) != 0) ? 0 : 1;\n+        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n+            result[index++] = count;\n+            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        }\n+        return result;\n+    }\n+\n+    public static int maxLocals(int flags, String type) {\n+        BitSet bs = findParams(type);\n+        int count = ((flags & ACC_STATIC) != 0) ? 0 : 1;\n+        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1))\n+            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        return count;\n+    }\n+\n+    public static String toClassString(String desc) {\n+        \/\/TODO: this doesn't look right L ... ;\n+        return desc.replaceAll(\"\/\", \".\");\n+    }\n+\n+    public static Iterator<String> parameterTypes(String s) {\n+        \/\/TODO: gracefully non-method types\n+        return new Iterator<>() {\n+            int ch = 1;\n+\n+            public boolean hasNext() {\n+                return s.charAt(ch) != ')';\n+            }\n+\n+            public String next() {\n+                char curr = s.charAt(ch);\n+                switch (curr) {\n+                    case 'C', 'B', 'S', 'I', 'J', 'F', 'D', 'Z':\n+                        ch++;\n+                        return String.valueOf(curr);\n+                    case '[':\n+                        ch++;\n+                        return \"[\" + next();\n+                    case 'L': {\n+                        int start = ch;\n+                        while (s.charAt(++ch) != ';') { }\n+                        ++ch;\n+                        return s.substring(start, ch);\n+                    }\n+                    default:\n+                        throw new AssertionError(\"cannot parse string: \" + s);\n+                }\n+            }\n+        };\n+    }\n+\n+    public static String returnDescriptor(String s) {\n+        return s.substring(s.indexOf(')') + 1);\n+    }\n+\n+    public static String toInternalName(ClassDesc cd) {\n+        var desc = cd.descriptorString();\n+        return switch (desc.charAt(0)) {\n+            case '[' -> desc;\n+            case 'L' -> desc.substring(1, desc.length() - 1);\n+            default -> throw new IllegalArgumentException(desc);\n+        };\n+    }\n+\n+    public static ClassDesc toClassDesc(String classInternalNameOrArrayDesc) {\n+        return classInternalNameOrArrayDesc.charAt(0) == '['\n+                ? ClassDesc.ofDescriptor(classInternalNameOrArrayDesc)\n+                : ClassDesc.ofInternalName(classInternalNameOrArrayDesc);\n+    }\n+\n+    public static<T, U> List<U> mappedList(List<? extends T> list, Function<T, U> mapper) {\n+        return new AbstractList<>() {\n+            @Override\n+            public U get(int index) {\n+                return mapper.apply(list.get(index));\n+            }\n+\n+            @Override\n+            public int size() {\n+                return list.size();\n+            }\n+        };\n+    }\n+\n+    public static List<ClassEntry> entryList(List<? extends ClassDesc> list) {\n+        var result = new Object[list.size()]; \/\/ null check\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(toInternalName(list.get(i))));\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(result);\n+    }\n+\n+    public static List<ModuleEntry> moduleEntryList(List<? extends ModuleDesc> list) {\n+        var result = new Object[list.size()]; \/\/ null check\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = TemporaryConstantPool.INSTANCE.moduleEntry(TemporaryConstantPool.INSTANCE.utf8Entry(list.get(i).moduleName()));\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArrayNullsAllowed(result);\n+    }\n+\n+    public static void checkKind(Opcode op, Opcode.Kind k) {\n+        if (op.kind() != k)\n+            throw new IllegalArgumentException(\n+                    String.format(\"Wrong opcode kind specified; found %s(%s), expected %s\", op, op.kind(), k));\n+    }\n+\n+    public static int flagsToBits(AccessFlag.Location location, Collection<AccessFlag> flags) {\n+        int i = 0;\n+        for (AccessFlag f : flags) {\n+            if (!f.locations().contains(location)) {\n+                throw new IllegalArgumentException(\"unexpected flag: \" + f + \" use in target location: \" + location);\n+            }\n+            i |= f.mask();\n+        }\n+        return i;\n+    }\n+\n+    public static int flagsToBits(AccessFlag.Location location, AccessFlag... flags) {\n+        int i = 0;\n+        for (AccessFlag f : flags) {\n+            if (!f.locations().contains(location)) {\n+                throw new IllegalArgumentException(\"unexpected flag: \" + f + \" use in target location: \" + location);\n+            }\n+            i |= f.mask();\n+        }\n+        return i;\n+    }\n+\n+    public static boolean has(AccessFlag.Location location, int flagsMask, AccessFlag flag) {\n+        return (flag.mask() & flagsMask) == flag.mask() && flag.locations().contains(location);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,403 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import java.nio.ByteBuffer;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.impl.verifier.VerificationSignature.BasicType;\n+import static jdk.internal.classfile.impl.verifier.VerificationSignature.BasicType.*;\n+\n+\/**\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.hpp\">hotspot\/share\/interpreter\/bytecodes.hpp<\/a>\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.cpp\">hotspot\/share\/interpreter\/bytecodes.cpp<\/a>\n+ *\/\n+class VerificationBytecodes {\n+\n+    static final int _breakpoint = 202,\n+            number_of_java_codes = 203,\n+            _fast_agetfield = 203,\n+            _fast_bgetfield = 204,\n+            _fast_cgetfield = 205,\n+            _fast_dgetfield = 206,\n+            _fast_fgetfield = 207,\n+            _fast_igetfield = 208,\n+            _fast_lgetfield = 209,\n+            _fast_sgetfield = 210,\n+            _fast_aputfield = 211,\n+            _fast_bputfield = 212,\n+            _fast_zputfield = 213,\n+            _fast_cputfield = 214,\n+            _fast_dputfield = 215,\n+            _fast_fputfield = 216,\n+            _fast_iputfield = 217,\n+            _fast_lputfield = 218,\n+            _fast_sputfield = 219,\n+            _fast_aload_0 = 220,\n+            _fast_iaccess_0 = 221,\n+            _fast_aaccess_0 = 222,\n+            _fast_faccess_0 = 223,\n+            _fast_iload = 224,\n+            _fast_iload2 = 225,\n+            _fast_icaload = 226,\n+            _fast_invokevfinal = 227,\n+            _fast_linearswitch = 228,\n+            _fast_binaryswitch = 229,\n+            _fast_aldc = 230,\n+            _fast_aldc_w = 231,\n+            _return_register_finalizer = 232,\n+            _invokehandle = 233,\n+            _nofast_getfield = 234,\n+            _nofast_putfield = 235,\n+            _nofast_aload_0 = 236,\n+            _nofast_iload = 237,\n+            _shouldnotreachhere = 238,\n+            number_of_codes = 239;\n+\n+    static int code_or_bp_at(byte[] code, int bci) {\n+        return code[bci] & 0xff;\n+    }\n+\n+    static boolean is_valid(int code) {\n+        return 0 <= code && code < number_of_codes;\n+    }\n+\n+    static int length_for(int code) {\n+        return is_valid(code) ? _lengths[code] & 0xf : -1;\n+    }\n+\n+    static int wide_length_for(int code) {\n+        return is_valid(code) ? _lengths[code] >> 4 : -1;\n+    }\n+\n+    static boolean is_store_into_local(int code) {\n+        return (Classfile.ISTORE <= code && code <= Classfile.ASTORE_3);\n+    }\n+\n+    static final int _lengths[] = new int[number_of_codes];\n+\n+    static int special_length_at(int code, byte bytecode[], int bci, int end) {\n+        switch (code) {\n+            case Classfile.WIDE:\n+                if (bci + 1 >= end) {\n+                    return -1;\n+                }\n+                return wide_length_for(bytecode[bci + 1] & 0xff);\n+            case Classfile.TABLESWITCH:\n+                int aligned_bci = align(bci + 1);\n+                if (aligned_bci + 3 * 4 >= end) {\n+                    return -1;\n+                }\n+                ByteBuffer bb = ByteBuffer.wrap(bytecode, aligned_bci + 1 * 4, 2 * 4);\n+                int lo = bb.getInt();\n+                int hi = bb.getInt();\n+                int len = aligned_bci - bci + (3 + hi - lo + 1) * 4;\n+                return len > 0 ? len : -1;\n+            case Classfile.LOOKUPSWITCH:\n+            case _fast_binaryswitch:\n+            case _fast_linearswitch:\n+                aligned_bci = align(bci + 1);\n+                if (aligned_bci + 2 * 4 >= end) {\n+                    return -1;\n+                }\n+                int npairs = ByteBuffer.wrap(bytecode, aligned_bci + 4, 4).getInt();\n+                len = aligned_bci - bci + (2 + 2 * npairs) * 4;\n+                return len > 0 ? len : -1;\n+            default:\n+                return 0;\n+        }\n+    }\n+\n+    static int align(int n) {\n+        return (n + 3) & ~3;\n+    }\n+\n+    static int raw_special_length_at(byte bytecode[], int bci, int end) {\n+        int code = code_or_bp_at(bytecode, bci);\n+        if (code == _breakpoint) {\n+            return 1;\n+        } else {\n+            return special_length_at(code, bytecode, bci, end);\n+        }\n+    }\n+\n+    static void def(int code, String name, String format, String wide_format, BasicType result_type, int depth) {\n+        def(code, name, format, wide_format, result_type, depth, code);\n+    }\n+\n+    static void def(int code, String name, String format, String wide_format, BasicType result_type, int depth, int java_code) {\n+        if (wide_format != null && format == null) throw new IllegalArgumentException(\"short form must exist if there's a wide form\");\n+        int len = format != null ? format.length() : 0;\n+        int wlen = wide_format != null ? wide_format.length() : 0;\n+        _lengths[code] = (wlen << 4) | (len & 0xf);\n+    }\n+\n+    static {\n+        def(Classfile.NOP, \"nop\", \"b\", null, T_VOID, 0);\n+        def(Classfile.ACONST_NULL, \"aconst_null\", \"b\", null, T_OBJECT, 1);\n+        def(Classfile.ICONST_M1, \"iconst_m1\", \"b\", null, T_INT, 1);\n+        def(Classfile.ICONST_0, \"iconst_0\", \"b\", null, T_INT, 1);\n+        def(Classfile.ICONST_1, \"iconst_1\", \"b\", null, T_INT, 1);\n+        def(Classfile.ICONST_2, \"iconst_2\", \"b\", null, T_INT, 1);\n+        def(Classfile.ICONST_3, \"iconst_3\", \"b\", null, T_INT, 1);\n+        def(Classfile.ICONST_4, \"iconst_4\", \"b\", null, T_INT, 1);\n+        def(Classfile.ICONST_5, \"iconst_5\", \"b\", null, T_INT, 1);\n+        def(Classfile.LCONST_0, \"lconst_0\", \"b\", null, T_LONG, 2);\n+        def(Classfile.LCONST_1, \"lconst_1\", \"b\", null, T_LONG, 2);\n+        def(Classfile.FCONST_0, \"fconst_0\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.FCONST_1, \"fconst_1\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.FCONST_2, \"fconst_2\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.DCONST_0, \"dconst_0\", \"b\", null, T_DOUBLE, 2);\n+        def(Classfile.DCONST_1, \"dconst_1\", \"b\", null, T_DOUBLE, 2);\n+        def(Classfile.BIPUSH, \"bipush\", \"bc\", null, T_INT, 1);\n+        def(Classfile.SIPUSH, \"sipush\", \"bcc\", null, T_INT, 1);\n+        def(Classfile.LDC, \"ldc\", \"bk\", null, T_ILLEGAL, 1);\n+        def(Classfile.LDC_W, \"ldc_w\", \"bkk\", null, T_ILLEGAL, 1);\n+        def(Classfile.LDC2_W, \"ldc2_w\", \"bkk\", null, T_ILLEGAL, 2);\n+        def(Classfile.ILOAD, \"iload\", \"bi\", \"wbii\", T_INT, 1);\n+        def(Classfile.LLOAD, \"lload\", \"bi\", \"wbii\", T_LONG, 2);\n+        def(Classfile.FLOAD, \"fload\", \"bi\", \"wbii\", T_FLOAT, 1);\n+        def(Classfile.DLOAD, \"dload\", \"bi\", \"wbii\", T_DOUBLE, 2);\n+        def(Classfile.ALOAD, \"aload\", \"bi\", \"wbii\", T_OBJECT, 1);\n+        def(Classfile.ILOAD_0, \"iload_0\", \"b\", null, T_INT, 1);\n+        def(Classfile.ILOAD_1, \"iload_1\", \"b\", null, T_INT, 1);\n+        def(Classfile.ILOAD_2, \"iload_2\", \"b\", null, T_INT, 1);\n+        def(Classfile.ILOAD_3, \"iload_3\", \"b\", null, T_INT, 1);\n+        def(Classfile.LLOAD_0, \"lload_0\", \"b\", null, T_LONG, 2);\n+        def(Classfile.LLOAD_1, \"lload_1\", \"b\", null, T_LONG, 2);\n+        def(Classfile.LLOAD_2, \"lload_2\", \"b\", null, T_LONG, 2);\n+        def(Classfile.LLOAD_3, \"lload_3\", \"b\", null, T_LONG, 2);\n+        def(Classfile.FLOAD_0, \"fload_0\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.FLOAD_1, \"fload_1\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.FLOAD_2, \"fload_2\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.FLOAD_3, \"fload_3\", \"b\", null, T_FLOAT, 1);\n+        def(Classfile.DLOAD_0, \"dload_0\", \"b\", null, T_DOUBLE, 2);\n+        def(Classfile.DLOAD_1, \"dload_1\", \"b\", null, T_DOUBLE, 2);\n+        def(Classfile.DLOAD_2, \"dload_2\", \"b\", null, T_DOUBLE, 2);\n+        def(Classfile.DLOAD_3, \"dload_3\", \"b\", null, T_DOUBLE, 2);\n+        def(Classfile.ALOAD_0, \"aload_0\", \"b\", null, T_OBJECT, 1);\n+        def(Classfile.ALOAD_1, \"aload_1\", \"b\", null, T_OBJECT, 1);\n+        def(Classfile.ALOAD_2, \"aload_2\", \"b\", null, T_OBJECT, 1);\n+        def(Classfile.ALOAD_3, \"aload_3\", \"b\", null, T_OBJECT, 1);\n+        def(Classfile.IALOAD, \"iaload\", \"b\", null, T_INT, -1);\n+        def(Classfile.LALOAD, \"laload\", \"b\", null, T_LONG, 0);\n+        def(Classfile.FALOAD, \"faload\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DALOAD, \"daload\", \"b\", null, T_DOUBLE, 0);\n+        def(Classfile.AALOAD, \"aaload\", \"b\", null, T_OBJECT, -1);\n+        def(Classfile.BALOAD, \"baload\", \"b\", null, T_INT, -1);\n+        def(Classfile.CALOAD, \"caload\", \"b\", null, T_INT, -1);\n+        def(Classfile.SALOAD, \"saload\", \"b\", null, T_INT, -1);\n+        def(Classfile.ISTORE, \"istore\", \"bi\", \"wbii\", T_VOID, -1);\n+        def(Classfile.LSTORE, \"lstore\", \"bi\", \"wbii\", T_VOID, -2);\n+        def(Classfile.FSTORE, \"fstore\", \"bi\", \"wbii\", T_VOID, -1);\n+        def(Classfile.DSTORE, \"dstore\", \"bi\", \"wbii\", T_VOID, -2);\n+        def(Classfile.ASTORE, \"astore\", \"bi\", \"wbii\", T_VOID, -1);\n+        def(Classfile.ISTORE_0, \"istore_0\", \"b\", null, T_VOID, -1);\n+        def(Classfile.ISTORE_1, \"istore_1\", \"b\", null, T_VOID, -1);\n+        def(Classfile.ISTORE_2, \"istore_2\", \"b\", null, T_VOID, -1);\n+        def(Classfile.ISTORE_3, \"istore_3\", \"b\", null, T_VOID, -1);\n+        def(Classfile.LSTORE_0, \"lstore_0\", \"b\", null, T_VOID, -2);\n+        def(Classfile.LSTORE_1, \"lstore_1\", \"b\", null, T_VOID, -2);\n+        def(Classfile.LSTORE_2, \"lstore_2\", \"b\", null, T_VOID, -2);\n+        def(Classfile.LSTORE_3, \"lstore_3\", \"b\", null, T_VOID, -2);\n+        def(Classfile.FSTORE_0, \"fstore_0\", \"b\", null, T_VOID, -1);\n+        def(Classfile.FSTORE_1, \"fstore_1\", \"b\", null, T_VOID, -1);\n+        def(Classfile.FSTORE_2, \"fstore_2\", \"b\", null, T_VOID, -1);\n+        def(Classfile.FSTORE_3, \"fstore_3\", \"b\", null, T_VOID, -1);\n+        def(Classfile.DSTORE_0, \"dstore_0\", \"b\", null, T_VOID, -2);\n+        def(Classfile.DSTORE_1, \"dstore_1\", \"b\", null, T_VOID, -2);\n+        def(Classfile.DSTORE_2, \"dstore_2\", \"b\", null, T_VOID, -2);\n+        def(Classfile.DSTORE_3, \"dstore_3\", \"b\", null, T_VOID, -2);\n+        def(Classfile.ASTORE_0, \"astore_0\", \"b\", null, T_VOID, -1);\n+        def(Classfile.ASTORE_1, \"astore_1\", \"b\", null, T_VOID, -1);\n+        def(Classfile.ASTORE_2, \"astore_2\", \"b\", null, T_VOID, -1);\n+        def(Classfile.ASTORE_3, \"astore_3\", \"b\", null, T_VOID, -1);\n+        def(Classfile.IASTORE, \"iastore\", \"b\", null, T_VOID, -3);\n+        def(Classfile.LASTORE, \"lastore\", \"b\", null, T_VOID, -4);\n+        def(Classfile.FASTORE, \"fastore\", \"b\", null, T_VOID, -3);\n+        def(Classfile.DASTORE, \"dastore\", \"b\", null, T_VOID, -4);\n+        def(Classfile.AASTORE, \"aastore\", \"b\", null, T_VOID, -3);\n+        def(Classfile.BASTORE, \"bastore\", \"b\", null, T_VOID, -3);\n+        def(Classfile.CASTORE, \"castore\", \"b\", null, T_VOID, -3);\n+        def(Classfile.SASTORE, \"sastore\", \"b\", null, T_VOID, -3);\n+        def(Classfile.POP, \"pop\", \"b\", null, T_VOID, -1);\n+        def(Classfile.POP2, \"pop2\", \"b\", null, T_VOID, -2);\n+        def(Classfile.DUP, \"dup\", \"b\", null, T_VOID, 1);\n+        def(Classfile.DUP_X1, \"dup_x1\", \"b\", null, T_VOID, 1);\n+        def(Classfile.DUP_X2, \"dup_x2\", \"b\", null, T_VOID, 1);\n+        def(Classfile.DUP2, \"dup2\", \"b\", null, T_VOID, 2);\n+        def(Classfile.DUP2_X1, \"dup2_x1\", \"b\", null, T_VOID, 2);\n+        def(Classfile.DUP2_X2, \"dup2_x2\", \"b\", null, T_VOID, 2);\n+        def(Classfile.SWAP, \"swap\", \"b\", null, T_VOID, 0);\n+        def(Classfile.IADD, \"iadd\", \"b\", null, T_INT, -1);\n+        def(Classfile.LADD, \"ladd\", \"b\", null, T_LONG, -2);\n+        def(Classfile.FADD, \"fadd\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DADD, \"dadd\", \"b\", null, T_DOUBLE, -2);\n+        def(Classfile.ISUB, \"isub\", \"b\", null, T_INT, -1);\n+        def(Classfile.LSUB, \"lsub\", \"b\", null, T_LONG, -2);\n+        def(Classfile.FSUB, \"fsub\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DSUB, \"dsub\", \"b\", null, T_DOUBLE, -2);\n+        def(Classfile.IMUL, \"imul\", \"b\", null, T_INT, -1);\n+        def(Classfile.LMUL, \"lmul\", \"b\", null, T_LONG, -2);\n+        def(Classfile.FMUL, \"fmul\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DMUL, \"dmul\", \"b\", null, T_DOUBLE, -2);\n+        def(Classfile.IDIV, \"idiv\", \"b\", null, T_INT, -1);\n+        def(Classfile.LDIV, \"ldiv\", \"b\", null, T_LONG, -2);\n+        def(Classfile.FDIV, \"fdiv\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DDIV, \"ddiv\", \"b\", null, T_DOUBLE, -2);\n+        def(Classfile.IREM, \"irem\", \"b\", null, T_INT, -1);\n+        def(Classfile.LREM, \"lrem\", \"b\", null, T_LONG, -2);\n+        def(Classfile.FREM, \"frem\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DREM, \"drem\", \"b\", null, T_DOUBLE, -2);\n+        def(Classfile.INEG, \"ineg\", \"b\", null, T_INT, 0);\n+        def(Classfile.LNEG, \"lneg\", \"b\", null, T_LONG, 0);\n+        def(Classfile.FNEG, \"fneg\", \"b\", null, T_FLOAT, 0);\n+        def(Classfile.DNEG, \"dneg\", \"b\", null, T_DOUBLE, 0);\n+        def(Classfile.ISHL, \"ishl\", \"b\", null, T_INT, -1);\n+        def(Classfile.LSHL, \"lshl\", \"b\", null, T_LONG, -1);\n+        def(Classfile.ISHR, \"ishr\", \"b\", null, T_INT, -1);\n+        def(Classfile.LSHR, \"lshr\", \"b\", null, T_LONG, -1);\n+        def(Classfile.IUSHR, \"iushr\", \"b\", null, T_INT, -1);\n+        def(Classfile.LUSHR, \"lushr\", \"b\", null, T_LONG, -1);\n+        def(Classfile.IAND, \"iand\", \"b\", null, T_INT, -1);\n+        def(Classfile.LAND, \"land\", \"b\", null, T_LONG, -2);\n+        def(Classfile.IOR, \"ior\", \"b\", null, T_INT, -1);\n+        def(Classfile.LOR, \"lor\", \"b\", null, T_LONG, -2);\n+        def(Classfile.IXOR, \"ixor\", \"b\", null, T_INT, -1);\n+        def(Classfile.LXOR, \"lxor\", \"b\", null, T_LONG, -2);\n+        def(Classfile.IINC, \"iinc\", \"bic\", \"wbiicc\", T_VOID, 0);\n+        def(Classfile.I2L, \"i2l\", \"b\", null, T_LONG, 1);\n+        def(Classfile.I2F, \"i2f\", \"b\", null, T_FLOAT, 0);\n+        def(Classfile.I2D, \"i2d\", \"b\", null, T_DOUBLE, 1);\n+        def(Classfile.L2I, \"l2i\", \"b\", null, T_INT, -1);\n+        def(Classfile.L2F, \"l2f\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.L2D, \"l2d\", \"b\", null, T_DOUBLE, 0);\n+        def(Classfile.F2I, \"f2i\", \"b\", null, T_INT, 0);\n+        def(Classfile.F2L, \"f2l\", \"b\", null, T_LONG, 1);\n+        def(Classfile.F2D, \"f2d\", \"b\", null, T_DOUBLE, 1);\n+        def(Classfile.D2I, \"d2i\", \"b\", null, T_INT, -1);\n+        def(Classfile.D2L, \"d2l\", \"b\", null, T_LONG, 0);\n+        def(Classfile.D2F, \"d2f\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.I2B, \"i2b\", \"b\", null, T_BYTE, 0);\n+        def(Classfile.I2C, \"i2c\", \"b\", null, T_CHAR, 0);\n+        def(Classfile.I2S, \"i2s\", \"b\", null, T_SHORT, 0);\n+        def(Classfile.LCMP, \"lcmp\", \"b\", null, T_VOID, -3);\n+        def(Classfile.FCMPL, \"fcmpl\", \"b\", null, T_VOID, -1);\n+        def(Classfile.FCMPG, \"fcmpg\", \"b\", null, T_VOID, -1);\n+        def(Classfile.DCMPL, \"dcmpl\", \"b\", null, T_VOID, -3);\n+        def(Classfile.DCMPG, \"dcmpg\", \"b\", null, T_VOID, -3);\n+        def(Classfile.IFEQ, \"ifeq\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IFNE, \"ifne\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IFLT, \"iflt\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IFGE, \"ifge\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IFGT, \"ifgt\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IFLE, \"ifle\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IF_ICMPEQ, \"if_icmpeq\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ICMPNE, \"if_icmpne\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ICMPLT, \"if_icmplt\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ICMPGE, \"if_icmpge\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ICMPGT, \"if_icmpgt\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ICMPLE, \"if_icmple\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ACMPEQ, \"if_acmpeq\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.IF_ACMPNE, \"if_acmpne\", \"boo\", null, T_VOID, -2);\n+        def(Classfile.GOTO, \"goto\", \"boo\", null, T_VOID, 0);\n+        def(Classfile.JSR, \"jsr\", \"boo\", null, T_INT, 0);\n+        def(Classfile.RET, \"ret\", \"bi\", \"wbii\", T_VOID, 0);\n+        def(Classfile.TABLESWITCH, \"tableswitch\", \"\", null, T_VOID, -1); \/\/ may have backward branches\n+        def(Classfile.LOOKUPSWITCH, \"lookupswitch\", \"\", null, T_VOID, -1); \/\/ rewriting in interpreter\n+        def(Classfile.IRETURN, \"ireturn\", \"b\", null, T_INT, -1);\n+        def(Classfile.LRETURN, \"lreturn\", \"b\", null, T_LONG, -2);\n+        def(Classfile.FRETURN, \"freturn\", \"b\", null, T_FLOAT, -1);\n+        def(Classfile.DRETURN, \"dreturn\", \"b\", null, T_DOUBLE, -2);\n+        def(Classfile.ARETURN, \"areturn\", \"b\", null, T_OBJECT, -1);\n+        def(Classfile.RETURN, \"return\", \"b\", null, T_VOID, 0);\n+        def(Classfile.GETSTATIC, \"getstatic\", \"bJJ\", null, T_ILLEGAL, 1);\n+        def(Classfile.PUTSTATIC, \"putstatic\", \"bJJ\", null, T_ILLEGAL, -1);\n+        def(Classfile.GETFIELD, \"getfield\", \"bJJ\", null, T_ILLEGAL, 0);\n+        def(Classfile.PUTFIELD, \"putfield\", \"bJJ\", null, T_ILLEGAL, -2);\n+        def(Classfile.INVOKEVIRTUAL, \"invokevirtual\", \"bJJ\", null, T_ILLEGAL, -1);\n+        def(Classfile.INVOKESPECIAL, \"invokespecial\", \"bJJ\", null, T_ILLEGAL, -1);\n+        def(Classfile.INVOKESTATIC, \"invokestatic\", \"bJJ\", null, T_ILLEGAL, 0);\n+        def(Classfile.INVOKEINTERFACE, \"invokeinterface\", \"bJJ__\", null, T_ILLEGAL, -1);\n+        def(Classfile.INVOKEDYNAMIC, \"invokedynamic\", \"bJJJJ\", null, T_ILLEGAL, 0);\n+        def(Classfile.NEW, \"new\", \"bkk\", null, T_OBJECT, 1);\n+        def(Classfile.NEWARRAY, \"newarray\", \"bc\", null, T_OBJECT, 0);\n+        def(Classfile.ANEWARRAY, \"anewarray\", \"bkk\", null, T_OBJECT, 0);\n+        def(Classfile.ARRAYLENGTH, \"arraylength\", \"b\", null, T_VOID, 0);\n+        def(Classfile.ATHROW, \"athrow\", \"b\", null, T_VOID, -1);\n+        def(Classfile.CHECKCAST, \"checkcast\", \"bkk\", null, T_OBJECT, 0);\n+        def(Classfile.INSTANCEOF, \"instanceof\", \"bkk\", null, T_INT, 0);\n+        def(Classfile.MONITORENTER, \"monitorenter\", \"b\", null, T_VOID, -1);\n+        def(Classfile.MONITOREXIT, \"monitorexit\", \"b\", null, T_VOID, -1);\n+        def(Classfile.WIDE, \"wide\", \"\", null, T_VOID, 0);\n+        def(Classfile.MULTIANEWARRAY, \"multianewarray\", \"bkkc\", null, T_OBJECT, 1);\n+        def(Classfile.IFNULL, \"ifnull\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.IFNONNULL, \"ifnonnull\", \"boo\", null, T_VOID, -1);\n+        def(Classfile.GOTO_W, \"goto_w\", \"boooo\", null, T_VOID, 0);\n+        def(Classfile.JSR_W, \"jsr_w\", \"boooo\", null, T_INT, 0);\n+        def(_breakpoint, \"breakpoint\", \"\", null, T_VOID, 0);\n+        def(_fast_agetfield, \"fast_agetfield\", \"bJJ\", null, T_OBJECT, 0, Classfile.GETFIELD);\n+        def(_fast_bgetfield, \"fast_bgetfield\", \"bJJ\", null, T_INT, 0, Classfile.GETFIELD);\n+        def(_fast_cgetfield, \"fast_cgetfield\", \"bJJ\", null, T_CHAR, 0, Classfile.GETFIELD);\n+        def(_fast_dgetfield, \"fast_dgetfield\", \"bJJ\", null, T_DOUBLE, 0, Classfile.GETFIELD);\n+        def(_fast_fgetfield, \"fast_fgetfield\", \"bJJ\", null, T_FLOAT, 0, Classfile.GETFIELD);\n+        def(_fast_igetfield, \"fast_igetfield\", \"bJJ\", null, T_INT, 0, Classfile.GETFIELD);\n+        def(_fast_lgetfield, \"fast_lgetfield\", \"bJJ\", null, T_LONG, 0, Classfile.GETFIELD);\n+        def(_fast_sgetfield, \"fast_sgetfield\", \"bJJ\", null, T_SHORT, 0, Classfile.GETFIELD);\n+        def(_fast_aputfield, \"fast_aputfield\", \"bJJ\", null, T_OBJECT, 0, Classfile.PUTFIELD);\n+        def(_fast_bputfield, \"fast_bputfield\", \"bJJ\", null, T_INT, 0, Classfile.PUTFIELD);\n+        def(_fast_zputfield, \"fast_zputfield\", \"bJJ\", null, T_INT, 0, Classfile.PUTFIELD);\n+        def(_fast_cputfield, \"fast_cputfield\", \"bJJ\", null, T_CHAR, 0, Classfile.PUTFIELD);\n+        def(_fast_dputfield, \"fast_dputfield\", \"bJJ\", null, T_DOUBLE, 0, Classfile.PUTFIELD);\n+        def(_fast_fputfield, \"fast_fputfield\", \"bJJ\", null, T_FLOAT, 0, Classfile.PUTFIELD);\n+        def(_fast_iputfield, \"fast_iputfield\", \"bJJ\", null, T_INT, 0, Classfile.PUTFIELD);\n+        def(_fast_lputfield, \"fast_lputfield\", \"bJJ\", null, T_LONG, 0, Classfile.PUTFIELD);\n+        def(_fast_sputfield, \"fast_sputfield\", \"bJJ\", null, T_SHORT, 0, Classfile.PUTFIELD);\n+        def(_fast_aload_0, \"fast_aload_0\", \"b\", null, T_OBJECT, 1, Classfile.ALOAD_0);\n+        def(_fast_iaccess_0, \"fast_iaccess_0\", \"b_JJ\", null, T_INT, 1, Classfile.ALOAD_0);\n+        def(_fast_aaccess_0, \"fast_aaccess_0\", \"b_JJ\", null, T_OBJECT, 1, Classfile.ALOAD_0);\n+        def(_fast_faccess_0, \"fast_faccess_0\", \"b_JJ\", null, T_OBJECT, 1, Classfile.ALOAD_0);\n+        def(_fast_iload, \"fast_iload\", \"bi\", null, T_INT, 1, Classfile.ILOAD);\n+        def(_fast_iload2, \"fast_iload2\", \"bi_i\", null, T_INT, 2, Classfile.ILOAD);\n+        def(_fast_icaload, \"fast_icaload\", \"bi_\", null, T_INT, 0, Classfile.ILOAD);\n+        def(_fast_invokevfinal, \"fast_invokevfinal\", \"bJJ\", null, T_ILLEGAL, -1, Classfile.INVOKEVIRTUAL);\n+        def(_fast_linearswitch, \"fast_linearswitch\", \"\", null, T_VOID, -1, Classfile.LOOKUPSWITCH);\n+        def(_fast_binaryswitch, \"fast_binaryswitch\", \"\", null, T_VOID, -1, Classfile.LOOKUPSWITCH);\n+        def(_return_register_finalizer, \"return_register_finalizer\", \"b\", null, T_VOID, 0, Classfile.RETURN);\n+        def(_invokehandle, \"invokehandle\", \"bJJ\", null, T_ILLEGAL, -1, Classfile.INVOKEVIRTUAL);\n+        def(_fast_aldc, \"fast_aldc\", \"bj\", null, T_OBJECT, 1, Classfile.LDC);\n+        def(_fast_aldc_w, \"fast_aldc_w\", \"bJJ\", null, T_OBJECT, 1, Classfile.LDC_W);\n+        def(_nofast_getfield, \"nofast_getfield\", \"bJJ\", null, T_ILLEGAL, 0, Classfile.GETFIELD);\n+        def(_nofast_putfield, \"nofast PUTFIELD\", \"bJJ\", null, T_ILLEGAL, -2, Classfile.PUTFIELD);\n+        def(_nofast_aload_0, \"nofast_aload_0\", \"b\", null, T_ILLEGAL, 1, Classfile.ALOAD_0);\n+        def(_nofast_iload, \"nofast_iload\", \"bi\", null, T_ILLEGAL, 1, Classfile.ILOAD);\n+        def(_shouldnotreachhere, \"_shouldnotreachhere\", \"b\", null, T_VOID, 0);\n+    }\n+\n+    final int code;\n+    VerificationBytecodes(int code) {\n+        this.code = code;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":403,"deletions":0,"binary":false,"changes":403,"status":"added"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.hpp\">hotspot\/share\/classfile\/stackMapFrame.hpp<\/a>\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.cpp\">hotspot\/share\/classfile\/stackMapFrame.cpp<\/a>\n+ *\/\n+class VerificationFrame {\n+\n+    public static final int FLAG_THIS_UNINIT = 0x01;\n+\n+    private int _offset;\n+    private int _locals_size, _stack_size;\n+    private int _stack_mark;\n+    private final int _max_locals, _max_stack;\n+    private int _flags;\n+    private final VerificationType[] _locals, _stack;\n+    private final VerifierImpl _verifier;\n+\n+    public VerificationFrame(int offset, int flags, int locals_size, int stack_size, int max_locals, int max_stack, VerificationType[] locals, VerificationType[] stack, VerifierImpl v) {\n+        this._offset = offset;\n+        this._locals_size = locals_size;\n+        this._stack_size = stack_size;\n+        this._stack_mark = -1;\n+        this._max_locals = max_locals;\n+        this._max_stack = max_stack;\n+        this._flags = flags;\n+        this._locals = locals;\n+        this._stack = stack;\n+        this._verifier = v;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"frame @\" + _offset + \" with locals \" + (_locals == null ? \"[]\" : Arrays.asList(_locals)) + \" and stack \" + (_stack == null ? \"[]\" : Arrays.asList(_stack));\n+    }\n+\n+    void set_offset(int offset) {\n+        this._offset = offset;\n+    }\n+\n+    void set_flags(int flags) {\n+        _flags = flags;\n+    }\n+\n+    void set_locals_size(int locals_size) {\n+        _locals_size = locals_size;\n+    }\n+\n+    void set_stack_size(int stack_size) {\n+        _stack_size = _stack_mark = stack_size;\n+    }\n+\n+    int offset() {\n+        return _offset;\n+    }\n+\n+    VerifierImpl verifier() {\n+        return _verifier;\n+    }\n+\n+    int flags() {\n+        return _flags;\n+    }\n+\n+    int locals_size() {\n+        return _locals_size;\n+    }\n+\n+    VerificationType[] locals() {\n+        return _locals;\n+    }\n+\n+    int stack_size() {\n+        return _stack_size;\n+    }\n+\n+    VerificationType[] stack() {\n+        return _stack;\n+    }\n+\n+    int max_locals() {\n+        return _max_locals;\n+    }\n+\n+    boolean flag_this_uninit() {\n+        return (_flags & FLAG_THIS_UNINIT) == FLAG_THIS_UNINIT;\n+    }\n+\n+    void reset() {\n+        for (int i = 0; i < _max_locals; i++) {\n+            _locals[i] = VerificationType.bogus_type;\n+        }\n+        for (int i = 0; i < _max_stack; i++) {\n+            _stack[i] = VerificationType.bogus_type;\n+        }\n+    }\n+\n+    void set_mark() {\n+        if (_stack_mark != -1) {\n+            for (int i = _stack_mark - 1; i >= _stack_size; --i) {\n+                _stack[i] = VerificationType.bogus_type;\n+            }\n+            _stack_mark = _stack_size;\n+        }\n+    }\n+\n+    void push_stack(VerificationType type) {\n+        if (type.is_check()) _verifier.verifyError(\"Must be a real type\");\n+        if (_stack_size >= _max_stack) {\n+            _verifier.verifyError(\"Operand stack overflow\");\n+        }\n+        _stack[_stack_size++] = type;\n+    }\n+\n+    void push_stack_2(VerificationType type1, VerificationType type2) {\n+        if (!(type1.is_long() || type1.is_double())) _verifier.verifyError(\"must be long\/double\");\n+        if (!(type2.is_long2() || type2.is_double2())) _verifier.verifyError(\"must be long\/double_2\");\n+        if (_stack_size >= _max_stack - 1) {\n+            _verifier.verifyError(\"Operand stack overflow\");\n+        }\n+        _stack[_stack_size++] = type1;\n+        _stack[_stack_size++] = type2;\n+    }\n+\n+    VerificationType pop_stack() {\n+        if (_stack_size <= 0) {\n+            _verifier.verifyError(\"Operand stack underflow\");\n+        }\n+        VerificationType top = _stack[--_stack_size];\n+        return top;\n+    }\n+\n+    VerificationType pop_stack(VerificationType type) {\n+        if (_stack_size != 0) {\n+            VerificationType top = _stack[_stack_size - 1];\n+            boolean subtype = type.is_assignable_from(top, verifier());\n+            if (subtype) {\n+                --_stack_size;\n+                return top;\n+            }\n+        }\n+        return pop_stack_ex(type);\n+    }\n+\n+    void pop_stack_2(VerificationType type1, VerificationType type2) {\n+        if (!(type1.is_long2() || type1.is_double2())) _verifier.verifyError(\"must be long\/double\");\n+        if (!(type2.is_long() || type2.is_double())) _verifier.verifyError(\"must be long\/double_2\");\n+        if (_stack_size >= 2) {\n+            VerificationType top1 = _stack[_stack_size - 1];\n+            boolean subtype1 = type1.is_assignable_from(top1, verifier());\n+            VerificationType top2 = _stack[_stack_size - 2];\n+            boolean subtype2 = type2.is_assignable_from(top2, verifier());\n+            if (subtype1 && subtype2) {\n+                _stack_size -= 2;\n+                return;\n+            }\n+        }\n+        pop_stack_ex(type1);\n+        pop_stack_ex(type2);\n+    }\n+\n+    VerificationFrame(int max_locals, int max_stack, VerifierImpl verifier) {\n+        _offset = 0;\n+        _locals_size = 0;\n+        _stack_size = 0;\n+        _stack_mark = 0;\n+        _max_locals = max_locals;\n+        _max_stack = max_stack;\n+        _flags = 0;\n+        _verifier = verifier;\n+        _locals = new VerificationType[max_locals];\n+        _stack = new VerificationType[max_stack];\n+        for (int i = 0; i < max_locals; i++) {\n+            _locals[i] = VerificationType.bogus_type;\n+        }\n+        for (int i = 0; i < max_stack; i++) {\n+            _stack[i] = VerificationType.bogus_type;\n+        }\n+    }\n+\n+    VerificationFrame frame_in_exception_handler(int flags) {\n+        VerificationType[] stack = new VerificationType[1];\n+        VerificationFrame frame = new VerificationFrame(_offset, flags, _locals_size, 0, _max_locals, _max_stack, _locals, stack, _verifier);\n+        return frame;\n+    }\n+\n+    void initialize_object(VerificationType old_object, VerificationType new_object) {\n+        int i;\n+        for (i = 0; i < _max_locals; i++) {\n+            if (_locals[i].equals(old_object)) {\n+                _locals[i] = new_object;\n+            }\n+        }\n+        for (i = 0; i < _stack_size; i++) {\n+            if (_stack[i].equals(old_object)) {\n+                _stack[i] = new_object;\n+            }\n+        }\n+        if (old_object.is_uninitialized_this(_verifier)) {\n+            _flags = 0;\n+        }\n+    }\n+\n+    VerificationType  set_locals_from_arg(VerificationWrapper.MethodWrapper m, VerificationType thisKlass) {\n+        var ss = new VerificationSignature(m.descriptor(), true, _verifier);\n+        int init_local_num = 0;\n+        if (!m.isStatic()) {\n+            init_local_num++;\n+            if (VerifierImpl.object_initializer_name.equals(m.name()) && !VerifierImpl.java_lang_Object.equals(thisKlass.name())) {\n+                _locals[0] = VerificationType.uninitialized_this_type;\n+                _flags |= FLAG_THIS_UNINIT;\n+            } else {\n+                _locals[0] = thisKlass;\n+            }\n+        }\n+        while (!ss.atReturnType()) {\n+            init_local_num += _verifier.change_sig_to_verificationType(ss, _locals, init_local_num);\n+            ss.next();\n+        }\n+        _locals_size = init_local_num;\n+        switch (ss.type()) {\n+            case T_OBJECT:\n+            case T_ARRAY:\n+            {\n+                String sig = ss.asSymbol();\n+                return VerificationType.reference_type(sig);\n+            }\n+            case T_INT:         return VerificationType.integer_type;\n+            case T_BYTE:        return VerificationType.byte_type;\n+            case T_CHAR:        return VerificationType.char_type;\n+            case T_SHORT:     return VerificationType.short_type;\n+            case T_BOOLEAN: return VerificationType.boolean_type;\n+            case T_FLOAT:     return VerificationType.float_type;\n+            case T_DOUBLE:    return VerificationType.double_type;\n+            case T_LONG:        return VerificationType.long_type;\n+            case T_VOID:        return VerificationType.bogus_type;\n+            default:\n+                _verifier.verifyError(\"Should not reach here\");\n+                return VerificationType.bogus_type;\n+        }\n+    }\n+\n+    void copy_locals(VerificationFrame src) {\n+        int len = src.locals_size() < _locals_size ? src.locals_size() : _locals_size;\n+        for (int i = 0; i < len; i++) {\n+            _locals[i] = src.locals()[i];\n+        }\n+    }\n+\n+    void copy_stack(VerificationFrame src) {\n+        int len = src.stack_size() < _stack_size ? src.stack_size() : _stack_size;\n+        for (int i = 0; i < len; i++) {\n+            _stack[i] = src.stack()[i];\n+        }\n+    }\n+\n+    private int is_assignable_to(VerificationType[] from, VerificationType[] to, int len) {\n+        int i = 0;\n+        for (i = 0; i < len; i++) {\n+            if (!to[i].is_assignable_from(from[i], verifier())) {\n+                break;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    boolean is_assignable_to(VerificationFrame target) {\n+        if (_max_locals != target.max_locals()) {\n+            _verifier.verifyError(\"Locals size mismatch\", this, target);\n+        }\n+        if (_stack_size != target.stack_size()) {\n+            _verifier.verifyError(\"Stack size mismatch\", this, target);\n+        }\n+        int mismatch_loc;\n+        mismatch_loc = is_assignable_to(_locals, target.locals(), target.locals_size());\n+        if (mismatch_loc != target.locals_size()) {\n+            _verifier.verifyError(\"Bad type\", this, target);\n+        }\n+        mismatch_loc = is_assignable_to(_stack, target.stack(), _stack_size);\n+        if (mismatch_loc != _stack_size) {\n+            _verifier.verifyError(\"Bad type\", this, target);\n+        }\n+\n+        if ((_flags | target.flags()) == target.flags()) {\n+            return true;\n+        } else {\n+            _verifier.verifyError(\"Bad flags\", this, target);\n+        }\n+        return false;\n+    }\n+\n+    VerificationType pop_stack_ex(VerificationType type) {\n+        if (_stack_size <= 0) {\n+            _verifier.verifyError(\"Operand stack underflow\");\n+        }\n+        VerificationType top = _stack[--_stack_size];\n+        boolean subtype = type.is_assignable_from(top, verifier());\n+        if (!subtype) {\n+            _verifier.verifyError(\"Bad type on operand stack\");\n+        }\n+        return top;\n+    }\n+\n+    VerificationType get_local(int index, VerificationType type) {\n+        if (index >= _max_locals) {\n+            _verifier.verifyError(\"Local variable table overflow\");\n+        }\n+        boolean subtype = type.is_assignable_from(_locals[index],\n+            verifier());\n+        if (!subtype) {\n+            _verifier.verifyError(\"Bad local variable type\");\n+        }\n+        if(index >= _locals_size) { _locals_size = index + 1; }\n+        return _locals[index];\n+    }\n+\n+    void get_local_2(int index, VerificationType type1, VerificationType type2) {\n+        if (!(type1.is_long() || type1.is_double())) _verifier.verifyError(\"must be long\/double\");\n+        if (!(type2.is_long2() || type2.is_double2())) _verifier.verifyError(\"must be long\/double_2\");\n+        if (index >= _locals_size - 1) {\n+            _verifier.verifyError(\"get long\/double overflows locals\");\n+        }\n+        boolean subtype = type1.is_assignable_from(_locals[index], verifier());\n+        if (!subtype) {\n+            _verifier.verifyError(\"Bad local variable type\");\n+        } else {\n+            subtype = type2.is_assignable_from(_locals[index + 1], verifier());\n+            if (!subtype) {\n+                _verifier.verifyError(\"Bad local variable type\");\n+            }\n+        }\n+    }\n+\n+    void set_local(int index, VerificationType type) {\n+        if (type.is_check()) _verifier.verifyError(\"Must be a real type\");\n+        if (index >= _max_locals) {\n+            _verifier.verifyError(\"Local variable table overflow\");\n+        }\n+        if (_locals[index].is_double() || _locals[index].is_long()) {\n+            if ((index + 1) >= _locals_size) _verifier.verifyError(\"Local variable table overflow\");\n+            _locals[index + 1] = VerificationType.bogus_type;\n+        }\n+        if (_locals[index].is_double2() || _locals[index].is_long2()) {\n+            if (index < 1) _verifier.verifyError(\"Local variable table underflow\");\n+            _locals[index - 1] = VerificationType.bogus_type;\n+        }\n+        _locals[index] = type;\n+        if (index >= _locals_size) {\n+            for (int i=_locals_size; i<index; i++) {\n+                if (_locals[i] != VerificationType.bogus_type) _verifier.verifyError(\"holes must be bogus type\");\n+            }\n+            _locals_size = index + 1;\n+        }\n+    }\n+\n+    void set_local_2(int index, VerificationType type1, VerificationType type2) {\n+        if (!(type1.is_long() || type1.is_double())) _verifier.verifyError(\"must be long\/double\");\n+        if (!(type2.is_long2() || type2.is_double2())) _verifier.verifyError(\"must be long\/double_2\");\n+        if (index >= _max_locals - 1) {\n+            _verifier.verifyError(\"Local variable table overflow\");\n+        }\n+        if (_locals[index+1].is_double() || _locals[index+1].is_long()) {\n+            if ((index + 2) >= _locals_size) _verifier.verifyError(\"Local variable table overflow\");\n+            _locals[index + 2] = VerificationType.bogus_type;\n+        }\n+        if (_locals[index].is_double2() || _locals[index].is_long2()) {\n+            if (index < 1) _verifier.verifyError(\"Local variable table underflow\");\n+            _locals[index - 1] = VerificationType.bogus_type;\n+        }\n+        _locals[index] = type1;\n+        _locals[index+1] = type2;\n+        if (index >= _locals_size - 1) {\n+            for (int i=_locals_size; i<index; i++) {\n+                if (_locals[i] != VerificationType.bogus_type) _verifier.verifyError(\"holes must be bogus type\");\n+            }\n+            _locals_size = index + 2;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationFrame.java","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+final class VerificationSignature {\n+\n+    enum BasicType {\n+        T_BOOLEAN(4),\n+        T_CHAR(5),\n+        T_FLOAT(6),\n+        T_DOUBLE(7),\n+        T_BYTE(8),\n+        T_SHORT(9),\n+        T_INT(10),\n+        T_LONG(11),\n+        T_OBJECT(12),\n+        T_ARRAY(13),\n+        T_VOID(14),\n+        T_ADDRESS(15),\n+        T_NARROWOOP(16),\n+        T_METADATA(17),\n+        T_NARROWKLASS(18),\n+        T_CONFLICT(19),\n+        T_ILLEGAL(99);\n+\n+        final int type;\n+\n+        BasicType(int type) {\n+            this.type = type;\n+        }\n+\n+        static BasicType fromSignature(char ch) {\n+            return switch (ch) {\n+                case JVM_SIGNATURE_BOOLEAN ->\n+                    T_BOOLEAN;\n+                case JVM_SIGNATURE_CHAR ->\n+                    T_CHAR;\n+                case JVM_SIGNATURE_FLOAT ->\n+                    T_FLOAT;\n+                case JVM_SIGNATURE_DOUBLE ->\n+                    T_DOUBLE;\n+                case JVM_SIGNATURE_BYTE ->\n+                    T_BYTE;\n+                case JVM_SIGNATURE_SHORT ->\n+                    T_SHORT;\n+                case JVM_SIGNATURE_INT ->\n+                    T_INT;\n+                case JVM_SIGNATURE_LONG ->\n+                    T_LONG;\n+                case JVM_SIGNATURE_CLASS ->\n+                    T_OBJECT;\n+                case JVM_SIGNATURE_ARRAY ->\n+                    T_ARRAY;\n+                case JVM_SIGNATURE_VOID ->\n+                    T_VOID;\n+                default ->\n+                    throw new IllegalArgumentException(\"Not a valid type: '\" + ch + \"'\");\n+            };\n+        }\n+    }\n+\n+    static final char JVM_SIGNATURE_SLASH = '\/',\n+            JVM_SIGNATURE_DOT = '.',\n+            JVM_SIGNATURE_SPECIAL = '<',\n+            JVM_SIGNATURE_ENDSPECIAL = '>',\n+            JVM_SIGNATURE_ARRAY = '[',\n+            JVM_SIGNATURE_BYTE = 'B',\n+            JVM_SIGNATURE_CHAR = 'C',\n+            JVM_SIGNATURE_CLASS = 'L',\n+            JVM_SIGNATURE_ENDCLASS = ';',\n+            JVM_SIGNATURE_ENUM = 'E',\n+            JVM_SIGNATURE_FLOAT = 'F',\n+            JVM_SIGNATURE_DOUBLE = 'D',\n+            JVM_SIGNATURE_FUNC = '(',\n+            JVM_SIGNATURE_ENDFUNC = ')',\n+            JVM_SIGNATURE_INT = 'I',\n+            JVM_SIGNATURE_LONG = 'J',\n+            JVM_SIGNATURE_SHORT = 'S',\n+            JVM_SIGNATURE_VOID = 'V',\n+            JVM_SIGNATURE_BOOLEAN = 'Z';\n+\n+    static boolean isJavaPrimitive(BasicType t) {\n+        return BasicType.T_BOOLEAN.type <= t.type && t.type <= BasicType.T_LONG.type;\n+    }\n+\n+    static boolean isReferenceType(BasicType t) {\n+        return t == BasicType.T_OBJECT || t == BasicType.T_ARRAY;\n+    }\n+\n+    static char type2Char(BasicType t) {\n+        return t.type < TYPE2CHAR_TAB.length ? TYPE2CHAR_TAB[t.type] : 0;\n+    }\n+\n+    private static final char TYPE2CHAR_TAB[] = new char[]{\n+        0, 0, 0, 0,\n+        JVM_SIGNATURE_BOOLEAN, JVM_SIGNATURE_CHAR,\n+        JVM_SIGNATURE_FLOAT, JVM_SIGNATURE_DOUBLE,\n+        JVM_SIGNATURE_BYTE, JVM_SIGNATURE_SHORT,\n+        JVM_SIGNATURE_INT, JVM_SIGNATURE_LONG,\n+        JVM_SIGNATURE_CLASS, JVM_SIGNATURE_ARRAY,\n+        JVM_SIGNATURE_VOID, 0,\n+        0, 0, 0, 0\n+    };\n+\n+    static boolean hasEnvelope(char signature_char) {\n+        return signature_char == JVM_SIGNATURE_CLASS;\n+    }\n+\n+    private BasicType type;\n+    private final String signature;\n+    private final int limit;\n+    private int begin, end, arrayPrefix, state;\n+\n+    private static final int S_FIELD = 0, S_METHOD = 1, S_METHOD_RETURN = 3;\n+\n+    boolean atReturnType() {\n+        return state == S_METHOD_RETURN;\n+    }\n+\n+    VerificationSignature(String signature, boolean is_method) {\n+        this(signature, is_method, null);\n+    }\n+\n+    boolean isReference() {\n+        return isReferenceType(type);\n+    }\n+\n+    BasicType type() {\n+        return type;\n+    }\n+\n+    private int rawSymbolBegin() {\n+        return begin + (hasEnvelope() ? 1 : 0);\n+    }\n+\n+    private int rawSymbolEnd() {\n+        return end - (hasEnvelope() ? 1 : 0);\n+    }\n+\n+    private boolean hasEnvelope() {\n+        return hasEnvelope(signature.charAt(begin));\n+    }\n+\n+    String asSymbol() {\n+        int begin = rawSymbolBegin();\n+        int end = rawSymbolEnd();\n+        return signature.substring(begin, end);\n+    }\n+\n+    int skipArrayPrefix(int max_skip_length) {\n+        if (type != BasicType.T_ARRAY) {\n+            return 0;\n+        }\n+        if (arrayPrefix > max_skip_length) {\n+            \/\/ strip some but not all levels of T_ARRAY\n+            arrayPrefix -= max_skip_length;\n+            begin += max_skip_length;\n+            return max_skip_length;\n+        }\n+        return skipWholeArrayPrefix();\n+    }\n+\n+    static BasicType decodeSignatureChar(char ch) {\n+        return BasicType.fromSignature(ch);\n+    }\n+\n+    private final VerifierImpl context;\n+\n+    VerificationSignature(String signature, boolean is_method, VerifierImpl context) {\n+        this.signature = signature;\n+        this.limit = signature.length();\n+        int oz = is_method ? S_METHOD : S_FIELD;\n+        this.state = oz;\n+        this.begin = this.end = oz;\n+        this.arrayPrefix = 0;\n+        this.context = context;\n+        next();\n+    }\n+\n+    private int scanType(BasicType type) {\n+        int e = end;\n+        int tem;\n+        switch (type) {\n+            case T_OBJECT:\n+                tem = signature.indexOf(JVM_SIGNATURE_ENDCLASS, e);\n+                return tem < 0 ? limit : tem + 1;\n+            case T_ARRAY:\n+                while (e < limit && signature.charAt(e) == JVM_SIGNATURE_ARRAY) {\n+                    e++;\n+                }\n+                arrayPrefix = e - end;\n+                if (hasEnvelope(signature.charAt(e))) {\n+                    tem = signature.indexOf(JVM_SIGNATURE_ENDCLASS, e);\n+                    return tem < 0 ? limit : tem + 1;\n+                }\n+                return e + 1;\n+            default:\n+                return e + 1;\n+        }\n+    }\n+\n+    void next() {\n+        final String sig = signature;\n+        int len = limit;\n+        testLen(len);\n+        begin = end;\n+        char ch = sig.charAt(begin);\n+        if (ch == JVM_SIGNATURE_ENDFUNC) {\n+            state = S_METHOD_RETURN;\n+            begin = ++end;\n+            testLen(len);\n+            ch = sig.charAt(begin);\n+        }\n+        try {\n+            BasicType bt = decodeSignatureChar(ch);\n+            type = bt;\n+            end = scanType(bt);\n+        } catch (IllegalArgumentException iae) {\n+            throw new IllegalArgumentException(\"Not a valid signature: '\" + signature + \"'\", iae);\n+        }\n+    }\n+\n+    private void testLen(int len) {\n+        if (end >= len) {\n+            if (context == null) {\n+                throw new IllegalArgumentException(\"Invalid signature \" + signature);\n+            } else {\n+                context.verifyError(\"Invalid signature \" + signature);\n+            }\n+        }\n+    }\n+\n+    int skipWholeArrayPrefix() {\n+        int whole_array_prefix = arrayPrefix;\n+        int new_begin = begin + whole_array_prefix;\n+        begin = new_begin;\n+        char ch = signature.charAt(new_begin);\n+        BasicType bt = decodeSignatureChar(ch);\n+        type = bt;\n+        return whole_array_prefix;\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    static int isValidType(String type, int limit) {\n+        int index = 0;\n+\n+        \/\/ Iterate over any number of array dimensions\n+        while (index < limit && type.charAt(index) == JVM_SIGNATURE_ARRAY) {\n+            ++index;\n+        }\n+        if (index >= limit) {\n+            return -1;\n+        }\n+        switch (type.charAt(index)) {\n+            case JVM_SIGNATURE_BYTE:\n+            case JVM_SIGNATURE_CHAR:\n+            case JVM_SIGNATURE_FLOAT:\n+            case JVM_SIGNATURE_DOUBLE:\n+            case JVM_SIGNATURE_INT:\n+            case JVM_SIGNATURE_LONG:\n+            case JVM_SIGNATURE_SHORT:\n+            case JVM_SIGNATURE_BOOLEAN:\n+            case JVM_SIGNATURE_VOID:\n+                return index + 1;\n+            case JVM_SIGNATURE_CLASS:\n+                for (index = index + 1; index < limit; ++index) {\n+                    char c = type.charAt(index);\n+                    switch (c) {\n+                        case JVM_SIGNATURE_ENDCLASS:\n+                            return index + 1;\n+                        case '\\0':\n+                        case JVM_SIGNATURE_DOT:\n+                        case JVM_SIGNATURE_ARRAY:\n+                            return -1;\n+                        default: ; \/\/ fall through\n+                        }\n+                }\n+            \/\/ fall through\n+            default: ; \/\/ fall through\n+            }\n+        return -1;\n+    }\n+\n+    static boolean isValidMethodSignature(String method_sig) {\n+        if (method_sig != null) {\n+            int len = method_sig.length();\n+            int index = 0;\n+            if (len > 1 && method_sig.charAt(index) == JVM_SIGNATURE_FUNC) {\n+                ++index;\n+                while (index < len && method_sig.charAt(index) != JVM_SIGNATURE_ENDFUNC) {\n+                    int res = isValidType(method_sig.substring(index), len - index);\n+                    if (res == -1) {\n+                        return false;\n+                    } else {\n+                        index += res;\n+                    }\n+                }\n+                if (index < len && method_sig.charAt(index) == JVM_SIGNATURE_ENDFUNC) {\n+                    \/\/ check the return type\n+                    ++index;\n+                    return (isValidType(method_sig.substring(index), len - index) == (len - index));\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static boolean isValidTypeSignature(String sig) {\n+        if (sig == null) return false;\n+        int len = sig.length();\n+        return (len >= 1 && (isValidType(sig, len) == len));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationSignature.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"},{"patch":"@@ -0,0 +1,411 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import static jdk.internal.classfile.impl.verifier.VerificationType.*;\n+\n+\/**\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.hpp\">hotspot\/share\/classfile\/stackMapTable.hpp<\/a>\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.cpp\">hotspot\/share\/classfile\/stackMapTable.cpp<\/a>\n+ *\/\n+class VerificationTable {\n+\n+    private final int _code_length;\n+    private final int _frame_count;\n+    private final VerificationFrame[] _frame_array;\n+    private final VerifierImpl _verifier;\n+\n+    int get_frame_count() {\n+        return _frame_count;\n+    }\n+\n+    int get_offset(int index) {\n+        return _frame_array[index].offset();\n+    }\n+\n+    static class StackMapStream {\n+\n+        private final byte[] _data;\n+        private int _index;\n+        private final VerifierImpl _verifier;\n+\n+        StackMapStream(byte[] ah, VerifierImpl context) {\n+            _data = ah;\n+            _index = 0;\n+            _verifier = context;\n+        }\n+\n+        int get_u1() {\n+            if (_data == null || _index >= _data.length) {\n+                _verifier.classError(\"access beyond the end of attribute\");\n+            }\n+            return _data[_index++] & 0xff;\n+        }\n+\n+        int get_u2() {\n+            int res = get_u1() << 8;\n+            return res | get_u1();\n+        }\n+\n+        boolean at_end() {\n+            return (_data == null) || (_index == _data.length);\n+        }\n+    }\n+\n+    VerificationTable(byte[] stackmap_data, VerificationFrame init_frame, int max_locals, int max_stack, byte[] code_data, int code_len,\n+            VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl v) {\n+        _verifier = v;\n+        var reader = new StackMapReader(stackmap_data, code_data, code_len, cp, v);\n+        _code_length = code_len;\n+        _frame_count = reader.get_frame_count();\n+        _frame_array = new VerificationFrame[_frame_count];\n+        if (_frame_count > 0) {\n+            VerificationFrame pre_frame = init_frame;\n+            for (int i = 0; i < _frame_count; i++) {\n+                VerificationFrame frame = reader.next(pre_frame, i == 0, max_locals, max_stack);\n+                _frame_array[i] = frame;\n+                int offset = frame.offset();\n+                if (offset >= code_len || code_data[offset] == 0) {\n+                    _verifier.verifyError(\"StackMapTable error: bad offset\");\n+                }\n+                pre_frame = frame;\n+            }\n+        }\n+        reader.check_end();\n+    }\n+\n+    int get_index_from_offset(int offset) {\n+        int i = 0;\n+        for (; i < _frame_count; i++) {\n+            if (_frame_array[i].offset() == offset) {\n+                return i;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    boolean match_stackmap(VerificationFrame frame, int target, boolean match, boolean update) {\n+        int index = get_index_from_offset(target);\n+        return match_stackmap(frame, target, index, match, update);\n+    }\n+\n+    boolean match_stackmap(VerificationFrame frame, int target, int frame_index, boolean match, boolean update) {\n+        if (frame_index < 0 || frame_index >= _frame_count) {\n+            _verifier.verifyError(String.format(\"Expecting a stackmap frame at branch target %d\", target));\n+        }\n+        VerificationFrame stackmap_frame = _frame_array[frame_index];\n+        boolean result = true;\n+        if (match) {\n+            result = frame.is_assignable_to(stackmap_frame);\n+        }\n+        if (update) {\n+            int lsize = stackmap_frame.locals_size();\n+            int ssize = stackmap_frame.stack_size();\n+            if (frame.locals_size() > lsize || frame.stack_size() > ssize) {\n+                frame.reset();\n+            }\n+            frame.set_locals_size(lsize);\n+            frame.copy_locals(stackmap_frame);\n+            frame.set_stack_size(ssize);\n+            frame.copy_stack(stackmap_frame);\n+            frame.set_flags(stackmap_frame.flags());\n+        }\n+        return result;\n+    }\n+\n+    void check_jump_target(VerificationFrame frame, int target) {\n+        boolean match = match_stackmap(frame, target, true, false);\n+        if (!match || (target < 0 || target >= _code_length)) {\n+            _verifier.verifyError(String.format(\"Inconsistent stackmap frames at branch target %d\", target));\n+        }\n+    }\n+\n+    static class StackMapReader {\n+\n+        private VerificationWrapper.ConstantPoolWrapper _cp;\n+        private final StackMapStream _stream;\n+        private byte[] _code_data;\n+        private int _code_length;\n+        private final int _frame_count;\n+\n+        void check_verification_type_array_size(int size, int max_size) {\n+            if (size < 0 || size > max_size) {\n+                _verifier.classError(\"StackMapTable format error: bad type array size\");\n+            }\n+        }\n+\n+        private static final int\n+                        SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247,\n+                        SAME_EXTENDED = 251,\n+                        FULL = 255;\n+\n+        public int get_frame_count() {\n+            return _frame_count;\n+        }\n+\n+        public void check_end() {\n+            if (!_stream.at_end()) {\n+                _verifier.classError(\"wrong attribute size\");\n+            }\n+        }\n+\n+        private final VerifierImpl _verifier;\n+\n+        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len, VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n+            this._verifier = context;\n+            _stream = new StackMapStream(stackmapData, _verifier);\n+            if (stackmapData != null) {\n+                _frame_count = _stream.get_u2();\n+            } else {\n+                _frame_count = 0;\n+            }\n+            _code_data = code_data;\n+            _code_length = code_len;\n+            _cp = cp;\n+        }\n+\n+        int chop(VerificationType[] locals, int length, int chops) {\n+            if (locals == null) return -1;\n+            int pos = length - 1;\n+            for (int i=0; i<chops; i++) {\n+                if (locals[pos].is_category2_2nd()) {\n+                    pos -= 2;\n+                } else {\n+                    pos--;\n+                }\n+                if (pos<0 && i<(chops-1)) return -1;\n+            }\n+            return pos+1;\n+        }\n+\n+        VerificationType parse_verification_type(int[] flags) {\n+            int tag = _stream.get_u1();\n+            if (tag < ITEM_UninitializedThis) {\n+                return VerificationType.from_tag(tag, _verifier);\n+            }\n+            if (tag == ITEM_Object) {\n+                int class_index = _stream.get_u2();\n+                int nconstants = _cp.entryCount();\n+                if (class_index <= 0 || class_index >= nconstants || _cp.tagAt(class_index) != VerifierImpl.JVM_CONSTANT_Class) {\n+                    _verifier.classError(\"bad class index\");\n+                }\n+                return VerificationType.reference_type(_cp.classNameAt(class_index));\n+            }\n+            if (tag == ITEM_UninitializedThis) {\n+                if (flags != null) {\n+                    flags[0] |= VerificationFrame.FLAG_THIS_UNINIT;\n+                }\n+                return VerificationType.uninitialized_this_type;\n+            }\n+            if (tag == ITEM_Uninitialized) {\n+                int offset = _stream.get_u2();\n+                if (offset >= _code_length || _code_data[offset] != VerifierImpl.NEW_OFFSET) {\n+                    _verifier.classError(\"StackMapTable format error: bad offset for Uninitialized\");\n+                }\n+                return VerificationType.uninitialized_type(offset);\n+            }\n+            _verifier.classError(\"bad verification type\");\n+            return VerificationType.bogus_type;\n+        }\n+\n+        public VerificationFrame next(VerificationFrame pre_frame, boolean first, int max_locals, int max_stack) {\n+            VerificationFrame frame;\n+            int offset;\n+            VerificationType[] locals = null;\n+            int frame_type = _stream.get_u1();\n+            if (frame_type < 64) {\n+                if (first) {\n+                    offset = frame_type;\n+                    if (pre_frame.locals_size() > 0) {\n+                        locals = new VerificationType[pre_frame.locals_size()];\n+                    }\n+                } else {\n+                    offset = pre_frame.offset() + frame_type + 1;\n+                    locals = pre_frame.locals();\n+                }\n+                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), 0, max_locals, max_stack, locals, null, _verifier);\n+                if (first && locals != null) {\n+                    frame.copy_locals(pre_frame);\n+                }\n+                return frame;\n+            }\n+            if (frame_type < 128) {\n+                if (first) {\n+                    offset = frame_type - 64;\n+                    if (pre_frame.locals_size() > 0) {\n+                        locals = new VerificationType[pre_frame.locals_size()];\n+                    }\n+                } else {\n+                    offset = pre_frame.offset() + frame_type - 63;\n+                    locals = pre_frame.locals();\n+                }\n+                VerificationType[] stack = new VerificationType[2];\n+                int stack_size = 1;\n+                stack[0] = parse_verification_type(null);\n+                if (stack[0].is_category2()) {\n+                    stack[1] = stack[0].to_category2_2nd(_verifier);\n+                    stack_size = 2;\n+                }\n+                check_verification_type_array_size(stack_size, max_stack);\n+                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                if (first && locals != null) {\n+                    frame.copy_locals(pre_frame);\n+                }\n+                return frame;\n+            }\n+            int offset_delta = _stream.get_u2();\n+            if (frame_type < SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+                _verifier.classError(\"reserved frame type\");\n+            }\n+            if (frame_type == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+                if (first) {\n+                    offset = offset_delta;\n+                    if (pre_frame.locals_size() > 0) {\n+                        locals = new VerificationType[pre_frame.locals_size()];\n+                    }\n+                } else {\n+                    offset = pre_frame.offset() + offset_delta + 1;\n+                    locals = pre_frame.locals();\n+                }\n+                VerificationType[] stack = new VerificationType[2];\n+                int stack_size = 1;\n+                stack[0] = parse_verification_type(null);\n+                if (stack[0].is_category2()) {\n+                    stack[1] = stack[0].to_category2_2nd(_verifier);\n+                    stack_size = 2;\n+                }\n+                check_verification_type_array_size(stack_size, max_stack);\n+                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                if (first && locals != null) {\n+                    frame.copy_locals(pre_frame);\n+                }\n+                return frame;\n+            }\n+            if (frame_type <= SAME_EXTENDED) {\n+                locals = pre_frame.locals();\n+                int length = pre_frame.locals_size();\n+                int chops = SAME_EXTENDED - frame_type;\n+                int new_length = length;\n+                int flags = pre_frame.flags();\n+                if (chops != 0) {\n+                    new_length = chop(locals, length, chops);\n+                    check_verification_type_array_size(new_length, max_locals);\n+                    flags = 0;\n+                    for (int i=0; i<new_length; i++) {\n+                        if (locals[i].is_uninitialized_this(_verifier)) {\n+                            flags |= VerificationFrame.FLAG_THIS_UNINIT;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (first) {\n+                    offset = offset_delta;\n+                    if (new_length > 0) {\n+                        locals = new VerificationType[new_length];\n+                    } else {\n+                        locals = null;\n+                    }\n+                } else {\n+                    offset = pre_frame.offset() + offset_delta + 1;\n+                }\n+                frame = new VerificationFrame(offset, flags, new_length, 0, max_locals, max_stack, locals, null, _verifier);\n+                if (first && locals != null) {\n+                    frame.copy_locals(pre_frame);\n+                }\n+                return frame;\n+            } else if (frame_type < SAME_EXTENDED + 4) {\n+                int appends = frame_type - SAME_EXTENDED;\n+                int real_length = pre_frame.locals_size();\n+                int new_length = real_length + appends*2;\n+                locals = new VerificationType[new_length];\n+                VerificationType[] pre_locals = pre_frame.locals();\n+                int i;\n+                for (i=0; i<pre_frame.locals_size(); i++) {\n+                    locals[i] = pre_locals[i];\n+                }\n+                int[] flags = new int[]{pre_frame.flags()};\n+                for (i=0; i<appends; i++) {\n+                    locals[real_length] = parse_verification_type(flags);\n+                    if (locals[real_length].is_category2()) {\n+                        locals[real_length + 1] = locals[real_length].to_category2_2nd(_verifier);\n+                        ++real_length;\n+                    }\n+                    ++real_length;\n+                }\n+                check_verification_type_array_size(real_length, max_locals);\n+                if (first) {\n+                    offset = offset_delta;\n+                } else {\n+                    offset = pre_frame.offset() + offset_delta + 1;\n+                }\n+                frame = new VerificationFrame(offset, flags[0], real_length, 0, max_locals, max_stack, locals, null, _verifier);\n+                return frame;\n+            }\n+            if (frame_type == FULL) {\n+                int flags[] = new int[]{0};\n+                int locals_size = _stream.get_u2();\n+                int real_locals_size = 0;\n+                if (locals_size > 0) {\n+                    locals = new VerificationType[locals_size*2];\n+                }\n+                int i;\n+                for (i=0; i<locals_size; i++) {\n+                    locals[real_locals_size] = parse_verification_type(flags);\n+                    if (locals[real_locals_size].is_category2()) {\n+                        locals[real_locals_size + 1] =\n+                            locals[real_locals_size].to_category2_2nd(_verifier);\n+                        ++real_locals_size;\n+                    }\n+                    ++real_locals_size;\n+                }\n+                check_verification_type_array_size(real_locals_size, max_locals);\n+                int stack_size = _stream.get_u2();\n+                int real_stack_size = 0;\n+                VerificationType[] stack = null;\n+                if (stack_size > 0) {\n+                    stack = new VerificationType[stack_size*2];\n+                }\n+                for (i=0; i<stack_size; i++) {\n+                    stack[real_stack_size] = parse_verification_type(null);\n+                    if (stack[real_stack_size].is_category2()) {\n+                        stack[real_stack_size + 1] = stack[real_stack_size].to_category2_2nd(_verifier);\n+                        ++real_stack_size;\n+                    }\n+                    ++real_stack_size;\n+                }\n+                check_verification_type_array_size(real_stack_size, max_stack);\n+                if (first) {\n+                    offset = offset_delta;\n+                } else {\n+                    offset = pre_frame.offset() + offset_delta + 1;\n+                }\n+                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                return frame;\n+            }\n+            _verifier.classError(\"reserved frame type\");\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -0,0 +1,464 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import jdk.internal.classfile.impl.ClassHierarchyImpl;\n+import jdk.internal.classfile.impl.Util;\n+import static jdk.internal.classfile.impl.verifier.VerifierImpl.*;\n+import static jdk.internal.classfile.impl.verifier.VerificationSignature.BasicType.*;\n+\n+\/**\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.hpp\">hotspot\/share\/classfile\/verificationType.hpp<\/a>\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.cpp\">hotspot\/share\/classfile\/verificationType.cpp<\/a>\n+ *\/\n+class VerificationType {\n+\n+    private static final int BitsPerByte = 8;\n+\n+    static final int\n+            ITEM_Top = 0,\n+            ITEM_Integer = 1,\n+            ITEM_Float = 2,\n+            ITEM_Double = 3,\n+            ITEM_Long = 4,\n+            ITEM_Null = 5,\n+            ITEM_UninitializedThis = 6,\n+            ITEM_Object = 7,\n+            ITEM_Uninitialized = 8,\n+            ITEM_Bogus = -1;\n+\n+    VerificationType(String sym) {\n+        _data = 0x100;\n+        _sym = sym;\n+    }\n+    public VerificationType(int data, String sym) {\n+        _data = data;\n+        _sym = sym;\n+    }\n+    private final int _data;\n+    private final String _sym;\n+\n+    @Override\n+    public int hashCode() {\n+        return _sym == null ? _data : _sym.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj instanceof VerificationType ? (_data == ((VerificationType)obj)._data) && Objects.equals(_sym, ((VerificationType)obj)._sym) : false;\n+    }\n+\n+    private static final Map<VerificationType, String> _constantsMap = new IdentityHashMap<>(18);\n+\n+    @Override\n+    public String toString() {\n+        if (_constantsMap.isEmpty()) {\n+            for (Field f : VerificationType.class.getDeclaredFields()) {\n+                if (Modifier.isStatic(f.getModifiers()) && f.getType() == VerificationType.class) try {\n+                    _constantsMap.put((VerificationType)f.get(null), f.getName());\n+                } catch (IllegalAccessException ignore) {}\n+            }\n+        }\n+        if (_sym != null) return _sym;\n+        if ((_data & 0xff) == Uninitialized) return \"uninit@\" + (_data >> 8);\n+        return _constantsMap.getOrDefault(this, java.lang.Integer.toHexString(_data));\n+    }\n+\n+    String name() {\n+        return _sym;\n+    }\n+    private static final int\n+            ITEM_Boolean = 9, ITEM_Byte = 10, ITEM_Short = 11, ITEM_Char = 12,\n+            ITEM_Long_2nd = 13, ITEM_Double_2nd = 14;\n+\n+    private static final int\n+                            TypeMask                     = 0x00000003,\n+                            \/\/ Topmost types encoding\n+                            Reference                    = 0x0,                \/\/ _sym contains the name\n+                            Primitive                    = 0x1,                \/\/ see below for primitive list\n+                            Uninitialized            = 0x2,                \/\/ 0x00ffff00 contains bci\n+                            TypeQuery                    = 0x3,                \/\/ Meta-types used for category testing\n+                            \/\/ Utility flags\n+                            ReferenceFlag            = 0x00,             \/\/ For reference query types\n+                            Category1Flag            = 0x01,             \/\/ One-word values\n+                            Category2Flag            = 0x02,             \/\/ First word of a two-word value\n+                            Category2_2ndFlag    = 0x04,             \/\/ Second word of a two-word value\n+                            \/\/ special reference values\n+                            Null                             = 0x00000000, \/\/ A reference with a 0 sym is null\n+                            \/\/ Primitives categories (the second byte determines the category)\n+                            Category1                    = (Category1Flag         << 1 * BitsPerByte) | Primitive,\n+                            Category2                    = (Category2Flag         << 1 * BitsPerByte) | Primitive,\n+                            Category2_2nd            = (Category2_2ndFlag << 1 * BitsPerByte) | Primitive,\n+                            \/\/ Primitive values (type descriminator stored in most-signifcant bytes)\n+                            \/\/ Bogus needs the \" | Primitive\".    Else, isReference(Bogus) returns TRUE.\n+                            Bogus                            = (ITEM_Bogus            << 2 * BitsPerByte) | Primitive,\n+                            Boolean                        = (ITEM_Boolean        << 2 * BitsPerByte) | Category1,\n+                            Byte                             = (ITEM_Byte             << 2 * BitsPerByte) | Category1,\n+                            Short                            = (ITEM_Short            << 2 * BitsPerByte) | Category1,\n+                            Char                             = (ITEM_Char             << 2 * BitsPerByte) | Category1,\n+                            Integer                        = (ITEM_Integer        << 2 * BitsPerByte) | Category1,\n+                            Float                            = (ITEM_Float            << 2 * BitsPerByte) | Category1,\n+                            Long                             = (ITEM_Long             << 2 * BitsPerByte) | Category2,\n+                            Double                         = (ITEM_Double         << 2 * BitsPerByte) | Category2,\n+                            Long_2nd                     = (ITEM_Long_2nd     << 2 * BitsPerByte) | Category2_2nd,\n+                            Double_2nd                 = (ITEM_Double_2nd << 2 * BitsPerByte) | Category2_2nd,\n+                            \/\/ Used by Uninitialized (second and third bytes hold the bci)\n+                            BciMask                        = 0xffff << 1 * BitsPerByte,\n+                            \/\/ A bci of -1 is an Unintialized-This\n+                            BciForThis = 0xffff,\n+                            \/\/ Query values\n+                            ReferenceQuery         = (ReferenceFlag         << 1 * BitsPerByte) | TypeQuery,\n+                            Category1Query         = (Category1Flag         << 1 * BitsPerByte) | TypeQuery,\n+                            Category2Query         = (Category2Flag         << 1 * BitsPerByte) | TypeQuery,\n+                            Category2_2ndQuery = (Category2_2ndFlag << 1 * BitsPerByte) | TypeQuery;\n+\n+    VerificationType(int raw_data) {\n+        this._data = raw_data;\n+        this._sym = null;\n+    }\n+\n+    VerificationType() {\n+        this(Bogus);\n+    }\n+\n+    static final VerificationType bogus_type = new VerificationType(Bogus),\n+            top_type = bogus_type,\n+            null_type = new VerificationType(Null),\n+            integer_type = new VerificationType(Integer),\n+            float_type = new VerificationType(Float),\n+            long_type = new VerificationType(Long),\n+            long2_type = new VerificationType(Long_2nd),\n+            double_type = new VerificationType(Double),\n+            boolean_type = new VerificationType(Boolean),\n+            byte_type = new VerificationType(Byte),\n+            char_type = new VerificationType(Char),\n+            short_type = new VerificationType(Short),\n+            double2_type = new VerificationType(Double_2nd),\n+            \/\/ \"check\" types are used for queries.    A \"check\" type is not assignable\n+            \/\/ to anything, but the specified types are assignable to a \"check\".    For\n+            \/\/ example, any category1 primitive is assignable to category1_check and\n+            \/\/ any reference is assignable to reference_check.\n+            reference_check = new VerificationType(ReferenceQuery),\n+            category1_check = new VerificationType(Category1Query),\n+            category2_check = new VerificationType(Category2Query),\n+            category2_2nd_check = new VerificationType(Category2_2ndQuery);\n+\n+    static VerificationType reference_type(String sh) {\n+        return new VerificationType(sh);\n+    }\n+\n+    static VerificationType uninitialized_type(int bci) {\n+        return new VerificationType(bci << 1 * BitsPerByte | Uninitialized);\n+    }\n+\n+    static final VerificationType uninitialized_this_type = uninitialized_type(BciForThis);\n+\n+    boolean is_bogus() {\n+        return (_data == Bogus);\n+    }\n+\n+    boolean is_null() {\n+        return (_data == Null);\n+    }\n+\n+    boolean is_boolean() {\n+        return (_data == Boolean);\n+    }\n+\n+    boolean is_byte() {\n+        return (_data == Byte);\n+    }\n+\n+    boolean is_char() {\n+        return (_data == Char);\n+    }\n+\n+    boolean is_short() {\n+        return (_data == Short);\n+    }\n+\n+    boolean is_integer() {\n+        return (_data == Integer);\n+    }\n+\n+    boolean is_long() {\n+        return (_data == Long);\n+    }\n+\n+    boolean is_float() {\n+        return (_data == Float);\n+    }\n+\n+    boolean is_double() {\n+        return (_data == Double);\n+    }\n+\n+    boolean is_long2() {\n+        return (_data == Long_2nd );\n+    }\n+\n+    boolean is_double2() {\n+        return (_data == Double_2nd);\n+    }\n+\n+    boolean is_reference() {\n+        return ((_data & TypeMask) == Reference);\n+    }\n+\n+    boolean is_category1(VerifierImpl context) {\n+        \/\/ This should return true for all one-word types, which are category1\n+        \/\/ primitives, and references (including uninitialized refs).    Though\n+        \/\/ the 'query' types should technically return 'false' here, if we\n+        \/\/ allow this to return true, we can perform the test using only\n+        \/\/ 2 operations rather than 8 (3 masks, 3 compares and 2 logical 'ands').\n+        \/\/ Since noone should call this on a query type anyway, this is ok.\n+        if(is_check()) context.verifyError(\"Must not be a check type (wrong value returned)\");\n+        \/\/ should only return false if it's a primitive, and the category1 flag\n+        \/\/ is not set.\n+        return ((_data & Category1) != Primitive);\n+    }\n+\n+    boolean is_category2() {\n+        return ((_data & Category2) == Category2);\n+    }\n+\n+    boolean is_category2_2nd() {\n+        return ((_data & Category2_2nd) == Category2_2nd);\n+    }\n+\n+    boolean is_check() {\n+        return (_data & TypeQuery) == TypeQuery;\n+    }\n+\n+    boolean is_x_array(char sig) {\n+        return is_null() || (is_array() &&(name().charAt(1) == sig));\n+    }\n+\n+    boolean is_int_array() {\n+        return is_x_array(JVM_SIGNATURE_INT);\n+    }\n+\n+    boolean is_byte_array() {\n+        return is_x_array(JVM_SIGNATURE_BYTE);\n+    }\n+\n+    boolean is_bool_array() {\n+        return is_x_array(JVM_SIGNATURE_BOOLEAN);\n+    }\n+\n+    boolean is_char_array() {\n+        return is_x_array(JVM_SIGNATURE_CHAR);\n+    }\n+\n+    boolean is_short_array() {\n+        return is_x_array(JVM_SIGNATURE_SHORT);\n+    }\n+\n+    boolean is_long_array() {\n+        return is_x_array(JVM_SIGNATURE_LONG);\n+    }\n+\n+    boolean is_float_array() {\n+        return is_x_array(JVM_SIGNATURE_FLOAT);\n+    }\n+\n+    boolean is_double_array() {\n+        return is_x_array(JVM_SIGNATURE_DOUBLE);\n+    }\n+\n+    boolean is_object_array() {\n+        return is_x_array(JVM_SIGNATURE_CLASS);\n+    }\n+\n+    boolean is_array_array() {\n+        return is_x_array(JVM_SIGNATURE_ARRAY);\n+    }\n+\n+    boolean is_reference_array() {\n+        return is_object_array() || is_array_array();\n+    }\n+\n+    boolean is_object() {\n+        return (is_reference() && !is_null() && name().length() >= 1 && name().charAt(0) != JVM_SIGNATURE_ARRAY);\n+    }\n+\n+    boolean is_array() {\n+        return (is_reference() && !is_null() && name().length() >= 2 && name().charAt(0) == JVM_SIGNATURE_ARRAY);\n+    }\n+\n+    boolean is_uninitialized() {\n+        return ((_data & Uninitialized) == Uninitialized);\n+    }\n+\n+    boolean is_uninitialized_this(VerifierImpl context) {\n+        return is_uninitialized() && bci(context) == BciForThis;\n+    }\n+\n+    VerificationType to_category2_2nd(VerifierImpl context) {\n+        if (!(is_category2())) context.verifyError(\"Must be a double word\");\n+        return is_long() ? long2_type : double2_type;\n+    }\n+\n+    int bci(VerifierImpl context) {\n+        if (!(is_uninitialized())) context.verifyError(\"Must be uninitialized type\");\n+        return ((_data & BciMask) >> 1 * BitsPerByte);\n+    }\n+\n+    boolean is_assignable_from(VerificationType from, VerifierImpl context) {\n+        boolean ret = _is_assignable_from(from, context);\n+        context.errorContext = ret ? \"\" : String.format(\"(%s is not assignable from %s)\", this, from);\n+        return ret;\n+    }\n+\n+    private boolean _is_assignable_from(VerificationType from, VerifierImpl context) {\n+        if (equals(from) || is_bogus()) {\n+            return true;\n+        } else {\n+            switch(_data) {\n+                case Category1Query:\n+                    return from.is_category1(context);\n+                case Category2Query:\n+                    return from.is_category2();\n+                case Category2_2ndQuery:\n+                    return from.is_category2_2nd();\n+                case ReferenceQuery:\n+                    return from.is_reference() || from.is_uninitialized();\n+                case Boolean:\n+                case Byte:\n+                case Char:\n+                case Short:\n+                    return from.is_integer();\n+                default:\n+                    if (is_reference() && from.is_reference()) {\n+                        return is_reference_assignable_from(from, context);\n+                    } else {\n+                        return false;\n+                    }\n+            }\n+        }\n+    }\n+\n+    \/\/ Check to see if one array component type is assignable to another.\n+    \/\/ Same as is_assignable_from() except int primitives must be identical.\n+    boolean is_component_assignable_from(VerificationType from, VerifierImpl context) {\n+        if (equals(from) || is_bogus()) {\n+            return true;\n+        } else {\n+            switch (_data) {\n+                case Boolean:\n+                case Byte:\n+                case Char:\n+                case Short:\n+                    return false;\n+                default:\n+                    return is_assignable_from(from, context);\n+            }\n+        }\n+    }\n+\n+    int dimensions(VerifierImpl context) {\n+        if (!(is_array())) context.verifyError(\"Must be an array\");\n+        int index = 0;\n+        while (name().charAt(index) == JVM_SIGNATURE_ARRAY) index++;\n+        return index;\n+    }\n+\n+    static VerificationType from_tag(int tag, VerifierImpl context) {\n+        switch (tag) {\n+            case ITEM_Top:         return bogus_type;\n+            case ITEM_Integer: return integer_type;\n+            case ITEM_Float:     return float_type;\n+            case ITEM_Double:    return double_type;\n+            case ITEM_Long:        return long_type;\n+            case ITEM_Null:        return null_type;\n+            default:\n+                context.verifyError(\"Should not reach here\");\n+                return bogus_type;\n+        }\n+    }\n+\n+    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String name, String from_name, boolean from_is_array, boolean from_is_object) {\n+        \/\/let's delegate assignability to SPI\n+        var desc = Util.toClassDesc(name);\n+        if (assignResolver.isInterface(desc)) {\n+            return !from_is_array || \"java\/lang\/Cloneable\".equals(name) || \"java\/io\/Serializable\".equals(name);\n+        } else if (from_is_object) {\n+            return assignResolver.isAssignableFrom(desc, Util.toClassDesc(from_name));\n+        }\n+        return false;\n+    }\n+\n+    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context) {\n+        ClassHierarchyImpl clsTree = context.class_hierarchy();\n+        if (from.is_null()) {\n+            return true;\n+        } else if (is_null()) {\n+            return false;\n+        } else if (name().equals(from.name())) {\n+            return true;\n+        } else if (is_object()) {\n+            if (VerifierImpl.java_lang_Object.equals(name())) {\n+                return true;\n+            }\n+            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object());\n+        } else if (is_array() && from.is_array()) {\n+            VerificationType comp_this = get_component(context);\n+            VerificationType comp_from = from.get_component(context);\n+            if (!comp_this.is_bogus() && !comp_from.is_bogus()) {\n+                return comp_this.is_component_assignable_from(comp_from, context);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    VerificationType get_component(VerifierImpl context) {\n+        if (!(is_array() && name().length() >= 2)) context.verifyError(\"Must be a valid array\");\n+        var ss = new VerificationSignature(name(), false, context);\n+        ss.skipArrayPrefix(1);\n+        switch (ss.type()) {\n+            case T_BOOLEAN: return VerificationType.boolean_type;\n+            case T_BYTE:        return VerificationType.byte_type;\n+            case T_CHAR:        return VerificationType.char_type;\n+            case T_SHORT:     return VerificationType.short_type;\n+            case T_INT:         return VerificationType.integer_type;\n+            case T_LONG:        return VerificationType.long_type;\n+            case T_FLOAT:     return VerificationType.float_type;\n+            case T_DOUBLE:    return VerificationType.double_type;\n+            case T_ARRAY:\n+            case T_OBJECT: {\n+                if (!(ss.isReference())) context.verifyError(\"Unchecked verifier input\");\n+                String component = ss.asSymbol();\n+                return VerificationType.reference_type(component);\n+         }\n+         default:\n+             return VerificationType.bogus_type;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationType.java","additions":464,"deletions":0,"binary":false,"changes":464,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.DynamicConstantPoolEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.attribute.LocalVariableInfo;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.CodeImpl;\n+import jdk.internal.classfile.impl.Util;\n+\n+public final class VerificationWrapper {\n+    private final ClassModel clm;\n+    private final ConstantPoolWrapper cp;\n+\n+    public VerificationWrapper(ClassModel clm) {\n+        this.clm = clm;\n+        this.cp = new ConstantPoolWrapper(clm.constantPool());\n+     }\n+\n+    String thisClassName() {\n+        return clm.thisClass().asInternalName();\n+    }\n+\n+    int majorVersion() {\n+        return clm.majorVersion();\n+    }\n+\n+    String superclassName() {\n+        return clm.superclass().map(ClassEntry::asInternalName).orElse(null);\n+    }\n+\n+    Iterable<String> interfaceNames() {\n+        return Util.mappedList(clm.interfaces(), ClassEntry::asInternalName);\n+    }\n+\n+    ConstantPoolWrapper constantPool() {\n+        return cp;\n+    }\n+\n+    Iterable<MethodWrapper> methods() {\n+        return clm.methods().stream().map(m -> new MethodWrapper(m)).toList();\n+    }\n+\n+    boolean findField(String name, String sig) {\n+        for (var f : clm.fields())\n+            if (f.fieldName().stringValue().equals(name) && f.fieldType().stringValue().equals(sig))\n+                return true;\n+        return false;\n+    }\n+\n+    class MethodWrapper {\n+\n+        final MethodModel m;\n+        private final CodeImpl c;\n+        private final List<int[]> exc;\n+\n+        MethodWrapper(MethodModel m) {\n+            this.m = m;\n+            this.c = (CodeImpl)m.code().orElse(null);\n+            exc = new LinkedList<>();\n+            if (c != null) c.iterateExceptionHandlers((start, end, handler, catchType) -> {\n+                exc.add(new int[] {start, end, handler, catchType});\n+            });\n+        }\n+\n+        ConstantPoolWrapper constantPool() {\n+            return cp;\n+        }\n+\n+        boolean isNative() {\n+            return m.flags().has(AccessFlag.NATIVE);\n+        }\n+\n+        boolean isAbstract() {\n+            return m.flags().has(AccessFlag.ABSTRACT);\n+        }\n+\n+        boolean isBridge() {\n+            return m.flags().has(AccessFlag.BRIDGE);\n+        }\n+\n+        boolean isStatic() {\n+            return m.flags().has(AccessFlag.STATIC);\n+        }\n+\n+        String name() {\n+            return m.methodName().stringValue();\n+        }\n+\n+        int maxStack() {\n+            return c == null ? 0 : c.maxStack();\n+        }\n+\n+        int maxLocals() {\n+            return c == null ? 0 : c.maxLocals();\n+        }\n+\n+        String descriptor() {\n+            return m.methodType().stringValue();\n+        }\n+\n+        int codeLength() {\n+            return c == null ? 0 : c.codeLength();\n+        }\n+\n+        byte[] codeArray() {\n+            return c == null ? null : c.codeArray();\n+        }\n+\n+        List<int[]> exceptionTable() {\n+            return exc;\n+        }\n+\n+        List<LocalVariableInfo> localVariableTable() {\n+            var attro = c.findAttribute(Attributes.LOCAL_VARIABLE_TABLE);\n+            return attro.map(lvta -> lvta.localVariables()).orElse(List.of());\n+        }\n+\n+        byte[] stackMapTableRawData() {\n+            var attro = c.findAttribute(Attributes.STACK_MAP_TABLE);\n+            return attro.map(attr -> ((BoundAttribute) attr).contents()).orElse(null);\n+        }\n+\n+    }\n+\n+    static class ConstantPoolWrapper {\n+\n+        private final ConstantPool cp;\n+\n+        ConstantPoolWrapper(ConstantPool cp) {\n+            this.cp = cp;\n+        }\n+\n+        int entryCount() {\n+            return cp.entryCount();\n+        }\n+\n+        String classNameAt(int index) {\n+            return ((ClassEntry)cp.entryByIndex(index)).asInternalName();\n+        }\n+\n+        String dynamicConstantSignatureAt(int index) {\n+            return ((DynamicConstantPoolEntry)cp.entryByIndex(index)).type().stringValue();\n+        }\n+\n+        int tagAt(int index) {\n+            return cp.entryByIndex(index).tag();\n+        }\n+\n+        private NameAndTypeEntry _refNameType(int index) {\n+            var e = cp.entryByIndex(index);\n+            return (e instanceof DynamicConstantPoolEntry de) ? de.nameAndType() : ((MemberRefEntry)e).nameAndType();\n+        }\n+\n+        String refNameAt(int index) {\n+            return _refNameType(index).name().stringValue();\n+        }\n+\n+        String refSignatureAt(int index) {\n+            return _refNameType(index).type().stringValue();\n+        }\n+\n+        int refClassIndexAt(int index) {\n+            return ((MemberRefEntry)cp.entryByIndex(index)).owner().index();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,1846 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.impl.ClassHierarchyImpl;\n+import jdk.internal.classfile.impl.RawBytecodeHelper;\n+import static jdk.internal.classfile.impl.RawBytecodeHelper.ILLEGAL;\n+import jdk.internal.classfile.impl.verifier.VerificationWrapper.ConstantPoolWrapper;\n+import static jdk.internal.classfile.impl.verifier.VerificationSignature.BasicType.*;\n+import jdk.internal.classfile.impl.verifier.VerificationSignature.BasicType;\n+import static jdk.internal.classfile.impl.verifier.VerificationFrame.FLAG_THIS_UNINIT;\n+\n+\/**\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/java.base\/share\/native\/include\/classfile_constants.h.template\">java.base\/share\/native\/include\/classfile_constants.h.template<\/a>\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.hpp\">hotspot\/share\/classfile\/verifier.hpp<\/a>\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.cpp\">hotspot\/share\/classfile\/verifier.cpp<\/a>\n+ *\/\n+public final class VerifierImpl {\n+    static final int\n+            JVM_CONSTANT_Utf8                   = 1,\n+            JVM_CONSTANT_Unicode                = 2,\n+            JVM_CONSTANT_Integer                = 3,\n+            JVM_CONSTANT_Float                  = 4,\n+            JVM_CONSTANT_Long                   = 5,\n+            JVM_CONSTANT_Double                 = 6,\n+            JVM_CONSTANT_Class                  = 7,\n+            JVM_CONSTANT_String                 = 8,\n+            JVM_CONSTANT_Fieldref               = 9,\n+            JVM_CONSTANT_Methodref              = 10,\n+            JVM_CONSTANT_InterfaceMethodref     = 11,\n+            JVM_CONSTANT_NameAndType            = 12,\n+            JVM_CONSTANT_MethodHandle           = 15,\n+            JVM_CONSTANT_MethodType             = 16,\n+            JVM_CONSTANT_Dynamic                = 17,\n+            JVM_CONSTANT_InvokeDynamic          = 18,\n+            JVM_CONSTANT_Module                 = 19,\n+            JVM_CONSTANT_Package                = 20,\n+            JVM_CONSTANT_ExternalMax            = 20;\n+\n+static final char JVM_SIGNATURE_SLASH = '\/',\n+            JVM_SIGNATURE_DOT = '.',\n+            JVM_SIGNATURE_SPECIAL = '<',\n+            JVM_SIGNATURE_ENDSPECIAL = '>',\n+            JVM_SIGNATURE_ARRAY = '[',\n+            JVM_SIGNATURE_BYTE = 'B',\n+            JVM_SIGNATURE_CHAR = 'C',\n+            JVM_SIGNATURE_CLASS = 'L',\n+            JVM_SIGNATURE_ENDCLASS = ';',\n+            JVM_SIGNATURE_ENUM = 'E',\n+            JVM_SIGNATURE_FLOAT = 'F',\n+            JVM_SIGNATURE_DOUBLE = 'D',\n+            JVM_SIGNATURE_FUNC = '(',\n+            JVM_SIGNATURE_ENDFUNC = ')',\n+            JVM_SIGNATURE_INT = 'I',\n+            JVM_SIGNATURE_LONG = 'J',\n+            JVM_SIGNATURE_SHORT = 'S',\n+            JVM_SIGNATURE_VOID = 'V',\n+            JVM_SIGNATURE_BOOLEAN = 'Z';\n+\n+    static final String java_lang_String = \"java\/lang\/String\";\n+    static final String object_initializer_name = \"<init>\";\n+    static final String java_lang_invoke_MethodHandle = \"java\/lang\/invoke\/MethodHandle\";\n+    static final String java_lang_Object = \"java\/lang\/Object\";\n+    static final String java_lang_invoke_MethodType = \"java\/lang\/invoke\/MethodType\";\n+    static final String java_lang_Throwable = \"java\/lang\/Throwable\";\n+    static final String java_lang_Class = \"java\/lang\/Class\";\n+\n+    String errorContext = \"\";\n+    private int bci;\n+\n+    static void log_info(Consumer<String> logger, String messageFormat, Object... args) {\n+        if (logger != null) logger.accept(String.format(messageFormat + \"%n\", args));\n+    }\n+    private final Consumer<String> _logger;\n+    void log_info(String messageFormat, Object... args) {\n+        log_info(_logger, messageFormat, args);\n+    }\n+\n+\n+    static final int STACKMAP_ATTRIBUTE_MAJOR_VERSION = 50;\n+    static final int INVOKEDYNAMIC_MAJOR_VERSION = 51;\n+    static final int NOFAILOVER_MAJOR_VERSION = 51;\n+\n+    public static List<VerifyError> verify(ClassModel classModel, Consumer<String> logger) {\n+        return verify(classModel, ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER, logger);\n+    }\n+\n+    public static List<VerifyError> verify(ClassModel classModel, ClassHierarchyResolver classHierarchyResolver, Consumer<String> logger) {\n+        var klass = new VerificationWrapper(classModel);\n+        if (!is_eligible_for_verification(klass)) {\n+            return List.of();\n+        }\n+        log_info(logger, \"Start class verification for: %s\", klass.thisClassName());\n+        try {\n+            if (klass.majorVersion() >= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {\n+                var errors = new VerifierImpl(klass, classHierarchyResolver, logger).verify_class();\n+                if (!errors.isEmpty() && klass.majorVersion() < NOFAILOVER_MAJOR_VERSION) {\n+                    log_info(logger, \"Fail over class verification to old verifier for: %s\", klass.thisClassName());\n+                    return inference_verify(klass);\n+                } else {\n+                    return errors;\n+                }\n+            } else {\n+                return inference_verify(klass);\n+            }\n+        } finally {\n+            log_info(logger, \"End class verification for: %s\", klass.thisClassName());\n+        }\n+    }\n+\n+    public static boolean is_eligible_for_verification(VerificationWrapper klass) {\n+        String name = klass.thisClassName();\n+        return !java_lang_Object.equals(name) &&\n+                !java_lang_Class.equals(name) &&\n+                !java_lang_String.equals(name) &&\n+                !java_lang_Throwable.equals(name);\n+    }\n+\n+    static List<VerifyError> inference_verify(VerificationWrapper klass) {\n+        return List.of(new VerifyError(\"Inference verification is not supported\"));\n+    }\n+\n+    static class sig_as_verification_types {\n+        private int _num_args;\n+        private ArrayList<VerificationType> _sig_verif_types;\n+\n+        sig_as_verification_types(ArrayList<VerificationType> sig_verif_types) {\n+            this._sig_verif_types = sig_verif_types;\n+            this._num_args = 0;\n+        }\n+\n+        int num_args() {\n+            return _num_args;\n+        }\n+\n+        void set_num_args(int num_args) {\n+            _num_args = num_args;\n+        }\n+\n+        ArrayList<VerificationType> sig_verif_types() {\n+            return _sig_verif_types;\n+        }\n+\n+        void set_sig_verif_types(ArrayList<VerificationType> sig_verif_types) {\n+            _sig_verif_types = sig_verif_types;\n+        }\n+    }\n+\n+    VerificationType cp_ref_index_to_type(int index, ConstantPoolWrapper cp) {\n+        return cp_index_to_type(cp.refClassIndexAt(index), cp);\n+    }\n+\n+    final VerificationWrapper _klass;\n+    final ClassHierarchyImpl _class_hierarchy;\n+    VerificationWrapper.MethodWrapper _method;\n+    VerificationType _this_type;\n+\n+    static final int BYTECODE_OFFSET = 1, NEW_OFFSET = 2;\n+\n+    VerificationWrapper.MethodWrapper method() {\n+        return _method;\n+    }\n+\n+    VerificationWrapper current_class() {\n+        return _klass;\n+    }\n+\n+    ClassHierarchyImpl class_hierarchy() {\n+        return _class_hierarchy;\n+    }\n+\n+    VerificationType current_type() {\n+        return _this_type;\n+    }\n+\n+    VerificationType cp_index_to_type(int index, ConstantPoolWrapper cp) {\n+        return VerificationType.reference_type(cp.classNameAt(index));\n+    }\n+\n+    int change_sig_to_verificationType(VerificationSignature sig_type, VerificationType inference_types[], int inference_type_index) {\n+        BasicType bt = sig_type.type();\n+        switch (bt) {\n+            case T_OBJECT:\n+            case T_ARRAY:\n+                String name = sig_type.asSymbol();\n+                inference_types[inference_type_index] = VerificationType.reference_type(name);\n+                return 1;\n+            case T_LONG:\n+                inference_types[inference_type_index] = VerificationType.long_type;\n+                inference_types[++inference_type_index] = VerificationType.long2_type;\n+                return 2;\n+            case T_DOUBLE:\n+                inference_types[inference_type_index] = VerificationType.double_type;\n+                inference_types[++inference_type_index] = VerificationType.double2_type;\n+                return 2;\n+            case T_INT:\n+            case T_BOOLEAN:\n+            case T_BYTE:\n+            case T_CHAR:\n+            case T_SHORT:\n+                inference_types[inference_type_index] = VerificationType.integer_type;\n+                return 1;\n+            case T_FLOAT:\n+                inference_types[inference_type_index] = VerificationType.float_type;\n+                return 1;\n+            default:\n+                verifyError(\"Should not reach here\");\n+                return 1;\n+        }\n+    }\n+\n+    private static final int NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION = 51;\n+    private static final int STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION = 52;\n+    private static final int MAX_ARRAY_DIMENSIONS = 255;\n+\n+    VerifierImpl(VerificationWrapper klass, ClassHierarchyResolver classHierarchyResolver, Consumer<String> logger) {\n+        _klass = klass;\n+        _class_hierarchy = new ClassHierarchyImpl(classHierarchyResolver);\n+        _this_type = VerificationType.reference_type(klass.thisClassName());\n+        _logger = logger;\n+    }\n+\n+    private VerificationType object_type() {\n+        return VerificationType.reference_type(java_lang_Object);\n+    }\n+\n+    List<VerifyError> verify_class() {\n+        log_info(\"Verifying class %s with new format\", _klass.thisClassName());\n+        var errors = new ArrayList<VerifyError>();\n+        for (VerificationWrapper.MethodWrapper m : _klass.methods()) {\n+            if (m.isNative() || m.isAbstract() || m.isBridge()) {\n+                continue;\n+            }\n+            verify_method(m, errors);\n+        }\n+        return errors;\n+    }\n+\n+    void translate_signature(String method_sig, sig_as_verification_types sig_verif_types) {\n+        var sig_stream = new VerificationSignature(method_sig, true, this);\n+        VerificationType[] sig_type = new VerificationType[2];\n+        int sig_i = 0;\n+        ArrayList<VerificationType> verif_types = sig_verif_types.sig_verif_types();\n+        while (!sig_stream.atReturnType()) {\n+            int n = change_sig_to_verificationType(sig_stream, sig_type, 0);\n+            if (n > 2) verifyError(\"Unexpected signature type\");\n+            for (int x = 0; x < n; x++) {\n+                verif_types.add(sig_type[x]);\n+            }\n+            sig_i += n;\n+            sig_stream.next();\n+        }\n+        sig_verif_types.set_num_args(sig_i);\n+        if (sig_stream.type() != BasicType.T_VOID) {\n+            int n = change_sig_to_verificationType(sig_stream, sig_type, 0);\n+            if (n > 2) verifyError(\"Unexpected signature return type\");\n+            for (int y = 0; y < n; y++) {\n+                verif_types.add(sig_type[y]);\n+            }\n+        }\n+    }\n+\n+    void create_method_sig_entry(sig_as_verification_types sig_verif_types, String method_sig) {\n+        translate_signature(method_sig, sig_verif_types);\n+    }\n+\n+    void verify_method(VerificationWrapper.MethodWrapper m, List<VerifyError> errorsCollector) {\n+        try {\n+            verify_method(m, m.maxLocals(), m.maxStack(), m.stackMapTableRawData());\n+        } catch (VerifyError err) {\n+            errorsCollector.add(err);\n+        } catch (Error | Exception e) {\n+            errorsCollector.add(new VerifyError(e.toString()));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    void verify_method(VerificationWrapper.MethodWrapper m, int max_locals, int max_stack, byte[] stackmap_data) {\n+        _method = m;\n+        log_info(_logger, \"Verifying method %s%s\", m.name(), m.descriptor());\n+        var cp = m.constantPool();\n+        if (!VerificationSignature.isValidMethodSignature(m.descriptor())) verifyError(\"Invalid method signature\");\n+        VerificationFrame current_frame = new VerificationFrame(max_locals, max_stack, this);\n+        VerificationType return_type = current_frame.set_locals_from_arg(m, current_type());\n+        int stackmap_index = 0;\n+        int code_length = m.codeLength();\n+        var code = ByteBuffer.wrap(_method.codeArray(), 0, _method.codeLength());\n+        byte[] code_data = generate_code_data(code, code_length);\n+        int ex_minmax[] = new int[] {code_length, -1};\n+        verify_exception_handler_table(code_length, code_data, ex_minmax);\n+        verify_local_variable_table(code_length, code_data);\n+\n+        VerificationTable stackmap_table = new VerificationTable(stackmap_data, current_frame, max_locals, max_stack, code_data, code_length, cp, this);\n+\n+        var bcs = new RawBytecodeHelper(code);\n+        boolean no_control_flow = false;\n+        int opcode;\n+        while (!bcs.isLastBytecode()) {\n+            opcode = bcs.rawNext();\n+            bci = bcs.bci;\n+            current_frame.set_offset(bci);\n+            current_frame.set_mark();\n+            stackmap_index = verify_stackmap_table(stackmap_index, bci, current_frame, stackmap_table, no_control_flow);\n+            boolean this_uninit = false;\n+            boolean verified_exc_handlers = false;\n+            {\n+                int index;\n+                int target;\n+                VerificationType type, type2 = null;\n+                VerificationType atype;\n+                if (bcs.isWide) {\n+                    if (opcode != Classfile.IINC && opcode != Classfile.ILOAD\n+                        && opcode != Classfile.ALOAD && opcode != Classfile.LLOAD\n+                        && opcode != Classfile.ISTORE && opcode != Classfile.ASTORE\n+                        && opcode != Classfile.LSTORE && opcode != Classfile.FLOAD\n+                        && opcode != Classfile.DLOAD && opcode != Classfile.FSTORE\n+                        && opcode != Classfile.DSTORE) {\n+                        verifyError(\"Bad wide instruction\");\n+                    }\n+                }\n+                if (VerificationBytecodes.is_store_into_local(opcode) && bci >= ex_minmax[0] && bci < ex_minmax[1]) {\n+                    verify_exception_handler_targets(bci, this_uninit, current_frame, stackmap_table);\n+                    verified_exc_handlers = true;\n+                }\n+                switch (opcode) {\n+                    case Classfile.NOP :\n+                        no_control_flow = false; break;\n+                    case Classfile.ACONST_NULL :\n+                        current_frame.push_stack(\n+                            VerificationType.null_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.ICONST_M1 :\n+                    case Classfile.ICONST_0 :\n+                    case Classfile.ICONST_1 :\n+                    case Classfile.ICONST_2 :\n+                    case Classfile.ICONST_3 :\n+                    case Classfile.ICONST_4 :\n+                    case Classfile.ICONST_5 :\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.LCONST_0 :\n+                    case Classfile.LCONST_1 :\n+                        current_frame.push_stack_2(\n+                            VerificationType.long_type,\n+                            VerificationType.long2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.FCONST_0 :\n+                    case Classfile.FCONST_1 :\n+                    case Classfile.FCONST_2 :\n+                        current_frame.push_stack(\n+                            VerificationType.float_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DCONST_0 :\n+                    case Classfile.DCONST_1 :\n+                        current_frame.push_stack_2(\n+                            VerificationType.double_type,\n+                            VerificationType.double2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.SIPUSH :\n+                    case Classfile.BIPUSH :\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.LDC :\n+                        verify_ldc(\n+                            opcode, bcs.getIndexU1(), current_frame,\n+                            cp, bci);\n+                        no_control_flow = false; break;\n+                    case Classfile.LDC_W :\n+                    case Classfile.LDC2_W :\n+                        verify_ldc(\n+                            opcode, bcs.getIndexU2(), current_frame,\n+                            cp, bci);\n+                        no_control_flow = false; break;\n+                    case Classfile.ILOAD :\n+                        verify_iload(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ILOAD_0 :\n+                    case Classfile.ILOAD_1 :\n+                    case Classfile.ILOAD_2 :\n+                    case Classfile.ILOAD_3 :\n+                        index = opcode - Classfile.ILOAD_0;\n+                        verify_iload(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.LLOAD :\n+                        verify_lload(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.LLOAD_0 :\n+                    case Classfile.LLOAD_1 :\n+                    case Classfile.LLOAD_2 :\n+                    case Classfile.LLOAD_3 :\n+                        index = opcode - Classfile.LLOAD_0;\n+                        verify_lload(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.FLOAD :\n+                        verify_fload(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.FLOAD_0 :\n+                    case Classfile.FLOAD_1 :\n+                    case Classfile.FLOAD_2 :\n+                    case Classfile.FLOAD_3 :\n+                        index = opcode - Classfile.FLOAD_0;\n+                        verify_fload(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.DLOAD :\n+                        verify_dload(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.DLOAD_0 :\n+                    case Classfile.DLOAD_1 :\n+                    case Classfile.DLOAD_2 :\n+                    case Classfile.DLOAD_3 :\n+                        index = opcode - Classfile.DLOAD_0;\n+                        verify_dload(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ALOAD :\n+                        verify_aload(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ALOAD_0 :\n+                    case Classfile.ALOAD_1 :\n+                    case Classfile.ALOAD_2 :\n+                    case Classfile.ALOAD_3 :\n+                        index = opcode - Classfile.ALOAD_0;\n+                        verify_aload(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.IALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_int_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.BALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_bool_array() && !atype.is_byte_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.CALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_char_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.SALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_short_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.LALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_long_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack_2(\n+                            VerificationType.long_type,\n+                            VerificationType.long2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.FALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_float_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(\n+                            VerificationType.float_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DALOAD :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_double_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack_2(\n+                            VerificationType.double_type,\n+                            VerificationType.double2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.AALOAD : {\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_reference_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        if (atype.is_null()) {\n+                            current_frame.push_stack(\n+                                VerificationType.null_type);\n+                        } else {\n+                            VerificationType component =\n+                                atype.get_component(this);\n+                            current_frame.push_stack(component);\n+                        }\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.ISTORE :\n+                        verify_istore(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ISTORE_0 :\n+                    case Classfile.ISTORE_1 :\n+                    case Classfile.ISTORE_2 :\n+                    case Classfile.ISTORE_3 :\n+                        index = opcode - Classfile.ISTORE_0;\n+                        verify_istore(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.LSTORE :\n+                        verify_lstore(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.LSTORE_0 :\n+                    case Classfile.LSTORE_1 :\n+                    case Classfile.LSTORE_2 :\n+                    case Classfile.LSTORE_3 :\n+                        index = opcode - Classfile.LSTORE_0;\n+                        verify_lstore(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.FSTORE :\n+                        verify_fstore(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.FSTORE_0 :\n+                    case Classfile.FSTORE_1 :\n+                    case Classfile.FSTORE_2 :\n+                    case Classfile.FSTORE_3 :\n+                        index = opcode - Classfile.FSTORE_0;\n+                        verify_fstore(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.DSTORE :\n+                        verify_dstore(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.DSTORE_0 :\n+                    case Classfile.DSTORE_1 :\n+                    case Classfile.DSTORE_2 :\n+                    case Classfile.DSTORE_3 :\n+                        index = opcode - Classfile.DSTORE_0;\n+                        verify_dstore(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ASTORE :\n+                        verify_astore(bcs.getIndex(), current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ASTORE_0 :\n+                    case Classfile.ASTORE_1 :\n+                    case Classfile.ASTORE_2 :\n+                    case Classfile.ASTORE_3 :\n+                        index = opcode - Classfile.ASTORE_0;\n+                        verify_astore(index, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.IASTORE :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_int_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.BASTORE :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_bool_array() && !atype.is_byte_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.CASTORE :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_char_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.SASTORE :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_short_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.LASTORE :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_long_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.FASTORE :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.pop_stack\n+                            (VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_float_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.DASTORE :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!atype.is_double_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.AASTORE :\n+                        type = current_frame.pop_stack(object_type());\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        atype = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        \/\/ more type-checking is done at runtime\n+                        if (!atype.is_reference_array()) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        \/\/ 4938384: relaxed constraint in JVMS 3nd edition.\n+                        no_control_flow = false; break;\n+                    case Classfile.POP :\n+                        current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        no_control_flow = false; break;\n+                    case Classfile.POP2 :\n+                        type = current_frame.pop_stack();\n+                        if (type.is_category1(this)) {\n+                            current_frame.pop_stack(\n+                                VerificationType.category1_check);\n+                        } else if (type.is_category2_2nd()) {\n+                            current_frame.pop_stack(\n+                                VerificationType.category2_check);\n+                        } else {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        no_control_flow = false; break;\n+                    case Classfile.DUP :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DUP_X1 :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DUP_X2 :\n+                    {\n+                        VerificationType type3 = null;\n+                        type = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        type2 = current_frame.pop_stack();\n+                        if (type2.is_category1(this)) {\n+                            type3 = current_frame.pop_stack(\n+                                VerificationType.category1_check);\n+                        } else if (type2.is_category2_2nd()) {\n+                            type3 = current_frame.pop_stack(\n+                                VerificationType.category2_check);\n+                        } else {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type3);\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.DUP2 :\n+                        type = current_frame.pop_stack();\n+                        if (type.is_category1(this)) {\n+                            type2 = current_frame.pop_stack(\n+                                VerificationType.category1_check);\n+                        } else if (type.is_category2_2nd()) {\n+                            type2 = current_frame.pop_stack(\n+                                VerificationType.category2_check);\n+                        } else {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DUP2_X1 :\n+                    {\n+                        VerificationType type3;\n+                        type = current_frame.pop_stack();\n+                        if (type.is_category1(this)) {\n+                            type2 = current_frame.pop_stack(\n+                                VerificationType.category1_check);\n+                        } else if (type.is_category2_2nd()) {\n+                            type2 = current_frame.pop_stack(\n+                                VerificationType.category2_check);\n+                        } else {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        type3 = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type3);\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.DUP2_X2 :\n+                        VerificationType type3, type4 = null;\n+                        type = current_frame.pop_stack();\n+                        if (type.is_category1(this)) {\n+                            type2 = current_frame.pop_stack(\n+                                VerificationType.category1_check);\n+                        } else if (type.is_category2_2nd()) {\n+                            type2 = current_frame.pop_stack(\n+                                VerificationType.category2_check);\n+                        } else {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        type3 = current_frame.pop_stack();\n+                        if (type3.is_category1(this)) {\n+                            type4 = current_frame.pop_stack(\n+                                VerificationType.category1_check);\n+                        } else if (type3.is_category2_2nd()) {\n+                            type4 = current_frame.pop_stack(\n+                                VerificationType.category2_check);\n+                        } else {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type4);\n+                        current_frame.push_stack(type3);\n+                        current_frame.push_stack(type2);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    case Classfile.SWAP :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.category1_check);\n+                        current_frame.push_stack(type);\n+                        current_frame.push_stack(type2);\n+                        no_control_flow = false; break;\n+                    case Classfile.IADD :\n+                    case Classfile.ISUB :\n+                    case Classfile.IMUL :\n+                    case Classfile.IDIV :\n+                    case Classfile.IREM :\n+                    case Classfile.ISHL :\n+                    case Classfile.ISHR :\n+                    case Classfile.IUSHR :\n+                    case Classfile.IOR :\n+                    case Classfile.IXOR :\n+                    case Classfile.IAND :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        \/\/ fall through\n+                    case Classfile.INEG :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.LADD :\n+                    case Classfile.LSUB :\n+                    case Classfile.LMUL :\n+                    case Classfile.LDIV :\n+                    case Classfile.LREM :\n+                    case Classfile.LAND :\n+                    case Classfile.LOR :\n+                    case Classfile.LXOR :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        \/\/ fall through\n+                    case Classfile.LNEG :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.long_type,\n+                            VerificationType.long2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.LSHL :\n+                    case Classfile.LSHR :\n+                    case Classfile.LUSHR :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.long_type,\n+                            VerificationType.long2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.FADD :\n+                    case Classfile.FSUB :\n+                    case Classfile.FMUL :\n+                    case Classfile.FDIV :\n+                    case Classfile.FREM :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        \/\/ fall through\n+                    case Classfile.FNEG :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.push_stack(\n+                            VerificationType.float_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DADD :\n+                    case Classfile.DSUB :\n+                    case Classfile.DMUL :\n+                    case Classfile.DDIV :\n+                    case Classfile.DREM :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        \/\/ fall through\n+                    case Classfile.DNEG :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.double_type,\n+                            VerificationType.double2_type);\n+                        no_control_flow = false; break;\n+                                case Classfile.IINC :\n+                                    verify_iinc(bcs.getIndex(), current_frame);\n+                                    no_control_flow = false; break;\n+                                case Classfile.I2L :\n+                                    type = current_frame.pop_stack(\n+                                        VerificationType.integer_type);\n+                                    current_frame.push_stack_2(\n+                                        VerificationType.long_type,\n+                                        VerificationType.long2_type);\n+                                    no_control_flow = false; break;\n+                             case Classfile.L2I :\n+                                    current_frame.pop_stack_2(\n+                                        VerificationType.long2_type,\n+                                        VerificationType.long_type);\n+                                    current_frame.push_stack(\n+                                        VerificationType.integer_type);\n+                                    no_control_flow = false; break;\n+                                case Classfile.I2F :\n+                                    current_frame.pop_stack(\n+                                        VerificationType.integer_type);\n+                                    current_frame.push_stack(\n+                                        VerificationType.float_type);\n+                                    no_control_flow = false; break;\n+                    case Classfile.I2D :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.double_type,\n+                            VerificationType.double2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.L2F :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.push_stack(\n+                            VerificationType.float_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.L2D :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.double_type,\n+                            VerificationType.double2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.F2I :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.F2L :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.long_type,\n+                            VerificationType.long2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.F2D :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.double_type,\n+                            VerificationType.double2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.D2I :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.D2L :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.push_stack_2(\n+                            VerificationType.long_type,\n+                            VerificationType.long2_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.D2F :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.push_stack(\n+                            VerificationType.float_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.I2B :\n+                    case Classfile.I2C :\n+                    case Classfile.I2S :\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.LCMP :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.pop_stack_2(\n+                            VerificationType.long2_type,\n+                            VerificationType.long_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.FCMPL :\n+                    case Classfile.FCMPG :\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.DCMPL :\n+                    case Classfile.DCMPG :\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.pop_stack_2(\n+                            VerificationType.double2_type,\n+                            VerificationType.double_type);\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.IF_ICMPEQ:\n+                    case Classfile.IF_ICMPNE:\n+                    case Classfile.IF_ICMPLT:\n+                    case Classfile.IF_ICMPGE:\n+                    case Classfile.IF_ICMPGT:\n+                    case Classfile.IF_ICMPLE:\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        \/\/ fall through\n+                    case Classfile.IFEQ:\n+                    case Classfile.IFNE:\n+                    case Classfile.IFLT:\n+                    case Classfile.IFGE:\n+                    case Classfile.IFGT:\n+                    case Classfile.IFLE:\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        target = bcs.dest();\n+                        stackmap_table.check_jump_target(\n+                            current_frame, target);\n+                        no_control_flow = false; break;\n+                    case Classfile.IF_ACMPEQ :\n+                    case Classfile.IF_ACMPNE :\n+                        current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        \/\/ fall through\n+                    case Classfile.IFNULL :\n+                    case Classfile.IFNONNULL :\n+                        current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        target = bcs.dest();\n+                        stackmap_table.check_jump_target\n+                            (current_frame, target);\n+                        no_control_flow = false; break;\n+                    case Classfile.GOTO :\n+                        target = bcs.dest();\n+                        stackmap_table.check_jump_target(\n+                            current_frame, target);\n+                        no_control_flow = true; break;\n+                    case Classfile.GOTO_W :\n+                        target = bcs.destW();\n+                        stackmap_table.check_jump_target(\n+                            current_frame, target);\n+                        no_control_flow = true; break;\n+                    case Classfile.TABLESWITCH :\n+                    case Classfile.LOOKUPSWITCH :\n+                        verify_switch(\n+                            bcs, code_length, code_data, current_frame,\n+                            stackmap_table);\n+                        no_control_flow = true; break;\n+                    case Classfile.IRETURN :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        verify_return_value(return_type, type, bci,\n+                                                                current_frame);\n+                        no_control_flow = true; break;\n+                    case Classfile.LRETURN :\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.long2_type);\n+                        type = current_frame.pop_stack(\n+                            VerificationType.long_type);\n+                        verify_return_value(return_type, type, bci,\n+                                                                current_frame);\n+                        no_control_flow = true; break;\n+                    case Classfile.FRETURN :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.float_type);\n+                        verify_return_value(return_type, type, bci,\n+                                                                current_frame);\n+                        no_control_flow = true; break;\n+                    case Classfile.DRETURN :\n+                        type2 = current_frame.pop_stack(\n+                            VerificationType.double2_type);\n+                        type = current_frame.pop_stack(\n+                            VerificationType.double_type);\n+                        verify_return_value(return_type, type, bci,\n+                                                                current_frame);\n+                        no_control_flow = true; break;\n+                    case Classfile.ARETURN :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        verify_return_value(return_type, type, bci,\n+                                                                current_frame);\n+                        no_control_flow = true; break;\n+                    case Classfile.RETURN:\n+                        if (!return_type.is_bogus()) {\n+                            verifyError(\"Method expects a return value\");\n+                        }\n+                        if (object_initializer_name.equals(_method.name()) &&\n+                                current_frame.flag_this_uninit()) {\n+                            verifyError(\"Constructor must call super() or this() before return\");\n+                        }\n+                        no_control_flow = true; break;\n+                    case Classfile.GETSTATIC :\n+                    case Classfile.PUTSTATIC :\n+                        verify_field_instructions(bcs, current_frame, cp, true);\n+                        no_control_flow = false; break;\n+                    case Classfile.GETFIELD :\n+                    case Classfile.PUTFIELD :\n+                        verify_field_instructions(bcs, current_frame, cp, false);\n+                        no_control_flow = false; break;\n+                    case Classfile.INVOKEVIRTUAL :\n+                    case Classfile.INVOKESPECIAL :\n+                    case Classfile.INVOKESTATIC :\n+                        this_uninit = verify_invoke_instructions(bcs, code_length, current_frame, (bci >= ex_minmax[0] && bci < ex_minmax[1]), this_uninit, return_type, cp, stackmap_table);\n+                        no_control_flow = false; break;\n+                    case Classfile.INVOKEINTERFACE :\n+                    case Classfile.INVOKEDYNAMIC :\n+                        this_uninit = verify_invoke_instructions(bcs, code_length, current_frame, (bci >= ex_minmax[0] && bci < ex_minmax[1]), this_uninit, return_type, cp, stackmap_table);\n+                        no_control_flow = false; break;\n+                    case Classfile.NEW :\n+                    {\n+                        index = bcs.getIndexU2();\n+                        verify_cp_class_type(bci, index, cp);\n+                        VerificationType new_class_type =\n+                            cp_index_to_type(index, cp);\n+                        if (!new_class_type.is_object()) {\n+                            verifyError(\"Illegal new instruction\");\n+                        }\n+                        type = VerificationType.uninitialized_type(bci);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.NEWARRAY :\n+                        type = get_newarray_type(bcs.getIndex(), bci);\n+                        current_frame.pop_stack(\n+                            VerificationType.integer_type);\n+                        current_frame.push_stack(type);\n+                        no_control_flow = false; break;\n+                    case Classfile.ANEWARRAY :\n+                        verify_anewarray(bci, bcs.getIndexU2(), cp, current_frame);\n+                        no_control_flow = false; break;\n+                    case Classfile.ARRAYLENGTH :\n+                        type = current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        if (!(type.is_null() || type.is_array())) {\n+                            verifyError(\"Bad type\");\n+                        }\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    case Classfile.CHECKCAST :\n+                    {\n+                        index = bcs.getIndexU2();\n+                        verify_cp_class_type(bci, index, cp);\n+                        current_frame.pop_stack(object_type());\n+                        VerificationType klass_type = cp_index_to_type(\n+                            index, cp);\n+                        current_frame.push_stack(klass_type);\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.INSTANCEOF : {\n+                        index = bcs.getIndexU2();\n+                        verify_cp_class_type(bci, index, cp);\n+                        current_frame.pop_stack(object_type());\n+                        current_frame.push_stack(\n+                            VerificationType.integer_type);\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.MONITORENTER :\n+                    case Classfile.MONITOREXIT :\n+                        current_frame.pop_stack(\n+                            VerificationType.reference_check);\n+                        no_control_flow = false; break;\n+                    case Classfile.MULTIANEWARRAY :\n+                    {\n+                        index = bcs.getIndexU2();\n+                        int dim = _method.codeArray()[bcs.bci+3] & 0xff;\n+                        verify_cp_class_type(bci, index, cp);\n+                        VerificationType new_array_type =\n+                            cp_index_to_type(index, cp);\n+                        if (!new_array_type.is_array()) {\n+                            verifyError(\"Illegal constant pool index in multianewarray instruction\");\n+                        }\n+                        if (dim < 1 || new_array_type.dimensions(this) < dim) {\n+                            verifyError(String.format(\"Illegal dimension in multianewarray instruction: %d\", dim));\n+                        }\n+                        for (int i = 0; i < dim; i++) {\n+                            current_frame.pop_stack(\n+                                VerificationType.integer_type);\n+                        }\n+                        current_frame.push_stack(new_array_type);\n+                        no_control_flow = false; break;\n+                    }\n+                    case Classfile.ATHROW :\n+                        type = VerificationType.reference_type(java_lang_Throwable);\n+                        current_frame.pop_stack(type);\n+                        no_control_flow = true; break;\n+                    default:\n+                        verifyError(String.format(\"Bad instruction: %02x\", opcode));\n+                }\n+            }\n+            if (verified_exc_handlers && this_uninit) verifyError(\"Exception handler targets got verified before this_uninit got set\");\n+            if (!verified_exc_handlers && bci >= ex_minmax[0] && bci < ex_minmax[1]) {\n+                verify_exception_handler_targets(bci, this_uninit, current_frame, stackmap_table);\n+            }\n+        }\n+        if (!no_control_flow) {\n+            verifyError(\"Control flow falls through code end\");\n+        }\n+    }\n+\n+    private byte[] generate_code_data(ByteBuffer code, int code_length) {\n+        byte code_data[] = new byte[code_length];\n+        var bcs = new RawBytecodeHelper(code);\n+        while (!bcs.isLastBytecode()) {\n+            if (bcs.rawNext() != ILLEGAL) {\n+                int bci = bcs.bci;\n+                if (bcs.rawCode == Classfile.NEW) {\n+                    code_data[bci] = NEW_OFFSET;\n+                } else {\n+                    code_data[bci] = BYTECODE_OFFSET;\n+                }\n+            } else {\n+                verifyError(\"Bad instruction\");\n+            }\n+        }\n+        return code_data;\n+    }\n+\n+    void verify_exception_handler_table(int code_length, byte[] code_data, int[] minmax) {\n+        var cp = _method.constantPool();\n+        for (var exhandler : _method.exceptionTable()) {\n+            int start_pc = exhandler[0];\n+            int end_pc = exhandler[1];\n+            int handler_pc = exhandler[2];\n+            if (start_pc >= code_length || code_data[start_pc] == 0) {\n+                classError(String.format(\"Illegal exception table start_pc %d\", start_pc));\n+            }\n+            if (end_pc != code_length) {\n+                if (end_pc > code_length || code_data[end_pc] == 0) {\n+                    classError(String.format(\"Illegal exception table end_pc %d\", end_pc));\n+                }\n+            }\n+            if (handler_pc >= code_length || code_data[handler_pc] == 0) {\n+                classError(String.format(\"Illegal exception table handler_pc %d\", handler_pc));\n+            }\n+            int catch_type_index = exhandler[3];\n+            if (catch_type_index != 0) {\n+                VerificationType catch_type = cp_index_to_type(catch_type_index, cp);\n+                VerificationType throwable = VerificationType.reference_type(java_lang_Throwable);\n+                boolean is_subclass = throwable.is_assignable_from(catch_type, this);\n+                if (!is_subclass) {\n+                    verifyError(String.format(\"Catch type is not a subclass of Throwable in exception handler %d\", handler_pc));\n+                }\n+            }\n+            if (start_pc < minmax[0]) minmax[0] = start_pc;\n+            if (end_pc > minmax[1]) minmax[1] = end_pc;\n+        }\n+    }\n+\n+    void verify_local_variable_table(int code_length, byte[] code_data) {\n+        for (var lvte : _method.localVariableTable()) {\n+            int start_bci = lvte.startPc();\n+            int length = lvte.length();\n+            if (start_bci >= code_length || code_data[start_bci] == 0) {\n+                classError(String.format(\"Illegal local variable table start_pc %d\", start_bci));\n+            }\n+            int end_bci = start_bci + length;\n+            if (end_bci != code_length) {\n+                if (end_bci >= code_length || code_data[end_bci] == 0) {\n+                    classError(String.format(\"Illegal local variable table length %d\", length));\n+                }\n+            }\n+        }\n+    }\n+\n+    int verify_stackmap_table(int stackmap_index, int bci, VerificationFrame current_frame, VerificationTable stackmap_table, boolean no_control_flow) {\n+        if (stackmap_index < stackmap_table.get_frame_count()) {\n+            int this_offset = stackmap_table.get_offset(stackmap_index);\n+            if (no_control_flow && this_offset > bci) {\n+                verifyError(\"Expecting a stack map frame\");\n+            }\n+            if (this_offset == bci) {\n+                boolean matches = stackmap_table.match_stackmap(current_frame, this_offset, stackmap_index, !no_control_flow, true);\n+                if (!matches) {\n+                    verifyError(\"Instruction type does not match stack map\");\n+                }\n+                stackmap_index++;\n+            } else if (this_offset < bci) {\n+                classError(String.format(\"Bad stack map offset %d\", this_offset));\n+            }\n+        } else if (no_control_flow) {\n+            verifyError(\"Expecting a stack map frame\");\n+        }\n+        return stackmap_index;\n+    }\n+\n+    void verify_exception_handler_targets(int bci, boolean this_uninit, VerificationFrame current_frame, VerificationTable stackmap_table) {\n+        var cp = _method.constantPool();\n+        for(var exhandler : _method.exceptionTable()) {\n+            int start_pc = exhandler[0];\n+            int end_pc = exhandler[1];\n+            int handler_pc = exhandler[2];\n+            int catch_type_index = exhandler[3];\n+            if(bci >= start_pc && bci < end_pc) {\n+                int flags = current_frame.flags();\n+                if (this_uninit) {    flags |= FLAG_THIS_UNINIT; }\n+                VerificationFrame new_frame = current_frame.frame_in_exception_handler(flags);\n+                if (catch_type_index != 0) {\n+                    VerificationType catch_type = cp_index_to_type(catch_type_index, cp);\n+                    new_frame.push_stack(catch_type);\n+                } else {\n+                    VerificationType throwable = VerificationType.reference_type(java_lang_Throwable);\n+                    new_frame.push_stack(throwable);\n+                }\n+                boolean matches = stackmap_table.match_stackmap(new_frame, handler_pc, true, false);\n+                if (!matches) {\n+                    verifyError(String.format(\"Stack map does not match the one at exception handler %d\", handler_pc));\n+                }\n+            }\n+        }\n+    }\n+\n+    void verify_cp_index(int bci, ConstantPoolWrapper cp, int index) {\n+        int nconstants = cp.entryCount();\n+        if ((index <= 0) || (index >= nconstants)) {\n+            verifyError(String.format(\"Illegal constant pool index %d\", index));\n+        }\n+    }\n+\n+    void verify_cp_type(int bci, int index, ConstantPoolWrapper cp, int types) {\n+        verify_cp_index(bci, cp, index);\n+        int tag = cp.tagAt(index);\n+        if ((types & (1 << tag))== 0) {\n+            verifyError(String.format(\"Illegal type at constant pool entry %d\", index));\n+        }\n+    }\n+\n+    void verify_cp_class_type(int bci, int index, ConstantPoolWrapper cp) {\n+        verify_cp_index(bci, cp, index);\n+        int tag = cp.tagAt(index);\n+        if (tag != JVM_CONSTANT_Class) {\n+            verifyError(String.format(\"Illegal type at constant pool entry %d\", index));\n+        }\n+    }\n+\n+    void verify_ldc(int opcode, int index, VerificationFrame current_frame, ConstantPoolWrapper cp, int bci) {\n+        verify_cp_index(bci, cp, index);\n+        int tag = cp.tagAt(index);\n+        int types = 0;\n+        if (opcode == Classfile.LDC || opcode == Classfile.LDC_W) {\n+            types = (1 << JVM_CONSTANT_Integer) | (1 << JVM_CONSTANT_Float)\n+                    | (1 << JVM_CONSTANT_String) | (1 << JVM_CONSTANT_Class)\n+                    | (1 << JVM_CONSTANT_MethodHandle) | (1 << JVM_CONSTANT_MethodType)\n+                    | (1 << JVM_CONSTANT_Dynamic);\n+            verify_cp_type(bci, index, cp, types);\n+        } else {\n+            if (opcode != Classfile.LDC2_W) verifyError(\"must be ldc2_w\");\n+            types = (1 << JVM_CONSTANT_Double) | (1 << JVM_CONSTANT_Long) | (1 << JVM_CONSTANT_Dynamic);\n+            verify_cp_type(bci, index, cp, types);\n+        }\n+        switch (tag) {\n+            case JVM_CONSTANT_Utf8 -> current_frame.push_stack(object_type());\n+            case JVM_CONSTANT_String -> current_frame.push_stack(VerificationType.reference_type(java_lang_String));\n+            case JVM_CONSTANT_Class -> current_frame.push_stack(VerificationType.reference_type(java_lang_Class));\n+            case JVM_CONSTANT_Integer -> current_frame.push_stack(VerificationType.integer_type);\n+            case JVM_CONSTANT_Float -> current_frame.push_stack(VerificationType.float_type);\n+            case JVM_CONSTANT_Double -> current_frame.push_stack_2(VerificationType.double_type, VerificationType.double2_type);\n+            case JVM_CONSTANT_Long -> current_frame.push_stack_2(VerificationType.long_type, VerificationType.long2_type);\n+            case JVM_CONSTANT_MethodHandle -> current_frame.push_stack(VerificationType.reference_type(java_lang_invoke_MethodHandle));\n+            case JVM_CONSTANT_MethodType -> current_frame.push_stack(VerificationType.reference_type(java_lang_invoke_MethodType));\n+            case JVM_CONSTANT_Dynamic -> {\n+                String constant_type = cp.dynamicConstantSignatureAt(index);\n+                if (!VerificationSignature.isValidTypeSignature(constant_type)) verifyError(\"Invalid type for dynamic constant\");\n+                VerificationType[] v_constant_type = new VerificationType[2];\n+                var sig_stream = new VerificationSignature(constant_type, false, this);\n+                int n = change_sig_to_verificationType(sig_stream, v_constant_type, 0);\n+                int opcode_n = (opcode == Classfile.LDC2_W ? 2 : 1);\n+                if (n != opcode_n) {\n+                    types &= ~(1 << JVM_CONSTANT_Dynamic);\n+                    verify_cp_type(bci, index, cp, types);\n+                }\n+                for (int i = 0; i < n; i++) {\n+                    current_frame.push_stack(v_constant_type[i]);\n+                }\n+            }\n+            default -> verifyError(\"Invalid index in ldc\");\n+        }\n+    }\n+\n+    void verify_switch(RawBytecodeHelper bcs, int code_length, byte[] code_data, VerificationFrame current_frame, VerificationTable stackmap_table) {\n+        int bci = bcs.bci;\n+        int aligned_bci = VerificationBytecodes.align(bci + 1);\n+        \/\/ 4639449 & 4647081: padding bytes must be 0\n+        if (_klass.majorVersion() < NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION) {\n+            int padding_offset = 1;\n+            while ((bci + padding_offset) < aligned_bci) {\n+                if (_method.codeArray()[bci + padding_offset] != 0) {\n+                    verifyError(\"Nonzero padding byte in lookupswitch or tableswitch\");\n+                }\n+                padding_offset++;\n+            }\n+        }\n+        int default_ofset = bcs.getInt(aligned_bci);\n+        int keys, delta;\n+        current_frame.pop_stack(VerificationType.integer_type);\n+        if (bcs.rawCode == Classfile.TABLESWITCH) {\n+            int low = bcs.getInt(aligned_bci + 4);\n+            int high = bcs.getInt(aligned_bci + 2*4);\n+            if (low > high) {\n+                verifyError(\"low must be less than or equal to high in tableswitch\");\n+            }\n+            keys = high - low + 1;\n+            if (keys < 0) {\n+                verifyError(\"too many keys in tableswitch\");\n+            }\n+            delta = 1;\n+        } else {\n+            \/\/ Make sure that the lookupswitch items are sorted\n+            keys = bcs.getInt(aligned_bci + 4);\n+            if (keys < 0) {\n+                verifyError(\"number of keys in lookupswitch less than 0\");\n+            }\n+            delta = 2;\n+            for (int i = 0; i < (keys - 1); i++) {\n+                int this_key = bcs.getInt(aligned_bci + (2+2*i)*4);\n+                int next_key = bcs.getInt(aligned_bci + (2+2*i+2)*4);\n+                if (this_key >= next_key) {\n+                    verifyError(\"Bad lookupswitch instruction\");\n+                }\n+            }\n+        }\n+        int target = bci + default_ofset;\n+        stackmap_table.check_jump_target(current_frame, target);\n+        for (int i = 0; i < keys; i++) {\n+            aligned_bci = VerificationBytecodes.align(bcs.bci + 1);\n+            target = bci + bcs.getInt(aligned_bci + (3+i*delta)*4);\n+            stackmap_table.check_jump_target(current_frame, target);\n+        }\n+    }\n+\n+    void verify_field_instructions(RawBytecodeHelper bcs, VerificationFrame current_frame, ConstantPoolWrapper cp, boolean allow_arrays) {\n+        int index = bcs.getIndexU2();\n+        verify_cp_type(bcs.bci, index, cp, 1 << JVM_CONSTANT_Fieldref);\n+        String field_name = cp.refNameAt(index);\n+        String field_sig = cp.refSignatureAt(index);\n+        if (!VerificationSignature.isValidTypeSignature(field_sig)) verifyError(\"Invalid field signature\");\n+        VerificationType ref_class_type = cp_ref_index_to_type(index, cp);\n+        if (!ref_class_type.is_object() &&\n+            (!allow_arrays || !ref_class_type.is_array())) {\n+            verifyError(String.format(\"Expecting reference to class in class %s at constant pool index %d\", _klass.thisClassName(), index));\n+        }\n+        VerificationType target_class_type = ref_class_type;\n+        VerificationType[] field_type = new VerificationType[2];\n+        var sig_stream = new VerificationSignature(field_sig, false, this);\n+        VerificationType stack_object_type = null;\n+        int n = change_sig_to_verificationType(sig_stream, field_type, 0);\n+        int bci = bcs.bci;\n+        boolean is_assignable;\n+        switch (bcs.rawCode) {\n+            case Classfile.GETSTATIC: {\n+                for (int i = 0; i < n; i++) {\n+                    current_frame.push_stack(field_type[i]);\n+                }\n+                break;\n+            }\n+            case Classfile.PUTSTATIC: {\n+                for (int i = n - 1; i >= 0; i--) {\n+                    current_frame.pop_stack(field_type[i]);\n+                }\n+                break;\n+            }\n+            case Classfile.GETFIELD: {\n+                stack_object_type = current_frame.pop_stack(\n+                    target_class_type);\n+                for (int i = 0; i < n; i++) {\n+                    current_frame.push_stack(field_type[i]);\n+                }\n+                break;\n+            }\n+            case Classfile.PUTFIELD: {\n+                for (int i = n - 1; i >= 0; i--) {\n+                    current_frame.pop_stack(field_type[i]);\n+                }\n+                stack_object_type = current_frame.pop_stack();\n+                if (stack_object_type.is_uninitialized_this(this) &&\n+                        target_class_type.equals(current_type()) &&\n+                        _klass.findField(field_name, field_sig)) {\n+                    stack_object_type = current_type();\n+                }\n+                is_assignable = target_class_type.is_assignable_from(stack_object_type, this);\n+                if (!is_assignable) {\n+                    verifyError(\"Bad type on operand stack in putfield\");\n+                }\n+                break;\n+            }\n+            default: verifyError(\"Should not reach here\");\n+        }\n+    }\n+\n+    \/\/ Return TRUE if all code paths starting with start_bc_offset end in\n+    \/\/ bytecode athrow or loop.\n+    boolean ends_in_athrow(int start_bc_offset) {\n+        log_info(\"unimplemented VerifierImpl.ends_in_athrow\");\n+        return true;\n+    }\n+\n+    boolean verify_invoke_init(RawBytecodeHelper bcs, int ref_class_index, VerificationType ref_class_type,\n+            VerificationFrame current_frame, int code_length, boolean in_try_block,\n+            boolean this_uninit, ConstantPoolWrapper cp, VerificationTable stackmap_table) {\n+        int bci = bcs.bci;\n+        VerificationType type = current_frame.pop_stack(VerificationType.reference_check);\n+        if (type.is_uninitialized_this(this)) {\n+            String superk_name = current_class().superclassName();\n+            if (!current_class().thisClassName().equals(ref_class_type.name()) &&\n+                    !superk_name.equals(ref_class_type.name())) {\n+                verifyError(\"Bad <init> method call\");\n+            }\n+            if (in_try_block) {\n+                for(var exhandler : _method.exceptionTable()) {\n+                    int start_pc = exhandler[0];\n+                    int end_pc = exhandler[1];\n+\n+                    if (bci >= start_pc && bci < end_pc) {\n+                        if (!ends_in_athrow(exhandler[2])) {\n+                            verifyError(\"Bad <init> method call from after the start of a try block\");\n+                        }\n+                    }\n+                }\n+                verify_exception_handler_targets(bci, true, current_frame, stackmap_table);\n+            }\n+            current_frame.initialize_object(type, current_type());\n+            this_uninit = true;\n+        } else if (type.is_uninitialized()) {\n+            int new_offset = type.bci(this);\n+            if (new_offset > (code_length - 3) || (_method.codeArray()[new_offset] & 0xff) != Classfile.NEW) {\n+                verifyError(\"Expecting new instruction\");\n+            }\n+            int new_class_index = bcs.getIndexU2Raw(new_offset + 1);\n+            verify_cp_class_type(bci, new_class_index, cp);\n+            VerificationType new_class_type = cp_index_to_type(\n+                new_class_index, cp);\n+            if (!new_class_type.equals(ref_class_type)) {\n+                verifyError(\"Call to wrong <init> method\");\n+            }\n+            if (in_try_block) {\n+                verify_exception_handler_targets(bci, this_uninit, current_frame,\n+                                                                                 stackmap_table);\n+            }\n+            current_frame.initialize_object(type, new_class_type);\n+        } else {\n+            verifyError(\"Bad operand type when invoking <init>\");\n+        }\n+        return this_uninit;\n+    }\n+\n+    static boolean is_same_or_direct_interface(VerificationWrapper klass, VerificationType klass_type, VerificationType ref_class_type) {\n+        if (ref_class_type.equals(klass_type)) return true;\n+        for (String k_name : klass.interfaceNames()) {\n+            if (ref_class_type.equals(VerificationType.reference_type(k_name))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    boolean verify_invoke_instructions(RawBytecodeHelper bcs, int code_length, VerificationFrame current_frame, boolean in_try_block, boolean this_uninit, VerificationType return_type, ConstantPoolWrapper cp, VerificationTable stackmap_table) {\n+        \/\/ Make sure the constant pool item is the right type\n+        int index = bcs.getIndexU2();\n+        int opcode = bcs.rawCode;\n+        int types = 0;\n+        switch (opcode) {\n+            case Classfile.INVOKEINTERFACE:\n+                types = 1 << JVM_CONSTANT_InterfaceMethodref;\n+                break;\n+            case Classfile.INVOKEDYNAMIC:\n+                types = 1 << JVM_CONSTANT_InvokeDynamic;\n+                break;\n+            case Classfile.INVOKESPECIAL:\n+            case Classfile.INVOKESTATIC:\n+                types = (_klass.majorVersion() < STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION) ?\n+                    (1 << JVM_CONSTANT_Methodref) :\n+                    ((1 << JVM_CONSTANT_InterfaceMethodref) | (1 << JVM_CONSTANT_Methodref));\n+                break;\n+            default:\n+                types = 1 << JVM_CONSTANT_Methodref;\n+        }\n+        verify_cp_type(bcs.bci, index, cp, types);\n+        String method_name = cp.refNameAt(index);\n+        String method_sig = cp.refSignatureAt(index);\n+        if (!VerificationSignature.isValidMethodSignature(method_sig)) verifyError(\"Invalid method signature\");\n+        VerificationType ref_class_type = null;\n+        if (opcode == Classfile.INVOKEDYNAMIC) {\n+            if (_klass.majorVersion() < INVOKEDYNAMIC_MAJOR_VERSION) {\n+                classError(String.format(\"invokedynamic instructions not supported by this class file version (%d), class %s\", _klass.majorVersion(), _klass.thisClassName()));\n+            }\n+        } else {\n+            ref_class_type = cp_ref_index_to_type(index, cp);\n+        }\n+        String sig = cp.refSignatureAt(index);\n+        sig_as_verification_types mth_sig_verif_types;\n+        ArrayList<VerificationType> verif_types = new ArrayList<>(10);\n+        mth_sig_verif_types = new sig_as_verification_types(verif_types);\n+        create_method_sig_entry(mth_sig_verif_types, sig);\n+        int nargs = mth_sig_verif_types.num_args();\n+        int bci = bcs.bci;\n+        if (opcode == Classfile.INVOKEINTERFACE) {\n+            if ((_method.codeArray()[bci+3] & 0xff) != (nargs+1)) {\n+                verifyError(\"Inconsistent args count operand in invokeinterface\");\n+            }\n+            if ((_method.codeArray()[bci+4] & 0xff) != 0) {\n+                verifyError(\"Fourth operand byte of invokeinterface must be zero\");\n+            }\n+        }\n+        if (opcode == Classfile.INVOKEDYNAMIC) {\n+            if ((_method.codeArray()[bci+3] & 0xff) != 0 || (_method.codeArray()[bci+4] & 0xff) != 0) {\n+                verifyError(\"Third and fourth operand bytes of invokedynamic must be zero\");\n+            }\n+        }\n+        if (method_name.charAt(0) == JVM_SIGNATURE_SPECIAL) {\n+            if (opcode != Classfile.INVOKESPECIAL ||\n+                !object_initializer_name.equals(method_name)) {\n+                verifyError(\"Illegal call to internal method\");\n+            }\n+        } else if (opcode == Classfile.INVOKESPECIAL\n+                             && !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)\n+                             && !ref_class_type.equals(VerificationType.reference_type(\n+                                        current_class().superclassName()))) {\n+            boolean subtype = false;\n+            boolean have_imr_indirect = cp.tagAt(index) == JVM_CONSTANT_InterfaceMethodref;\n+            subtype = ref_class_type.is_assignable_from(current_type(), this);\n+            if (!subtype) {\n+                verifyError(\"Bad invokespecial instruction: current class isn't assignable to reference class.\");\n+            } else if (have_imr_indirect) {\n+                verifyError(\"Bad invokespecial instruction: interface method reference is in an indirect superinterface.\");\n+            }\n+\n+        }\n+        ArrayList<VerificationType> sig_verif_types = mth_sig_verif_types.sig_verif_types();\n+        if (sig_verif_types == null) verifyError(\"Missing signature's array of verification types\");\n+        for (int i = nargs - 1; i >= 0; i--) { \/\/ Run backwards\n+            current_frame.pop_stack(sig_verif_types.get(i));\n+        }\n+        if (opcode != Classfile.INVOKESTATIC &&\n+            opcode != Classfile.INVOKEDYNAMIC) {\n+            if (object_initializer_name.equals(method_name)) {    \/\/ <init> method\n+                this_uninit = verify_invoke_init(bcs, index, ref_class_type, current_frame,\n+                    code_length, in_try_block, this_uninit, cp, stackmap_table);\n+            } else {\n+                if (opcode == Classfile.INVOKESPECIAL) {\n+                        current_frame.pop_stack(current_type());\n+                } else if (opcode == Classfile.INVOKEVIRTUAL) {\n+                    VerificationType stack_object_type =\n+                        current_frame.pop_stack(ref_class_type);\n+                    if (current_type() != stack_object_type) {\n+                        String ref_class_name =\n+                            cp.classNameAt(cp.refClassIndexAt(index));\n+                    }\n+                } else {\n+                    if (opcode != Classfile.INVOKEINTERFACE) verifyError(\"Unexpected opcode encountered\");\n+                    current_frame.pop_stack(ref_class_type);\n+                }\n+            }\n+        }\n+        int sig_verif_types_len = sig_verif_types.size();\n+        if (sig_verif_types_len > nargs) {    \/\/ There's a return type\n+            if (object_initializer_name.equals(method_name)) {\n+                verifyError(\"Return type must be void in <init> method\");\n+            }\n+\n+            if (sig_verif_types_len > nargs + 2) verifyError(\"Signature verification types array return type is bogus\");\n+            for (int i = nargs; i < sig_verif_types_len; i++) {\n+                if (!(i == nargs || sig_verif_types.get(i).is_long2() || sig_verif_types.get(i).is_double2())) verifyError(\"Unexpected return verificationType\");\n+                current_frame.push_stack(sig_verif_types.get(i));\n+            }\n+        }\n+        return this_uninit;\n+    }\n+\n+    VerificationType get_newarray_type(int index, int bci) {\n+        String[] from_bt = new String[] {\n+            null, null, null, null, \"[Z\", \"[C\", \"[F\", \"[D\", \"[B\", \"[S\", \"[I\", \"[J\",\n+        };\n+        if (index < T_BOOLEAN.type || index > T_LONG.type) {\n+            verifyError(\"Illegal newarray instruction\");\n+        }\n+        String sig = from_bt[index];\n+        return VerificationType.reference_type(sig);\n+    }\n+\n+    void verify_anewarray(int bci, int index, ConstantPoolWrapper cp, VerificationFrame current_frame) {\n+        verify_cp_class_type(bci, index, cp);\n+        current_frame.pop_stack(VerificationType.integer_type);\n+        VerificationType component_type = cp_index_to_type(index, cp);\n+        int length;\n+        String arr_sig_str;\n+        if (component_type.is_array()) {         \/\/ it's an array\n+            String component_name = component_type.name();\n+            length = component_name.length();\n+            if (length > MAX_ARRAY_DIMENSIONS &&\n+                    component_name.charAt(MAX_ARRAY_DIMENSIONS - 1) == JVM_SIGNATURE_ARRAY) {\n+                verifyError(\"Illegal anewarray instruction, array has more than 255 dimensions\");\n+            }\n+            length++;\n+            arr_sig_str = String.format(\"%c%s\", JVM_SIGNATURE_ARRAY, component_name);\n+            if (arr_sig_str.length() != length) verifyError(\"Unexpected number of characters in string\");\n+        } else {                 \/\/ it's an object or interface\n+            String component_name = component_type.name();\n+            length = component_name.length() + 3;\n+            arr_sig_str = String.format(\"%c%c%s;\", JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);\n+            if (arr_sig_str.length() != length) verifyError(\"Unexpected number of characters in string\");\n+        }\n+        VerificationType new_array_type = VerificationType.reference_type(arr_sig_str);\n+        current_frame.push_stack(new_array_type);\n+    }\n+\n+    void verify_iload(int index, VerificationFrame current_frame) {\n+        current_frame.get_local(\n+            index, VerificationType.integer_type);\n+        current_frame.push_stack(\n+            VerificationType.integer_type);\n+    }\n+\n+    void verify_lload(int index, VerificationFrame current_frame) {\n+        current_frame.get_local_2(\n+            index, VerificationType.long_type,\n+            VerificationType.long2_type);\n+        current_frame.push_stack_2(\n+            VerificationType.long_type,\n+            VerificationType.long2_type);\n+    }\n+\n+    void verify_fload(int index, VerificationFrame current_frame) {\n+        current_frame.get_local(\n+            index, VerificationType.float_type);\n+        current_frame.push_stack(\n+            VerificationType.float_type);\n+    }\n+\n+    void verify_dload(int index, VerificationFrame current_frame) {\n+        current_frame.get_local_2(\n+            index, VerificationType.double_type,\n+            VerificationType.double2_type);\n+        current_frame.push_stack_2(\n+            VerificationType.double_type,\n+            VerificationType.double2_type);\n+    }\n+\n+    void verify_aload(int index, VerificationFrame current_frame) {\n+        VerificationType type = current_frame.get_local(\n+            index, VerificationType.reference_check);\n+        current_frame.push_stack(type);\n+    }\n+\n+    void verify_istore(int index, VerificationFrame current_frame) {\n+        current_frame.pop_stack(\n+            VerificationType.integer_type);\n+        current_frame.set_local(\n+            index, VerificationType.integer_type);\n+    }\n+\n+    void verify_lstore(int index, VerificationFrame current_frame) {\n+        current_frame.pop_stack_2(\n+            VerificationType.long2_type,\n+            VerificationType.long_type);\n+        current_frame.set_local_2(\n+            index, VerificationType.long_type,\n+            VerificationType.long2_type);\n+    }\n+\n+    void verify_fstore(int index, VerificationFrame current_frame) {\n+        current_frame.pop_stack(\n+            VerificationType.float_type);\n+        current_frame.set_local(\n+            index, VerificationType.float_type);\n+    }\n+\n+    void verify_dstore(int index, VerificationFrame current_frame) {\n+        current_frame.pop_stack_2(\n+            VerificationType.double2_type,\n+            VerificationType.double_type);\n+        current_frame.set_local_2(\n+            index, VerificationType.double_type,\n+            VerificationType.double2_type);\n+    }\n+\n+    void verify_astore(int index, VerificationFrame current_frame) {\n+        VerificationType type = current_frame.pop_stack(\n+            VerificationType.reference_check);\n+        current_frame.set_local(index, type);\n+    }\n+\n+    void verify_iinc(int index, VerificationFrame current_frame) {\n+        VerificationType type = current_frame.get_local(\n+            index, VerificationType.integer_type);\n+        current_frame.set_local(index, type);\n+    }\n+\n+    void verify_return_value(VerificationType return_type, VerificationType type, int bci, VerificationFrame current_frame) {\n+        if (return_type.is_bogus()) {\n+            verifyError(\"Method expects a return value\");\n+        }\n+        boolean match = return_type.is_assignable_from(type, this);\n+        if (!match) {\n+            verifyError(\"Bad return type\");\n+        }\n+    }\n+\n+    private void dumpMethod() {\n+        if (_logger != null) ClassPrinter.toTree(_method.m, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES).toYaml(_logger);\n+    }\n+\n+    void verifyError(String msg) {\n+        dumpMethod();\n+        throw new VerifyError(String.format(\"%s at %s.%s%s @%d %s\", msg, _klass.thisClassName(), _method.name(), _method.descriptor(), bci, errorContext));\n+    }\n+\n+    void verifyError(String msg, VerificationFrame from, VerificationFrame target) {\n+        dumpMethod();\n+        throw new VerifyError(String.format(\"%s at %s.%s%s @%d %s%n  while assigning %s%n  to %s\", msg, _klass.thisClassName(), _method.name(), _method.descriptor(), bci, errorContext, from, target));\n+    }\n+\n+    void classError(String msg) {\n+        dumpMethod();\n+        throw new ClassFormatError(String.format(\"%s at %s.%s%s\", msg, _klass.thisClassName(), _method.name(), _method.descriptor()));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":1846,"deletions":0,"binary":false,"changes":1846,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models an array load instruction in the {@code code} array of a {@code Code}\n+ * attribute.  Corresponding opcodes will have a {@code kind} of {@link\n+ * Opcode.Kind#ARRAY_LOAD}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface ArrayLoadInstruction extends Instruction\n+        permits AbstractInstruction.UnboundArrayLoadInstruction {\n+    \/**\n+     * {@return the component type of the array}\n+     *\/\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return an array load instruction}\n+     *\n+     * @param op the opcode for the specific type of array load instruction,\n+     *           which must be of kind {@link Opcode.Kind#ARRAY_LOAD}\n+     *\/\n+    static ArrayLoadInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.ARRAY_LOAD);\n+        return new AbstractInstruction.UnboundArrayLoadInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ArrayLoadInstruction.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models an array store instruction in the {@code code} array of a {@code Code}\n+ * attribute.  Corresponding opcodes will have a {@code kind} of {@link\n+ * Opcode.Kind#ARRAY_STORE}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface ArrayStoreInstruction extends Instruction\n+        permits AbstractInstruction.UnboundArrayStoreInstruction {\n+    \/**\n+     * {@return the component type of the array}\n+     *\/\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return an array store instruction}\n+     *\n+     * @param op the opcode for the specific type of array store instruction,\n+     *           which must be of kind {@link Opcode.Kind#ARRAY_STORE}\n+     *\/\n+    static ArrayStoreInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.ARRAY_STORE);\n+        return new AbstractInstruction.UnboundArrayStoreInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ArrayStoreInstruction.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a branching instruction (conditional or unconditional) in the {@code\n+ * code} array of a {@code Code} attribute.  Corresponding opcodes will have a\n+ * {@code kind} of {@link Opcode.Kind#BRANCH}.  Delivered as a {@link\n+ * CodeElement} when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface BranchInstruction extends Instruction\n+        permits AbstractInstruction.BoundBranchInstruction,\n+                AbstractInstruction.UnboundBranchInstruction {\n+    \/**\n+     * {@return the target of the branch}\n+     *\/\n+    Label target();\n+\n+    \/**\n+     * {@return a branch instruction}\n+     *\n+     * @param op the opcode for the specific type of branch instruction,\n+     *           which must be of kind {@link Opcode.Kind#BRANCH}\n+     *\/\n+    static BranchInstruction of(Opcode op, Label target) {\n+        Util.checkKind(op, Opcode.Kind.BRANCH);\n+        return new AbstractInstruction.UnboundBranchInstruction(op, target);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/BranchInstruction.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.PseudoInstruction;\n+import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+import jdk.internal.classfile.impl.BoundCharacterRange;\n+\n+\/**\n+ * A pseudo-instruction which models a single entry in the\n+ * {@link CharacterRangeTableAttribute}.  Delivered as a {@link CodeElement}\n+ * during traversal of the elements of a {@link CodeModel}, according to\n+ * the setting of the {@link Classfile.Option#processDebug(boolean)} option.\n+ *\/\n+public sealed interface CharacterRange extends PseudoInstruction\n+        permits AbstractPseudoInstruction.UnboundCharacterRange, BoundCharacterRange {\n+    \/**\n+     * {@return the start of the instruction range}\n+     *\/\n+    Label startScope();\n+\n+    \/**\n+     * {@return the end of the instruction range}\n+     *\/\n+    Label endScope();\n+\n+    \/**\n+     * {@return the encoded start of the character range region (inclusive)}\n+     * The value is constructed from the line_number\/column_number pair as given\n+     * by {@code line_number << 10 + column_number}, where the source file is\n+     * viewed as an array of (possibly multi-byte) characters.\n+     *\/\n+    int characterRangeStart();\n+\n+    \/**\n+     * {@return the encoded end of the character range region (exclusive)}.\n+     * The value is constructed from the line_number\/column_number pair as given\n+     * by {@code line_number << 10 + column_number}, where the source file is\n+     * viewed as an array of (possibly multi-byte) characters.\n+     *\/\n+    int characterRangeEnd();\n+\n+    \/**\n+     * A flags word, indicating the kind of range.  Multiple flag bits\n+     * may be set.  Valid flags include\n+     * {@link jdk.internal.classfile.Classfile#CRT_STATEMENT},\n+     * {@link jdk.internal.classfile.Classfile#CRT_BLOCK},\n+     * {@link jdk.internal.classfile.Classfile#CRT_ASSIGNMENT},\n+     * {@link jdk.internal.classfile.Classfile#CRT_FLOW_CONTROLLER},\n+     * {@link jdk.internal.classfile.Classfile#CRT_FLOW_TARGET},\n+     * {@link jdk.internal.classfile.Classfile#CRT_INVOKE},\n+     * {@link jdk.internal.classfile.Classfile#CRT_CREATE},\n+     * {@link jdk.internal.classfile.Classfile#CRT_BRANCH_TRUE},\n+     * {@link jdk.internal.classfile.Classfile#CRT_BRANCH_FALSE}.\n+     *\n+     * @see jdk.internal.classfile.attribute.CharacterRangeInfo#flags()\n+     *\n+     * @return the flags\n+     *\/\n+    int flags();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/CharacterRange.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.lang.constant.ConstantDesc;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a constant-load instruction in the {@code code} array of a {@code\n+ * Code} attribute, including \"intrinsic constant\" instructions (e.g., {@code\n+ * aload_0}), \"argument constant\" instructions (e.g., {@code bipush}), and \"load\n+ * constant\" instructions (e.g., {@code LDC}).  Corresponding opcodes will have\n+ * a {@code kind} of {@link Opcode.Kind#CONSTANT}.  Delivered as a {@link\n+ * CodeElement} when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface ConstantInstruction extends Instruction {\n+\n+    \/**\n+     * {@return the constant value}\n+     *\/\n+    ConstantDesc constantValue();\n+\n+    \/**\n+     * {@return the type of the constant}\n+     *\/\n+    TypeKind typeKind();\n+\n+    \/**\n+     * Models an \"intrinsic constant\" instruction (e.g., {@code\n+     * aload_0}).\n+     *\/\n+    sealed interface IntrinsicConstantInstruction extends ConstantInstruction\n+            permits AbstractInstruction.UnboundIntrinsicConstantInstruction {\n+\n+        \/**\n+         * {@return the type of the constant}\n+         *\/\n+        default TypeKind typeKind() {\n+            return opcode().primaryTypeKind();\n+        }\n+    }\n+\n+    \/**\n+     * Models an \"argument constant\" instruction (e.g., {@code\n+     * bipush}).\n+     *\/\n+    sealed interface ArgumentConstantInstruction extends ConstantInstruction\n+            permits AbstractInstruction.BoundArgumentConstantInstruction,\n+                    AbstractInstruction.UnboundArgumentConstantInstruction {\n+\n+        @Override\n+        Integer constantValue();\n+\n+        \/**\n+         * {@return the type of the constant}\n+         *\/\n+        default TypeKind typeKind() {\n+            return opcode().primaryTypeKind();\n+        }\n+    }\n+\n+    \/**\n+     * Models a \"load constant\" instruction (e.g., {@code\n+     * ldc}).\n+     *\/\n+    sealed interface LoadConstantInstruction extends ConstantInstruction\n+            permits AbstractInstruction.BoundLoadConstantInstruction,\n+                    AbstractInstruction.UnboundLoadConstantInstruction {\n+\n+        \/**\n+         * {@return the constant value}\n+         *\/\n+        LoadableConstantEntry constantEntry();\n+\n+        \/**\n+         * {@return the type of the constant}\n+         *\/\n+        default TypeKind typeKind() {\n+            return constantEntry().typeKind();\n+        }\n+    }\n+\n+    \/**\n+     * {@return an intrinsic constant instruction}\n+     *\n+     * @param op the opcode for the specific type of intrinsic constant instruction,\n+     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n+     *\/\n+    static IntrinsicConstantInstruction ofIntrinsic(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.CONSTANT);\n+        if (op.constantValue() == null)\n+            throw new IllegalArgumentException(String.format(\"Wrong opcode specified; found %s, expected xCONST_val\", op));\n+        return new AbstractInstruction.UnboundIntrinsicConstantInstruction(op);\n+    }\n+\n+    \/**\n+     * {@return an argument constant instruction}\n+     *\n+     * @param op the opcode for the specific type of intrinsic constant instruction,\n+     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n+     * @param value the constant value\n+     *\/\n+    static ArgumentConstantInstruction ofArgument(Opcode op, int value) {\n+        Util.checkKind(op, Opcode.Kind.CONSTANT);\n+        if (op != Opcode.BIPUSH && op != Opcode.SIPUSH)\n+            throw new IllegalArgumentException(String.format(\"Wrong opcode specified; found %s, expected BIPUSH or SIPUSH\", op, op.kind()));\n+        return new AbstractInstruction.UnboundArgumentConstantInstruction(op, value);\n+    }\n+\n+    \/**\n+     * {@return a load constant instruction}\n+     *\n+     * @param op the opcode for the specific type of load constant instruction,\n+     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n+     * @param constant the constant value\n+     *\/\n+    static LoadConstantInstruction ofLoad(Opcode op, LoadableConstantEntry constant) {\n+        Util.checkKind(op, Opcode.Kind.CONSTANT);\n+        if (op != Opcode.LDC && op != Opcode.LDC_W && op != Opcode.LDC2_W)\n+            throw new IllegalArgumentException(String.format(\"Wrong opcode specified; found %s, expected LDC, LDC_W or LDC2_W\", op, op.kind()));\n+        return new AbstractInstruction.UnboundLoadConstantInstruction(op, constant);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ConstantInstruction.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a primitive conversion instruction in the {@code code} array of a\n+ * {@code Code} attribute, such as {@code i2l}.  Corresponding opcodes will have\n+ * a {@code kind} of {@link Opcode.Kind#CONVERT}.  Delivered as a {@link\n+ * CodeElement} when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface ConvertInstruction extends Instruction\n+        permits AbstractInstruction.UnboundConvertInstruction {\n+    \/**\n+     * {@return the source type to convert from}\n+     *\/\n+    TypeKind fromType();\n+\n+    \/**\n+     * {@return the destination type to convert to}\n+     *\/\n+    TypeKind toType();\n+\n+    \/**\n+     * {@return A conversion instruction}\n+     *\n+     * @param fromType the type to convert from\n+     * @param toType the type to convert to\n+     *\/\n+    static ConvertInstruction of(TypeKind fromType, TypeKind toType) {\n+        return of(BytecodeHelpers.convertOpcode(fromType, toType));\n+    }\n+\n+    \/**\n+     * {@return a conversion instruction}\n+     *\n+     * @param op the opcode for the specific type of conversion instruction,\n+     *           which must be of kind {@link Opcode.Kind#CONVERT}\n+     *\/\n+    static ConvertInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.CONVERT);\n+        return new AbstractInstruction.UnboundConvertInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ConvertInstruction.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.PseudoInstruction;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+\n+\/**\n+ * A pseudo-instruction modeling an entry in the exception table of a code\n+ * attribute.  Entries in the exception table model catch and finally blocks.\n+ * Delivered as a {@link CodeElement} when traversing the contents\n+ * of a {@link CodeModel}.\n+ *\n+ * @see PseudoInstruction\n+ *\/\n+public sealed interface ExceptionCatch extends PseudoInstruction\n+        permits AbstractPseudoInstruction.ExceptionCatchImpl {\n+    \/**\n+     * {@return the handler for the exception}\n+     *\/\n+    Label handler();\n+\n+    \/**\n+     * {@return the beginning of the instruction range for the guarded instructions}\n+     *\/\n+    Label tryStart();\n+\n+    \/**\n+     * {@return the end of the instruction range for the guarded instructions}\n+     *\/\n+    Label tryEnd();\n+\n+    \/**\n+     * {@return the type of the exception to catch, or empty if this handler is\n+     * unconditional}\n+     *\/\n+    Optional<ClassEntry> catchType();\n+\n+    \/**\n+     * {@return an exception table pseudo-instruction}\n+     * @param handler the handler for the exception\n+     * @param tryStart the beginning of the instruction range for the gaurded instructions\n+     * @param tryEnd the end of the instruction range for the gaurded instructions\n+     * @param catchTypeEntry the type of exception to catch, or empty if this\n+     *                       handler is unconditional\n+     *\/\n+    static ExceptionCatch of(Label handler, Label tryStart, Label tryEnd,\n+                             Optional<ClassEntry> catchTypeEntry) {\n+        return new AbstractPseudoInstruction.ExceptionCatchImpl(handler, tryStart, tryEnd, catchTypeEntry);\n+    }\n+\n+    \/**\n+     * {@return an exception table pseudo-instruction for an unconditional handler}\n+     * @param handler the handler for the exception\n+     * @param tryStart the beginning of the instruction range for the gaurded instructions\n+     * @param tryEnd the end of the instruction range for the gaurded instructions\n+     *\/\n+    static ExceptionCatch of(Label handler, Label tryStart, Label tryEnd) {\n+        return new AbstractPseudoInstruction.ExceptionCatchImpl(handler, tryStart, tryEnd, (ClassEntry) null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ExceptionCatch.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.lang.constant.ClassDesc;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a field access instruction in the {@code code} array of a {@code Code}\n+ * attribute.  Corresponding opcodes will have a {@code kind} of {@link\n+ * Opcode.Kind#FIELD_ACCESS}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface FieldInstruction extends Instruction\n+        permits AbstractInstruction.BoundFieldInstruction, AbstractInstruction.UnboundFieldInstruction {\n+    \/**\n+     * {@return the {@link FieldRefEntry} constant described by this instruction}\n+     *\/\n+    FieldRefEntry field();\n+\n+    \/**\n+     * {@return the class holding the field}\n+     *\/\n+    default ClassEntry owner() {\n+        return field().owner();\n+    }\n+\n+    \/**\n+     * {@return the name of the field}\n+     *\/\n+    default Utf8Entry name() {\n+        return field().nameAndType().name();\n+    }\n+\n+    \/**\n+     * {@return the field descriptor of the field}\n+     *\/\n+    default Utf8Entry type() {\n+        return field().nameAndType().type();\n+    }\n+\n+    \/**\n+     * {@return a symbolic descriptor for the type of the field}\n+     *\/\n+    default ClassDesc typeSymbol() {\n+        return ClassDesc.ofDescriptor(type().stringValue());\n+    }\n+\n+    \/**\n+     * {@return a field access instruction}\n+     *\n+     * @param op the opcode for the specific type of field access instruction,\n+     *           which must be of kind {@link Opcode.Kind#FIELD_ACCESS}\n+     * @param field a constant pool entry describing the field\n+     *\/\n+    static FieldInstruction of(Opcode op, FieldRefEntry field) {\n+        Util.checkKind(op, Opcode.Kind.FIELD_ACCESS);\n+        return new AbstractInstruction.UnboundFieldInstruction(op, field);\n+    }\n+\n+    \/**\n+     * {@return a field access instruction}\n+     *\n+     * @param op the opcode for the specific type of field access instruction,\n+     *           which must be of kind {@link Opcode.Kind#FIELD_ACCESS}\n+     * @param owner the class holding the field\n+     * @param name the name of the field\n+     * @param type the field descriptor\n+     *\/\n+    static FieldInstruction of(Opcode op,\n+                               ClassEntry owner,\n+                               Utf8Entry name,\n+                               Utf8Entry type) {\n+        return of(op, owner, TemporaryConstantPool.INSTANCE.natEntry(name, type));\n+    }\n+\n+    \/**\n+     * {@return a field access instruction}\n+     *\n+     * @param op the opcode for the specific type of field access instruction,\n+     *           which must be of kind {@link Opcode.Kind#FIELD_ACCESS}\n+     * @param owner the class holding the field\n+     * @param nameAndType the name and field descriptor of the field\n+     *\/\n+    static FieldInstruction of(Opcode op,\n+                               ClassEntry owner,\n+                               NameAndTypeEntry nameAndType) {\n+        return of(op, TemporaryConstantPool.INSTANCE.fieldRefEntry(owner, nameAndType));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/FieldInstruction.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a local variable increment instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Corresponding opcodes will have a {@code kind} of\n+ * {@link Opcode.Kind#INCREMENT}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface IncrementInstruction extends Instruction\n+        permits AbstractInstruction.BoundIncrementInstruction,\n+                AbstractInstruction.UnboundIncrementInstruction {\n+    \/**\n+     * {@return the local variable slot to increment}\n+     *\/\n+    int slot();\n+\n+    \/**\n+     * {@return the value to increment by}\n+     *\/\n+    int constant();\n+\n+    \/**\n+     * {@return an increment instruction}\n+     *\n+     * @param slot the local variable slot to increment\n+     * @param constant the value to increment by\n+     *\/\n+    static IncrementInstruction of(int slot, int constant) {\n+        return new AbstractInstruction.UnboundIncrementInstruction(slot, constant);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/IncrementInstruction.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models an {@code invokedynamic} instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Delivered as a {@link CodeElement} when traversing\n+ * the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface InvokeDynamicInstruction extends Instruction\n+        permits AbstractInstruction.BoundInvokeDynamicInstruction, AbstractInstruction.UnboundInvokeDynamicInstruction {\n+    \/**\n+     * {@return an {@link InvokeDynamicEntry} describing the call site}\n+     *\/\n+    InvokeDynamicEntry invokedynamic();\n+\n+    \/**\n+     * {@return the invocation name of the call site}\n+     *\/\n+    default Utf8Entry name() {\n+        return invokedynamic().name();\n+    }\n+\n+    \/**\n+     * {@return the invocation type of the call site}\n+     *\/\n+    default Utf8Entry type() {\n+        return invokedynamic().type();\n+    }\n+\n+    \/**\n+     * {@return the invocation type of the call site, as a symbolic descriptor}\n+     *\/\n+    default MethodTypeDesc typeSymbol() {\n+        return MethodTypeDesc.ofDescriptor(type().stringValue());\n+    }\n+\n+    \/**\n+     * {@return the bootstrap method of the call site}\n+     *\/\n+    default DirectMethodHandleDesc bootstrapMethod() {\n+        return invokedynamic().bootstrap()\n+                              .bootstrapMethod()\n+                              .asSymbol();\n+    }\n+\n+    \/**\n+     * {@return the bootstrap arguments of the call site}\n+     *\/\n+    default List<ConstantDesc> bootstrapArgs() {\n+        return Util.mappedList(invokedynamic().bootstrap().arguments(), new Function<>() {\n+            @Override\n+            public ConstantDesc apply(LoadableConstantEntry loadableConstantEntry) {\n+                return loadableConstantEntry.constantValue();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * {@return an invokedynamic instruction}\n+     *\n+     * @param invokedynamic the constant pool entry describing the call site\n+     *\/\n+    static InvokeDynamicInstruction of(InvokeDynamicEntry invokedynamic) {\n+        return new AbstractInstruction.UnboundInvokeDynamicInstruction(invokedynamic);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeDynamicInstruction.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a method invocation instruction in the {@code code} array of a {@code\n+ * Code} attribute, other than {@code invokedynamic}.  Corresponding opcodes\n+ * will have a {@code kind} of {@link Opcode.Kind#INVOKE}.  Delivered as a\n+ * {@link CodeElement} when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface InvokeInstruction extends Instruction\n+        permits AbstractInstruction.BoundInvokeInterfaceInstruction, AbstractInstruction.BoundInvokeInstruction, AbstractInstruction.UnboundInvokeInstruction {\n+    \/**\n+     * {@return the {@link MethodRefEntry} or {@link InterfaceMethodRefEntry}\n+     * constant described by this instruction}\n+     *\/\n+    MemberRefEntry method();\n+\n+    \/**\n+     * {@return whether the class holding the method is an interface}\n+     *\/\n+    boolean isInterface();\n+\n+    \/**\n+     * @return for an {@code invokeinterface}, the {@code count} value, as defined in {@jvms 6.5}\n+     *\/\n+    int count();\n+\n+    \/**\n+     * {@return the class holding the method}\n+     *\/\n+    default ClassEntry owner() {\n+        return method().owner();\n+    }\n+\n+    \/**\n+     * {@return the name of the method}\n+     *\/\n+    default Utf8Entry name() {\n+        return method().nameAndType().name();\n+    }\n+\n+    \/**\n+     * {@return the method descriptor of the method}\n+     *\/\n+    default Utf8Entry type() {\n+        return method().nameAndType().type();\n+    }\n+\n+    \/**\n+     * {@return a symbolic descriptor for the method type}\n+     *\/\n+    default MethodTypeDesc typeSymbol() {\n+        return MethodTypeDesc.ofDescriptor(type().stringValue());\n+    }\n+\n+\n+    \/**\n+     * {@return an invocation instruction}\n+     *\n+     * @param op the opcode for the specific type of invocation instruction,\n+     *           which must be of kind {@link Opcode.Kind#INVOKE}\n+     * @param method a constant pool entry describing the method\n+     *\/\n+    static InvokeInstruction of(Opcode op, MemberRefEntry method) {\n+        Util.checkKind(op, Opcode.Kind.INVOKE);\n+        return new AbstractInstruction.UnboundInvokeInstruction(op, method);\n+    }\n+\n+    \/**\n+     * {@return an invocation instruction}\n+     *\n+     * @param op the opcode for the specific type of invocation instruction,\n+     *           which must be of kind {@link Opcode.Kind#INVOKE}\n+     * @param owner the class holding the method\n+     * @param name the name of the method\n+     * @param type the method descriptor\n+     * @param isInterface whether the class holding the method is an interface\n+     *\/\n+    static InvokeInstruction of(Opcode op,\n+                                ClassEntry owner,\n+                                Utf8Entry name,\n+                                Utf8Entry type,\n+                                boolean isInterface) {\n+        return of(op, owner, TemporaryConstantPool.INSTANCE.natEntry(name, type), isInterface);\n+    }\n+\n+    \/**\n+     * {@return an invocation instruction}\n+     *\n+     * @param op the opcode for the specific type of invocation instruction,\n+     *           which must be of kind {@link Opcode.Kind#INVOKE}\n+     * @param owner the class holding the method\n+     * @param nameAndType the name and type of the method\n+     * @param isInterface whether the class holding the method is an interface\n+     *\/\n+    static InvokeInstruction of(Opcode op,\n+                                ClassEntry owner,\n+                                NameAndTypeEntry nameAndType,\n+                                boolean isInterface) {\n+        return of(op, isInterface\n+                      ? TemporaryConstantPool.INSTANCE.interfaceMethodRefEntry(owner, nameAndType)\n+                      : TemporaryConstantPool.INSTANCE.methodRefEntry(owner, nameAndType));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeInstruction.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.PseudoInstruction;\n+import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n+import jdk.internal.classfile.impl.LabelImpl;\n+\n+\/**\n+ * A pseudo-instruction which indicates that the specified label corresponds to\n+ * the current position in the {@code Code} attribute.  Delivered as a {@link\n+ * CodeElement} during traversal of the elements of a {@link CodeModel}.\n+ *\n+ * @see PseudoInstruction\n+ *\/\n+public sealed interface LabelTarget extends PseudoInstruction\n+        permits LabelImpl {\n+    Label label();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LabelTarget.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.PseudoInstruction;\n+import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n+import jdk.internal.classfile.attribute.LineNumberTableAttribute;\n+import jdk.internal.classfile.impl.LineNumberImpl;\n+\n+\/**\n+ * A pseudo-instruction which models a single entry in the\n+ * {@link LineNumberTableAttribute}.  Delivered as a {@link CodeElement}\n+ * during traversal of the elements of a {@link CodeModel}, according to\n+ * the setting of the {@link Classfile.Option#processLineNumbers(boolean)} option.\n+ *\n+ * @see PseudoInstruction\n+ *\/\n+public sealed interface LineNumber extends PseudoInstruction\n+        permits LineNumberImpl {\n+    int line();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LineNumber.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a local variable load instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Corresponding opcodes will have a {@code kind} of\n+ * {@link Opcode.Kind#LOAD}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface LoadInstruction extends Instruction\n+        permits AbstractInstruction.BoundLoadInstruction,\n+                AbstractInstruction.UnboundLoadInstruction {\n+    int slot();\n+\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return a local variable load instruction}\n+     *\n+     * @param kind the type of the value to be loaded\n+     * @param slot the local varaible slot to load from\n+     *\/\n+    static LoadInstruction of(TypeKind kind, int slot) {\n+        return of(BytecodeHelpers.loadOpcode(kind, slot), slot);\n+    }\n+\n+    \/**\n+     * {@return a local variable load instruction}\n+     *\n+     * @param op the opcode for the specific type of load instruction,\n+     *           which must be of kind {@link Opcode.Kind#LOAD}\n+     * @param slot the local varaible slot to load from\n+     *\/\n+    static LoadInstruction of(Opcode op, int slot) {\n+        Util.checkKind(op, Opcode.Kind.LOAD);\n+        return new AbstractInstruction.UnboundLoadInstruction(op, slot);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LoadInstruction.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.lang.constant.ClassDesc;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.PseudoInstruction;\n+import jdk.internal.classfile.attribute.LocalVariableTableAttribute;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+import jdk.internal.classfile.impl.BoundLocalVariable;\n+\n+\/**\n+ * A pseudo-instruction which models a single entry in the\n+ * {@link LocalVariableTableAttribute}.  Delivered as a {@link CodeElement}\n+ * during traversal of the elements of a {@link CodeModel}, according to\n+ * the setting of the {@link Classfile.Option#processDebug(boolean)} option.\n+ *\n+ * @see PseudoInstruction\n+ *\/\n+public sealed interface LocalVariable extends PseudoInstruction\n+        permits AbstractPseudoInstruction.UnboundLocalVariable, BoundLocalVariable {\n+    \/**\n+     * {@return the local variable slot}\n+     *\/\n+    int slot();\n+\n+    \/**\n+     * {@return the local variable name}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the local variable field descriptor}\n+     *\/\n+    Utf8Entry type();\n+\n+    \/**\n+     * {@return the local variable type, as a symbolic descriptor}\n+     *\/\n+    default ClassDesc typeSymbol() {\n+        return ClassDesc.ofDescriptor(type().stringValue());\n+    }\n+\n+    \/**\n+     * {@return the start range of the local variable scope}\n+     *\/\n+    Label startScope();\n+\n+    \/**\n+     * {@return the end range of the local variable scope}\n+     *\/\n+    Label endScope();\n+\n+    boolean writeTo(BufWriter buf);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LocalVariable.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.PseudoInstruction;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.attribute.LocalVariableTypeTableAttribute;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+import jdk.internal.classfile.impl.BoundLocalVariableType;\n+\n+\/**\n+ * A pseudo-instruction which models a single entry in the {@link\n+ * LocalVariableTypeTableAttribute}.  Delivered as a {@link CodeElement} during\n+ * traversal of the elements of a {@link CodeModel}, according to the setting of\n+ * the {@link Classfile.Option#processDebug(boolean)} option.\n+ *\/\n+public sealed interface LocalVariableType extends PseudoInstruction\n+        permits AbstractPseudoInstruction.UnboundLocalVariableType, BoundLocalVariableType {\n+    \/**\n+     * {@return the local variable slot}\n+     *\/\n+    int slot();\n+\n+    \/**\n+     * {@return the local variable name}\n+     *\/\n+    Utf8Entry name();\n+\n+    \/**\n+     * {@return the local variable signature}\n+     *\/\n+    Utf8Entry signature();\n+\n+    \/**\n+     * {@return the local variable signature}\n+     *\/\n+    default Signature signatureSymbol() {\n+        return Signature.parseFrom(signature().stringValue());\n+    }\n+\n+    \/**\n+     * {@return the start range of the local variable scope}\n+     *\/\n+    Label startScope();\n+\n+    \/**\n+     * {@return the end range of the local variable scope}\n+     *\/\n+    Label endScope();\n+\n+    boolean writeTo(BufWriter buf);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LocalVariableType.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code lookupswitch} instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Delivered as a {@link CodeElement} when traversing\n+ * the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface LookupSwitchInstruction extends Instruction\n+        permits AbstractInstruction.BoundLookupSwitchInstruction,\n+                AbstractInstruction.UnboundLookupSwitchInstruction {\n+    \/**\n+     * {@return the target of the default case}\n+     *\/\n+    Label defaultTarget();\n+\n+    \/**\n+     * {@return the cases of the switch}\n+     *\/\n+    List<SwitchCase> cases();\n+\n+    \/**\n+     * {@return a lookup switch instruction}\n+     *\n+     * @param defaultTarget the default target of the switch\n+     * @param cases the cases of the switch\n+     *\/\n+    static LookupSwitchInstruction of(Label defaultTarget, List<SwitchCase> cases) {\n+        return new AbstractInstruction.UnboundLookupSwitchInstruction(defaultTarget, cases);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LookupSwitchInstruction.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a {@code monitorenter} or {@code monitorexit} instruction in the\n+ * {@code code} array of a {@code Code} attribute.  Delivered as a {@link\n+ * CodeElement} when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface MonitorInstruction extends Instruction\n+        permits AbstractInstruction.UnboundMonitorInstruction {\n+\n+    \/**\n+     * {@return a monitor instruction}\n+     *\n+     * @param op the opcode for the specific type of monitor instruction,\n+     *           which must be of kind {@link Opcode.Kind#MONITOR}\n+     *\/\n+    static MonitorInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.MONITOR);\n+        return new AbstractInstruction.UnboundMonitorInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/MonitorInstruction.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code multianewarray} invocation instruction in the {@code code}\n+ * array of a {@code Code} attribute.  Delivered as a {@link CodeElement}\n+ * when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface NewMultiArrayInstruction extends Instruction\n+        permits AbstractInstruction.BoundNewMultidimensionalArrayInstruction,\n+                AbstractInstruction.UnboundNewMultidimensionalArrayInstruction {\n+\n+    \/**\n+     * {@return the type of the array, as a symbolic descriptor}\n+     *\/\n+    ClassEntry arrayType();\n+\n+    \/**\n+     * {@return the number of dimensions of the aray}\n+     *\/\n+    int dimensions();\n+\n+    \/**\n+     * {@return a new multi-dimensional array instruction}\n+     *\n+     * @param arrayTypeEntry the type of the array\n+     * @param dimensions the number of dimensions of the array\n+     *\/\n+    static NewMultiArrayInstruction of(ClassEntry arrayTypeEntry,\n+                                       int dimensions) {\n+        return new AbstractInstruction.UnboundNewMultidimensionalArrayInstruction(arrayTypeEntry, dimensions);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/NewMultiArrayInstruction.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code new} instruction in the {@code code} array of a {@code Code}\n+ * attribute.  Delivered as a {@link CodeElement} when traversing the elements\n+ * of a {@link CodeModel}.\n+ *\/\n+public sealed interface NewObjectInstruction extends Instruction\n+        permits AbstractInstruction.BoundNewObjectInstruction, AbstractInstruction.UnboundNewObjectInstruction {\n+\n+    \/**\n+     * {@return the type of object to create}\n+     *\/\n+    ClassEntry className();\n+\n+    \/**\n+     * {@return a new object instruction}\n+     *\n+     * @param className the type of object to create\n+     *\/\n+    static NewObjectInstruction of(ClassEntry className) {\n+        return new AbstractInstruction.UnboundNewObjectInstruction(className);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/NewObjectInstruction.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code newarray} invocation instruction in the {@code code}\n+ * array of a {@code Code} attribute.  Delivered as a {@link CodeElement}\n+ * when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface NewPrimitiveArrayInstruction extends Instruction\n+        permits AbstractInstruction.BoundNewPrimitiveArrayInstruction,\n+                AbstractInstruction.UnboundNewPrimitiveArrayInstruction {\n+    \/**\n+     * {@return the component type of the array}\n+     *\/\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return a new primitive array instruction}\n+     *\n+     * @param typeKind the component type of the array\n+     *\/\n+    static NewPrimitiveArrayInstruction of(TypeKind typeKind) {\n+        return new AbstractInstruction.UnboundNewPrimitiveArrayInstruction(typeKind);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code anewarray} invocation instruction in the {@code code}\n+ * array of a {@code Code} attribute.  Delivered as a {@link CodeElement}\n+ * when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface NewReferenceArrayInstruction extends Instruction\n+        permits AbstractInstruction.BoundNewReferenceArrayInstruction, AbstractInstruction.UnboundNewReferenceArrayInstruction {\n+    \/**\n+     * {@return the component type of the array}\n+     *\/\n+    ClassEntry componentType();\n+\n+    \/**\n+     * {@return a new reference array instruction}\n+     *\n+     * @param componentType the component type of the array\n+     *\/\n+    static NewReferenceArrayInstruction of(ClassEntry componentType) {\n+        return new AbstractInstruction.UnboundNewReferenceArrayInstruction(componentType);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/NewReferenceArrayInstruction.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code nop} invocation instruction in the {@code code}\n+ * array of a {@code Code} attribute.  Delivered as a {@link CodeElement}\n+ * when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface NopInstruction extends Instruction\n+        permits AbstractInstruction.UnboundNopInstruction {\n+    \/**\n+     * {@return a no-op instruction}\n+     *\/\n+    static NopInstruction of() {\n+        return new AbstractInstruction.UnboundNopInstruction();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/NopInstruction.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models an arithmetic operator instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Corresponding opcodes will have a {@code kind} of\n+ * {@link Opcode.Kind#OPERATOR}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface OperatorInstruction extends Instruction\n+        permits AbstractInstruction.UnboundOperatorInstruction {\n+    \/**\n+     * {@return the operand type of the instruction}\n+     *\/\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return an operator instruction}\n+     *\n+     * @param op the opcode for the specific type of array load instruction,\n+     *           which must be of kind {@link Opcode.Kind#OPERATOR}\n+     *\/\n+    static OperatorInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.OPERATOR);\n+        return new AbstractInstruction.UnboundOperatorInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/OperatorInstruction.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a return-from-method instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Corresponding opcodes will have a {@code kind} of\n+ * {@link Opcode.Kind#RETURN}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface ReturnInstruction extends Instruction\n+        permits AbstractInstruction.UnboundReturnInstruction {\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return a return instruction}\n+     *\n+     * @param typeKind the type of the return instruction\n+     *\/\n+    static ReturnInstruction of(TypeKind typeKind) {\n+        return of(BytecodeHelpers.returnOpcode(typeKind));\n+    }\n+\n+    \/**\n+     * {@return a return instruction}\n+     *\n+     * @param op the opcode for the specific type of return instruction,\n+     *           which must be of kind {@link Opcode.Kind#RETURN}\n+     *\/\n+    static ReturnInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.RETURN);\n+        return new AbstractInstruction.UnboundReturnInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ReturnInstruction.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a stack manipulation instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Corresponding opcodes will have a {@code kind} of\n+ * {@link Opcode.Kind#STACK}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface StackInstruction extends Instruction\n+        permits AbstractInstruction.UnboundStackInstruction {\n+\n+    \/**\n+     * {@return a stack manipulation instruction}\n+     *\n+     * @param op the opcode for the specific type of stack instruction,\n+     *           which must be of kind {@link Opcode.Kind#STACK}\n+     *\/\n+    static StackInstruction of(Opcode op) {\n+        Util.checkKind(op, Opcode.Kind.STACK);\n+        return new AbstractInstruction.UnboundStackInstruction(op);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/StackInstruction.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models a local variable store instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Corresponding opcodes will have a {@code kind} of\n+ * {@link Opcode.Kind#STORE}.  Delivered as a {@link CodeElement} when\n+ * traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface StoreInstruction extends Instruction\n+        permits AbstractInstruction.BoundStoreInstruction, AbstractInstruction.UnboundStoreInstruction {\n+    int slot();\n+    TypeKind typeKind();\n+\n+    \/**\n+     * {@return a local variable store instruction}\n+     *\n+     * @param kind the type of the value to be stored\n+     * @param slot the local varaible slot to store to\n+     *\/\n+    static StoreInstruction of(TypeKind kind, int slot) {\n+        return of(BytecodeHelpers.storeOpcode(kind, slot), slot);\n+    }\n+\n+    \/**\n+     * {@return a local variable store instruction}\n+     *\n+     * @param op the opcode for the specific type of store instruction,\n+     *           which must be of kind {@link Opcode.Kind#STORE}\n+     * @param slot the local varaible slot to store to\n+     *\/\n+    static StoreInstruction of(Opcode op, int slot) {\n+        Util.checkKind(op, Opcode.Kind.STORE);\n+        return new AbstractInstruction.UnboundStoreInstruction(op, slot);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/StoreInstruction.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a single case in a {@code lookupswitch} or {@code tableswitch}\n+ * instruction.\n+ *\n+ * @see LookupSwitchInstruction\n+ * @see TableSwitchInstruction\n+ *\/\n+public sealed interface SwitchCase\n+        permits AbstractInstruction.SwitchCaseImpl {\n+\n+    \/** {@return the integer value corresponding to this case} *\/\n+    int caseValue();\n+\n+    \/** {@return the branch target corresponding to this case} *\/\n+    Label target();\n+\n+    \/**\n+     * Create a {@linkplain SwitchCase}\n+     *\n+     * @param caseValue the integer value for the case\n+     * @param target the branch target for the case\n+     * @return the {@linkplain SwitchCase}\n+     *\/\n+    static SwitchCase of(int caseValue, Label target) {\n+        return new AbstractInstruction.SwitchCaseImpl(caseValue, target);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/SwitchCase.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.util.List;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models a {@code tableswitch} instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Delivered as a {@link CodeElement} when traversing\n+ * the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface TableSwitchInstruction extends Instruction\n+        permits AbstractInstruction.BoundTableSwitchInstruction, AbstractInstruction.UnboundTableSwitchInstruction {\n+    \/**\n+     * {@return the low value of the switch target range, inclusive}\n+     *\/\n+    int lowValue();\n+\n+    \/**\n+     * {@return the high value of the switch target range, inclusive}\n+     *\/\n+    int highValue();\n+\n+    \/**\n+     * {@return the default target of the switch}\n+     *\/\n+    Label defaultTarget();\n+\n+    \/**\n+     * {@return the cases of the switch}\n+     *\/\n+    List<SwitchCase> cases();\n+\n+    \/**\n+     * {@return a table switch instruction}\n+     *\n+     * @param lowValue the low value of the switch target range, inclusive\n+     * @param highValue the high value of the switch target range, inclusive\n+     * @param defaultTarget the default target of the switch\n+     * @param cases the cases of the switch\n+     *\/\n+    static TableSwitchInstruction of(int lowValue, int highValue, Label defaultTarget, List<SwitchCase> cases) {\n+        return new AbstractInstruction.UnboundTableSwitchInstruction(lowValue, highValue, defaultTarget, cases);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/TableSwitchInstruction.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+\n+\/**\n+ * Models an {@code athrow} instruction in the {@code code} array of a\n+ * {@code Code} attribute.  Delivered as a {@link CodeElement} when traversing\n+ * the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface ThrowInstruction extends Instruction\n+        permits AbstractInstruction.UnboundThrowInstruction {\n+\n+    \/**\n+     * {@return a throw instruction}\n+     *\/\n+    static ThrowInstruction of() {\n+        return new AbstractInstruction.UnboundThrowInstruction();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ThrowInstruction.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.instruction;\n+\n+import java.lang.constant.ClassDesc;\n+\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * Models an {@code instanceof} or {@code checkcast} instruction in the {@code\n+ * code} array of a {@code Code} attribute.  Delivered as a {@link CodeElement}\n+ * when traversing the elements of a {@link CodeModel}.\n+ *\/\n+public sealed interface TypeCheckInstruction extends Instruction\n+        permits AbstractInstruction.BoundTypeCheckInstruction,\n+                AbstractInstruction.UnboundTypeCheckInstruction {\n+    ClassEntry type();\n+\n+    \/**\n+     * {@return a type check instruction}\n+     *\n+     * @param op the opcode for the specific type of type check instruction,\n+     *           which must be of kind {@link Opcode.Kind#TYPE_CHECK}\n+     * @param type the type against which to check or cast\n+     *\/\n+    static TypeCheckInstruction of(Opcode op, ClassEntry type) {\n+        Util.checkKind(op, Opcode.Kind.TYPE_CHECK);\n+        return new AbstractInstruction.UnboundTypeCheckInstruction(op, type);\n+    }\n+\n+    \/**\n+     * {@return a type check instruction}\n+     *\n+     * @param op the opcode for the specific type of type check instruction,\n+     *           which must be of kind {@link Opcode.Kind#TYPE_CHECK}\n+     * @param type the type against which to check or cast\n+     *\/\n+    static TypeCheckInstruction of(Opcode op, ClassDesc type) {\n+        return of(op, TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(type))));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/TypeCheckInstruction.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.jdktypes;\n+\n+import static java.util.Objects.requireNonNull;\n+import jdk.internal.classfile.impl.ModuleDescImpl;\n+import static jdk.internal.classfile.impl.ModuleDescImpl.*;\n+\n+\/**\n+ * A nominal descriptor for a {@link Module} constant.\n+ *\n+ * <p>To create a {@linkplain ModuleDesc} for a module, use {@link #of}.\n+ *\n+ *\/\n+public sealed interface ModuleDesc\n+        permits ModuleDescImpl {\n+\n+    \/**\n+     * Returns a {@linkplain ModuleDesc} for a module,\n+     * given the name of the module.\n+     * <p>\n+     * {@jvms 4.2.3} Module names are not encoded in \"internal form\" like class and interface names, that is,\n+     * the ASCII periods (.) that separate the identifiers in a module name are not replaced by ASCII forward slashes (\/).\n+     * <p>\n+     * Module names may be drawn from the entire Unicode codespace, subject to the following constraints:\n+     * <ul>\n+     * <li>A module name must not contain any code point in the range '&#92;u0000' to '&#92;u001F' inclusive.\n+     * <li>The ASCII backslash (\\) is reserved for use as an escape character in module names.\n+     * It must not appear in a module name unless it is followed by an ASCII backslash, an ASCII colon (:), or an ASCII at-sign (@).\n+     * The ASCII character sequence \\\\ may be used to encode a backslash in a module name.\n+     * <li>The ASCII colon (:) and at-sign (@) are reserved for future use in module names.\n+     * They must not appear in module names unless they are escaped.\n+     * The ASCII character sequences \\: and \\@ may be used to encode a colon and an at-sign in a module name.\n+     * <\/ul>\n+     * @param name module name\n+     * @return a {@linkplain ModuleDesc} describing the desired module\n+     * @throws NullPointerException if the argument is {@code null}\n+     * @throws IllegalArgumentException if the name string is not in the\n+     * correct format\n+     *\/\n+    static ModuleDesc of(String name) {\n+        validateModuleName(requireNonNull(name));\n+        return new ModuleDescImpl(name);\n+    }\n+\n+    \/**\n+     * Returns the module name of this {@linkplain ModuleDesc}.\n+     *\n+     * @return the module name\n+     *\/\n+    String moduleName();\n+\n+    \/**\n+     * Compare the specified object with this descriptor for equality.  Returns\n+     * {@code true} if and only if the specified object is also a\n+     * {@linkplain ModuleDesc} and both describe the same module.\n+     *\n+     * @param o the other object\n+     * @return whether this descriptor is equal to the other object\n+     *\/\n+    @Override\n+    boolean equals(Object o);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/jdktypes\/ModuleDesc.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.jdktypes;\n+\n+import static java.util.Objects.requireNonNull;\n+import jdk.internal.classfile.impl.PackageDescImpl;\n+import static jdk.internal.classfile.impl.PackageDescImpl.*;\n+\n+\/**\n+ * A nominal descriptor for a {@link Package} constant.\n+ *\n+ * <p>To create a {@linkplain PackageDesc} for a package, use {@link #of} or\n+ * {@link #ofInternalName(String)}.\n+ *\n+ *\/\n+public sealed interface PackageDesc\n+        permits PackageDescImpl {\n+\n+    \/**\n+     * Returns a {@linkplain PackageDesc} for a package,\n+     * given the name of the package, such as {@code \"java.lang\"}.\n+     * <p>\n+     * {@jls 13.1}\n+     *\n+     * @param name the fully qualified (dot-separated) binary package name\n+     * @return a {@linkplain PackageDesc} describing the desired package\n+     * @throws NullPointerException if the argument is {@code null}\n+     * @throws IllegalArgumentException if the name string is not in the\n+     * correct format\n+     *\/\n+    static PackageDesc of(String name) {\n+        validateBinaryPackageName(requireNonNull(name));\n+        return new PackageDescImpl(binaryToInternal(name));\n+    }\n+\n+    \/**\n+     * Returns a {@linkplain PackageDesc} for a package,\n+     * given the name of the package in internal form,\n+     * such as {@code \"java\/lang\"}.\n+     * <p>\n+     * {@jvms 4.2.1} In this internal form, the ASCII periods (.) that normally separate the identifiers\n+     * which make up the binary name are replaced by ASCII forward slashes (\/).\n+     * @param name the fully qualified class name, in internal (slash-separated) form\n+     * @return a {@linkplain PackageDesc} describing the desired package\n+     * @throws NullPointerException if the argument is {@code null}\n+     * @throws IllegalArgumentException if the name string is not in the\n+     * correct format\n+     *\/\n+    static PackageDesc ofInternalName(String name) {\n+        validateInternalPackageName(requireNonNull(name));\n+        return new PackageDescImpl(name);\n+    }\n+\n+    \/**\n+     * Returns the fully qualified (slash-separated) internal package name\n+     * of this {@linkplain PackageDesc}.\n+     *\n+     * @return the package name, or the empty string for the\n+     * default package\n+     *\/\n+    String packageInternalName();\n+\n+    \/**\n+     * Returns the fully qualified (dot-separated) binary package name\n+     * of this {@linkplain PackageDesc}.\n+     *\n+     * @return the package name, or the empty string for the\n+     * default package\n+     *\/\n+    default String packageName() {\n+        return internalToBinary(packageInternalName());\n+    }\n+\n+    \/**\n+     * Compare the specified object with this descriptor for equality.  Returns\n+     * {@code true} if and only if the specified object is also a\n+     * {@linkplain PackageDesc} and both describe the same package.\n+     *\n+     * @param o the other object\n+     * @return whether this descriptor is equal to the other object\n+     *\/\n+    @Override\n+    boolean equals(Object o);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/jdktypes\/PackageDesc.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * <h2>Classfile parsing, generation, and transformation<\/h2>\n+ * The {@code jdk.internal.classfile} package contains classes for reading, writing, and\n+ * modifying Java class files, as specified in Chapter 4 of the <a\n+ * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se17\/html\/index.html\">Java\n+ * Java Virtual Machine Specification<\/a>.\n+ *\n+ * <h2>Reading classfiles<\/h2>\n+ * The main class for reading classfiles is {@link jdk.internal.classfile.ClassModel}; we\n+ * convert bytes into a {@link jdk.internal.classfile.ClassModel} with {@link\n+ * jdk.internal.classfile.Classfile#parse(byte[], jdk.internal.classfile.Classfile.Option[])}:\n+ * <p>\n+ * {@snippet lang=java :\n+ * ClassModel cm = Classfile.parse(bytes);\n+ * }\n+ * <p>\n+ * There are several additional overloads of {@code parse} that let you specify\n+ * various processing options.\n+ * <p>\n+ * A {@link jdk.internal.classfile.ClassModel} is an immutable description of a class\n+ * file.  It provides accessor methods to get at class metadata (e.g., {@link\n+ * jdk.internal.classfile.ClassModel#thisClass()}, {@link jdk.internal.classfile.ClassModel#flags()}),\n+ * as well as subordinate classfile entities ({@link jdk.internal.classfile.ClassModel#fields()},\n+ * {@link jdk.internal.classfile.ClassModel#attributes()}). A {@link\n+ * jdk.internal.classfile.ClassModel} is inflated lazily; most parts of the classfile are\n+ * not parsed until they are actually needed.\n+ * <p>\n+ * We can enumerate the names of the fields and methods in a class by:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"enumerateFieldsMethods1\"}\n+ * <p>\n+ * When we enumerate the methods, we get a {@link jdk.internal.classfile.MethodModel} for each method; like a\n+ * {@code ClassModel}, it gives us access to method metadata and\n+ * the ability to descend into subordinate entities such as the bytecodes of the\n+ * method body. In this way, a {@code ClassModel} is the root of a\n+ * tree, with children for fields, methods, and attributes, and {@code MethodModel} in\n+ * turn has its own children (attributes, {@code CodeModel}, etc.)\n+ * <p>\n+ * Methods like {@link jdk.internal.classfile.ClassModel#methods} allows us to traverse the class structure\n+ * explicitly, going straight to the parts we are interested in.  This is useful\n+ * for certain kinds of analysis, but if we wanted to process the whole\n+ * classfile, we may want something more organized.  A {@link\n+ * jdk.internal.classfile.ClassModel} also provides us with a view of the classfile as a\n+ * series of class <em>elements<\/em>, which may include methods, fields, attributes,\n+ * and more, and which can be distinguished with pattern matching.  We could\n+ * rewrite the above example as:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"enumerateFieldsMethods2\"}\n+ * <p>\n+ * The models returned as elements from traversing {@code ClassModel} can in\n+ * turn be sources of elements.  If we wanted to\n+ * traverse a classfile and enumerate all the classes for which we access fields\n+ * and methods, we can pick out the class elements that describe methods, then\n+ * in turn pick out the method elements that describe the code attribute, and\n+ * finally pick out the code elements that describe field access and invocation\n+ * instructions:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"gatherDependencies1\"}\n+ * <p>\n+ * This same query could alternately be processed as a stream pipeline over\n+ * class elements:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"gatherDependencies2\"}\n+ *\n+ * <h3>Models and elements<\/h3>\n+ * The view of classfiles presented by this API is framed in terms of\n+ * <em>models<\/em> and <em>elements<\/em>.  Models represent complex structures,\n+ * such as classes, methods, fields, record elements, or the code body of a\n+ * method.  Models can be explored either via random-access navigation (such as\n+ * the {@link jdk.internal.classfile.ClassModel#methods()} accessor) or as a linear\n+ * sequence of <em>elements<\/em>. (Elements can in turn also be models; a {@link\n+ * jdk.internal.classfile.FieldModel} is also an element of a class.) For each model type\n+ * (e.g., {@link jdk.internal.classfile.MethodModel}), there is a corresponding element\n+ * type ({@link jdk.internal.classfile.MethodElement}).  Models and elements are immutable\n+ * and are inflated lazily so creating a model does not necessarily require\n+ * processing its entire content.\n+ *\n+ * <h3>The constant pool<\/h3>\n+ * Much of the interesting content in a classfile lives in the <em>constant\n+ * pool<\/em>. {@link jdk.internal.classfile.ClassModel} provides a lazily-inflated,\n+ * read-only view of the constant pool via {@link jdk.internal.classfile.ClassModel#constantPool()}.\n+ * Descriptions of classfile content is often exposed in the form of various\n+ * subtypes of {@link jdk.internal.classfile.constantpool.PoolEntry}, such as {@link\n+ * jdk.internal.classfile.constantpool.ClassEntry} or {@link jdk.internal.classfile.constantpool.Utf8Entry}.\n+ * <p>\n+ * Constant pool entries are also exposed through models and elements; in the\n+ * above traversal example, the {@link jdk.internal.classfile.instruction.InvokeInstruction}\n+ * element exposed a method for {@code owner} that corresponds to a {@code\n+ * Constant_Class_info} entry in the constant pool.\n+ *\n+ * <h3>Attributes<\/h3>\n+ * Much of the contents of a classfile is stored in attributes; attributes are\n+ * found on classes, methods, fields, record components, and on the {@code Code}\n+ * attribute.  Most attributes are surfaced as elements; for example, {@link\n+ * jdk.internal.classfile.attribute.SignatureAttribute} is a {@link\n+ * jdk.internal.classfile.ClassElement}, {@link jdk.internal.classfile.MethodElement}, and {@link\n+ * jdk.internal.classfile.FieldElement} since it can appear in all of those places, and is\n+ * included when iterating the elements of the corresponding model.\n+ * <p>\n+ * Some attributes are not surfaced as elements; these are attributes that are\n+ * tightly coupled to -- and logically part of -- other parts of the class file.\n+ * These include the {@code BootstrapMethods}, {@code LineNumberTable}, {@code\n+ * StackMapTable}, {@code LocalVariableTable}, and {@code\n+ * LocalVariableTypeTable} attributes.  These are processed by the library and\n+ * treated as part of the structure they are coupled to (the entries of the\n+ * {@code BootstrapMethods} attribute are treated as part of the constant pool;\n+ * line numbers and local variable metadata are modeled as elements of {@link\n+ * jdk.internal.classfile.CodeModel}.)\n+ * <p>\n+ * The {@code Code} attribute, in addition to being modeled as a {@link\n+ * jdk.internal.classfile.MethodElement}, is also a model in its own right ({@link\n+ * jdk.internal.classfile.CodeModel}) due to its complex structure.\n+ * <p>\n+ * Each standard attribute has an interface (in {@code jdk.internal.classfile.attribute})\n+ * which exposes the contents of the attribute and provides factories to\n+ * construct the attribute.  For example, the {@code Signature} attribute is\n+ * defined by the {@link jdk.internal.classfile.attribute.SignatureAttribute} class, and\n+ * provides accessors for {@link jdk.internal.classfile.attribute.SignatureAttribute#signature()}\n+ * as well as factories taking {@link jdk.internal.classfile.constantpool.Utf8Entry} or\n+ * {@link java.lang.String}.\n+ *\n+ * <h3>Custom attributes<\/h3>\n+ * Attributes are converted between their classfile form and their corresponding\n+ * object form via an {@link jdk.internal.classfile.AttributeMapper}.  An {@code\n+ * AttributeMapper} provides the {@link jdk.internal.classfile.AttributeMapper#readAttribute(AttributedElement, ClassReader, int)} method for mapping from the classfile format\n+ * to an attribute instance, and the {@link jdk.internal.classfile.AttributeMapper#writeAttribute(jdk.internal.classfile.BufWriter,\n+ * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * contains metadata including the attribute name, the set of classfile entities\n+ * where the attribute is applicable, and whether multiple attributes of the\n+ * same kind are allowed on a single entity.\n+ * <p>\n+ * There are built-in attribute mappers (in {@link jdk.internal.classfile.Attributes}) for\n+ * each of the attribute types defined in section {@jvms 4.7} of <cite>The Java Virtual\n+ * Machine Specification<\/cite>, as well as several common nonstandard attributes used by the\n+ * JDK such as {@code CharacterRangeTable}.\n+ * <p>\n+ * Unrecognized attributes are delivered as elements of type {@link\n+ * jdk.internal.classfile.attribute.UnknownAttribute}, which provide access only to the\n+ * {@code byte[]} contents of the attribute.\n+ * <p>\n+ * For nonstandard attributes, user-provided attribute mappers can be specified\n+ * through the use of the {@link jdk.internal.classfile.Classfile.Option#attributeMapper(java.util.function.Function)}}\n+ * classfile option.  Implementations of custom attributes should extend {@link\n+ * jdk.internal.classfile.CustomAttribute}.\n+ *\n+ * <h3>Options<\/h3>\n+ * <p>\n+ * {@link jdk.internal.classfile.Classfile#parse(byte[], jdk.internal.classfile.Classfile.Option[])}\n+ * accepts a list of options.  {@link jdk.internal.classfile.Classfile.Option} exports some\n+ * static boolean options, as well as factories for more complex options,\n+ * including:\n+ * <ul>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#generateStackmap(boolean)} -- generate stackmaps (default is true)<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#processDebug(boolean)} -- processing of debug information, such as local variable metadata (default is true) <\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#processLineNumbers(boolean)} -- processing of line numbers (default is true) <\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#processUnknownAttributes(boolean)} -- processing of unrecognized attributes (default is true)<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#constantPoolSharing(boolean)}} -- share constant pool when transforming (default is true)<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#classHierarchyResolver(jdk.internal.classfile.ClassHierarchyResolver)} -- specify a custom class hierarchy\n+ * resolver used by stack map generation<\/li>\n+ *   <li>{@link jdk.internal.classfile.Classfile.Option#attributeMapper(java.util.function.Function)} -- specify format of custom attributes<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Most options allow you to request that certain parts of the classfile be\n+ * skipped during traversal, such as debug information or unrecognized\n+ * attributes.  Some options allow you to suppress generation of portions of the\n+ * classfile, such as stack maps.  Many of these options are to access\n+ * performance tradeoffs; processing debug information and line numbers has a\n+ * cost (both in writing and reading.)  If you don't need this information, you\n+ * can suppress it with options to gain some performance.\n+ *\n+ * <h2>Writing classfiles<\/h2>\n+ * Classfile generation is accomplished through <em>builders<\/em>.  For each\n+ * entity type that has a model, there is also a corresponding builder type;\n+ * classes are built through {@link jdk.internal.classfile.ClassBuilder}, methods through\n+ * {@link jdk.internal.classfile.MethodBuilder}, etc.\n+ * <p>\n+ * Rather than creating builders directly, builders are provided as an argument\n+ * to a user-provided lambda.  To generate the familiar \"hello world\" program,\n+ * we ask for a class builder, and use that class builder to create method\n+ * builders for the constructor and {@code main} method, and in turn use the\n+ * method builders to create a {@code Code} attribute and use the code builders\n+ * to generate the instructions:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"helloWorld\"}\n+ * <p>\n+ * Builders often support multiple ways of expressing the same entity at\n+ * different levels of abstraction.  For example, the {@code invokevirtual}\n+ * instruction invoking {@code println} could have been generated with {@link\n+ * jdk.internal.classfile.CodeBuilder#invokevirtual(java.lang.constant.ClassDesc,\n+ * java.lang.String, java.lang.constant.MethodTypeDesc) CodeBuilder.invokevirtual}, {@link\n+ * jdk.internal.classfile.CodeBuilder#invokeInstruction(jdk.internal.classfile.Opcode,\n+ * java.lang.constant.ClassDesc, java.lang.String, java.lang.constant.MethodTypeDesc,\n+ * boolean) CodeBuilder.invokeInstruction}, or\n+ * {@link jdk.internal.classfile.CodeBuilder#with(jdk.internal.classfile.ClassfileElement) CodeBuilder.with}.\n+ * <p>\n+ * The convenience method {@code CodeBuilder.invokevirtual} behaves as if it calls\n+ * the convenience method {@code CodeBuilder.invokeInstruction}, which in turn behaves\n+ * as if it calls method {@code CodeBuilder.with}. This composing of method calls on the\n+ * builder enables the composing of transforms (as described later).\n+ *\n+ * <h3>Symbolic information<\/h3>\n+ * To describe symbolic information for classes and types, the API uses the\n+ * nominal descriptor abstractions from {@code java.lang.constant} such as {@link\n+ * java.lang.constant.ClassDesc} and {@link java.lang.constant.MethodTypeDesc},\n+ * which is less error-prone than using raw strings.\n+ * <p>\n+ * If a constant pool entry has a nominal representation then it provides a\n+ * method returning the corresponding nominal descriptor type e.g.\n+ * method {@link jdk.internal.classfile.constantpool.ClassEntry#asSymbol} returns\n+ * {@code ClassDesc}.\n+ * <p>\n+ * Where appropriate builders provide two methods for building an element with\n+ * symbolic information, one accepting nominal descriptors, and the other\n+ * accepting constant pool entries.\n+ *\n+ * <h2>Transforming classfiles<\/h2>\n+ * Classfile Processing APIs are most frequently used to combine reading and\n+ * writing into transformation, where a classfile is read, localized changes are\n+ * made, but much of the classfile is passed through unchanged.  For each kind\n+ * of builder, {@code XxxBuilder} has a method {@code with(XxxElement)} so that\n+ * elements that we wish to pass through unchanged can be handed directly back\n+ * to the builder.\n+ * <p>\n+ * If we wanted to strip out methods whose names starts with \"debug\", we could\n+ * get an existing {@link jdk.internal.classfile.ClassModel}, build a new classfile that\n+ * provides a {@link jdk.internal.classfile.ClassBuilder}, iterate the elements of the\n+ * original {@link jdk.internal.classfile.ClassModel}, and pass through all of them to\n+ * the builder except the methods we want to drop:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods1\"}\n+ * <p>\n+ * This hands every class element, except for those corresponding to methods\n+ * whose names start with {@code debug}, back to the builder.  Transformations\n+ * can of course be more complicated, diving into method bodies and instructions\n+ * and transforming those as well, but the same structure is repeated at every\n+ * level, since every entity has corresponding model, builder, and element\n+ * abstractions.\n+ * <p>\n+ * Transformation can be viewed as a \"flatMap\" operation on the sequence of\n+ * elements; for every element, we could pass it through unchanged, drop it, or\n+ * replace it with one or more elements.  Because transformation is such a\n+ * common operation on classfiles, each model type has a corresponding {@code\n+ * XxxTransform} type (which describes a transform on a sequence of {@code\n+ * XxxElement}) and each builder type has {@code transformYyy} methods for transforming\n+ * its child models.  A transform is simply a functional interface that takes a\n+ * builder and an element, and an implementation \"flatMap\"s elements\n+ * into the builder.  We could express the above as:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"stripDebugMethods2\"}\n+ *\n+ * <h3>Lifting transforms<\/h3>\n+ * While the second example is only slightly shorter than the first, the\n+ * advantage of expressing transformation in this way is that the transform\n+ * operations can be more easily combined.  Suppose we want to redirect\n+ * invocations of static methods on {@code Foo} to the corresponding method on\n+ * {@code Bar} instead.  We could express this as a transformation on {@link\n+ * jdk.internal.classfile.CodeElement}:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"fooToBarTransform\"}\n+ * <p>\n+ * We can then <em>lift<\/em> this transformation on code elements into a\n+ * transformation on method elements.  This intercepts method elements that\n+ * correspond to a {@code Code} attribute, dives into its code elements, and\n+ * applies the code transform to them, and passes other method elements through\n+ * unchanged:\n+ * {@snippet lang=java :\n+ * MethodTransform mt = MethodTransform.transformingCode(fooToBar);\n+ * }\n+ * <p>\n+ * and further lift the transform on method elements into one on class\n+ * elements:\n+ * {@snippet lang=java :\n+ * ClassTransform ct = ClassTransform.transformingMethods(mt);\n+ * }\n+ * <p>\n+ * and then transform the classfile:\n+ * {@snippet lang=java :\n+ * byte[] newBytes = Classfile.parse(bytes).transform(ct);\n+ * }\n+ * <p>\n+ * This is much more concise (and less error-prone) than the equivalent\n+ * expressed by traversing the classfile structure directly:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"fooToBarUnrolled\"}\n+ *\n+ * <h3>Composing transforms<\/h3>\n+ * Transforms on the same type of element can be composed in sequence, where the\n+ * output of the first is fed to the input of the second.  Suppose we want to\n+ * instrument all method calls, where we print the name of a method before\n+ * calling it:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"instrumentCallsTransform\"}\n+ * <p>\n+ * Then we can compose {@code fooToBar} and {@code instrumentCalls} with {@link\n+ * jdk.internal.classfile.CodeTransform#andThen(jdk.internal.classfile.CodeTransform)}:\n+ * <p>\n+ * {@snippet lang=java :\n+ * byte[] newBytes = Classfile.parse(bytes)\n+ *                             .transform(ClassTransform.transformingMethods(\n+ *                                 MethodTransform.transformingCode(\n+ *                                     fooToBar.andThen(instrumentCalls))));\n+ * }\n+ *\n+ * Transform {@code instrumentCalls} will receive all code elements produced by\n+ * transform {@code forToBar}, either those code elements from the original classfile\n+ * or replacements (replacing static invocations to {@code Foo} with those to {@code Bar}).\n+ *\n+ * <h3>Constant pool sharing<\/h3>\n+ * Transformation doesn't merely handle the logistics of reading, transforming\n+ * elements, and writing.  Most of the time when we are transforming a\n+ * classfile, we are making relatively minor changes.  To optimize such cases,\n+ * transformation seeds the new classfile with a copy of the constant pool from\n+ * the original classfile; this enables significant optimizations (methods and\n+ * attributes that are not transformed can be processed by bulk-copying their\n+ * bytes, rather than parsing them and regenerating their contents.)  If\n+ * constant pool sharing is not desired it can be suppressed\n+ * with the {@link jdk.internal.classfile.Classfile.Option#constantPoolSharing(boolean)} option.\n+ * Such suppression may be beneficial when transformation removes many elements,\n+ * resulting in many unreferenced constant pool entries.\n+ *\n+ * <h2>API conventions<\/h2>\n+ * <p>\n+ * The API is largely derived from a <a href=\"#data_model\"><em>data model<\/em><\/a>\n+ * for the classfile format, which defines each element kind (which includes models and\n+ * attributes) and its properties.  For each element kind, there is a\n+ * corresponding interface to describe that element, and factory methods to\n+ * create that element.  Some element kinds also have convenience methods on the\n+ * corresponding builder (e.g., {@link jdk.internal.classfile.CodeBuilder#invokevirtual(java.lang.constant.ClassDesc,\n+ * java.lang.String, java.lang.constant.MethodTypeDesc)}).\n+ * <p>\n+ * Most symbolic information in elements is represented by constant pool entries\n+ * (for example, the owner of a field is represented by a {@link\n+ * jdk.internal.classfile.constantpool.ClassEntry}.) Factories and builders also accept nominal\n+ * descriptors from {@code java.lang.constant} (e.g., {@link\n+ * java.lang.constant.ClassDesc}.)\n+ *\n+ * <h2><a id=\"data_model\"><\/a>Data model<\/h2>\n+ * We define each kind of element by its name, an optional arity indicator (zero\n+ * or more, zero or one, exactly one), and a list of components.  The elements\n+ * of a class are fields, methods, and the attributes that can appear on\n+ * classes:\n+ * <p>\n+ * {@snippet lang=\"text\" :\n+ * ClassElement =\n+ *     FieldModel*(UtfEntry name, Utf8Entry descriptor)\n+ *     | MethodModel*(UtfEntry name, Utf8Entry descriptor)\n+ *     | ModuleAttribute?(int flags, ModuleEntry moduleName, UtfEntry moduleVersion,\n+ *                        List<ModuleRequireInfo> requires, List<ModuleOpenInfo> opens,\n+ *                        List<ModuleExportInfo> exports, List<ModuleProvidesInfo> provides,\n+ *                        List<ClassEntry> uses)\n+ *     | ModulePackagesAttribute?(List<PackageEntry> packages)\n+ *     | ModuleTargetAttribute?(Utf8Entry targetPlatform)\n+ *     | ModuleHashesAttribute?(Utf8Entry algorithm, List<HashInfo> hashes)\n+ *     | ModuleResolutionAttribute?(int resolutionFlags)\n+ *     | SourceFileAttribute?(Utf8Entry sourceFile)\n+ *     | SourceDebugExtensionsAttribute?(byte[] contents)\n+ *     | CompilationIDAttribute?(Utf8Entry compilationId)\n+ *     | SourceIDAttribute?(Utf8Entry sourceId)\n+ *     | NestHostAttribute?(ClassEntry nestHost)\n+ *     | NestMembersAttribute?(List<ClassEntry> nestMembers)\n+ *     | RecordAttribute?(List<RecordComponent> components)\n+ *     | EnclosingMethodAttribute?(ClassEntry className, NameAndTypeEntry method)\n+ *     | InnerClassesAttribute?(List<InnerClassInfo> classes)\n+ *     | PermittedSubclassesAttribute?(List<ClassEntry> permittedSubclasses)\n+ *     | DeclarationElement*\n+ * }\n+ *<p>\n+ * where {@code DeclarationElement} are the elements that are common to all declarations\n+ * (classes,  methods, fields) and so are factored out:\n+ *\n+ * {@snippet lang=\"text\" :\n+ * DeclarationElement =\n+ *     SignatureAttribute?(Utf8Entry signature)\n+ *     | SyntheticAttribute?()\n+ *     | DeprecatedAttribute?()\n+ *     | RuntimeInvisibleAnnotationsAttribute?(List<Annotation> annotations)\n+ *     | RuntimeVisibleAnnotationsAttribute?(List<Annotation> annotations)\n+ *     | CustomAttribute*\n+ *     | UnknownAttribute*\n+ * }\n+ *\n+ * Fields and methods are models with their own elements.  The elements of fields\n+ * and methods are fairly simple; most of the complexity of methods lives in the\n+ * {@link jdk.internal.classfile.CodeModel} (which models the {@code Code} attribute\n+ * along with the code-related attributes: stack map table, local variable table,\n+ * line number table, etc.)\n+ *\n+ * {@snippet lang=\"text\" :\n+ * FieldElement =\n+ *     DeclarationElement\n+ *     | ConstantValueAttribute?(ConstantValueEntry constant)\n+ *\n+ * MethodElement =\n+ *     DeclarationElement\n+ *     | CodeModel?()\n+ *     | AnnotationDefaultAttribute?(ElementValue defaultValue)\n+ *     | MethodParametersAttribute?(List<MethodParameterInfo> parameters)\n+ *     | ExceptionsAttribute?(List<ClassEntry> exceptions)\n+ * }\n+ *\n+ * {@link jdk.internal.classfile.CodeModel} is unique in that its elements are <em>ordered<\/em>.\n+ * Elements of {@code Code} include ordinary bytecodes, as well as a number of pseudo-instructions\n+ * representing branch targets, line number metadata, local variable metadata, and\n+ * catch blocks.\n+ *\n+ * {@snippet lang=\"text\" :\n+ * CodeElement = Instruction | PseudoInstruction\n+ *\n+ * Instruction =\n+ *     LoadInstruction(TypeKind type, int slot)\n+ *     | StoreInstruction(TypeKind type, int slot)\n+ *     | IncrementInstruction(int slot, int constant)\n+ *     | BranchInstruction(Opcode opcode, Label target)\n+ *     | LookupSwitchInstruction(Label defaultTarget, List<SwitchCase> cases)\n+ *     | TableSwitchInstruction(Label defaultTarget, int low, int high,\n+ *                              List<SwitchCase> cases)\n+ *     | ReturnInstruction(TypeKind kind)\n+ *     | ThrowInstruction()\n+ *     | FieldInstruction(Opcode opcode, FieldRefEntry field)\n+ *     | InvokeInstruction(Opcode opcode, MemberRefEntry method, boolean isInterface)\n+ *     | InvokeDynamicInstruction(InvokeDynamicEntry invokedynamic)\n+ *     | NewObjectInstruction(ClassEntry className)\n+ *     | NewReferenceArrayInstruction(ClassEntry componentType)\n+ *     | NewPrimitiveArrayInstruction(TypeKind typeKind)\n+ *     | NewMultiArrayInstruction(ClassEntry componentType, int dims)\n+ *     | ArrayLoadInstruction(Opcode opcode)\n+ *     | ArrayStoreInstruction(Opcode opcode)\n+ *     | TypeCheckInstruction(Opcode opcode, ClassEntry className)\n+ *     | ConvertInstruction(TypeKind from, TypeKind to)\n+ *     | OperatorInstruction(Opcode opcode)\n+ *     | ConstantInstruction(ConstantDesc constant)\n+ *     | StackInstruction(Opcode opcode)\n+ *     | MonitorInstruction(Opcode opcode)\n+ *     | NopInstruction()\n+ *\n+ * PseudoInstruction =\n+ *     | LabelTarget(Label label)\n+ *     | LineNumber(int line)\n+ *     | ExceptionCatch(Label tryStart, Label tryEnd, Label handler, ClassEntry exception)\n+ *     | LocalVariable(int slot, UtfEntry name, Utf8Entry type, Label startScope, Label endScope)\n+ *     | LocalVariableType(int slot, Utf8Entry name, Utf8Entry type, Label startScope, Label endScope)\n+ *     | CharacterRange(int rangeStart, int rangeEnd, int flags, Label startScope, Label endScope)\n+ * }\n+ *\/\n+package jdk.internal.classfile;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/package-info.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import java.lang.reflect.AccessFlag;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+\n+import static java.util.stream.Collectors.toSet;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n+import jdk.internal.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+\n+class PackageSnippets {\n+    void enumerateFieldsMethods1(byte[] bytes) {\n+        \/\/ @start region=\"enumerateFieldsMethods1\"\n+        ClassModel cm = Classfile.parse(bytes);\n+        for (FieldModel fm : cm.fields())\n+            System.out.printf(\"Field %s%n\", fm.fieldName().stringValue());\n+        for (MethodModel mm : cm.methods())\n+            System.out.printf(\"Method %s%n\", mm.methodName().stringValue());\n+        \/\/ @end\n+    }\n+\n+    void enumerateFieldsMethods2(byte[] bytes) {\n+        \/\/ @start region=\"enumerateFieldsMethods2\"\n+        ClassModel cm = Classfile.parse(bytes);\n+        for (ClassElement ce : cm) {\n+            switch (ce) {\n+                case MethodModel mm -> System.out.printf(\"Method %s%n\", mm.methodName().stringValue());\n+                case FieldModel fm -> System.out.printf(\"Field %s%n\", fm.fieldName().stringValue());\n+                default -> { }\n+            }\n+        }\n+        \/\/ @end\n+    }\n+\n+    void gatherDependencies1(byte[] bytes) {\n+        \/\/ @start region=\"gatherDependencies1\"\n+        ClassModel cm = Classfile.parse(bytes);\n+        Set<ClassDesc> dependencies = new HashSet<>();\n+\n+        for (ClassElement ce : cm) {\n+            if (ce instanceof MethodModel mm) {\n+                for (MethodElement me : mm) {\n+                    if (me instanceof CodeModel xm) {\n+                        for (CodeElement e : xm) {\n+                            switch (e) {\n+                                case InvokeInstruction i -> dependencies.add(i.owner().asSymbol());\n+                                case FieldInstruction i -> dependencies.add(i.owner().asSymbol());\n+                                default -> { }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ @end\n+    }\n+\n+    void gatherDependencies2(byte[] bytes) {\n+        \/\/ @start region=\"gatherDependencies2\"\n+        ClassModel cm = Classfile.parse(bytes);\n+        Set<ClassDesc> dependencies = cm.elementStream()\n+                                        .filter(ce -> ce instanceof MethodModel)\n+                                        .flatMap(ce -> ((MethodModel) ce).elementStream())\n+                                        .filter(me -> me instanceof CodeModel)\n+                                        .flatMap(me -> ((CodeModel) me).elementStream())\n+                                        .<ClassDesc>mapMulti((xe, c) -> {\n+                                            switch (xe) {\n+                                                case InvokeInstruction i -> c.accept(i.owner().asSymbol());\n+                                                case FieldInstruction i -> c.accept(i.owner().asSymbol());\n+                                                default -> { }\n+                                            }\n+                                        })\n+                                        .collect(toSet());\n+        \/\/ @end\n+    }\n+\n+    void writeHelloWorld() {\n+        \/\/ @start region=\"helloWorld\"\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Hello\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"<init>\", MethodTypeDesc.of(ConstantDescs.CD_void), Classfile.ACC_PUBLIC,\n+                          mb -> mb.withCode(\n+                                  b -> b.aload(0)\n+                                        .invokespecial(ConstantDescs.CD_Object, \"<init>\",\n+                                                       MethodTypeDesc.of(ConstantDescs.CD_void))\n+                                        .returnInstruction(TypeKind.VoidType)\n+                          )\n+              )\n+              .withMethod(\"main\", MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String.arrayType()),\n+                          Classfile.ACC_PUBLIC,\n+                          mb -> mb.withFlags(AccessFlag.STATIC, AccessFlag.PUBLIC)\n+                                  .withCode(\n+                                  b -> b.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n+                                        .constantInstruction(Opcode.LDC, \"Hello World\")\n+                                        .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\",\n+                                                       MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String))\n+                                        .returnInstruction(TypeKind.VoidType)\n+            ));\n+        });\n+        \/\/ @end\n+    }\n+\n+    void stripDebugMethods1(byte[] bytes) {\n+        \/\/ @start region=\"stripDebugMethods1\"\n+        ClassModel classModel = Classfile.parse(bytes);\n+        byte[] newBytes = Classfile.build(classModel.thisClass().asSymbol(),\n+                                          classBuilder -> {\n+                                              for (ClassElement ce : classModel) {\n+                                                  if (!(ce instanceof MethodModel mm\n+                                                        && mm.methodName().stringValue().startsWith(\"debug\")))\n+                                                  classBuilder.with(ce);\n+                                              }\n+                                          });\n+        \/\/ @end\n+    }\n+\n+    void stripDebugMethods2(byte[] bytes) {\n+        \/\/ @start region=\"stripDebugMethods2\"\n+        ClassTransform ct = (builder, element) -> {\n+            if (!(element instanceof MethodModel mm && mm.methodName().stringValue().startsWith(\"debug\")))\n+                builder.with(element);\n+        };\n+        byte[] newBytes = Classfile.parse(bytes).transform(ct);\n+        \/\/ @end\n+    }\n+\n+    void fooToBarTransform() {\n+        \/\/ @start region=\"fooToBarTransform\"\n+        CodeTransform fooToBar = (b, e) -> {\n+            if (e instanceof InvokeInstruction i\n+                    && i.owner().asInternalName().equals(\"Foo\")\n+                    && i.opcode() == Opcode.INVOKESTATIC)\n+                        b.invokeInstruction(i.opcode(), ClassDesc.of(\"Bar\"), i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+            else b.with(e);\n+        };\n+        \/\/ @end\n+    }\n+\n+    void instrumentCallsTransform() {\n+        \/\/ @start region=\"instrumentCallsTransform\"\n+        CodeTransform instrumentCalls = (b, e) -> {\n+            if (e instanceof InvokeInstruction i) {\n+                b.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n+                 .constantInstruction(Opcode.LDC, i.name().stringValue())\n+                 .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\",\n+                                MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String));\n+            }\n+            b.with(e);\n+        };\n+        \/\/ @end\n+    }\n+\n+    void fooToBarUnrolled(ClassModel classModel) {\n+        \/\/ @start region=\"fooToBarUnrolled\"\n+        byte[] newBytes = Classfile.build(classModel.thisClass().asSymbol(),\n+            classBuilder -> {\n+              for (ClassElement ce : classModel) {\n+                  if (ce instanceof MethodModel mm) {\n+                      classBuilder.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(),\n+                                              mm.flags().flagsMask(),\n+                                              methodBuilder -> {\n+                                  for (MethodElement me : mm) {\n+                                      if (me instanceof CodeModel xm) {\n+                                          methodBuilder.withCode(codeBuilder -> {\n+                                              for (CodeElement e : xm) {\n+                                                  if (e instanceof InvokeInstruction i && i.owner().asInternalName().equals(\"Foo\")\n+                                                                               && i.opcode() == Opcode.INVOKESTATIC)\n+                                                              codeBuilder.invokeInstruction(i.opcode(), ClassDesc.of(\"Bar\"),\n+                                                                                            i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+                                                  else codeBuilder.with(e);\n+                                              }});\n+                                          }\n+                                          else\n+                                          methodBuilder.with(me);\n+                                      }\n+                                  });\n+                              }\n+                      else\n+                      classBuilder.with(ce);\n+                  }\n+              });\n+        \/\/ @end\n+    }\n+\n+    void codeRelabeling(ClassModel classModel) {\n+        \/\/ @start region=\"codeRelabeling\"\n+        byte[] newBytes = classModel.transform(\n+                ClassTransform.transformingMethodBodies(\n+                        CodeTransform.ofStateful(CodeRelabeler::of)));\n+        \/\/ @end\n+    }\n+\n+    \/\/ @start region=\"classInstrumentation\"\n+    byte[] classInstrumentation(ClassModel target, ClassModel instrumentor, Predicate<MethodModel> instrumentedMethodsFilter) {\n+        var instrumentorCodeMap = instrumentor.methods().stream()\n+                                              .filter(instrumentedMethodsFilter)\n+                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElse(null)));\n+        var targetFieldNames = target.fields().stream().map(f -> f.fieldName().stringValue()).collect(Collectors.toSet());\n+        var targetMethods = target.methods().stream().map(m -> m.methodName().stringValue() + m.methodType().stringValue()).collect(Collectors.toSet());\n+        var instrumentorClassRemapper = ClassRemapper.of(Map.of(instrumentor.thisClass().asSymbol(), target.thisClass().asSymbol()));\n+        return target.transform(\n+                ClassTransform.transformingMethods(\n+                        instrumentedMethodsFilter,\n+                        (mb, me) -> {\n+                            if (me instanceof CodeModel targetCodeModel) {\n+                                var mm = targetCodeModel.parent().get();\n+                                \/\/instrumented methods code is taken from instrumentor\n+                                mb.transformCode(instrumentorCodeMap.get(mm.methodName().stringValue() + mm.methodType().stringValue()),\n+                                        \/\/all references to the instrumentor class are remapped to target class\n+                                        instrumentorClassRemapper.asCodeTransform()\n+                                        .andThen((codeBuilder, instrumentorCodeElement) -> {\n+                                            \/\/all invocations of target methods from instrumentor are inlined\n+                                            if (instrumentorCodeElement instanceof InvokeInstruction inv\n+                                                && target.thisClass().asInternalName().equals(inv.owner().asInternalName())\n+                                                && mm.methodName().stringValue().equals(inv.name().stringValue())\n+                                                && mm.methodType().stringValue().equals(inv.type().stringValue())) {\n+\n+                                                \/\/store stacked method parameters into locals\n+                                                var storeStack = new LinkedList<StoreInstruction>();\n+                                                int slot = 0;\n+                                                if (!mm.flags().has(AccessFlag.STATIC))\n+                                                    storeStack.add(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                for (var pt : mm.methodTypeSymbol().parameterList()) {\n+                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    storeStack.addFirst(StoreInstruction.of(tk, slot));\n+                                                    slot += tk.slotSize();\n+                                                }\n+                                                storeStack.forEach(codeBuilder::with);\n+\n+                                                \/\/inlined target locals must be shifted based on the actual instrumentor locals\n+                                                codeBuilder.block(inlinedBlockBuilder -> inlinedBlockBuilder\n+                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                        .andThen(CodeRelabeler.of())\n+                                                        .andThen((innerBuilder, shiftedTargetCode) -> {\n+                                                            \/\/returns must be replaced with jump to the end of the inlined method\n+                                                            if (shiftedTargetCode instanceof ReturnInstruction)\n+                                                                innerBuilder.goto_(inlinedBlockBuilder.breakLabel());\n+                                                            else\n+                                                                innerBuilder.with(shiftedTargetCode);\n+                                                        })));\n+                                            } else\n+                                                codeBuilder.with(instrumentorCodeElement);\n+                                        }));\n+                            } else\n+                                mb.with(me);\n+                        })\n+                .andThen(ClassTransform.endHandler(clb ->\n+                    \/\/remaining instrumentor fields and methods are injected at the end\n+                    clb.transform(instrumentor,\n+                            ClassTransform.dropping(cle ->\n+                                    !(cle instanceof FieldModel fm\n+                                            && !targetFieldNames.contains(fm.fieldName().stringValue()))\n+                                    && !(cle instanceof MethodModel mm\n+                                            && !\"<init>\".equals(mm.methodName().stringValue())\n+                                            && !targetMethods.contains(mm.methodName().stringValue() + mm.methodType().stringValue())))\n+                            \/\/and instrumentor class references remapped to target class\n+                            .andThen(instrumentorClassRemapper)))));\n+    }\n+    \/\/ @end\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -110,0 +110,2 @@\n+    private Symtab syms;\n+\n@@ -175,0 +177,1 @@\n+        syms = Symtab.instance(context);\n@@ -1636,1 +1639,3 @@\n-        if (preview.isEnabled() && preview.usesPreview(c.sourcefile)) {\n+        if (preview.isEnabled() && preview.usesPreview(c.sourcefile)\n+                \/\/ do not write PREVIEW_MINOR_VERSION for classes participating in preview\n+                && !preview.participatesInPreview(syms, c, syms.java_base.unnamedPackage)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    jdk\/classfile \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile AccessFlags.\n+ * @run junit AccessFlagsTest\n+ *\/\n+import java.util.EnumSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.AccessFlags;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.ParameterizedTest;\n+\n+class AccessFlagsTest {\n+\n+    @ParameterizedTest\n+    @EnumSource(names = { \"CLASS\", \"METHOD\", \"FIELD\" })\n+    void testRandomAccessFlagsConverions(AccessFlag.Location ctx) {\n+        IntFunction<AccessFlags> intFactory = switch (ctx) {\n+            case CLASS -> AccessFlags::ofClass;\n+            case METHOD -> AccessFlags::ofMethod;\n+            case FIELD -> AccessFlags::ofField;\n+            default -> null;\n+        };\n+        Function<AccessFlag[], AccessFlags> flagsFactory = switch (ctx) {\n+            case CLASS -> AccessFlags::ofClass;\n+            case METHOD -> AccessFlags::ofMethod;\n+            case FIELD -> AccessFlags::ofField;\n+            default -> null;\n+        };\n+\n+        var allFlags = EnumSet.allOf(AccessFlag.class);\n+        allFlags.removeIf(f -> !f.locations().contains(ctx));\n+\n+        var r = new Random(123);\n+        for (int i = 0; i < 1000; i++) {\n+            var randomFlags = allFlags.stream().filter(f -> r.nextBoolean()).toArray(AccessFlag[]::new);\n+            assertEquals(intFactory.apply(flagsFactory.apply(randomFlags).flagsMask()).flags(), Set.of(randomFlags));\n+\n+            var randomMask = r.nextInt(Short.MAX_VALUE);\n+            assertEquals(intFactory.apply(randomMask).flagsMask(), randomMask);\n+        }\n+    }\n+\n+    @Test\n+    void testInvalidFlagsUse() {\n+        assertAll(\n+            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofClass),\n+            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofField),\n+            () -> assertThrowsForInvalidFlagsUse(AccessFlags::ofMethod)\n+        );\n+    }\n+\n+    void assertThrowsForInvalidFlagsUse(Consumer<AccessFlag[]> factory) {\n+        assertThrows(IllegalArgumentException.class, () -> factory.accept(AccessFlag.values()));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AccessFlagsTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile Code Adaptation.\n+ * @run junit AdaptCodeTest\n+ *\/\n+\n+import java.lang.constant.ConstantDesc;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import helpers.ByteArrayClassLoader;\n+import helpers.TestUtil;\n+import helpers.Transforms;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+class AdaptCodeTest {\n+\n+    static final String testClassName = \"AdaptCodeTest$TestClass\";\n+    static final Path testClassPath = Paths.get(URI.create(AdaptCodeTest.class.getResource(testClassName + \".class\").toString()));\n+    private static final String THIRTEEN = \"BlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlah\";\n+    private static final String SEVEN = \"BlahBlahBlahBlahBlahBlahBlah\";\n+\n+    @Test\n+    void testNullAdaptIterator() throws Exception {\n+        ClassModel cm = Classfile.parse(testClassPath);\n+        for (ClassTransform t : Transforms.noops) {\n+            byte[] newBytes = cm.transform(t);\n+            String result = (String)\n+                    new ByteArrayClassLoader(AdaptCodeTest.class.getClassLoader(), testClassName, newBytes)\n+                            .getMethod(testClassName, \"many\")\n+                            .invoke(null, \"Blah\");\n+            assertEquals(result, THIRTEEN);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+        \"modules\/java.base\/java\/util\/AbstractCollection.class\",\n+        \"modules\/java.base\/java\/util\/PriorityQueue.class\",\n+        \"modules\/java.base\/java\/util\/ArraysParallelSortHelpers.class\"\n+    })\n+    void testNullAdaptIterator2(String path) throws Exception {\n+        FileSystem fs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        ClassModel cm = Classfile.parse(fs.getPath(path));\n+        for (ClassTransform t : Transforms.noops) {\n+            byte[] newBytes = cm.transform(t);\n+        }\n+    }\n+\n+    @Test\n+    void testSevenOfThirteenIterator() throws Exception {\n+        ClassModel cm = Classfile.parse(testClassPath);\n+\n+        var transform = ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+            switch (codeE) {\n+                case ConstantInstruction i -> {\n+                    ConstantDesc val = i.constantValue();\n+                    if ((val instanceof Integer) && ((Integer) val) == 13) {\n+                        val = 7;\n+                    }\n+                    codeB.constantInstruction(i.opcode(), val);\n+                }\n+                default -> codeB.with(codeE);\n+            }\n+        });\n+\n+        byte[] newBytes = cm.transform(transform);\n+\/\/        Files.write(Path.of(\"foo.class\"), newBytes);\n+        String result = (String)\n+                new ByteArrayClassLoader(AdaptCodeTest.class.getClassLoader(), testClassName, newBytes)\n+                        .getMethod(testClassName, \"many\")\n+                        .invoke(null, \"Blah\");\n+        assertEquals(result, SEVEN);\n+    }\n+\n+    @Test\n+    void testCopy() throws Exception {\n+        ClassModel cm = Classfile.parse(testClassPath);\n+        byte[] newBytes = Classfile.build(cm.thisClass().asSymbol(), cb -> cm.forEachElement(cb));\n+\/\/        TestUtil.writeClass(newBytes, \"TestClass.class\");\n+        String result = (String)\n+                new ByteArrayClassLoader(AdaptCodeTest.class.getClassLoader(), testClassName, newBytes)\n+                        .getMethod(testClassName, \"many\")\n+                        .invoke(null, \"Blah\");\n+        assertEquals(result, THIRTEEN);\n+    }\n+\n+    public static class TestClass {\n+        public static String many(String snip) {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i <= 13; ++i) {\n+                sb.append(snip);\n+            }\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile advanced transformations.\n+ * @run junit AdvancedTransformationsTest\n+ *\/\n+import helpers.ByteArrayClassLoader;\n+import java.util.Map;\n+import java.util.Set;\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.StackMapGenerator;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.classfile.components.CodeLocalsShifter;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static helpers.TestUtil.assertEmpty;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.LinkedList;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.impl.AbstractInstruction;\n+import jdk.internal.classfile.impl.RawBytecodeHelper;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.ReturnInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.components.CodeRelabeler;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import static java.lang.annotation.ElementType.*;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+\n+class AdvancedTransformationsTest {\n+\n+    @Test\n+    void testShiftLocals() throws Exception {\n+        try (var in = StackMapGenerator.class.getResourceAsStream(\"StackMapGenerator.class\")) {\n+            var clm = Classfile.parse(in.readAllBytes());\n+            var remapped = Classfile.parse(clm.transform((clb, cle) -> {\n+                if (cle instanceof MethodModel mm) {\n+                    clb.transformMethod(mm, (mb, me) -> {\n+                        if (me instanceof CodeModel com) {\n+                            var shifter = CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol());\n+                            mb.transformCode(com, new CodeTransform() {\n+                                @Override\n+                                public void atStart(CodeBuilder builder) {\n+                                    builder.allocateLocal(TypeKind.ReferenceType);\n+                                    builder.allocateLocal(TypeKind.LongType);\n+                                    builder.allocateLocal(TypeKind.IntType);\n+                                    builder.allocateLocal(TypeKind.DoubleType);\n+                                }\n+                                @Override\n+                                public void accept(CodeBuilder builder, CodeElement element) {\n+                                    builder.with(element);\n+                                }\n+                            }.andThen(shifter));\n+                        } else mb.with(me);\n+                    });\n+                }\n+                else\n+                    clb.with(cle);\n+            }));\n+            remapped.verify(null);\n+        }\n+    }\n+\n+    @Test\n+    void testRemapClass() throws Exception {\n+        var map = Map.of(\n+                ConstantDescs.CD_List, ClassDesc.of(\"remapped.List\"),\n+                ClassDesc.ofDescriptor(AbstractPseudoInstruction.ExceptionCatchImpl.class.descriptorString()), ClassDesc.of(\"remapped.ExceptionCatchImpl\"),\n+                ClassDesc.ofDescriptor(RawBytecodeHelper.class.descriptorString()), ClassDesc.of(\"remapped.RemappedBytecode\"),\n+                ClassDesc.ofDescriptor(StackMapGenerator.class.descriptorString()), ClassDesc.of(\"remapped.StackMapGenerator\")\n+        );\n+        try (var in = StackMapGenerator.class.getResourceAsStream(\"StackMapGenerator.class\")) {\n+            var clm = Classfile.parse(in.readAllBytes());\n+            var remapped = Classfile.parse(ClassRemapper.of(map).remapClass(clm));\n+            assertEmpty(remapped.verify(\n+                    ClassHierarchyResolver.of(Set.of(), Map.of(\n+                            ClassDesc.of(\"remapped.RemappedBytecode\"), ConstantDescs.CD_Object,\n+                            ClassDesc.ofDescriptor(RawBytecodeHelper.class.descriptorString()), ClassDesc.of(\"remapped.RemappedBytecode\")))\n+                                          .orElse(ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER)\n+                    , null)); \/\/System.out::print));\n+            remapped.fields().forEach(f -> f.findAttribute(Attributes.SIGNATURE).ifPresent(sa ->\n+                    verifySignature(f.fieldTypeSymbol(), sa.asTypeSignature())));\n+            remapped.methods().forEach(m -> m.findAttribute(Attributes.SIGNATURE).ifPresent(sa -> {\n+                    var md = m.methodTypeSymbol();\n+                    var ms = sa.asMethodSignature();\n+                    verifySignature(md.returnType(), ms.result());\n+                    var args = ms.arguments();\n+                    assertEquals(md.parameterCount(), args.size());\n+                    for (int i=0; i<args.size(); i++)\n+                        verifySignature(md.parameterType(i), args.get(i));\n+                }));\n+        }\n+    }\n+\n+    @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface FooAnno {\n+    }\n+\n+    @interface BarAnno {\n+    }\n+\n+    public static class Foo {\n+        public static Foo fooField;\n+        public static Foo fooMethod(Foo arg) {\n+            return null;\n+        }\n+\n+    };\n+    public static class Bar {};\n+\n+    @FooAnno\n+    public static record Rec(@FooAnno Foo foo) {\n+        @FooAnno\n+        public Rec(Foo foo) {\n+            this.foo = new @FooAnno Foo();\n+            Foo local @FooAnno [] = new Foo @FooAnno [0];\n+            Foo.fooField = foo;\n+            Foo.fooMethod(foo);\n+        }\n+    }\n+\n+    @Test\n+    void testRemapModule() throws Exception {\n+        var foo = ClassDesc.ofDescriptor(Foo.class.descriptorString());\n+        var bar = ClassDesc.ofDescriptor(Bar.class.descriptorString());\n+\n+        var ma = Classfile.parse(\n+                ClassRemapper.of(Map.of(foo, bar)).remapClass(\n+                        Classfile.parse(\n+                                Classfile.buildModule(\n+                                        ModuleAttribute.of(ModuleDesc.of(\"MyModule\"), mab ->\n+                                                mab.uses(foo).provides(foo, foo)))))).findAttribute(Attributes.MODULE).get();\n+        assertEquals(ma.uses().get(0).asSymbol(), bar);\n+        var provides = ma.provides().get(0);\n+        assertEquals(provides.provides().asSymbol(), bar);\n+        assertEquals(provides.providesWith().get(0).asSymbol(), bar);\n+    }\n+\n+    @Test\n+    void testRemapDetails() throws Exception {\n+        var foo = ClassDesc.ofDescriptor(Foo.class.descriptorString());\n+        var bar = ClassDesc.ofDescriptor(Bar.class.descriptorString());\n+        var fooAnno = ClassDesc.ofDescriptor(FooAnno.class.descriptorString());\n+        var barAnno = ClassDesc.ofDescriptor(BarAnno.class.descriptorString());\n+        var rec = ClassDesc.ofDescriptor(Rec.class.descriptorString());\n+\n+        var remapped = Classfile.parse(\n+                ClassRemapper.of(Map.of(foo, bar, fooAnno, barAnno)).remapClass(\n+                        Classfile.parse(\n+                                Rec.class.getResourceAsStream(Rec.class.getName() + \".class\")\n+                                        .readAllBytes())));\n+        var sb = new StringBuilder();\n+        ClassPrinter.toYaml(remapped, ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n+        String out = sb.toString();\n+        assertContains(out,\n+                \"annotation class: LAdvancedTransformationsTest$BarAnno;\",\n+                \"type: LAdvancedTransformationsTest$Bar;\",\n+                \"inner class: AdvancedTransformationsTest$Bar\",\n+                \"inner class: AdvancedTransformationsTest$BarAnno\",\n+                \"field type: LAdvancedTransformationsTest$Bar;\",\n+                \"method type: (LAdvancedTransformationsTest$Bar;)V\",\n+                \"stack map frame @0: {locals: [THIS, AdvancedTransformationsTest$Bar\",\n+                \"[{annotation class: LAdvancedTransformationsTest$BarAnno;\",\n+                \"INVOKESPECIAL, owner: AdvancedTransformationsTest$Bar\",\n+                \"ANEWARRAY, dimensions: 1, descriptor: AdvancedTransformationsTest$Bar\",\n+                \"PUTSTATIC, owner: AdvancedTransformationsTest$Bar, field name: fooField, field type: LAdvancedTransformationsTest$Bar;\",\n+                \"INVOKESTATIC, owner: AdvancedTransformationsTest$Bar, method name: fooMethod, method type: (LAdvancedTransformationsTest$Bar;)LAdvancedTransformationsTest$Bar\",\n+                \"method type: ()LAdvancedTransformationsTest$Bar;\",\n+                \"GETFIELD, owner: AdvancedTransformationsTest$Rec, field name: foo, field type: LAdvancedTransformationsTest$Bar;\");\n+    }\n+\n+    private static void assertContains(String actual, String... expected) {\n+        for (String exp : expected)\n+            assertTrue(actual.contains(exp), \"expected text: \\\"\" + exp + \"\\\" not found in:\\n\" + actual);\n+    }\n+\n+    private static void verifySignature(ClassDesc desc, Signature sig) {\n+        switch (sig) {\n+            case Signature.ClassTypeSig cts ->\n+                assertEquals(desc.descriptorString(), cts.classDesc().descriptorString());\n+            case Signature.ArrayTypeSig ats ->\n+                verifySignature(desc.componentType(), ats.componentSignature());\n+            case Signature.BaseTypeSig bts ->\n+                assertEquals(desc.descriptorString(), bts.signatureString());\n+            default -> {}\n+        }\n+    }\n+\n+    @Test\n+    void testInstrumentClass() throws Exception {\n+        var instrumentor = Classfile.parse(AdvancedTransformationsTest.class.getResourceAsStream(\"AdvancedTransformationsTest$InstrumentorClass.class\").readAllBytes());\n+        var target = Classfile.parse(AdvancedTransformationsTest.class.getResourceAsStream(\"AdvancedTransformationsTest$TargetClass.class\").readAllBytes());\n+        var instrumentedBytes = instrument(target, instrumentor, mm -> mm.methodName().stringValue().equals(\"instrumentedMethod\"));\n+        assertEmpty(Classfile.parse(instrumentedBytes).verify(null)); \/\/System.out::print));\n+        var targetClass = new ByteArrayClassLoader(AdvancedTransformationsTest.class.getClassLoader(), \"AdvancedTransformationsTest$TargetClass\", instrumentedBytes).loadClass(\"AdvancedTransformationsTest$TargetClass\");\n+        assertEquals(targetClass.getDeclaredMethod(\"instrumentedMethod\", Boolean.class).invoke(targetClass.getDeclaredConstructor().newInstance(), false), 34);\n+    }\n+\n+    public static class InstrumentorClass {\n+\n+        \/\/matching fields are mapped\n+        private String privateField;\n+        \/\/non-matching fields are added, however not initialized\n+        int instrumentorField = 8;\n+\n+        \/\/matching methods are instrumenting frames\n+        public int instrumentedMethod(Boolean instrumented) {\n+\/\/            System.out.println(\"instrumentor start\");\n+            assertEquals(privateField, \"hi\");\n+            int local = 42;\n+            instrumented = true;\n+            \/\/matching method call is inlined\n+            instrumentedMethod(instrumented);\n+            instrumentedMethod(instrumented);\n+            assertEquals(local, 42);\n+            assertEquals(privateField, \"hello\");\n+            assertEquals(instrumentorField, 0);\n+            assertEquals(insHelper(), 77);\n+\/\/            System.out.println(\"instrumentor end\");\n+            return 34;\n+        }\n+\n+        \/\/non-matching methods are added\n+        private static int insHelper() {\n+            return 77;\n+        }\n+    }\n+\n+    public static class TargetClass {\n+\n+        private String privateField = \"hi\";\n+\n+        public int instrumentedMethod(Boolean instrumented) {\n+\/\/            System.out.println(\"target called\");\n+            assertTrue(instrumented);\n+            anotherTargetMethod();\n+            privateField = \"hello\";\n+            int local = 13;\n+            return local;\n+        }\n+\n+        public void anotherTargetMethod() {\n+\/\/            System.out.println(\"anotherTargetMethod called\");\n+        }\n+    }\n+\n+    \/\/synchronized copy of instrumentation code from jdk.jfr jdk.jfr.internal.instrument.JIClassInstrumentation for testing purposes\n+    private static byte[] instrument(ClassModel target, ClassModel instrumentor, Predicate<MethodModel> instrumentedMethodsFilter) {\n+        var instrumentorCodeMap = instrumentor.methods().stream()\n+                                              .filter(instrumentedMethodsFilter)\n+                                              .collect(Collectors.toMap(mm -> mm.methodName().stringValue() + mm.methodType().stringValue(), mm -> mm.code().orElse(null)));\n+        var targetFieldNames = target.fields().stream().map(f -> f.fieldName().stringValue()).collect(Collectors.toSet());\n+        var targetMethods = target.methods().stream().map(m -> m.methodName().stringValue() + m.methodType().stringValue()).collect(Collectors.toSet());\n+        var instrumentorClassRemapper = ClassRemapper.of(Map.of(instrumentor.thisClass().asSymbol(), target.thisClass().asSymbol()));\n+        return target.transform(\n+                ClassTransform.transformingMethods(\n+                        instrumentedMethodsFilter,\n+                        (mb, me) -> {\n+                            if (me instanceof CodeModel targetCodeModel) {\n+                                var mm = targetCodeModel.parent().get();\n+                                \/\/instrumented methods code is taken from instrumentor\n+                                mb.transformCode(instrumentorCodeMap.get(mm.methodName().stringValue() + mm.methodType().stringValue()),\n+                                        \/\/all references to the instrumentor class are remapped to target class\n+                                        instrumentorClassRemapper.asCodeTransform()\n+                                        .andThen((codeBuilder, instrumentorCodeElement) -> {\n+                                            \/\/all invocations of target methods from instrumentor are inlined\n+                                            if (instrumentorCodeElement instanceof InvokeInstruction inv\n+                                                && target.thisClass().asInternalName().equals(inv.owner().asInternalName())\n+                                                && mm.methodName().stringValue().equals(inv.name().stringValue())\n+                                                && mm.methodType().stringValue().equals(inv.type().stringValue())) {\n+\n+                                                \/\/store stacked method parameters into locals\n+                                                var storeStack = new LinkedList<StoreInstruction>();\n+                                                int slot = 0;\n+                                                if (!mm.flags().has(AccessFlag.STATIC))\n+                                                    storeStack.add(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                for (var pt : mm.methodTypeSymbol().parameterList()) {\n+                                                    var tk = TypeKind.fromDescriptor(pt.descriptorString());\n+                                                    storeStack.addFirst(StoreInstruction.of(tk, slot));\n+                                                    slot += tk.slotSize();\n+                                                }\n+                                                storeStack.forEach(codeBuilder::with);\n+\n+                                                \/\/inlined target locals must be shifted based on the actual instrumentor locals\n+                                                codeBuilder.block(inlinedBlockBuilder -> inlinedBlockBuilder\n+                                                        .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())\n+                                                        .andThen(CodeRelabeler.of())\n+                                                        .andThen((innerBuilder, shiftedTargetCode) -> {\n+                                                            \/\/returns must be replaced with jump to the end of the inlined method\n+                                                            if (shiftedTargetCode instanceof ReturnInstruction)\n+                                                                innerBuilder.goto_(inlinedBlockBuilder.breakLabel());\n+                                                            else\n+                                                                innerBuilder.with(shiftedTargetCode);\n+                                                        })));\n+                                            } else\n+                                                codeBuilder.with(instrumentorCodeElement);\n+                                        }));\n+                            } else\n+                                mb.with(me);\n+                        })\n+                .andThen(ClassTransform.endHandler(clb ->\n+                    \/\/remaining instrumentor fields and methods are injected at the end\n+                    clb.transform(instrumentor,\n+                            ClassTransform.dropping(cle ->\n+                                    !(cle instanceof FieldModel fm\n+                                            && !targetFieldNames.contains(fm.fieldName().stringValue()))\n+                                    && !(cle instanceof MethodModel mm\n+                                            && !\"<init>\".equals(mm.methodName().stringValue())\n+                                            && !targetMethods.contains(mm.methodName().stringValue() + mm.methodType().stringValue())))\n+                            \/\/and instrumentor class references remapped to target class\n+                            .andThen(instrumentorClassRemapper)))));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile annotation model.\n+ * @run junit AnnotationModelTest\n+ *\/\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Attributes;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class AnnotationModelTest {\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final String testClass = \"modules\/java.base\/java\/lang\/annotation\/Target.class\";\n+    static byte[] fileBytes;\n+\n+    static {\n+        try {\n+            fileBytes = Files.readAllBytes(JRT.getPath(testClass));\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    @Test\n+    void readAnnos() {\n+        var model = Classfile.parse(fileBytes);\n+        var annotations = model.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get().annotations();\n+\n+        assertEquals(annotations.size(), 3);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationModelTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile annotations.\n+ * @run junit AnnotationTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+import jdk.internal.classfile.impl.DirectClassBuilder;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * AnnotationTest\n+ *\/\n+class AnnotationTest {\n+    enum E {C};\n+\n+    private static Map<String, Object> constants\n+            = Map.ofEntries(\n+            new AbstractMap.SimpleImmutableEntry<>(\"i\", 1),\n+            new AbstractMap.SimpleImmutableEntry<>(\"j\", 1L),\n+            new AbstractMap.SimpleImmutableEntry<>(\"s\", 1),\n+            new AbstractMap.SimpleImmutableEntry<>(\"b\", 1),\n+            new AbstractMap.SimpleImmutableEntry<>(\"f\", 1.0f),\n+            new AbstractMap.SimpleImmutableEntry<>(\"d\", 1.0d),\n+            new AbstractMap.SimpleImmutableEntry<>(\"z\", 1),\n+            new AbstractMap.SimpleImmutableEntry<>(\"c\", (int) '1'),\n+            new AbstractMap.SimpleImmutableEntry<>(\"st\", \"1\"),\n+            new AbstractMap.SimpleImmutableEntry<>(\"cl\", ClassDesc.of(\"foo.Bar\")),\n+            new AbstractMap.SimpleImmutableEntry<>(\"en\", E.C),\n+            new AbstractMap.SimpleImmutableEntry<>(\"arr\", new Object[] {1, \"1\", 1.0f})\n+    );\n+\n+    private static final List<AnnotationElement> constantElements =\n+            constants.entrySet().stream()\n+                    .map(e -> AnnotationElement.of(e.getKey(), AnnotationValue.of(e.getValue())))\n+                    .toList();\n+\n+    private static List<AnnotationElement> elements() {\n+        List<AnnotationElement> list = new ArrayList<>(constantElements);\n+        list.add(AnnotationElement.ofAnnotation(\"a\", Annotation.of(ClassDesc.of(\"Bar\"), constantElements)));\n+        return list;\n+    }\n+\n+    private static boolean assertAnno(Annotation a, String annoClassDescriptor, boolean deep) {\n+        assertEquals(a.className().stringValue(), annoClassDescriptor);\n+        assertEquals(a.elements().size(), deep ? 13 : 12);\n+        Set<String> names = new HashSet<>();\n+        for (AnnotationElement evp : a.elements()) {\n+            names.add(evp.name().stringValue());\n+            switch (evp.name().stringValue()) {\n+                case \"i\", \"j\", \"s\", \"b\", \"f\", \"d\", \"z\", \"c\", \"st\":\n+                    assertTrue (evp.value() instanceof AnnotationValue.OfConstant c);\n+                    assertEquals(((AnnotationValue.OfConstant) evp.value()).constantValue(),\n+                                 constants.get(evp.name().stringValue()));\n+                    break;\n+                case \"cl\":\n+                    assertTrue (evp.value() instanceof AnnotationValue.OfClass c\n+                                && c.className().stringValue().equals(\"Lfoo\/Bar;\"));\n+                    break;\n+                case \"en\":\n+                    assertTrue (evp.value() instanceof AnnotationValue.OfEnum c\n+                                && c.className().stringValue().equals(E.class.descriptorString()) && c.constantName().stringValue().equals(\"C\"));\n+                    break;\n+                case \"a\":\n+                    assertTrue (evp.value() instanceof AnnotationValue.OfAnnotation c\n+                                && assertAnno(c.annotation(), \"LBar;\", false));\n+                    break;\n+                case \"arr\":\n+                    assertTrue (evp.value() instanceof AnnotationValue.OfArray);\n+                    List<AnnotationValue> values = ((AnnotationValue.OfArray) evp.value()).values();\n+                    assertEquals(values.stream().map(v -> ((AnnotationValue.OfConstant) v).constant().constantValue()).collect(toSet()),\n+                                 Set.of(1, 1.0f, \"1\"));\n+                    break;\n+                default:\n+                    fail(\"Unexpected annotation element: \" + evp.name().stringValue());\n+\n+            }\n+        }\n+        assertEquals(names.size(), a.elements().size());\n+        return true;\n+    }\n+\n+    private static RuntimeVisibleAnnotationsAttribute buildAnnotationsWithCPB(ConstantPoolBuilder constantPoolBuilder) {\n+        return RuntimeVisibleAnnotationsAttribute.of(Annotation.of(constantPoolBuilder.utf8Entry(\"LAnno;\"), elements()));\n+    }\n+\n+    @Test\n+    void testAnnos() {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            ((DirectClassBuilder) cb).writeAttribute(buildAnnotationsWithCPB(cb.constantPool()));\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_void), 0, mb -> mb.with(buildAnnotationsWithCPB(mb.constantPool())));\n+            cb.withField(\"foo\", CD_int, fb -> fb.with(buildAnnotationsWithCPB(fb.constantPool())));\n+        });\n+        ClassModel cm = Classfile.parse(bytes);\n+        List<ClassElement> ces = cm.elementList();\n+        List<Annotation> annos = ces.stream()\n+                .filter(ce -> ce instanceof RuntimeVisibleAnnotationsAttribute)\n+                .map(ce -> (RuntimeVisibleAnnotationsAttribute) ce)\n+                .flatMap(a -> a.annotations().stream())\n+                .collect(toList());\n+        List<Annotation> fannos = ces.stream()\n+                                     .filter(ce -> ce instanceof FieldModel)\n+                                     .map(ce -> (FieldModel) ce)\n+                                     .flatMap(ce -> ce.elementList().stream())\n+                                     .filter(ce -> ce instanceof RuntimeVisibleAnnotationsAttribute)\n+                                     .map(ce -> (RuntimeVisibleAnnotationsAttribute) ce)\n+                                     .flatMap(am -> am.annotations().stream())\n+                                     .collect(toList());\n+        List<Annotation> mannos = ces.stream()\n+                                     .filter(ce -> ce instanceof MethodModel)\n+                                     .map(ce -> (MethodModel) ce)\n+                                     .flatMap(ce -> ce.elementList().stream())\n+                                     .filter(ce -> ce instanceof RuntimeVisibleAnnotationsAttribute)\n+                                     .map(ce -> (RuntimeVisibleAnnotationsAttribute) ce)\n+                                     .flatMap(am -> am.annotations().stream())\n+                                     .collect(toList());\n+        assertEquals(annos.size(), 1);\n+        assertEquals(mannos.size(), 1);\n+        assertEquals(fannos.size(), 1);\n+        assertAnno(annos.get(0), \"LAnno;\", true);\n+        assertAnno(mannos.get(0), \"LAnno;\", true);\n+        assertAnno(fannos.get(0), \"LAnno;\", true);\n+    }\n+\n+    \/\/ annotation default on methods\n+\n+    private static RuntimeVisibleAnnotationsAttribute buildAnnotations() {\n+        return RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.of(\"Anno\"),\n+                                                                   elements()));\n+    }\n+\n+    @Test\n+    void testAnnosNoCPB() {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            ((DirectClassBuilder) cb).writeAttribute(buildAnnotations());\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_void), 0, mb -> mb.with(buildAnnotations()));\n+            cb.withField(\"foo\", CD_int, fb -> fb.with(buildAnnotations()));\n+        });\n+        ClassModel cm = Classfile.parse(bytes);\n+        List<ClassElement> ces = cm.elementList();\n+        List<Annotation> annos = ces.stream()\n+                .filter(ce -> ce instanceof RuntimeVisibleAnnotationsAttribute)\n+                .map(ce -> (RuntimeVisibleAnnotationsAttribute) ce)\n+                .flatMap(a -> a.annotations().stream())\n+                .toList();\n+        List<Annotation> fannos = ces.stream()\n+                .filter(ce -> ce instanceof FieldModel)\n+                .map(ce -> (FieldModel) ce)\n+                .flatMap(ce -> ce.elementList().stream())\n+                .filter(ce -> ce instanceof RuntimeVisibleAnnotationsAttribute)\n+                .map(ce -> (RuntimeVisibleAnnotationsAttribute) ce)\n+                .flatMap(am -> am.annotations().stream())\n+                .toList();\n+        List<Annotation> mannos = ces.stream()\n+                .filter(ce -> ce instanceof MethodModel)\n+                .map(ce -> (MethodModel) ce)\n+                .flatMap(ce -> ce.elementList().stream())\n+                .filter(ce -> ce instanceof RuntimeVisibleAnnotationsAttribute)\n+                .map(ce -> (RuntimeVisibleAnnotationsAttribute) ce)\n+                .flatMap(am -> am.annotations().stream())\n+                .toList();\n+        assertEquals(annos.size(), 1);\n+        assertEquals(mannos.size(), 1);\n+        assertEquals(fannos.size(), 1);\n+        assertAnno(annos.get(0), \"LAnno;\", true);\n+        assertAnno(mannos.get(0), \"LAnno;\", true);\n+        assertAnno(fannos.get(0), \"LAnno;\", true);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile arrays.\n+ * @run junit ArrayTest\n+ *\/\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Iterator;\n+\n+class ArrayTest {\n+    static final String testClassName = \"ArrayTest$TestClass\";\n+    static final Path testClassPath = Paths.get(URI.create(ArrayTest.class.getResource(testClassName + \".class\").toString()));\n+\n+\n+    @Test\n+    void testArrayNew() throws Exception {\n+        ClassModel cm = Classfile.parse(testClassPath);\n+\n+        for (MethodModel mm : cm.methods()) {\n+            mm.code().ifPresent(code -> {\n+                Iterator<CodeElement> it = code.iterator();\n+                int arrayCreateCount = 1;\n+                while (it.hasNext()) {\n+                    CodeElement im = it.next();\n+                    if (im instanceof NewReferenceArrayInstruction\n+                        || im instanceof NewPrimitiveArrayInstruction\n+                        || im instanceof NewMultiArrayInstruction) {\n+                        switch (arrayCreateCount++) {\n+                            case 1: {\n+                                NewMultiArrayInstruction nai = (NewMultiArrayInstruction) im;\n+                                assertEquals(nai.opcode(), Opcode.MULTIANEWARRAY);\n+                                assertEquals(nai.arrayType().asInternalName(), \"[[[I\");\n+                                assertEquals(nai.dimensions(), 3);\n+                                break;\n+                            }\n+                            case 2: {\n+                                NewMultiArrayInstruction nai = (NewMultiArrayInstruction) im;\n+                                assertEquals(nai.opcode(), Opcode.MULTIANEWARRAY);\n+                                assertEquals(nai.arrayType().asInternalName(),\n+                                             \"[[[Ljava\/lang\/String;\");\n+                                assertEquals(nai.dimensions(), 2);\n+                                break;\n+                            }\n+                            case 3: {\n+                                NewReferenceArrayInstruction nai = (NewReferenceArrayInstruction) im;\n+                                assertEquals(nai.opcode(), Opcode.ANEWARRAY);\n+                                assertEquals(nai.componentType().asInternalName(),\n+                                             \"java\/lang\/String\");\n+                                break;\n+                            }\n+                            case 4: {\n+                                NewPrimitiveArrayInstruction nai = (NewPrimitiveArrayInstruction) im;\n+                                assertEquals(nai.opcode(), Opcode.NEWARRAY);\n+                                assertEquals(nai.typeKind(), TypeKind.DoubleType);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                if (arrayCreateCount > 1) {\n+                    assertEquals(arrayCreateCount, 5);\n+                }\n+            });\n+        }\n+    }\n+\n+    public static class TestClass {\n+        public static void makeArrays() {\n+            int[][][] ma = new int[10][20][30];\n+            String[][][] pa = new String[10][20][];\n+            String[] sa = new String[5];\n+            double[] da = new double[3];\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ArrayTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile bootstrap methods.\n+ * @run junit BSMTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.internal.classfile.*;\n+import helpers.ByteArrayClassLoader;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BSMTest {\n+    static final String testClassName = \"BSMTest$SomeClass\";\n+    static final Path testClassPath = Paths.get(URI.create(ArrayTest.class.getResource(testClassName + \".class\").toString()));\n+    private static final String THIRTEEN = \"BlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlah\";\n+    private static final String SEVEN = \"BlahBlahBlahBlahBlahBlahBlah\";\n+    private static final String TWENTY = \"BlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlahBlah\";\n+    private static final String TYPE = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/String;\";\n+\n+    @Test\n+    void testSevenOfThirteenIterator() throws Exception {\n+        ClassModel cm = Classfile.parse(testClassPath);\n+        byte[] newBytes = cm.transform((cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                cb.transformMethod(mm, (mb, me) -> {\n+                    if (me instanceof CodeModel xm) {\n+                        mb.transformCode(xm, (codeB, codeE) -> {\n+                            switch (codeE) {\n+                                case ConstantInstruction ci -> {\n+                                    ConstantPoolBuilder cpb = codeB.constantPool();\n+\n+                                    List<LoadableConstantEntry> staticArgs = new ArrayList<>(2);\n+                                    staticArgs.add(cpb.stringEntry(SEVEN));\n+                                    staticArgs.add(cpb.stringEntry(THIRTEEN));\n+\n+                                    MemberRefEntry memberRefEntry = cpb.methodRefEntry(ClassDesc.of(\"BSMTest\"), \"bootstrap\", MethodTypeDesc.ofDescriptor(TYPE));\n+                                    MethodHandleEntry methodHandleEntry = cpb.methodHandleEntry(6, memberRefEntry);\n+                                    BootstrapMethodEntry bme = cpb.bsmEntry(methodHandleEntry, staticArgs);\n+                                    ConstantDynamicEntry cde = cpb.constantDynamicEntry(bme, cpb.natEntry(\"name\", CD_String));\n+\n+                                    codeB.constantInstruction(Opcode.LDC, cde.constantValue());\n+                                }\n+                                default -> codeB.with(codeE);\n+                            }\n+                        });\n+                    }\n+                    else\n+                        mb.with(me);\n+                });\n+            }\n+            else\n+                cb.with(ce);\n+        });\n+        String result = (String)\n+                new ByteArrayClassLoader(BSMTest.class.getClassLoader(), testClassName, newBytes)\n+                        .getMethod(testClassName, \"many\")\n+                        .invoke(null, new Object[0]);\n+        assertEquals(result, TWENTY);\n+    }\n+\n+    public static String bootstrap(MethodHandles.Lookup lookup, String name, Class<?> clz, Object arg1, Object arg2) {\n+        return (String)arg1 + (String)arg2;\n+    }\n+\n+    public static class SomeClass {\n+        public static String many() {\n+            String s = \"Foo\";\n+            return s;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/BSMTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile complex basic blocks affecting SM generator.\n+ * @run junit BasicBlockTest\n+ *\/\n+import java.io.InputStream;\n+import java.io.IOException;\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+class BasicBlockTest {\n+\n+       public void npeInResolveMystery() {\n+            int i=0; Object key;\n+            Object[] a= new Object[0];\n+            for (; i < 0; i++) {\n+                if ((key = a[i]) == null) {}\n+            }\n+        }\n+\n+    void exponentialComplexityInJointNeedLocalPartial(boolean a) {\n+        while (a) {\n+            if ((a || a) && (a || a) && (a || a) && (a || a) && (a || a) && (a || a)) {} else\n+            if ((a || a) && (a || a) && (a || a) && (a || a) && (a || a) && (a || a)) {} else\n+            if ((a || a) && (a || a) && (a || a) && (a || a) && (a || a) && (a || a)) {} else\n+            if ((a || a) && (a || a) && (a || a) && (a || a) && (a || a) && (a || a)) {} else\n+            if ((a || a) && (a || a) && (a || a) && (a || a) && (a || a) && (a || a)) {} else\n+            if ((a || a) && (a || a) && (a || a) && (a || a) && (a || a) && (a || a)) {}\n+        }\n+    }\n+\n+    @Test\n+    void testPatternsCausingBasicBlockTroubles() throws IOException {\n+        try (InputStream in = BasicBlockTest.class.getResourceAsStream(\"BasicBlockTest.class\")) {\n+            var classModel = Classfile.parse(in.readAllBytes());\n+            Classfile.build(classModel.thisClass().asSymbol(), cb -> classModel.forEachElement(cb));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/BasicBlockTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile builder blocks.\n+ * @run junit BuilderBlockTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import helpers.ByteArrayClassLoader;\n+import jdk.internal.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.impl.LabelImpl;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+\/**\n+ * BuilderBlockTest\n+ *\/\n+class BuilderBlockTest {\n+\n+    static final String testClassName = \"AdaptCodeTest$TestClass\";\n+    static final Path testClassPath = Paths.get(\"target\/test-classes\/\" + testClassName + \".class\");\n+\n+    @Test\n+    void testStartEnd() throws Exception {\n+        \/\/ Ensure that start=0 at top level, end is undefined until code is done, then end=1\n+        Label startEnd[] = new Label[2];\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_void), 0,\n+                          mb -> mb.withCode(xb -> {\n+                              startEnd[0] = xb.startLabel();\n+                              startEnd[1] = xb.endLabel();\n+                              xb.returnInstruction(TypeKind.VoidType);\n+                              assertEquals(((LabelImpl) startEnd[0]).getContextInfo(), 0);\n+                              assertEquals(((LabelImpl) startEnd[1]).getContextInfo(), -1);\n+                          }));\n+        });\n+\n+        assertEquals(((LabelImpl) startEnd[0]).getContextInfo(), 0);\n+        assertEquals(((LabelImpl) startEnd[1]).getContextInfo(), 1);\n+    }\n+\n+    @Test\n+    void testStartEndBlock() throws Exception {\n+        Label startEnd[] = new Label[4];\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_void), 0,\n+                          mb -> mb.withCode(xb -> {\n+                              startEnd[0] = xb.startLabel();\n+                              startEnd[1] = xb.endLabel();\n+                              xb.nopInstruction();\n+                              xb.block(xxb -> {\n+                                  startEnd[2] = xxb.startLabel();\n+                                  startEnd[3] = xxb.endLabel();\n+                                  xxb.nopInstruction();\n+                              });\n+                              xb.returnInstruction(TypeKind.VoidType);\n+                          }));\n+        });\n+\n+        assertEquals(((LabelImpl) startEnd[0]).getContextInfo(), 0);\n+        assertEquals(((LabelImpl) startEnd[1]).getContextInfo(), 3);\n+        assertEquals(((LabelImpl) startEnd[2]).getContextInfo(), 1);\n+        assertEquals(((LabelImpl) startEnd[3]).getContextInfo(), 2);\n+    }\n+\n+    @Test\n+    void testIfThenReturn() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(xb -> xb.iload(0)\n+                                                    .ifThen(xxb -> xxb.iconst_1().returnInstruction(TypeKind.IntType))\n+                                                    .iconst_2()\n+                                                    .returnInstruction(TypeKind.IntType)));\n+        });\n+\n+        Method fooMethod = new ByteArrayClassLoader(BuilderBlockTest.class.getClassLoader(), \"Foo\", bytes)\n+                .getMethod(\"Foo\", \"foo\");\n+        assertEquals(fooMethod.invoke(null, 3), 1);\n+        assertEquals(fooMethod.invoke(null, 0), 2);\n+\n+    }\n+\n+    @Test\n+    void testIfThenElseReturn() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(xb -> xb.iload(0)\n+                                                    .ifThenElse(xxb -> xxb.iconst_1().returnInstruction(TypeKind.IntType),\n+                                                                xxb -> xxb.iconst_2().returnInstruction(TypeKind.IntType))));\n+        });\n+\n+        Method fooMethod = new ByteArrayClassLoader(BuilderBlockTest.class.getClassLoader(), \"Foo\", bytes)\n+                .getMethod(\"Foo\", \"foo\");\n+        assertEquals(fooMethod.invoke(null, 3), 1);\n+        assertEquals(fooMethod.invoke(null, 0), 2);\n+\n+    }\n+\n+    @Test\n+    void testIfThenBadOpcode()  {\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int, CD_int),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    mb -> mb.withCode(xb -> {\n+                        xb.iload(0);\n+                        xb.iload(1);\n+                        assertThrows(IllegalArgumentException.class, () -> {\n+                            xb.ifThen(\n+                                    Opcode.GOTO,\n+                                    xxb -> xxb.iconst_1().istore(2));\n+                        });\n+                        xb.iload(2);\n+                        xb.ireturn();\n+                    }));\n+        });\n+    }\n+\n+    @Test\n+    void testIfThenElseImplicitBreak() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(xb -> xb.iload(0)\n+                                                    .ifThenElse(xxb -> xxb.iconst_1().istore(2),\n+                                                                xxb -> xxb.iconst_2().istore(2))\n+                                                    .iload(2)\n+                                                    .ireturn()));\n+        });\n+\n+        Method fooMethod = new ByteArrayClassLoader(BuilderBlockTest.class.getClassLoader(), \"Foo\", bytes)\n+                .getMethod(\"Foo\", \"foo\");\n+        assertEquals(fooMethod.invoke(null, 3), 1);\n+        assertEquals(fooMethod.invoke(null, 0), 2);\n+\n+    }\n+\n+    @Test\n+    void testIfThenElseExplicitBreak() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    mb -> mb.withCode(xb -> xb.iload(0)\n+                            .ifThenElse(xxb -> xxb.iconst_1().istore(2).goto_(xxb.breakLabel()),\n+                                    xxb -> xxb.iconst_2().istore(2).goto_(xxb.breakLabel()))\n+                            .iload(2)\n+                            .ireturn()));\n+        });\n+\n+        Method fooMethod = new ByteArrayClassLoader(BuilderBlockTest.class.getClassLoader(), \"Foo\", bytes)\n+                .getMethod(\"Foo\", \"foo\");\n+        assertEquals(fooMethod.invoke(null, 3), 1);\n+        assertEquals(fooMethod.invoke(null, 0), 2);\n+    }\n+\n+    @Test\n+    void testIfThenElseOpcode() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int, CD_int),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    mb -> mb.withCode(xb ->\n+                            xb.iload(0)\n+                            .iload(1)\n+                            .ifThenElse(\n+                                    Opcode.IF_ICMPLT,\n+                                    xxb -> xxb.iconst_1().istore(2),\n+                                    xxb -> xxb.iconst_2().istore(2))\n+                            .iload(2)\n+                            .ireturn()));\n+        });\n+\n+        Method fooMethod = new ByteArrayClassLoader(BuilderBlockTest.class.getClassLoader(), \"Foo\", bytes)\n+                .getMethod(\"Foo\", \"foo\");\n+        assertEquals(fooMethod.invoke(null, 1, 10), 1);\n+        assertEquals(fooMethod.invoke(null, 9, 10), 1);\n+        assertEquals(fooMethod.invoke(null, 10, 10), 2);\n+        assertEquals(fooMethod.invoke(null, 11, 10), 2);\n+    }\n+\n+    @Test\n+    void testIfThenElseBadOpcode()  {\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withMethod(\"foo\", MethodTypeDesc.of(CD_int, CD_int, CD_int),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                    mb -> mb.withCode(xb -> {\n+                        xb.iload(0);\n+                        xb.iload(1);\n+                        assertThrows(IllegalArgumentException.class, () -> {\n+                            xb.ifThenElse(\n+                                    Opcode.GOTO,\n+                                    xxb -> xxb.iconst_1().istore(2),\n+                                    xxb -> xxb.iconst_2().istore(2));\n+                        });\n+                        xb.iload(2);\n+                        xb.ireturn();\n+                    }));\n+        });\n+    }\n+\n+    @Test\n+    void testAllocateLocal() {\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), Classfile.ACC_STATIC,\n+                          mb -> mb.withCode(xb -> {\n+                              int slot1 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot2 = xb.allocateLocal(TypeKind.LongType);\n+                              int slot3 = xb.allocateLocal(TypeKind.IntType);\n+\n+                              assertEquals(slot1, 4);\n+                              assertEquals(slot2, 5);\n+                              assertEquals(slot3, 7);\n+                          }));\n+        });\n+    }\n+\n+    @Test\n+    void testAllocateLocalBlock() {\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), Classfile.ACC_STATIC,\n+                          mb -> mb.withCode(xb -> {\n+                              xb.block(bb -> {\n+                                  int slot1 = bb.allocateLocal(TypeKind.IntType);\n+                                  int slot2 = bb.allocateLocal(TypeKind.LongType);\n+                                  int slot3 = bb.allocateLocal(TypeKind.IntType);\n+\n+                                  assertEquals(slot1, 4);\n+                                  assertEquals(slot2, 5);\n+                                  assertEquals(slot3, 7);\n+                              });\n+                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              assertEquals(slot4, 4);\n+                          }));\n+        });\n+    }\n+\n+    @Test\n+    void testAllocateLocalIfThen() {\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), Classfile.ACC_STATIC,\n+                          mb -> mb.withCode(xb -> {\n+                              xb.iconst_0();\n+                              xb.ifThenElse(bb -> {\n+                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot2 = bb.allocateLocal(TypeKind.LongType);\n+                                                int slot3 = bb.allocateLocal(TypeKind.IntType);\n+\n+                                                assertEquals(slot1, 4);\n+                                                assertEquals(slot2, 5);\n+                                                assertEquals(slot3, 7);\n+                                            },\n+                                            bb -> {\n+                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n+\n+                                                assertEquals(slot1, 4);\n+                                            });\n+                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              assertEquals(slot4, 4);\n+                              xb.return_();\n+                          }));\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile builder parameters.\n+ * @run junit BuilderParamTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * BuilderParamTest\n+ *\/\n+class BuilderParamTest {\n+    @Test\n+    void testDirectBuilder() {\n+\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), 0,\n+                          mb -> mb.withCode(xb -> {\n+                assertEquals(xb.receiverSlot(), 0);\n+                assertEquals(xb.parameterSlot(0), 1);\n+                assertEquals(xb.parameterSlot(1), 2);\n+                assertEquals(xb.parameterSlot(2), 4);\n+            }));\n+        });\n+\n+        Classfile.build(ClassDesc.of(\"Foo\"), cb -> {\n+            cb.withMethod(\"foo\", MethodTypeDesc.ofDescriptor(\"(IJI)V\"), ACC_STATIC,\n+                          mb -> mb.withCode(xb -> {\n+                              assertEquals(xb.parameterSlot(0), 0);\n+                              assertEquals(xb.parameterSlot(1), 1);\n+                              assertEquals(xb.parameterSlot(2), 3);\n+                          }));\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/BuilderParamTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile builder blocks.\n+ * @run junit BuilderTryCatchTest\n+ *\/\n+\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CompoundElement;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static java.lang.constant.ConstantDescs.CD_Double;\n+import static java.lang.constant.ConstantDescs.CD_Integer;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+\n+class BuilderTryCatchTest {\n+\n+    static final ClassDesc CD_IOOBE = IndexOutOfBoundsException.class.describeConstable().get();\n+    static final ClassDesc CD_NPE = NullPointerException.class.describeConstable().get();\n+    static final MethodTypeDesc MTD_String = MethodType.methodType(String.class).describeConstable().get();\n+\n+    @Test\n+    void testTryCatchCatchAll() throws Throwable {\n+        byte[] bytes = generateTryCatchMethod(catchBuilder -> {\n+            catchBuilder.catching(CD_IOOBE, tb -> {\n+                tb.pop();\n+\n+                tb.constantInstruction(Opcode.LDC, \"IndexOutOfBoundsException\");\n+                tb.returnInstruction(TypeKind.ReferenceType);\n+            }).catchingAll(tb -> {\n+                tb.pop();\n+\n+                tb.constantInstruction(Opcode.LDC, \"any\");\n+                tb.returnInstruction(TypeKind.ReferenceType);\n+            });\n+        });\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle main = lookup.findStatic(lookup.lookupClass(), \"main\",\n+                MethodType.methodType(String.class, String[].class));\n+\n+        assertEquals(main.invoke(new String[]{\"BODY\"}), \"BODY\");\n+        assertEquals(main.invoke(new String[]{}), \"IndexOutOfBoundsException\");\n+        assertEquals(main.invoke(null), \"any\");\n+    }\n+\n+    @Test\n+    void testTryCatchCatchAllReachable() throws Throwable {\n+        byte[] bytes = generateTryCatchMethod(catchBuilder -> {\n+            catchBuilder.catching(CD_IOOBE, tb -> {\n+                tb.pop();\n+\n+                tb.constantInstruction(Opcode.LDC, \"IndexOutOfBoundsException\");\n+                tb.astore(1);\n+            }).catchingAll(tb -> {\n+                tb.pop();\n+\n+                tb.constantInstruction(Opcode.LDC, \"any\");\n+                tb.astore(1);\n+            });\n+        });\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle main = lookup.findStatic(lookup.lookupClass(), \"main\",\n+                MethodType.methodType(String.class, String[].class));\n+\n+        assertEquals(main.invoke(new String[]{\"BODY\"}), \"BODY\");\n+        assertEquals(main.invoke(new String[]{}), \"IndexOutOfBoundsException\");\n+        assertEquals(main.invoke(null), \"any\");\n+    }\n+\n+    @Test\n+    void testTryMutliCatchReachable() throws Throwable {\n+        byte[] bytes = generateTryCatchMethod(catchBuilder ->\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            }));\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle main = lookup.findStatic(lookup.lookupClass(), \"main\",\n+                MethodType.methodType(String.class, String[].class));\n+\n+        assertTrue(main.invoke(new String[]{}).toString().contains(\"IndexOutOfBoundsException\"));\n+        assertTrue(main.invoke(null).toString().contains(\"NullPointerException\"));\n+    }\n+\n+    @Test\n+    void testTryCatch() throws Throwable {\n+        byte[] bytes = generateTryCatchMethod(catchBuilder -> {\n+            catchBuilder.catching(CD_IOOBE, tb -> {\n+                tb.pop();\n+\n+                tb.constantInstruction(Opcode.LDC, \"IndexOutOfBoundsException\");\n+                tb.returnInstruction(TypeKind.ReferenceType);\n+            });\n+        });\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle main = lookup.findStatic(lookup.lookupClass(), \"main\",\n+                MethodType.methodType(String.class, String[].class));\n+\n+        assertEquals(main.invoke(new String[]{\"BODY\"}), \"BODY\");\n+        assertEquals(main.invoke(new String[]{}), \"IndexOutOfBoundsException\");\n+        assertThrows(NullPointerException.class,\n+                () -> main.invoke(null));\n+    }\n+\n+    @Test\n+    void testTryCatchAll() throws Throwable {\n+        byte[] bytes = generateTryCatchMethod(catchBuilder -> {\n+            catchBuilder.catchingAll(tb -> {\n+                tb.pop();\n+\n+                tb.constantInstruction(Opcode.LDC, \"any\");\n+                tb.returnInstruction(TypeKind.ReferenceType);\n+            });\n+        });\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle main = lookup.findStatic(lookup.lookupClass(), \"main\",\n+                MethodType.methodType(String.class, String[].class));\n+\n+        assertEquals(main.invoke(new String[]{\"BODY\"}), \"BODY\");\n+        assertEquals(main.invoke(new String[]{}), \"any\");\n+        assertEquals(main.invoke(null), \"any\");\n+    }\n+\n+    @Test\n+    void testTryEmptyCatch() {\n+        byte[] bytes = generateTryCatchMethod(catchBuilder -> {});\n+\n+        boolean anyGotos = Classfile.parse(bytes).methods().stream()\n+                .flatMap(mm -> mm.code().stream())\n+                .flatMap(CompoundElement::elementStream)\n+                .anyMatch(codeElement ->\n+                        (codeElement instanceof BranchInstruction bi && bi.opcode() == Opcode.GOTO) ||\n+                                (codeElement instanceof ExceptionCatch));\n+        assertFalse(anyGotos);\n+    }\n+\n+    @Test\n+    void testEmptyTry() {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+            cb.withMethod(\"main\", MethodTypeDesc.of(CD_String, CD_String.arrayType()),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                        mb.withCode(xb -> {\n+                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            xb.constantInstruction(\"S\");\n+                            xb.astore(stringSlot);\n+\n+                            assertThrows(IllegalStateException.class, () -> {\n+                                xb.trying(tb -> {\n+                                }, catchBuilder -> {\n+                                    fail();\n+\n+                                    catchBuilder.catchingAll(tb -> {\n+                                        tb.pop();\n+\n+                                        tb.constantInstruction(Opcode.LDC, \"any\");\n+                                        tb.returnInstruction(TypeKind.ReferenceType);\n+                                    });\n+                                });\n+                            });\n+\n+                            xb.aload(stringSlot);\n+                            xb.returnInstruction(TypeKind.ReferenceType);\n+                        });\n+                    });\n+        });\n+    }\n+\n+    @Test\n+    void testLocalAllocation() throws Throwable {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+            cb.withMethod(\"main\", MethodTypeDesc.of(CD_String, CD_String.arrayType()),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                        mb.withCode(xb -> {\n+                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            xb.constantInstruction(\"S\");\n+                            xb.astore(stringSlot);\n+\n+                            xb.trying(tb -> {\n+                                int intSlot = tb.allocateLocal(TypeKind.IntType);\n+\n+                                tb.aload(0);\n+                                tb.constantInstruction(0);\n+                                \/\/ IndexOutOfBoundsException\n+                                tb.aaload();\n+                                \/\/ NullPointerException\n+                                tb.invokevirtual(CD_String, \"length\", MethodType.methodType(int.class).describeConstable().get());\n+                                tb.istore(intSlot);\n+\n+                                tb.iload(intSlot);\n+                                tb.invokestatic(CD_Integer, \"toString\", MethodType.methodType(String.class, int.class).describeConstable().get());\n+                                tb.astore(stringSlot);\n+                            }, catchBuilder -> {\n+                                catchBuilder.catching(CD_IOOBE, tb -> {\n+                                    tb.pop();\n+\n+                                    int doubleSlot = tb.allocateLocal(TypeKind.DoubleType);\n+                                    tb.constantInstruction(Math.PI);\n+                                    tb.dstore(doubleSlot);\n+\n+                                    tb.dload(doubleSlot);\n+                                    tb.invokestatic(CD_Double, \"toString\", MethodType.methodType(String.class, double.class).describeConstable().get());\n+                                    tb.astore(stringSlot);\n+                                }).catchingAll(tb -> {\n+                                    tb.pop();\n+\n+                                    int refSlot = tb.allocateLocal(TypeKind.ReferenceType);\n+                                    tb.constantInstruction(\"REF\");\n+                                    tb.astore(refSlot);\n+\n+                                    tb.aload(refSlot);\n+                                    tb.invokevirtual(CD_String, \"toString\", MTD_String);\n+                                    tb.astore(stringSlot);\n+                                });\n+                            });\n+\n+                            xb.aload(stringSlot);\n+                            xb.returnInstruction(TypeKind.ReferenceType);\n+                        });\n+                    });\n+        });\n+\n+        Files.write(Path.of(\"x.class\"), bytes);\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle main = lookup.findStatic(lookup.lookupClass(), \"main\",\n+                MethodType.methodType(String.class, String[].class));\n+\n+        assertEquals(main.invoke(new String[]{\"BODY\"}), Integer.toString(4));\n+        assertEquals(main.invoke(new String[]{}), Double.toString(Math.PI));\n+        assertEquals(main.invoke(null), \"REF\");\n+    }\n+\n+    static byte[] generateTryCatchMethod(Consumer<CodeBuilder.CatchBuilder> c) {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+            cb.withMethod(\"main\", MethodTypeDesc.of(CD_String, CD_String.arrayType()),\n+                    AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(), mb -> {\n+                        mb.withCode(xb -> {\n+                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            xb.constantInstruction(\"S\");\n+                            xb.astore(stringSlot);\n+\n+                            xb.trying(tb -> {\n+                                tb.aload(0);\n+                                tb.constantInstruction(0);\n+                                \/\/ IndexOutOfBoundsException\n+                                tb.aaload();\n+                                \/\/ NullPointerException\n+                                tb.invokevirtual(CD_String, \"toString\", MTD_String);\n+                                tb.astore(stringSlot);\n+                            }, c);\n+\n+                            xb.aload(stringSlot);\n+                            xb.returnInstruction(TypeKind.ReferenceType);\n+                        });\n+                    });\n+        });\n+\n+        return bytes;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * @test\n+ * @summary Testing Classfile ClassEntry lists methods.\n+ * @run junit ClassEntryTest\n+ *\/\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClassEntryTest {\n+\n+    static final List<ClassEntry> additionCE = List.copyOf(ClassEntry.addingSymbols(List.of(), new ClassDesc[] {ConstantDescs.CD_Void, ConstantDescs.CD_Enum, ConstantDescs.CD_Class}));\n+    static final List<ClassDesc> additionCD = List.of(ConstantDescs.CD_Void, ConstantDescs.CD_Enum, ConstantDescs.CD_Class);\n+    static final List<ClassEntry> base = List.copyOf(additionCE);\n+\n+    @Test\n+    void testNPECombos() {\n+        \/\/ NPE on first param\n+        try {\n+            ClassEntry.adding(null, additionCE);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.adding(null, additionCE.get(1), additionCE.get(2));\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.addingSymbols(null, additionCD);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.addingSymbols(null, additionCD.get(1), additionCD.get(2));\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        \/\/ NPE on second param\n+        try {\n+            ClassEntry.adding(base, (List<ClassEntry>)null);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.adding(base, (ClassEntry[])null);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.addingSymbols(base, (List<ClassDesc>)null);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.addingSymbols(base, (ClassDesc[])null);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+    }\n+\n+    @Test\n+    void combine() {\n+        List<ClassEntry> expected = new ArrayList<>(base);\n+        expected.addAll(additionCE);\n+        expected = List.copyOf(expected);\n+        \/\/ Ensure inputs are equivalent before using 'expected' as a common result\n+        assertTrue(listCompare(additionCE, ClassEntry.addingSymbols(List.<ClassEntry>of(), additionCD)));\n+        assertTrue(listCompare(expected, ClassEntry.adding(base, additionCE)));\n+        assertTrue(listCompare(expected, ClassEntry.adding(base, additionCE.toArray(new ClassEntry[0]))));\n+        assertTrue(listCompare(expected, ClassEntry.addingSymbols(base, additionCD)));\n+        assertTrue(listCompare(expected, ClassEntry.addingSymbols(base, additionCD.toArray(new ClassDesc[0]))));\n+    }\n+\n+    boolean listCompare(List<ClassEntry> a, List<ClassEntry> b) {\n+        if (a.size() != b.size()) return false;\n+\n+        for (int i = 0; i < a.size(); i++) {\n+            ClassEntry ca = a.get(i);\n+            ClassEntry cb = b.get(i);\n+            if (!ca.asSymbol().equals(cb.asSymbol())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Test\n+    void throwOnNullAdditions() {\n+        \/\/ NPE when adding a null element\n+        ArrayList<ClassEntry> withNullElement = new ArrayList<ClassEntry>(additionCE);\n+        withNullElement.add(null);\n+        try {\n+            ClassEntry.adding(base, withNullElement);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.adding(base, withNullElement.toArray(new ClassEntry[0]));\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        ArrayList<ClassDesc> withNullElementCD = new ArrayList<ClassDesc>(additionCD);\n+        withNullElementCD.add(null);\n+        try {\n+            ClassEntry.addingSymbols(base, withNullElementCD);\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+        try {\n+            ClassEntry.addingSymbols(base, withNullElementCD.toArray(new ClassDesc[0]));\n+            fail(\"NPE expected\");\n+        } catch(NullPointerException e) { }\n+    }\n+\n+    @Test\n+    void addEmpty() {\n+        assertEquals(base, ClassEntry.adding(base, List.of()));\n+        assertEquals(base, ClassEntry.adding(base, new ClassEntry[0]));\n+        assertEquals(base, ClassEntry.addingSymbols(base, List.of()));\n+        assertEquals(base, ClassEntry.addingSymbols(base, new ClassDesc[0]));\n+    }\n+\n+    @Test\n+    void dedup() {\n+        {\n+            List<ClassEntry> duplicates = ClassEntry.adding(base, base);\n+            List<ClassEntry> dedup = ClassEntry.deduplicate(duplicates);\n+            boolean result = listCompare(base, dedup);\n+            if (!result) {\n+                fail(\"Different: \" + Arrays.toString(base.toArray())+ \" : \" + Arrays.toString(dedup.toArray()));\n+            }\n+            assertTrue(result);\n+        }\n+        {\n+            List<ClassEntry> duplicates = ClassEntry.addingSymbols(List.of(), additionCD);\n+            duplicates = ClassEntry.addingSymbols(duplicates, additionCD);\n+            List<ClassEntry> dedup = ClassEntry.deduplicate(duplicates);\n+            boolean result = listCompare(base, dedup);\n+            if (!result) {\n+                fail(\"Different: \" + Arrays.toString(base.toArray())+ \" : \" + Arrays.toString(dedup.toArray()));\n+            }\n+            assertTrue(result);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ClassEntryTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile class hierarchy resolution SPI.\n+ * @run junit ClassHierarchyInfoTest\n+ *\/\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Set;\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.impl.Util;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClassHierarchyInfoTest {\n+\n+    @Test\n+    public void testProduceInvalidStackMaps() throws Exception {\n+        assertThrows(VerifyError.class, () -> transformAndVerify(className -> null));\n+    }\n+\n+    @Test\n+    void testProvideCustomClassHierarchy() throws Exception {\n+        transformAndVerify(ClassHierarchyResolver.of(\n+                Set.of(ConstantDescs.CD_Set,\n+                       ConstantDescs.CD_Collection),\n+                Map.of(ClassDesc.of(\"java.util.HashMap$TreeNode\"), ClassDesc.of(\"java.util.HashMap$Node\"),\n+                        ClassDesc.of(\"java.util.HashMap$Node\"), ConstantDescs.CD_Object,\n+                        ClassDesc.of(\"java.util.HashMap$Values\"), ConstantDescs.CD_Object)));\n+    }\n+\n+    @Test\n+    void testBreakDefaulClassHierarchy() throws Exception {\n+        assertThrows(VerifyError.class, () ->\n+        transformAndVerify(ClassHierarchyResolver.of(\n+                Set.of(),\n+                Map.of(ClassDesc.of(\"java.util.HashMap$Node\"), ClassDesc.of(\"java.util.HashMap$TreeNode\"))).orElse(ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER))\n+        );\n+    }\n+\n+    @Test\n+    void testProvideCustomClassStreamResolver() throws Exception {\n+        var fs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        transformAndVerify(ClassHierarchyResolver.ofCached(classDesc -> {\n+            try {\n+                return Files.newInputStream(fs.getPath(\"modules\/java.base\/\" + Util.toInternalName(classDesc) + \".class\"));\n+            } catch (IOException ioe) {\n+                throw new AssertionError(ioe);\n+            }\n+        }));\n+    }\n+\n+    void transformAndVerify(ClassHierarchyResolver res) throws Exception {\n+        Path path = FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\/HashMap.class\");\n+        var classModel = Classfile.parse(path, Classfile.Option.classHierarchyResolver(res));\n+        byte[] newBytes = classModel.transform(\n+                (clb, cle) -> {\n+                    if (cle instanceof MethodModel mm) {\n+                        clb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel cm) {\n+                                mb.withCode(cob -> cm.forEachElement(cob));\n+                            }\n+                            else\n+                                mb.with(me);\n+                        });\n+                    }\n+                    else\n+                        clb.with(cle);\n+                });\n+        var errors = Classfile.parse(newBytes).verify(null);\n+        if (!errors.isEmpty()) throw errors.iterator().next();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ClassHierarchyInfoTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,847 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile ClassPrinter.\n+ * @run junit ClassPrinterTest\n+ *\/\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.Optional;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClassPrinterTest {\n+\n+    ClassModel getClassModel() {\n+        return Classfile.parse(Classfile.build(ClassDesc.of(\"Foo\"), clb ->\n+            clb.withVersion(61, 0)\n+                .withFlags(Classfile.ACC_PUBLIC)\n+                .with(SourceFileAttribute.of(\"Foo.java\"))\n+                .withSuperclass(ClassDesc.of(\"Boo\"))\n+                .withInterfaceSymbols(ClassDesc.of(\"Phee\"), ClassDesc.of(\"Phoo\"))\n+                .with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(ClassDesc.of(\"Phee\"), Optional.of(ClassDesc.of(\"Phoo\")), Optional.of(\"InnerName\"), Classfile.ACC_PROTECTED),\n+                        InnerClassInfo.of(ClassDesc.of(\"Phoo\"), Optional.empty(), Optional.empty(), Classfile.ACC_PRIVATE)))\n+                .with(EnclosingMethodAttribute.of(ClassDesc.of(\"Phee\"), Optional.of(\"enclosingMethod\"), Optional.of(MethodTypeDesc.of(ConstantDescs.CD_Double, ConstantDescs.CD_Collection))))\n+                .with(SyntheticAttribute.of())\n+                .with(SignatureAttribute.of(ClassSignature.of(Signature.ClassTypeSig.of(ClassDesc.of(\"Boo\")), Signature.ClassTypeSig.of(ClassDesc.of(\"Phee\")), Signature.ClassTypeSig.of(ClassDesc.of(\"Phoo\")))))\n+                .with(DeprecatedAttribute.of())\n+                .with(NestHostAttribute.of(ClassDesc.of(\"Phee\")))\n+                .with(NestMembersAttribute.ofSymbols(ClassDesc.of(\"Phoo\"), ClassDesc.of(\"Boo\"), ClassDesc.of(\"Bee\")))\n+                .with(RecordAttribute.of(RecordComponentInfo.of(\"fee\", ClassDesc.of(\"Phoo\"), List.of(\n+                        SignatureAttribute.of(Signature.of(ClassDesc.of(\"Phoo\"))),\n+                        RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(),\n+                                                  List.of(TypeAnnotation.TypePathComponent.WILDCARD),\n+                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                .with(RuntimeInvisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.of(\"Phoo\"), AnnotationElement.ofFloat(\"flfl\", 2),  AnnotationElement.ofFloat(\"frfl\", 3))))\n+                .with(PermittedSubclassesAttribute.ofSymbols(ClassDesc.of(\"Boo\"), ClassDesc.of(\"Phoo\")))\n+                .withField(\"f\", ConstantDescs.CD_String, fb -> fb\n+                        .withFlags(Classfile.ACC_PRIVATE)\n+                        .with(RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.of(\"Phoo\"), AnnotationElement.ofFloat(\"flfl\", 0),  AnnotationElement.ofFloat(\"frfl\", 1)))))\n+                .withMethod(\"m\", MethodTypeDesc.of(ConstantDescs.CD_Void, ConstantDescs.CD_boolean, ConstantDescs.CD_Throwable), Classfile.ACC_PROTECTED, mb -> mb\n+                        .with(AnnotationDefaultAttribute.of(AnnotationValue.ofArray(\n+                            AnnotationValue.ofBoolean(true),\n+                            AnnotationValue.ofByte((byte)12),\n+                            AnnotationValue.ofChar('c'),\n+                            AnnotationValue.ofClass(ClassDesc.of(\"Phee\")),\n+                            AnnotationValue.ofDouble(1.3),\n+                            AnnotationValue.ofEnum(ClassDesc.of(\"Boo\"), \"BOO\"),\n+                            AnnotationValue.ofFloat((float)3.7),\n+                            AnnotationValue.ofInt(33),\n+                            AnnotationValue.ofLong(3333),\n+                            AnnotationValue.ofShort((short)25),\n+                            AnnotationValue.ofString(\"BOO\"),\n+                            AnnotationValue.ofAnnotation(Annotation.of(ClassDesc.of(\"Phoo\"), AnnotationElement.of(\"param\", AnnotationValue.ofInt(3)))))))\n+                        .with(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(Annotation.of(ClassDesc.of(\"Phoo\"), AnnotationElement.ofFloat(\"flfl\", 22),  AnnotationElement.ofFloat(\"frfl\", 11))))))\n+                        .with(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(List.of(Annotation.of(ClassDesc.of(\"Phoo\"), AnnotationElement.ofFloat(\"flfl\", -22),  AnnotationElement.ofFloat(\"frfl\", -11))))))\n+                        .with(ExceptionsAttribute.ofSymbols(ClassDesc.of(\"Phoo\"), ClassDesc.of(\"Boo\"), ClassDesc.of(\"Bee\")))\n+                        .withCode(cob ->\n+                            cob.trying(tryb -> {\n+                                tryb.lineNumber(1);\n+                                tryb.iload(1);\n+                                tryb.lineNumber(2);\n+                                tryb.ifThen(thb -> thb.aload(2).athrow());\n+                                tryb.lineNumber(3);\n+                                tryb.localVariable(2, \"variable\", ClassDesc.of(\"Phoo\"), tryb.startLabel(), tryb.endLabel());\n+                                tryb.localVariableType(2, \"variable\", Signature.of(ClassDesc.of(\"Phoo\")), tryb.startLabel(), tryb.endLabel());\n+                                tryb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(\n+                                        TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(),\n+                                                List.of(TypeAnnotation.TypePathComponent.WILDCARD),\n+                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                tryb.return_();\n+                            }, catchb -> catchb.catching(ClassDesc.of(\"Phee\"), cb -> {\n+                                cb.lineNumber(4);\n+                                cb.athrow();\n+                            }))\n+                            .with(RuntimeVisibleTypeAnnotationsAttribute.of(\n+                                    TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(),\n+                                          List.of(TypeAnnotation.TypePathComponent.ARRAY),\n+                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                        ))));\n+    }\n+\n+    @Test\n+    void testPrintYamlTraceAll() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toYaml(getClassModel(), ClassPrinter.Verbosity.TRACE_ALL, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                  - class name: Foo\n+                    version: 61.0\n+                    flags: [PUBLIC]\n+                    superclass: Boo\n+                    interfaces: [Phee, Phoo]\n+                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses]\n+                    constant pool:\n+                        1: {tag: Utf8, value: Foo}\n+                        2: {tag: Class, class name index: 1, class internal name: Foo}\n+                        3: {tag: Utf8, value: Boo}\n+                        4: {tag: Class, class name index: 3, class internal name: Boo}\n+                        5: {tag: Utf8, value: f}\n+                        6: {tag: Utf8, value: Ljava\/lang\/String;}\n+                        7: {tag: Utf8, value: m}\n+                        8: {tag: Utf8, value: (ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;}\n+                        9: {tag: Utf8, value: variable}\n+                        10: {tag: Utf8, value: LPhoo;}\n+                        11: {tag: Utf8, value: Phee}\n+                        12: {tag: Class, class name index: 11, class internal name: Phee}\n+                        13: {tag: Utf8, value: Phoo}\n+                        14: {tag: Class, class name index: 13, class internal name: Phoo}\n+                        15: {tag: Utf8, value: RuntimeVisibleAnnotations}\n+                        16: {tag: Utf8, value: flfl}\n+                        17: {tag: Float, value: 0.0}\n+                        18: {tag: Utf8, value: frfl}\n+                        19: {tag: Float, value: 1.0}\n+                        20: {tag: Utf8, value: AnnotationDefault}\n+                        21: {tag: Integer, value: 1}\n+                        22: {tag: Integer, value: 12}\n+                        23: {tag: Integer, value: 99}\n+                        24: {tag: Utf8, value: LPhee;}\n+                        25: {tag: Double, value: 1.3}\n+                        27: {tag: Utf8, value: LBoo;}\n+                        28: {tag: Utf8, value: BOO}\n+                        29: {tag: Float, value: 3.7}\n+                        30: {tag: Integer, value: 33}\n+                        31: {tag: Long, value: 3333}\n+                        33: {tag: Integer, value: 25}\n+                        34: {tag: Utf8, value: param}\n+                        35: {tag: Integer, value: 3}\n+                        36: {tag: Utf8, value: RuntimeVisibleParameterAnnotations}\n+                        37: {tag: Float, value: 22.0}\n+                        38: {tag: Float, value: 11.0}\n+                        39: {tag: Utf8, value: RuntimeInvisibleParameterAnnotations}\n+                        40: {tag: Float, value: '-22.0'}\n+                        41: {tag: Float, value: '-11.0'}\n+                        42: {tag: Utf8, value: Exceptions}\n+                        43: {tag: Utf8, value: Bee}\n+                        44: {tag: Class, class name index: 43, class internal name: Bee}\n+                        45: {tag: Utf8, value: Code}\n+                        46: {tag: Utf8, value: RuntimeInvisibleTypeAnnotations}\n+                        47: {tag: Utf8, value: RuntimeVisibleTypeAnnotations}\n+                        48: {tag: Utf8, value: LFee;}\n+                        49: {tag: Utf8, value: yes}\n+                        50: {tag: Integer, value: 0}\n+                        51: {tag: Utf8, value: LocalVariableTable}\n+                        52: {tag: Utf8, value: LocalVariableTypeTable}\n+                        53: {tag: Utf8, value: LineNumberTable}\n+                        54: {tag: Utf8, value: StackMapTable}\n+                        55: {tag: Utf8, value: SourceFile}\n+                        56: {tag: Utf8, value: Foo.java}\n+                        57: {tag: Utf8, value: InnerClasses}\n+                        58: {tag: Utf8, value: InnerName}\n+                        59: {tag: Utf8, value: EnclosingMethod}\n+                        60: {tag: Utf8, value: enclosingMethod}\n+                        61: {tag: Utf8, value: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n+                        62: {tag: NameAndType, name index: 60, type index: 61, name: enclosingMethod, type: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n+                        63: {tag: Utf8, value: Synthetic}\n+                        64: {tag: Utf8, value: Signature}\n+                        65: {tag: Utf8, value: LBoo;LPhee;LPhoo;}\n+                        66: {tag: Utf8, value: Deprecated}\n+                        67: {tag: Utf8, value: NestHost}\n+                        68: {tag: Utf8, value: NestMembers}\n+                        69: {tag: Utf8, value: Record}\n+                        70: {tag: Utf8, value: fee}\n+                        71: {tag: Utf8, value: RuntimeInvisibleAnnotations}\n+                        72: {tag: Float, value: 2.0}\n+                        73: {tag: Float, value: 3.0}\n+                        74: {tag: Utf8, value: PermittedSubclasses}\n+                    source file: Foo.java\n+                    inner classes:\n+                      - {inner class: Phee, outer class: Phoo, inner name: InnerName, flags: [PROTECTED]}\n+                      - {inner class: Phoo, outer class: null, inner name: null, flags: [PRIVATE]}\n+                    enclosing method: {class: Phee, method name: enclosingMethod, method type: (Ljava\/util\/Collection;)Ljava\/lang\/Double;}\n+                    signature: LBoo;LPhee;LPhoo;\n+                    nest host: Phee\n+                    nest members: [Phoo, Boo, Bee]\n+                    record components:\n+                      - name: fee\n+                        type: LPhoo;\n+                        attributes: [Signature, RuntimeInvisibleTypeAnnotations]\n+                        signature: LPhoo;\n+                        invisible type annotations:\n+                          - {annotation class: LBoo;, target info: FIELD, values: []}\n+                    invisible annotations:\n+                      - {annotation class: LPhoo;, values: [{name: flfl, value: {float: 2.0}}, {name: frfl, value: {float: 3.0}}]}\n+                    permitted subclasses: [Boo, Phoo]\n+                    fields:\n+                      - field name: f\n+                        flags: [PRIVATE]\n+                        field type: Ljava\/lang\/String;\n+                        attributes: [RuntimeVisibleAnnotations]\n+                        visible annotations:\n+                          - {annotation class: LPhoo;, values: [{name: flfl, value: {float: 0.0}}, {name: frfl, value: {float: 1.0}}]}\n+                    methods:\n+                      - method name: m\n+                        flags: [PROTECTED]\n+                        method type: (ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\n+                        attributes: [AnnotationDefault, RuntimeVisibleParameterAnnotations, RuntimeInvisibleParameterAnnotations, Exceptions, Code]\n+                        annotation default: {array: [{boolean: true}, {byte: 12}, {char: 99}, {class: LPhee;}, {double: 1.3}, {enum class: LBoo;, contant name: BOO}, {float: 3.7}, {int: 33}, {long: 3333}, {short: 25}, {string: BOO}, {annotation class: LPhoo;}]}\n+                        visible parameter annotations:\n+                            parameter 1: [{annotation class: LPhoo;, values: [{name: flfl, value: {float: 22.0}}, {name: frfl, value: {float: 11.0}}]}]\n+                        invisible parameter annotations:\n+                            parameter 1: [{annotation class: LPhoo;, values: [{name: flfl, value: {float: '-22.0'}}, {name: frfl, value: {float: '-11.0'}}]}]\n+                        excceptions: [Phoo, Boo, Bee]\n+                        code:\n+                            max stack: 1\n+                            max locals: 3\n+                            attributes: [RuntimeInvisibleTypeAnnotations, RuntimeVisibleTypeAnnotations, LocalVariableTable, LocalVariableTypeTable, LineNumberTable, StackMapTable]\n+                            local variables:\n+                              - {start: 0, end: 7, slot: 2, name: variable, type: LPhoo;}\n+                            local variable types:\n+                              - {start: 0, end: 7, slot: 2, name: variable, signature: LPhoo;}\n+                            line numbers:\n+                              - {start: 0, line number: 1}\n+                              - {start: 1, line number: 2}\n+                              - {start: 6, line number: 3}\n+                              - {start: 7, line number: 4}\n+                            stack map frames:\n+                                6: {locals: [Foo, int, java\/lang\/Throwable], stack: []}\n+                                7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                            invisible type annotations:\n+                              - {annotation class: LBoo;, target info: FIELD, values: []}\n+                            visible type annotations:\n+                              - {annotation class: LFee;, target info: FIELD, values: [{name: yes, value: {boolean: false}}]}\n+                            \/\/stack map frame @0: {locals: [Foo, int, java\/lang\/Throwable], stack: []}\n+                            \/\/try block 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            0: {opcode: ILOAD_1, slot: 1}\n+                            1: {opcode: IFEQ, target: 6}\n+                            4: {opcode: ALOAD_2, slot: 2, type: LPhoo;, variable name: variable}\n+                            5: {opcode: ATHROW}\n+                            \/\/stack map frame @6: {locals: [Foo, int, java\/lang\/Throwable], stack: []}\n+                            6: {opcode: RETURN}\n+                            \/\/stack map frame @7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                            \/\/try block 1 end: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            \/\/exception handler 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            7: {opcode: ATHROW}\n+                            exception handlers:\n+                                handler 1: {start: 0, end: 7, handler: 7, type: Phee}\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintYamlCriticalAttributes() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toYaml(getClassModel(), ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                  - class name: Foo\n+                    version: 61.0\n+                    flags: [PUBLIC]\n+                    superclass: Boo\n+                    interfaces: [Phee, Phoo]\n+                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses]\n+                    nest host: Phee\n+                    nest members: [Phoo, Boo, Bee]\n+                    permitted subclasses: [Boo, Phoo]\n+                    fields:\n+                      - field name: f\n+                        flags: [PRIVATE]\n+                        field type: Ljava\/lang\/String;\n+                        attributes: [RuntimeVisibleAnnotations]\n+                    methods:\n+                      - method name: m\n+                        flags: [PROTECTED]\n+                        method type: (ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\n+                        attributes: [AnnotationDefault, RuntimeVisibleParameterAnnotations, RuntimeInvisibleParameterAnnotations, Exceptions, Code]\n+                        code:\n+                            max stack: 1\n+                            max locals: 3\n+                            attributes: [RuntimeInvisibleTypeAnnotations, RuntimeVisibleTypeAnnotations, LocalVariableTable, LocalVariableTypeTable, LineNumberTable, StackMapTable]\n+                            stack map frames:\n+                                6: {locals: [Foo, int, java\/lang\/Throwable], stack: []}\n+                                7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                            \/\/stack map frame @0: {locals: [Foo, int, java\/lang\/Throwable], stack: []}\n+                            \/\/try block 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            0: {opcode: ILOAD_1, slot: 1}\n+                            1: {opcode: IFEQ, target: 6}\n+                            4: {opcode: ALOAD_2, slot: 2}\n+                            5: {opcode: ATHROW}\n+                            \/\/stack map frame @6: {locals: [Foo, int, java\/lang\/Throwable], stack: []}\n+                            6: {opcode: RETURN}\n+                            \/\/stack map frame @7: {locals: [Foo, int, java\/lang\/Throwable], stack: [Phee]}\n+                            \/\/try block 1 end: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            \/\/exception handler 1 start: {start: 0, end: 7, handler: 7, catch type: Phee}\n+                            7: {opcode: ATHROW}\n+                            exception handlers:\n+                                handler 1: {start: 0, end: 7, handler: 7, type: Phee}\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintYamlMembersOnly() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toYaml(getClassModel(), ClassPrinter.Verbosity.MEMBERS_ONLY, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                  - class name: Foo\n+                    version: 61.0\n+                    flags: [PUBLIC]\n+                    superclass: Boo\n+                    interfaces: [Phee, Phoo]\n+                    attributes: [SourceFile, InnerClasses, EnclosingMethod, Synthetic, Signature, Deprecated, NestHost, NestMembers, Record, RuntimeInvisibleAnnotations, PermittedSubclasses]\n+                    fields:\n+                      - field name: f\n+                        flags: [PRIVATE]\n+                        field type: Ljava\/lang\/String;\n+                        attributes: [RuntimeVisibleAnnotations]\n+                    methods:\n+                      - method name: m\n+                        flags: [PROTECTED]\n+                        method type: (ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\n+                        attributes: [AnnotationDefault, RuntimeVisibleParameterAnnotations, RuntimeInvisibleParameterAnnotations, Exceptions, Code]\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintJsonTraceAll() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toJson(getClassModel(), ClassPrinter.Verbosity.TRACE_ALL, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                  { \"class name\": \"Foo\",\n+                    \"version\": \"61.0\",\n+                    \"flags\": [\"PUBLIC\"],\n+                    \"superclass\": \"Boo\",\n+                    \"interfaces\": [\"Phee\", \"Phoo\"],\n+                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\"],\n+                    \"constant pool\": {\n+                        \"1\": {\"tag\": \"Utf8\", \"value\": \"Foo\"},\n+                        \"2\": {\"tag\": \"Class\", \"class name index\": 1, \"class internal name\": \"Foo\"},\n+                        \"3\": {\"tag\": \"Utf8\", \"value\": \"Boo\"},\n+                        \"4\": {\"tag\": \"Class\", \"class name index\": 3, \"class internal name\": \"Boo\"},\n+                        \"5\": {\"tag\": \"Utf8\", \"value\": \"f\"},\n+                        \"6\": {\"tag\": \"Utf8\", \"value\": \"Ljava\/lang\/String;\"},\n+                        \"7\": {\"tag\": \"Utf8\", \"value\": \"m\"},\n+                        \"8\": {\"tag\": \"Utf8\", \"value\": \"(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\"},\n+                        \"9\": {\"tag\": \"Utf8\", \"value\": \"variable\"},\n+                        \"10\": {\"tag\": \"Utf8\", \"value\": \"LPhoo;\"},\n+                        \"11\": {\"tag\": \"Utf8\", \"value\": \"Phee\"},\n+                        \"12\": {\"tag\": \"Class\", \"class name index\": 11, \"class internal name\": \"Phee\"},\n+                        \"13\": {\"tag\": \"Utf8\", \"value\": \"Phoo\"},\n+                        \"14\": {\"tag\": \"Class\", \"class name index\": 13, \"class internal name\": \"Phoo\"},\n+                        \"15\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleAnnotations\"},\n+                        \"16\": {\"tag\": \"Utf8\", \"value\": \"flfl\"},\n+                        \"17\": {\"tag\": \"Float\", \"value\": \"0.0\"},\n+                        \"18\": {\"tag\": \"Utf8\", \"value\": \"frfl\"},\n+                        \"19\": {\"tag\": \"Float\", \"value\": \"1.0\"},\n+                        \"20\": {\"tag\": \"Utf8\", \"value\": \"AnnotationDefault\"},\n+                        \"21\": {\"tag\": \"Integer\", \"value\": \"1\"},\n+                        \"22\": {\"tag\": \"Integer\", \"value\": \"12\"},\n+                        \"23\": {\"tag\": \"Integer\", \"value\": \"99\"},\n+                        \"24\": {\"tag\": \"Utf8\", \"value\": \"LPhee;\"},\n+                        \"25\": {\"tag\": \"Double\", \"value\": \"1.3\"},\n+                        \"27\": {\"tag\": \"Utf8\", \"value\": \"LBoo;\"},\n+                        \"28\": {\"tag\": \"Utf8\", \"value\": \"BOO\"},\n+                        \"29\": {\"tag\": \"Float\", \"value\": \"3.7\"},\n+                        \"30\": {\"tag\": \"Integer\", \"value\": \"33\"},\n+                        \"31\": {\"tag\": \"Long\", \"value\": \"3333\"},\n+                        \"33\": {\"tag\": \"Integer\", \"value\": \"25\"},\n+                        \"34\": {\"tag\": \"Utf8\", \"value\": \"param\"},\n+                        \"35\": {\"tag\": \"Integer\", \"value\": \"3\"},\n+                        \"36\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleParameterAnnotations\"},\n+                        \"37\": {\"tag\": \"Float\", \"value\": \"22.0\"},\n+                        \"38\": {\"tag\": \"Float\", \"value\": \"11.0\"},\n+                        \"39\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleParameterAnnotations\"},\n+                        \"40\": {\"tag\": \"Float\", \"value\": \"-22.0\"},\n+                        \"41\": {\"tag\": \"Float\", \"value\": \"-11.0\"},\n+                        \"42\": {\"tag\": \"Utf8\", \"value\": \"Exceptions\"},\n+                        \"43\": {\"tag\": \"Utf8\", \"value\": \"Bee\"},\n+                        \"44\": {\"tag\": \"Class\", \"class name index\": 43, \"class internal name\": \"Bee\"},\n+                        \"45\": {\"tag\": \"Utf8\", \"value\": \"Code\"},\n+                        \"46\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleTypeAnnotations\"},\n+                        \"47\": {\"tag\": \"Utf8\", \"value\": \"RuntimeVisibleTypeAnnotations\"},\n+                        \"48\": {\"tag\": \"Utf8\", \"value\": \"LFee;\"},\n+                        \"49\": {\"tag\": \"Utf8\", \"value\": \"yes\"},\n+                        \"50\": {\"tag\": \"Integer\", \"value\": \"0\"},\n+                        \"51\": {\"tag\": \"Utf8\", \"value\": \"LocalVariableTable\"},\n+                        \"52\": {\"tag\": \"Utf8\", \"value\": \"LocalVariableTypeTable\"},\n+                        \"53\": {\"tag\": \"Utf8\", \"value\": \"LineNumberTable\"},\n+                        \"54\": {\"tag\": \"Utf8\", \"value\": \"StackMapTable\"},\n+                        \"55\": {\"tag\": \"Utf8\", \"value\": \"SourceFile\"},\n+                        \"56\": {\"tag\": \"Utf8\", \"value\": \"Foo.java\"},\n+                        \"57\": {\"tag\": \"Utf8\", \"value\": \"InnerClasses\"},\n+                        \"58\": {\"tag\": \"Utf8\", \"value\": \"InnerName\"},\n+                        \"59\": {\"tag\": \"Utf8\", \"value\": \"EnclosingMethod\"},\n+                        \"60\": {\"tag\": \"Utf8\", \"value\": \"enclosingMethod\"},\n+                        \"61\": {\"tag\": \"Utf8\", \"value\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n+                        \"62\": {\"tag\": \"NameAndType\", \"name index\": 60, \"type index\": 61, \"name\": \"enclosingMethod\", \"type\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n+                        \"63\": {\"tag\": \"Utf8\", \"value\": \"Synthetic\"},\n+                        \"64\": {\"tag\": \"Utf8\", \"value\": \"Signature\"},\n+                        \"65\": {\"tag\": \"Utf8\", \"value\": \"LBoo;LPhee;LPhoo;\"},\n+                        \"66\": {\"tag\": \"Utf8\", \"value\": \"Deprecated\"},\n+                        \"67\": {\"tag\": \"Utf8\", \"value\": \"NestHost\"},\n+                        \"68\": {\"tag\": \"Utf8\", \"value\": \"NestMembers\"},\n+                        \"69\": {\"tag\": \"Utf8\", \"value\": \"Record\"},\n+                        \"70\": {\"tag\": \"Utf8\", \"value\": \"fee\"},\n+                        \"71\": {\"tag\": \"Utf8\", \"value\": \"RuntimeInvisibleAnnotations\"},\n+                        \"72\": {\"tag\": \"Float\", \"value\": \"2.0\"},\n+                        \"73\": {\"tag\": \"Float\", \"value\": \"3.0\"},\n+                        \"74\": {\"tag\": \"Utf8\", \"value\": \"PermittedSubclasses\"}},\n+                    \"source file\": \"Foo.java\",\n+                    \"inner classes\": [\n+                        {\"inner class\": \"Phee\", \"outer class\": \"Phoo\", \"inner name\": \"InnerName\", \"flags\": [\"PROTECTED\"]},\n+                        {\"inner class\": \"Phoo\", \"outer class\": \"null\", \"inner name\": \"null\", \"flags\": [\"PRIVATE\"]}],\n+                    \"enclosing method\": {\"class\": \"Phee\", \"method name\": \"enclosingMethod\", \"method type\": \"(Ljava\/util\/Collection;)Ljava\/lang\/Double;\"},\n+                    \"signature\": \"LBoo;LPhee;LPhoo;\",\n+                    \"nest host\": \"Phee\",\n+                    \"nest members\": [\"Phoo\", \"Boo\", \"Bee\"],\n+                    \"record components\": [\n+                          { \"name\": \"fee\",\n+                            \"type\": \"LPhoo;\",\n+                            \"attributes\": [\"Signature\", \"RuntimeInvisibleTypeAnnotations\"],\n+                            \"signature\": \"LPhoo;\",\n+                            \"invisible type annotations\": [\n+                                {\"annotation class\": \"LBoo;\", \"target info\": \"FIELD\", \"values\": []}]}],\n+                    \"invisible annotations\": [\n+                        {\"annotation class\": \"LPhoo;\", \"values\": [{\"name\": \"flfl\", \"value\": {\"float\": \"2.0\"}}, {\"name\": \"frfl\", \"value\": {\"float\": \"3.0\"}}]}],\n+                    \"permitted subclasses\": [\"Boo\", \"Phoo\"],\n+                    \"fields\": [\n+                          { \"field name\": \"f\",\n+                            \"flags\": [\"PRIVATE\"],\n+                            \"field type\": \"Ljava\/lang\/String;\",\n+                            \"attributes\": [\"RuntimeVisibleAnnotations\"],\n+                            \"visible annotations\": [\n+                                {\"annotation class\": \"LPhoo;\", \"values\": [{\"name\": \"flfl\", \"value\": {\"float\": \"0.0\"}}, {\"name\": \"frfl\", \"value\": {\"float\": \"1.0\"}}]}]}],\n+                    \"methods\": [\n+                          { \"method name\": \"m\",\n+                            \"flags\": [\"PROTECTED\"],\n+                            \"method type\": \"(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\",\n+                            \"attributes\": [\"AnnotationDefault\", \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", \"Exceptions\", \"Code\"],\n+                            \"annotation default\": {\"array\": [{\"boolean\": \"true\"}, {\"byte\": \"12\"}, {\"char\": \"99\"}, {\"class\": \"LPhee;\"}, {\"double\": \"1.3\"}, {\"enum class\": \"LBoo;\", \"contant name\": \"BOO\"}, {\"float\": \"3.7\"}, {\"int\": \"33\"}, {\"long\": \"3333\"}, {\"short\": \"25\"}, {\"string\": \"BOO\"}, {\"annotation class\": \"LPhoo;\"}]},\n+                            \"visible parameter annotations\": {\n+                                \"parameter 1\": [{\"annotation class\": \"LPhoo;\", \"values\": [{\"name\": \"flfl\", \"value\": {\"float\": \"22.0\"}}, {\"name\": \"frfl\", \"value\": {\"float\": \"11.0\"}}]}]},\n+                            \"invisible parameter annotations\": {\n+                                \"parameter 1\": [{\"annotation class\": \"LPhoo;\", \"values\": [{\"name\": \"flfl\", \"value\": {\"float\": \"-22.0\"}}, {\"name\": \"frfl\", \"value\": {\"float\": \"-11.0\"}}]}]},\n+                            \"excceptions\": [\"Phoo\", \"Boo\", \"Bee\"],\n+                            \"code\": {\n+                                \"max stack\": 1,\n+                                \"max locals\": 3,\n+                                \"attributes\": [\"RuntimeInvisibleTypeAnnotations\", \"RuntimeVisibleTypeAnnotations\", \"LocalVariableTable\", \"LocalVariableTypeTable\", \"LineNumberTable\", \"StackMapTable\"],\n+                                \"local variables\": [\n+                                    {\"start\": 0, \"end\": 7, \"slot\": 2, \"name\": \"variable\", \"type\": \"LPhoo;\"}],\n+                                \"local variable types\": [\n+                                    {\"start\": 0, \"end\": 7, \"slot\": 2, \"name\": \"variable\", \"signature\": \"LPhoo;\"}],\n+                                \"line numbers\": [\n+                                    {\"start\": 0, \"line number\": 1},\n+                                    {\"start\": 1, \"line number\": 2},\n+                                    {\"start\": 6, \"line number\": 3},\n+                                    {\"start\": 7, \"line number\": 4}],\n+                                \"stack map frames\": {\n+                                    \"6\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": []},\n+                                    \"7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]}},\n+                                \"invisible type annotations\": [\n+                                    {\"annotation class\": \"LBoo;\", \"target info\": \"FIELD\", \"values\": []}],\n+                                \"visible type annotations\": [\n+                                    {\"annotation class\": \"LFee;\", \"target info\": \"FIELD\", \"values\": [{\"name\": \"yes\", \"value\": {\"boolean\": \"false\"}}]}],\n+                                \"\/\/stack map frame @0\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": []},\n+                                \"\/\/try block 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"0\": {\"opcode\": \"ILOAD_1\", \"slot\": 1},\n+                                \"1\": {\"opcode\": \"IFEQ\", \"target\": 6},\n+                                \"4\": {\"opcode\": \"ALOAD_2\", \"slot\": 2, \"type\": \"LPhoo;\", \"variable name\": \"variable\"},\n+                                \"5\": {\"opcode\": \"ATHROW\"},\n+                                \"\/\/stack map frame @6\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": []},\n+                                \"6\": {\"opcode\": \"RETURN\"},\n+                                \"\/\/stack map frame @7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]},\n+                                \"\/\/try block 1 end\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"\/\/exception handler 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"7\": {\"opcode\": \"ATHROW\"},\n+                                \"exception handlers\": {\n+                                    \"handler 1\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"type\": \"Phee\"}}}}]}\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintJsonCriticalAttributes() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toJson(getClassModel(), ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                  { \"class name\": \"Foo\",\n+                    \"version\": \"61.0\",\n+                    \"flags\": [\"PUBLIC\"],\n+                    \"superclass\": \"Boo\",\n+                    \"interfaces\": [\"Phee\", \"Phoo\"],\n+                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\"],\n+                    \"nest host\": \"Phee\",\n+                    \"nest members\": [\"Phoo\", \"Boo\", \"Bee\"],\n+                    \"permitted subclasses\": [\"Boo\", \"Phoo\"],\n+                    \"fields\": [\n+                          { \"field name\": \"f\",\n+                            \"flags\": [\"PRIVATE\"],\n+                            \"field type\": \"Ljava\/lang\/String;\",\n+                            \"attributes\": [\"RuntimeVisibleAnnotations\"]}],\n+                    \"methods\": [\n+                          { \"method name\": \"m\",\n+                            \"flags\": [\"PROTECTED\"],\n+                            \"method type\": \"(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\",\n+                            \"attributes\": [\"AnnotationDefault\", \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", \"Exceptions\", \"Code\"],\n+                            \"code\": {\n+                                \"max stack\": 1,\n+                                \"max locals\": 3,\n+                                \"attributes\": [\"RuntimeInvisibleTypeAnnotations\", \"RuntimeVisibleTypeAnnotations\", \"LocalVariableTable\", \"LocalVariableTypeTable\", \"LineNumberTable\", \"StackMapTable\"],\n+                                \"stack map frames\": {\n+                                    \"6\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": []},\n+                                    \"7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]}},\n+                                \"\/\/stack map frame @0\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": []},\n+                                \"\/\/try block 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"0\": {\"opcode\": \"ILOAD_1\", \"slot\": 1},\n+                                \"1\": {\"opcode\": \"IFEQ\", \"target\": 6},\n+                                \"4\": {\"opcode\": \"ALOAD_2\", \"slot\": 2},\n+                                \"5\": {\"opcode\": \"ATHROW\"},\n+                                \"\/\/stack map frame @6\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": []},\n+                                \"6\": {\"opcode\": \"RETURN\"},\n+                                \"\/\/stack map frame @7\": {\"locals\": [\"Foo\", \"int\", \"java\/lang\/Throwable\"], \"stack\": [\"Phee\"]},\n+                                \"\/\/try block 1 end\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"\/\/exception handler 1 start\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"catch type\": \"Phee\"},\n+                                \"7\": {\"opcode\": \"ATHROW\"},\n+                                \"exception handlers\": {\n+                                    \"handler 1\": {\"start\": 0, \"end\": 7, \"handler\": 7, \"type\": \"Phee\"}}}}]}\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintJsonMembersOnly() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toJson(getClassModel(), ClassPrinter.Verbosity.MEMBERS_ONLY, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                  { \"class name\": \"Foo\",\n+                    \"version\": \"61.0\",\n+                    \"flags\": [\"PUBLIC\"],\n+                    \"superclass\": \"Boo\",\n+                    \"interfaces\": [\"Phee\", \"Phoo\"],\n+                    \"attributes\": [\"SourceFile\", \"InnerClasses\", \"EnclosingMethod\", \"Synthetic\", \"Signature\", \"Deprecated\", \"NestHost\", \"NestMembers\", \"Record\", \"RuntimeInvisibleAnnotations\", \"PermittedSubclasses\"],\n+                    \"fields\": [\n+                          { \"field name\": \"f\",\n+                            \"flags\": [\"PRIVATE\"],\n+                            \"field type\": \"Ljava\/lang\/String;\",\n+                            \"attributes\": [\"RuntimeVisibleAnnotations\"]}],\n+                    \"methods\": [\n+                          { \"method name\": \"m\",\n+                            \"flags\": [\"PROTECTED\"],\n+                            \"method type\": \"(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;\",\n+                            \"attributes\": [\"AnnotationDefault\", \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", \"Exceptions\", \"Code\"]}]}\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintXmlTraceAll() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toXml(getClassModel(), ClassPrinter.Verbosity.TRACE_ALL, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                <?xml version = '1.0'?>\n+                <class>\n+                    <class_name>Foo<\/class_name>\n+                    <version>61.0<\/version>\n+                    <flags><flag>PUBLIC<\/flag><\/flags>\n+                    <superclass>Boo<\/superclass>\n+                    <interfaces><interface>Phee<\/interface><interface>Phoo<\/interface><\/interfaces>\n+                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><\/attributes>\n+                    <constant_pool>\n+                        <_1><tag>Utf8<\/tag><value>Foo<\/value><\/_1>\n+                        <_2><tag>Class<\/tag><class_name_index>1<\/class_name_index><class_internal_name>Foo<\/class_internal_name><\/_2>\n+                        <_3><tag>Utf8<\/tag><value>Boo<\/value><\/_3>\n+                        <_4><tag>Class<\/tag><class_name_index>3<\/class_name_index><class_internal_name>Boo<\/class_internal_name><\/_4>\n+                        <_5><tag>Utf8<\/tag><value>f<\/value><\/_5>\n+                        <_6><tag>Utf8<\/tag><value>Ljava\/lang\/String;<\/value><\/_6>\n+                        <_7><tag>Utf8<\/tag><value>m<\/value><\/_7>\n+                        <_8><tag>Utf8<\/tag><value>(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;<\/value><\/_8>\n+                        <_9><tag>Utf8<\/tag><value>variable<\/value><\/_9>\n+                        <_10><tag>Utf8<\/tag><value>LPhoo;<\/value><\/_10>\n+                        <_11><tag>Utf8<\/tag><value>Phee<\/value><\/_11>\n+                        <_12><tag>Class<\/tag><class_name_index>11<\/class_name_index><class_internal_name>Phee<\/class_internal_name><\/_12>\n+                        <_13><tag>Utf8<\/tag><value>Phoo<\/value><\/_13>\n+                        <_14><tag>Class<\/tag><class_name_index>13<\/class_name_index><class_internal_name>Phoo<\/class_internal_name><\/_14>\n+                        <_15><tag>Utf8<\/tag><value>RuntimeVisibleAnnotations<\/value><\/_15>\n+                        <_16><tag>Utf8<\/tag><value>flfl<\/value><\/_16>\n+                        <_17><tag>Float<\/tag><value>0.0<\/value><\/_17>\n+                        <_18><tag>Utf8<\/tag><value>frfl<\/value><\/_18>\n+                        <_19><tag>Float<\/tag><value>1.0<\/value><\/_19>\n+                        <_20><tag>Utf8<\/tag><value>AnnotationDefault<\/value><\/_20>\n+                        <_21><tag>Integer<\/tag><value>1<\/value><\/_21>\n+                        <_22><tag>Integer<\/tag><value>12<\/value><\/_22>\n+                        <_23><tag>Integer<\/tag><value>99<\/value><\/_23>\n+                        <_24><tag>Utf8<\/tag><value>LPhee;<\/value><\/_24>\n+                        <_25><tag>Double<\/tag><value>1.3<\/value><\/_25>\n+                        <_27><tag>Utf8<\/tag><value>LBoo;<\/value><\/_27>\n+                        <_28><tag>Utf8<\/tag><value>BOO<\/value><\/_28>\n+                        <_29><tag>Float<\/tag><value>3.7<\/value><\/_29>\n+                        <_30><tag>Integer<\/tag><value>33<\/value><\/_30>\n+                        <_31><tag>Long<\/tag><value>3333<\/value><\/_31>\n+                        <_33><tag>Integer<\/tag><value>25<\/value><\/_33>\n+                        <_34><tag>Utf8<\/tag><value>param<\/value><\/_34>\n+                        <_35><tag>Integer<\/tag><value>3<\/value><\/_35>\n+                        <_36><tag>Utf8<\/tag><value>RuntimeVisibleParameterAnnotations<\/value><\/_36>\n+                        <_37><tag>Float<\/tag><value>22.0<\/value><\/_37>\n+                        <_38><tag>Float<\/tag><value>11.0<\/value><\/_38>\n+                        <_39><tag>Utf8<\/tag><value>RuntimeInvisibleParameterAnnotations<\/value><\/_39>\n+                        <_40><tag>Float<\/tag><value>-22.0<\/value><\/_40>\n+                        <_41><tag>Float<\/tag><value>-11.0<\/value><\/_41>\n+                        <_42><tag>Utf8<\/tag><value>Exceptions<\/value><\/_42>\n+                        <_43><tag>Utf8<\/tag><value>Bee<\/value><\/_43>\n+                        <_44><tag>Class<\/tag><class_name_index>43<\/class_name_index><class_internal_name>Bee<\/class_internal_name><\/_44>\n+                        <_45><tag>Utf8<\/tag><value>Code<\/value><\/_45>\n+                        <_46><tag>Utf8<\/tag><value>RuntimeInvisibleTypeAnnotations<\/value><\/_46>\n+                        <_47><tag>Utf8<\/tag><value>RuntimeVisibleTypeAnnotations<\/value><\/_47>\n+                        <_48><tag>Utf8<\/tag><value>LFee;<\/value><\/_48>\n+                        <_49><tag>Utf8<\/tag><value>yes<\/value><\/_49>\n+                        <_50><tag>Integer<\/tag><value>0<\/value><\/_50>\n+                        <_51><tag>Utf8<\/tag><value>LocalVariableTable<\/value><\/_51>\n+                        <_52><tag>Utf8<\/tag><value>LocalVariableTypeTable<\/value><\/_52>\n+                        <_53><tag>Utf8<\/tag><value>LineNumberTable<\/value><\/_53>\n+                        <_54><tag>Utf8<\/tag><value>StackMapTable<\/value><\/_54>\n+                        <_55><tag>Utf8<\/tag><value>SourceFile<\/value><\/_55>\n+                        <_56><tag>Utf8<\/tag><value>Foo.java<\/value><\/_56>\n+                        <_57><tag>Utf8<\/tag><value>InnerClasses<\/value><\/_57>\n+                        <_58><tag>Utf8<\/tag><value>InnerName<\/value><\/_58>\n+                        <_59><tag>Utf8<\/tag><value>EnclosingMethod<\/value><\/_59>\n+                        <_60><tag>Utf8<\/tag><value>enclosingMethod<\/value><\/_60>\n+                        <_61><tag>Utf8<\/tag><value>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/value><\/_61>\n+                        <_62><tag>NameAndType<\/tag><name_index>60<\/name_index><type_index>61<\/type_index><name>enclosingMethod<\/name><type>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/type><\/_62>\n+                        <_63><tag>Utf8<\/tag><value>Synthetic<\/value><\/_63>\n+                        <_64><tag>Utf8<\/tag><value>Signature<\/value><\/_64>\n+                        <_65><tag>Utf8<\/tag><value>LBoo;LPhee;LPhoo;<\/value><\/_65>\n+                        <_66><tag>Utf8<\/tag><value>Deprecated<\/value><\/_66>\n+                        <_67><tag>Utf8<\/tag><value>NestHost<\/value><\/_67>\n+                        <_68><tag>Utf8<\/tag><value>NestMembers<\/value><\/_68>\n+                        <_69><tag>Utf8<\/tag><value>Record<\/value><\/_69>\n+                        <_70><tag>Utf8<\/tag><value>fee<\/value><\/_70>\n+                        <_71><tag>Utf8<\/tag><value>RuntimeInvisibleAnnotations<\/value><\/_71>\n+                        <_72><tag>Float<\/tag><value>2.0<\/value><\/_72>\n+                        <_73><tag>Float<\/tag><value>3.0<\/value><\/_73>\n+                        <_74><tag>Utf8<\/tag><value>PermittedSubclasses<\/value><\/_74><\/constant_pool>\n+                    <source_file>Foo.java<\/source_file>\n+                    <inner_classes>\n+                        <cls><inner_class>Phee<\/inner_class><outer_class>Phoo<\/outer_class><inner_name>InnerName<\/inner_name><flags><flag>PROTECTED<\/flag><\/flags><\/cls>\n+                        <cls><inner_class>Phoo<\/inner_class><outer_class>null<\/outer_class><inner_name>null<\/inner_name><flags><flag>PRIVATE<\/flag><\/flags><\/cls><\/inner_classes>\n+                    <enclosing_method><class>Phee<\/class><method_name>enclosingMethod<\/method_name><method_type>(Ljava\/util\/Collection;)Ljava\/lang\/Double;<\/method_type><\/enclosing_method>\n+                    <signature>LBoo;LPhee;LPhoo;<\/signature>\n+                    <nest_host>Phee<\/nest_host>\n+                    <nest_members><member>Phoo<\/member><member>Boo<\/member><member>Bee<\/member><\/nest_members>\n+                    <record_components>\n+                        <record>\n+                            <name>fee<\/name>\n+                            <type>LPhoo;<\/type>\n+                            <attributes><attribute>Signature<\/attribute><attribute>RuntimeInvisibleTypeAnnotations<\/attribute><\/attributes>\n+                            <signature>LPhoo;<\/signature>\n+                            <invisible_type_annotations>\n+                                <anno><annotation_class>LBoo;<\/annotation_class><target_info>FIELD<\/target_info><values><\/values><\/anno><\/invisible_type_annotations><\/record><\/record_components>\n+                    <invisible_annotations>\n+                        <anno><annotation_class>LPhoo;<\/annotation_class><values><pair><name>flfl<\/name><value><float>2.0<\/float><\/value><\/pair><pair><name>frfl<\/name><value><float>3.0<\/float><\/value><\/pair><\/values><\/anno><\/invisible_annotations>\n+                    <permitted_subclasses><subclass>Boo<\/subclass><subclass>Phoo<\/subclass><\/permitted_subclasses>\n+                    <fields>\n+                        <field>\n+                            <field_name>f<\/field_name>\n+                            <flags><flag>PRIVATE<\/flag><\/flags>\n+                            <field_type>Ljava\/lang\/String;<\/field_type>\n+                            <attributes><attribute>RuntimeVisibleAnnotations<\/attribute><\/attributes>\n+                            <visible_annotations>\n+                                <anno><annotation_class>LPhoo;<\/annotation_class><values><pair><name>flfl<\/name><value><float>0.0<\/float><\/value><\/pair><pair><name>frfl<\/name><value><float>1.0<\/float><\/value><\/pair><\/values><\/anno><\/visible_annotations><\/field><\/fields>\n+                    <methods>\n+                        <method>\n+                            <method_name>m<\/method_name>\n+                            <flags><flag>PROTECTED<\/flag><\/flags>\n+                            <method_type>(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;<\/method_type>\n+                            <attributes><attribute>AnnotationDefault<\/attribute><attribute>RuntimeVisibleParameterAnnotations<\/attribute><attribute>RuntimeInvisibleParameterAnnotations<\/attribute><attribute>Exceptions<\/attribute><attribute>Code<\/attribute><\/attributes>\n+                            <annotation_default><array><value><boolean>true<\/boolean><\/value><value><byte>12<\/byte><\/value><value><char>99<\/char><\/value><value><class>LPhee;<\/class><\/value><value><double>1.3<\/double><\/value><value><enum_class>LBoo;<\/enum_class><contant_name>BOO<\/contant_name><\/value><value><float>3.7<\/float><\/value><value><int>33<\/int><\/value><value><long>3333<\/long><\/value><value><short>25<\/short><\/value><value><string>BOO<\/string><\/value><value><annotation_class>LPhoo;<\/annotation_class><\/value><\/array><\/annotation_default>\n+                            <visible_parameter_annotations>\n+                                <parameter_1><anno><annotation_class>LPhoo;<\/annotation_class><values><pair><name>flfl<\/name><value><float>22.0<\/float><\/value><\/pair><pair><name>frfl<\/name><value><float>11.0<\/float><\/value><\/pair><\/values><\/anno><\/parameter_1><\/visible_parameter_annotations>\n+                            <invisible_parameter_annotations>\n+                                <parameter_1><anno><annotation_class>LPhoo;<\/annotation_class><values><pair><name>flfl<\/name><value><float>-22.0<\/float><\/value><\/pair><pair><name>frfl<\/name><value><float>-11.0<\/float><\/value><\/pair><\/values><\/anno><\/parameter_1><\/invisible_parameter_annotations>\n+                            <excceptions><exc>Phoo<\/exc><exc>Boo<\/exc><exc>Bee<\/exc><\/excceptions>\n+                            <code>\n+                                <max_stack>1<\/max_stack>\n+                                <max_locals>3<\/max_locals>\n+                                <attributes><attribute>RuntimeInvisibleTypeAnnotations<\/attribute><attribute>RuntimeVisibleTypeAnnotations<\/attribute><attribute>LocalVariableTable<\/attribute><attribute>LocalVariableTypeTable<\/attribute><attribute>LineNumberTable<\/attribute><attribute>StackMapTable<\/attribute><\/attributes>\n+                                <local_variables>\n+                                    <_1><start>0<\/start><end>7<\/end><slot>2<\/slot><name>variable<\/name><type>LPhoo;<\/type><\/_1><\/local_variables>\n+                                <local_variable_types>\n+                                    <_1><start>0<\/start><end>7<\/end><slot>2<\/slot><name>variable<\/name><signature>LPhoo;<\/signature><\/_1><\/local_variable_types>\n+                                <line_numbers>\n+                                    <_1><start>0<\/start><line_number>1<\/line_number><\/_1>\n+                                    <_2><start>1<\/start><line_number>2<\/line_number><\/_2>\n+                                    <_3><start>6<\/start><line_number>3<\/line_number><\/_3>\n+                                    <_4><start>7<\/start><line_number>4<\/line_number><\/_4><\/line_numbers>\n+                                <stack_map_frames>\n+                                    <_6><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><\/stack><\/_6>\n+                                    <_7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/_7><\/stack_map_frames>\n+                                <invisible_type_annotations>\n+                                    <anno><annotation_class>LBoo;<\/annotation_class><target_info>FIELD<\/target_info><values><\/values><\/anno><\/invisible_type_annotations>\n+                                <visible_type_annotations>\n+                                    <anno><annotation_class>LFee;<\/annotation_class><target_info>FIELD<\/target_info><values><pair><name>yes<\/name><value><boolean>false<\/boolean><\/value><\/pair><\/values><\/anno><\/visible_type_annotations>\n+                                <__stack_map_frame__0><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><\/stack><\/__stack_map_frame__0>\n+                                <__try_block_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_start>\n+                                <_0><opcode>ILOAD_1<\/opcode><slot>1<\/slot><\/_0>\n+                                <_1><opcode>IFEQ<\/opcode><target>6<\/target><\/_1>\n+                                <_4><opcode>ALOAD_2<\/opcode><slot>2<\/slot><type>LPhoo;<\/type><variable_name>variable<\/variable_name><\/_4>\n+                                <_5><opcode>ATHROW<\/opcode><\/_5>\n+                                <__stack_map_frame__6><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><\/stack><\/__stack_map_frame__6>\n+                                <_6><opcode>RETURN<\/opcode><\/_6>\n+                                <__stack_map_frame__7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/__stack_map_frame__7>\n+                                <__try_block_1_end><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_end>\n+                                <__exception_handler_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__exception_handler_1_start>\n+                                <_7><opcode>ATHROW<\/opcode><\/_7>\n+                                <exception_handlers>\n+                                    <handler_1><start>0<\/start><end>7<\/end><handler>7<\/handler><type>Phee<\/type><\/handler_1><\/exception_handlers><\/code><\/method><\/methods><\/class>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintXmlCriticalAttributes() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toXml(getClassModel(), ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                <?xml version = '1.0'?>\n+                <class>\n+                    <class_name>Foo<\/class_name>\n+                    <version>61.0<\/version>\n+                    <flags><flag>PUBLIC<\/flag><\/flags>\n+                    <superclass>Boo<\/superclass>\n+                    <interfaces><interface>Phee<\/interface><interface>Phoo<\/interface><\/interfaces>\n+                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><\/attributes>\n+                    <nest_host>Phee<\/nest_host>\n+                    <nest_members><member>Phoo<\/member><member>Boo<\/member><member>Bee<\/member><\/nest_members>\n+                    <permitted_subclasses><subclass>Boo<\/subclass><subclass>Phoo<\/subclass><\/permitted_subclasses>\n+                    <fields>\n+                        <field>\n+                            <field_name>f<\/field_name>\n+                            <flags><flag>PRIVATE<\/flag><\/flags>\n+                            <field_type>Ljava\/lang\/String;<\/field_type>\n+                            <attributes><attribute>RuntimeVisibleAnnotations<\/attribute><\/attributes><\/field><\/fields>\n+                    <methods>\n+                        <method>\n+                            <method_name>m<\/method_name>\n+                            <flags><flag>PROTECTED<\/flag><\/flags>\n+                            <method_type>(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;<\/method_type>\n+                            <attributes><attribute>AnnotationDefault<\/attribute><attribute>RuntimeVisibleParameterAnnotations<\/attribute><attribute>RuntimeInvisibleParameterAnnotations<\/attribute><attribute>Exceptions<\/attribute><attribute>Code<\/attribute><\/attributes>\n+                            <code>\n+                                <max_stack>1<\/max_stack>\n+                                <max_locals>3<\/max_locals>\n+                                <attributes><attribute>RuntimeInvisibleTypeAnnotations<\/attribute><attribute>RuntimeVisibleTypeAnnotations<\/attribute><attribute>LocalVariableTable<\/attribute><attribute>LocalVariableTypeTable<\/attribute><attribute>LineNumberTable<\/attribute><attribute>StackMapTable<\/attribute><\/attributes>\n+                                <stack_map_frames>\n+                                    <_6><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><\/stack><\/_6>\n+                                    <_7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/_7><\/stack_map_frames>\n+                                <__stack_map_frame__0><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><\/stack><\/__stack_map_frame__0>\n+                                <__try_block_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_start>\n+                                <_0><opcode>ILOAD_1<\/opcode><slot>1<\/slot><\/_0>\n+                                <_1><opcode>IFEQ<\/opcode><target>6<\/target><\/_1>\n+                                <_4><opcode>ALOAD_2<\/opcode><slot>2<\/slot><\/_4>\n+                                <_5><opcode>ATHROW<\/opcode><\/_5>\n+                                <__stack_map_frame__6><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><\/stack><\/__stack_map_frame__6>\n+                                <_6><opcode>RETURN<\/opcode><\/_6>\n+                                <__stack_map_frame__7><locals><item>Foo<\/item><item>int<\/item><item>java\/lang\/Throwable<\/item><\/locals><stack><item>Phee<\/item><\/stack><\/__stack_map_frame__7>\n+                                <__try_block_1_end><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__try_block_1_end>\n+                                <__exception_handler_1_start><start>0<\/start><end>7<\/end><handler>7<\/handler><catch_type>Phee<\/catch_type><\/__exception_handler_1_start>\n+                                <_7><opcode>ATHROW<\/opcode><\/_7>\n+                                <exception_handlers>\n+                                    <handler_1><start>0<\/start><end>7<\/end><handler>7<\/handler><type>Phee<\/type><\/handler_1><\/exception_handlers><\/code><\/method><\/methods><\/class>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testPrintXmlMembersOnly() throws IOException {\n+        var out = new StringBuilder();\n+        ClassPrinter.toXml(getClassModel(), ClassPrinter.Verbosity.MEMBERS_ONLY, out::append);\n+        assertOut(out,\n+                \"\"\"\n+                <?xml version = '1.0'?>\n+                <class>\n+                    <class_name>Foo<\/class_name>\n+                    <version>61.0<\/version>\n+                    <flags><flag>PUBLIC<\/flag><\/flags>\n+                    <superclass>Boo<\/superclass>\n+                    <interfaces><interface>Phee<\/interface><interface>Phoo<\/interface><\/interfaces>\n+                    <attributes><attribute>SourceFile<\/attribute><attribute>InnerClasses<\/attribute><attribute>EnclosingMethod<\/attribute><attribute>Synthetic<\/attribute><attribute>Signature<\/attribute><attribute>Deprecated<\/attribute><attribute>NestHost<\/attribute><attribute>NestMembers<\/attribute><attribute>Record<\/attribute><attribute>RuntimeInvisibleAnnotations<\/attribute><attribute>PermittedSubclasses<\/attribute><\/attributes>\n+                    <fields>\n+                        <field>\n+                            <field_name>f<\/field_name>\n+                            <flags><flag>PRIVATE<\/flag><\/flags>\n+                            <field_type>Ljava\/lang\/String;<\/field_type>\n+                            <attributes><attribute>RuntimeVisibleAnnotations<\/attribute><\/attributes><\/field><\/fields>\n+                    <methods>\n+                        <method>\n+                            <method_name>m<\/method_name>\n+                            <flags><flag>PROTECTED<\/flag><\/flags>\n+                            <method_type>(ZLjava\/lang\/Throwable;)Ljava\/lang\/Void;<\/method_type>\n+                            <attributes><attribute>AnnotationDefault<\/attribute><attribute>RuntimeVisibleParameterAnnotations<\/attribute><attribute>RuntimeInvisibleParameterAnnotations<\/attribute><attribute>Exceptions<\/attribute><attribute>Code<\/attribute><\/attributes><\/method><\/methods><\/class>\n+                \"\"\");\n+    }\n+\n+    @Test\n+    void testWalkTraceAll() throws IOException {\n+        var node = ClassPrinter.toTree(getClassModel(), ClassPrinter.Verbosity.TRACE_ALL);\n+        assertEquals(node.walk().count(), 509);\n+    }\n+\n+    @Test\n+    void testWalkCriticalAttributes() throws IOException {\n+        var node = ClassPrinter.toTree(getClassModel(), ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES);\n+        assertEquals(node.walk().count(), 128);\n+    }\n+\n+    @Test\n+    void testWalkMembersOnly() throws IOException {\n+        var node = ClassPrinter.toTree(getClassModel(), ClassPrinter.Verbosity.MEMBERS_ONLY);\n+        assertEquals(node.walk().count(), 41);\n+    }\n+\n+    private static void assertOut(StringBuilder out, String expected) {\n+\/\/        System.out.println(\"-----------------\");\n+\/\/        System.out.println(out.toString());\n+\/\/        System.out.println(\"-----------------\");\n+        assertArrayEquals(out.toString().trim().split(\" *\\r?\\n\"), expected.trim().split(\"\\n\"));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":847,"deletions":0,"binary":false,"changes":847,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile constant pool cloning.\n+ * @run junit ConstantPoolCopyTest\n+ *\/\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.DynamicConstantPoolEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.FloatEntry;\n+import jdk.internal.classfile.constantpool.IntegerEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.MethodTypeEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.SplitConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ConstantPoolCopyTest {\n+    private static ClassModel[] rtJarToClassLow(FileSystem fs) {\n+        try {\n+            var modules = Stream.of(\n+                    Files.walk(fs.getPath(\"modules\/java.base\/java\")),\n+                    Files.walk(fs.getPath(\"modules\"), 2).filter(p -> p.endsWith(\"module-info.class\")))\n+                    .flatMap(p -> p)\n+                    .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+                    .map(ConstantPoolCopyTest::readAllBytes)\n+                    .map(bytes -> Classfile.parse(bytes))\n+                    .toArray(ClassModel[]::new);\n+            return modules;\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    private static byte[] readAllBytes(Path p) {\n+        try {\n+            return Files.readAllBytes(p);\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    static ClassModel[] classes() {\n+        return rtJarToClassLow(FileSystems.getFileSystem(URI.create(\"jrt:\/\")));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"classes\")\n+    void cloneConstantPool(ClassModel c) throws Exception {\n+        ConstantPool cp = c.constantPool();\n+        ConstantPoolBuilder cp2 = new SplitConstantPool((ClassReader) cp);\n+\n+        assertEquals(cp2.entryCount(), cp.entryCount(), \"Cloned constant pool must be same size\");\n+\n+        for (int i = 1; i < cp.entryCount();) {\n+            PoolEntry cp1i = cp.entryByIndex(i);\n+            PoolEntry cp2i = cp2.entryByIndex(i);\n+            assertTrue(representsTheSame(cp1i, cp2i), cp2i + \" does not represent the same constant pool entry as \" + cp1i);\n+            i+= cp1i.width();\n+        }\n+\n+        \/\/ Bootstrap methods\n+        assertEquals(cp.bootstrapMethodCount(), cp2.bootstrapMethodCount());\n+        for (int i = 0; i<cp.bootstrapMethodCount(); i++)\n+            assertTrue(sameBootstrap(cp.bootstrapMethodEntry(i), cp2.bootstrapMethodEntry(i)));\n+    }\n+\n+    \/\/ This differs from a value-based equals in that the constant pool field can differ while the constants still\n+    \/\/ represent the same\n+    boolean representsTheSame(PoolEntry first, PoolEntry second) {\n+        if (first instanceof Utf8Entry i) {\n+            if (second instanceof Utf8Entry j) {\n+                return i.stringValue().equals(j.stringValue());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof ClassEntry i) {\n+            if (second instanceof ClassEntry j) {\n+                return i.asInternalName().equals(j.asInternalName());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof PackageEntry i) {\n+            if (second instanceof PackageEntry j) {\n+                return i.name().stringValue().equals(j.name().stringValue());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof ModuleEntry i) {\n+            if (second instanceof ModuleEntry j) {\n+                return i.name().stringValue().equals(j.name().stringValue());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof NameAndTypeEntry i) {\n+            if (second instanceof NameAndTypeEntry j) {\n+                return i.name().stringValue().equals(j.name().stringValue()) && i.type().stringValue().equals(j.type().stringValue());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof FieldRefEntry i) {\n+            if (second instanceof FieldRefEntry j) {\n+                return sameMemberRef(i,j);\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof MethodRefEntry i) {\n+            if (second instanceof MethodRefEntry j) {\n+                return sameMemberRef(i, j);\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof InterfaceMethodRefEntry i) {\n+            if (second instanceof InterfaceMethodRefEntry j) {\n+                return sameMemberRef(i, j);\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof InvokeDynamicEntry i) {\n+            if (second instanceof InvokeDynamicEntry j) {\n+                return sameDynamic(i, j);\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof ConstantDynamicEntry i) {\n+            if (second instanceof ConstantDynamicEntry j) {\n+                return sameDynamic(i, j);\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof MethodHandleEntry i) {\n+            if (second instanceof MethodHandleEntry j) {\n+                return i.kind() == j.kind() && sameMemberRef(i.reference(), j.reference());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof MethodTypeEntry i) {\n+            if (second instanceof MethodTypeEntry j) {\n+                return representsTheSame(i.descriptor(), j.descriptor());\n+            }\n+        } else if (first instanceof StringEntry i) {\n+            if (second instanceof StringEntry j) {\n+                return i.stringValue().equals(j.stringValue());\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof IntegerEntry i) {\n+            if (second instanceof IntegerEntry j) {\n+                return i.intValue() == j.intValue();\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof FloatEntry i) {\n+            if (second instanceof FloatEntry j) {\n+                return Float.isNaN(i.floatValue()) ? Float.isNaN(j.floatValue()) : i.floatValue() == j.floatValue();\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof LongEntry i) {\n+            if (second instanceof LongEntry j) {\n+                return i.longValue() == j.longValue();\n+            } else {\n+                return false;\n+            }\n+        } else if (first instanceof DoubleEntry i) {\n+            if (second instanceof DoubleEntry j) {\n+                return Double.isNaN(i.doubleValue()) ? Double.isNaN(j.doubleValue()) : i.doubleValue() == j.doubleValue();\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    boolean sameMemberRef(MemberRefEntry first, MemberRefEntry second) {\n+        return first.owner().asInternalName().equals(second.owner().asInternalName()) &&\n+               representsTheSame(first.nameAndType(), second.nameAndType());\n+    }\n+\n+    boolean sameDynamic(DynamicConstantPoolEntry first, DynamicConstantPoolEntry second) {\n+        return sameBootstrap(first.bootstrap(), second.bootstrap()) &&\n+                representsTheSame(first.nameAndType(), second.nameAndType());\n+    }\n+\n+    boolean sameBootstrap(BootstrapMethodEntry first, BootstrapMethodEntry second) {\n+        if (representsTheSame(first.bootstrapMethod(), second.bootstrapMethod()) &&\n+                first.arguments().size() == second.arguments().size()) {\n+            var firstArgs = first.arguments();\n+            var secondArgs = second.arguments();\n+\n+            for (int i = 0; i < firstArgs.size(); ++i) {\n+                if (!representsTheSame(firstArgs.get(i), secondArgs.get(i)))\n+                    return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ConstantPoolCopyTest.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile on small Corpus.\n+ * @build helpers.* testdata.*\n+ * @run junit\/othervm -Djunit.jupiter.execution.parallel.enabled=true CorpusTest\n+ *\/\n+import helpers.ClassRecord;\n+import helpers.ClassRecord.CompatibilityFilter;\n+import helpers.Transforms;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.api.parallel.Execution;\n+import org.junit.jupiter.api.parallel.ExecutionMode;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.*;\n+\n+import static helpers.ClassRecord.assertEqualsDeep;\n+import static java.util.stream.Collectors.joining;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static helpers.TestUtil.assertEmpty;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.impl.DirectCodeBuilder;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import jdk.internal.classfile.instruction.LineNumber;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+\n+\/**\n+ * CorpusTest\n+ *\/\n+@Execution(ExecutionMode.CONCURRENT)\n+class CorpusTest {\n+\n+    protected static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    protected static final String testFilter = null; \/\/\"modules\/java.base\/java\/util\/function\/Supplier.class\";\n+\n+    static void splitTableAttributes(String sourceClassFile, String targetClassFile) throws IOException, URISyntaxException {\n+        var root = Paths.get(URI.create(CorpusTest.class.getResource(\"CorpusTest.class\").toString())).getParent();\n+        Files.write(root.resolve(targetClassFile), Classfile.parse(root.resolve(sourceClassFile)).transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+            var dcob = (DirectCodeBuilder)cob;\n+            var curPc = dcob.curPc();\n+            switch (coe) {\n+                case LineNumber ln -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LINE_NUMBER_TABLE) {\n+                    @Override\n+                    public void writeBody(BufWriter b) {\n+                        b.writeU2(1);\n+                        b.writeU2(curPc);\n+                        b.writeU2(ln.line());\n+                    }\n+                });\n+                case LocalVariable lv -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TABLE) {\n+                    @Override\n+                    public void writeBody(BufWriter b) {\n+                        b.writeU2(1);\n+                        lv.writeTo(b);\n+                    }\n+                });\n+                case LocalVariableType lvt -> dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.LOCAL_VARIABLE_TYPE_TABLE) {\n+                    @Override\n+                    public void writeBody(BufWriter b) {\n+                        b.writeU2(1);\n+                        lvt.writeTo(b);\n+                    }\n+                });\n+                default -> cob.with(coe);\n+            }\n+        })));\n+\/\/        ClassRecord.assertEqualsDeep(\n+\/\/                ClassRecord.ofClassModel(ClassModel.of(Files.readAllBytes(root.resolve(targetClassFile)))),\n+\/\/                ClassRecord.ofClassModel(ClassModel.of(Files.readAllBytes(root.resolve(sourceClassFile)))));\n+\/\/        ClassPrinter.toYaml(ClassModel.of(Files.readAllBytes(root.resolve(targetClassFile))), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+    }\n+\n+    static Path[] corpus() throws IOException, URISyntaxException {\n+        splitTableAttributes(\"testdata\/Pattern2.class\", \"testdata\/Pattern2-split.class\");\n+        return Stream.of(\n+                Files.walk(JRT.getPath(\"modules\/java.base\/java\")),\n+                Files.walk(JRT.getPath(\"modules\"), 2).filter(p -> p.endsWith(\"module-info.class\")),\n+                Files.walk(Paths.get(URI.create(CorpusTest.class.getResource(\"CorpusTest.class\").toString())).getParent()))\n+                .flatMap(p -> p)\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\") && !p.endsWith(\"DeadCodePattern.class\"))\n+                .filter(p -> testFilter == null || p.toString().equals(testFilter))\n+                .toArray(Path[]::new);\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"corpus\")\n+    void testNullAdaptations(Path path) throws Exception {\n+        byte[] bytes = Files.readAllBytes(path);\n+\n+        Optional<ClassRecord> oldRecord;\n+        Optional<ClassRecord> newRecord;\n+        Map<Transforms.NoOpTransform, Exception> errors = new HashMap<>();\n+        Map<Integer, Integer> baseDups = findDups(bytes);\n+\n+        for (Transforms.NoOpTransform m : Transforms.NoOpTransform.values()) {\n+            if (m == Transforms.NoOpTransform.ARRAYCOPY\n+                || m == Transforms.NoOpTransform.SHARED_3_NO_STACKMAP\n+                || m.name().startsWith(\"ASM\"))\n+                continue;\n+\n+            try {\n+                byte[] transformed = m.shared && m.classTransform != null\n+                                     ? Classfile.parse(bytes, Classfile.Option.generateStackmap(false))\n+                                                .transform(m.classTransform)\n+                                     : m.transform.apply(bytes);\n+                Map<Integer, Integer> newDups = findDups(transformed);\n+                oldRecord = m.classRecord(bytes);\n+                newRecord = m.classRecord(transformed);\n+                if (oldRecord.isPresent() && newRecord.isPresent())\n+                    assertEqualsDeep(newRecord.get(), oldRecord.get(),\n+                            \"Class[%s] with %s\".formatted(path, m.name()));\n+                switch (m) {\n+                    case SHARED_1, SHARED_2, SHARED_3, SHARED_3L, SHARED_3P:\n+                        if (newDups.size() > baseDups.size()) {\n+                            System.out.println(String.format(\"Incremental dups in file %s (%s): %s \/ %s\", path, m, baseDups, newDups));\n+                        }\n+                        compareCp(bytes, transformed);\n+                        break;\n+                    case UNSHARED_1, UNSHARED_2, UNSHARED_3:\n+                        if (!newDups.isEmpty()) {\n+                            System.out.println(String.format(\"Dups in file %s (%s): %s\", path, m, newDups));\n+                        }\n+                        break;\n+                }\n+            }\n+            catch (Exception ex) {\n+                System.err.printf(\"Error processing %s with %s: %s.%s%n\", path, m.name(),\n+                                  ex.getClass(), ex.getMessage());\n+                ex.printStackTrace(System.err);\n+                errors.put(m, ex);\n+            }\n+        }\n+\n+        if (!errors.isEmpty()) {\n+            String msg = String.format(\"Failures for %s:%n\", path)\n+                         + errors.entrySet().stream()\n+                                 .map(e -> {\n+                                     Exception exception = e.getValue();\n+                                     StackTraceElement[] trace = exception.getStackTrace();\n+                                     return String.format(\"    Mode %s: %s (%s:%d)\",\n+                                                   e.getKey(), exception.toString(),\n+                                                   trace.length > 0 ? trace[0].getClassName() : \"unknown\",\n+                                                   trace.length > 0 ? trace[0].getLineNumber() : 0);\n+                                 })\n+                                 .collect(joining(\"\\n\"));\n+            fail(String.format(\"Errors in testNullAdapt: %s\", msg));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"corpus\")\n+    void testReadAndTransform(Path path) throws IOException {\n+        byte[] bytes = Files.readAllBytes(path);\n+\n+        var classModel = Classfile.parse(bytes);\n+        assertEqualsDeep(ClassRecord.ofClassModel(classModel), ClassRecord.ofStreamingElements(classModel),\n+                         \"ClassModel (actual) vs StreamingElements (expected)\");\n+\n+        byte[] newBytes = Classfile.build(\n+                classModel.thisClass().asSymbol(),\n+                classModel::forEachElement);\n+        var newModel = Classfile.parse(newBytes);\n+        assertEqualsDeep(ClassRecord.ofClassModel(newModel, CompatibilityFilter.By_ClassBuilder),\n+                ClassRecord.ofClassModel(classModel, CompatibilityFilter.By_ClassBuilder),\n+                \"ClassModel[%s] transformed by ClassBuilder (actual) vs ClassModel before transformation (expected)\".formatted(path));\n+\n+        assertEmpty(newModel.verify(null));\n+    }\n+\n+\/\/    @Test(enabled = false)\n+\/\/    public void checkDups() {\n+        \/\/ Checks input files for dups -- and there are.  Not clear this test has value.\n+        \/\/ Tests above\n+\/\/        Map<Integer, Integer> dups = findDups(bytes);\n+\/\/        if (!dups.isEmpty()) {\n+\/\/            String dupsString = dups.entrySet().stream()\n+\/\/                                    .map(e -> String.format(\"%d -> %d\", e.getKey(), e.getValue()))\n+\/\/                                    .collect(joining(\", \"));\n+\/\/            System.out.println(String.format(\"Duplicate entries in input file %s: %s\", path, dupsString));\n+\/\/        }\n+\/\/    }\n+\n+    private void compareCp(byte[] orig, byte[] transformed) {\n+        var cp1 = Classfile.parse(orig).constantPool();\n+        var cp2 = Classfile.parse(transformed).constantPool();\n+\n+        for (int i = 1; i < cp1.entryCount(); i += cp1.entryByIndex(i).width()) {\n+            assertEquals(cpiToString(cp1.entryByIndex(i)), cpiToString(cp2.entryByIndex(i)));\n+        }\n+\n+        if (cp1.entryCount() != cp2.entryCount()) {\n+            StringBuilder failMsg = new StringBuilder(\"Extra entries in constant pool (\" + (cp2.entryCount() - cp1.entryCount()) + \"): \");\n+            for (int i = cp1.entryCount(); i < cp2.entryCount(); i += cp2.entryByIndex(i).width())\n+                failMsg.append(\"\\n\").append(cp2.entryByIndex(i));\n+            fail(failMsg.toString());\n+        }\n+    }\n+\n+    private static String cpiToString(PoolEntry e) {\n+        String s = e.toString();\n+        if (e instanceof Utf8Entry ue)\n+            s = \"CONSTANT_Utf8_info[value: \\\"%s\\\"]\".formatted(ue.stringValue());\n+        return s;\n+    }\n+\n+    private static Map<Integer, Integer> findDups(byte[] bytes) {\n+        Map<Integer, Integer> dups = new HashMap<>();\n+        var cf = Classfile.parse(bytes);\n+        var pool = cf.constantPool();\n+        Set<String> entryStrings = new HashSet<>();\n+        for (int i = 1; i < pool.entryCount(); i += pool.entryByIndex(i).width()) {\n+            String s = cpiToString(pool.entryByIndex(i));\n+            if (entryStrings.contains(s)) {\n+                for (int j=1; j<i; j += pool.entryByIndex(j).width()) {\n+                    var e2 = pool.entryByIndex(j);\n+                    if (s.equals(cpiToString(e2)))\n+                        dups.put(i, j);\n+                }\n+            }\n+            entryStrings.add(s);\n+        }\n+        return dups;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/CorpusTest.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing filtering of dead labels.\n+ * @run junit FilterDeadLabelsTest\n+ *\/\n+\n+import jdk.internal.classfile.Classfile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.Signature;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class FilterDeadLabelsTest {\n+\n+    static List<Consumer<CodeBuilder>> deadLabelFragments() {\n+        return List.of(\n+                cob -> cob.exceptionCatchAll(cob.newLabel(), cob.startLabel(), cob.endLabel()),\n+                cob -> cob.exceptionCatchAll(cob.startLabel(), cob.newLabel(), cob.endLabel()),\n+                cob -> cob.exceptionCatchAll(cob.startLabel(), cob.endLabel(), cob.newLabel()),\n+                cob -> cob.localVariable(0, \"v\", ConstantDescs.CD_int, cob.startLabel(), cob.newLabel()),\n+                cob -> cob.localVariable(0, \"v\", ConstantDescs.CD_int, cob.newLabel(), cob.endLabel()),\n+                cob -> cob.localVariableType(0, \"v\", Signature.of(ConstantDescs.CD_int), cob.startLabel(), cob.newLabel()),\n+                cob -> cob.localVariableType(0, \"v\", Signature.of(ConstantDescs.CD_int), cob.newLabel(), cob.endLabel()),\n+                cob -> cob.characterRange(cob.startLabel(), cob.newLabel(), 0, 0, 0),\n+                cob -> cob.characterRange(cob.newLabel(), cob.endLabel(), 0, 0, 0));\n+    }\n+\n+    @Test\n+    void testFilterDeadLabels() {\n+        var code = Classfile.parse(Classfile.build(ClassDesc.of(\"cls\"), List.of(Classfile.Option.filterDeadLabels(true)), clb ->\n+                clb.withMethodBody(\"m\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, cob -> {\n+                    cob.return_();\n+                    deadLabelFragments().forEach(f -> f.accept(cob));\n+                }))).methods().get(0).code().get();\n+\n+        assertTrue(code.exceptionHandlers().isEmpty());\n+        code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE).ifPresent(a -> assertTrue(a.localVariables().isEmpty()));\n+        code.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).ifPresent(a -> assertTrue(a.localVariableTypes().isEmpty()));\n+        code.findAttribute(Attributes.CHARACTER_RANGE_TABLE).ifPresent(a -> assertTrue(a.characterRangeTable().isEmpty()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"deadLabelFragments\")\n+    void testThrowOnDeadLabels(Consumer<CodeBuilder> fragment) {\n+        assertThrows(IllegalStateException.class, () -> Classfile.build(ClassDesc.of(\"cls\"), clb ->\n+                clb.withMethodBody(\"m\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, cob -> {\n+                    cob.return_();\n+                    fragment.accept(cob);\n+                })));\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/FilterDeadLabelsTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile LDC instructions.\n+ * @run junit LDCTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import java.lang.reflect.AccessFlag;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import static helpers.TestConstants.MTD_VOID;\n+import static jdk.internal.classfile.Opcode.*;\n+import static jdk.internal.classfile.TypeKind.VoidType;\n+\n+class LDCTest {\n+    @Test\n+    void testLDCisConvertedToLDCW() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withVersion(52, 0);\n+            cb.withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .returnInstruction(VoidType)\n+                      )\n+              )\n+\n+              .withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(c0 -> {\n+                                  ConstantPoolBuilder cpb = cb.constantPool();\n+                                  for (int i = 0; i <= 256\/2 + 2; i++) { \/\/ two entries per String\n+                                      StringEntry s = cpb.stringEntry(\"string\" + i);\n+                                  }\n+                                  c0.constantInstruction(LDC, \"string0\")\n+                                    .constantInstruction(LDC, \"string131\")\n+                                    .constantInstruction(LDC, \"string50\")\n+                                    .returnInstruction(VoidType);\n+                              }));\n+        });\n+\n+        var model = Classfile.parse(bytes);\n+        var code = model.elementStream()\n+                .filter(e -> e instanceof MethodModel)\n+                .map(e -> (MethodModel) e)\n+                .filter(e -> e.methodName().stringValue().equals(\"main\"))\n+                .flatMap(MethodModel::elementStream)\n+                .filter(e -> e instanceof CodeModel)\n+                .map(e -> (CodeModel) e)\n+                .findFirst()\n+                .orElseThrow();\n+        var opcodes = code.elementList().stream()\n+                          .filter(e -> e instanceof Instruction)\n+                          .map(e -> (Instruction)e)\n+                          .toList();\n+\n+        assertEquals(opcodes.size(), 4);\n+        assertEquals(opcodes.get(0).opcode(), LDC);\n+        assertEquals(opcodes.get(1).opcode(), LDC_W);\n+        assertEquals(opcodes.get(2).opcode(), LDC);\n+        assertEquals(opcodes.get(3).opcode(), RETURN);\n+    }\n+\n+    \/\/ TODO test for explicit LDC_W?\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile limits.\n+ * @run junit LimitsTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+class LimitsTest {\n+\n+    @Test\n+    void testCPSizeLimit() {\n+        Classfile.build(ClassDesc.of(\"BigClass\"), cb -> {\n+            for (int i = 1; i < 65000; i++) {\n+                cb.withField(\"field\" + i, ConstantDescs.CD_int, fb -> {});\n+            }\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile low adaptation.\n+ * @run junit LowAdaptTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.net.URI;\n+import java.nio.file.Paths;\n+\n+import jdk.internal.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import helpers.ByteArrayClassLoader;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.impl.DirectClassBuilder;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class LowAdaptTest {\n+\n+    static final String test = \"LowAdaptTest$TestClass\";\n+\n+    @Test\n+    void testAdapt() throws Exception {\n+        ClassModel cl = Classfile.parse(Paths.get(URI.create(LowAdaptTest.class.getResource(test + \".class\").toString())));\n+\n+        DirectMethodHandleDesc bsm = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                               ClassDesc.of(\"java.lang.invoke.LambdaMetafactory\"),\n+                                                               \"metafactory\",\n+                                                               MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;\"\n+                                                                                           + \"Ljava\/lang\/invoke\/MethodType;\"\n+                                                                                           + \"Ljava\/lang\/invoke\/MethodType;\"\n+                                                                                           + \"Ljava\/lang\/invoke\/MethodHandle;\"\n+                                                                                           + \"Ljava\/lang\/invoke\/MethodType;\"\n+                                                                                           + \")Ljava\/lang\/invoke\/CallSite;\"));\n+        DynamicCallSiteDesc indy = DynamicCallSiteDesc.of(bsm,\n+                                                          \"applyAsInt\", MethodTypeDesc.ofDescriptor(\"()Ljava\/util\/function\/IntUnaryOperator;\"),\n+                                                          MethodTypeDesc.ofDescriptor(\"(I)I\"),\n+                                                          MethodHandleDesc.of(DirectMethodHandleDesc.Kind.STATIC, ClassDesc.of(test), \"fib\", \"(I)I\"),\n+                                                          MethodTypeDesc.ofDescriptor(\"(I)I\"));\n+\n+        byte[] clazz = Classfile.build(ClassDesc.of(test), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.with(SourceFileAttribute.of(\"\/some\/madeup\/TestClass.java\"));\n+            cl.methods().forEach(m -> ((DirectClassBuilder) cb).withMethod(m));\n+\n+            cb.withMethod(\"doit\", MethodTypeDesc.of(CD_int, CD_int),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(xb -> {\n+                              xb.invokeDynamicInstruction(indy);\n+                              xb.storeInstruction(TypeKind.ReferenceType, 1);\n+                              xb.loadInstruction(TypeKind.ReferenceType, 1);\n+                              xb.loadInstruction(TypeKind.IntType, 0);\n+                              xb.invokeInstruction(Opcode.INVOKEINTERFACE, ClassDesc.of(\"java.util.function.IntUnaryOperator\"),\n+                                                   \"applyAsInt\", MethodTypeDesc.ofDescriptor(\"(I)I\"), true);\n+                              xb.storeInstruction(TypeKind.IntType, 2);\n+                              xb.loadInstruction(TypeKind.IntType, 2);\n+                              xb.returnInstruction(TypeKind.IntType);\n+                          }));\n+        });\n+\n+\n+        int result = (Integer)\n+                new ByteArrayClassLoader(LowAdaptTest.class.getClassLoader(), test, clazz)\n+                        .getMethod(test,\"doit\")\n+                        .invoke(null, 10);\n+        assertEquals(result, 55);\n+    }\n+\n+    public static class TestClass {\n+\n+        static int fib(int n) {\n+            if (n <= 1)\n+                return n;\n+            return fib(n - 1) + fib(n - 2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/LowAdaptTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile low JCov attributes.\n+ * @compile -Xjcov LowJCovAttributeTest.java\n+ * @run junit LowJCovAttributeTest\n+ *\/\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * LowJCovAttributeTest\n+ *\/\n+class LowJCovAttributeTest {\n+\n+    private static final boolean VERBOSE = false;\n+\n+    \/\/ (isolated and) compiled with -Xjcov\n+    private static final String TEST_FILE = \"LowJCovAttributeTest.class\";\n+\n+    private final Path path;\n+    private final ClassModel classLow;\n+\n+    LowJCovAttributeTest() throws IOException {\n+        this.path = Paths.get(URI.create(LowJCovAttributeTest.class.getResource(TEST_FILE).toString()));\n+        this.classLow = Classfile.parse(path);\n+    }\n+\n+    @Test\n+    void testRead() {\n+        try {\n+            testRead0();\n+        } catch(Exception ex) {\n+            System.err.printf(\"%nLowJCovAttributeTest: FAIL %s%n\", ex);\n+            ex.printStackTrace(System.err);\n+            throw ex;\n+        }\n+    }\n+\n+    private void testRead0() {\n+        int[] mask = new int[1];\n+        for (Attribute<?> attr : classLow.attributes()) {\n+            switch (attr.attributeName()) {\n+                case Attributes.NAME_COMPILATION_ID: {\n+                    CompilationIDAttribute cid = (CompilationIDAttribute) attr;\n+                    Utf8Entry v = cid.compilationId();\n+                    printf(\"CompilationID %s%n\", v);\n+                    mask[0] |= 1;\n+                    break;\n+                }\n+                case Attributes.NAME_SOURCE_ID: {\n+                    SourceIDAttribute cid = (SourceIDAttribute) attr;\n+                    Utf8Entry v = cid.sourceId();\n+                    printf(\"SourceID %s%n\", v);\n+                    mask[0] |= 2;\n+                    break;\n+                }\n+            }\n+        }\n+        for (MethodModel m : classLow.methods()) {\n+            m.findAttribute(Attributes.CODE).ifPresent(code ->\n+                ((CodeModel) code).findAttribute(Attributes.CHARACTER_RANGE_TABLE).ifPresent(attr -> {\n+                                for (CharacterRangeInfo cr : attr.characterRangeTable()) {\n+                                    printf(\"  %d-%d -> %d\/%d-%d\/%d (%x)%n\", cr.startPc(), cr.endPc(),\n+                                            cr.characterRangeStart() >> 10, cr.characterRangeStart() & 0x3FF,\n+                                            cr.characterRangeEnd() >> 10, cr.characterRangeEnd() & 0x3FF,\n+                                            cr.flags());\n+                                }\n+                                mask[0] |= 4;\n+                            }\n+                            ));\n+        }\n+        assertEquals(mask[0], 7, \"Not all JCov attributes seen\");\n+    }\n+\n+    private void printf(String format, Object... args) {\n+        if (VERBOSE) {\n+            System.out.printf(format, args);\n+        }\n+    }\n+\n+    private void println() {\n+        if (VERBOSE) {\n+            System.out.println();\n+        }\n+    }\n+\n+\/\/    @Test\n+\/\/    void testWrite() {\n+\/\/        try {\n+\/\/            testWrite0();\n+\/\/        } catch(Exception ex) {\n+\/\/            System.err.printf(\"%nLowJCovAttributeTest: FAIL %s - %s%n\", path, ex);\n+\/\/            ex.printStackTrace(System.err);\n+\/\/            throw ex;\n+\/\/        }\n+\/\/    }\n+\n+\/\/    private void testWrite0() {\n+\/\/        ConstantPoolLow cp = classLow.constantPool();\n+\/\/        ConstantPoolLow cp2 = cp.clonedPool();\n+\/\/        int sz = cp.size();\n+\/\/        \/\/ check match of constant pools\n+\/\/        assertEquals(cp2.size(), cp.size(), \"Cloned size should match\");\n+\/\/        for (int i = 1; i < sz; ) {\n+\/\/            ConstantPoolInfo info = cp.get(i);\n+\/\/            ConstantPoolInfo info2 = cp2.get(i);\n+\/\/            assertNotNull(info2, \"Test set up failure -- Null CP entry copy of \" + info.tag() + \" [\" + info.index() + \"] @ \"\n+\/\/                    + i\n+\/\/            );\n+\/\/            assertEquals(info2.index(), info.index(),\n+\/\/                    \"Test set up failure -- copying constant pool (index). \\n\"\n+\/\/                            + \"Orig: \" + info.tag() + \" [\" + info.index() + \"].\\n\"\n+\/\/                            + \"Copy: \" + info2.tag() + \" [\" + info2.index() + \"].\");\n+\/\/            assertEquals(info2.tag(), info.tag(),\n+\/\/                    \"Test set up failure -- copying constant pool (tag). \\n\"\n+\/\/                            + \"Orig: \" + info.tag() + \" [\" + info.index() + \"].\\n\"\n+\/\/                            + \"Copy: \" + info2.tag() + \" [\" + info2.index() + \"].\");\n+\/\/            i += info.tag().poolEntries;\n+\/\/        }\n+\/\/        writeAndCompareAttributes(classLow, cp);\n+\/\/        for (MethodLow m : classLow.methodsLow()) {\n+\/\/            m.findAttribute(Attributes.CODE).ifPresent(code ->\n+\/\/                    writeAndCompareAttributes(code, cp));\n+\/\/        }\n+\/\/    }\n+\n+\/\/    private void writeAndCompareAttributes(AttributeHolder ah, ConstantPoolLow cp) {\n+\/\/        for (AttributeLow attr : ah.attributes()) {\n+\/\/            if (attr instanceof UnknownAttribute) {\n+\/\/                System.err.printf(\"Unknown attribute %s - in %s%n\", attr.attributeName(), path);\n+\/\/            } else if (attr instanceof BootstrapMethodsAttribute\n+\/\/                    || attr instanceof StackMapTableAttribute) {\n+\/\/                \/\/ ignore\n+\/\/            } else {\n+\/\/                BufWriter gbb = new BufWriter(cp);\n+\/\/                BufWriter gbb2 = new BufWriter(cp);\n+\/\/                attr.writer().build(gbb);\n+\/\/                attr.writer().build(gbb2);\n+\/\/                assertEquals(gbb.bytes(), gbb2.bytes(),\n+\/\/                        \"Mismatched written attributes -  \" + attr);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/LowJCovAttributeTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile low module attribute.\n+ * @run junit LowModuleTest\n+ *\/\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.internal.classfile.Attribute;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * LowModuleTest\n+ *\/\n+class LowModuleTest {\n+\n+    private static final boolean VERBOSE = false;\n+\n+    static Path[] corpus() throws IOException {\n+        return Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/\"))\n+                .filter(p -> Files.isRegularFile(p))\n+                .filter(p -> p.endsWith(\"module-info.class\"))\n+                .toArray(Path[]::new);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"corpus\")\n+    void testRead(Path path, TestInfo test) throws Exception {\n+        try {\n+            printf(\"%nCHECK %s%n\", test.getDisplayName());\n+            ClassModel classLow = Classfile.parse(path);\n+            testRead0(classLow);\n+        } catch(Exception ex) {\n+            System.err.printf(\"%nFAIL %s - %s%n\", path, ex);\n+            ex.printStackTrace(System.err);\n+            throw ex;\n+        }\n+    }\n+\n+    private void testRead0(ClassModel classLow) {\n+        for (Attribute<?> attr : classLow.attributes()) {\n+            switch (attr.attributeName()) {\n+                case Attributes.NAME_SOURCE_FILE: {\n+                    SourceFileAttribute sfa = (SourceFileAttribute) attr;\n+                    Utf8Entry sf = sfa.sourceFile();\n+                    printf(\"SourceFile %s%n\", sf);\n+                    break;\n+                }\n+                case Attributes.NAME_MODULE: {\n+                    ModuleAttribute mal = (ModuleAttribute) attr;\n+                    ModuleEntry mni = mal.moduleName();\n+                    int mf = mal.moduleFlagsMask();\n+                    Utf8Entry mv = mal.moduleVersion().orElse(null);\n+                    printf(\"Module %s [%d] %s%n\", mni, mf, mv);\n+                    for (ModuleRequireInfo r : mal.requires()) {\n+                        ModuleEntry rm = r.requires();\n+                        int ri = r.requiresFlagsMask();\n+                        Utf8Entry rv = r.requiresVersion().orElse(null);\n+                        printf(\"  Requires %s [%d] %s%n\", rm, ri, rv);\n+                    }\n+                    for (ModuleExportInfo e : mal.exports()) {\n+                        printf(\"  Export %s [%d] - \",\n+                               e.exportedPackage(), e.exportsFlags());\n+                        for (ModuleEntry mi : e.exportsTo()) {\n+                            printf(\"%s \", mi);\n+                        }\n+                        println();\n+                    }\n+                    for (ModuleOpenInfo o : mal.opens()) {\n+                        printf(\"  Open %s [%d] - \",\n+                               o.openedPackage(), o.opensFlags());\n+                        for (ModuleEntry mi : o.opensTo()) {\n+                            printf(\"%s \", mi);\n+                        }\n+                        println();\n+                    }\n+                    for (ClassEntry u : mal.uses()) {\n+                        printf(\"  Use %s%n\", u);\n+                    }\n+                    for (ModuleProvideInfo provide : mal.provides()) {\n+                        printf(\"  Provide %s - \", provide.provides());\n+                        for (ClassEntry ci : provide.providesWith()) {\n+                            printf(\"%s \", ci);\n+                        }\n+                        println();\n+                    }\n+                    break;\n+                }\n+                case Attributes.NAME_MODULE_PACKAGES: {\n+                    ModulePackagesAttribute mp = (ModulePackagesAttribute) attr;\n+                    printf(\"ModulePackages%n\");\n+                    for (PackageEntry pi : mp.packages()) {\n+                        printf(\"  %s%n\", pi);\n+                    }\n+                    break;\n+                }\n+                case Attributes.NAME_MODULE_TARGET: {\n+                    ModuleTargetAttribute mt = (ModuleTargetAttribute) attr;\n+                    printf(\"ModuleTarget %s%n\", mt.targetPlatform());\n+                    break;\n+                }\n+                case Attributes.NAME_MODULE_RESOLUTION: {\n+                    ModuleResolutionAttribute mr = (ModuleResolutionAttribute) attr;\n+                    printf(\"ModuleResolution %d%n\", mr.resolutionFlags());\n+                    break;\n+                }\n+                case Attributes.NAME_MODULE_HASHES: {\n+                    ModuleHashesAttribute mh = (ModuleHashesAttribute) attr;\n+                    printf(\"ModuleHashes %s%n\", mh.algorithm());\n+                    for (ModuleHashInfo hi : mh.hashes()) {\n+                        printf(\"  %s: %n\", hi.moduleName());\n+                        for (byte b : hi.hash()) {\n+                            printf(\"%2x\", b);\n+                        }\n+                        println();\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void printf(String format, Object... args) {\n+        if (VERBOSE) {\n+            System.out.printf(format, args);\n+        }\n+    }\n+\n+    private void println() {\n+        if (VERBOSE) {\n+            System.out.println();\n+        }\n+    }\n+\n+\/\/    @Test\n+\/\/    public void testWrite() {\n+\/\/        try {\n+\/\/            testWrite0();\n+\/\/        } catch(Exception ex) {\n+\/\/            System.err.printf(\"%nFAIL %s - %s%n\", path, ex);\n+\/\/            ex.printStackTrace(System.err);\n+\/\/            throw ex;\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    private void testWrite0() {\n+\/\/        ConstantPoolLow cp = classLow.constantPool();\n+\/\/        ConstantPoolLow cp2 = cp.clonedPool();\n+\/\/        int sz = cp.size();\n+\/\/        \/\/ check match of constant pools\n+\/\/        assertEquals(cp2.size(), cp.size(),  \"Cloned size should match\");\n+\/\/        for (int i = 1; i < sz; ) {\n+\/\/            ConstantPoolInfo info = cp.get(i);\n+\/\/            ConstantPoolInfo info2 = cp2.get(i);\n+\/\/            assertNotNull(info2, \"Test set up failure -- Null CP entry copy of \" + info.tag() + \" [\" + info.index() + \"] @ \"\n+\/\/                    + i\n+\/\/                    + \" -- \" + getTestName()\n+\/\/            );\n+\/\/            assertEquals(info2.index(), info.index(),\n+\/\/                    \"Test set up failure -- copying constant pool (index). \\n\"\n+\/\/                            + \"Orig: \" + info.tag() + \" [\" + info.index() + \"].\\n\"\n+\/\/                            + \"Copy: \" + info2.tag() + \" [\" + info2.index() + \"].\");\n+\/\/            assertEquals(info2.tag(), info.tag(),\n+\/\/                    \"Test set up failure -- copying constant pool (tag). \\n\"\n+\/\/                            + \"Orig: \" + info.tag() + \" [\" + info.index() + \"].\\n\"\n+\/\/                            + \"Copy: \" + info2.tag() + \" [\" + info2.index() + \"].\");\n+\/\/            i += info.tag().poolEntries;\n+\/\/        }\n+\/\/        for (Attribute attr : classLow.attributes()) {\n+\/\/            if (attr instanceof UnknownAttribute) {\n+\/\/                System.err.printf(\"Unknown attribute %s - in %s%n\", attr.attributeName(), path);\n+\/\/            } else {\n+\/\/                BufWriter gbb = new BufWriter(cp);\n+\/\/                BufWriter gbb2 = new BufWriter(cp);\n+\/\/                attr.writeTo(gbb);\n+\/\/                attr.writeTo(gbb2);\n+\/\/                assertEquals(gbb2.bytes(), gbb.bytes(),\n+\/\/                        \"Mismatched written attributes -  \" + attr);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/LowModuleTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile local variable table.\n+ * @compile -g testdata\/Lvt.java\n+ * @run junit LvtTest\n+ *\/\n+import helpers.ClassRecord;\n+import helpers.Transforms;\n+import jdk.internal.classfile.*;\n+\n+import java.io.*;\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+import java.lang.reflect.AccessFlag;\n+import org.junit.jupiter.api.Test;\n+\n+import static helpers.TestConstants.CD_ArrayList;\n+import static helpers.TestConstants.CD_PrintStream;\n+import static helpers.TestConstants.CD_System;\n+import static helpers.TestConstants.MTD_INT_VOID;\n+import static helpers.TestConstants.MTD_VOID;\n+import static helpers.TestUtil.ExpectedLvRecord;\n+import static helpers.TestUtil.ExpectedLvtRecord;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+import static jdk.internal.classfile.Opcode.*;\n+import static jdk.internal.classfile.Opcode.INVOKEVIRTUAL;\n+import static jdk.internal.classfile.TypeKind.VoidType;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class LvtTest {\n+    static byte[] fileBytes;\n+\n+    static {\n+        try {\n+            fileBytes = Files.readAllBytes(Paths.get(URI.create(testdata.Lvt.class.getResource(\"Lvt.class\").toString())));\n+        }\n+        catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    @Test\n+    void getLVTEntries() {\n+        ClassModel c = Classfile.parse(fileBytes);\n+        CodeModel co = c.methods().stream()\n+                        .filter(mm -> mm.methodName().stringValue().equals(\"m\"))\n+                        .map(MethodModel::code)\n+                        .findFirst()\n+                        .get()\n+                        .orElseThrow();\n+\n+        List<LocalVariable> lvs = new ArrayList<>();\n+        co.forEachElement(e -> {\n+            if (e instanceof LocalVariable l) lvs.add(l);\n+        });\n+\n+        List<ExpectedLvRecord> expected = List.of(\n+                ExpectedLvRecord.of(5, \"j\", \"I\", 9, 21),\n+                ExpectedLvRecord.of(0, \"this\", \"Ltestdata\/Lvt;\", 0, 31),\n+                ExpectedLvRecord.of(1, \"a\", \"Ljava\/lang\/String;\", 0, 31),\n+                ExpectedLvRecord.of(4, \"d\", \"[C\", 6, 25));\n+\n+        \/\/ Exploits non-symmetric \"equals\" in ExpectedLvRecord\n+        assertTrue(expected.equals(lvs));\n+    }\n+\n+    @Test\n+    void buildLVTEntries() throws Exception {\n+        ClassModel c = Classfile.parse(fileBytes);\n+\n+        \/\/ Compare transformed model and original with CodeBuilder filter\n+        byte[] newClass = c.transform(Transforms.threeLevelNoop);\n+        ClassRecord orig = ClassRecord.ofClassModel(Classfile.parse(fileBytes), ClassRecord.CompatibilityFilter.By_ClassBuilder);\n+        ClassRecord transformed = ClassRecord.ofClassModel(Classfile.parse(newClass), ClassRecord.CompatibilityFilter.By_ClassBuilder);\n+        ClassRecord.assertEqualsDeep(transformed, orig);\n+    }\n+\n+    @Test\n+    void testCreateLoadLVT() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withVersion(52, 0);\n+            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .returnInstruction(VoidType)\n+                      )\n+              )\n+              .withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb\n+                              .withCode(c0 -> {\n+                                  ConstantPoolBuilder cpb = cb.constantPool();\n+                                  Utf8Entry slotName = cpb.utf8Entry(\"this\");\n+                                  Utf8Entry desc = cpb.utf8Entry(\"LMyClass;\");\n+                                  Utf8Entry i1n = cpb.utf8Entry(\"res\");\n+                                  Utf8Entry i2 = cpb.utf8Entry(\"i\");\n+                                  Utf8Entry intSig = cpb.utf8Entry(\"I\");\n+                                  Label start = c0.newLabel();\n+                                  Label end = c0.newLabel();\n+                                  Label i1 = c0.newLabel();\n+                                  Label preEnd = c0.newLabel();\n+                                  Label loopTop = c0.newLabel();\n+                                  Label loopEnd = c0.newLabel();\n+                                  c0.localVariable(1, i1n, intSig, i1, preEnd) \/\/ LV Entries can be added before the labels\n+                                    .localVariable(2, i2, intSig, loopTop, preEnd)\n+                                    .labelBinding(start)\n+                                    .constantInstruction(ICONST_1, 1)         \/\/ 0\n+                                    .storeInstruction(TypeKind.IntType, 1)          \/\/ 1\n+                                    .labelBinding(i1)\n+                                    .constantInstruction(ICONST_1, 1)         \/\/ 2\n+                                    .storeInstruction(TypeKind.IntType, 2)          \/\/ 3\n+                                    .labelBinding(loopTop)\n+                                    .loadInstruction(TypeKind.IntType, 2)           \/\/ 4\n+                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n+                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n+                                    .loadInstruction(TypeKind.IntType, 1)           \/\/ 7\n+                                    .loadInstruction(TypeKind.IntType, 2)           \/\/ 8\n+                                    .operatorInstruction(IMUL)             \/\/ 9\n+                                    .storeInstruction(TypeKind.IntType, 1)          \/\/ 10\n+                                    .incrementInstruction(2, 1)    \/\/ 11\n+                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                    .labelBinding(loopEnd)\n+                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n+                                    .loadInstruction(TypeKind.IntType, 1)\n+                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n+                                    .labelBinding(preEnd)\n+                                    .returnInstruction(VoidType)\n+                                    .labelBinding(end)\n+                                    .localVariable(0, slotName, desc, start, end); \/\/ and lv entries can be added after the labels\n+                              }));\n+        });\n+\n+        var c = Classfile.parse(bytes);\n+        var main = c.methods().get(1);\n+        var lvt = main.code().get().findAttribute(Attributes.LOCAL_VARIABLE_TABLE).get();\n+        var lvs = lvt.localVariables();\n+\n+        assertEquals(lvs.size(), 3);\n+        List<ExpectedLvRecord> expected = List.of(\n+                ExpectedLvRecord.of(1, \"res\", \"I\", 2, 25),\n+                ExpectedLvRecord.of(2, \"i\", \"I\", 4, 23),\n+                ExpectedLvRecord.of(0, \"this\", \"LMyClass;\", 0, 28));\n+\n+        \/\/ Exploits non-symmetric \"equals\" in ExpectedLvRecord\n+        assertTrue(expected.equals(lvs));\n+    }\n+\n+    @Test\n+    void getLVTTEntries() {\n+        ClassModel c = Classfile.parse(fileBytes);\n+        CodeModel co = c.methods().stream()\n+                        .filter(mm -> mm.methodName().stringValue().equals(\"n\"))\n+                        .map(MethodModel::code)\n+                        .findFirst()\n+                        .get()\n+                        .orElseThrow();\n+\n+        List<LocalVariableType> lvts = new ArrayList<>();\n+        co.forEachElement(e -> {\n+            if (e instanceof LocalVariableType l) lvts.add(l);\n+        });\n+\n+        \/* From javap:\n+\n+        LocalVariableTypeTable:\n+        Start  Length  Slot  Name   Signature\n+        51       8     6     f   Ljava\/util\/List<*>;\n+        0      64     1     u   TU;\n+        0      64     2     z   Ljava\/lang\/Class<+Ljava\/util\/List<*>;>;\n+        8      56     3     v   Ljava\/util\/ArrayList<Ljava\/lang\/Integer;>;\n+        17      47     4     s   Ljava\/util\/Set<-Ljava\/util\/Set;>;\n+        *\/\n+\n+        List<ExpectedLvtRecord> expected = List.of(\n+                ExpectedLvtRecord.of(6, \"f\", \"Ljava\/util\/List<*>;\", 51, 8),\n+                ExpectedLvtRecord.of(1, \"u\", \"TU;\", 0, 64),\n+                ExpectedLvtRecord.of(2, \"z\", \"Ljava\/lang\/Class<+Ljava\/util\/List<*>;>;\", 0, 64),\n+                ExpectedLvtRecord.of(3, \"v\", \"Ljava\/util\/ArrayList<Ljava\/lang\/Integer;>;\", 8, 56),\n+                ExpectedLvtRecord.of(4, \"s\", \"Ljava\/util\/Set<-Ljava\/util\/Set<*>;>;\", 17, 47)\n+        );\n+\n+        \/\/ Exploits non-symmetric \"equals\" in ExpectedLvRecord\n+        for (int i = 0; i < lvts.size(); i++) {\n+            assertTrue(expected.get(i).equals(lvts.get(i)));\n+        }\n+    }\n+\n+    @Test\n+    void testCreateLoadLVTT() throws Exception {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withVersion(52, 0);\n+            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .returnInstruction(VoidType)\n+                      )\n+              )\n+\n+              .withMethod(\"m\", MethodTypeDesc.of(CD_Object, CD_Object.arrayType()),\n+                          Classfile.ACC_PUBLIC,\n+                          mb -> mb.withFlags(AccessFlag.PUBLIC)\n+                                  .withCode(c0 -> {\n+                                      ConstantPoolBuilder cpb = cb.constantPool();\n+                                      Utf8Entry slotName = cpb.utf8Entry(\"this\");\n+                                      Utf8Entry desc = cpb.utf8Entry(\"LMyClass;\");\n+                                      Utf8Entry juList = cpb.utf8Entry(\"Ljava\/util\/List;\");\n+                                      Utf8Entry TU = cpb.utf8Entry(\"TU;\");\n+                                      Utf8Entry sig = cpb.utf8Entry(\"Ljava\/util\/List<+Ljava\/lang\/Object;>;\");\n+                                      Utf8Entry l = cpb.utf8Entry(\"l\");\n+                                      Utf8Entry jlObject = cpb.utf8Entry(\"Ljava\/lang\/Object;\");\n+                                      Utf8Entry u = cpb.utf8Entry(\"u\");\n+\n+                                      Label start = c0.newLabel();\n+                                      Label end = c0.newLabel();\n+                                      Label beforeRet = c0.newLabel();\n+\n+                                      c0.localVariable(2, l, juList, beforeRet, end)\n+                                        .localVariableType(1, u, TU, start, end)\n+                                        .labelBinding(start)\n+                                        .newObjectInstruction(ClassDesc.of(\"java.util.ArrayList\"))\n+                                        .stackInstruction(DUP)\n+                                        .invokeInstruction(INVOKESPECIAL, CD_ArrayList, \"<init>\", MTD_VOID, false)\n+                                        .storeInstruction(TypeKind.ReferenceType, 2)\n+                                        .labelBinding(beforeRet)\n+                                        .localVariableType(2, l, sig, beforeRet, end)\n+                                        .loadInstruction(TypeKind.ReferenceType, 1)\n+                                        .returnInstruction(TypeKind.ReferenceType)\n+                                        .labelBinding(end)\n+                                        .localVariable(0, slotName, desc, start, end)\n+                                        .localVariable(1, u, jlObject, start, end);\n+                                  }));\n+        });\n+        var c = Classfile.parse(bytes);\n+        var main = c.methods().get(1);\n+        var lvtt = main.code().get().findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE).get();\n+        var lvts = lvtt.localVariableTypes();\n+\n+        \/* From javap:\n+\n+        LocalVariableTypeTable:\n+        Start  Length  Slot  Name   Signature\n+            0      10     1     u   TU;\n+            8       2     2     l   Ljava\/util\/List<+Ljava\/lang\/Object;>;\n+         *\/\n+\n+        List<ExpectedLvtRecord> expected = List.of(\n+                ExpectedLvtRecord.of(1, \"u\", \"TU;\", 0, 10),\n+                ExpectedLvtRecord.of(2, \"l\", \"Ljava\/util\/List<+Ljava\/lang\/Object;>;\", 8, 2)\n+        );\n+\n+        \/\/ Exploits non-symmetric \"equals\" in ExpectedLvRecord\n+        for (int i = 0; i < lvts.size(); i++) {\n+            assertTrue(expected.get(i).equals(lvts.get(i)));\n+        }\n+    }\n+\n+    @Test\n+    void skipDebugSkipsLVT() {\n+        ClassModel c = Classfile.parse(fileBytes, Classfile.Option.processDebug(false));\n+\n+        c.forEachElement(e -> {\n+            if (e instanceof MethodModel m) {\n+                m.forEachElement(el -> {\n+                    if (el instanceof CodeModel cm) {\n+                        cm.forEachElement(elem -> {\n+                            assertFalse(elem instanceof LocalVariable);\n+                            assertFalse(elem instanceof LocalVariableType);\n+                        });\n+                    }\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/LvtTest.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile massive class adaptation.\n+ * @run junit MassAdaptCopyCodeTest\n+ *\/\n+import helpers.ByteArrayClassLoader;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodModel;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MassAdaptCopyCodeTest {\n+\n+    \/\/final static String testClasses = \"target\/classes\"; \/\/ \"\/w\/basejdk\/build\/linux-x86_64-server-release\/jdk\/modules\/java.base\"\n+\n+    final Map<String, ByteArrayClassLoader.ClassData> classNameToClass = new HashMap<>();\n+    String base;\n+\n+    @Test\n+    void testInstructionAdapt() throws Exception {\n+        File root = Paths.get(URI.create(MassAdaptCopyCodeTest.class.getResource(\"MassAdaptCopyCodeTest.class\").toString())).getParent().toFile();\n+        base = root.getCanonicalPath();\n+        copy(root);\n+        load();\n+    }\n+\n+    void copy(File f) throws Exception {\n+        if (f.isDirectory()) {\n+            for (File lf : f.listFiles()) {\n+                copy(lf);\n+            }\n+        }\n+        else {\n+            String n = f.getCanonicalPath().substring(base.length() + 1);\n+            if (n.endsWith(\".class\") && !n.endsWith(\"module-info.class\") && !n.endsWith(\"-split.class\")) {\n+                copy(n.substring(0, n.length() - 6).replace(File.separatorChar, '.'),\n+                     Files.readAllBytes(f.toPath()));\n+            }\n+        }\n+    }\n+\n+    void copy(String name, byte[] bytes) throws Exception {\n+        byte[] newBytes = adaptCopy(Classfile.parse(bytes));\n+        classNameToClass.put(name, new ByteArrayClassLoader.ClassData(name, newBytes));\n+        if (name.contains(\"\/\")) throw new RuntimeException(name);\n+    }\n+\n+    public byte[] adaptCopy(ClassModel cm) {\n+        return cm.transform((cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                cb.transformMethod(mm, (mb, me) -> {\n+                    if (me instanceof CodeModel xm) {\n+                        mb.transformCode(xm, CodeTransform.ACCEPT_ALL);\n+                    }\n+                    else\n+                        mb.with(me);\n+                });\n+            }\n+            else\n+                cb.with(ce);\n+        });\n+    }\n+\n+    public void load() throws Exception {\n+        new ByteArrayClassLoader(MassAdaptCopyCodeTest.class.getClassLoader(), classNameToClass)\n+                .loadAll();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyCodeTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile massive class adaptation.\n+ * @run junit MassAdaptCopyPrimitiveMatchCodeTest\n+ *\/\n+import helpers.InstructionModelToCodeBuilder;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * MassAdaptCopyPrimitiveMatchCodeTest.\n+ *\/\n+class MassAdaptCopyPrimitiveMatchCodeTest {\n+\n+    final static List<Path> testClasses(Path which) {\n+        try {\n+            return Files.walk(which)\n+                    .filter(p -> Files.isRegularFile(p))\n+                    .filter(p -> p.toString().endsWith(\".class\"))\n+                    .toList();\n+        } catch (IOException ex) {\n+            throw new AssertionError(\"Test failed in set-up - \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    final static List<Path> testClasses = testClasses(\n+            \/\/FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\")\n+            \/\/Path.of(\"target\", \"classes\")\n+            Paths.get(URI.create(MassAdaptCopyPrimitiveMatchCodeTest.class.getResource(\"MassAdaptCopyPrimitiveMatchCodeTest.class\").toString())).getParent()\n+    );\n+\n+    String base;\n+    boolean failure;\n+\n+    @Test\n+    @Disabled(\"for a reason...\")\n+    public void testCodeMatch() throws Exception {\n+        for (Path path : testClasses) {\n+            try {\n+                copy(path.toString(),\n+                        Files.readAllBytes(path));\n+                if (failure) {\n+                    fail(\"Copied bytecode does not match: \" + path);\n+                }\n+            } catch(Throwable ex) {\n+                System.err.printf(\"FAIL: MassAdaptCopyPrimitiveMatchCodeTest - %s%n\", ex.getMessage());\n+                ex.printStackTrace(System.err);\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    void copy(String name, byte[] bytes) throws Exception {\n+        \/\/System.err.printf(\"MassAdaptCopyPrimitiveMatchCodeTest - %s%n\", name);\n+        ClassModel cm =(Classfile.parse(bytes));\n+        Map<String, byte[]> m2b = new HashMap<>();\n+        Map<String, CodeAttribute> m2c = new HashMap<>();\n+        byte[] resultBytes =\n+                cm.transform((cb, e) -> {\n+                    if (e instanceof MethodModel mm) {\n+                        Optional<CodeModel> code = mm.code();\n+                        if (code.isPresent()) {\n+                            CodeAttribute cal = (CodeAttribute) code.get();\n+                            byte[] mbytes = cal.codeArray();\n+                            String key = methodToKey(mm);\n+                            m2b.put(key, mbytes);\n+                            m2c.put(key, cal);\n+                        }\n+                        cb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel xm)\n+                                mb.transformCode(xm, (xr, xe) -> InstructionModelToCodeBuilder.toBuilder(xe, xr));\n+                            else\n+                                mb.with(me);\n+                        });\n+                    }\n+                    else\n+                        cb.with(e);\n+                });\n+        \/\/TODO: work-around to compiler bug generating multiple constant pool entries within records\n+        if (cm.findAttribute(Attributes.RECORD).isPresent()) {\n+            System.err.printf(\"MassAdaptCopyPrimitiveMatchCodeTest: Ignored because it is a record%n         - %s%n\", name);\n+            return;\n+        }\n+        ClassModel rcm = Classfile.parse(resultBytes);\n+        for (MethodModel rmm : rcm.methods()) {\n+            Optional<CodeModel> code = rmm.code();\n+            if (code.isPresent()) {\n+                CodeModel codeModel = code.get();\n+                CodeAttribute rcal = (CodeAttribute) codeModel;\n+                String key = methodToKey(rmm);\n+                byte[] rbytes = rcal.codeArray();\n+                byte[] obytes = m2b.get(key);\n+                if (!Arrays.equals(rbytes, obytes)) {\n+                    System.err.printf(\"Copy has mismatched bytecode -- Method: %s.%s%n\", name, rmm.methodName().stringValue());\n+                    boolean secondFailure = false;\n+                    failure = true;\n+                    int rlen = rcal.codeLength();\n+                    CodeAttribute ocal = m2c.get(key);\n+                    int olen = ocal.codeLength();\n+                    if (rlen != olen) {\n+                        System.err.printf(\"  Lengths do not match: orig != copy: %d != %d%n\", olen, rlen);\n+                    }\n+                    int len = Math.max(rlen, olen);\n+                    \/\/ file instructions\n+                    CodeElement[] rima = new Instruction[len];\n+                    CodeElement[] oima = new Instruction[len];\n+                    int bci = 0;\n+                    for (CodeElement im : codeModel) {\n+                        if (im instanceof Instruction i) {\n+                            rima[bci] = im;\n+                            bci += i.sizeInBytes();\n+                        }\n+                    }\n+                    bci = 0;\n+                    for (CodeElement im : ((CodeModel) ocal)) {\n+                        if (im instanceof Instruction i) {\n+                            oima[bci] = im;\n+                            bci += i.sizeInBytes();\n+                        }\n+                    }\n+                    \/\/ find first bad BCI and instruction\n+                    int bciCurrentInstruction = -1;\n+                    int bciFirstBadInstruction = -1;\n+                    for (int i = 0; i < len; ++i) {\n+                        if (oima[i] != null) {\n+                            bciCurrentInstruction = i;\n+                        }\n+                        if (obytes[i] != rbytes[i]) {\n+                            if (bciFirstBadInstruction < 0) {\n+                                System.err.printf(\"  bytecode differs firstly at BCI [%d]; expected value is <%d> but was <%d>. Instruction BCI %d%n\",\n+                                        i, obytes[i], rbytes[i], bciCurrentInstruction);\n+                                bciFirstBadInstruction = bciCurrentInstruction;\n+                            } else {\n+                                secondFailure = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    System.err.printf(\"  BCI  Orig Copy Original ---> Copy%n\");\n+                    for (int i = 0; i < len; ++i) {\n+                        System.err.printf(\"  %4d \", i);\n+                        if (i < olen)\n+                            System.err.printf(\"%4d \", obytes[i] & 0xFF);\n+                        else\n+                            System.err.printf(\"     \");\n+                        if (i < rlen)\n+                            System.err.printf(\"%4d \", rbytes[i] & 0xFF);\n+                        else\n+                            System.err.printf(\"     \");\n+                        CodeElement oim = oima[i];\n+                        if (oim != null)\n+                            System.err.printf(\"%s  \", oim);\n+                        CodeElement rim = rima[i];\n+                        if (rim != null)\n+                            System.err.printf(\"---> %s  \", rim);\n+                        System.err.printf(\"%n\");\n+                        if (bciFirstBadInstruction == i\n+                                && oim instanceof InvokeInstruction oii\n+                                && rim instanceof InvokeInstruction rii) {\n+                            if (oii.isInterface() == rii.isInterface()\n+                                    && oii.name().stringValue().equals(rii.name().stringValue())\n+                                    && oii.owner().asInternalName().equals(rii.owner().asInternalName())\n+                                    && oii.type().stringValue().equals(rii.type().stringValue())\n+                                    && oii.count() == rii.count()\n+                                    && oii.sizeInBytes() == rii.sizeInBytes()\n+                                    && oii.opcode() == rii.opcode()) {\n+                                \/\/ they match, so was duplicate CP entries, e.g Object.clone()\n+                                \/\/ get a pass if this was the only failure\n+                                System.err.printf(\"NVM - duplicate CP entry -- ignored%n\");\n+                                failure = secondFailure;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    String methodToKey(MethodModel mm) {\n+        return mm.methodName().stringValue() + \"@\" + mm.methodType().stringValue() + (mm.flags().has(AccessFlag.STATIC) ? \"$\" : \"!\");\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/MassAdaptCopyPrimitiveMatchCodeTest.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile building module.\n+ * @run junit ModuleBuilderTest\n+ *\/\n+import jdk.internal.classfile.*;\n+\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleExportInfo;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModuleOpenInfo;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.ModuleProvideInfo;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ModuleBuilderTest {\n+    private final ModuleDesc modName = ModuleDesc.of(\"some.module.structure\");\n+    private final String modVsn = \"ab75\";\n+    private final ModuleDesc require1 = ModuleDesc.of(\"1require.some.mod\"); String vsn1 = \"1the.best.version\";\n+    private final ModuleDesc require2 = ModuleDesc.of(\"2require.some.mod\"); String vsn2 = \"2the.best.version\";\n+    private final ModuleDesc[] et1 = new ModuleDesc[] {ModuleDesc.of(\"1t1\"), ModuleDesc.of(\"1t2\")};\n+    private final ModuleDesc[] et2 = new ModuleDesc[] {ModuleDesc.of(\"2t1\")};\n+    private final ModuleDesc[] et3 = new ModuleDesc[] {ModuleDesc.of(\"3t1\"), ModuleDesc.of(\"3t2\"), ModuleDesc.of(\"3t3\")};\n+    private final ModuleDesc[] ot3 = new ModuleDesc[] {ModuleDesc.of(\"t1\"), ModuleDesc.of(\"t2\")};\n+\n+    private final ClassModel moduleModel;\n+    private final ModuleAttribute attr;\n+\n+    public ModuleBuilderTest() {\n+        byte[] modInfo = Classfile.buildModule(\n+                ModuleAttribute.of(modName, mb -> mb\n+                        .moduleVersion(modVsn)\n+\n+                        .requires(require1, 77, vsn1)\n+                        .requires(require2, 99, vsn2)\n+\n+                        .exports(PackageDesc.of(\"0\"), 0, et1)\n+                        .exports(PackageDesc.of(\"1\"), 1, et2)\n+                        .exports(PackageDesc.of(\"2\"), 2, et3)\n+                        .exports(PackageDesc.of(\"3\"), 3)\n+                        .exports(PackageDesc.of(\"4\"), 4)\n+\n+                        .opens(PackageDesc.of(\"o0\"), 0)\n+                        .opens(PackageDesc.of(\"o1\"), 1)\n+                        .opens(PackageDesc.of(\"o2\"), 2, ot3)\n+\n+                        .uses(ClassDesc.of(\"some.Service\"))\n+                        .uses(ClassDesc.of(\"another.Service\"))\n+\n+                        .provides(ClassDesc.of(\"some.nice.Feature\"), ClassDesc.of(\"impl\"), ClassDesc.of(\"another.impl\"))),\n+                List.of(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\"), PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")),\n+                clb -> clb.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Class\")))\n+                          .with(ModuleMainClassAttribute.of(ClassDesc.of(\"overwritten.main.Class\"))));\n+        moduleModel = Classfile.parse(modInfo);\n+        attr = ((ModuleAttribute) moduleModel.attributes().stream()\n+                .filter(a -> a.attributeMapper() == Attributes.MODULE)\n+                .findFirst()\n+                .orElseThrow());\n+    }\n+\n+    @Test\n+    void testCreateModuleInfo() {\n+        \/\/ Build the module-info.class bytes\n+        byte[] modBytes = Classfile.buildModule(ModuleAttribute.of(modName, mb -> mb.moduleVersion(modVsn)));\n+\n+        \/\/ Verify\n+        var cm = Classfile.parse(modBytes);\n+\n+        var attr =cm.findAttribute(Attributes.MODULE).get();\n+        assertEquals(attr.moduleName().name().stringValue(), modName.moduleName());\n+        assertEquals(attr.moduleFlagsMask(), 0);\n+        assertEquals(attr.moduleVersion().get().stringValue(), modVsn);\n+    }\n+\n+    @Test\n+    void testAllAttributes() {\n+        assertEquals(moduleModel.attributes().size(), 3);\n+    }\n+\n+    @Test\n+    void testVerifyRequires() {\n+        assertEquals(attr.requires().size(), 2);\n+        ModuleRequireInfo r = attr.requires().get(0);\n+        assertEquals(r.requires().name().stringValue(), require1.moduleName());\n+        assertEquals(r.requiresVersion().get().stringValue(), vsn1);\n+        assertEquals(r.requiresFlagsMask(), 77);\n+\n+        r = attr.requires().get(1);\n+        assertEquals(r.requires().name().stringValue(), require2.moduleName());\n+        assertEquals(r.requiresVersion().get().stringValue(), vsn2);\n+        assertEquals(r.requiresFlagsMask(), 99);\n+    }\n+\n+    @Test\n+    void testVerifyExports() {\n+        List<ModuleExportInfo> exports = attr.exports();\n+        assertEquals(exports.size(),5);\n+        for (int i = 0; i < 5; i++) {\n+            assertEquals(exports.get(i).exportsFlagsMask(), i);\n+            assertEquals(exports.get(i).exportedPackage().name().stringValue(), String.valueOf(i));\n+        }\n+        assertEquals(exports.get(0).exportsTo().size(), 2);\n+        for (int i = 0; i < 2; i++)\n+            assertEquals(exports.get(0).exportsTo().get(i).name().stringValue(), et1[i].moduleName());\n+\n+        assertEquals(exports.get(1).exportsTo().size(), 1);\n+        assertEquals(exports.get(1).exportsTo().get(0).name().stringValue(), et2[0].moduleName());\n+\n+        assertEquals(exports.get(2).exportsTo().size(), 3);\n+        for (int i = 0; i < 3; i++)\n+            assertEquals(exports.get(2).exportsTo().get(i).name().stringValue(), et3[i].moduleName());\n+\n+        assertEquals(exports.get(3).exportsTo().size(), 0);\n+        assertEquals(exports.get(4).exportsTo().size(), 0);\n+    }\n+\n+    @Test\n+    void testVerifyOpens() {\n+        List<ModuleOpenInfo> opens = attr.opens();\n+        assertEquals(opens.size(), 3);\n+        assertEquals(opens.get(0).opensTo().size(), 0);\n+        assertEquals(opens.get(1).opensTo().size(), 0);\n+        assertEquals(opens.get(2).opensTo().size(), 2);\n+        assertEquals(opens.get(2).opensFlagsMask(), 2);\n+        assertEquals(opens.get(2).opensTo().get(1).name().stringValue(), ot3[1].moduleName());\n+    }\n+\n+    @Test\n+    void testVerifyUses() {\n+        var uses = attr.uses();\n+        assertEquals(uses.size(), 2);\n+        assertEquals(uses.get(1).asInternalName(), \"another\/Service\");\n+    }\n+\n+    @Test\n+    void testVerifyProvides() {\n+        var provides = attr.provides();\n+        assertEquals(provides.size(), 1);\n+        ModuleProvideInfo p = provides.get(0);\n+        assertEquals(p.provides().asInternalName(), \"some\/nice\/Feature\");\n+        assertEquals(p.providesWith().size(), 2);\n+        assertEquals(p.providesWith().get(1).asInternalName(), \"another\/impl\");\n+    }\n+\n+    @Test\n+    void verifyPackages() {\n+        ModulePackagesAttribute a = moduleModel.findAttribute(Attributes.MODULE_PACKAGES).orElseThrow();\n+        assertEquals(a.packages().stream().map(pe -> pe.asSymbol().packageName()).toList(), List.of(\"0\", \"1\", \"2\", \"3\", \"4\", \"o0\", \"o1\", \"o2\", \"foo.bar.baz\", \"quux\"));\n+    }\n+\n+    @Test\n+    void verifyMainclass() {\n+        ModuleMainClassAttribute a = moduleModel.findAttribute(Attributes.MODULE_MAIN_CLASS).orElseThrow();\n+        assertEquals(a.mainClass().asInternalName(), \"overwritten\/main\/Class\");\n+    }\n+\n+    @Test\n+    void verifyIsModuleInfo() throws Exception {\n+        assertTrue(moduleModel.isModuleInfo());\n+\n+        ClassModel m = Classfile.parse(Paths.get(URI.create(ModuleBuilderTest.class.getResource(\"ModuleBuilderTest.class\").toString())));\n+        assertFalse(m.isModuleInfo());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ModuleBuilderTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing ModuleDesc.\n+ * @run junit ModuleDescTest\n+ *\/\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ModuleDescTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"abc\\\\\", \"ab\\\\c\", \"\\u0000\", \"\\u0001\", \"\\u001e\", \"\\u001f\"})\n+    public void testInvalidModuleNames(String mdl) {\n+        assertThrows(IllegalArgumentException.class, () -> ModuleDesc.of(mdl));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"a\\\\\\\\b\", \"a.b\/c\", \"a\\\\@b\\\\: c\"})\n+    public void testValidModuleNames(String mdl) {\n+        assertEquals(ModuleDesc.of(mdl), ModuleDesc.of(mdl));\n+        assertEquals(ModuleDesc.of(mdl).moduleName(), mdl);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ModuleDescTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile class writing and reading.\n+ * @run junit OneToOneTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+\n+import jdk.internal.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.OperatorInstruction;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+\n+import static helpers.TestConstants.CD_PrintStream;\n+import static helpers.TestConstants.CD_System;\n+import static helpers.TestConstants.MTD_INT_VOID;\n+import static helpers.TestConstants.MTD_VOID;\n+import static jdk.internal.classfile.Opcode.*;\n+\n+class OneToOneTest {\n+\n+    @Test\n+    void testClassWriteRead() {\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withVersion(52, 0);\n+            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                                  .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                                          .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                                          .returnInstruction(TypeKind.VoidType)\n+                                  )\n+              )\n+              .withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                          AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                          mb -> mb.withCode(c0 -> {\n+                                                Label loopTop = c0.newLabel();\n+                                                Label loopEnd = c0.newLabel();\n+                                                int fac = 1;\n+                                                int i = 2;\n+                                                c0.constantInstruction(ICONST_1, 1)         \/\/ 0\n+                                                  .storeInstruction(TypeKind.IntType, fac)        \/\/ 1\n+                                                  .constantInstruction(ICONST_1, 1)         \/\/ 2\n+                                                  .storeInstruction(TypeKind.IntType, i)          \/\/ 3\n+                                                  .labelBinding(loopTop)\n+                                                  .loadInstruction(TypeKind.IntType, i)           \/\/ 4\n+                                                  .constantInstruction(BIPUSH, 10)         \/\/ 5\n+                                                  .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n+                                                  .loadInstruction(TypeKind.IntType, fac)         \/\/ 7\n+                                                  .loadInstruction(TypeKind.IntType, i)           \/\/ 8\n+                                                  .operatorInstruction(IMUL)             \/\/ 9\n+                                                  .storeInstruction(TypeKind.IntType, fac)        \/\/ 10\n+                                                  .incrementInstruction(i, 1)    \/\/ 11\n+                                                  .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                                  .labelBinding(loopEnd)\n+                                                  .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n+                                                  .loadInstruction(TypeKind.IntType, fac)\n+                                                  .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n+                                                  .returnInstruction(TypeKind.VoidType);\n+                                            }\n+                          )\n+              );\n+                                       }\n+        );\n+\n+        ClassModel cm = Classfile.parse(bytes);\n+        List<MethodModel> ms = cm.methods();\n+        assertEquals(ms.size(), 2);\n+        boolean found = false;\n+        for (MethodModel mm : ms) {\n+            if (mm.methodName().stringValue().equals(\"main\") && mm.code().isPresent()) {\n+                found = true;\n+                var code = mm.code().get();\n+                var instructions = code.elementList().stream()\n+                                       .filter(e -> e instanceof Instruction)\n+                                       .map(e -> (Instruction)e)\n+                                       .toList();\n+                assertEquals(instructions.size(), 17);\n+\n+                assertEquals(instructions.get(0).opcode(), ICONST_1);\n+\n+                var i1 = (StoreInstruction) instructions.get(1);\n+                assertEquals(i1.opcode(), ISTORE_1);\n+                int lv1 = i1.slot();\n+                assertEquals(lv1, 1);\n+\n+                ConstantInstruction i5 = (ConstantInstruction) instructions.get(5);\n+                assertEquals(i5.opcode(), BIPUSH);\n+                assertEquals(i5.constantValue(), 10);\n+\n+                BranchInstruction i6 = (BranchInstruction) instructions.get(6);\n+                assertEquals(i6.opcode(), IF_ICMPGE);\n+                \/\/ assertEquals(code.instructionOffset(i6.target()), 14);  \/\/FIXME: CodeModel gives BCI, should give instruction offset\n+\n+                LoadInstruction i7 = (LoadInstruction) instructions.get(7);\n+                assertEquals(i7.opcode(), ILOAD_1);\n+\n+                OperatorInstruction i9 = (OperatorInstruction) instructions.get(9);\n+                assertEquals(i9.opcode(), IMUL);\n+\n+                FieldInstruction i13 = (FieldInstruction) instructions.get(13);\n+                assertEquals(i13.opcode(), GETSTATIC);\n+                assertEquals(i13.owner().asInternalName(), \"java\/lang\/System\");\n+                assertEquals(i13.name().stringValue(), \"out\");\n+                assertEquals(i13.type().stringValue(), \"Ljava\/io\/PrintStream;\");\n+\n+                InvokeInstruction i15 = (InvokeInstruction) instructions.get(15);\n+                assertEquals(i15.opcode(), INVOKEVIRTUAL);\n+                assertEquals(i15.owner().asInternalName(), \"java\/io\/PrintStream\");\n+                assertEquals(i15.name().stringValue(), \"println\");\n+                assertEquals(i15.type().stringValue(), \"(I)V\");\n+            }\n+        }\n+        assertTrue(found);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile constant instruction opcodes.\n+ * @run junit OpcodesValidationTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Opcode;\n+import org.junit.jupiter.api.*;\n+import static org.junit.jupiter.api.DynamicTest.dynamicTest;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static jdk.internal.classfile.Opcode.*;\n+import java.util.stream.Stream;\n+\n+public class OpcodesValidationTest {\n+\n+    record Case(Opcode opcode, Object constant) {}\n+\n+    static Stream<Case> positiveCases() {\n+        return Stream.of(\n+            new Case(ACONST_NULL, null),\n+            new Case(SIPUSH, (int)Short.MIN_VALUE),\n+            new Case(SIPUSH, (int)Short.MAX_VALUE),\n+            new Case(BIPUSH, (int)Byte.MIN_VALUE),\n+            new Case(BIPUSH, (int)Byte.MAX_VALUE),\n+            new Case(ICONST_M1, -1),\n+            new Case(ICONST_0, 0),\n+            new Case(ICONST_1, 1),\n+            new Case(ICONST_2, 2),\n+            new Case(ICONST_3, 3),\n+            new Case(ICONST_4, 4),\n+            new Case(ICONST_5, 5),\n+            new Case(LCONST_0, 0l),\n+            new Case(LCONST_0, 0),\n+            new Case(LCONST_1, 1l),\n+            new Case(LCONST_1, 1),\n+            new Case(FCONST_0, 0.0f),\n+            new Case(FCONST_1, 1.0f),\n+            new Case(FCONST_2, 2.0f),\n+            new Case(DCONST_0, 0.0d),\n+            new Case(DCONST_1, 1.0d)\n+        );\n+    }\n+\n+    static Stream<Case> negativeCases() {\n+        return Stream.of(\n+            new Case(ACONST_NULL, 0),\n+            new Case(SIPUSH, (int)Short.MIN_VALUE - 1),\n+            new Case(SIPUSH, (int)Short.MAX_VALUE + 1),\n+            new Case(BIPUSH, (int)Byte.MIN_VALUE - 1),\n+            new Case(BIPUSH, (int)Byte.MAX_VALUE + 1),\n+            new Case(ICONST_M1, -1l),\n+            new Case(ICONST_0, 0l),\n+            new Case(ICONST_1, 1l),\n+            new Case(ICONST_2, 2l),\n+            new Case(ICONST_3, 3l),\n+            new Case(ICONST_4, 4l),\n+            new Case(ICONST_5, 5l),\n+            new Case(LCONST_0, null),\n+            new Case(LCONST_0, 1l),\n+            new Case(LCONST_1, 1.0d),\n+            new Case(LCONST_1, 0),\n+            new Case(FCONST_0, 0.0d),\n+            new Case(FCONST_1, 1.01f),\n+            new Case(FCONST_2, 2),\n+            new Case(DCONST_0, 0.0f),\n+            new Case(DCONST_1, 1.0f),\n+            new Case(DCONST_1, 1)\n+        );\n+    }\n+\n+    @TestFactory\n+    Stream<DynamicTest> testPositiveCases() {\n+        return positiveCases().map(c -> dynamicTest(c.toString(), () -> testPositiveCase(c.opcode, c.constant)));\n+    }\n+\n+    private void testPositiveCase(Opcode opcode, Object constant) {\n+        Classfile.build(ClassDesc.of(\"MyClass\"),\n+                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n+                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n+                                      mb -> mb.withCode(\n+                                              codeb -> codeb.constantInstruction(opcode, (ConstantDesc) constant))));\n+    }\n+\n+\n+    @TestFactory\n+    Stream<DynamicTest> testNegativeCases() {\n+        return negativeCases().map(c -> dynamicTest(\n+            c.toString(),\n+            () -> assertThrows(IllegalArgumentException.class, () -> testNegativeCase(c.opcode, c.constant))\n+        ));\n+    }\n+\n+    private void testNegativeCase(Opcode opcode, Object constant) {\n+        Classfile.build(ClassDesc.of(\"MyClass\"),\n+                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n+                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n+                        mb -> mb .withCode(\n+                                codeb -> codeb.constantInstruction(opcode, (ConstantDesc)constant))));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing PackageDesc.\n+ * @run junit PackageDescTest\n+ *\/\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class PackageDescTest {\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"a\/b.d\", \"a[]\", \"a;\"})\n+    void testInvalidPackageNames(String pkg) {\n+        assertThrows(IllegalArgumentException.class, () -> PackageDesc.of(pkg));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"a\/b.d\", \"a[]\", \"a;\"})\n+    void testInvalidInternalPackageNames(String pkg) {\n+        assertThrows(IllegalArgumentException.class, () -> PackageDesc.ofInternalName(pkg));\n+    }\n+\n+    @Test\n+    void testValidPackageNames() {\n+        assertEquals(PackageDesc.of(\"a\"), PackageDesc.ofInternalName(\"a\"));\n+        assertEquals(PackageDesc.of(\"a.b\"), PackageDesc.ofInternalName(\"a\/b\"));\n+        assertEquals(PackageDesc.of(\"a.b.c\"), PackageDesc.ofInternalName(\"a\/b\/c\"));\n+        assertEquals(PackageDesc.of(\"a\").packageName(), PackageDesc.ofInternalName(\"a\").packageName());\n+        assertEquals(PackageDesc.of(\"a.b\").packageName(), PackageDesc.ofInternalName(\"a\/b\").packageName());\n+        assertEquals(PackageDesc.of(\"a.b.c\").packageName(), PackageDesc.ofInternalName(\"a\/b\/c\").packageName());\n+        assertEquals(PackageDesc.of(\"a\").packageInternalName(), PackageDesc.ofInternalName(\"a\").packageInternalName());\n+        assertEquals(PackageDesc.of(\"a.b\").packageInternalName(), PackageDesc.ofInternalName(\"a\/b\").packageInternalName());\n+        assertEquals(PackageDesc.of(\"a.b.c\").packageInternalName(), PackageDesc.ofInternalName(\"a\/b\/c\").packageInternalName());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/PackageDescTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile short to long jumps extension.\n+ * @run junit ShortJumpsFixTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.LinkedList;\n+import java.util.List;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.Opcode;\n+import static jdk.internal.classfile.Opcode.*;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.NopInstruction;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ShortJumpsFixTest {\n+\n+    record Sample(Opcode jumpCode, Opcode... expected) {\n+        @Override\n+        public String toString() {\n+            return jumpCode.name();\n+        }\n+    }\n+\n+    static Sample[] provideFwd()  {\n+        return new Sample[]{\n+            \/\/first is transformed opcode, followed by constant instructions and expected output\n+            new Sample(GOTO, GOTO_W, NOP, ATHROW, RETURN),\n+            new Sample(IFEQ, ICONST_0, IFNE, GOTO_W, NOP, RETURN),\n+            new Sample(IFNE, ICONST_0, IFEQ, GOTO_W, NOP, RETURN),\n+            new Sample(IFLT, ICONST_0, IFGE, GOTO_W, NOP, RETURN),\n+            new Sample(IFGE, ICONST_0, IFLT, GOTO_W, NOP, RETURN),\n+            new Sample(IFGT, ICONST_0, IFLE, GOTO_W, NOP, RETURN),\n+            new Sample(IFLE, ICONST_0, IFGT, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ICMPEQ, ICONST_0, ICONST_1, IF_ICMPNE, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ICMPNE, ICONST_0, ICONST_1, IF_ICMPEQ, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ICMPLT, ICONST_0, ICONST_1, IF_ICMPGE, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ICMPGE, ICONST_0, ICONST_1, IF_ICMPLT, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ICMPGT, ICONST_0, ICONST_1, IF_ICMPLE, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ICMPLE, ICONST_0, ICONST_1, IF_ICMPGT, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ACMPEQ, ICONST_0, ICONST_1, IF_ACMPNE, GOTO_W, NOP, RETURN),\n+            new Sample(IF_ACMPNE, ICONST_0, ICONST_1, IF_ACMPEQ, GOTO_W, NOP, RETURN),\n+            new Sample(IFNULL, ACONST_NULL, IFNONNULL, GOTO_W, NOP, RETURN),\n+            new Sample(IFNONNULL, ACONST_NULL, IFNULL, GOTO_W, NOP, RETURN),\n+        };\n+    }\n+\n+    static Sample[] provideBack()  {\n+        return new Sample[]{\n+            new Sample(GOTO, GOTO_W, NOP, RETURN, GOTO_W, ATHROW),\n+            new Sample(IFEQ, GOTO_W, NOP, RETURN, ICONST_0, IFNE, GOTO_W, RETURN),\n+            new Sample(IFNE, GOTO_W, NOP, RETURN, ICONST_0, IFEQ, GOTO_W, RETURN),\n+            new Sample(IFLT, GOTO_W, NOP, RETURN, ICONST_0, IFGE, GOTO_W, RETURN),\n+            new Sample(IFGE, GOTO_W, NOP, RETURN, ICONST_0, IFLT, GOTO_W, RETURN),\n+            new Sample(IFGT, GOTO_W, NOP, RETURN, ICONST_0, IFLE, GOTO_W, RETURN),\n+            new Sample(IFLE, GOTO_W, NOP, RETURN, ICONST_0, IFGT, GOTO_W, RETURN),\n+            new Sample(IF_ICMPEQ, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ICMPNE, GOTO_W, RETURN),\n+            new Sample(IF_ICMPNE, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ICMPEQ, GOTO_W, RETURN),\n+            new Sample(IF_ICMPLT, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ICMPGE, GOTO_W, RETURN),\n+            new Sample(IF_ICMPGE, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ICMPLT, GOTO_W, RETURN),\n+            new Sample(IF_ICMPGT, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ICMPLE, GOTO_W, RETURN),\n+            new Sample(IF_ICMPLE, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ICMPGT, GOTO_W, RETURN),\n+            new Sample(IF_ACMPEQ, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ACMPNE, GOTO_W, RETURN),\n+            new Sample(IF_ACMPNE, GOTO_W, NOP, RETURN, ICONST_0, ICONST_1, IF_ACMPEQ, GOTO_W, RETURN),\n+            new Sample(IFNULL, GOTO_W, NOP, RETURN, ACONST_NULL, IFNONNULL, GOTO_W, RETURN),\n+            new Sample(IFNONNULL, GOTO_W, NOP, RETURN, ACONST_NULL, IFNULL, GOTO_W, RETURN),\n+        };\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideFwd\")\n+    void testFixFwdJumpsDirectGen(Sample sample) throws Exception {\n+        assertFixed(sample, generateFwd(sample, true, Classfile.Option.fixShortJumps(true)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideBack\")\n+    void testFixBackJumpsDirectGen(Sample sample) throws Exception {\n+        assertFixed(sample, generateBack(sample, true, Classfile.Option.fixShortJumps(true)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideFwd\")\n+    void testFailFwdJumpsDirectGen(Sample sample) throws Exception {\n+        assertThrows(IllegalStateException.class, () -> generateFwd(sample, true, Classfile.Option.fixShortJumps(false)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideBack\")\n+    void testFailBackJumpsDirectGen(Sample sample) throws Exception {\n+        assertThrows(IllegalStateException.class, () -> generateBack(sample, true, Classfile.Option.fixShortJumps(false)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideFwd\")\n+    void testFixFwdJumpsTransform(Sample sample) throws Exception {\n+        assertFixed(sample, Classfile.parse(\n+                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(true))\n+                .transform(overflow()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideBack\")\n+    void testFixBackJumpsTransform(Sample sample) throws Exception {\n+        assertFixed(sample, Classfile.parse(\n+                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(true))\n+                .transform(overflow()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideFwd\")\n+    void testFailFwdJumpsTransform(Sample sample) throws Exception {\n+        assertThrows(IllegalStateException.class, () ->\n+        Classfile.parse(\n+                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(false))\n+                .transform(overflow()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideBack\")\n+    void testFailBackJumpsTransform(Sample sample) throws Exception {\n+        assertThrows(IllegalStateException.class, () ->\n+        Classfile.parse(\n+                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(false))\n+                .transform(overflow()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideFwd\")\n+    void testFixFwdJumpsChainedTransform(Sample sample) throws Exception {\n+        assertFixed(sample, Classfile.parse(\n+                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(true))\n+                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideBack\")\n+    void testFixBackJumpsChainedTransform(Sample sample) throws Exception {\n+        assertFixed(sample, Classfile.parse(\n+                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(true))\n+                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideFwd\")\n+    void testFailFwdJumpsChainedTransform(Sample sample) throws Exception {\n+        assertThrows(IllegalStateException.class, () ->\n+        Classfile.parse(\n+                generateFwd(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(false))\n+                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"provideBack\")\n+    void testFailBackJumpsChainedTransform(Sample sample) throws Exception {\n+        assertThrows(IllegalStateException.class, () ->\n+        Classfile.parse(\n+                generateBack(sample, false, Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                Classfile.Option.fixShortJumps(false))\n+                .transform(ClassTransform.ACCEPT_ALL.andThen(overflow()))); \/\/involve BufferedCodeBuilder here\n+    }\n+\n+    private static byte[] generateFwd(Sample sample, boolean overflow, Classfile.Option... options) {\n+        return Classfile.build(ClassDesc.of(\"WhateverClass\"), List.of(options),\n+                        cb -> cb.withMethod(\"whateverMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0,\n+                                mb -> mb.withCode(cob -> {\n+                                    for (int i = 0; i < sample.expected.length - 4; i++) \/\/cherry-pick XCONST_ instructions from expected output\n+                                        cob.with(ConstantInstruction.ofIntrinsic(sample.expected[i]));\n+                                    var target = cob.newLabel();\n+                                    cob.branchInstruction(sample.jumpCode, target);\n+                                    for (int i = overflow ? 40000 : 1; i > 0; i--)\n+                                        cob.nopInstruction();\n+                                    cob.labelBinding(target);\n+                                    cob.return_();\n+                                })));\n+    }\n+\n+    private static byte[] generateBack(Sample sample, boolean overflow, Classfile.Option... options) {\n+        return Classfile.build(ClassDesc.of(\"WhateverClass\"), List.of(options),\n+                        cb -> cb.withMethod(\"whateverMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0,\n+                                mb -> mb.withCode(cob -> {\n+                                    var target = cob.newLabel();\n+                                    var fwd = cob.newLabel();\n+                                    cob.goto_w(fwd);\n+                                    cob.labelBinding(target);\n+                                    for (int i = overflow ? 40000 : 1; i > 0; i--)\n+                                        cob.nopInstruction();\n+                                    cob.return_();\n+                                    cob.labelBinding(fwd);\n+                                    for (int i = 3; i < sample.expected.length - 3; i++) \/\/cherry-pick XCONST_ instructions from expected output\n+                                        cob.with(ConstantInstruction.ofIntrinsic(sample.expected[i]));\n+                                    cob.branchInstruction(sample.jumpCode, target);\n+                                    cob.return_();\n+                                })));\n+    }\n+\n+    private static ClassTransform overflow() {\n+        return ClassTransform.transformingMethods(\n+                        MethodTransform.transformingCode(\n+                                (cob, coe) -> {\n+                                    if (coe instanceof NopInstruction)\n+                                        for (int i = 0; i < 40000; i++) \/\/cause label overflow during transform\n+                                            cob.nopInstruction();\n+                                    cob.with(coe);\n+                                }));\n+    }\n+\n+    private static void assertFixed(Sample sample, byte[] classFile) {\n+        var found = new LinkedList<Opcode>();\n+        for (var e : Classfile.parse(classFile).methods().get(0).code().get())\n+            if (e instanceof Instruction i && found.peekLast() != i.opcode()) \/\/dedup subsequent (NOPs)\n+                found.add(i.opcode());\n+        assertEquals(found, List.of(sample.expected));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ShortJumpsFixTest.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Signatures.\n+ * @run junit SignaturesTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.Signature.*;\n+import jdk.internal.classfile.Attributes;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static helpers.ClassRecord.assertEqualsDeep;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+class SignaturesTest {\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+\n+    @Test\n+    void testBuildingSignatures() {\n+        assertEqualsDeep(\n+                ClassSignature.of(\n+                        ClassTypeSig.of(\n+                                ClassTypeSig.of(ClassDesc.of(\"java.util.LinkedHashMap\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")),\n+                                ClassDesc.of(\"LinkedHashIterator\")),\n+                        ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\"),\n+                                ClassTypeSig.of(ClassDesc.of(\"java.util.Map$Entry\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")))),\n+                ClassSignature.parseFrom(\"Ljava\/util\/LinkedHashMap<TK;TV;>.LinkedHashIterator;Ljava\/util\/Iterator<Ljava\/util\/Map$Entry<TK;TV;>;>;\"));\n+\n+        assertEqualsDeep(\n+                ClassSignature.of(\n+                        List.of(\n+                                TypeParam.of(\"K\", ClassTypeSig.of(CD_Object)),\n+                                TypeParam.of(\"V\", ClassTypeSig.of(CD_Object))),\n+                        ClassTypeSig.of(ClassDesc.of(\"java.util.AbstractMap\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")),\n+                        ClassTypeSig.of(ClassDesc.of(\"java.util.concurrent.ConcurrentMap\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")),\n+                        ClassTypeSig.of(ClassDesc.of(\"java.io.Serializable\"))),\n+                ClassSignature.parseFrom(\"<K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/util\/AbstractMap<TK;TV;>;Ljava\/util\/concurrent\/ConcurrentMap<TK;TV;>;Ljava\/io\/Serializable;\"));\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        ClassTypeSig.of(\n+                                CD_Map,\n+                                ClassTypeSig.of(\n+                                        CD_Class,\n+                                            TypeArg.extendsOf(\n+                                                    ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\")))),\n+                                ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\"))),\n+                        Signature.of(CD_byte.arrayType()),\n+                        ClassTypeSig.of(ClassDesc.of(\"jdk.internal.reflect.ConstantPool\")),\n+                        ClassTypeSig.of(CD_Class, TypeArg.unbounded()),\n+                        ArrayTypeSig.of(\n+                                ClassTypeSig.of(CD_Class,\n+                                        TypeArg.extendsOf(\n+                                                ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\")))))),\n+                MethodSignature.parseFrom(\"([BLjdk\/internal\/reflect\/ConstantPool;Ljava\/lang\/Class<*>;[Ljava\/lang\/Class<+Ljava\/lang\/annotation\/Annotation;>;)Ljava\/util\/Map<Ljava\/lang\/Class<+Ljava\/lang\/annotation\/Annotation;>;Ljava\/lang\/annotation\/Annotation;>;\"));\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(\n+                                TypeParam.of(\"T\", Optional.empty(), ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\")))),\n+                        List.of(\n+                                ClassTypeSig.of(ClassDesc.of(\"java.lang.IOException\")),\n+                                ClassTypeSig.of(ClassDesc.of(\"java.lang.IllegalAccessError\"))),\n+                        ArrayTypeSig.of(TypeVarSig.of(\"T\")),\n+                        ClassTypeSig.of(CD_Class, TypeVarSig.of(\"T\"))),\n+                MethodSignature.parseFrom(\"<T::Ljava\/lang\/annotation\/Annotation;>(Ljava\/lang\/Class<TT;>;)[TT;^Ljava\/lang\/IOException;^Ljava\/lang\/IllegalAccessError;\"));\n+\n+        assertEqualsDeep(\n+                ClassTypeSig.of(\n+                        CD_Set,\n+                        TypeArg.extendsOf(\n+                                ClassTypeSig.of(ClassDesc.of(\"java.nio.file.WatchEvent$Kind\"), TypeArg.unbounded()))),\n+                Signature.parseFrom(\"Ljava\/util\/Set<+Ljava\/nio\/file\/WatchEvent$Kind<*>;>;\"));\n+\n+        assertEqualsDeep(\n+                ArrayTypeSig.of(2, TypeVarSig.of(\"E\")),\n+                Signature.parseFrom(\"[[TE;\"));\n+    }\n+\n+    @Test\n+    void testParseAndPrintSignatures() throws Exception {\n+        var csc = new AtomicInteger();\n+        var msc = new AtomicInteger();\n+        var fsc = new AtomicInteger();\n+        var rsc = new AtomicInteger();\n+        Stream.of(\n+                Files.walk(JRT.getPath(\"modules\/java.base\")),\n+                Files.walk(JRT.getPath(\"modules\"), 2).filter(p -> p.endsWith(\"module-info.class\")),\n+                Files.walk(Path.of(SignaturesTest.class.getProtectionDomain().getCodeSource().getLocation().toURI())))\n+                .flatMap(p -> p)\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\")).forEach(path -> {\n+            try {\n+                var cm = Classfile.parse(path);\n+                cm.findAttribute(Attributes.SIGNATURE).ifPresent(csig -> {\n+                    assertEquals(\n+                            ClassSignature.parseFrom(csig.signature().stringValue()).signatureString(),\n+                            csig.signature().stringValue(),\n+                            cm.thisClass().asInternalName());\n+                    csc.incrementAndGet();\n+                });\n+                for (var m : cm.methods()) {\n+                    m.findAttribute(Attributes.SIGNATURE).ifPresent(msig -> {\n+                        assertEquals(\n+                                MethodSignature.parseFrom(msig.signature().stringValue()).signatureString(),\n+                                msig.signature().stringValue(),\n+                                cm.thisClass().asInternalName() + \"::\" + m.methodName().stringValue() + m.methodType().stringValue());\n+                        msc.incrementAndGet();\n+                    });\n+                }\n+                for (var f : cm.fields()) {\n+                    f.findAttribute(Attributes.SIGNATURE).ifPresent(fsig -> {\n+                        assertEquals(\n+                                Signature.parseFrom(fsig.signature().stringValue()).signatureString(),\n+                                fsig.signature().stringValue(),\n+                                cm.thisClass().asInternalName() + \".\" + f.fieldName().stringValue());\n+                        fsc.incrementAndGet();\n+                    });\n+                }\n+                cm.findAttribute(Attributes.RECORD).ifPresent(reca\n+                        -> reca.components().forEach(rc -> rc.findAttribute(Attributes.SIGNATURE).ifPresent(rsig -> {\n+                    assertEquals(\n+                            Signature.parseFrom(rsig.signature().stringValue()).signatureString(),\n+                            rsig.signature().stringValue(),\n+                            cm.thisClass().asInternalName() + \".\" + rc.name().stringValue());\n+                    rsc.incrementAndGet();\n+                })));\n+            } catch (Exception e) {\n+                throw new AssertionError(path.toString(), e);\n+            }\n+        });\n+        System.out.println(\"SignaturesTest - tested signatures of \" + csc + \" classes, \" + msc + \" methods, \" + fsc + \" fields and \" + rsc + \" record components\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile stack maps generator.\n+ * @build testdata.*\n+ * @run junit StackMapsTest\n+ *\/\n+\n+import jdk.internal.classfile.Classfile;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static helpers.TestUtil.assertEmpty;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+import java.lang.reflect.AccessFlag;\n+\n+\/**\n+ * StackMapsTest\n+ *\/\n+class StackMapsTest {\n+\n+    private byte[] buildDeadCode() {\n+        return Classfile.build(\n+                ClassDesc.of(\"DeadCodePattern\"),\n+                List.of(Classfile.Option.generateStackmap(false), Classfile.Option.patchDeadCode(false)),\n+                clb -> clb.withMethodBody(\n+                                \"twoReturns\",\n+                                MethodTypeDesc.of(ConstantDescs.CD_void),\n+                                0,\n+                                cob -> cob.return_().return_())\n+                        .withMethodBody(\n+                                \"deadJumpInExceptionBlocks\",\n+                                MethodTypeDesc.of(ConstantDescs.CD_void),\n+                                0,\n+                                cob -> {\n+                                    var deadEnd = cob.newLabel();\n+                                    cob.goto_(deadEnd);\n+                                    var deadStart = cob.newBoundLabel();\n+                                    cob.return_(); \/\/dead code\n+                                    cob.labelBinding(deadEnd);\n+                                    cob.return_();\n+                                    var handler = cob.newBoundLabel();\n+                                    cob.athrow();\n+                                    \/\/exception block before dead code to stay untouched\n+                                    cob.exceptionCatch(cob.startLabel(), deadStart, handler, ConstantDescs.CD_Throwable);\n+                                    \/\/exception block after dead code to stay untouched\n+                                    cob.exceptionCatch(deadEnd, handler, handler, ConstantDescs.CD_Throwable);\n+                                     \/\/exception block overlapping dead code to cut from right\n+                                    cob.exceptionCatch(cob.startLabel(), deadEnd, handler, ConstantDescs.CD_Throwable);\n+                                    \/\/exception block overlapping dead code to from left\n+                                    cob.exceptionCatch(deadStart, handler, handler, ConstantDescs.CD_Throwable);\n+                                    \/\/exception block matching dead code to remove\n+                                    cob.exceptionCatch(deadStart, deadEnd, handler, ConstantDescs.CD_Throwable);\n+                                    \/\/exception block around dead code to split\n+                                    cob.exceptionCatch(cob.startLabel(), handler, handler, ConstantDescs.CD_Throwable);\n+                                }));\n+    }\n+\n+    @Test\n+    void testDeadCodePatternPatch() throws Exception {\n+        testTransformedStackMaps(buildDeadCode());\n+    }\n+\n+    @Test\n+    void testDeadCodePatternFail() throws Exception {\n+        var error = assertThrows(IllegalStateException.class, () -> testTransformedStackMaps(buildDeadCode(), Classfile.Option.patchDeadCode(false)));\n+        assertLinesMatch(\n+            \"\"\"\n+            Unable to generate stack map frame for dead code at bytecode offset 1 of method twoReturns()\n+            >> more lines >>\n+                0: {opcode: RETURN}\n+                1: {opcode: RETURN}\n+            \"\"\".lines(),\n+            error.getMessage().lines(),\n+            error.getMessage()\n+        );\n+    }\n+\n+    @Test\n+    void testUnresolvedPermission() throws Exception {\n+        testTransformedStackMaps(\"modules\/java.base\/java\/security\/UnresolvedPermission.class\");\n+    }\n+\n+    @Test\n+    void testURL() throws Exception {\n+        testTransformedStackMaps(\"modules\/java.base\/java\/net\/URL.class\");\n+    }\n+\n+    @Test\n+    void testPattern1() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern1.class\");\n+    }\n+\n+    @Test\n+    void testPattern2() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern2.class\");\n+    }\n+\n+    @Test\n+    void testPattern3() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern3.class\");\n+    }\n+\n+    @Test\n+    void testPattern4() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern4.class\");\n+    }\n+\n+    @Test\n+    void testPattern5() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern5.class\");\n+    }\n+\n+    @Test\n+    void testPattern6() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern6.class\");\n+    }\n+\n+    @Test\n+    void testPattern7() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern7.class\");\n+    }\n+\n+    @Test\n+    void testPattern8() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern8.class\");\n+    }\n+\n+    @Test\n+    void testPattern9() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern9.class\");\n+    }\n+\n+    @Test\n+    void testPattern10() throws Exception {\n+        testTransformedStackMaps(\"\/testdata\/Pattern10.class\");\n+    }\n+\n+    @Test\n+    void testFrameOutOfBytecodeRange() {\n+        var error = assertThrows(IllegalStateException.class, () ->\n+        Classfile.parse(\n+                Classfile.build(ClassDesc.of(\"TestClass\"), clb ->\n+                        clb.withMethodBody(\"frameOutOfRangeMethod\", MethodTypeDesc.of(ConstantDescs.CD_void), 0, cob -> {\n+                            var l = cob.newLabel();\n+                            cob.goto_(l);\/\/jump to the end of method body triggers invalid frame creation\n+                            cob.labelBinding(l);\n+                        }))));\n+        assertLinesMatch(\n+            \"\"\"\n+            Detected branch target out of bytecode range at bytecode offset 0 of method frameOutOfRangeMethod()\n+            >> more lines >>\n+                0: {opcode: GOTO, target: 3}\n+            \"\"\".lines(),\n+            error.getMessage().lines(),\n+            error.getMessage()\n+        );\n+    }\n+\n+    @Test\n+    void testMethodSwitchFromStatic() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+        Classfile.build(ClassDesc.of(\"TestClass\"), clb ->\n+                clb.withMethod(\"testMethod\", MethodTypeDesc.of(ConstantDescs.CD_Object, ConstantDescs.CD_int),\n+                               ACC_STATIC,\n+                               mb -> mb.withCode(cob -> {\n+                                           var t = cob.newLabel();\n+                                           cob.aload(0).goto_(t).labelBinding(t).areturn();\n+                                       })\n+                                       .withFlags())));\n+    }\n+\n+    @Test\n+    void testMethodSwitchToStatic() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+        Classfile.build(ClassDesc.of(\"TestClass\"), clb ->\n+                clb.withMethod(\"testMethod\", MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int),\n+                               0, mb ->\n+                                       mb.withCode(cob -> {\n+                                             var t = cob.newLabel();\n+                                             cob.iload(0).goto_(t).labelBinding(t).ireturn();\n+                                         })\n+                                         .withFlags(AccessFlag.STATIC))));\n+    }\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+\n+    private static void testTransformedStackMaps(String classPath, Classfile.Option... options) throws Exception {\n+        testTransformedStackMaps(\n+                classPath.startsWith(\"\/\")\n+                            ? StackMapsTest.class.getResourceAsStream(classPath).readAllBytes()\n+                            : Files.readAllBytes(JRT.getPath(classPath)),\n+                options);\n+    }\n+\n+    private static void testTransformedStackMaps(byte[] originalBytes, Classfile.Option... options) throws Exception {\n+        \/\/transform the class model\n+        var classModel = Classfile.parse(originalBytes, options);\n+        var transformedBytes = Classfile.build(classModel.thisClass().asSymbol(), List.of(options),\n+                                               cb -> {\n+\/\/                                                   classModel.superclass().ifPresent(cb::withSuperclass);\n+\/\/                                                   cb.withInterfaces(classModel.interfaces());\n+\/\/                                                   cb.withVersion(classModel.majorVersion(), classModel.minorVersion());\n+                                                   classModel.forEachElement(cb);\n+                                               });\n+\n+        \/\/then verify transformed bytecode\n+        assertEmpty(Classfile.parse(transformedBytes).verify(null));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing CodeStackTracker in CodeBuilder.\n+ * @run junit StackTrackerTest\n+ *\/\n+import java.util.List;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ConstantDescs;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.components.CodeStackTracker;\n+import static jdk.internal.classfile.TypeKind.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * StackTrackerTest\n+ *\/\n+class StackTrackerTest {\n+\n+    @Test\n+    void testStackTracker() {\n+        Classfile.build(ClassDesc.of(\"Foo\"), clb ->\n+            clb.withMethodBody(\"m\", MethodTypeDesc.of(ConstantDescs.CD_Void), 0, cob -> {\n+                var stackTracker = CodeStackTracker.of(DoubleType, FloatType); \/\/initial stack tracker pre-set\n+                cob.transforming(stackTracker, stcb -> {\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(DoubleType, FloatType));\n+                    stcb.aload(0);\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, DoubleType, FloatType));\n+                    stcb.lconst_0();\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                    stcb.trying(tryb -> {\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        tryb.iconst_1();\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(IntType, LongType, ReferenceType, DoubleType, FloatType));\n+                        tryb.ifThen(thb -> {\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                            thb.constantInstruction(ClassDesc.of(\"Phee\"));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, LongType, ReferenceType, DoubleType, FloatType));\n+                            thb.athrow();\n+                            assertFalse(stackTracker.stack().isPresent());\n+                        });\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        tryb.return_();\n+                        assertFalse(stackTracker.stack().isPresent());\n+                    }, catchb -> catchb.catching(ClassDesc.of(\"Phee\"), cb -> {\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType));\n+                        cb.athrow();\n+                        assertFalse(stackTracker.stack().isPresent());\n+                    }));\n+                });\n+                assertTrue(stackTracker.maxStackSize().isPresent());\n+                assertEquals((int)stackTracker.maxStackSize().get(), 7);\n+            }));\n+    }\n+\n+    @Test\n+    void testTrackingLost() {\n+        Classfile.build(ClassDesc.of(\"Foo\"), clb ->\n+            clb.withMethodBody(\"m\", MethodTypeDesc.of(ConstantDescs.CD_Void), 0, cob -> {\n+                var stackTracker = CodeStackTracker.of();\n+                cob.transforming(stackTracker, stcb -> {\n+                    assertIterableEquals(stackTracker.stack().get(), List.of());\n+                    var l1 = stcb.newLabel();\n+                    stcb.goto_(l1); \/\/forward jump\n+                    assertFalse(stackTracker.stack().isPresent()); \/\/no stack\n+                    assertTrue(stackTracker.maxStackSize().isPresent()); \/\/however still tracking\n+                    var l2 = stcb.newBoundLabel(); \/\/back jump target\n+                    assertFalse(stackTracker.stack().isPresent()); \/\/no stack\n+                    assertTrue(stackTracker.maxStackSize().isPresent()); \/\/however still tracking\n+                    stcb.constantInstruction(ClassDesc.of(\"Phee\")); \/\/stack instruction on unknown stack cause tracking lost\n+                    assertFalse(stackTracker.stack().isPresent()); \/\/no stack\n+                    assertFalse(stackTracker.maxStackSize().isPresent()); \/\/because tracking lost\n+                    stcb.athrow();\n+                    stcb.labelBinding(l1); \/\/forward jump target\n+                    assertTrue(stackTracker.stack().isPresent()); \/\/stack known here\n+                    assertFalse(stackTracker.maxStackSize().isPresent()); \/\/no max stack size because tracking lost in back jump\n+                    stcb.goto_(l2); \/\/back jump\n+                    assertFalse(stackTracker.stack().isPresent()); \/\/no stack\n+                    assertFalse(stackTracker.maxStackSize().isPresent()); \/\/still no max stack size because tracking previously lost\n+                });\n+            }));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile streaming versus model.\n+ * @run junit StreamedVsListTest\n+ *\/\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.impl.DirectCodeBuilder;\n+import jdk.internal.classfile.instruction.BranchInstruction;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.FieldInstruction;\n+import jdk.internal.classfile.instruction.IncrementInstruction;\n+import jdk.internal.classfile.instruction.InvokeDynamicInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.classfile.instruction.LookupSwitchInstruction;\n+import jdk.internal.classfile.instruction.NewMultiArrayInstruction;\n+import jdk.internal.classfile.instruction.NewObjectInstruction;\n+import jdk.internal.classfile.instruction.NewPrimitiveArrayInstruction;\n+import jdk.internal.classfile.instruction.NewReferenceArrayInstruction;\n+import jdk.internal.classfile.instruction.StoreInstruction;\n+import jdk.internal.classfile.instruction.TableSwitchInstruction;\n+import jdk.internal.classfile.instruction.TypeCheckInstruction;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+class StreamedVsListTest {\n+    static byte[] fileBytes;\n+\n+    static {\n+        try {\n+            fileBytes = DirectCodeBuilder.class.getResourceAsStream(\"DirectCodeBuilder.class\").readAllBytes();\n+        } catch (IOException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+\n+    @Test\n+    void testStreamed() throws Exception {\n+        Vs vs = new Vs();\n+        vs.test();\n+        if (vs.failed) {\n+            throw new AssertionError(\"assertions failed\");\n+        }\n+    }\n+\n+    private class Vs {\n+        boolean failed;\n+        ClassModel cm = Classfile.parse(fileBytes);\n+        String meth;\n+        CodeElement iim;\n+        CodeElement mim;\n+        int n;\n+\n+        void test() {\n+            for (MethodModel mm : cm.methods()) {\n+                try {\n+                    mm.code().ifPresent(code -> {\n+                        meth = mm.methodName().stringValue();\n+                        List<CodeElement> insts = code.elementList();\n+                        n = 0;\n+                        for (CodeElement element : code) {\n+                            iim = element;\n+                            mim = insts.get(n++);\n+                            if (iim instanceof Instruction)\n+                                testInstruction();\n+                        }\n+                    });\n+                } catch (Throwable ex) {\n+                    failed = true;\n+                    System.err.printf(\"%s.%s #%d[%s]: \", cm.thisClass().asInternalName(), meth, n - 1, iim instanceof Instruction i ? i.opcode() : \"<->\");\n+                    System.err.printf(\"Threw: %s\" + \"%n\", ex);\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        void testInstruction() {\n+            assertEquals(((Instruction)iim).opcode(), ((Instruction)mim).opcode(), \"Opcodes don't match\");\n+            switch (((Instruction)iim).opcode().kind()) {\n+                case LOAD: {\n+                    LoadInstruction i = (LoadInstruction) iim;\n+                    LoadInstruction x = (LoadInstruction) mim;\n+                    assertEquals(i.slot(), x.slot(), \"variable\");\n+                    break;\n+                }\n+                case STORE: {\n+                    StoreInstruction i = (StoreInstruction) iim;\n+                    StoreInstruction x = (StoreInstruction) mim;\n+                    assertEquals(i.slot(), x.slot(), \"variable\");\n+                    break;\n+                }\n+                case INCREMENT: {\n+                    IncrementInstruction i = (IncrementInstruction) iim;\n+                    IncrementInstruction x = (IncrementInstruction) mim;\n+                    assertEquals(i.slot(), x.slot(), \"variable\");\n+                    assertEquals(i.constant(), x.constant(), \"constant\");\n+                    break;\n+                }\n+                case BRANCH: {\n+                    BranchInstruction i = (BranchInstruction) iim;\n+                    BranchInstruction x = (BranchInstruction) mim;\n+                    \/\/TODO: test labels\n+                    break;\n+                }\n+                case TABLE_SWITCH: {\n+                    TableSwitchInstruction i = (TableSwitchInstruction) iim;\n+                    TableSwitchInstruction x = (TableSwitchInstruction) mim;\n+                    assertEquals(i.lowValue(), x.lowValue(), \"lowValue\");\n+                    assertEquals(i.highValue(), x.highValue(), \"highValue\");\n+                    assertEquals(i.cases().size(), x.cases().size(), \"cases().size\");\n+                    \/\/TODO: test labels\n+                    break;\n+                }\n+                case LOOKUP_SWITCH: {\n+                    LookupSwitchInstruction i = (LookupSwitchInstruction) iim;\n+                    LookupSwitchInstruction x = (LookupSwitchInstruction) mim;\n+                    assertEquals(i.cases(), (Object) x.cases(), \"matches: \");\n+                    \/**\n+                    var ipairs = i.pairs();\n+                    var xpairs = x.pairs();\n+                    assertEquals(\"pairs().size\", ipairs.size(), xpairs.size());\n+                    for (int k = 0; k < xpairs.size(); ++k) {\n+                        assertEquals(\"pair #\" + k, ipairs.get(k).caseMatch(), xpairs.get(k).caseMatch());\n+                    }\n+                    **\/\n+                    \/\/TODO: test labels\n+                    break;\n+                }\n+                case RETURN:\n+                case THROW_EXCEPTION:\n+                    break;\n+                case FIELD_ACCESS: {\n+                    FieldInstruction i = (FieldInstruction) iim;\n+                    FieldInstruction x = (FieldInstruction) mim;\n+                    assertEquals(i.owner().asInternalName(), (Object) x.owner().asInternalName(), \"owner\");\n+                    assertEquals(i.name().stringValue(), (Object) x.name().stringValue(), \"name\");\n+                    assertEquals(i.type().stringValue(), (Object) x.type().stringValue(), \"type\");\n+                    break;\n+                }\n+                case INVOKE: {\n+                    InvokeInstruction i = (InvokeInstruction) iim;\n+                    InvokeInstruction x = (InvokeInstruction) mim;\n+                    assertEquals(i.owner().asInternalName(), (Object) x.owner().asInternalName(), \"owner\");\n+                    assertEquals(i.name().stringValue(), (Object) x.name().stringValue(), \"name\");\n+                    assertEquals(i.type().stringValue(), (Object) x.type().stringValue(), \"type\");\n+                    assertEquals(i.isInterface(), (Object) x.isInterface(), \"isInterface\");\n+                    assertEquals(i.count(), x.count(), \"count\");\n+                    break;\n+                }\n+                case INVOKE_DYNAMIC: {\n+                    InvokeDynamicInstruction i = (InvokeDynamicInstruction) iim;\n+                    InvokeDynamicInstruction x = (InvokeDynamicInstruction) mim;\n+                    assertEquals(i.bootstrapMethod(), x.bootstrapMethod(), \"bootstrapMethod\");\n+                    assertEquals(i.bootstrapArgs(), (Object) x.bootstrapArgs(), \"bootstrapArgs\");\n+                    assertEquals(i.name().stringValue(), (Object) x.name().stringValue(), \"name\");\n+                    assertEquals(i.type().stringValue(), (Object) x.type().stringValue(), \"type\");\n+                    break;\n+                }\n+                case NEW_OBJECT: {\n+                    NewObjectInstruction i = (NewObjectInstruction) iim;\n+                    NewObjectInstruction x = (NewObjectInstruction) mim;\n+                    assertEquals(i.className().asInternalName(), (Object) x.className().asInternalName(), \"type\");\n+                    break;\n+                }\n+                case NEW_PRIMITIVE_ARRAY:\n+                {\n+                    NewPrimitiveArrayInstruction i = (NewPrimitiveArrayInstruction) iim;\n+                    NewPrimitiveArrayInstruction x = (NewPrimitiveArrayInstruction) mim;\n+                    assertEquals(i.typeKind(), x.typeKind(), \"type\");\n+                    break;\n+                }\n+\n+                case NEW_REF_ARRAY:{\n+                    NewReferenceArrayInstruction i = (NewReferenceArrayInstruction) iim;\n+                    NewReferenceArrayInstruction x = (NewReferenceArrayInstruction) mim;\n+                    assertEquals(i.componentType().asInternalName(), (Object) x.componentType().asInternalName(), \"type\");\n+                    break;\n+                }\n+\n+                case NEW_MULTI_ARRAY:{\n+                    NewMultiArrayInstruction i = (NewMultiArrayInstruction) iim;\n+                    NewMultiArrayInstruction x = (NewMultiArrayInstruction) mim;\n+                    assertEquals(i.arrayType().asInternalName(), (Object) x.arrayType().asInternalName(), \"type\");\n+                    assertEquals(i.dimensions(), x.dimensions(), \"dimensions\");\n+                    break;\n+                }\n+\n+                case TYPE_CHECK: {\n+                    TypeCheckInstruction i = (TypeCheckInstruction) iim;\n+                    TypeCheckInstruction x = (TypeCheckInstruction) mim;\n+                    assertEquals(i.type().asInternalName(), (Object) x.type().asInternalName(), \"type\");\n+                    break;\n+                }\n+                case ARRAY_LOAD:\n+                case ARRAY_STORE:\n+                case STACK:\n+                case CONVERT:\n+                case OPERATOR:\n+                    break;\n+                case CONSTANT: {\n+                    ConstantInstruction i = (ConstantInstruction) iim;\n+                    ConstantInstruction x = (ConstantInstruction) mim;\n+                    assertEquals(i.constantValue(), x.constantValue(), \"constantValue\");\n+                }\n+                break;\n+                case MONITOR:\n+                case NOP:\n+                    break;\n+\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/StreamedVsListTest.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing swap instruction\n+ * @run junit SwapTest\n+ *\/\n+\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Classfile;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.reflect.AccessFlag.PUBLIC;\n+import static java.lang.reflect.AccessFlag.STATIC;\n+\n+class SwapTest {\n+    @Test\n+    void testTryCatchCatchAll() throws Throwable {\n+        MethodType mt = MethodType.methodType(String.class, String.class, String.class);\n+        MethodTypeDesc mtd = mt.describeConstable().get();\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"C\"), cb -> {\n+            cb.withMethodBody(\"m\", mtd, AccessFlags.ofMethod(PUBLIC, STATIC).flagsMask(), xb -> {\n+                        xb.aload(0); \/\/ 0\n+                        xb.aload(1); \/\/ 1, 0\n+                        xb.swap();   \/\/ 0, 1\n+                        xb.pop();    \/\/ 1\n+                        xb.areturn();\n+                    });\n+        });\n+\n+        MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+        MethodHandle m = lookup.findStatic(lookup.lookupClass(), \"m\", mt);\n+        assertEquals(m.invoke(\"A\", \"B\"), \"B\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SwapTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+maxOutputSize = 500000\n+enablePreview = true\n+modules = \\\n+    java.base\/jdk.internal.classfile \\\n+    java.base\/jdk.internal.classfile.attribute \\\n+    java.base\/jdk.internal.classfile.constantpool \\\n+    java.base\/jdk.internal.classfile.instruction \\\n+    java.base\/jdk.internal.classfile.impl \\\n+    java.base\/jdk.internal.classfile.impl.verifier \\\n+    java.base\/jdk.internal.classfile.jdktypes \\\n+    java.base\/jdk.internal.classfile.components \\\n+    java.base\/jdk.internal.classfile.util \\\n+    java.base\/jdk.internal.org.objectweb.asm \\\n+    java.base\/jdk.internal.org.objectweb.asm.tree\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/TEST.properties","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile TempConstantPoolBuilder.\n+ * @run junit TempConstantPoolBuilderTest\n+ *\/\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import java.lang.reflect.AccessFlag;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.constant.ClassDesc;\n+\n+import static helpers.TestConstants.MTD_VOID;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import java.lang.constant.MethodTypeDesc;\n+import static jdk.internal.classfile.Opcode.INVOKESPECIAL;\n+import static jdk.internal.classfile.TypeKind.VoidType;\n+\n+class TempConstantPoolBuilderTest {\n+\n+    public static final ClassDesc INTERFACE = ClassDesc.ofDescriptor(\"Ljava\/lang\/FunctionalInterface;\");\n+\n+    @Test\n+    void createAnno() {\n+        Annotation a = Annotation.of(INTERFACE,\n+                                     AnnotationElement.ofString(\"foo\", \"bar\"));\n+    }\n+\n+    @Test\n+    void addAnno() {\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC)\n+              .with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                            .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                    .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                    .returnInstruction(VoidType)\n+                            )\n+                            .with(RuntimeVisibleAnnotationsAttribute.of(Annotation.of(INTERFACE,\n+                                                                                      AnnotationElement.ofString(\"foo\", \"bar\"))))\n+              );\n+        });\n+        ClassModel m = Classfile.parse(bytes);\n+        \/\/ClassPrinter.toJson(m, ClassPrinter.Verbosity.TRACE_ALL, System.out::println);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TempConstantPoolBuilderTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile RecordComponent.\n+ * @run junit TestRecordComponent\n+ *\/\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import helpers.ClassRecord;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+class TestRecordComponent {\n+\n+    static final String testClassName = \"TestRecordComponent$TestRecord\";\n+    static final Path testClassPath = Paths.get(URI.create(ArrayTest.class.getResource(testClassName + \".class\").toString()));\n+\n+    @Test\n+    void testAdapt() throws Exception {\n+        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        ClassTransform xform = (cb, ce) -> {\n+            if (ce instanceof RecordAttribute rm) {\n+                List<RecordComponentInfo> components = rm.components();\n+                components = components.stream()\n+                                       .map(c -> RecordComponentInfo.of(c.name(), c.descriptor(), c.attributes()))\n+                                       .toList();\n+                cb.with(RecordAttribute.of(components));\n+            } else\n+                cb.with(ce);\n+        };\n+        ClassModel newModel = Classfile.parse(cm.transform(xform));\n+        ClassRecord.assertEquals(newModel, cm);\n+    }\n+\n+    @Test\n+    void testPassThrough() throws Exception {\n+        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        ClassTransform xform = (cb, ce) -> cb.with(ce);\n+        ClassModel newModel = Classfile.parse(cm.transform(xform));\n+        ClassRecord.assertEquals(newModel, cm);\n+    }\n+\n+    @Test\n+    void testChagne() throws Exception {\n+        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        ClassTransform xform = (cb, ce) -> {\n+            if (ce instanceof RecordAttribute ra) {\n+                List<RecordComponentInfo> components = ra.components();\n+                components = components.stream().map(c -> RecordComponentInfo.of(TemporaryConstantPool.INSTANCE.utf8Entry(c.name().stringValue() + \"XYZ\"), c.descriptor(), List.of()))\n+                                       .toList();\n+                cb.with(RecordAttribute.of(components));\n+            }\n+            else\n+                cb.with(ce);\n+        };\n+        ClassModel newModel = Classfile.parse(cm.transform(xform));\n+        RecordAttribute ra = newModel.findAttribute(Attributes.RECORD).orElseThrow();\n+        assertEquals(ra.components().size(), 2, \"Should have two components\");\n+        assertEquals(ra.components().get(0).name().stringValue(), \"fooXYZ\");\n+        assertEquals(ra.components().get(1).name().stringValue(), \"barXYZ\");\n+        assertTrue(ra.components().get(0).attributes().isEmpty());\n+        assertEquals(newModel.attributes().size(), cm.attributes().size());\n+    }\n+\n+    @Test\n+    void testOptions() throws Exception {\n+        AtomicInteger count = new AtomicInteger(0);\n+        ClassModel cm = Classfile.parse(Files.readAllBytes(testClassPath));\n+        cm.forEachElement((ce) -> {\n+            if (ce instanceof RecordAttribute rm) {\n+                count.addAndGet(rm.components().size());\n+            }});\n+        assertEquals(count.get(), 2);\n+        assertEquals(cm.findAttribute(Attributes.RECORD).orElseThrow().components().size(), 2);\n+\n+        count.set(0);\n+    }\n+\n+    public static record TestRecord(@RC String foo, int bar) {}\n+\n+    @Target(ElementType.RECORD_COMPONENT)\n+    public @interface RC {}\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TestRecordComponent.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile transformations.\n+ * @run junit TransformTests\n+ *\/\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import helpers.ByteArrayClassLoader;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * TransformTests\n+ *\/\n+class TransformTests {\n+    static final String testClassName = \"TransformTests$TestClass\";\n+    static final Path testClassPath = Paths.get(URI.create(ArrayTest.class.getResource(testClassName + \".class\").toString()));\n+    static CodeTransform\n+            foo2foo = swapLdc(\"foo\", \"foo\"),\n+            foo2bar = swapLdc(\"foo\", \"bar\"),\n+            bar2baz = swapLdc(\"bar\", \"baz\"),\n+            baz2quux = swapLdc(\"baz\", \"quux\"),\n+            baz2foo = swapLdc(\"baz\", \"foo\");\n+\n+    static CodeTransform swapLdc(String x, String y) {\n+        return (b, e) -> {\n+            if (e instanceof ConstantInstruction ci && ci.constantValue().equals(x)) {\n+                b.constantInstruction(y);\n+            }\n+            else\n+                b.with(e);\n+        };\n+    }\n+\n+    static ClassTransform transformCode(CodeTransform x) {\n+        return (cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                cb.transformMethod(mm, (mb, me) -> {\n+                    if (me instanceof CodeModel xm) {\n+                        mb.transformCode(xm, x);\n+                    }\n+                    else\n+                        mb.with(me);\n+                });\n+            }\n+            else\n+                cb.with(ce);\n+        };\n+    }\n+\n+    static String invoke(byte[] bytes) throws Exception {\n+        return (String)\n+                new ByteArrayClassLoader(AdaptCodeTest.class.getClassLoader(), testClassName, bytes)\n+                        .getMethod(testClassName, \"foo\")\n+                        .invoke(null);\n+    }\n+\n+    @Test\n+    void testSingleTransform() throws Exception {\n+\n+        byte[] bytes = Files.readAllBytes(testClassPath);\n+        ClassModel cm = Classfile.parse(bytes);\n+\n+        assertEquals(invoke(bytes), \"foo\");\n+        assertEquals(invoke(cm.transform(transformCode(foo2foo))), \"foo\");\n+        assertEquals(invoke(cm.transform(transformCode(foo2bar))), \"bar\");\n+    }\n+\n+    @Test\n+    void testSeq2() throws Exception {\n+\n+        byte[] bytes = Files.readAllBytes(testClassPath);\n+        ClassModel cm = Classfile.parse(bytes);\n+\n+        assertEquals(invoke(bytes), \"foo\");\n+        ClassTransform transform = transformCode(foo2bar.andThen(bar2baz));\n+        assertEquals(invoke(cm.transform(transform)), \"baz\");\n+    }\n+\n+    @Test\n+    void testSeqN() throws Exception {\n+\n+        byte[] bytes = Files.readAllBytes(testClassPath);\n+        ClassModel cm = Classfile.parse(bytes);\n+\n+        assertEquals(invoke(bytes), \"foo\");\n+        assertEquals(invoke(cm.transform(transformCode(foo2bar.andThen(bar2baz).andThen(baz2foo)))), \"foo\");\n+        assertEquals(invoke(cm.transform(transformCode(foo2bar.andThen(bar2baz).andThen(baz2quux)))), \"quux\");\n+        assertEquals(invoke(cm.transform(transformCode(foo2foo.andThen(foo2bar).andThen(bar2baz)))), \"baz\");\n+    }\n+\n+    public static class TestClass {\n+        static public String foo() {\n+            return \"foo\";\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile CP Utf8Entry.\n+ * @run junit Utf8EntryTest\n+ *\/\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.function.UnaryOperator;\n+\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.TypeKind.VoidType;\n+\n+class Utf8EntryTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(\n+        strings = {\n+            \"ascii\",\n+\n+            \"prefix\\u0080\\u0080\\u0080postfix\",\n+            \"prefix\\u0080\\u0080\\u0080\",\n+            \"\\u0080\\u0080\\u0080postfix\",\n+            \"\\u0080\\u0080\\u0080\",\n+\n+            \"prefix\\u07FF\\u07FF\\u07FFpostfix\",\n+            \"prefix\\u07FF\\u07FF\\u07FF\",\n+            \"\\u07FF\\u07FF\\u07FFpostfix\",\n+            \"\\u07FF\\u07FF\\u07FF\",\n+\n+            \"prefix\\u0800\\u0800\\u0800postfix\",\n+            \"prefix\\u0800\\u0800\\u0800\",\n+            \"\\u0800\\u0800\\u0800postfix\",\n+            \"\\u0800\\u0800\\u0800\",\n+\n+            \"prefix\\uFFFF\\uFFFF\\uFFFFpostfix\",\n+            \"prefix\\uFFFF\\uFFFF\\uFFFF\",\n+            \"\\uFFFF\\uFFFF\\uFFFFpostfix\",\n+            \"\\uFFFF\\uFFFF\\uFFFF\",\n+            \"\\ud83d\\ude01\"\n+        }\n+    )\n+    void testParse(String s) {\n+        byte[] classfile = createClassfile(s);\n+\n+        ClassModel cm = Classfile.parse(classfile);\n+        StringEntry se = obtainStringEntry(cm.constantPool());\n+\n+        Utf8Entry utf8Entry = se.utf8();\n+        \/\/ Inflate to byte[] or char[]\n+        assertTrue(utf8Entry.equalsString(s));\n+\n+        \/\/ Create string\n+        assertEquals(utf8Entry.stringValue(), s);\n+    }\n+\n+    static Stream<UnaryOperator<byte[]>> malformedStringsProvider() {\n+        List<UnaryOperator<byte[]>> l = new ArrayList<>();\n+\n+        l.add(withByte(0b1010_0000));\n+        l.add(withByte(0b1000_0000));\n+\n+        l.add(withByte(0b1101_0000));\n+        l.add(withByte(0b1100_0000));\n+        l.add(withByte(0b1001_0000));\n+        l.add(withByte(0b1000_0000));\n+\n+        l.add(withString(\"#X\", s -> {\n+            byte[] c = new String(\"\\u0080\").getBytes(StandardCharsets.UTF_8);\n+\n+            s[0] = c[0];\n+            s[1] = (byte) ((c[1] & 0xFF) & 0b0111_1111);\n+\n+            return s;\n+        }));\n+        l.add(withString(\"#X#\", s -> {\n+            byte[] c = new String(\"\\u0800\").getBytes(StandardCharsets.UTF_8);\n+\n+            s[0] = c[0];\n+            s[1] = (byte) ((c[1] & 0xFF) & 0b0111_1111);\n+            s[2] = c[2];\n+\n+            return s;\n+        }));\n+        l.add(withString(\"##X\", s -> {\n+            byte[] c = new String(\"\\u0800\").getBytes(StandardCharsets.UTF_8);\n+\n+            s[0] = c[0];\n+            s[1] = c[1];\n+            s[2] = (byte) ((c[2] & 0xFF) & 0b0111_1111);\n+\n+            return s;\n+        }));\n+\n+        return l.stream();\n+    }\n+\n+    static UnaryOperator<byte[]> withByte(int b) {\n+        return withString(Integer.toBinaryString(b), s -> {\n+            s[0] = (byte) b;\n+            return s;\n+        });\n+    }\n+\n+    static UnaryOperator<byte[]> withString(String name, UnaryOperator<byte[]> u) {\n+        return new UnaryOperator<byte[]>() {\n+            @Override\n+            public byte[] apply(byte[] bytes) {\n+                return u.apply(bytes);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedStringsProvider\")\n+    void testMalformedInput(UnaryOperator<byte[]> f) {\n+        String marker = \"XXXXXXXX\";\n+        byte[] classfile = createClassfile(marker);\n+        replace(classfile, marker, f);\n+\n+        ClassModel cm = Classfile.parse(classfile);\n+        StringEntry se = obtainStringEntry(cm.constantPool());\n+\n+        assertThrows(RuntimeException.class, () -> {\n+            String s = se.utf8().stringValue();\n+        });\n+    }\n+\n+    static void replace(byte[] b, String s, UnaryOperator<byte[]> f) {\n+        replace(b, s.getBytes(StandardCharsets.UTF_8), f);\n+    }\n+\n+    static void replace(byte[] b, byte[] s, UnaryOperator<byte[]> f) {\n+        for (int i = 0; i < b.length - s.length; i++) {\n+            if (Arrays.equals(b, i, i + s.length, s, 0, s.length)) {\n+                s = f.apply(s);\n+                System.arraycopy(s, 0, b, i, s.length);\n+                return;\n+            }\n+        }\n+        throw new AssertionError();\n+    }\n+\n+    static StringEntry obtainStringEntry(ConstantPool cp) {\n+        for (int i = 1; i < cp.entryCount(); i++) {\n+            PoolEntry entry = cp.entryByIndex(i);\n+            if (entry instanceof StringEntry se) {\n+                return se;\n+            }\n+        }\n+        throw new AssertionError();\n+    }\n+\n+    static byte[] createClassfile(String s) {\n+        return Classfile.build(ClassDesc.of(\"C\"),\n+                               clb -> clb.withMethod(\"m\", MethodTypeDesc.of(CD_void), 0,\n+                                                     mb -> mb.withCode(cb -> cb.constantInstruction(s)\n+                                                                               .returnInstruction(VoidType))));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/Utf8EntryTest.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile Util.\n+ * @run junit UtilTest\n+ *\/\n+import jdk.internal.classfile.impl.Util;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * UtilTest\n+ *\/\n+class UtilTest {\n+    @Test\n+    void testFindParams() {\n+        assertEquals(Util.findParams(\"(IIII)V\").cardinality(), 4);\n+        assertEquals(Util.findParams(\"([I[I[I[I)V\").cardinality(), 4);\n+        assertEquals(Util.findParams(\"(IJLFoo;IJ)V\").cardinality(), 5);\n+        assertEquals(Util.findParams(\"([[[[I)V\").cardinality(), 1);\n+        assertEquals(Util.findParams(\"([[[[LFoo;)V\").cardinality(), 1);\n+        assertEquals(Util.findParams(\"([I[LFoo;)V\").cardinality(), 2);\n+        assertEquals(Util.findParams(\"()V\").cardinality(), 0);\n+    }\n+\n+    @Test\n+    void testParameterSlots() {\n+        assertEquals(Util.parameterSlots(\"(IIII)V\"), 4);\n+        assertEquals(Util.parameterSlots(\"([I[I[I[I)V\"), 4);\n+        assertEquals(Util.parameterSlots(\"(IJLFoo;IJ)V\"), 7);\n+        assertEquals(Util.parameterSlots(\"([[[[I)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"([[[[LFoo;)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"([I[LFoo;)V\"), 2);\n+        assertEquals(Util.parameterSlots(\"()V\"), 0);\n+        assertEquals(Util.parameterSlots(\"(I)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(S)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(C)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(B)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(Z)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(F)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(LFoo;)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"(J)V\"), 2);\n+        assertEquals(Util.parameterSlots(\"(D)V\"), 2);\n+        assertEquals(Util.parameterSlots(\"([J)V\"), 1);\n+        assertEquals(Util.parameterSlots(\"([D)V\"), 1);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile Verifier.\n+ * @run junit VerifierSelfTest\n+ *\/\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.MethodModel;\n+import org.junit.jupiter.api.Test;\n+\n+class VerifierSelfTest {\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+\n+    @Test\n+    void testVerify() throws IOException {\n+        Stream.of(\n+                Files.walk(JRT.getPath(\"modules\/java.base\")),\n+                Files.walk(JRT.getPath(\"modules\"), 2).filter(p -> p.endsWith(\"module-info.class\")))\n+                    .flatMap(p -> p)\n+                    .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\")).forEach(path -> {\n+                        try {\n+                            Classfile.parse(path).verify(null);\n+                        } catch (IOException e) {\n+                            throw new AssertionError(e);\n+                        }\n+                    });\n+    }\n+\n+    @Test\n+    void testFailedDump() throws IOException {\n+        Path path = FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\/HashMap.class\");\n+        var classModel = Classfile.parse(path, Classfile.Option.classHierarchyResolver(className -> null));\n+        byte[] brokenClassBytes = classModel.transform(\n+                (clb, cle) -> {\n+                    if (cle instanceof MethodModel mm) {\n+                        clb.transformMethod(mm, (mb, me) -> {\n+                            if (me instanceof CodeModel cm) {\n+                                mb.withCode(cob -> cm.forEachElement(cob));\n+                            }\n+                            else\n+                                mb.with(me);\n+                        });\n+                    }\n+                    else\n+                        clb.with(cle);\n+                });\n+        StringBuilder sb = new StringBuilder();\n+        if (Classfile.parse(brokenClassBytes).verify(sb::append).isEmpty()) {\n+            throw new AssertionError(\"expected verification failure\");\n+        }\n+        String output = sb.toString();\n+        if (!output.contains(\"- method name: \")) {\n+            System.out.println(output);\n+            throw new AssertionError(\"failed method not dumped to output\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile class building.\n+ * @run junit WriteTest\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import helpers.TestConstants;\n+import jdk.internal.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import org.junit.jupiter.api.Test;\n+\n+import static helpers.TestConstants.MTD_VOID;\n+import static java.lang.constant.ConstantDescs.*;\n+import static jdk.internal.classfile.Opcode.*;\n+import static jdk.internal.classfile.TypeKind.IntType;\n+import static jdk.internal.classfile.TypeKind.ReferenceType;\n+import static jdk.internal.classfile.TypeKind.VoidType;\n+\n+class WriteTest {\n+\n+    @Test\n+    void testJavapWrite() {\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\",\n+                                                                 MethodTypeDesc.ofDescriptor(\"()V\"), false)\n+                                              .returnInstruction(VoidType)\n+                      )\n+              )\n+              .withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(c0 -> {\n+                                  Label loopTop = c0.newLabel();\n+                                  Label loopEnd = c0.newLabel();\n+                                  c0\n+                                          .constantInstruction(ICONST_1, 1)         \/\/ 0\n+                                          .storeInstruction(TypeKind.IntType, 1)          \/\/ 1\n+                                          .constantInstruction(ICONST_1, 1)         \/\/ 2\n+                                          .storeInstruction(TypeKind.IntType, 2)          \/\/ 3\n+                                          .labelBinding(loopTop)\n+                                          .loadInstruction(TypeKind.IntType, 2)           \/\/ 4\n+                                          .constantInstruction(BIPUSH, 10)         \/\/ 5\n+                                          .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n+                                          .loadInstruction(TypeKind.IntType, 1)           \/\/ 7\n+                                          .loadInstruction(TypeKind.IntType, 2)           \/\/ 8\n+                                          .operatorInstruction(IMUL)             \/\/ 9\n+                                          .storeInstruction(TypeKind.IntType, 1)          \/\/ 10\n+                                          .incrementInstruction(2, 1)    \/\/ 11\n+                                          .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                          .labelBinding(loopEnd)\n+                                          .fieldInstruction(GETSTATIC, TestConstants.CD_System, \"out\", TestConstants.CD_PrintStream)   \/\/ 13\n+                                          .loadInstruction(TypeKind.IntType, 1)\n+                                          .invokeInstruction(INVOKEVIRTUAL, TestConstants.CD_PrintStream, \"println\", TestConstants.MTD_INT_VOID, false)  \/\/ 15\n+                                          .returnInstruction(VoidType);\n+                              }));\n+        });\n+    }\n+\n+    @Test\n+    void testPrimitiveWrite() {\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC)\n+              .with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                      .withCode(codeb -> codeb.loadInstruction(ReferenceType, 0)\n+                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .returnInstruction(VoidType)\n+                      )\n+              )\n+              .withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                          AccessFlags.ofMethod(AccessFlag.PUBLIC, AccessFlag.STATIC).flagsMask(),\n+                          mb -> mb.withCode(c0 -> {\n+                                  Label loopTop = c0.newLabel();\n+                                  Label loopEnd = c0.newLabel();\n+                                  c0\n+                                          .constantInstruction(ICONST_1, 1)        \/\/ 0\n+                                          .storeInstruction(IntType, 1)          \/\/ 1\n+                                          .constantInstruction(ICONST_1, 1)        \/\/ 2\n+                                          .storeInstruction(IntType, 2)          \/\/ 3\n+                                          .labelBinding(loopTop)\n+                                          .loadInstruction(IntType, 2)           \/\/ 4\n+                                          .constantInstruction(BIPUSH, 10)         \/\/ 5\n+                                          .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n+                                          .loadInstruction(IntType, 1)           \/\/ 7\n+                                          .loadInstruction(IntType, 2)           \/\/ 8\n+                                          .operatorInstruction(IMUL)             \/\/ 9\n+                                          .storeInstruction(IntType, 1)          \/\/ 10\n+                                          .incrementInstruction(2, 1)    \/\/ 11\n+                                          .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                          .labelBinding(loopEnd)\n+                                          .fieldInstruction(GETSTATIC, TestConstants.CD_System, \"out\", TestConstants.CD_PrintStream)   \/\/ 13\n+                                          .loadInstruction(IntType, 1)\n+                                          .invokeInstruction(INVOKEVIRTUAL, TestConstants.CD_PrintStream, \"println\", TestConstants.MTD_INT_VOID, false)  \/\/ 15\n+                                          .returnInstruction(VoidType);\n+                              }));\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/WriteTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile AnnotationsExamples compilation.\n+ * @compile AnnotationsExamples.java\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.components.ClassPrinter;\n+\n+public class AnnotationsExamples {\n+\n+    \/** Add a single annotation to a class using a builder convenience *\/\n+    public byte[] addAnno(ClassModel m) {\n+        \/\/ @@@ Not correct\n+        List<Annotation> annos = List.of(Annotation.of(ClassDesc.of(\"java.lang.FunctionalInterface\")));\n+        return m.transform(ClassTransform.endHandler(cb -> cb.with(RuntimeVisibleAnnotationsAttribute.of(annos))));\n+    }\n+\n+    \/**\n+     * Find classes with annotations of a certain type\n+     *\/\n+    public void findAnnotation(ClassModel m) {\n+        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+            for (Annotation ann : a.annotations()) {\n+                if (ann.className().stringValue().equals(\"Ljava\/lang\/FunctionalInterface;\"))\n+                    System.out.println(m.thisClass().asInternalName());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Find classes with a specific annotation and create a new byte[] with that annotation swapped for @Deprecated.\n+     *\/\n+    public void swapAnnotation(ClassModel m) {\n+        ClassModel m2 = m;\n+\n+        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+            for (Annotation ann : a.annotations()) {\n+                if (ann.className().stringValue().equals(\"Ljava\/lang\/annotation\/Documented;\")) {\n+                    m2 = Classfile.parse(m.transform(SWAP_ANNO_TRANSFORM));\n+                }\n+            }\n+        }\n+\n+        if (m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+            for (Annotation ann : a.annotations()) {\n+                if (ann.className().stringValue().equals(\"Ljava\/lang\/annotation\/Documented;\"))\n+                    throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    \/\/where\n+    private static final ClassTransform SWAP_ANNO_TRANSFORM = (cb, ce) -> {\n+        switch (ce) {\n+            case RuntimeVisibleAnnotationsAttribute attr -> {\n+                List<Annotation> old = attr.annotations();\n+                List<Annotation> newAnnos = new ArrayList<>(old.size());\n+                for (Annotation ann : old) {\n+                    if (ann.className().stringValue().equals(\"Ljava\/lang\/annotation\/Documented;\")) {\n+                        newAnnos.add(Annotation.of(ClassDesc.of(\"java.lang.Deprecated\"), List.of()));\n+                    }\n+                    else\n+                        newAnnos.add(ann);\n+                }\n+                cb.with(RuntimeVisibleAnnotationsAttribute.of(newAnnos));\n+            }\n+            default -> cb.with(ce);\n+        }\n+    };\n+\n+    \/**\n+     * Find classes with a specific annotation and create a new byte[] with the same content except also adding a new annotation\n+     *\/\n+    public void addAnnotation(ClassModel m) {\n+        ClassModel m2 = m;\n+\n+        if (m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).isPresent()) {\n+            RuntimeVisibleAnnotationsAttribute a = m.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).get();\n+            for (Annotation ann : a.annotations()) {\n+                if (ann.className().stringValue().equals(\"Ljava\/lang\/FunctionalInterface;\")) {\n+                    m2 = Classfile.parse(m.transform((cb, ce) -> {\n+                        if (ce instanceof RuntimeVisibleAnnotationsAttribute ra) {\n+                            var oldAnnos = ra.annotations();\n+                            List<Annotation> newAnnos = new ArrayList<>(oldAnnos.size() + 1);\n+                            for (Annotation aa :oldAnnos)\n+                                newAnnos.add(aa);\n+                            ConstantPoolBuilder cpb = cb.constantPool();\n+                            newAnnos.add(Annotation.of(ClassDesc.of(\"java.lang.Deprecated\"), List.of()));\n+                            cb.with(RuntimeVisibleAnnotationsAttribute.of(newAnnos));\n+                        } else {\n+                            cb.with(ce);\n+                        }\n+                    }));\n+                }\n+            }\n+        }\n+\n+        int size = m2.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElseThrow().annotations().size();\n+        if (size !=2) {\n+            StringBuilder sb = new StringBuilder();\n+            ClassPrinter.toJson(m2, ClassPrinter.Verbosity.TRACE_ALL, sb::append);\n+            System.err.println(sb.toString());\n+        }\n+    }\n+\n+    public byte[] viaEndHandlerClassBuilderEdition(ClassModel m) {\n+        return m.transform(ClassTransform.ofStateful(() -> new ClassTransform() {\n+            boolean found = false;\n+\n+            @Override\n+            public void accept(ClassBuilder cb, ClassElement ce) {\n+                switch (ce) {\n+                    case RuntimeVisibleAnnotationsAttribute rvaa -> {\n+                        found = true;\n+                        List<Annotation> newAnnotations = new ArrayList<>(rvaa.annotations().size() + 1);\n+                        newAnnotations.addAll(rvaa.annotations());\n+                        newAnnotations.add(Annotation.of(ClassDesc.of(\"Foo\")));\n+                        cb.with(RuntimeVisibleAnnotationsAttribute.of(newAnnotations));\n+                    }\n+                    default -> cb.with(ce);\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                if (!found) {\n+                    builder.with(RuntimeVisibleAnnotationsAttribute.of(List.of(Annotation.of(ClassDesc.of(\"Foo\")))));\n+                }\n+            }\n+        }));\n+    }\n+\n+    public byte[] viaEndHandlerClassTransformEdition(ClassModel m) {\n+        return m.transform(ClassTransform.ofStateful(() -> new ClassTransform() {\n+            boolean found = false;\n+\n+            @Override\n+            public void accept(ClassBuilder cb, ClassElement ce) {\n+                if (ce instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                    found = true;\n+                    List<Annotation> newAnnotations = new ArrayList<>(rvaa.annotations().size() + 1);\n+                    newAnnotations.addAll(rvaa.annotations());\n+                    newAnnotations.add(Annotation.of(ClassDesc.of(\"Foo\")));\n+\n+                    cb.with(RuntimeVisibleAnnotationsAttribute.of(newAnnotations));\n+                }\n+                else\n+                    cb.with(ce);\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                if (!found) {\n+                    builder.with(RuntimeVisibleAnnotationsAttribute.of(List.of(Annotation.of(ClassDesc.of(\"Foo\")))));\n+                }\n+            }\n+        }));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/examples\/AnnotationsExamples.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile ExampleGallery compilation.\n+ * @compile ExampleGallery.java\n+ *\/\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassfileVersion;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.Interfaces;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.Signature.ClassTypeSig;\n+import jdk.internal.classfile.Superclass;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.instruction.ConstantInstruction;\n+import jdk.internal.classfile.instruction.InvokeInstruction;\n+\n+\/**\n+ * ExampleGallery\n+ *\/\n+public class ExampleGallery {\n+    public byte[] changeClassVersion(ClassModel cm) {\n+        return cm.transform((cb, ce) -> {\n+            switch (ce) {\n+                case ClassfileVersion cv -> cb.withVersion(57, 0);\n+                default -> cb.with(ce);\n+            }\n+        });\n+    }\n+\n+    public byte[] incrementClassVersion(ClassModel cm) {\n+        return cm.transform((cb, ce) -> {\n+            switch (ce) {\n+                case ClassfileVersion cv -> cb.withVersion(cv.majorVersion() + 1, 0);\n+                default -> cb.with(ce);\n+            }\n+        });\n+    }\n+\n+    public byte[] changeSuperclass(ClassModel cm, ClassDesc superclass) {\n+        return cm.transform((cb, ce) -> {\n+            switch (ce) {\n+                case Superclass sc -> cb.withSuperclass(superclass);\n+                default -> cb.with(ce);\n+            }\n+        });\n+    }\n+\n+    public byte[] overrideSuperclass(ClassModel cm, ClassDesc superclass) {\n+        return cm.transform(ClassTransform.endHandler(cb -> cb.withSuperclass(superclass)));\n+    }\n+\n+    public byte[] removeInterface(ClassModel cm, String internalName) {\n+        return cm.transform((cb, ce) -> {\n+            switch (ce) {\n+                case Interfaces i -> cb.withInterfaces(i.interfaces().stream()\n+                                                        .filter(e -> !e.asInternalName().equals(internalName))\n+                                                        .toList());\n+                default -> cb.with(ce);\n+            }\n+        });\n+    }\n+\n+    public byte[] addInterface(ClassModel cm, ClassDesc newIntf) {\n+        return cm.transform(ClassTransform.ofStateful(()  -> new ClassTransform() {\n+            boolean seen = false;\n+\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                switch (element) {\n+                    case Interfaces i:\n+                        List<ClassEntry> interfaces = Stream.concat(i.interfaces().stream(),\n+                                                                    Stream.of(builder.constantPool().classEntry(newIntf)))\n+                                                            .distinct()\n+                                                            .toList();\n+                        builder.withInterfaces(interfaces);\n+                        seen = true;\n+                        break;\n+\n+                    default:\n+                        builder.with(element);\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                if (!seen)\n+                    builder.withInterfaceSymbols(newIntf);\n+            }\n+        }));\n+\n+    }\n+    public byte[] addInterface1(ClassModel cm, ClassDesc newIntf) {\n+        return cm.transform(ClassTransform.ofStateful(()  -> new ClassTransform() {\n+            Interfaces interfaces;\n+\n+            @Override\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                switch (element) {\n+                    case Interfaces i -> interfaces = i;\n+                    default -> builder.with(element);\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(ClassBuilder builder) {\n+                if (interfaces != null) {\n+                    builder.withInterfaces(Stream.concat(interfaces.interfaces().stream(),\n+                                                         Stream.of(builder.constantPool().classEntry(newIntf)))\n+                                                 .distinct()\n+                                                 .toList());\n+                }\n+                else {\n+                    builder.withInterfaceSymbols(newIntf);\n+                }\n+            }\n+        }));\n+    }\n+\n+    public byte[] removeSignature(ClassModel cm) {\n+        return cm.transform(ClassTransform.dropping(e -> e instanceof SignatureAttribute));\n+    }\n+\n+    public byte[] changeSignature(ClassModel cm) {\n+        return cm.transform((cb, ce) -> {\n+            switch (ce) {\n+                case SignatureAttribute sa -> {\n+                    String result = sa.signature().stringValue();\n+                    cb.with(SignatureAttribute.of(ClassSignature.parseFrom(result.replace(\"this\/\", \"that\/\"))));\n+                }\n+                default -> cb.with(ce);\n+            }\n+        });\n+    }\n+\n+    public byte[] setSignature(ClassModel cm) {\n+        return cm.transform(ClassTransform.dropping(e -> e instanceof SignatureAttribute)\n+                                          .andThen(ClassTransform.endHandler(b -> b.with(SignatureAttribute.of(\n+                                              ClassSignature.of(\n+                                                      ClassTypeSig.of(ClassDesc.of(\"impl.Fox\"),\n+                                                                      ClassTypeSig.of(ClassDesc.of(\"impl.Cow\"))),\n+                                                      ClassTypeSig.of(ClassDesc.of(\"api.Rat\"))))))));\n+    }\n+\n+    \/\/ @@@ strip annos (class, all)\n+\n+    public byte[] stripFields(ClassModel cm, Predicate<String> filter) {\n+        return cm.transform(ClassTransform.dropping(e -> e instanceof FieldModel fm\n+                                                         && filter.test(fm.fieldName().stringValue())));\n+    }\n+\n+    public byte[] addField(ClassModel cm) {\n+        return cm.transform(ClassTransform.endHandler(cb -> cb.withField(\"cool\", ClassDesc.ofDescriptor(\"(I)D\"), Classfile.ACC_PUBLIC)));\n+    }\n+\n+    public byte[] changeFieldSig(ClassModel cm) {\n+        return cm.transform(ClassTransform.transformingFields((fb, fe) -> {\n+            if (fe instanceof SignatureAttribute sa)\n+                fb.with(SignatureAttribute.of(Signature.parseFrom(sa.signature().stringValue().replace(\"this\/\", \"that\/\"))));\n+            else\n+                fb.with(fe);\n+        }));\n+    }\n+\n+    public byte[] changeFieldFlags(ClassModel cm) {\n+        return cm.transform(ClassTransform.transformingFields((fb, fe) -> {\n+            switch (fe) {\n+                case AccessFlags a -> fb.with(AccessFlags.ofField(a.flagsMask() & ~Classfile.ACC_PUBLIC & ~Classfile.ACC_PROTECTED));\n+                default -> fb.with(fe);\n+            }\n+        }));\n+    }\n+\n+    public byte[] addException(ClassModel cm, ClassDesc ex) {\n+        return cm.transform(ClassTransform.transformingMethods(\n+                MethodTransform.ofStateful(() -> new MethodTransform() {\n+                    ExceptionsAttribute attr;\n+\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        switch (element) {\n+                            case ExceptionsAttribute a -> attr = a;\n+                            default -> builder.with(element);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void atEnd(MethodBuilder builder) {\n+                        if (attr == null) {\n+                            builder.with(ExceptionsAttribute.ofSymbols(ex));\n+                        }\n+                        else {\n+                            ClassEntry newEx = builder.constantPool().classEntry(ex);\n+                            if (!attr.exceptions().contains(newEx)) {\n+                                attr = ExceptionsAttribute.of(Stream.concat(attr.exceptions().stream(),\n+                                                                            Stream.of(newEx))\n+                                                                    .toList());\n+                            }\n+                            builder.with(attr);\n+                        }\n+                    }\n+                })));\n+    }\n+\n+    public byte[] addInstrumentation(ClassModel cm) {\n+        CodeTransform transform = CodeTransform.ofStateful(() -> new CodeTransform() {\n+            boolean found = true;\n+\n+            @Override\n+            public void accept(CodeBuilder codeB, CodeElement codeE) {\n+                if (found) {\n+                    codeB.nopInstruction();\n+                    found = false;\n+                }\n+                codeB.with(codeE);\n+            }\n+        });\n+\n+        return cm.transform(ClassTransform.transformingMethodBodies(transform));\n+    }\n+\n+    public byte[] addInstrumentationBeforeInvoke(ClassModel cm) {\n+        return cm.transform(ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+            switch (codeE) {\n+                case InvokeInstruction i -> {\n+                    codeB.nopInstruction();\n+                    codeB.with(codeE);\n+                }\n+                default -> codeB.with(codeE);\n+            }\n+        }));\n+    }\n+\n+    public byte[] replaceIntegerConstant(ClassModel cm) {\n+        return cm.transform(ClassTransform.transformingMethodBodies((codeB, codeE) -> {\n+            switch (codeE) {\n+                case ConstantInstruction ci -> {\n+                        if (ci.constantValue() instanceof Integer i) codeB.constantInstruction(i + 1);\n+                        else codeB.with(codeE);\n+                }\n+                default -> codeB.with(codeE);\n+            }\n+        }));\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile ExperimentalTransformExamples compilation.\n+ * @compile ExperimentalTransformExamples.java\n+ *\/\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+\n+\/**\n+ * ExperimentalTransformExamples\n+ *\n+ *\/\n+public class ExperimentalTransformExamples {\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+\n+    static MethodTransform dropMethodAnnos = (mb, me) -> {\n+        if (!(me instanceof RuntimeVisibleAnnotationsAttribute || me instanceof RuntimeInvisibleAnnotationsAttribute))\n+            mb.with(me);\n+    };\n+\n+    static FieldTransform dropFieldAnnos = (fb, fe) -> {\n+        if (!(fe instanceof RuntimeVisibleAnnotationsAttribute || fe instanceof RuntimeInvisibleAnnotationsAttribute))\n+            fb.with(fe);\n+    };\n+\n+    public byte[] deleteAnnotations(ClassModel cm) {\n+        return cm.transform((cb, ce) -> {\n+            switch (ce) {\n+                case MethodModel m -> cb.transformMethod(m, dropMethodAnnos);\n+                case FieldModel f -> cb.transformField(f, dropFieldAnnos);\n+                default -> cb.with(ce);\n+            }\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExperimentalTransformExamples.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile ModuleExamples compilation.\n+ * @compile ModuleExamples.java\n+ *\/\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleAttribute.ModuleAttributeBuilder;\n+import jdk.internal.classfile.attribute.ModuleMainClassAttribute;\n+import jdk.internal.classfile.attribute.ModulePackagesAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+\n+public class ModuleExamples {\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+\n+    public void examineModule() throws IOException {\n+        ClassModel cm = Classfile.parse(JRT.getPath(\"modules\/java.base\/module-info.class\"));\n+        System.out.println(\"Is JVMS $4.7 compatible module-info: \" + cm.isModuleInfo());\n+\n+        ModuleAttribute ma = cm.findAttribute(Attributes.MODULE).orElseThrow();\n+        System.out.println(\"Module name: \" + ma.moduleName().name().stringValue());\n+        System.out.println(\"Exports: \" + ma.exports());\n+\n+        ModuleMainClassAttribute mmca = cm.findAttribute(Attributes.MODULE_MAIN_CLASS).orElse(null);\n+        System.out.println(\"Does the module have a MainClassAttribte?: \" + (mmca != null));\n+\n+        ModulePackagesAttribute mmp = cm.findAttribute(Attributes.MODULE_PACKAGES).orElseThrow();\n+        System.out.println(\"Packages?: \" + mmp.packages());\n+    }\n+\n+    public void buildModuleFromScratch() {\n+        var moduleName = ModuleDesc.of(\"the.very.best.module\");\n+        int moduleFlags = 0;\n+\n+        Consumer<ModuleAttributeBuilder> handler = (mb -> {mb\n+                .moduleFlags(moduleFlags)\n+                .exports(PackageDesc.of(\"export.some.pkg\"), 0)\n+                .exports(PackageDesc.of(\"qualified.export.to\") , 0, ModuleDesc.of(\"to.first.module\"), ModuleDesc.of(\"to.another.module\"));\n+        });\n+\n+        \/\/ Build it\n+        byte[] moduleInfo = Classfile.buildModule(ModuleAttribute.of(moduleName, handler), List.of(), clb -> {\n+\n+                \/\/ Add an annotation to the module\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.ofDescriptor(\"Ljava\/lang\/Deprecated;\"),\n+                                                                          AnnotationElement.ofBoolean(\"forRemoval\", true),\n+                                                                          AnnotationElement.ofString(\"since\", \"17\"))));\n+        });\n+\n+        \/\/ Examine it\n+        ClassModel mm = Classfile.parse(moduleInfo);\n+        System.out.println(\"Is module info?: \" + mm.isModuleInfo());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ModuleExamples.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Testing Classfile TransformExamples compilation.\n+ * @compile TransformExamples.java\n+ *\/\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Attribute;\n+\n+\/**\n+ * TransformExamples\n+ *\/\n+public class TransformExamples {\n+    public byte[] noop(ClassModel cm) {\n+        return cm.transform(ClassTransform.ACCEPT_ALL);\n+    }\n+\n+    public byte[] deleteAllMethods(ClassModel cm) {\n+        return cm.transform((b, e) -> {\n+            if (!(e instanceof MethodModel))\n+                b.with(e);\n+        });\n+    }\n+\n+    public byte[] deleteFieldsWithDollarInName(ClassModel cm) {\n+        return cm.transform((b, e) ->\n+                        {\n+                            if (!(e instanceof FieldModel fm && fm.fieldName().stringValue().contains(\"$\")))\n+                                b.with(e);\n+                        });\n+    }\n+\n+    public byte[] deleteAttributes(ClassModel cm) {\n+        return cm.transform((b, e) -> {\n+            if (!(e instanceof Attribute))\n+                b.with(e);\n+        });\n+    }\n+\n+    public byte[] keepMethodsAndFields(ClassModel cm) {\n+        return cm.transform((b, e) -> {\n+            if (e instanceof MethodModel || e instanceof FieldModel)\n+                b.with(e);\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/examples\/TransformExamples.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public class ByteArrayClassLoader extends ClassLoader {\n+    final Map<String, ClassData> classNameToClass;\n+\n+    public ByteArrayClassLoader(ClassLoader parent, String name, byte[] bytes) {\n+        this(parent, Collections.singletonMap(name, new ClassData(name, bytes)));\n+    }\n+\n+    public ByteArrayClassLoader(ClassLoader parent, Map<String, ClassData> classNameToClass) {\n+        super(parent);\n+        this.classNameToClass = classNameToClass;\n+    }\n+\n+    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+        if (classNameToClass.containsKey(name)) {\n+            return findClass(name);\n+        }\n+        return super.loadClass(name, resolve);\n+    }\n+\n+    public Class<?> findClass(String name) throws ClassNotFoundException {\n+        ClassData d = classNameToClass.get(name);\n+        if (d != null) {\n+            if (d.klass != null) {\n+                return d.klass;\n+            }\n+            return d.klass = defineClass(name, d.bytes, 0, d.bytes.length);\n+        }\n+        return super.findClass(name);\n+    }\n+\n+    public void loadAll() throws Exception {\n+        for (String className : classNameToClass.keySet()) {\n+            loadClass(className);\n+        }\n+    }\n+\n+    public Method getMethod(String className, String methodName) throws Exception {\n+            for (Method m : loadClass(className).getDeclaredMethods()) {\n+            if (m.getName().equals(methodName)) {\n+                return m;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Method name '\" + methodName + \"' not found in '\" + className + \"'\");\n+    }\n+\n+    public static class ClassData {\n+        final String name;\n+        final byte[] bytes;\n+        Class<?> klass;\n+\n+        public ClassData(String name, byte[] bytes) {\n+            this.name = name;\n+            this.bytes = bytes;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ByteArrayClassLoader.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,1267 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.RecordComponent;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.*;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.internal.classfile.Classfile.*;\n+import static jdk.internal.classfile.Attributes.*;\n+import static helpers.ClassRecord.CompatibilityFilter.By_ClassBuilder;\n+\n+\/**\n+ * ClassRecord\n+ *\/\n+public record ClassRecord(\n+        int majorVersion,\n+        int minorVersion,\n+        String thisClass,\n+        String superClass,\n+        Set<String> interfaces,\n+        String classFlags,\n+        Map<String, FieldRecord> fields,\n+        Map<String, MethodRecord> methods,\n+        AttributesRecord attributes) {\n+\n+    public enum CompatibilityFilter {\n+        Read_all, By_ClassBuilder;\n+\n+        private <T> T isNotDirectlyComparable(CompatibilityFilter compatibilityFilter[], T value) {\n+            for (CompatibilityFilter p : compatibilityFilter) {\n+                if (p == this) return null;\n+            }\n+            return value;\n+        }\n+    }\n+\n+    public enum DefinedValue {\n+        DEFINED\n+    }\n+\n+    public static ClassRecord ofStreamingElements(ClassModel cl, CompatibilityFilter... compatibilityFilter) {\n+        return ofStreamingElements(\n+                cl.majorVersion(),\n+                cl.minorVersion(),\n+                cl.thisClass().asInternalName(),\n+                cl.superclass().map(ClassEntry::asInternalName).orElse(null),\n+                cl.interfaces().stream().map(ClassEntry::asInternalName).collect(toSet()),\n+                cl.flags().flagsMask(),\n+                cl.constantPool(),\n+                cl::elementStream, compatibilityFilter);\n+    }\n+    public static ClassRecord ofStreamingElements(int majorVersion, int minorVersion, String thisClass, String superClass, Set<String> interfaces, int flags, ConstantPool cp, Supplier<Stream<? extends ClassfileElement>> elements, CompatibilityFilter... compatibilityFilter) {\n+        return new ClassRecord(\n+                majorVersion,\n+                minorVersion,\n+                thisClass,\n+                superClass,\n+                interfaces,\n+                Flags.toString(flags, false),\n+                elements.get().filter(e -> e instanceof FieldModel).map(e -> (FieldModel)e).collect(toMap(\n+                        fm -> fm.fieldName().stringValue() + fm.fieldType().stringValue(),\n+                        fm -> FieldRecord.ofStreamingElements(fm.fieldName().stringValue(), fm.fieldType().stringValue(), fm.flags().flagsMask(), fm::elementStream, compatibilityFilter))),\n+                elements.get().filter(e -> e instanceof MethodModel).map(e -> (MethodModel)e).collect(toMap(\n+                        mm -> mm.methodName().stringValue() + mm.methodType().stringValue(),\n+                        mm -> MethodRecord.ofStreamingElements(mm.methodName().stringValue(), mm.methodType().stringValue(), mm.flags().flagsMask(), mm::elementStream, compatibilityFilter))),\n+                AttributesRecord.ofStreamingElements(elements, cp, compatibilityFilter));\n+    }\n+\n+    public static ClassRecord ofClassModel(ClassModel cl, CompatibilityFilter... compatibilityFilter) {\n+        return new ClassRecord(\n+                cl.majorVersion(),\n+                cl.minorVersion(),\n+                cl.thisClass().asInternalName(),\n+                cl.superclass().map(ClassEntry::asInternalName).orElse(null),\n+                cl.interfaces().stream().map(ci -> ci.asInternalName()).collect(toSet()),\n+                Flags.toString(cl.flags().flagsMask(), false),\n+                cl.fields().stream().collect(toMap(f -> f.fieldName().stringValue() + f.fieldType().stringValue(), f -> FieldRecord.ofFieldModel(f, compatibilityFilter))),\n+                cl.methods().stream().collect(toMap(m -> m.methodName().stringValue() + m.methodType().stringValue(), m -> MethodRecord.ofMethodModel(m, compatibilityFilter))),\n+                AttributesRecord.ofAttributes(cl::attributes, compatibilityFilter));\n+    }\n+\n+    public record FieldRecord(\n+            String fieldName,\n+            String fieldType,\n+            String fieldFlags,\n+            AttributesRecord fieldAttributes) {\n+\n+        public static FieldRecord ofStreamingElements(String fieldName, String fieldType, int flags, Supplier<Stream<? extends ClassfileElement>> elements, CompatibilityFilter... compatibilityFilter) {\n+            return new FieldRecord(\n+                    fieldName,\n+                    fieldType,\n+                    Flags.toString(flags, false),\n+                    AttributesRecord.ofStreamingElements(elements, null, compatibilityFilter));\n+        }\n+\n+        public static FieldRecord ofFieldModel(FieldModel f, CompatibilityFilter... compatibilityFilter) {\n+            return new FieldRecord(\n+                    f.fieldName().stringValue(),\n+                    f.fieldType().stringValue(),\n+                    Flags.toString(f.flags().flagsMask(), false),\n+                    AttributesRecord.ofAttributes(f::attributes, compatibilityFilter));\n+        }\n+    }\n+\n+    public record MethodRecord(\n+            String methodName,\n+            String methodType,\n+            String methodFlags,\n+            AttributesRecord methodAttributes) {\n+\n+        public static MethodRecord ofStreamingElements(String methodName, String methodType, int flags, Supplier<Stream<? extends ClassfileElement>> elements, CompatibilityFilter... compatibilityFilter) {\n+            return new MethodRecord(\n+                    methodName,\n+                    methodType,\n+                    Flags.toString(flags, true),\n+                    AttributesRecord.ofStreamingElements(elements, null, compatibilityFilter));\n+        }\n+\n+        public static MethodRecord ofMethodModel(MethodModel m, CompatibilityFilter... compatibilityFilter) {\n+            return new MethodRecord(\n+                    m.methodName().stringValue(),\n+                    m.methodType().stringValue(),\n+                    Flags.toString(m.flags().flagsMask(), true),\n+                    AttributesRecord.ofAttributes(m::attributes, compatibilityFilter));\n+        }\n+    }\n+\n+    private static<T extends Attribute<T>, U> U mapAttr(Map<String, Attribute<?>> attrs, AttributeMapper<T> mapper, Function<T, U> f) {\n+        return mapAttr(attrs, mapper, f, null);\n+    }\n+\n+    private static<T extends Attribute<T>, U> U mapAttr(Map<String, Attribute<?>> attrs, AttributeMapper<T> mapper, Function<T, U> f, U defaultReturn) {\n+        @SuppressWarnings(\"unchecked\")\n+        var attr = (T) attrs.get(mapper.name());\n+        return map(attr, a -> f.apply(a), defaultReturn);\n+    }\n+\n+    interface AttributeFinder extends Supplier<List<Attribute<?>>> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default <T extends Attribute<T>, R> R findAndMap(AttributeMapper<T> m, Function<T, R> mapping) {\n+            for (Attribute<?> a : get()) {\n+                if (a.attributeMapper() == m) {\n+                    return mapping.apply((T) a);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default <T extends Attribute<T>> Stream<T> findAll(AttributeMapper<T> m) {\n+            return get().stream().filter(a -> a.attributeMapper() == m).map(a -> (T)a);\n+        }\n+    }\n+\n+    public static <T> Collector<T,?,Set<T>> toSetOrNull() {\n+        return Collectors.collectingAndThen(Collectors.toSet(), (Set<T> s) -> s.isEmpty() ? null : s);\n+    }\n+\n+    public record AttributesRecord(\n+            ElementValueRecord annotationDefaultAttribute,\n+            Set<BootstrapMethodRecord> bootstrapMethodsAttribute,\n+            CodeRecord codeAttribute,\n+            String compilationIDAttribute,\n+            ConstantPoolEntryRecord constantValueAttribute,\n+            DefinedValue deprecated,\n+            EnclosingMethodRecord enclosingMethodAttribute,\n+            Set<String> exceptionsAttribute,\n+            Map<String, InnerClassRecord> innerClassesAttribute,\n+            List<MethodParameterRecord> methodParametersAttribute,\n+            ModuleRecord moduleAttribute,\n+            ModuleHashesRecord moduleHashesAttribute,\n+            String moduleMainClassAttribute,\n+            Set<String> modulePackagesAttribute,\n+            Integer moduleResolutionAttribute,\n+            String moduleTargetAttribute,\n+            String nestHostAttribute,\n+            Set<String> nestMembersAttribute,\n+            Set<String> permittedSubclassesAttribute,\n+            List<RecordComponentRecord> recordAttribute,\n+            Set<AnnotationRecord> runtimeVisibleAnnotationsAttribute,\n+            Set<AnnotationRecord> runtimeInvisibleAnnotationsAttribute,\n+            List<Set<AnnotationRecord>> runtimeVisibleParameterAnnotationsAttribute,\n+            List<Set<AnnotationRecord>> runtimeInvisibleParameterAnnotationsAttribute,\n+            Set<TypeAnnotationRecord> runtimeVisibleTypeAnnotationsAttribute,\n+            Set<TypeAnnotationRecord> runtimeInvisibleTypeAnnotationsAttribute,\n+            String signatureAttribute,\n+            String sourceDebugExtensionAttribute,\n+            String sourceFileAttribute,\n+            String sourceIDAttribute,\n+            DefinedValue syntheticAttribute) {\n+\n+        public static AttributesRecord ofStreamingElements(Supplier<Stream<? extends ClassfileElement>> elements, ConstantPool cp, CompatibilityFilter... cf) {\n+            Map<String, Attribute<?>> attrs = elements.get().filter(e -> e instanceof Attribute<?>)\n+                    .map(e -> (Attribute<?>) e)\n+                    .collect(toMap(Attribute::attributeName, e -> e));\n+            return new AttributesRecord(\n+                    mapAttr(attrs, ANNOTATION_DEFAULT, a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n+                    cp == null ? null : IntStream.range(0, cp.bootstrapMethodCount()).mapToObj(i -> BootstrapMethodRecord.ofBootstrapMethodEntry(cp.bootstrapMethodEntry(i))).collect(toSetOrNull()),\n+                    mapAttr(attrs, CODE, a -> CodeRecord.ofStreamingElements(a.maxStack(), a.maxLocals(), a.codeLength(), a::elementStream, a, new CodeNormalizerHelper(a.codeArray()), cf)),\n+                    mapAttr(attrs, COMPILATION_ID, a -> a.compilationId().stringValue()),\n+                    mapAttr(attrs, CONSTANT_VALUE, a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n+                    mapAttr(attrs, DEPRECATED, a -> DefinedValue.DEFINED),\n+                    mapAttr(attrs, ENCLOSING_METHOD, a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n+                    mapAttr(attrs, EXCEPTIONS, a -> new HashSet<>(a.exceptions().stream().map(e -> e.asInternalName()).toList())),\n+                    mapAttr(attrs, INNER_CLASSES, a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n+                    mapAttr(attrs, METHOD_PARAMETERS, a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n+                    mapAttr(attrs, MODULE, a -> ModuleRecord.ofModuleAttribute(a)),\n+                    mapAttr(attrs, MODULE_HASHES, a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n+                    mapAttr(attrs, MODULE_MAIN_CLASS, a -> a.mainClass().asInternalName()),\n+                    mapAttr(attrs, MODULE_PACKAGES, a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n+                    mapAttr(attrs, MODULE_RESOLUTION, a -> a.resolutionFlags()),\n+                    mapAttr(attrs, MODULE_TARGET, a -> a.targetPlatform().stringValue()),\n+                    mapAttr(attrs, NEST_HOST, a -> a.nestHost().asInternalName()),\n+                    mapAttr(attrs, NEST_MEMBERS, a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n+                    mapAttr(attrs, PERMITTED_SUBCLASSES, a -> new HashSet<>(a.permittedSubclasses().stream().map(e -> e.asInternalName()).toList())),\n+                    mapAttr(attrs, RECORD, a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n+                    elements.get().filter(e -> e instanceof RuntimeVisibleAnnotationsAttribute).map(e -> (RuntimeVisibleAnnotationsAttribute) e).flatMap(a -> a.annotations().stream())\n+                            .map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    elements.get().filter(e -> e instanceof RuntimeInvisibleAnnotationsAttribute).map(e -> (RuntimeInvisibleAnnotationsAttribute) e).flatMap(a -> a.annotations().stream())\n+                            .map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    mapAttr(attrs, RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    mapAttr(attrs, RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    mapAttr(attrs, RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    mapAttr(attrs, RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    mapAttr(attrs, SIGNATURE, a -> a.signature().stringValue()),\n+                    mapAttr(attrs, SOURCE_DEBUG_EXTENSION, a -> new String(a.contents(), StandardCharsets.UTF_8)),\n+                    mapAttr(attrs, SOURCE_FILE, a -> a.sourceFile().stringValue()),\n+                    mapAttr(attrs, SOURCE_ID, a -> a.sourceId().stringValue()),\n+                    mapAttr(attrs, SYNTHETIC, a -> DefinedValue.DEFINED)\n+            );\n+        }\n+\n+        public static AttributesRecord ofAttributes(AttributeFinder af, CompatibilityFilter... cf) {\n+            return new AttributesRecord(\n+                    af.findAndMap(Attributes.ANNOTATION_DEFAULT, a -> ElementValueRecord.ofElementValue(a.defaultValue())),\n+                    af.findAndMap(Attributes.BOOTSTRAP_METHODS, a -> a.bootstrapMethods().stream().map(bm -> BootstrapMethodRecord.ofBootstrapMethodEntry(bm)).collect(toSet())),\n+                    af.findAndMap(Attributes.CODE, a -> CodeRecord.ofCodeAttribute(a, cf)),\n+                    af.findAndMap(Attributes.COMPILATION_ID, a -> a.compilationId().stringValue()),\n+                    af.findAndMap(Attributes.CONSTANT_VALUE, a -> ConstantPoolEntryRecord.ofCPEntry(a.constant())),\n+                    af.findAndMap(Attributes.DEPRECATED, a -> DefinedValue.DEFINED),\n+                    af.findAndMap(Attributes.ENCLOSING_METHOD, a -> EnclosingMethodRecord.ofEnclosingMethodAttribute(a)),\n+                    af.findAndMap(Attributes.EXCEPTIONS, a -> a.exceptions().stream().map(e -> e.asInternalName()).collect(toSet())),\n+                    af.findAndMap(Attributes.INNER_CLASSES, a -> a.classes().stream().collect(toMap(ic -> ic.innerClass().asInternalName(), ic -> InnerClassRecord.ofInnerClassInfo(ic)))),\n+                    af.findAndMap(Attributes.METHOD_PARAMETERS, a -> a.parameters().stream().map(mp -> MethodParameterRecord.ofMethodParameter(mp)).toList()),\n+                    af.findAndMap(Attributes.MODULE, a -> ModuleRecord.ofModuleAttribute(a)),\n+                    af.findAndMap(Attributes.MODULE_HASHES, a -> ModuleHashesRecord.ofModuleHashesAttribute(a)),\n+                    af.findAndMap(Attributes.MODULE_MAIN_CLASS, a -> a.mainClass().asInternalName()),\n+                    af.findAndMap(Attributes.MODULE_PACKAGES, a -> a.packages().stream().map(p -> p.name().stringValue()).collect(toSet())),\n+                    af.findAndMap(Attributes.MODULE_RESOLUTION, a -> a.resolutionFlags()),\n+                    af.findAndMap(Attributes.MODULE_TARGET, a -> a.targetPlatform().stringValue()),\n+                    af.findAndMap(Attributes.NEST_HOST, a -> a.nestHost().asInternalName()),\n+                    af.findAndMap(Attributes.NEST_MEMBERS, a -> a.nestMembers().stream().map(m -> m.asInternalName()).collect(toSet())),\n+                    af.findAndMap(Attributes.PERMITTED_SUBCLASSES, a -> a.permittedSubclasses().stream().map(e -> e.asInternalName()).collect(toSet())),\n+                    af.findAndMap(RECORD, a -> a.components().stream().map(rc -> RecordComponentRecord.ofRecordComponent(rc, cf)).toList()),\n+                    af.findAll(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    af.findAll(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).flatMap(a -> a.annotations().stream()).map(AnnotationRecord::ofAnnotation).collect(toSetOrNull()),\n+                    af.findAndMap(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, a -> a.parameterAnnotations().stream().map(list -> list.stream().map(AnnotationRecord::ofAnnotation).collect(toSet())).toList()),\n+                    af.findAndMap(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(TypeAnnotationRecord::ofTypeAnnotation).collect(toSet())),\n+                    af.findAndMap(Attributes.SIGNATURE, a -> a.signature().stringValue()),\n+                    af.findAndMap(Attributes.SOURCE_DEBUG_EXTENSION, a -> new String(a.contents(), StandardCharsets.UTF_8)),\n+                    af.findAndMap(Attributes.SOURCE_FILE, a -> a.sourceFile().stringValue()),\n+                    af.findAndMap(Attributes.SOURCE_ID, a -> a.sourceId().stringValue()),\n+                    af.findAndMap(Attributes.SYNTHETIC, a -> DefinedValue.DEFINED));\n+        }\n+    }\n+\n+    public record CodeAttributesRecord(\n+            Set<CharacterRangeRecord> characterRangeTableAttribute,\n+            Set<LineNumberRecord> lineNumbersTableAttribute,\n+            Set<LocalVariableRecord> localVariableTableAttribute,\n+            Set<LocalVariableTypeRecord> localVariableTypeTableAttribute,\n+            Set<TypeAnnotationRecord> runtimeVisibleTypeAnnotationsAttribute,\n+            Set<TypeAnnotationRecord> runtimeInvisibleTypeAnnotationsAttribute) {\n+\n+        static CodeAttributesRecord ofStreamingElements(Supplier<Stream<? extends ClassfileElement>> elements, CodeAttribute lc, CodeNormalizerHelper code, CompatibilityFilter... cf) {\n+            int[] p = {0};\n+            var characterRanges = new HashSet<CharacterRangeRecord>();\n+            var lineNumbers = new HashSet<LineNumberRecord>();\n+            var localVariables = new HashSet<LocalVariableRecord>();\n+            var localVariableTypes = new HashSet<LocalVariableTypeRecord>();\n+            var visibleTypeAnnos = new HashSet<TypeAnnotationRecord>();\n+            var invisibleTypeAnnos = new HashSet<TypeAnnotationRecord>();\n+            elements.get().forEach(e -> {\n+                switch (e) {\n+                    case Instruction ins -> p[0] += ins.sizeInBytes();\n+                    case CharacterRange cr -> characterRanges.add(CharacterRangeRecord.ofCharacterRange(cr, lc, code));\n+                    case LineNumber ln -> lineNumbers.add(new LineNumberRecord(ln.line(), code.targetIndex(p[0])));\n+                    case LocalVariable lv -> localVariables.add(LocalVariableRecord.ofLocalVariable(lv, lc, code));\n+                    case LocalVariableType lvt -> localVariableTypes.add(LocalVariableTypeRecord.ofLocalVariableType(lvt, lc, code));\n+                    case RuntimeVisibleTypeAnnotationsAttribute taa -> taa.annotations().forEach(ann -> visibleTypeAnnos.add(TypeAnnotationRecord.ofTypeAnnotation(ann, lc, code)));\n+                    case RuntimeInvisibleTypeAnnotationsAttribute taa -> taa.annotations().forEach(ann -> invisibleTypeAnnos.add(TypeAnnotationRecord.ofTypeAnnotation(ann, lc, code)));\n+                    default -> {}\n+                }});\n+            return new CodeAttributesRecord(\n+                    characterRanges.isEmpty() ? null : characterRanges,\n+                    lineNumbers.isEmpty() ? null : lineNumbers,\n+                    localVariables.isEmpty() ? null : localVariables,\n+                    localVariableTypes.isEmpty() ? null : localVariableTypes,\n+                    visibleTypeAnnos.isEmpty() ? null : visibleTypeAnnos,\n+                    invisibleTypeAnnos.isEmpty() ? null : invisibleTypeAnnos);\n+        }\n+\n+        static CodeAttributesRecord ofAttributes(AttributeFinder af, CodeNormalizerHelper code, CodeAttribute lr, CompatibilityFilter... cf) {\n+            return new CodeAttributesRecord(\n+                    af.findAll(Attributes.CHARACTER_RANGE_TABLE).flatMap(a -> a.characterRangeTable().stream()).map(cr -> CharacterRangeRecord.ofCharacterRange(cr, code)).collect(toSetOrNull()),\n+                    af.findAll(Attributes.LINE_NUMBER_TABLE).flatMap(a -> a.lineNumbers().stream()).map(ln -> new LineNumberRecord(ln.lineNumber(), code.targetIndex(ln.startPc()))).collect(toSetOrNull()),\n+                    af.findAll(Attributes.LOCAL_VARIABLE_TABLE).flatMap(a -> a.localVariables().stream()).map(lv -> LocalVariableRecord.ofLocalVariableInfo(lv, code)).collect(toSetOrNull()),\n+                    af.findAll(Attributes.LOCAL_VARIABLE_TYPE_TABLE).flatMap(a -> a.localVariableTypes().stream()).map(lv -> LocalVariableTypeRecord.ofLocalVariableTypeInfo(lv, code)).collect(toSetOrNull()),\n+                    af.findAndMap(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())),\n+                    af.findAndMap(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS, a -> a.annotations().stream().map(ann -> TypeAnnotationRecord.ofTypeAnnotation(ann, lr, code)).collect(toSet())));\n+        }\n+    }\n+\n+    public record AnnotationRecord(\n+            String type,\n+            Map<String, ElementValueRecord> elementValues) {\n+\n+        public static AnnotationRecord ofAnnotation(Annotation ann) {\n+            return new AnnotationRecord(\n+                    ann.className().stringValue(),\n+                    ann.elements().stream().collect(toMap(evp -> evp.name().stringValue(), evp -> ElementValueRecord.ofElementValue(evp.value()))));\n+        }\n+    }\n+\n+    public record BootstrapMethodRecord(\n+            ConstantPoolEntryRecord methodHandle,\n+            List<ConstantPoolEntryRecord> arguments) {\n+\n+        public static BootstrapMethodRecord ofBootstrapMethodEntry(BootstrapMethodEntry bm) {\n+            return new BootstrapMethodRecord(\n+                    ConstantPoolEntryRecord.ofCPEntry(bm.bootstrapMethod()),\n+                    bm.arguments().stream().map(arg -> ConstantPoolEntryRecord.ofCPEntry(arg)).toList());\n+        }\n+    }\n+\n+    public record CharacterRangeRecord(\n+            int startIndex,\n+            int endIndex,\n+            int characterRangeStart,\n+            int characterRangeEnd,\n+            int flags) {\n+\n+        public static CharacterRangeRecord ofCharacterRange(CharacterRange cr, CodeAttribute lc, CodeNormalizerHelper code) {\n+            return new CharacterRangeRecord(code.targetIndex(lc.labelToBci(cr.startScope())), code.targetIndex(lc.labelToBci(cr.endScope())), cr.characterRangeStart(), cr.characterRangeEnd(), cr.flags());\n+        }\n+\n+        public static CharacterRangeRecord ofCharacterRange(CharacterRangeInfo cr, CodeNormalizerHelper code) {\n+            return new CharacterRangeRecord(\n+                    code.targetIndex(cr.startPc()),\n+                    code.targetIndex(cr.endPc() + 1), cr.characterRangeStart(), cr.characterRangeEnd(), cr.flags());\n+        }\n+    }\n+\n+    private static String opcodeMask(String opcode) {\n+        return switch (opcode) {\n+            case \"BIPUSH\", \"SIPUSH\" -> \"IPUSH\";\n+            case \"ICONST_M1\" -> \"IPUSH#fff\";\n+            case \"ICONST_0\" -> \"IPUSH#0\";\n+            case \"ICONST_1\" -> \"IPUSH#1\";\n+            case \"ICONST_2\" -> \"IPUSH#2\";\n+            case \"ICONST_3\" -> \"IPUSH#3\";\n+            case \"ICONST_4\" -> \"IPUSH#4\";\n+            case \"ICONST_5\" -> \"IPUSH#5\";\n+            case \"MULTIANEWARRAY\" -> \"NEWARRAY\";\n+            case \"ANEWARRAY\" -> \"NEWARRAY\";\n+            default -> {\n+                if (opcode.endsWith(\"_W\")) {\n+                    yield opcode.substring(0, opcode.length() - 2);\n+                } else if (opcode.contains(\"LOAD_\") || opcode.contains(\"STORE_\")) {\n+                    yield opcode.replace('_', '#');\n+                } else {\n+                    yield opcode;\n+                }\n+            }\n+        };\n+    }\n+\n+    private static final class CodeNormalizerHelper {\n+\n+        private static final byte[] LENGTHS = new byte[] {\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 3, 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 | (6 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 | (4 << 4), 0, 0, 1, 1, 1,\n+            1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 4, 4, 4, 2, 4, 3, 3, 0, 0, 1, 3, 2, 3, 3, 3, 1, 2, 1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n+        };\n+\n+        private static int instrLen(byte[] code, int pc) {\n+            int op = code[pc] & 0xff;\n+            int aligned = (pc + 4) & ~3;\n+            int len = switch (op) {\n+                case WIDE -> LENGTHS[code[pc + 1] & 0xff] >> 4;\n+                case TABLESWITCH -> aligned - pc + (3 + getInt(code, aligned + 2 * 4) - getInt(code, aligned + 1 * 4) + 1) * 4;\n+                case LOOKUPSWITCH -> aligned - pc + (2 + 2 * getInt(code, aligned + 4)) * 4;\n+                default -> LENGTHS[op] & 0xf;\n+            };\n+            if (len < 1) throw new AssertionError(pc +\": \" + op);\n+            return len;\n+        }\n+\n+        private static int getInt(byte[] bytes, int off) {\n+            return bytes[off] << 24 | (bytes[off + 1] & 0xFF) << 16 | (bytes[off + 2] & 0xFF) << 8 | (bytes[off + 3] & 0xFF);\n+        }\n+\n+\n+        private final int[] codeToIndexMap;\n+\n+        CodeNormalizerHelper(byte[] code) {\n+            this.codeToIndexMap = new int[code.length + 1];\n+            for (int pc = 1; pc < code.length; pc++) codeToIndexMap[pc] = -pc;\n+            int index = 0;\n+            for (int pc = 0; pc < code.length; pc += instrLen(code, pc)) {\n+                codeToIndexMap[pc] = index++;\n+            }\n+            codeToIndexMap[code.length] = index;\n+        }\n+\n+        int targetIndex(int pc) {\n+            if (pc < 0) return pc;\n+            if (pc > codeToIndexMap.length) return -pc;\n+            return codeToIndexMap[pc];\n+        }\n+\n+        int multipleTargetsHash(int pc, int firstOffset, int[] otherOffsets, int... otherHashes) {\n+            int hash = targetIndex(pc + firstOffset);\n+            for (var off : otherOffsets) {\n+                hash = 31*hash + targetIndex(pc + off);\n+            }\n+            for (var other : otherHashes) {\n+                hash = 31*hash + other;\n+            }\n+            return hash;\n+        }\n+\n+        int hash(int from, int length) {\n+            int result = 1;\n+            for (int i = from; i < length; i++) {\n+                int elementHash = (codeToIndexMap[i] ^ (codeToIndexMap[i] >>> 32));\n+                result = 31 * result + elementHash;\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public record CodeRecord(\n+            Integer maxStack,\n+            Integer maxLocals,\n+            Integer  codeLength,\n+            List<String> instructionsSequence,\n+            Set<ExceptionHandlerRecord> exceptionHandlers,\n+            CodeAttributesRecord codeAttributes) {\n+\n+        private static List<String> instructions(Supplier<Stream<? extends ClassfileElement>> elements, CodeNormalizerHelper code, CodeAttribute lr) {\n+            int[] p = {0};\n+            return elements.get().filter(e -> e instanceof Instruction).map(e -> {\n+                var ins = (Instruction)e;\n+                String opCode = opcodeMask(ins.opcode().name());\n+                Integer hash = switch (ins) {\n+                    case FieldInstruction cins ->\n+                        ConstantPoolEntryRecord.ofCPEntry(cins.field()).hashCode();\n+                    case InvokeInstruction cins ->\n+                        ConstantPoolEntryRecord.ofCPEntry(cins.method()).hashCode();\n+                    case NewObjectInstruction cins ->\n+                        ConstantPoolEntryRecord.ofCPEntry(cins.className()).hashCode();\n+                    case NewReferenceArrayInstruction cins -> {\n+                        String type = cins.componentType().asInternalName();\n+                        if (!type.startsWith(\"[\"))\n+                            type = \"L\" + type + \";\";\n+                        yield new ConstantPoolEntryRecord.CpClassRecord(\"[\" + type).hashCode() + 1;\n+                    }\n+                    case NewPrimitiveArrayInstruction cins ->\n+                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().descriptor()).hashCode() + 1;\n+                    case TypeCheckInstruction cins ->\n+                        ConstantPoolEntryRecord.ofCPEntry(cins.type()).hashCode();\n+                    case ConstantInstruction.LoadConstantInstruction cins -> {\n+                        var cper = ConstantPoolEntryRecord.ofCPEntry(cins.constantEntry());\n+                        String altOpcode = cper.altOpcode();\n+                        if (altOpcode != null) {\n+                            opCode = altOpcode;\n+                            yield null;\n+                        }\n+                        else {\n+                            yield cper.hashCode();\n+                        }\n+                    }\n+                    case InvokeDynamicInstruction cins ->\n+                        ConstantPoolEntryRecord.ofCPEntry(cins.invokedynamic()).hashCode();\n+                    case NewMultiArrayInstruction cins ->\n+                            ConstantPoolEntryRecord.ofCPEntry(cins.arrayType()).hashCode() + cins.dimensions();\n+                    case BranchInstruction cins ->\n+                        code.targetIndex(lr.labelToBci(cins.target()));\n+                    case LookupSwitchInstruction cins ->\n+                        code.multipleTargetsHash(p[0], lr.labelToBci(cins.defaultTarget()) - p[0], cins.cases().stream().mapToInt(sc -> lr.labelToBci(sc.target()) - p[0]).toArray(), cins.cases().stream().mapToInt(SwitchCase::caseValue).toArray());\n+                    case TableSwitchInstruction cins ->\n+                        code.multipleTargetsHash(p[0], lr.labelToBci(cins.defaultTarget()) - p[0], cins.cases().stream().mapToInt(sc -> lr.labelToBci(sc.target()) - p[0]).toArray(), cins.lowValue(), cins.highValue());\n+                    case ConstantInstruction.ArgumentConstantInstruction cins ->\n+                        cins.constantValue();\n+                    default -> {\n+                        if (ins.sizeInBytes() <= 1) {\n+                            yield null;\n+                        }\n+                        else if ((ins instanceof LoadInstruction local)) {\n+                            yield local.slot();\n+                        }\n+                        else if ((ins instanceof StoreInstruction local)) {\n+                            yield local.slot();\n+                        }\n+                        else {\n+                            yield code.hash(p[0] + 1, ins.sizeInBytes());\n+                        }\n+                    }\n+                };\n+                p[0] += ins.sizeInBytes();\n+                return opCode + (hash != null ? '#' + Integer.toHexString(hash & 0xfff) : \"\");\n+            }).toList();\n+        }\n+\n+        public static CodeRecord ofStreamingElements(int maxStack, int maxLocals, int codeLength, Supplier<Stream<? extends ClassfileElement>> elements, CodeAttribute lc, CodeNormalizerHelper codeHelper, CompatibilityFilter... cf) {\n+            return new CodeRecord(\n+                    By_ClassBuilder.isNotDirectlyComparable(cf, maxStack),\n+                    By_ClassBuilder.isNotDirectlyComparable(cf, maxLocals),\n+                    By_ClassBuilder.isNotDirectlyComparable(cf, codeLength),\n+                    instructions(elements, codeHelper, lc),\n+                    elements.get().filter(e -> e instanceof ExceptionCatch).map(eh -> ExceptionHandlerRecord.ofExceptionCatch((ExceptionCatch)eh, codeHelper, lc)).collect(toSet()),\n+                    CodeAttributesRecord.ofStreamingElements(elements, lc, codeHelper, cf));\n+        }\n+\n+        public static CodeRecord ofCodeAttribute(CodeAttribute a, CompatibilityFilter... cf) {\n+            var codeHelper = new CodeNormalizerHelper(a.codeArray());\n+            return new CodeRecord(\n+                    By_ClassBuilder.isNotDirectlyComparable(cf, a.maxStack()),\n+                    By_ClassBuilder.isNotDirectlyComparable(cf, a.maxLocals()),\n+                    By_ClassBuilder.isNotDirectlyComparable(cf, a.codeLength()),\n+                    instructions(a::elementStream, codeHelper, a),\n+                    a.exceptionHandlers().stream().map(eh -> ExceptionHandlerRecord.ofExceptionCatch(eh, codeHelper, a)).collect(toSet()),\n+                    CodeAttributesRecord.ofAttributes(a::attributes, codeHelper, a, cf));\n+        }\n+\n+        public record ExceptionHandlerRecord(\n+                int startIndex,\n+                int endIndex,\n+                int handlerIndex,\n+                ConstantPoolEntryRecord catchType) {\n+\n+            public static ExceptionHandlerRecord ofExceptionCatch(ExceptionCatch et, CodeNormalizerHelper code, CodeAttribute labelContext) {\n+                return new ExceptionHandlerRecord(\n+                        code.targetIndex(labelContext.labelToBci(et.tryStart())),\n+                        code.targetIndex(labelContext.labelToBci(et.tryEnd())),\n+                        code.targetIndex(labelContext.labelToBci(et.handler())),\n+                        et.catchType().map(ct -> ConstantPoolEntryRecord.ofCPEntry(ct)).orElse(null));\n+            }\n+        }\n+    }\n+\n+    public record EnclosingMethodRecord(\n+            String className,\n+            ConstantPoolEntryRecord method) {\n+\n+        public static EnclosingMethodRecord ofEnclosingMethodAttribute(EnclosingMethodAttribute ema) {\n+            return new EnclosingMethodRecord(\n+                    ema.enclosingClass().asInternalName(),\n+                    ema.enclosingMethod().map(m -> ConstantPoolEntryRecord.ofCPEntry(m)).orElse(null));\n+        }\n+    }\n+\n+    public record InnerClassRecord(\n+            String innerClass,\n+            String innerName,\n+            String outerClass,\n+            String accessFlags) {\n+\n+        public static InnerClassRecord ofInnerClassInfo(InnerClassInfo ic) {\n+            return new InnerClassRecord(\n+                    ic.innerClass().asInternalName(),\n+                    ic.innerName().map(Utf8Entry::stringValue).orElse(null),\n+                    ic.outerClass().map(ClassEntry::asInternalName).orElse(null),\n+                    Flags.toString(ic.flagsMask(), false));\n+        }\n+    }\n+\n+    public record LineNumberRecord(\n+            int lineNumber,\n+            int startIndex) {}\n+\n+    public record LocalVariableRecord(\n+            int startIndex,\n+            int endIndex,\n+            String name,\n+            String descriptor,\n+            int slot) {\n+\n+        public static LocalVariableRecord ofLocalVariable(LocalVariable lv, CodeAttribute lc, CodeNormalizerHelper code) {\n+            return new LocalVariableRecord(\n+                    code.targetIndex(lc.labelToBci(lv.startScope())),\n+                    code.targetIndex(lc.labelToBci(lv.endScope())),\n+                    lv.name().stringValue(),\n+                    lv.type().stringValue(),\n+                    lv.slot());\n+        }\n+\n+        public static LocalVariableRecord ofLocalVariableInfo(LocalVariableInfo lv, CodeNormalizerHelper code) {\n+            return new LocalVariableRecord(\n+                    code.targetIndex(lv.startPc()),\n+                    code.targetIndex(lv.startPc() + lv.length()),\n+                    lv.name().stringValue(),\n+                    lv.type().stringValue(),\n+                    lv.slot());\n+        }\n+    }\n+\n+    public record LocalVariableTypeRecord(\n+            int startIndex,\n+            int endIndex,\n+            String name,\n+            String signature,\n+            int index) {\n+\n+        public static LocalVariableTypeRecord ofLocalVariableType(LocalVariableType lvt, CodeAttribute lc, CodeNormalizerHelper code) {\n+            return new LocalVariableTypeRecord(\n+                    code.targetIndex(lc.labelToBci(lvt.startScope())),\n+                    code.targetIndex(lc.labelToBci(lvt.endScope())),\n+                    lvt.name().stringValue(),\n+                    lvt.signature().stringValue(),\n+                    lvt.slot());\n+        }\n+\n+        public static LocalVariableTypeRecord ofLocalVariableTypeInfo(LocalVariableTypeInfo lvt, CodeNormalizerHelper code) {\n+            return new LocalVariableTypeRecord(\n+                    code.targetIndex(lvt.startPc()),\n+                    code.targetIndex(lvt.startPc() + lvt.length()),\n+                    lvt.name().stringValue(),\n+                    lvt.signature().stringValue(),\n+                    lvt.slot());\n+        }\n+    }\n+\n+    public record MethodParameterRecord(\n+            String name,\n+            int accessFlags) {\n+\n+        public static MethodParameterRecord ofMethodParameter(MethodParameterInfo mp) {\n+            return new MethodParameterRecord(mp.name().map(Utf8Entry::stringValue).orElse(null), mp.flagsMask());\n+        }\n+    }\n+\n+    public record ModuleRecord(\n+            String moduleName,\n+            int moduleFlags,\n+            String moduleVersion,\n+            Set<RequiresRecord> requires,\n+            Set<ExportsRecord> exports,\n+            Set<OpensRecord> opens,\n+            Set<String> uses,\n+            Set<ProvidesRecord> provides) {\n+\n+        public static ModuleRecord ofModuleAttribute(ModuleAttribute m) {\n+            return new ModuleRecord(\n+                    m.moduleName().name().stringValue(),\n+                    m.moduleFlagsMask(),\n+                    m.moduleVersion().map(mv -> mv.stringValue()).orElse(null),\n+                    m.requires().stream().map(r -> RequiresRecord.ofRequire(r)).collect(toSet()),\n+                    m.exports().stream().map(e -> ExportsRecord.ofExport(e)).collect(toSet()),\n+                    m.opens().stream().map(o -> OpensRecord.ofOpen(o)).collect(toSet()),\n+                    m.uses().stream().map(u -> u.asInternalName()).collect(toSet()),\n+                    m.provides().stream().map(p -> ProvidesRecord.ofProvide(p)).collect(toSet()));\n+        }\n+\n+        public record RequiresRecord(\n+                String requires,\n+                int requiresFlags,\n+                String requiresVersion) {\n+\n+            public static RequiresRecord ofRequire(ModuleRequireInfo r) {\n+                return new RequiresRecord(r.requires().name().stringValue(), r.requiresFlagsMask(), r.requiresVersion().map(v -> v.stringValue()).orElse(null));\n+            }\n+        }\n+\n+        public record ExportsRecord(\n+                String exports,\n+                int exportFlag,\n+                Set<String> exportsTo) {\n+\n+            public static ExportsRecord ofExport(ModuleExportInfo e) {\n+                return new ExportsRecord(\n+                        e.exportedPackage().name().stringValue(),\n+                        e.exportsFlagsMask(),\n+                        e.exportsTo().stream().map(to -> to.name().stringValue()).collect(toSet()));\n+            }\n+        }\n+\n+        public record OpensRecord(\n+                String opens,\n+                int opensFlag,\n+                Set<String> opensTo) {\n+\n+            public static OpensRecord ofOpen(ModuleOpenInfo o) {\n+                return new OpensRecord(\n+                        o.openedPackage().name().stringValue(),\n+                        o.opensFlagsMask(),\n+                        o.opensTo().stream().map(to -> to.name().stringValue()).collect(toSet()));\n+            }\n+        }\n+\n+        public record ProvidesRecord(\n+                String provides,\n+                Set<String> providesWith) {\n+\n+            public static ProvidesRecord ofProvide(ModuleProvideInfo p) {\n+                return new ProvidesRecord(\n+                        p.provides().asInternalName(),\n+                        p.providesWith().stream().map(w -> w.asInternalName()).collect(toSet()));\n+            }\n+        }\n+\n+    }\n+\n+    public record ModuleHashesRecord(\n+            String algorithm,\n+            Map<String, String> hashes) {\n+\n+        public static ModuleHashesRecord ofModuleHashesAttribute(ModuleHashesAttribute mh) {\n+            return new ModuleHashesRecord(\n+                    mh.algorithm().stringValue(),\n+                    mh.hashes().stream().collect(toMap(e -> e.moduleName().name().stringValue(), e -> new BigInteger(1, e.hash()).toString(16))));\n+        }\n+    }\n+\n+    public record RecordComponentRecord(\n+            String name,\n+            String descriptor,\n+            AttributesRecord attributes) {\n+\n+        public static RecordComponentRecord ofRecordComponent(RecordComponentInfo rc, CompatibilityFilter... compatibilityFilter) {\n+            return new RecordComponentRecord(rc.name().stringValue(), rc.descriptor().stringValue(),\n+                                             AttributesRecord.ofAttributes(rc::attributes, compatibilityFilter));\n+        }\n+    }\n+\n+    public enum FrameTypeEnum {\n+        SAME(0, 63),\n+        SAME_LOCALS_1_STACK_ITEM(64, 127),\n+        RESERVED_FOR_FUTURE_USE(128, 246),\n+        SAME_LOCALS_1_STACK_ITEM_EXTENDED(247, 247),\n+        CHOP(248, 250),\n+        SAME_FRAME_EXTENDED(251, 251),\n+        APPEND(252, 254),\n+        FULL_FRAME(255, 255);\n+\n+        int start;\n+        int end;\n+\n+        public static FrameTypeEnum of(int frameType) {\n+            for (var e : FrameTypeEnum.values()) {\n+                if (e.start <= frameType && e.end >= frameType) return e;\n+            }\n+            throw new IllegalArgumentException(\"Invalid frame type: \" + frameType);\n+        }\n+\n+        FrameTypeEnum(int start, int end) {\n+            this.start = start;\n+            this.end = end;\n+        }\n+    }\n+\n+    public record TypeAnnotationRecord(\n+            int targetType,\n+            TargetInfoRecord targetInfo,\n+            Set<TypePathRecord> targetPath,\n+            AnnotationRecord annotation) {\n+\n+        public static TypeAnnotationRecord ofTypeAnnotation(TypeAnnotation ann) {\n+            return ofTypeAnnotation(ann, null, null);\n+        }\n+\n+        public static TypeAnnotationRecord ofTypeAnnotation(TypeAnnotation ann, CodeAttribute lr, CodeNormalizerHelper code) {\n+            return new TypeAnnotationRecord(\n+                    ann.targetInfo().targetType().targetTypeValue(),\n+                    TargetInfoRecord.ofTargetInfo(ann.targetInfo(), lr, code),\n+                    ann.targetPath().stream().map(tpc -> TypePathRecord.ofTypePathComponent(tpc)).collect(toSet()),\n+                    AnnotationRecord.ofAnnotation(ann));\n+        }\n+\n+        public interface TargetInfoRecord {\n+\n+            public static TargetInfoRecord ofTargetInfo(TypeAnnotation.TargetInfo tiu, CodeAttribute lr, CodeNormalizerHelper code) {\n+                if (tiu instanceof TypeAnnotation.CatchTarget ct) {\n+                    return new CatchTargetRecord(ct.exceptionTableIndex());\n+                } else if (tiu instanceof TypeAnnotation.EmptyTarget et) {\n+                    return new EmptyTargetRecord();\n+                } else if (tiu instanceof TypeAnnotation.FormalParameterTarget fpt) {\n+                    return new FormalParameterTargetRecord(fpt.formalParameterIndex());\n+                } else if (tiu instanceof TypeAnnotation.LocalVarTarget lvt) {\n+                    return new LocalVarTargetRecord(lvt.table().stream().map(ent\n+                            -> new LocalVarTargetRecord.EntryRecord(code.targetIndex(lr.labelToBci(ent.startLabel())), code.targetIndex(lr.labelToBci(ent.endLabel())), ent.index())).collect(toSet()));\n+                } else if (tiu instanceof TypeAnnotation.OffsetTarget ot) {\n+                    return new OffsetTargetRecord(code.targetIndex(lr.labelToBci(ot.target())));\n+                } else if (tiu instanceof TypeAnnotation.SupertypeTarget st) {\n+                    return new SupertypeTargetRecord(st.supertypeIndex());\n+                } else if (tiu instanceof TypeAnnotation.ThrowsTarget tt) {\n+                    return new ThrowsTargetRecord(tt.throwsTargetIndex());\n+                } else if (tiu instanceof TypeAnnotation.TypeArgumentTarget tat) {\n+                    return new TypeArgumentTargetRecord(code.targetIndex(lr.labelToBci(tat.target())), tat.typeArgumentIndex());\n+                } else if (tiu instanceof TypeAnnotation.TypeParameterBoundTarget tpbt) {\n+                    return new TypeParameterBoundTargetRecord(tpbt.typeParameterIndex(), tpbt.boundIndex());\n+                } else if (tiu instanceof TypeAnnotation.TypeParameterTarget tpt) {\n+                    return new TypeParameterTargetRecord(tpt.typeParameterIndex());\n+                } else {\n+                    throw new IllegalArgumentException(tiu.getClass().getName());\n+                }\n+            }\n+\n+            public record CatchTargetRecord(int exceptionTableIndex) implements TargetInfoRecord{}\n+\n+            public record EmptyTargetRecord() implements TargetInfoRecord {}\n+\n+            public record FormalParameterTargetRecord(int formalParameterIndex) implements TargetInfoRecord {}\n+\n+            public record LocalVarTargetRecord(Set<LocalVarTargetRecord.EntryRecord> table) implements TargetInfoRecord {\n+\n+                public record EntryRecord(int startPC, int length, int index) {}\n+            }\n+\n+            public record OffsetTargetRecord(int offset) implements TargetInfoRecord {}\n+\n+            public record SupertypeTargetRecord(int supertypeIndex) implements TargetInfoRecord {}\n+\n+            public record ThrowsTargetRecord(int throwsTargetIndex) implements TargetInfoRecord {}\n+\n+            public record TypeArgumentTargetRecord(int offset, int typeArgumentIndex) implements TargetInfoRecord {}\n+\n+            public record TypeParameterBoundTargetRecord(int typeParameterIndex, int boundIndex) implements TargetInfoRecord {}\n+\n+            public record TypeParameterTargetRecord(int typeParameterIndex) implements TargetInfoRecord {}\n+        }\n+\n+        public record TypePathRecord(\n+                int typePathKind,\n+                int typeArgumentIndex) {\n+\n+            public static TypePathRecord ofTypePathComponent(TypeAnnotation.TypePathComponent tpc) {\n+                return new TypePathRecord(tpc.typePathKind().tag(), tpc.typeArgumentIndex());\n+            }\n+        }\n+    }\n+\n+    public interface ConstantPoolEntryRecord {\n+\n+        public static ConstantPoolEntryRecord ofCPEntry(PoolEntry cpInfo) {\n+            return switch (cpInfo.tag()) {\n+                case TAG_UTF8 ->\n+                    new CpUTF8Record(((Utf8Entry) cpInfo).stringValue());\n+                case TAG_INTEGER ->\n+                    new CpIntegerRecord(((IntegerEntry) cpInfo).intValue());\n+                case TAG_FLOAT ->\n+                    new CpFloatRecord(((FloatEntry) cpInfo).floatValue());\n+                case TAG_LONG ->\n+                    new CpLongRecord(((LongEntry) cpInfo).longValue());\n+                case TAG_DOUBLE ->\n+                    new CpDoubleRecord(((DoubleEntry) cpInfo).doubleValue());\n+                case TAG_CLASS ->\n+                    new CpClassRecord(((ClassEntry) cpInfo).asInternalName());\n+                case TAG_STRING ->\n+                    new CpStringRecord(((StringEntry) cpInfo).stringValue());\n+                case TAG_FIELDREF ->\n+                    CpFieldRefRecord.ofFieldRefEntry((FieldRefEntry) cpInfo);\n+                case TAG_METHODREF ->\n+                    CpMethodRefRecord.ofMethodRefEntry((MethodRefEntry) cpInfo);\n+                case TAG_INTERFACEMETHODREF ->\n+                    CpInterfaceMethodRefRecord.ofInterfaceMethodRefEntry((InterfaceMethodRefEntry) cpInfo);\n+                case TAG_NAMEANDTYPE ->\n+                    CpNameAndTypeRecord.ofNameAndTypeEntry((NameAndTypeEntry) cpInfo);\n+                case TAG_METHODHANDLE ->\n+                    CpMethodHandleRecord.ofMethodHandleEntry((MethodHandleEntry) cpInfo);\n+                case TAG_METHODTYPE ->\n+                    new CpMethodTypeRecord(((MethodTypeEntry) cpInfo).descriptor().stringValue());\n+                case TAG_CONSTANTDYNAMIC ->\n+                    CpConstantDynamicRecord.ofConstantDynamicEntry((ConstantDynamicEntry) cpInfo);\n+                case TAG_INVOKEDYNAMIC ->\n+                    CpInvokeDynamicRecord.ofInvokeDynamicEntry((InvokeDynamicEntry) cpInfo);\n+                case TAG_MODULE ->\n+                    new CpModuleRecord(((ModuleEntry) cpInfo).name().stringValue());\n+                case TAG_PACKAGE ->\n+                    new CpPackageRecord(((PackageEntry) cpInfo).name().stringValue());\n+                default -> throw new IllegalArgumentException(Integer.toString(cpInfo.tag()));\n+            };\n+        }\n+\n+        default String altOpcode() {\n+            return null;\n+        }\n+\n+        public record CpUTF8Record(String cpUTF8) implements ConstantPoolEntryRecord {}\n+\n+        public record CpIntegerRecord(int cpInteger) implements ConstantPoolEntryRecord {\n+            @Override\n+            public String altOpcode() {\n+                return \"IPUSH#\" + Integer.toHexString(cpInteger & 0xfff);\n+            }\n+        }\n+\n+        public record CpFloatRecord(float cpFloat) implements ConstantPoolEntryRecord {\n+            @Override\n+            public String altOpcode() {\n+                return cpFloat == 0.0f ? \"FCONST_0\" :\n+                          cpFloat == 1.0f ? \"FCONST_1\" :\n+                          cpFloat == 2.0f ? \"FCONST_2\" : null;\n+            }\n+        }\n+\n+        public record CpLongRecord(long cpLong) implements ConstantPoolEntryRecord {\n+            @Override\n+            public String altOpcode() {\n+                return cpLong == 0 ? \"LCONST_0\" :\n+                          cpLong == 1 ? \"LCONST_1\" : null;\n+            }\n+        }\n+\n+        public record CpDoubleRecord(double cpDouble) implements ConstantPoolEntryRecord {\n+            @Override\n+            public String altOpcode() {\n+                return cpDouble == 0.0 ? \"DCONST_0\" :\n+                          cpDouble == 1.0 ? \"DCONST_1\" : null;\n+            }\n+        }\n+\n+        public record CpClassRecord(String cpClass) implements ConstantPoolEntryRecord {}\n+\n+        public record CpStringRecord(String cpString) implements ConstantPoolEntryRecord {}\n+\n+        public record CpFieldRefRecord(\n+                String cpFieldRefClass,\n+                String cpFieldRefName,\n+                String cpFieldRefType) implements ConstantPoolEntryRecord {\n+\n+            public static CpFieldRefRecord ofFieldRefEntry(FieldRefEntry cpInfo) {\n+                return new CpFieldRefRecord(cpInfo.owner().asInternalName(), cpInfo.nameAndType().name().stringValue(), cpInfo.nameAndType().type().stringValue());\n+            }\n+        }\n+\n+        public record CpMethodRefRecord(\n+                String cpMethodRefClass,\n+                String cpMethodRefName,\n+                String cpMethodRefType) implements ConstantPoolEntryRecord {\n+\n+            public static CpMethodRefRecord ofMethodRefEntry(MethodRefEntry cpInfo) {\n+                return new CpMethodRefRecord(cpInfo.owner().asInternalName(), cpInfo.nameAndType().name().stringValue(), cpInfo.nameAndType().type().stringValue());\n+            }\n+        }\n+\n+        public record CpInterfaceMethodRefRecord(\n+                String cpInterfaceMethodRefClass,\n+                String cpInterfaceMethodRefName,\n+                String cpInterfaceMethodRefType) implements ConstantPoolEntryRecord {\n+\n+            public static CpInterfaceMethodRefRecord ofInterfaceMethodRefEntry(InterfaceMethodRefEntry cpInfo) {\n+                return new CpInterfaceMethodRefRecord(cpInfo.owner().asInternalName(), cpInfo.nameAndType().name().stringValue(), cpInfo.nameAndType().type().stringValue());\n+            }\n+        }\n+\n+        public record CpNameAndTypeRecord(\n+                String cpNameAndTypeName,\n+                String cpNameAndTypeType) implements ConstantPoolEntryRecord {\n+\n+            public static CpNameAndTypeRecord ofNameAndTypeEntry(NameAndTypeEntry cpInfo) {\n+                return new CpNameAndTypeRecord(cpInfo.name().stringValue(), cpInfo.type().stringValue());\n+            }\n+        }\n+\n+        public record CpMethodHandleRecord(\n+                ConstantPoolEntryRecord cpHandleReference,\n+                int cpHandleKind) implements ConstantPoolEntryRecord {\n+\n+            public static CpMethodHandleRecord ofMethodHandleEntry(MethodHandleEntry cpInfo) {\n+                return new CpMethodHandleRecord(ConstantPoolEntryRecord.ofCPEntry(cpInfo.reference()), cpInfo.kind());\n+            }\n+        }\n+\n+        public record CpMethodTypeRecord(String cpMethodType) implements ConstantPoolEntryRecord {}\n+\n+        public record CpConstantDynamicRecord(\n+                String cpConstantDynamicName,\n+                String cpConstantDynamicType) implements ConstantPoolEntryRecord {\n+\n+            public static CpConstantDynamicRecord ofConstantDynamicEntry(ConstantDynamicEntry cpInfo) {\n+                return new CpConstantDynamicRecord(cpInfo.name().stringValue(), cpInfo.type().stringValue());\n+            }\n+        }\n+\n+        public record CpInvokeDynamicRecord(\n+                String cpInvokeDynamicName,\n+                String cpInvokeDynamicType) implements ConstantPoolEntryRecord {\n+\n+            public static CpInvokeDynamicRecord ofInvokeDynamicEntry(InvokeDynamicEntry cpInfo) {\n+                return new CpInvokeDynamicRecord(cpInfo.name().stringValue(), cpInfo.type().stringValue());\n+            }\n+        }\n+\n+        public record CpModuleRecord(String cpModule) implements ConstantPoolEntryRecord {}\n+\n+        public record CpPackageRecord(String cpPackage) implements ConstantPoolEntryRecord {}\n+\n+    }\n+\n+    public interface ElementValueRecord {\n+\n+        public int tag();\n+\n+        public static ElementValueRecord ofElementValue(AnnotationValue ev) {\n+            return switch (ev) {\n+                case AnnotationValue.OfConstant evc -> new EvConstRecord(ev.tag(), ConstantPoolEntryRecord.ofCPEntry(evc.constant()));\n+                case AnnotationValue.OfEnum enumVal -> new EvEnumConstRecord(ev.tag(), enumVal.className().stringValue(), enumVal.constantName().stringValue());\n+                case AnnotationValue.OfClass classVal -> new EvClassRecord(ev.tag(), classVal.className().stringValue());\n+                case AnnotationValue.OfAnnotation ann -> new EvAnnotationRecord(ev.tag(), AnnotationRecord.ofAnnotation(ann.annotation()));\n+                case AnnotationValue.OfArray evav -> new EvArrayRecord(ev.tag(), evav.values().stream().map(ElementValueRecord::ofElementValue).toList());\n+                case null, default -> throw new IllegalArgumentException(ev.getClass().getName());\n+            };\n+        }\n+\n+        public record EvAnnotationRecord(\n+                int tag,\n+                AnnotationRecord annotation) implements ElementValueRecord {}\n+\n+        public record EvArrayRecord(\n+                int tag,\n+                List<ElementValueRecord> values) implements ElementValueRecord {}\n+\n+        public record EvClassRecord(\n+                int tag,\n+                String classInfo) implements ElementValueRecord {}\n+\n+        public record EvEnumConstRecord(\n+                int tag,\n+                String typeName,\n+                String constName) implements ElementValueRecord {}\n+\n+        public record EvConstRecord(\n+                int tag,\n+                ConstantPoolEntryRecord constValue) implements ElementValueRecord {\n+        }\n+    }\n+\n+    private enum Flags {\n+        PUBLIC, PRIVATE, PROTECTED,  STATIC, FINAL, SUPER (\"SYNCHRONIZED\"), VOLATILE (\"BRIDGE\"), TRANSIENT (\"VARARGS\"),\n+        NATIVE,  INTERFACE, ABSTRACT,  STRICT,  SYNTHETIC,  ANNOTATION,  ENUM,  MODULE (\"MANDATED\");\n+\n+        private String alt;\n+\n+        Flags() {\n+            this.alt = name();\n+        }\n+\n+        Flags(String alt) {\n+            this.alt = alt;\n+        }\n+\n+        public static String toString(int flags, boolean methodFlags) {\n+            int i=1;\n+            StringBuilder sb = new StringBuilder();\n+            for (var cf : values()) {\n+                if ((flags & i) != 0) {\n+                    if (sb.length() > 0) sb.append(',');\n+                    sb.append(methodFlags ? cf.alt : cf.name());\n+                }\n+                i <<= 1;\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static void assertEquals(ClassModel actual, ClassModel expected) {\n+        assertEqualsDeep(ClassRecord.ofClassModel(actual, By_ClassBuilder),\n+                ClassRecord.ofClassModel(expected, By_ClassBuilder));\n+    }\n+\n+    public static void assertEqualsDeep(Object actual, Object expected) {\n+        assertEqualsDeep(actual, expected, null, true);\n+    }\n+\n+    public static void assertEqualsDeep(Object actual, Object expected, String message) {\n+        assertEqualsDeep(actual, expected, message, true);\n+    }\n+\n+    public static void assertEqualsDeep(Object actual, Object expected, String message, boolean printValues) {\n+        assertEqualsDeepImpl(actual, expected, message == null ? \"\" : message + \" \", \"$\", printValues);\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private static void assertEqualsDeepImpl(Object actual, Object expected, String message, String path, boolean printValues) {\n+        if (actual instanceof Record && expected instanceof Record) {\n+            assertEqualsDeepImpl(actual.getClass(), expected.getClass(), message, path, printValues);\n+            for (RecordComponent rc : actual.getClass().getRecordComponents()) {\n+                try {\n+                    assertEqualsDeepImpl(rc.getAccessor().invoke(actual), rc.getAccessor().invoke(expected), message, path + \".\" + rc.getName(), printValues);\n+                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n+                    throw new AssertionError(message + ex.getLocalizedMessage(), ex);\n+                }\n+            }\n+        } else if (actual instanceof Map actualMap && expected instanceof Map expectedMap) {\n+            assertEqualsDeepImpl(actualMap.keySet(), expectedMap.keySet(), message, path + \"(keys)\", printValues);\n+            actualMap.forEach((key, actualValue) -> {\n+                assertEqualsDeepImpl(actualValue, expectedMap.get(key), message, path + \".\" + key, printValues);\n+            });\n+        } else if (actual instanceof List actualList && expected instanceof List expectedList) {\n+            assertEqualsDeepImpl(actualList.size(), expectedList.size(), message, path + \"(size)\", printValues);\n+            IntStream.range(0, actualList.size()).forEach(i -> assertEqualsDeepImpl(actualList.get(i), expectedList.get(i), message, path + \"[\" + i +\"]\", printValues));\n+        } else {\n+            if (actual instanceof Set actualSet && expected instanceof Set expectedSet) {\n+                actual = actualSet.stream().filter(e -> !expectedSet.contains(e)).collect(toSet());\n+                expected = expectedSet.stream().filter(e -> !actualSet.contains(e)).collect(toSet());\n+            }\n+            if (!Objects.equals(actual, expected)) {\n+                throw new AssertionError(message + \"not equal on path [\" + path + \"]\");\n+\/\/                        + (printValues ? \"\\nexpected: \" + prettyPrintToJson(expected) + \"\\nbut found: \" + prettyPrintToJson(actual) : \"\"));\n+            }\n+        }\n+    }\n+\n+\/\/    @Override\n+\/\/    public String toString() {\n+\/\/        return prettyPrintToJson(this);\n+\/\/    }\n+\/\/\n+\/\/    private static final JsonWriterFactory JWF = Json.createWriterFactory(Map.of(JsonGenerator.PRETTY_PRINTING, true));\n+\/\/\n+\/\/    public static String prettyPrintToJson(Object o) {\n+\/\/        var stringWriter = new StringWriter();\n+\/\/        try ( var jsonWriter = JWF.createWriter(stringWriter)) {\n+\/\/            jsonWriter.write(toJson(o));\n+\/\/        }\n+\/\/        return stringWriter.toString();\n+\/\/    }\n+\/\/\n+\/\/    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\/\/    private static JsonValue toJson(Object o) {\n+\/\/        if (o == null) {\n+\/\/            return JsonValue.NULL;\n+\/\/        } else if (o instanceof Record) {\n+\/\/            var b = Json.createObjectBuilder();\n+\/\/            for (RecordComponent rc : o.getClass().getRecordComponents()) try {\n+\/\/                var val = rc.getAccessor().invoke(o);\n+\/\/                if (val != null) {\n+\/\/                    b.add(rc.getName(), toJson(val));\n+\/\/                }\n+\/\/            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n+\/\/                throw new RuntimeException(ex);\n+\/\/            }\n+\/\/            return b.build();\n+\/\/        }\n+\/\/        if (o instanceof Map map) {\n+\/\/            var b = Json.createObjectBuilder();\n+\/\/            map.forEach((k, v) -> b.add(String.valueOf(k), toJson(v)));\n+\/\/            return b.build();\n+\/\/        }\n+\/\/        if (o instanceof Collection col) {\n+\/\/            var b = Json.createArrayBuilder();\n+\/\/            col.forEach(e -> b.add(toJson(e)));\n+\/\/            return b.build();\n+\/\/        } else if (o instanceof String s) {\n+\/\/            return Json.createValue(s);\n+\/\/        } else if (o instanceof Double d) {\n+\/\/            return Json.createValue(d);\n+\/\/        } else if (o instanceof Integer i) {\n+\/\/            return Json.createValue(i);\n+\/\/        } else if (o instanceof Long l) {\n+\/\/            return Json.createValue(l);\n+\/\/        } else {\n+\/\/            return Json.createValue(o.toString());\n+\/\/        }\n+\/\/    }\n+\n+    private interface SupplierThrowingException<R> {\n+        R get() throws Exception;\n+    }\n+\n+    private static <R> R wrapException(SupplierThrowingException<R> supplier) {\n+        try {\n+            return supplier.get();\n+        } catch (RuntimeException re) {\n+            throw re;\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private interface FunctionThrowingException<P, R> {\n+        R apply(P p) throws Exception;\n+    }\n+\n+    private static <P, R> R map(P value, FunctionThrowingException<P, R> mapper) {\n+        return map(value, mapper, null);\n+    }\n+\n+    private static <P, R> R map(P value, FunctionThrowingException<P, R> mapper, R defaultReturn) {\n+        try {\n+            return value == null ? defaultReturn : mapper.apply(value);\n+        } catch (RuntimeException re) {\n+            throw re;\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static <P, R> Function<P, R> wrapException(FunctionThrowingException<P, R> function) {\n+        return p -> {\n+            try {\n+                return function.apply(p);\n+            } catch (RuntimeException re) {\n+                throw re;\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1267,"deletions":0,"binary":false,"changes":1267,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.instruction.*;\n+\n+public class InstructionModelToCodeBuilder {\n+\n+    public static void toBuilder(CodeElement model, CodeBuilder cb) {\n+        switch (model) {\n+            case LoadInstruction im ->\n+                cb.loadInstruction(im.typeKind(), im.slot());\n+            case StoreInstruction im ->\n+                cb.storeInstruction(im.typeKind(), im.slot());\n+            case IncrementInstruction im ->\n+                cb.incrementInstruction(im.slot(), im.constant());\n+            case BranchInstruction im ->\n+                cb.branchInstruction(im.opcode(), im.target());\n+            case LookupSwitchInstruction im ->\n+                cb.lookupSwitchInstruction(im.defaultTarget(), im.cases());\n+            case TableSwitchInstruction im ->\n+                cb.tableSwitchInstruction(im.lowValue(), im.highValue(), im.defaultTarget(), im.cases());\n+            case ReturnInstruction im ->\n+                cb.returnInstruction(im.typeKind());\n+            case ThrowInstruction im ->\n+                cb.throwInstruction();\n+            case FieldInstruction im ->\n+                cb.fieldInstruction(im.opcode(), im.owner().asSymbol(), im.name().stringValue(), im.typeSymbol());\n+            case InvokeInstruction im ->\n+                cb.invokeInstruction(im.opcode(), im.owner().asSymbol(), im.name().stringValue(), im.typeSymbol(), im.isInterface());\n+            case InvokeDynamicInstruction im ->\n+                cb.invokeDynamicInstruction(DynamicCallSiteDesc.of(im.bootstrapMethod(), im.name().stringValue(), MethodTypeDesc.ofDescriptor(im.type().stringValue()), im.bootstrapArgs().toArray(ConstantDesc[]::new)));\n+            case NewObjectInstruction im ->\n+                cb.newObjectInstruction(im.className().asSymbol());\n+            case NewPrimitiveArrayInstruction im ->\n+                cb.newPrimitiveArrayInstruction(im.typeKind());\n+            case NewReferenceArrayInstruction im ->\n+                cb.newReferenceArrayInstruction(im.componentType());\n+            case NewMultiArrayInstruction im ->\n+                cb.newMultidimensionalArrayInstruction(im.dimensions(), im.arrayType());\n+            case TypeCheckInstruction im ->\n+                cb.typeCheckInstruction(im.opcode(), im.type().asSymbol());\n+            case ArrayLoadInstruction im ->\n+                cb.arrayLoadInstruction(im.typeKind());\n+            case ArrayStoreInstruction im ->\n+                cb.arrayStoreInstruction(im.typeKind());\n+            case StackInstruction im ->\n+                cb.stackInstruction(im.opcode());\n+            case ConvertInstruction im ->\n+                cb.convertInstruction(im.fromType(), im.toType());\n+            case OperatorInstruction im ->\n+                cb.operatorInstruction(im.opcode());\n+            case ConstantInstruction im ->\n+                cb.constantInstruction(im.opcode(), im.constantValue());\n+            case MonitorInstruction im ->\n+                cb.monitorInstruction(im.opcode());\n+            case NopInstruction im ->\n+                cb.nopInstruction();\n+            case LabelTarget im ->\n+                cb.labelBinding(im.label());\n+            case ExceptionCatch im ->\n+                cb.exceptionCatch(im.tryStart(), im.tryEnd(), im.handler(), im.catchType());\n+            default ->\n+                throw new IllegalArgumentException(\"not yet implemented: \" + model);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/InstructionModelToCodeBuilder.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,590 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Random;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.instruction.*;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+import jdk.internal.classfile.components.CodeStackTracker;\n+\n+class RebuildingTransformation {\n+\n+    static private Random pathSwitch = new Random(1234);\n+\n+    static byte[] transform(ClassModel clm) {\n+        return Classfile.build(clm.thisClass().asSymbol(), List.of(Classfile.Option.generateStackmap(false)), clb -> {\n+            for (var cle : clm) {\n+                switch (cle) {\n+                    case AccessFlags af -> clb.withFlags(af.flagsMask());\n+                    case Superclass sc -> clb.withSuperclass(sc.superclassEntry().asSymbol());\n+                    case Interfaces i -> clb.withInterfaceSymbols(i.interfaces().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n+                    case ClassfileVersion v -> clb.withVersion(v.majorVersion(), v.minorVersion());\n+                    case FieldModel fm ->\n+                        clb.withField(fm.fieldName().stringValue(), fm.fieldTypeSymbol(), fb -> {\n+                            for (var fe : fm) {\n+                                switch (fe) {\n+                                    case AccessFlags af -> fb.withFlags(af.flagsMask());\n+                                    case ConstantValueAttribute a -> fb.with(ConstantValueAttribute.of(a.constant().constantValue()));\n+                                    case DeprecatedAttribute a -> fb.with(DeprecatedAttribute.of());\n+                                    case RuntimeInvisibleAnnotationsAttribute a -> fb.with(RuntimeInvisibleAnnotationsAttribute.of(transformAnnotations(a.annotations())));\n+                                    case RuntimeInvisibleTypeAnnotationsAttribute a -> fb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), null, null)));\n+                                    case RuntimeVisibleAnnotationsAttribute a -> fb.with(RuntimeVisibleAnnotationsAttribute.of(transformAnnotations(a.annotations())));\n+                                    case RuntimeVisibleTypeAnnotationsAttribute a -> fb.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), null, null)));\n+                                    case SignatureAttribute a -> fb.with(SignatureAttribute.of(Signature.parseFrom(a.asTypeSignature().signatureString())));\n+                                    case SyntheticAttribute a -> fb.with(SyntheticAttribute.of());\n+                                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+                                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName());\n+                                }\n+                            }\n+                        });\n+                    case MethodModel mm -> {\n+                        clb.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> {\n+                            for (var me : mm) {\n+                                switch (me) {\n+                                    case AccessFlags af -> mb.withFlags(af.flagsMask());\n+                                    case CodeModel com -> mb.withCode(cb -> cb.transforming(CodeStackTracker.of(), cob -> {\n+                                        var labels = new HashMap<Label, Label>();\n+                                        for (var coe : com) {\n+                                            switch (coe) {\n+                                                case ArrayLoadInstruction i -> {\n+                                                    switch (i.typeKind()) {\n+                                                        case ByteType -> cob.baload();\n+                                                        case ShortType -> cob.saload();\n+                                                        case IntType -> cob.iaload();\n+                                                        case FloatType -> cob.faload();\n+                                                        case LongType -> cob.laload();\n+                                                        case DoubleType -> cob.daload();\n+                                                        case ReferenceType -> cob.aaload();\n+                                                        case CharType -> cob.caload();\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case ArrayStoreInstruction i -> {\n+                                                    switch (i.typeKind()) {\n+                                                        case ByteType -> cob.bastore();\n+                                                        case ShortType -> cob.sastore();\n+                                                        case IntType -> cob.iastore();\n+                                                        case FloatType -> cob.fastore();\n+                                                        case LongType -> cob.lastore();\n+                                                        case DoubleType -> cob.dastore();\n+                                                        case ReferenceType -> cob.aastore();\n+                                                        case CharType -> cob.castore();\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case BranchInstruction i -> {\n+                                                    var target = labels.computeIfAbsent(i.target(), l -> cob.newLabel());\n+                                                    switch (i.opcode()) {\n+                                                        case GOTO -> cob.goto_(target);\n+                                                        case GOTO_W -> cob.goto_w(target);\n+                                                        case IF_ACMPEQ -> cob.if_acmpeq(target);\n+                                                        case IF_ACMPNE -> cob.if_acmpne(target);\n+                                                        case IF_ICMPEQ -> cob.if_icmpeq(target);\n+                                                        case IF_ICMPGE -> cob.if_icmpge(target);\n+                                                        case IF_ICMPGT -> cob.if_icmpgt(target);\n+                                                        case IF_ICMPLE -> cob.if_icmple(target);\n+                                                        case IF_ICMPLT -> cob.if_icmplt(target);\n+                                                        case IF_ICMPNE -> cob.if_icmpne(target);\n+                                                        case IFNONNULL -> cob.if_nonnull(target);\n+                                                        case IFNULL -> cob.if_null(target);\n+                                                        case IFEQ -> cob.ifeq(target);\n+                                                        case IFGE -> cob.ifge(target);\n+                                                        case IFGT -> cob.ifgt(target);\n+                                                        case IFLE -> cob.ifle(target);\n+                                                        case IFLT -> cob.iflt(target);\n+                                                        case IFNE -> cob.ifne(target);\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case ConstantInstruction i -> {\n+                                                    if (i.constantValue() == null)\n+                                                        if (pathSwitch.nextBoolean()) cob.aconst_null();\n+                                                        else cob.constantInstruction(null);\n+                                                    else switch (i.constantValue()) {\n+                                                        case Integer iVal -> {\n+                                                            if (iVal == 1 && pathSwitch.nextBoolean()) cob.iconst_1();\n+                                                            else if (iVal == 2 && pathSwitch.nextBoolean()) cob.iconst_2();\n+                                                            else if (iVal == 3 && pathSwitch.nextBoolean()) cob.iconst_3();\n+                                                            else if (iVal == 4 && pathSwitch.nextBoolean()) cob.iconst_4();\n+                                                            else if (iVal == 5 && pathSwitch.nextBoolean()) cob.iconst_5();\n+                                                            else if (iVal == -1 && pathSwitch.nextBoolean()) cob.iconst_m1();\n+                                                            else if (iVal >= -128 && iVal <= 127 && pathSwitch.nextBoolean()) cob.bipush(iVal);\n+                                                            else if (iVal >= -32768 && iVal <= 32767 && pathSwitch.nextBoolean()) cob.sipush(iVal);\n+                                                            else cob.constantInstruction(iVal);\n+                                                        }\n+                                                        case Long lVal -> {\n+                                                            if (lVal == 0 && pathSwitch.nextBoolean()) cob.lconst_0();\n+                                                            else if (lVal == 1 && pathSwitch.nextBoolean()) cob.lconst_1();\n+                                                            else cob.constantInstruction(lVal);\n+                                                        }\n+                                                        case Float fVal -> {\n+                                                            if (fVal == 0.0 && pathSwitch.nextBoolean()) cob.fconst_0();\n+                                                            else if (fVal == 1.0 && pathSwitch.nextBoolean()) cob.fconst_1();\n+                                                            else if (fVal == 2.0 && pathSwitch.nextBoolean()) cob.fconst_2();\n+                                                            else cob.constantInstruction(fVal);\n+                                                        }\n+                                                        case Double dVal -> {\n+                                                            if (dVal == 0.0d && pathSwitch.nextBoolean()) cob.dconst_0();\n+                                                            else if (dVal == 1.0d && pathSwitch.nextBoolean()) cob.dconst_1();\n+                                                            else cob.constantInstruction(dVal);\n+                                                        }\n+                                                        default -> cob.constantInstruction(i.constantValue());\n+                                                    }\n+                                                }\n+                                                case ConvertInstruction i -> {\n+                                                    switch (i.fromType()) {\n+                                                        case DoubleType -> {\n+                                                            switch (i.toType()) {\n+                                                                case FloatType -> cob.d2f();\n+                                                                case IntType -> cob.d2i();\n+                                                                case LongType -> cob.d2l();\n+                                                                default -> throw new AssertionError(\"Should not reach here\");\n+                                                            }\n+                                                        }\n+                                                        case FloatType -> {\n+                                                            switch (i.toType()) {\n+                                                                case DoubleType -> cob.f2d();\n+                                                                case IntType -> cob.f2i();\n+                                                                case LongType -> cob.f2l();\n+                                                                default -> throw new AssertionError(\"Should not reach here\");\n+                                                            }\n+                                                        }\n+                                                        case IntType -> {\n+                                                            switch (i.toType()) {\n+                                                                case ByteType -> cob.i2b();\n+                                                                case CharType -> cob.i2c();\n+                                                                case DoubleType -> cob.i2d();\n+                                                                case FloatType -> cob.i2f();\n+                                                                case LongType -> cob.i2l();\n+                                                                case ShortType -> cob.i2s();\n+                                                                default -> throw new AssertionError(\"Should not reach here\");\n+                                                            }\n+                                                        }\n+                                                        case LongType -> {\n+                                                            switch (i.toType()) {\n+                                                                case DoubleType -> cob.l2d();\n+                                                                case FloatType -> cob.l2f();\n+                                                                case IntType -> cob.l2i();\n+                                                                default -> throw new AssertionError(\"Should not reach here\");\n+                                                            }\n+                                                        }\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case FieldInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) {\n+                                                        switch (i.opcode()) {\n+                                                            case GETFIELD -> cob.getfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                            case GETSTATIC -> cob.getstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                            case PUTFIELD -> cob.putfield(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                            case PUTSTATIC -> cob.putstatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                            default -> throw new AssertionError(\"Should not reach here\");\n+                                                        }\n+                                                    } else {\n+                                                        switch (i.opcode()) {\n+                                                            case GETFIELD -> cob.getfield(i.field());\n+                                                            case GETSTATIC -> cob.getstatic(i.field());\n+                                                            case PUTFIELD -> cob.putfield(i.field());\n+                                                            case PUTSTATIC -> cob.putstatic(i.field());\n+                                                            default -> throw new AssertionError(\"Should not reach here\");\n+                                                        }\n+                                                    }\n+                                                }\n+                                                case InvokeDynamicInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) cob.invokedynamic(i.invokedynamic().asSymbol());\n+                                                    else cob.invokedynamic(i.invokedynamic());\n+                                                }\n+                                                case InvokeInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) {\n+                                                        if (i.isInterface()) {\n+                                                            switch (i.opcode()) {\n+                                                                case INVOKEINTERFACE -> cob.invokeinterface(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n+                                                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), true);\n+                                                                default -> throw new AssertionError(\"Should not reach here\");\n+                                                            }\n+                                                        } else {\n+                                                            switch (i.opcode()) {\n+                                                                case INVOKESPECIAL -> cob.invokespecial(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                                case INVOKESTATIC -> cob.invokestatic(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                                case INVOKEVIRTUAL -> cob.invokevirtual(i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                                                                default -> throw new AssertionError(\"Should not reach here\");\n+                                                            }\n+                                                        }\n+                                                    } else {\n+                                                        switch (i.method()) {\n+                                                            case InterfaceMethodRefEntry en -> {\n+                                                                switch (i.opcode()) {\n+                                                                        case INVOKEINTERFACE -> cob.invokeinterface(en);\n+                                                                        case INVOKESPECIAL -> cob.invokespecial(en);\n+                                                                        case INVOKESTATIC -> cob.invokestatic(en);\n+                                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                                }\n+                                                            }\n+                                                            case MethodRefEntry en -> {\n+                                                                switch (i.opcode()) {\n+                                                                        case INVOKESPECIAL -> cob.invokespecial(en);\n+                                                                        case INVOKESTATIC -> cob.invokestatic(en);\n+                                                                        case INVOKEVIRTUAL -> cob.invokevirtual(en);\n+                                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                                }\n+                                                            }\n+                                                            default -> throw new AssertionError(\"Should not reach here\");\n+                                                        }\n+                                                    }\n+                                                }\n+                                                case LoadInstruction i -> {\n+                                                    switch (i.typeKind()) {\n+                                                        case IntType -> cob.iload(i.slot());\n+                                                        case FloatType -> cob.fload(i.slot());\n+                                                        case LongType -> cob.lload(i.slot());\n+                                                        case DoubleType -> cob.dload(i.slot());\n+                                                        case ReferenceType -> cob.aload(i.slot());\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case StoreInstruction i -> {\n+                                                    switch (i.typeKind()) {\n+                                                        case IntType -> cob.istore(i.slot());\n+                                                        case FloatType -> cob.fstore(i.slot());\n+                                                        case LongType -> cob.lstore(i.slot());\n+                                                        case DoubleType -> cob.dstore(i.slot());\n+                                                        case ReferenceType -> cob.astore(i.slot());\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case IncrementInstruction i ->\n+                                                    cob.iinc(i.slot(), i.constant());\n+                                                case LookupSwitchInstruction i ->\n+                                                    cob.lookupswitch(labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n+                                                                     i.cases().stream().map(sc ->\n+                                                                             SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n+                                                case MonitorInstruction i -> {\n+                                                    switch (i.opcode()) {\n+                                                        case MONITORENTER ->  cob.monitorenter();\n+                                                        case MONITOREXIT ->  cob.monitorexit();\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case NewMultiArrayInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) {\n+                                                        cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n+                                                    } else {\n+                                                        cob.multianewarray(i.arrayType(), i.dimensions());\n+                                                    }\n+                                                }\n+                                                case NewObjectInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) {\n+                                                        cob.new_(i.className().asSymbol());\n+                                                    } else {\n+                                                        cob.new_(i.className());\n+                                                    }\n+                                                }\n+                                                case NewPrimitiveArrayInstruction i ->\n+                                                    cob.newarray(i.typeKind());\n+                                                case NewReferenceArrayInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) {\n+                                                        cob.anewarray(i.componentType().asSymbol());\n+                                                    } else {\n+                                                        cob.anewarray(i.componentType());\n+                                                    }\n+                                                }\n+                                                case NopInstruction i ->\n+                                                    cob.nop();\n+                                                case OperatorInstruction i -> {\n+                                                    switch (i.opcode()) {\n+                                                        case IADD -> cob.iadd();\n+                                                        case LADD -> cob.ladd();\n+                                                        case FADD -> cob.fadd();\n+                                                        case DADD -> cob.dadd();\n+                                                        case ISUB -> cob.isub();\n+                                                        case LSUB -> cob.lsub();\n+                                                        case FSUB -> cob.fsub();\n+                                                        case DSUB -> cob.dsub();\n+                                                        case IMUL -> cob.imul();\n+                                                        case LMUL -> cob.lmul();\n+                                                        case FMUL -> cob.fmul();\n+                                                        case DMUL -> cob.dmul();\n+                                                        case IDIV -> cob.idiv();\n+                                                        case LDIV -> cob.ldiv();\n+                                                        case FDIV -> cob.fdiv();\n+                                                        case DDIV -> cob.ddiv();\n+                                                        case IREM -> cob.irem();\n+                                                        case LREM -> cob.lrem();\n+                                                        case FREM -> cob.frem();\n+                                                        case DREM -> cob.drem();\n+                                                        case INEG -> cob.ineg();\n+                                                        case LNEG -> cob.lneg();\n+                                                        case FNEG -> cob.fneg();\n+                                                        case DNEG -> cob.dneg();\n+                                                        case ISHL -> cob.ishl();\n+                                                        case LSHL -> cob.lshl();\n+                                                        case ISHR -> cob.ishr();\n+                                                        case LSHR -> cob.lshr();\n+                                                        case IUSHR -> cob.iushr();\n+                                                        case LUSHR -> cob.lushr();\n+                                                        case IAND -> cob.iand();\n+                                                        case LAND -> cob.land();\n+                                                        case IOR -> cob.ior();\n+                                                        case LOR -> cob.lor();\n+                                                        case IXOR -> cob.ixor();\n+                                                        case LXOR -> cob.lxor();\n+                                                        case LCMP -> cob.lcmp();\n+                                                        case FCMPL -> cob.fcmpl();\n+                                                        case FCMPG -> cob.fcmpg();\n+                                                        case DCMPL -> cob.dcmpl();\n+                                                        case DCMPG -> cob.dcmpg();\n+                                                        case ARRAYLENGTH -> cob.arraylength();\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case ReturnInstruction i -> {\n+                                                    switch (i.typeKind()) {\n+                                                        case IntType -> cob.ireturn();\n+                                                        case FloatType -> cob.freturn();\n+                                                        case LongType -> cob.lreturn();\n+                                                        case DoubleType -> cob.dreturn();\n+                                                        case ReferenceType -> cob.areturn();\n+                                                        case VoidType -> cob.return_();\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case StackInstruction i -> {\n+                                                    switch (i.opcode()) {\n+                                                        case POP -> cob.pop();\n+                                                        case POP2 -> cob.pop2();\n+                                                        case DUP -> cob.dup();\n+                                                        case DUP_X1 -> cob.dup_x1();\n+                                                        case DUP_X2 -> cob.dup_x2();\n+                                                        case DUP2 -> cob.dup2();\n+                                                        case DUP2_X1 -> cob.dup2_x1();\n+                                                        case DUP2_X2 -> cob.dup2_x2();\n+                                                        case SWAP -> cob.swap();\n+                                                        default -> throw new AssertionError(\"Should not reach here\");\n+                                                    }\n+                                                }\n+                                                case TableSwitchInstruction i ->\n+                                                    cob.tableswitch(i.lowValue(), i.highValue(),\n+                                                                    labels.computeIfAbsent(i.defaultTarget(), l -> cob.newLabel()),\n+                                                                    i.cases().stream().map(sc ->\n+                                                                            SwitchCase.of(sc.caseValue(), labels.computeIfAbsent(sc.target(), l -> cob.newLabel()))).toList());\n+                                                case ThrowInstruction i -> cob.athrow();\n+                                                case TypeCheckInstruction i -> {\n+                                                    if (pathSwitch.nextBoolean()) {\n+                                                        switch (i.opcode()) {\n+                                                            case CHECKCAST -> cob.checkcast(i.type().asSymbol());\n+                                                            case INSTANCEOF -> cob.instanceof_(i.type().asSymbol());\n+                                                            default -> throw new AssertionError(\"Should not reach here\");\n+                                                        }\n+                                                    } else {\n+                                                        switch (i.opcode()) {\n+                                                            case CHECKCAST -> cob.checkcast(i.type());\n+                                                            case INSTANCEOF -> cob.instanceof_(i.type());\n+                                                            default -> throw new AssertionError(\"Should not reach here\");\n+                                                        }\n+                                                    }\n+                                                }\n+                                                case CharacterRange pi ->\n+                                                    cob.characterRange(labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()),\n+                                                                       pi.characterRangeStart(), pi.characterRangeEnd(), pi.flags());\n+                                                case ExceptionCatch pi ->\n+                                                    pi.catchType().ifPresentOrElse(\n+                                                            catchType -> cob.exceptionCatch(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n+                                                                                            labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n+                                                                                            labels.computeIfAbsent(pi.handler(), l -> cob.newLabel()),\n+                                                                                            catchType.asSymbol()),\n+                                                            () -> cob.exceptionCatchAll(labels.computeIfAbsent(pi.tryStart(), l -> cob.newLabel()),\n+                                                                                        labels.computeIfAbsent(pi.tryEnd(), l -> cob.newLabel()),\n+                                                                                        labels.computeIfAbsent(pi.handler(), l -> cob.newLabel())));\n+                                                case LabelTarget pi ->\n+                                                    cob.labelBinding(labels.computeIfAbsent(pi.label(), l -> cob.newLabel()));\n+                                                case LineNumber pi ->\n+                                                    cob.lineNumber(pi.line());\n+                                                case LocalVariable pi ->\n+                                                    cob.localVariable(pi.slot(), pi.name().stringValue(), pi.typeSymbol(),\n+                                                                      labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                                                       labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n+                                                case LocalVariableType pi ->\n+                                                    cob.localVariableType(pi.slot(), pi.name().stringValue(),\n+                                                                          Signature.parseFrom(pi.signatureSymbol().signatureString()),\n+                                                                          labels.computeIfAbsent(pi.startScope(), l -> cob.newLabel()),\n+                                                                          labels.computeIfAbsent(pi.endScope(), l -> cob.newLabel()));\n+                                                case RuntimeInvisibleTypeAnnotationsAttribute a ->\n+                                                    cob.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n+                                                case RuntimeVisibleTypeAnnotationsAttribute a ->\n+                                                    cob.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), cob, labels)));\n+                                                case StackMapTableAttribute a ->\n+                                                    throw new AssertionError(\"Unexpected StackMapTableAttribute here\");\n+                                                case CustomAttribute a ->\n+                                                    throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+                                            }\n+                                        }\n+                                        com.findAttribute(Attributes.STACK_MAP_TABLE).ifPresent(smta ->\n+                                                    cob.with(StackMapTableAttribute.of(smta.entries().stream().map(fr ->\n+                                                            StackMapTableAttribute.StackMapFrameInfo.of(labels.computeIfAbsent(fr.target(), l -> cob.newLabel()),\n+                                                                    transformFrameTypeInfos(fr.locals(), cob, labels),\n+                                                                    transformFrameTypeInfos(fr.stack(), cob, labels))).toList())));\n+                                    }));\n+                                    case AnnotationDefaultAttribute a -> mb.with(AnnotationDefaultAttribute.of(transformAnnotationValue(a.defaultValue())));\n+                                    case DeprecatedAttribute a -> mb.with(DeprecatedAttribute.of());\n+                                    case ExceptionsAttribute a -> mb.with(ExceptionsAttribute.ofSymbols(a.exceptions().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new)));\n+                                    case MethodParametersAttribute a -> mb.with(MethodParametersAttribute.of(a.parameters().stream().map(mp ->\n+                                            MethodParameterInfo.ofParameter(mp.name().map(Utf8Entry::stringValue), mp.flagsMask())).toArray(MethodParameterInfo[]::new)));\n+                                    case RuntimeInvisibleAnnotationsAttribute a -> mb.with(RuntimeInvisibleAnnotationsAttribute.of(transformAnnotations(a.annotations())));\n+                                    case RuntimeInvisibleParameterAnnotationsAttribute a -> mb.with(RuntimeInvisibleParameterAnnotationsAttribute.of(a.parameterAnnotations().stream().map(pas -> List.of(transformAnnotations(pas))).toList()));\n+                                    case RuntimeInvisibleTypeAnnotationsAttribute a -> mb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), null, null)));\n+                                    case RuntimeVisibleAnnotationsAttribute a -> mb.with(RuntimeVisibleAnnotationsAttribute.of(transformAnnotations(a.annotations())));\n+                                    case RuntimeVisibleParameterAnnotationsAttribute a -> mb.with(RuntimeVisibleParameterAnnotationsAttribute.of(a.parameterAnnotations().stream().map(pas -> List.of(transformAnnotations(pas))).toList()));\n+                                    case RuntimeVisibleTypeAnnotationsAttribute a -> mb.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), null, null)));\n+                                    case SignatureAttribute a -> mb.with(SignatureAttribute.of(MethodSignature.parseFrom(a.asMethodSignature().signatureString())));\n+                                    case SyntheticAttribute a -> mb.with(SyntheticAttribute.of());\n+                                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+                                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName());\n+                                }\n+                            }\n+                        });\n+                    }\n+                    case CompilationIDAttribute a -> clb.with(CompilationIDAttribute.of(a.compilationId().stringValue()));\n+                    case DeprecatedAttribute a -> clb.with(DeprecatedAttribute.of());\n+                    case EnclosingMethodAttribute a -> clb.with(EnclosingMethodAttribute.of(a.enclosingClass().asSymbol(), a.enclosingMethodName().map(Utf8Entry::stringValue), a.enclosingMethodTypeSymbol()));\n+                    case InnerClassesAttribute a -> clb.with(InnerClassesAttribute.of(a.classes().stream().map(ici -> InnerClassInfo.of(\n+                            ici.innerClass().asSymbol(),\n+                            ici.outerClass().map(ClassEntry::asSymbol),\n+                            ici.innerName().map(Utf8Entry::stringValue),\n+                            ici.flagsMask())).toArray(InnerClassInfo[]::new)));\n+                    case ModuleAttribute a -> clb.with(ModuleAttribute.of(a.moduleName().asSymbol(), mob -> {\n+                        mob.moduleFlags(a.moduleFlagsMask());\n+                        a.moduleVersion().ifPresent(v -> mob.moduleVersion(v.stringValue()));\n+                        for (var req : a.requires()) mob.requires(req.requires().asSymbol(), req.requiresFlagsMask(), req.requiresVersion().map(Utf8Entry::stringValue).orElse(null));\n+                        for (var exp : a.exports()) mob.exports(exp.exportedPackage().asSymbol(), exp.exportsFlagsMask(), exp.exportsTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n+                        for (var opn : a.opens()) mob.opens(opn.openedPackage().asSymbol(), opn.opensFlagsMask(), opn.opensTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n+                        for (var use : a.uses()) mob.uses(use.asSymbol());\n+                        for (var prov : a.provides()) mob.provides(prov.provides().asSymbol(), prov.providesWith().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n+                    }));\n+                    case ModuleHashesAttribute a -> clb.with(ModuleHashesAttribute.of(a.algorithm().stringValue(),\n+                            a.hashes().stream().map(mh -> ModuleHashInfo.of(mh.moduleName().asSymbol(), mh.hash())).toArray(ModuleHashInfo[]::new)));\n+                    case ModuleMainClassAttribute a -> clb.with(ModuleMainClassAttribute.of(a.mainClass().asSymbol()));\n+                    case ModulePackagesAttribute a -> clb.with(ModulePackagesAttribute.ofNames(a.packages().stream().map(PackageEntry::asSymbol).toArray(PackageDesc[]::new)));\n+                    case ModuleResolutionAttribute a -> clb.with(ModuleResolutionAttribute.of(a.resolutionFlags()));\n+                    case ModuleTargetAttribute a -> clb.with(ModuleTargetAttribute.of(a.targetPlatform().stringValue()));\n+                    case NestHostAttribute a -> clb.with(NestHostAttribute.of(a.nestHost().asSymbol()));\n+                    case NestMembersAttribute a -> clb.with(NestMembersAttribute.ofSymbols(a.nestMembers().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new)));\n+                    case PermittedSubclassesAttribute a -> clb.with(PermittedSubclassesAttribute.ofSymbols(a.permittedSubclasses().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new)));\n+                    case RecordAttribute a -> clb.with(RecordAttribute.of(a.components().stream().map(rci ->\n+                            RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((rca, rcac) -> {\n+                                    switch(rca) {\n+                                        case RuntimeInvisibleAnnotationsAttribute riaa -> rcac.accept(RuntimeInvisibleAnnotationsAttribute.of(transformAnnotations(riaa.annotations())));\n+                                        case RuntimeInvisibleTypeAnnotationsAttribute ritaa -> rcac.accept(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(ritaa.annotations(), null, null)));\n+                                        case RuntimeVisibleAnnotationsAttribute rvaa -> rcac.accept(RuntimeVisibleAnnotationsAttribute.of(transformAnnotations(rvaa.annotations())));\n+                                        case RuntimeVisibleTypeAnnotationsAttribute rvtaa -> rcac.accept(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(rvtaa.annotations(), null, null)));\n+                                        case SignatureAttribute sa -> rcac.accept(SignatureAttribute.of(Signature.parseFrom(sa.asTypeSignature().signatureString())));\n+                                        default -> throw new AssertionError(\"Unexpected record component attribute: \" + rca.attributeName());\n+                                    }}).toArray(Attribute[]::new))).toArray(RecordComponentInfo[]::new)));\n+                    case RuntimeInvisibleAnnotationsAttribute a -> clb.with(RuntimeInvisibleAnnotationsAttribute.of(transformAnnotations(a.annotations())));\n+                    case RuntimeInvisibleTypeAnnotationsAttribute a -> clb.with(RuntimeInvisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), null, null)));\n+                    case RuntimeVisibleAnnotationsAttribute a -> clb.with(RuntimeVisibleAnnotationsAttribute.of(transformAnnotations(a.annotations())));\n+                    case RuntimeVisibleTypeAnnotationsAttribute a -> clb.with(RuntimeVisibleTypeAnnotationsAttribute.of(transformTypeAnnotations(a.annotations(), null, null)));\n+                    case SignatureAttribute a -> clb.with(SignatureAttribute.of(ClassSignature.parseFrom(a.asClassSignature().signatureString())));\n+                    case SourceDebugExtensionAttribute a -> clb.with(SourceDebugExtensionAttribute.of(a.contents()));\n+                    case SourceFileAttribute a -> clb.with(SourceFileAttribute.of(a.sourceFile().stringValue()));\n+                    case SourceIDAttribute a -> clb.with(SourceIDAttribute.of(a.sourceId().stringValue()));\n+                    case SyntheticAttribute a -> clb.with(SyntheticAttribute.of());\n+                    case CustomAttribute a -> throw new AssertionError(\"Unexpected custom attribute: \" + a.attributeName());\n+                    case UnknownAttribute a -> throw new AssertionError(\"Unexpected unknown attribute: \" + a.attributeName());\n+                }\n+            }\n+        });\n+    }\n+\n+    static Annotation[] transformAnnotations(List<Annotation> annotations) {\n+        return annotations.stream().map(a -> transformAnnotation(a)).toArray(Annotation[]::new);\n+    }\n+\n+    static Annotation transformAnnotation(Annotation a) {\n+        return Annotation.of(a.classSymbol(), a.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toArray(AnnotationElement[]::new));\n+    }\n+\n+    static AnnotationValue transformAnnotationValue(AnnotationValue av) {\n+        return switch (av) {\n+            case AnnotationValue.OfAnnotation oa -> AnnotationValue.ofAnnotation(transformAnnotation(oa.annotation()));\n+            case AnnotationValue.OfArray oa -> AnnotationValue.ofArray(oa.values().stream().map(v -> transformAnnotationValue(v)).toArray(AnnotationValue[]::new));\n+            case AnnotationValue.OfString v -> AnnotationValue.of(v.stringValue());\n+            case AnnotationValue.OfDouble v -> AnnotationValue.of(v.doubleValue());\n+            case AnnotationValue.OfFloat v -> AnnotationValue.of(v.floatValue());\n+            case AnnotationValue.OfLong v -> AnnotationValue.of(v.longValue());\n+            case AnnotationValue.OfInteger v -> AnnotationValue.of(v.intValue());\n+            case AnnotationValue.OfShort v -> AnnotationValue.of(v.shortValue());\n+            case AnnotationValue.OfCharacter v -> AnnotationValue.of(v.charValue());\n+            case AnnotationValue.OfByte v -> AnnotationValue.of(v.byteValue());\n+            case AnnotationValue.OfBoolean v -> AnnotationValue.of(v.booleanValue());\n+            case AnnotationValue.OfClass oc -> AnnotationValue.of(oc.classSymbol());\n+            case AnnotationValue.OfEnum oe -> AnnotationValue.ofEnum(oe.classSymbol(), oe.constantName().stringValue());\n+        };\n+    }\n+\n+    static TypeAnnotation[] transformTypeAnnotations(List<TypeAnnotation> annotations, CodeBuilder cob, HashMap<Label, Label> labels) {\n+        return annotations.stream().map(ta -> TypeAnnotation.of(\n+                        transformTargetInfo(ta.targetInfo(), cob, labels),\n+                        ta.targetPath().stream().map(tpc -> TypeAnnotation.TypePathComponent.of(tpc.typePathKind(), tpc.typeArgumentIndex())).toList(),\n+                        ta.classSymbol(),\n+                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+    }\n+\n+    static TypeAnnotation.TargetInfo transformTargetInfo(TypeAnnotation.TargetInfo ti, CodeBuilder cob, HashMap<Label, Label> labels) {\n+        return switch (ti) {\n+            case TypeAnnotation.CatchTarget t -> TypeAnnotation.TargetInfo.ofExceptionParameter(t.exceptionTableIndex());\n+            case TypeAnnotation.EmptyTarget t -> TypeAnnotation.TargetInfo.of(t.targetType());\n+            case TypeAnnotation.FormalParameterTarget t -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(t.formalParameterIndex());\n+            case TypeAnnotation.SupertypeTarget t -> TypeAnnotation.TargetInfo.ofClassExtends(t.supertypeIndex());\n+            case TypeAnnotation.ThrowsTarget t -> TypeAnnotation.TargetInfo.ofThrows(t.throwsTargetIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget t -> TypeAnnotation.TargetInfo.ofTypeParameterBound(t.targetType(), t.typeParameterIndex(), t.boundIndex());\n+            case TypeAnnotation.TypeParameterTarget t -> TypeAnnotation.TargetInfo.ofTypeParameter(t.targetType(), t.typeParameterIndex());\n+            case TypeAnnotation.LocalVarTarget t -> TypeAnnotation.TargetInfo.ofVariable(t.targetType(), t.table().stream().map(lvti ->\n+                            TypeAnnotation.LocalVarTargetInfo.of(labels.computeIfAbsent(lvti.startLabel(), l -> cob.newLabel()),\n+                            labels.computeIfAbsent(lvti.endLabel(), l -> cob.newLabel()), lvti.index())).toList());\n+            case TypeAnnotation.OffsetTarget t -> TypeAnnotation.TargetInfo.ofOffset(t.targetType(), labels.computeIfAbsent(t.target(), l -> cob.newLabel()));\n+            case TypeAnnotation.TypeArgumentTarget t -> TypeAnnotation.TargetInfo.ofTypeArgument(t.targetType(),\n+                            labels.computeIfAbsent(t.target(), l -> cob.newLabel()), t.typeArgumentIndex());\n+        };\n+    }\n+\n+    static List<StackMapTableAttribute.VerificationTypeInfo> transformFrameTypeInfos(List<StackMapTableAttribute.VerificationTypeInfo> infos, CodeBuilder cob, HashMap<Label, Label> labels) {\n+        return infos.stream().map(ti -> {\n+            return switch (ti) {\n+                case StackMapTableAttribute.SimpleVerificationTypeInfo i -> i;\n+                case StackMapTableAttribute.ObjectVerificationTypeInfo i -> StackMapTableAttribute.ObjectVerificationTypeInfo.of(i.classSymbol());\n+                case StackMapTableAttribute.UninitializedVerificationTypeInfo i -> StackMapTableAttribute.UninitializedVerificationTypeInfo.of(labels.computeIfAbsent(i.newTarget(), l -> cob.newLabel()));\n+            };\n+        }).toList();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":590,"deletions":0,"binary":false,"changes":590,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+\/**\n+ * TestConstants\n+ *\/\n+public class TestConstants {\n+    public static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    public static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    public static final ClassDesc CD_ArrayList = ClassDesc.of(\"java.util.ArrayList\");\n+\n+    public static final MethodTypeDesc MTD_INT_VOID = MethodTypeDesc.ofDescriptor(\"(I)V\");\n+    public static final MethodTypeDesc MTD_VOID = MethodTypeDesc.ofDescriptor(\"()V\");\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/TestConstants.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import jdk.internal.classfile.impl.LabelContext;\n+import jdk.internal.classfile.impl.LabelImpl;\n+import jdk.internal.classfile.instruction.LocalVariable;\n+import jdk.internal.classfile.instruction.LocalVariableType;\n+\n+import java.io.FileOutputStream;\n+import java.util.Collection;\n+\n+public class TestUtil {\n+\n+    public static void assertEmpty(Collection<?> col) {\n+        if (!col.isEmpty()) throw new AssertionError(col);\n+    }\n+\n+    public static void writeClass(byte[] bytes, String fn) {\n+        try {\n+            FileOutputStream out = new FileOutputStream(fn);\n+            out.write(bytes);\n+            out.close();\n+        } catch (Exception ex) {\n+            throw new InternalError(ex);\n+        }\n+    }\n+\n+\n+    public static class ExpectedLvRecord {\n+        int slot;\n+        String desc;\n+        String name;\n+        int start;\n+        int length;\n+\n+        ExpectedLvRecord(int slot, String name, String desc, int start, int length) {\n+            this.slot = slot;\n+            this.name = name;\n+            this.desc = desc;\n+            this.start = start;\n+            this.length = length;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other instanceof LocalVariable l) {\n+                LabelContext ctx = ((LabelImpl) l.startScope()).labelContext();\n+                if (!(slot == l.slot() &&\n+                       desc.equals(l.type().stringValue()) &&\n+                       name.equals(l.name().stringValue()) &&\n+                        ctx.labelToBci(l.startScope()) == start &&\n+                        ctx.labelToBci(l.endScope()) - start == length)) throw new RuntimeException(l.slot() + \" \" + l.name().stringValue() + \" \" + l.type().stringValue() + \" \" + ctx.labelToBci(l.startScope()) + \" \" + (ctx.labelToBci(l.endScope()) - start));\n+                return slot == l.slot() &&\n+                       desc.equals(l.type().stringValue()) &&\n+                       name.equals(l.name().stringValue()) &&\n+                        ctx.labelToBci(l.startScope()) == start &&\n+                        ctx.labelToBci(l.endScope()) - start == length;\n+            }\n+\n+    throw new RuntimeException(other.toString());\n+\/\/            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode();\n+        }\n+\n+        public static ExpectedLvRecord of(int slot, String name, String desc, int start, int length) {\n+            return new ExpectedLvRecord(slot, name, desc, start, length);\n+        }\n+    }\n+\n+    public static class ExpectedLvtRecord {\n+        int slot;\n+        String signature;\n+        String name;\n+        int start;\n+        int length;\n+\n+        ExpectedLvtRecord(int slot, String name, String signature, int start, int length) {\n+            this.slot = slot;\n+            this.name = name;\n+            this.signature = signature;\n+            this.start = start;\n+            this.length = length;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other instanceof LocalVariableType l) {\n+                LabelContext ctx = ((LabelImpl) l.startScope()).labelContext();\n+                return slot == l.slot() &&\n+                       signature.equals(l.signature().stringValue()) &&\n+                       name.equals(l.name().stringValue()) &&\n+                        ctx.labelToBci(l.startScope()) == start &&\n+                        ctx.labelToBci(l.endScope()) - start == length;\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode();\n+        }\n+\n+        public static ExpectedLvtRecord of(int slot, String name, String signature, int start, int length) {\n+            return new ExpectedLvtRecord(slot, name, signature, start, length);\n+        }\n+\n+        public String toString() {\n+            return \"LocalVariableType[slot=\" +slot + \", name=\" + name + \", sig=\" + signature +\", start=\" + start + \", length=\" + length +\"]\";\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/TestUtil.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,592 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package helpers;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.ModuleVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n+import jdk.internal.org.objectweb.asm.TypePath;\n+import jdk.internal.org.objectweb.asm.tree.ClassNode;\n+\n+\/**\n+ * Transforms\n+ *\/\n+public class Transforms {\n+\n+    static int ASM9 = 9 << 16 | 0 << 8;\n+\n+    public static final ClassTransform threeLevelNoop = (cb, ce) -> {\n+        if (ce instanceof MethodModel mm) {\n+            cb.transformMethod(mm, (mb, me) -> {\n+                if (me instanceof CodeModel xm) {\n+                    mb.transformCode(xm, CodeTransform.ACCEPT_ALL);\n+                }\n+                else\n+                    mb.with(me);\n+            });\n+        }\n+        else\n+            cb.with(ce);\n+    };\n+\n+    private static final ClassTransform threeLevelNoopPipedCMC_seed = (cb, ce) -> {\n+        if (ce instanceof MethodModel mm) {\n+            MethodTransform transform = (mb, me) -> {\n+                if (me instanceof CodeModel xm) {\n+                    mb.transformCode(xm, CodeTransform.ACCEPT_ALL.andThen(CodeTransform.ACCEPT_ALL));\n+                }\n+                else\n+                    mb.with(me);\n+            };\n+            cb.transformMethod(mm, transform);\n+        }\n+        else\n+            cb.with(ce);\n+    };\n+\n+    static final ClassTransform twoLevelNoop = (cb, ce) -> {\n+        if (ce instanceof MethodModel mm) {\n+            cb.transformMethod(mm, MethodTransform.ACCEPT_ALL);\n+        }\n+        else\n+            cb.with(ce);\n+    };\n+\n+    static final ClassTransform oneLevelNoop = ClassTransform.ACCEPT_ALL;\n+\n+    public static final List<ClassTransform> noops = List.of(threeLevelNoop, twoLevelNoop, oneLevelNoop);\n+\n+    public enum NoOpTransform {\n+        ARRAYCOPY(bytes -> {\n+            byte[] bs = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, bs, 0, bytes.length);\n+            return bs;\n+        }),\n+        BUILD_FROM_SCRATCH(bytes -> {\n+            return RebuildingTransformation.transform(Classfile.parse(bytes));\n+        }),\n+        SHARED_1(true, oneLevelNoop),\n+        SHARED_2(true, twoLevelNoop),\n+        SHARED_3(true, threeLevelNoop),\n+        SHARED_3P(true, threeLevelNoop.andThen(threeLevelNoop)),\n+        SHARED_3L(true, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)),\n+        SHARED_3Sx(true, threeLevelNoopPipedCMC_seed.andThen(ClassTransform.ACCEPT_ALL)),\n+        SHARED_3bc(true, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL))),\n+        UNSHARED_1(false, oneLevelNoop),\n+        UNSHARED_2(false, twoLevelNoop),\n+        UNSHARED_3(false, threeLevelNoop),\n+        SHARED_3_NO_STACKMAP(true, threeLevelNoop, Classfile.Option.generateStackmap(false)),\n+        SHARED_3_NO_DEBUG(true, threeLevelNoop, Classfile.Option.processDebug(false), Classfile.Option.processLineNumbers(false)),\n+        ASM_1(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(cw, 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_UNSHARED_1(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(cw, 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_3(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(new CustomClassVisitor(cw), 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_UNSHARED_3(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(new CustomClassVisitor(cw), 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_TREE(bytes -> {\n+            ClassNode node = new ClassNode();\n+            ClassReader cr = new ClassReader(bytes);\n+            cr.accept(node, 0);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            node.accept(cw);\n+            return cw.toByteArray();\n+        }),\n+        CLASS_REMAPPER(bytes ->\n+                ClassRemapper.of(Map.of()).remapClass(Classfile.parse(bytes)));\n+\n+        \/\/ Need ASM, LOW_UNSHARED\n+\n+        public final UnaryOperator<byte[]> transform;\n+        public final boolean shared;\n+        public final ClassTransform classTransform;\n+        public final Classfile.Option[] options;\n+\n+        NoOpTransform(UnaryOperator<byte[]> transform) {\n+            this.transform = transform;\n+            classTransform = null;\n+            shared = false;\n+            options = new Classfile.Option[0];\n+        }\n+\n+        NoOpTransform(boolean shared,\n+                      ClassTransform classTransform,\n+                      Classfile.Option... options) {\n+            this.shared = shared;\n+            this.classTransform = classTransform;\n+            this.options = shared\n+                           ? options\n+                           : Stream.concat(Stream.of(options), Stream.of(Classfile.Option.constantPoolSharing(false))).toArray(Classfile.Option[]::new);\n+            this.transform = bytes -> Classfile.parse(bytes, this.options).transform(classTransform);\n+        }\n+\n+        public Optional<ClassRecord> classRecord(byte[] bytes) throws IOException {\n+            return switch (this) {\n+                case ARRAYCOPY -> Optional.of(ClassRecord.ofClassModel(Classfile.parse(bytes)));\n+                case SHARED_1, SHARED_2, SHARED_3,\n+                        UNSHARED_1, UNSHARED_2, UNSHARED_3,\n+                            BUILD_FROM_SCRATCH\n+                        -> Optional.of(ClassRecord.ofClassModel(Classfile.parse(bytes), ClassRecord.CompatibilityFilter.By_ClassBuilder));\n+                default -> Optional.empty();\n+            };\n+        }\n+    }\n+\n+    public enum InjectNopTransform {\n+        ASM_NOP_SHARED(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(new NopClassVisitor(cw), 0);\n+            return cw.toByteArray();\n+        }),\n+        NOP_SHARED(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return cm.transform((cb, ce) -> {\n+                if (ce instanceof MethodModel mm) {\n+                    cb.transformMethod(mm, (mb, me) -> {\n+                        if (me instanceof CodeModel xm) {\n+                            mb.withCode(xb -> {\n+                                xb.nopInstruction();\n+                                xm.forEachElement(new Consumer<>() {\n+                                    @Override\n+                                    public void accept(CodeElement e) {\n+                                        xb.with(e);\n+                                    }\n+                                });\n+                            });\n+                        }\n+                        else\n+                            mb.with(me);\n+                    });\n+                }\n+                else\n+                    cb.with(ce);\n+            });\n+        });\n+\n+        public final UnaryOperator<byte[]> transform;\n+\n+        InjectNopTransform(UnaryOperator<byte[]> transform) {\n+            this.transform = transform;\n+        }\n+    }\n+\n+    public enum SimpleTransform {\n+        ASM_ADD_FIELD(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(cw, 0);\n+            cw.visitField(0, \"argleBargleWoogaWooga\", \"I\", null, null);\n+            return cw.toByteArray();\n+        }),\n+        HIGH_SHARED_ADD_FIELD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return cm.transform(new ClassTransform() {\n+                @Override\n+                public void accept(ClassBuilder builder, ClassElement element) {\n+                    builder.with(element);\n+                }\n+\n+                @Override\n+                public void atEnd(ClassBuilder builder) {\n+                    builder.withField(\"argleBargleWoogaWooga\", ConstantDescs.CD_int, b -> { });\n+                }\n+            });\n+        }),\n+        HIGH_UNSHARED_ADD_FIELD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return Classfile.build(cm.thisClass().asSymbol(),\n+                                   cb -> {\n+                                       cm.forEachElement(cb);\n+                                       cb.withField(\"argleBargleWoogaWooga\", ConstantDescs.CD_int, b -> { });\n+                                   });\n+        }),\n+        ASM_DEL_METHOD(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            ClassVisitor v = new ClassVisitor(ASM9, cw) {\n+                @Override\n+                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+                    return (name.equals(\"hashCode\") && descriptor.equals(\"()Z\"))\n+                           ? null\n+                           : super.visitMethod(access, name, descriptor, signature, exceptions);\n+                }\n+            };\n+            cr.accept(cw, 0);\n+            return cw.toByteArray();\n+        }),\n+        HIGH_SHARED_DEL_METHOD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return cm.transform((builder, element) -> {\n+                if (!(element instanceof MethodModel mm))\n+                    builder.with(element);\n+            });\n+        }),\n+        HIGH_UNSHARED_DEL_METHOD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return Classfile.build(cm.thisClass().asSymbol(),\n+                                   cb -> {\n+                                       cm.forEachElement(element -> {\n+                                           if (element instanceof MethodModel mm\n+                                               && mm.methodName().stringValue().equals(\"hashCode\")\n+                                               && mm.methodType().stringValue().equals(\"()Z\")) {\n+\n+                                           }\n+                                           else\n+                                               cb.with(element);\n+                                       });\n+                                   });\n+        });\n+\n+        public final UnaryOperator<byte[]> transform;\n+\n+        SimpleTransform(UnaryOperator<byte[]> transform) {\n+            this.transform = transform;\n+        }\n+    }\n+\n+    static class CustomClassVisitor extends ClassVisitor {\n+\n+        public CustomClassVisitor(ClassVisitor writer) {\n+            super(ASM9, writer);\n+        }\n+\n+        @Override\n+        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            super.visit(version, access, name, signature, superName, interfaces);\n+        }\n+\n+        @Override\n+        public void visitSource(String source, String debug) {\n+            super.visitSource(source, debug);\n+        }\n+\n+        @Override\n+        public ModuleVisitor visitModule(String name, int access, String version) {\n+            return super.visitModule(name, access, version);\n+        }\n+\n+        @Override\n+        public void visitNestHost(String nestHost) {\n+            super.visitNestHost(nestHost);\n+        }\n+\n+        @Override\n+        public void visitOuterClass(String owner, String name, String descriptor) {\n+            super.visitOuterClass(owner, name, descriptor);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAttribute(Attribute attribute) {\n+            super.visitAttribute(attribute);\n+        }\n+\n+        @Override\n+        public void visitNestMember(String nestMember) {\n+            super.visitNestMember(nestMember);\n+        }\n+\n+        @Override\n+        public void visitInnerClass(String name, String outerName, String innerName, int access) {\n+            super.visitInnerClass(name, outerName, innerName, access);\n+        }\n+\n+        @Override\n+        public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {\n+            return super.visitRecordComponent(name, descriptor, signature);\n+        }\n+\n+        @Override\n+        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+            return super.visitField(access, name, descriptor, signature, value);\n+        }\n+\n+        @Override\n+        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n+            return new CustomMethodVisitor(mv);\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+        }\n+    };\n+\n+\n+    static class CustomMethodVisitor extends MethodVisitor {\n+\n+        public CustomMethodVisitor(MethodVisitor methodVisitor) {\n+            super(ASM9, methodVisitor);\n+        }\n+\n+        @Override\n+        public void visitParameter(String name, int access) {\n+            super.visitParameter(name, access);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotationDefault() {\n+            return super.visitAnnotationDefault();\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n+            super.visitAnnotableParameterCount(parameterCount, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {\n+            return super.visitParameterAnnotation(parameter, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAttribute(Attribute attribute) {\n+            super.visitAttribute(attribute);\n+        }\n+\n+        @Override\n+        public void visitCode() {\n+            super.visitCode();\n+        }\n+\n+        @Override\n+        public void visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack) {\n+            super.visitFrame(type, numLocal, local, numStack, stack);\n+        }\n+\n+        @Override\n+        public void visitInsn(int opcode) {\n+            super.visitInsn(opcode);\n+        }\n+\n+        @Override\n+        public void visitIntInsn(int opcode, int operand) {\n+            super.visitIntInsn(opcode, operand);\n+        }\n+\n+        @Override\n+        public void visitVarInsn(int opcode, int var) {\n+            super.visitVarInsn(opcode, var);\n+        }\n+\n+        @Override\n+        public void visitTypeInsn(int opcode, String type) {\n+            super.visitTypeInsn(opcode, type);\n+        }\n+\n+        @Override\n+        public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n+            super.visitFieldInsn(opcode, owner, name, descriptor);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public void visitMethodInsn(int opcode, String owner, String name, String descriptor) {\n+            super.visitMethodInsn(opcode, owner, name, descriptor);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n+            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n+        }\n+\n+        @Override\n+        public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n+            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n+        }\n+\n+        @Override\n+        public void visitJumpInsn(int opcode, Label label) {\n+            super.visitJumpInsn(opcode, label);\n+        }\n+\n+        @Override\n+        public void visitLabel(Label label) {\n+            super.visitLabel(label);\n+        }\n+\n+        @Override\n+        public void visitLdcInsn(Object value) {\n+            super.visitLdcInsn(value);\n+        }\n+\n+        @Override\n+        public void visitIincInsn(int var, int increment) {\n+            super.visitIincInsn(var, increment);\n+        }\n+\n+        @Override\n+        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\n+            super.visitTableSwitchInsn(min, max, dflt, labels);\n+        }\n+\n+        @Override\n+        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n+            super.visitLookupSwitchInsn(dflt, keys, labels);\n+        }\n+\n+        @Override\n+        public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {\n+            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n+            super.visitTryCatchBlock(start, end, handler, type);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {\n+            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String descriptor, boolean visible) {\n+            return super.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitLineNumber(int line, Label start) {\n+            super.visitLineNumber(line, start);\n+        }\n+\n+        @Override\n+        public void visitMaxs(int maxStack, int maxLocals) {\n+            super.visitMaxs(maxStack, maxLocals);\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+        }\n+    };\n+\n+    static class NopClassVisitor extends CustomClassVisitor {\n+\n+        public NopClassVisitor(ClassVisitor writer) {\n+            super(writer);\n+        }\n+\n+        @Override\n+        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n+            return new NopMethodVisitor(mv);\n+        }\n+    }\n+\n+    static class NopMethodVisitor extends CustomMethodVisitor {\n+\n+        public NopMethodVisitor(MethodVisitor methodVisitor) {\n+            super(methodVisitor);\n+        }\n+\n+        @Override\n+        public void visitCode() {\n+            super.visitCode();\n+            visitInsn(Opcodes.NOP);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":592,"deletions":0,"binary":false,"changes":592,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+import java.util.*;\n+\n+public class Lvt {\n+    public void m(String a) {\n+        int b;\n+        Object c;\n+        char[] d = new char[27];\n+\n+        for (int j = 0; j < d.length; j++) {\n+            char x = d[j];\n+        }\n+    }\n+\n+    public <U> List<String> n(U u, Class <? extends List<?>> z) {\n+        var v = new ArrayList<Integer>();\n+\n+        Set<? super Set<?>> s = new TreeSet<>();\n+\n+        for (List<?> f : new ArrayList<List<Object>>()) {\n+            System.out.println(f);\n+        }\n+\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Lvt.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public final class Pattern1 {\n+\n+    static void troublesCausingMethod() {\n+        Object[] obj = null;\n+        boolean match;\n+        for (int i = 0; i < obj.length; i++) {\n+            match = false;\n+            for (int j = 0; j < obj.length; j++) {\n+                if (obj[i].equals(obj[j])) {\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            if (!match) {\n+                return;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern1.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public class Pattern10 {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static void troublesCausingMethod(Object arg) {\n+        boolean b = true;\n+        if (b) {\n+            var v = new byte[0];\n+        } else {\n+            var v = new int[0];\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern10.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class Pattern2 {\n+\n+    static void troublesCausingMethod() {\n+        String s = null;\n+        Object o;\n+        Map<String, Object> map = null;\n+        List<String> list = null;\n+        if (s == null) return;\n+        for (int i = 0; i < 10; i++) {\n+            String key = \"\";\n+            if (map.containsKey(key)) {\n+                o = map.get(key);\n+            } else {\n+                o = new Object();\n+                map.put(key, o);\n+            }\n+            Object bais = new Object();\n+            try {\n+                list.add(o.toString());\n+            } catch (Exception ce) {\n+                throw ce;\n+            }\n+            bais.toString();\n+        }\n+        if (list != null) {}\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern2.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public class Pattern3 {\n+\n+    private String file;\n+\n+    void troublesCausingMethod() {\n+        String path = null;\n+        String query = null;\n+        this.file = query == null ? path : path + query;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern3.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public class Pattern4 {\n+\n+    static void troublesCausingMethod() {\n+        try {\n+            Object o = null;\n+            try {\n+                o = null;\n+            } catch (Exception e) {\n+                if (o != null) o = null;\n+            }\n+            if (o != null) {}\n+        } catch (Exception e) {}\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern4.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public class Pattern5 {\n+\n+    String troublesCausingMethod() {\n+        Object o = null;\n+        String t;\n+        if (o != null || (t = o.toString()) == null) {\n+            t = toString();\n+        }\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern5.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public class Pattern6 {\n+\n+        static void troublesCausingMethod() {\n+            boolean b = true;\n+            String s1 = null;\n+            String s2;\n+            if (s1 != null) {\n+                s2 = s1;\n+            } else {\n+                try {\n+                    s2 = null;\n+                    if (b) {}\n+                    s2.equals(null);\n+                } catch (Error ex) {\n+                    throw ex;\n+                }\n+            }\n+            if (null == s2) {}\n+        }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern6.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+public class Pattern7 {\n+\n+    static void troublesCausingMethod() {\n+        Object r = null;\n+        Boolean e = null;\n+        String x;\n+        String d = null;\n+        if (r instanceof Integer && (x = ((Integer) r).toString()) != null) {\n+            d = x + r.toString();\n+        } else  {\n+            if (e != null) {}\n+        }\n+        d.chars();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern7.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+import java.util.Vector;\n+\n+public class Pattern8 {\n+    private Vector<int[]>   expandTable = null;\n+        private static final int INITIALTABLESIZE = 20;\n+\n+   private int addExpansion(int anOrder, String expandChars) {\n+        if (expandTable == null) {\n+            expandTable = new Vector<>(INITIALTABLESIZE);\n+        }\n+\n+        \/\/ If anOrder is valid, we want to add it at the beginning of the list\n+        int offset = (anOrder == 13) ? 0 : 1;\n+\n+        int[] valueList = new int[expandChars.length() + offset];\n+        if (offset == 1) {\n+            valueList[0] = anOrder;\n+        }\n+\n+        int j = offset;\n+        for (int i = 0; i < expandChars.length(); i++) {\n+            char ch0 = expandChars.charAt(i);\n+            char ch1;\n+            int ch;\n+            if (Character.isHighSurrogate(ch0)) {\n+                if (++i == expandChars.length() ||\n+                    !Character.isLowSurrogate(ch1=expandChars.charAt(i))) {\n+                    \/\/ether we are missing the low surrogate or the next char\n+                    \/\/is not a legal low surrogate, so stop loop\n+                    break;\n+                }\n+                ch = Character.toCodePoint(ch0, ch1);\n+\n+            } else {\n+                ch = ch0;\n+            }\n+\n+            int mapValue = ch;\n+\n+            if (mapValue !=  0xFFFFFFFF) {\n+                valueList[j++] = mapValue;\n+            } else {\n+                \/\/ can't find it in the table, will be filled in by commit().\n+                valueList[j++] = 0x70000000 + ch;\n+            }\n+        }\n+        if (j < valueList.length) {\n+            \/\/we had at least one supplementary character, the size of valueList\n+            \/\/is bigger than it really needs...\n+            int[] tmpBuf = new int[j];\n+            while (--j >= 0) {\n+                tmpBuf[j] = valueList[j];\n+            }\n+            valueList = tmpBuf;\n+        }\n+        \/\/ Add the expanding char list into the expansion table.\n+        int tableIndex = 10 + expandTable.size();\n+        expandTable.addElement(valueList);\n+\n+        return tableIndex;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern8.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+import java.lang.reflect.RecordComponent;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class Pattern9 {\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static void troublesCausingMethod(Object arg) {\n+        if (arg instanceof Record) {\n+            for (RecordComponent rc : arg.getClass().getRecordComponents()) {}\n+        } else if (arg instanceof Optional actualOpt) {\n+        } else {\n+            if (arg instanceof Set actualSet) {}\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/Pattern9.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package testdata;\n+\n+import static java.lang.annotation.ElementType.*;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TypeAnnotationPattern {\n+\n+    class Middle {\n+        class Inner {}\n+    }\n+\n+    @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface Foo {\n+    }\n+\n+    @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER, TYPE_USE})\n+    @Retention(RetentionPolicy.CLASS)\n+    @interface Bar {\n+    }\n+\n+    @Foo String @Bar [][]  fa;\n+    String @Foo [] @Bar[] fb;\n+    @Bar String[] @Foo [] fc;\n+\n+    @Foo TypeAnnotationPattern.@Bar Middle.Inner fd;\n+    TypeAnnotationPattern.@Foo Middle.@Bar Inner fe;\n+    @Bar TypeAnnotationPattern.Middle.@Foo Inner ff;\n+\n+    @Foo Map<@Bar String,Object> fg;\n+    Map<@Foo String,@Bar Object> fh;\n+    @Bar Map<String,@Foo Object> fi;\n+\n+    List<@Foo ? extends @Bar String> fj;\n+    List<@Bar ? extends @Foo String> fk;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <E> void annotatedCode(\n+        @Foo String @Bar [][]  mpa,\n+        String @Foo [] @Bar[] mpb,\n+        @Bar String[] @Foo [] mpc,\n+\n+        @Foo TypeAnnotationPattern.@Bar Middle.Inner mpd,\n+        TypeAnnotationPattern.@Foo Middle.@Bar Inner mpe,\n+        @Bar TypeAnnotationPattern.Middle.@Foo Inner mpf,\n+\n+        @Foo Map<@Bar String,Object> mpg,\n+        Map<@Foo String,@Bar Object> mph,\n+        @Bar Map<String,@Foo Object> mpi,\n+\n+        List<@Foo ? extends @Bar String> mpj,\n+        List<@Bar ? extends @Foo String> mpk\n+    ) {\n+        @Foo String[][]  lva;\n+\/\/        String @Foo [][] lvb; \/\/ AssertionError from javac\n+\/\/        String[] @Foo [] lvc; \/\/ AssertionError from javac\n+\n+        @Foo TypeAnnotationPattern.@Bar Middle.Inner lvd;\n+\/\/        TypeAnnotationPattern.@Foo Middle.@Bar Inner lve; \/\/ AssertionError from javac\n+\/\/        @Bar TypeAnnotationPattern.Middle.@Foo Inner lvf; \/\/ AssertionError from javac\n+\n+        @Foo Map<@Bar String,Object> lvg;\n+        Map<@Foo String,@Bar Object> lvh;\n+        @Bar Map<String,@Foo Object> lvi;\n+\n+        List<@Foo ? extends @Bar String> lvj;\n+        List<@Bar ? extends @Foo String> lvk;\n+\n+        Object o = null;\n+\/\/        var cea = (@Foo String [][]) o; \/\/ AssertionError from javac\n+\/\/        var ceb = (String @Foo [] @Bar[]) o; \/\/ AssertionError from javac\n+\/\/        var cec = (@Bar String[] @Foo []) o; \/\/ AssertionError from javac\n+\n+        var ced = (@Foo TypeAnnotationPattern.@Bar Middle.Inner) o;\n+\/\/        var cee = (TypeAnnotationPattern.@Foo Middle.@Bar Inner) o; \/\/ AssertionError from javac\n+\/\/        var cef = (@Bar TypeAnnotationPattern.Middle.@Foo Inner) o; \/\/ AssertionError from javac\n+\n+\/\/        var ceg = (@Foo Map<@Bar String,Object> ) o; \/\/ AssertionError from javac\n+        var ceh = (Map<@Foo String,@Bar Object>) o;\n+\/\/        var cei = (@Bar Map<String,@Foo Object>) o; \/\/ AssertionError from javac\n+\n+        var cej = (List<@Foo ? extends @Bar String>) o;\n+        var cek = (List<@Bar ? extends @Foo String>) o;\n+\n+\/\/        var na = new @Foo String [][] {}; \/\/ AssertionError from javac\n+\/\/        var nb = new String @Foo [] @Bar[] {}; \/\/ AssertionError from javac\n+\/\/        var nc = new @Bar String[] @Foo [] {}; \/\/ AssertionError from javac\n+\n+\/\/        var ng = new @Foo HashMap<@Bar String,Object>(); \/\/ AssertionError from javac\n+        var nh = new HashMap<@Foo String,@Bar Object>();\n+\/\/        var ni = new @Bar HashMap<String,@Foo Object>(); \/\/ AssertionError from javac\n+\n+\/\/        if (o instanceof @Foo String [][]) {} \/\/ AssertionError from javac\n+\/\/        if (o instanceof String @Foo [] @Bar[]) {} \/\/ AssertionError from javac\n+\/\/        if (o instanceof @Bar String[] @Foo []) {} \/\/ AssertionError from javac\n+\n+        if (o instanceof @Foo TypeAnnotationPattern.Middle.Inner) {}\n+\/\/        if (o instanceof TypeAnnotationPattern.@Foo Middle.@Bar Inner) {} \/\/ AssertionError from javac\n+\/\/        if (o instanceof @Bar TypeAnnotationPattern.Middle.@Foo Inner) {} \/\/ AssertionError from javac\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/testdata\/TypeAnnotationPattern.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * AbstractCorpusBenchmark\n+ *\/\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 4)\n+@Fork(1)\n+@State(Scope.Benchmark)\n+public class AbstractCorpusBenchmark {\n+    protected byte[][] classes;\n+\n+    @Setup\n+    public void setup() {\n+        classes = rtJarToBytes(FileSystems.getFileSystem(URI.create(\"jrt:\/\")));\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        \/\/nop\n+    }\n+\n+    private static byte[][] rtJarToBytes(FileSystem fs) {\n+        try {\n+            var modules = Stream.of(\n+                    Files.walk(fs.getPath(\"modules\/java.base\/java\")),\n+                    Files.walk(fs.getPath(\"modules\"), 2).filter(p -> p.endsWith(\"module-info.class\")))\n+                                .flatMap(p -> p)\n+                                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+                                .map(AbstractCorpusBenchmark::readAllBytes)\n+                                .toArray(byte[][]::new);\n+            return modules;\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    private static byte[] readAllBytes(Path p) {\n+        try {\n+            return Files.readAllBytes(p);\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AbstractCorpusBenchmark.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeTransform;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * AdHocAdapt\n+ *\/\n+public class AdHocAdapt extends AbstractCorpusBenchmark {\n+    public enum X {\n+        LIFT(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)),\n+        LIFT1(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL\n+                                                          .andThen(CodeTransform.ACCEPT_ALL))),\n+        LIFT2(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                            .andThen(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)));\n+\n+        ClassTransform transform;\n+\n+        X(ClassTransform transform) {\n+            this.transform = transform;\n+        }\n+    }\n+\n+    @Param\n+    X transform;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transform(Blackhole bh) {\n+        for (byte[] bytes : classes)\n+            bh.consume(Classfile.parse(bytes).transform(transform.transform));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdHocAdapt.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * AdaptInjectNoop\n+ *\/\n+public class AdaptInjectNoop extends AbstractCorpusBenchmark {\n+    @Param\n+    Transforms.InjectNopTransform transform;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transform(Blackhole bh) {\n+        for (byte[] aClass : classes)\n+            bh.consume(transform.transform.apply(aClass));\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdaptInjectNoop.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * CorpusAdapt\n+ *\/\n+public class AdaptMetadata extends AbstractCorpusBenchmark {\n+\n+    @Param\n+    Transforms.SimpleTransform transform;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transform(Blackhole bh) {\n+        for (byte[] aClass : classes)\n+            bh.consume(transform.transform.apply(aClass));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdaptMetadata.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * CorpusNullAdapt\n+ *\/\n+public class AdaptNull extends AbstractCorpusBenchmark {\n+\n+    @Param({\n+\/\/            \"ARRAYCOPY\",\n+            \"ASM_1\",\n+            \"ASM_3\",\n+            \"ASM_UNSHARED_3\",\n+\/\/            \"ASM_TREE\",\n+            \"SHARED_1\",\n+            \"SHARED_2\",\n+            \"SHARED_3\",\n+            \"SHARED_3_NO_DEBUG\",\n+\/\/            \"HIGH_X1\",\n+\/\/            \"HIGH_X2\",\n+\/\/            \"HIGH_X3\",\n+\/\/            \"UNSHARED_1\",\n+\/\/            \"UNSHARED_2\",\n+            \"UNSHARED_3\",\n+\/\/            \"SHARED_3_NO_STACKMAP\"\n+    })\n+    Transforms.NoOpTransform noOpTransform;\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transform(Blackhole bh) {\n+        for (byte[] aClass : classes)\n+            bh.consume(noOpTransform.transform.apply(aClass));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdaptNull.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassReader;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+import jdk.internal.classfile.impl.CodeImpl;\n+import jdk.internal.classfile.impl.LabelContext;\n+import jdk.internal.classfile.impl.SplitConstantPool;\n+import jdk.internal.classfile.impl.StackMapGenerator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Fork(1)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 10)\n+public class GenerateStackMaps {\n+\n+    record GenData(LabelContext labelContext,\n+                    ClassDesc thisClass,\n+                    String methodName,\n+                    MethodTypeDesc methodDesc,\n+                    boolean isStatic,\n+                    ByteBuffer bytecode,\n+                    ConstantPoolBuilder constantPool,\n+                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {}\n+\n+    List<GenData> data;\n+    Iterator<GenData> it;\n+    GenData d;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws IOException {\n+        data = new LinkedList<>();\n+        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\")).forEach(p ->  {\n+            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n+                var clm = Classfile.parse(p);\n+                var thisCls = clm.thisClass().asSymbol();\n+                var cp = new SplitConstantPool((ClassReader)clm.constantPool());\n+                for (var m : clm.methods()) {\n+                    m.code().ifPresent(com -> {\n+                        var bb = ByteBuffer.wrap(((CodeImpl)com).contents());\n+                        data.add(new GenData(\n+                                (LabelContext)com,\n+                                thisCls,\n+                                m.methodName().stringValue(),\n+                                m.methodTypeSymbol(),\n+                                (m.flags().flagsMask() & Classfile.ACC_STATIC) != 0,\n+                                bb.slice(8, bb.getInt(4)),\n+                                cp,\n+                                com.exceptionHandlers().stream().map(eh -> (AbstractPseudoInstruction.ExceptionCatchImpl)eh).toList()));\n+                    });\n+                }\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    @Benchmark\n+    public void benchmark() {\n+        if (it == null || !it.hasNext())\n+            it = data.iterator();\n+        var d = it.next();\n+        new StackMapGenerator(\n+                d.labelContext(),\n+                d.thisClass(),\n+                d.methodName(),\n+                d.methodDesc(),\n+                d.isStatic(),\n+                d.bytecode().rewind(),\n+                (SplitConstantPool)d.constantPool(),\n+                d.handlers());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.jdk.classfile.Transforms.threeLevelNoop;\n+\n+\/**\n+ * ParseOptions\n+ *\/\n+public class ParseOptions extends AbstractCorpusBenchmark {\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transformNoDebug(Blackhole bh) {\n+        for (byte[] aClass : classes) {\n+            ClassModel cm = Classfile.parse(aClass, Classfile.Option.processDebug(false));\n+            bh.consume(cm.transform(threeLevelNoop));\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transformNoStackmap(Blackhole bh) {\n+        for (byte[] aClass : classes) {\n+            ClassModel cm = Classfile.parse(aClass, Classfile.Option.generateStackmap(false));\n+            bh.consume(cm.transform(threeLevelNoop));\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void transformNoLineNumbers(Blackhole bh) {\n+        for (byte[] aClass : classes) {\n+            ClassModel cm = Classfile.parse(aClass, Classfile.Option.processLineNumbers(false));\n+            bh.consume(cm.transform(threeLevelNoop));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ParseOptions.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassfileElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CompoundElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.instruction.LoadInstruction;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.tree.ClassNode;\n+import jdk.internal.org.objectweb.asm.tree.MethodNode;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * ReadCode\n+ *\/\n+public class ReadDeep extends AbstractCorpusBenchmark {\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void asmStreamCountLoads(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            ClassReader cr = new ClassReader(bytes);\n+\n+            var mv = new MethodVisitor(Opcodes.ASM9) {\n+                int count = 0;\n+\n+                @Override\n+                public void visitVarInsn(int opcode, int var) {\n+                    ++count;\n+                }\n+            };\n+\n+            var visitor = new ClassVisitor(Opcodes.ASM9) {\n+                @Override\n+                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+                    return mv;\n+                }\n+            };\n+            cr.accept(visitor, 0);\n+            bh.consume(mv.count);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void asmTreeCountLoads(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            var mv = new MethodVisitor(Opcodes.ASM9) {\n+                int count = 0;\n+\n+                @Override\n+                public void visitVarInsn(int opcode, int var) {\n+                    ++count;\n+                }\n+            };\n+\n+            ClassNode node = new ClassNode();\n+            ClassReader cr = new ClassReader(bytes);\n+            cr.accept(node, 0);\n+            for (MethodNode mn : node.methods) {\n+                mn.accept(mv);\n+            }\n+            bh.consume(mv.count);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void jdkElementsCountLoads(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            int[] count = new int[1];\n+            ClassModel cm = Classfile.parse(bytes);\n+            cm.forEachElement(ce -> {\n+                if (ce instanceof MethodModel mm) {\n+                    mm.forEachElement(me -> {\n+                        if (me instanceof CodeModel xm) {\n+                            xm.forEachElement(xe -> {\n+                                if (xe instanceof LoadInstruction) {\n+                                    ++count[0];\n+                                }\n+                            });\n+                        }\n+                    });\n+                };\n+            });\n+            bh.consume(count[0]);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void jdkElementsDeepIterate(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            ClassModel cm = Classfile.parse(bytes);\n+            bh.consume(iterateAll(cm));\n+        }\n+    }\n+\n+    private static ClassfileElement iterateAll(CompoundElement<?> model) {\n+        ClassfileElement last = null;\n+        for (var e : model) {\n+            if (e instanceof CompoundElement<?> cm) {\n+                last = iterateAll(cm);\n+            } else {\n+                last = e;\n+            }\n+        }\n+        return last; \/\/ provide some kind of result that the benchmark can feed to the black hole\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadDeep.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.org.objectweb.asm.*;\n+import jdk.internal.org.objectweb.asm.tree.*;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+public class ReadMetadata extends AbstractCorpusBenchmark {\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void asmStreamReadName(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            ClassReader cr = new ClassReader(bytes);\n+            var  visitor = new ClassVisitor(Opcodes.ASM9) {\n+                String theName;\n+\n+                @Override\n+                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+                    theName = name;\n+                }\n+            };\n+            cr.accept(visitor, 0);\n+            bh.consume(visitor.theName);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void asmTreeReadName(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            ClassNode node = new ClassNode();\n+            ClassReader cr = new ClassReader(bytes);\n+            cr.accept(node, 0);\n+            bh.consume(node.name);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void jdkReadName(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            bh.consume(Classfile.parse(bytes).thisClass().asInternalName());\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void asmStreamCountFields(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            ClassReader cr = new ClassReader(bytes);\n+            var visitor = new ClassVisitor(Opcodes.ASM9) {\n+                int count;\n+\n+                @Override\n+                public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+                    if ((access & Opcodes.ACC_PUBLIC) != 1) {\n+                        ++count;\n+                    }\n+                    return null;\n+                }\n+            };\n+            cr.accept(visitor, 0);\n+            bh.consume(visitor.count);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void asmTreeCountFields(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            int count = 0;\n+            ClassNode node = new ClassNode();\n+            ClassReader cr = new ClassReader(bytes);\n+            cr.accept(node, 0);\n+            for (FieldNode fn : node.fields)\n+                if ((fn.access & Opcodes.ACC_PUBLIC) != 1) {\n+                    ++count;\n+                }\n+            bh.consume(count);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void jdkTreeCountFields(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            int count = 0;\n+            ClassModel cm = Classfile.parse(bytes);\n+            for (FieldModel fm : cm.fields())\n+                if (!fm.flags().has(AccessFlag.PUBLIC)) {\n+                    ++count;\n+                }\n+            bh.consume(count);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void jdkCountFields(Blackhole bh) {\n+        for (byte[] bytes : classes) {\n+            int count = 0;\n+            ClassModel cm = Classfile.parse(bytes);\n+            for (ClassElement ce : cm) {\n+                if (ce instanceof FieldModel fm) {\n+                    if (!fm.flags().has(AccessFlag.PUBLIC)) {\n+                        ++count;\n+                    }\n+                }\n+            }\n+            bh.consume(count);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadMetadata.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+\/**\n+ * TestConstants\n+ *\/\n+public class TestConstants {\n+    public static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    public static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    public static final ClassDesc CD_ArrayList = ClassDesc.of(\"java.util.ArrayList\");\n+\n+    public static final MethodTypeDesc MTD_INT_VOID = MethodTypeDesc.ofDescriptor(\"(I)V\");\n+    public static final MethodTypeDesc MTD_VOID = MethodTypeDesc.ofDescriptor(\"()V\");\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/TestConstants.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,578 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.components.ClassRemapper;\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.FieldVisitor;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.ModuleVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n+import jdk.internal.org.objectweb.asm.TypePath;\n+import jdk.internal.org.objectweb.asm.tree.ClassNode;\n+\n+\/**\n+ * Transforms\n+ *\/\n+public class Transforms {\n+\n+    static int ASM9 = 9 << 16 | 0 << 8;\n+\n+    public static final ClassTransform threeLevelNoop = (cb, ce) -> {\n+        if (ce instanceof MethodModel mm) {\n+            cb.transformMethod(mm, (mb, me) -> {\n+                if (me instanceof CodeModel xm) {\n+                    mb.transformCode(xm, CodeTransform.ACCEPT_ALL);\n+                }\n+                else\n+                    mb.with(me);\n+            });\n+        }\n+        else\n+            cb.with(ce);\n+    };\n+\n+    private static final ClassTransform threeLevelNoopPipedCMC_seed = (cb, ce) -> {\n+        if (ce instanceof MethodModel mm) {\n+            MethodTransform transform = (mb, me) -> {\n+                if (me instanceof CodeModel xm) {\n+                    mb.transformCode(xm, CodeTransform.ACCEPT_ALL.andThen(CodeTransform.ACCEPT_ALL));\n+                }\n+                else\n+                    mb.with(me);\n+            };\n+            cb.transformMethod(mm, transform);\n+        }\n+        else\n+            cb.with(ce);\n+    };\n+\n+    static final ClassTransform twoLevelNoop = (cb, ce) -> {\n+        if (ce instanceof MethodModel mm) {\n+            cb.transformMethod(mm, MethodTransform.ACCEPT_ALL);\n+        }\n+        else\n+            cb.with(ce);\n+    };\n+\n+    static final ClassTransform oneLevelNoop = ClassTransform.ACCEPT_ALL;\n+\n+    public static final List<ClassTransform> noops = List.of(threeLevelNoop, twoLevelNoop, oneLevelNoop);\n+\n+    public enum NoOpTransform {\n+        ARRAYCOPY(bytes -> {\n+            byte[] bs = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, bs, 0, bytes.length);\n+            return bs;\n+        }),\n+        SHARED_1(true, oneLevelNoop),\n+        SHARED_2(true, twoLevelNoop),\n+        SHARED_3(true, threeLevelNoop),\n+        SHARED_3P(true, threeLevelNoop.andThen(threeLevelNoop)),\n+        SHARED_3L(true, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)),\n+        SHARED_3Sx(true, threeLevelNoopPipedCMC_seed.andThen(ClassTransform.ACCEPT_ALL)),\n+        SHARED_3bc(true, ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.ACCEPT_ALL)\n+                .andThen(ClassTransform.transformingMethodBodies(CodeTransform.ACCEPT_ALL))),\n+        UNSHARED_1(false, oneLevelNoop),\n+        UNSHARED_2(false, twoLevelNoop),\n+        UNSHARED_3(false, threeLevelNoop),\n+        SHARED_3_NO_STACKMAP(true, threeLevelNoop, Classfile.Option.generateStackmap(false)),\n+        SHARED_3_NO_DEBUG(true, threeLevelNoop, Classfile.Option.processDebug(false), Classfile.Option.processLineNumbers(false)),\n+        ASM_1(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(cw, 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_UNSHARED_1(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(cw, 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_3(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(new CustomClassVisitor(cw), 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_UNSHARED_3(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(new CustomClassVisitor(cw), 0);\n+            return cw.toByteArray();\n+        }),\n+        ASM_TREE(bytes -> {\n+            ClassNode node = new ClassNode();\n+            ClassReader cr = new ClassReader(bytes);\n+            cr.accept(node, 0);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            node.accept(cw);\n+            return cw.toByteArray();\n+        }),\n+        CLASS_REMAPPER(bytes ->\n+                ClassRemapper.of(Map.of()).remapClass(Classfile.parse(bytes)));\n+\n+        \/\/ Need ASM, LOW_UNSHARED\n+\n+        public final UnaryOperator<byte[]> transform;\n+        public final boolean shared;\n+        public final ClassTransform classTransform;\n+        public final Classfile.Option[] options;\n+\n+        NoOpTransform(UnaryOperator<byte[]> transform) {\n+            this.transform = transform;\n+            classTransform = null;\n+            shared = false;\n+            options = new Classfile.Option[0];\n+        }\n+\n+        NoOpTransform(boolean shared,\n+                      ClassTransform classTransform,\n+                      Classfile.Option... options) {\n+            this.shared = shared;\n+            this.classTransform = classTransform;\n+            this.options = shared\n+                           ? options\n+                           : Stream.concat(Stream.of(options), Stream.of(Classfile.Option.constantPoolSharing(false))).toArray(Classfile.Option[]::new);\n+            this.transform = bytes -> Classfile.parse(bytes, this.options).transform(classTransform);\n+        }\n+    }\n+\n+    public enum InjectNopTransform {\n+        ASM_NOP_SHARED(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(new NopClassVisitor(cw), 0);\n+            return cw.toByteArray();\n+        }),\n+        NOP_SHARED(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return cm.transform((cb, ce) -> {\n+                if (ce instanceof MethodModel mm) {\n+                    cb.transformMethod(mm, (mb, me) -> {\n+                        if (me instanceof CodeModel xm) {\n+                            mb.withCode(xb -> {\n+                                xb.nopInstruction();\n+                                xm.forEachElement(new Consumer<>() {\n+                                    @Override\n+                                    public void accept(CodeElement e) {\n+                                        xb.with(e);\n+                                    }\n+                                });\n+                            });\n+                        }\n+                        else\n+                            mb.with(me);\n+                    });\n+                }\n+                else\n+                    cb.with(ce);\n+            });\n+        });\n+\n+        public final UnaryOperator<byte[]> transform;\n+\n+        InjectNopTransform(UnaryOperator<byte[]> transform) {\n+            this.transform = transform;\n+        }\n+    }\n+\n+    public enum SimpleTransform {\n+        ASM_ADD_FIELD(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            cr.accept(cw, 0);\n+            cw.visitField(0, \"argleBargleWoogaWooga\", \"I\", null, null);\n+            return cw.toByteArray();\n+        }),\n+        HIGH_SHARED_ADD_FIELD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return cm.transform(new ClassTransform() {\n+                @Override\n+                public void accept(ClassBuilder builder, ClassElement element) {\n+                    builder.with(element);\n+                }\n+\n+                @Override\n+                public void atEnd(ClassBuilder builder) {\n+                    builder.withField(\"argleBargleWoogaWooga\", ConstantDescs.CD_int, b -> { });\n+                }\n+            });\n+        }),\n+        HIGH_UNSHARED_ADD_FIELD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return Classfile.build(cm.thisClass().asSymbol(),\n+                                   cb -> {\n+                                       cm.forEachElement(cb);\n+                                       cb.withField(\"argleBargleWoogaWooga\", ConstantDescs.CD_int, b -> { });\n+                                   });\n+        }),\n+        ASM_DEL_METHOD(bytes -> {\n+            ClassReader cr = new ClassReader(bytes);\n+            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n+            ClassVisitor v = new ClassVisitor(ASM9, cw) {\n+                @Override\n+                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+                    return (name.equals(\"hashCode\") && descriptor.equals(\"()Z\"))\n+                           ? null\n+                           : super.visitMethod(access, name, descriptor, signature, exceptions);\n+                }\n+            };\n+            cr.accept(cw, 0);\n+            return cw.toByteArray();\n+        }),\n+        HIGH_SHARED_DEL_METHOD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return cm.transform((builder, element) -> {\n+                if (!(element instanceof MethodModel mm))\n+                    builder.with(element);\n+            });\n+        }),\n+        HIGH_UNSHARED_DEL_METHOD(bytes -> {\n+            ClassModel cm = Classfile.parse(bytes);\n+            return Classfile.build(cm.thisClass().asSymbol(),\n+                                   cb -> {\n+                                       cm.forEachElement(element -> {\n+                                           if (element instanceof MethodModel mm\n+                                               && mm.methodName().stringValue().equals(\"hashCode\")\n+                                               && mm.methodType().stringValue().equals(\"()Z\")) {\n+\n+                                           }\n+                                           else\n+                                               cb.with(element);\n+                                       });\n+                                   });\n+        });\n+\n+        public final UnaryOperator<byte[]> transform;\n+\n+        SimpleTransform(UnaryOperator<byte[]> transform) {\n+            this.transform = transform;\n+        }\n+    }\n+\n+    static class CustomClassVisitor extends ClassVisitor {\n+\n+        public CustomClassVisitor(ClassVisitor writer) {\n+            super(ASM9, writer);\n+        }\n+\n+        @Override\n+        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+            super.visit(version, access, name, signature, superName, interfaces);\n+        }\n+\n+        @Override\n+        public void visitSource(String source, String debug) {\n+            super.visitSource(source, debug);\n+        }\n+\n+        @Override\n+        public ModuleVisitor visitModule(String name, int access, String version) {\n+            return super.visitModule(name, access, version);\n+        }\n+\n+        @Override\n+        public void visitNestHost(String nestHost) {\n+            super.visitNestHost(nestHost);\n+        }\n+\n+        @Override\n+        public void visitOuterClass(String owner, String name, String descriptor) {\n+            super.visitOuterClass(owner, name, descriptor);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAttribute(Attribute attribute) {\n+            super.visitAttribute(attribute);\n+        }\n+\n+        @Override\n+        public void visitNestMember(String nestMember) {\n+            super.visitNestMember(nestMember);\n+        }\n+\n+        @Override\n+        public void visitInnerClass(String name, String outerName, String innerName, int access) {\n+            super.visitInnerClass(name, outerName, innerName, access);\n+        }\n+\n+        @Override\n+        public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {\n+            return super.visitRecordComponent(name, descriptor, signature);\n+        }\n+\n+        @Override\n+        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+            return super.visitField(access, name, descriptor, signature, value);\n+        }\n+\n+        @Override\n+        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n+            return new CustomMethodVisitor(mv);\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+        }\n+    };\n+\n+\n+    static class CustomMethodVisitor extends MethodVisitor {\n+\n+        public CustomMethodVisitor(MethodVisitor methodVisitor) {\n+            super(ASM9, methodVisitor);\n+        }\n+\n+        @Override\n+        public void visitParameter(String name, int access) {\n+            super.visitParameter(name, access);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotationDefault() {\n+            return super.visitAnnotationDefault();\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n+            super.visitAnnotableParameterCount(parameterCount, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {\n+            return super.visitParameterAnnotation(parameter, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAttribute(Attribute attribute) {\n+            super.visitAttribute(attribute);\n+        }\n+\n+        @Override\n+        public void visitCode() {\n+            super.visitCode();\n+        }\n+\n+        @Override\n+        public void visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack) {\n+            super.visitFrame(type, numLocal, local, numStack, stack);\n+        }\n+\n+        @Override\n+        public void visitInsn(int opcode) {\n+            super.visitInsn(opcode);\n+        }\n+\n+        @Override\n+        public void visitIntInsn(int opcode, int operand) {\n+            super.visitIntInsn(opcode, operand);\n+        }\n+\n+        @Override\n+        public void visitVarInsn(int opcode, int var) {\n+            super.visitVarInsn(opcode, var);\n+        }\n+\n+        @Override\n+        public void visitTypeInsn(int opcode, String type) {\n+            super.visitTypeInsn(opcode, type);\n+        }\n+\n+        @Override\n+        public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n+            super.visitFieldInsn(opcode, owner, name, descriptor);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public void visitMethodInsn(int opcode, String owner, String name, String descriptor) {\n+            super.visitMethodInsn(opcode, owner, name, descriptor);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n+            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n+        }\n+\n+        @Override\n+        public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n+            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n+        }\n+\n+        @Override\n+        public void visitJumpInsn(int opcode, Label label) {\n+            super.visitJumpInsn(opcode, label);\n+        }\n+\n+        @Override\n+        public void visitLabel(Label label) {\n+            super.visitLabel(label);\n+        }\n+\n+        @Override\n+        public void visitLdcInsn(Object value) {\n+            super.visitLdcInsn(value);\n+        }\n+\n+        @Override\n+        public void visitIincInsn(int var, int increment) {\n+            super.visitIincInsn(var, increment);\n+        }\n+\n+        @Override\n+        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\n+            super.visitTableSwitchInsn(min, max, dflt, labels);\n+        }\n+\n+        @Override\n+        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n+            super.visitLookupSwitchInsn(dflt, keys, labels);\n+        }\n+\n+        @Override\n+        public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {\n+            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n+            super.visitTryCatchBlock(start, end, handler, type);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n+            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {\n+            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String descriptor, boolean visible) {\n+            return super.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitLineNumber(int line, Label start) {\n+            super.visitLineNumber(line, start);\n+        }\n+\n+        @Override\n+        public void visitMaxs(int maxStack, int maxLocals) {\n+            super.visitMaxs(maxStack, maxLocals);\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+        }\n+    };\n+\n+    static class NopClassVisitor extends CustomClassVisitor {\n+\n+        public NopClassVisitor(ClassVisitor writer) {\n+            super(writer);\n+        }\n+\n+        @Override\n+        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n+            return new NopMethodVisitor(mv);\n+        }\n+    }\n+\n+    static class NopMethodVisitor extends CustomMethodVisitor {\n+\n+        public NopMethodVisitor(MethodVisitor methodVisitor) {\n+            super(methodVisitor);\n+        }\n+\n+        @Override\n+        public void visitCode() {\n+            super.visitCode();\n+            visitInsn(Opcodes.NOP);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":578,"deletions":0,"binary":false,"changes":578,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import jdk.internal.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.SourceFileAttribute;\n+import jdk.internal.org.objectweb.asm.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.io.FileOutputStream;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import static org.openjdk.bench.jdk.classfile.TestConstants.CD_PrintStream;\n+import static org.openjdk.bench.jdk.classfile.TestConstants.CD_System;\n+import static org.openjdk.bench.jdk.classfile.TestConstants.MTD_INT_VOID;\n+import static org.openjdk.bench.jdk.classfile.TestConstants.MTD_VOID;\n+import static jdk.internal.classfile.Opcode.*;\n+import static jdk.internal.classfile.TypeKind.*;\n+import static jdk.internal.classfile.TypeKind.IntType;\n+import static jdk.internal.org.objectweb.asm.Opcodes.V12;\n+\n+\/**\n+ * Write\n+ *\n+ * Generates this program with 40 mains...\n+ *\n+ * class MyClass {\n+ *   public static void main(String[] args) {\n+ *     int fac = 1;\n+ *     for (int i = 1; i < 10; ++i) {\n+ *       fac = fac * i;\n+ *     }\n+ *     System.out.println(fac);\n+ *   }\n+ * }\n+ *\/\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 5)\n+@Fork(1)\n+public class Write {\n+    static String checkFileAsm = \"\/tmp\/asw\/MyClass.class\";\n+    static String checkFileBc = \"\/tmp\/byw\/MyClass.class\";\n+    static boolean writeClassAsm = Files.exists(Paths.get(checkFileAsm).getParent());\n+    static boolean writeClassBc = Files.exists(Paths.get(checkFileBc).getParent());\n+\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public byte[] asmStream() {\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n+        cw.visit(V12, Opcodes.ACC_PUBLIC, \"MyClass\", null, \"java\/lang\/Object\", null);\n+        cw.visitSource(\"MyClass.java\", null);\n+\n+        {\n+            MethodVisitor mv = cw.visitMethod(0, \"<init>\", \"()V\", null, null);\n+            mv.visitCode();\n+            Label startLabel = new Label();\n+            Label endLabel = new Label();\n+            mv.visitLabel(startLabel);\n+            mv.visitVarInsn(Opcodes.ALOAD, 0);\n+            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n+            mv.visitInsn(Opcodes.RETURN);\n+            mv.visitLabel(endLabel);\n+            mv.visitLocalVariable(\"this\", \"LMyClass;\", null, startLabel, endLabel, 1);\n+            mv.visitMaxs(-1, -1);\n+            mv.visitEnd();\n+        }\n+\n+        for (int xi = 0; xi < 40; ++xi) {\n+            MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, \"main\"+ ((xi==0)? \"\" : \"\"+xi), \"([Ljava\/lang\/String;)V\", null, null);\n+            mv.visitCode();\n+            Label loopTop = new Label();\n+            Label loopEnd = new Label();\n+            Label startLabel = new Label();\n+            Label endLabel = new Label();\n+            Label iStart = new Label();\n+            mv.visitLabel(startLabel);\n+            mv.visitInsn(Opcodes.ICONST_1);\n+            mv.visitVarInsn(Opcodes.ISTORE, 1);\n+            mv.visitLabel(iStart);\n+            mv.visitInsn(Opcodes.ICONST_1);\n+            mv.visitVarInsn(Opcodes.ISTORE, 2);\n+            mv.visitLabel(loopTop);\n+            mv.visitVarInsn(Opcodes.ILOAD, 2);\n+            mv.visitIntInsn(Opcodes.BIPUSH, 10);\n+            mv.visitJumpInsn(Opcodes.IF_ICMPGE, loopEnd);\n+            mv.visitVarInsn(Opcodes.ILOAD, 1);\n+            mv.visitVarInsn(Opcodes.ILOAD, 2);\n+            mv.visitInsn(Opcodes.IMUL);\n+            mv.visitVarInsn(Opcodes.ISTORE, 1);\n+            mv.visitIincInsn(2, 1);\n+            mv.visitJumpInsn(Opcodes.GOTO, loopTop);\n+            mv.visitLabel(loopEnd);\n+            mv.visitFieldInsn(Opcodes.GETSTATIC,\"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n+            mv.visitVarInsn(Opcodes.ILOAD, 1);\n+            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(I)V\", false);\n+            mv.visitLabel(endLabel);\n+            mv.visitInsn(Opcodes.RETURN);\n+            mv.visitLocalVariable(\"fac\", \"I\", null, startLabel, endLabel, 1);\n+            mv.visitLocalVariable(\"i\",   \"I\", null, iStart, loopEnd, 2);\n+            mv.visitMaxs(-1, -1);\n+            mv.visitEnd();\n+        }\n+        cw.visitEnd();\n+\n+        byte[] bytes = cw.toByteArray();\n+        if (writeClassAsm) writeClass(bytes, checkFileAsm);\n+        return bytes;\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public byte[] jdkTree() {\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withVersion(52, 0);\n+            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n+                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n+                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                              .returnInstruction(VoidType)\n+                      )\n+              );\n+            for (int xi = 0; xi < 40; ++xi) {\n+                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                              mb -> mb.withCode(c0 -> {\n+                                  jdk.internal.classfile.Label loopTop = c0.newLabel();\n+                                  jdk.internal.classfile.Label loopEnd = c0.newLabel();\n+                                  int vFac = 1;\n+                                  int vI = 2;\n+                                  c0.constantInstruction(ICONST_1, 1)         \/\/ 0\n+                                    .storeInstruction(IntType, vFac)        \/\/ 1\n+                                    .constantInstruction(ICONST_1, 1)         \/\/ 2\n+                                    .storeInstruction(IntType, vI)          \/\/ 3\n+                                    .labelBinding(loopTop)\n+                                    .loadInstruction(IntType, vI)           \/\/ 4\n+                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n+                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n+                                    .loadInstruction(IntType, vFac)         \/\/ 7\n+                                    .loadInstruction(IntType, vI)           \/\/ 8\n+                                    .operatorInstruction(IMUL)             \/\/ 9\n+                                    .storeInstruction(IntType, vFac)        \/\/ 10\n+                                    .incrementInstruction(vI, 1)    \/\/ 11\n+                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                    .labelBinding(loopEnd)\n+                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n+                                    .loadInstruction(IntType, vFac)\n+                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n+                                    .returnInstruction(VoidType);\n+                        }));\n+            }\n+        });\n+        if (writeClassBc) writeClass(bytes, checkFileBc);\n+        return bytes;\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public byte[] jdkTreePrimitive() {\n+\n+        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+            cb.withFlags(AccessFlag.PUBLIC);\n+            cb.withVersion(52, 0);\n+            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n+              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n+                          mb -> mb.withCode(codeb -> codeb.loadInstruction(ReferenceType, 0)\n+                                                          .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n+                                                          .returnInstruction(VoidType)\n+                          )\n+              );\n+            for (int xi = 0; xi < 40; ++xi) {\n+                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n+                              mb -> mb.withCode(c0 -> {\n+                                  jdk.internal.classfile.Label loopTop = c0.newLabel();\n+                                  jdk.internal.classfile.Label loopEnd = c0.newLabel();\n+                                  int vFac = 1;\n+                                  int vI = 2;\n+                                  c0.constantInstruction(ICONST_1, 1)        \/\/ 0\n+                                    .storeInstruction(IntType, 1)          \/\/ 1\n+                                    .constantInstruction(ICONST_1, 1)        \/\/ 2\n+                                    .storeInstruction(IntType, 2)          \/\/ 3\n+                                    .labelBinding(loopTop)\n+                                    .loadInstruction(IntType, 2)           \/\/ 4\n+                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n+                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n+                                    .loadInstruction(IntType, 1)           \/\/ 7\n+                                    .loadInstruction(IntType, 2)           \/\/ 8\n+                                    .operatorInstruction(IMUL)             \/\/ 9\n+                                    .storeInstruction(IntType, 1)          \/\/ 10\n+                                    .incrementInstruction(2, 1)    \/\/ 11\n+                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n+                                    .labelBinding(loopEnd)\n+                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n+                                    .loadInstruction(IntType, 1)\n+                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n+                                    .returnInstruction(VoidType);\n+                        }));\n+            }\n+        });\n+        if (writeClassBc) writeClass(bytes, checkFileBc);\n+        return bytes;\n+    }\n+\n+    private void writeClass(byte[] bytes, String fn) {\n+        try {\n+            FileOutputStream out = new FileOutputStream(fn);\n+            out.write(bytes);\n+            out.close();\n+        } catch (Exception ex) {\n+            throw new InternalError(ex);\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"}]}