{"files":[{"patch":"@@ -38,3 +38,0 @@\n-    public AttributeHolder() {\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,59 +35,0 @@\n-import jdk.internal.classfile.attribute.StackMapTableAttribute;\n-import jdk.internal.classfile.constantpool.ClassEntry;\n-import jdk.internal.classfile.instruction.ExceptionCatch;\n-\n-import static jdk.internal.classfile.Classfile.ALOAD;\n-import static jdk.internal.classfile.Classfile.ANEWARRAY;\n-import static jdk.internal.classfile.Classfile.ASTORE;\n-import static jdk.internal.classfile.Classfile.BIPUSH;\n-import static jdk.internal.classfile.Classfile.CHECKCAST;\n-import static jdk.internal.classfile.Classfile.DLOAD;\n-import static jdk.internal.classfile.Classfile.DSTORE;\n-import static jdk.internal.classfile.Classfile.FLOAD;\n-import static jdk.internal.classfile.Classfile.FSTORE;\n-import static jdk.internal.classfile.Classfile.GETFIELD;\n-import static jdk.internal.classfile.Classfile.GETSTATIC;\n-import static jdk.internal.classfile.Classfile.GOTO;\n-import static jdk.internal.classfile.Classfile.GOTO_W;\n-import static jdk.internal.classfile.Classfile.IFEQ;\n-import static jdk.internal.classfile.Classfile.IFGE;\n-import static jdk.internal.classfile.Classfile.IFGT;\n-import static jdk.internal.classfile.Classfile.IFLE;\n-import static jdk.internal.classfile.Classfile.IFLT;\n-import static jdk.internal.classfile.Classfile.IFNE;\n-import static jdk.internal.classfile.Classfile.IFNONNULL;\n-import static jdk.internal.classfile.Classfile.IFNULL;\n-import static jdk.internal.classfile.Classfile.IF_ACMPEQ;\n-import static jdk.internal.classfile.Classfile.IF_ACMPNE;\n-import static jdk.internal.classfile.Classfile.IF_ICMPEQ;\n-import static jdk.internal.classfile.Classfile.IF_ICMPGE;\n-import static jdk.internal.classfile.Classfile.IF_ICMPGT;\n-import static jdk.internal.classfile.Classfile.IF_ICMPLE;\n-import static jdk.internal.classfile.Classfile.IF_ICMPLT;\n-import static jdk.internal.classfile.Classfile.IF_ICMPNE;\n-import static jdk.internal.classfile.Classfile.IINC;\n-import static jdk.internal.classfile.Classfile.ILOAD;\n-import static jdk.internal.classfile.Classfile.INSTANCEOF;\n-import static jdk.internal.classfile.Classfile.INVOKEDYNAMIC;\n-import static jdk.internal.classfile.Classfile.INVOKEINTERFACE;\n-import static jdk.internal.classfile.Classfile.INVOKESPECIAL;\n-import static jdk.internal.classfile.Classfile.INVOKESTATIC;\n-import static jdk.internal.classfile.Classfile.INVOKEVIRTUAL;\n-import static jdk.internal.classfile.Classfile.ISTORE;\n-import static jdk.internal.classfile.Classfile.JSR;\n-import static jdk.internal.classfile.Classfile.JSR_W;\n-import static jdk.internal.classfile.Classfile.LDC;\n-import static jdk.internal.classfile.Classfile.LDC2_W;\n-import static jdk.internal.classfile.Classfile.LDC_W;\n-import static jdk.internal.classfile.Classfile.LLOAD;\n-import static jdk.internal.classfile.Classfile.LOOKUPSWITCH;\n-import static jdk.internal.classfile.Classfile.LSTORE;\n-import static jdk.internal.classfile.Classfile.MULTIANEWARRAY;\n-import static jdk.internal.classfile.Classfile.NEW;\n-import static jdk.internal.classfile.Classfile.NEWARRAY;\n-import static jdk.internal.classfile.Classfile.PUTFIELD;\n-import static jdk.internal.classfile.Classfile.PUTSTATIC;\n-import static jdk.internal.classfile.Classfile.RET;\n-import static jdk.internal.classfile.Classfile.SIPUSH;\n-import static jdk.internal.classfile.Classfile.TABLESWITCH;\n-import static jdk.internal.classfile.Classfile.WIDE;\n@@ -96,0 +37,5 @@\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.instruction.*;\n+\n+import static jdk.internal.classfile.Classfile.*;\n@@ -103,0 +49,57 @@\n+\n+    static final Instruction[] SINGLETON_INSTRUCTIONS = new Instruction[256];\n+\n+    static {\n+        for (Opcode o : List.of(Opcode.NOP))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = NopInstruction.of();\n+        for (Opcode o : List.of(Opcode.ACONST_NULL,\n+                                Opcode.ICONST_M1,\n+                                Opcode.ICONST_0, Opcode.ICONST_1, Opcode.ICONST_2, Opcode.ICONST_3, Opcode.ICONST_4, Opcode.ICONST_5,\n+                                Opcode.LCONST_0, Opcode.LCONST_1,\n+                                Opcode.FCONST_0, Opcode.FCONST_1, Opcode.FCONST_2,\n+                                Opcode.DCONST_0, Opcode.DCONST_1))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = ConstantInstruction.ofIntrinsic(o);\n+        for (Opcode o : List.of(Opcode.ILOAD_0, Opcode.ILOAD_1, Opcode.ILOAD_2, Opcode.ILOAD_3,\n+                                Opcode.LLOAD_0, Opcode.LLOAD_1, Opcode.LLOAD_2, Opcode.LLOAD_3,\n+                                Opcode.FLOAD_0, Opcode.FLOAD_1, Opcode.FLOAD_2, Opcode.FLOAD_3,\n+                                Opcode.DLOAD_0, Opcode.DLOAD_1, Opcode.DLOAD_2, Opcode.DLOAD_3,\n+                                Opcode.ALOAD_0, Opcode.ALOAD_1, Opcode.ALOAD_2, Opcode.ALOAD_3))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = LoadInstruction.of(o, o.slot());\n+        for (Opcode o : List.of(Opcode.ISTORE_0, Opcode.ISTORE_1, Opcode.ISTORE_2, Opcode.ISTORE_3,\n+                                Opcode.LSTORE_0, Opcode.LSTORE_1, Opcode.LSTORE_2, Opcode.LSTORE_3,\n+                                Opcode.FSTORE_0, Opcode.FSTORE_1, Opcode.FSTORE_2, Opcode.FSTORE_3,\n+                                Opcode.DSTORE_0, Opcode.DSTORE_1, Opcode.DSTORE_2, Opcode.DSTORE_3,\n+                                Opcode.ASTORE_0, Opcode.ASTORE_1, Opcode.ASTORE_2, Opcode.ASTORE_3))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = StoreInstruction.of(o, o.slot());\n+        for (Opcode o : List.of(Opcode.IALOAD, Opcode.LALOAD, Opcode.FALOAD, Opcode.DALOAD, Opcode.AALOAD, Opcode.BALOAD, Opcode.CALOAD, Opcode.SALOAD))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = ArrayLoadInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.IASTORE, Opcode.LASTORE, Opcode.FASTORE, Opcode.DASTORE, Opcode.AASTORE, Opcode.BASTORE, Opcode.CASTORE, Opcode.SASTORE))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = ArrayStoreInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.POP, Opcode.POP2, Opcode.DUP, Opcode.DUP_X1, Opcode.DUP_X2, Opcode.DUP2, Opcode.DUP2_X1, Opcode.DUP2_X2, Opcode.SWAP))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = StackInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.IADD, Opcode.LADD, Opcode.FADD, Opcode.DADD, Opcode.ISUB,\n+                                Opcode.LSUB, Opcode.FSUB, Opcode.DSUB,\n+                                Opcode.IMUL, Opcode.LMUL, Opcode.FMUL, Opcode.DMUL,\n+                                Opcode.IDIV, Opcode.LDIV, Opcode.FDIV, Opcode.DDIV,\n+                                Opcode.IREM, Opcode.LREM, Opcode.FREM, Opcode.DREM,\n+                                Opcode.INEG, Opcode.LNEG, Opcode.FNEG, Opcode.DNEG,\n+                                Opcode.ISHL, Opcode.LSHL, Opcode.ISHR, Opcode.LSHR, Opcode.IUSHR, Opcode.LUSHR,\n+                                Opcode.IAND, Opcode.LAND, Opcode.IOR, Opcode.LOR, Opcode.IXOR, Opcode.LXOR,\n+                                Opcode.LCMP, Opcode.FCMPL, Opcode.FCMPG, Opcode.DCMPL, Opcode.DCMPG,\n+                                Opcode.ARRAYLENGTH))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = OperatorInstruction.of(o);\n+\n+        for (Opcode o : List.of(Opcode.I2L, Opcode.I2F, Opcode.I2D,\n+                                Opcode.L2I, Opcode.L2F, Opcode.L2D,\n+                                Opcode.F2I, Opcode.F2L, Opcode.F2D,\n+                                Opcode.D2I, Opcode.D2L, Opcode.D2F,\n+                                Opcode.I2B, Opcode.I2C, Opcode.I2S))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = ConvertInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.IRETURN, Opcode.LRETURN, Opcode.FRETURN, Opcode.DRETURN, Opcode.ARETURN, Opcode.RETURN))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = ReturnInstruction.of(o);\n+        for (Opcode o : List.of(Opcode.ATHROW))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = ThrowInstruction.of();\n+        for (Opcode o : List.of(Opcode.MONITORENTER, Opcode.MONITOREXIT))\n+            SINGLETON_INSTRUCTIONS[o.bytecode()] = MonitorInstruction.of(o);\n+    }\n+\n@@ -146,1 +149,1 @@\n-        return lab.getContextInfo();\n+        return lab.getBCI();\n@@ -491,1 +494,1 @@\n-                Instruction instr = InstructionData.singletonInstructions[bc];\n+                Instruction instr = SINGLETON_INSTRUCTIONS[bc];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":64,"deletions":61,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -641,1 +641,1 @@\n-            return lab.getContextInfo();\n+            return lab.getBCI();\n@@ -644,1 +644,1 @@\n-            return mruParentTable[lab.getContextInfo()] - 1;\n+            return mruParentTable[lab.getBCI()] - 1;\n@@ -659,1 +659,1 @@\n-            return mruParentTable[lab.getContextInfo()] - 1;\n+            return mruParentTable[lab.getBCI()] - 1;\n@@ -663,1 +663,1 @@\n-            return lab.getContextInfo();\n+            return lab.getBCI();\n@@ -686,1 +686,1 @@\n-            if (lab.getContextInfo() != -1)\n+            if (lab.getBCI() != -1)\n@@ -688,1 +688,1 @@\n-            lab.setContextInfo(bci);\n+            lab.setBCI(bci);\n@@ -691,1 +691,1 @@\n-            mruParentTable[lab.getContextInfo()] = bci + 1;\n+            mruParentTable[lab.getBCI()] = bci + 1;\n@@ -705,1 +705,1 @@\n-            mruParentTable[lab.getContextInfo()] = bci + 1;\n+            mruParentTable[lab.getBCI()] = bci + 1;\n@@ -709,1 +709,1 @@\n-            lab.setContextInfo(bci);\n+            lab.setBCI(bci);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.util.List;\n-\n-import jdk.internal.classfile.Instruction;\n-import jdk.internal.classfile.Opcode;\n-import jdk.internal.classfile.instruction.ArrayLoadInstruction;\n-import jdk.internal.classfile.instruction.ArrayStoreInstruction;\n-import jdk.internal.classfile.instruction.ConstantInstruction;\n-import jdk.internal.classfile.instruction.ConvertInstruction;\n-import jdk.internal.classfile.instruction.LoadInstruction;\n-import jdk.internal.classfile.instruction.MonitorInstruction;\n-import jdk.internal.classfile.instruction.NopInstruction;\n-import jdk.internal.classfile.instruction.OperatorInstruction;\n-import jdk.internal.classfile.instruction.ReturnInstruction;\n-import jdk.internal.classfile.instruction.StackInstruction;\n-import jdk.internal.classfile.instruction.StoreInstruction;\n-import jdk.internal.classfile.instruction.ThrowInstruction;\n-\n-\/**\n- * InstructionData\n- *\/\n-public class InstructionData {\n-    static final Instruction[] singletonInstructions = new Instruction[256];\n-\n-    static {\n-        for (Opcode o : List.of(Opcode.NOP))\n-            singletonInstructions[o.bytecode()] = NopInstruction.of();\n-        for (Opcode o : List.of(Opcode.ACONST_NULL,\n-                                Opcode.ICONST_M1,\n-                                Opcode.ICONST_0, Opcode.ICONST_1, Opcode.ICONST_2, Opcode.ICONST_3, Opcode.ICONST_4, Opcode.ICONST_5,\n-                                Opcode.LCONST_0, Opcode.LCONST_1,\n-                                Opcode.FCONST_0, Opcode.FCONST_1, Opcode.FCONST_2,\n-                                Opcode.DCONST_0, Opcode.DCONST_1))\n-            singletonInstructions[o.bytecode()] = ConstantInstruction.ofIntrinsic(o);\n-        for (Opcode o : List.of(Opcode.ILOAD_0, Opcode.ILOAD_1, Opcode.ILOAD_2, Opcode.ILOAD_3,\n-                                Opcode.LLOAD_0, Opcode.LLOAD_1, Opcode.LLOAD_2, Opcode.LLOAD_3,\n-                                Opcode.FLOAD_0, Opcode.FLOAD_1, Opcode.FLOAD_2, Opcode.FLOAD_3,\n-                                Opcode.DLOAD_0, Opcode.DLOAD_1, Opcode.DLOAD_2, Opcode.DLOAD_3,\n-                                Opcode.ALOAD_0, Opcode.ALOAD_1, Opcode.ALOAD_2, Opcode.ALOAD_3))\n-            singletonInstructions[o.bytecode()] = LoadInstruction.of(o, o.slot());\n-        for (Opcode o : List.of(Opcode.ISTORE_0, Opcode.ISTORE_1, Opcode.ISTORE_2, Opcode.ISTORE_3,\n-                                Opcode.LSTORE_0, Opcode.LSTORE_1, Opcode.LSTORE_2, Opcode.LSTORE_3,\n-                                Opcode.FSTORE_0, Opcode.FSTORE_1, Opcode.FSTORE_2, Opcode.FSTORE_3,\n-                                Opcode.DSTORE_0, Opcode.DSTORE_1, Opcode.DSTORE_2, Opcode.DSTORE_3,\n-                                Opcode.ASTORE_0, Opcode.ASTORE_1, Opcode.ASTORE_2, Opcode.ASTORE_3))\n-            singletonInstructions[o.bytecode()] = StoreInstruction.of(o, o.slot());\n-        for (Opcode o : List.of(Opcode.IALOAD, Opcode.LALOAD, Opcode.FALOAD, Opcode.DALOAD, Opcode.AALOAD, Opcode.BALOAD, Opcode.CALOAD, Opcode.SALOAD))\n-            singletonInstructions[o.bytecode()] = ArrayLoadInstruction.of(o);\n-        for (Opcode o : List.of(Opcode.IASTORE, Opcode.LASTORE, Opcode.FASTORE, Opcode.DASTORE, Opcode.AASTORE, Opcode.BASTORE, Opcode.CASTORE, Opcode.SASTORE))\n-            singletonInstructions[o.bytecode()] = ArrayStoreInstruction.of(o);\n-        for (Opcode o : List.of(Opcode.POP, Opcode.POP2, Opcode.DUP, Opcode.DUP_X1, Opcode.DUP_X2, Opcode.DUP2, Opcode.DUP2_X1, Opcode.DUP2_X2, Opcode.SWAP))\n-            singletonInstructions[o.bytecode()] = StackInstruction.of(o);\n-        for (Opcode o : List.of(Opcode.IADD, Opcode.LADD, Opcode.FADD, Opcode.DADD, Opcode.ISUB,\n-                                Opcode.LSUB, Opcode.FSUB, Opcode.DSUB,\n-                                Opcode.IMUL, Opcode.LMUL, Opcode.FMUL, Opcode.DMUL,\n-                                Opcode.IDIV, Opcode.LDIV, Opcode.FDIV, Opcode.DDIV,\n-                                Opcode.IREM, Opcode.LREM, Opcode.FREM, Opcode.DREM,\n-                                Opcode.INEG, Opcode.LNEG, Opcode.FNEG, Opcode.DNEG,\n-                                Opcode.ISHL, Opcode.LSHL, Opcode.ISHR, Opcode.LSHR, Opcode.IUSHR, Opcode.LUSHR,\n-                                Opcode.IAND, Opcode.LAND, Opcode.IOR, Opcode.LOR, Opcode.IXOR, Opcode.LXOR,\n-                                Opcode.LCMP, Opcode.FCMPL, Opcode.FCMPG, Opcode.DCMPL, Opcode.DCMPG,\n-                                Opcode.ARRAYLENGTH))\n-            singletonInstructions[o.bytecode()] = OperatorInstruction.of(o);\n-\n-        for (Opcode o : List.of(Opcode.I2L, Opcode.I2F, Opcode.I2D,\n-                                Opcode.L2I, Opcode.L2F, Opcode.L2D,\n-                                Opcode.F2I, Opcode.F2L, Opcode.F2D,\n-                                Opcode.D2I, Opcode.D2L, Opcode.D2F,\n-                                Opcode.I2B, Opcode.I2C, Opcode.I2S))\n-            singletonInstructions[o.bytecode()] = ConvertInstruction.of(o);\n-        for (Opcode o : List.of(Opcode.IRETURN, Opcode.LRETURN, Opcode.FRETURN, Opcode.DRETURN, Opcode.ARETURN, Opcode.RETURN))\n-            singletonInstructions[o.bytecode()] = ReturnInstruction.of(o);\n-        for (Opcode o : List.of(Opcode.ATHROW))\n-            singletonInstructions[o.bytecode()] = ThrowInstruction.of();\n-        for (Opcode o : List.of(Opcode.MONITORENTER, Opcode.MONITOREXIT))\n-            singletonInstructions[o.bytecode()] = MonitorInstruction.of(o);\n-    }\n-\n-    private InstructionData() {\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/InstructionData.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -53,1 +53,1 @@\n-    private int contextInfo;\n+    private int bci;\n@@ -55,1 +55,1 @@\n-    public LabelImpl(LabelContext labelContext, int contextInfo) {\n+        public LabelImpl(LabelContext labelContext, int bci) {\n@@ -57,1 +57,1 @@\n-        this.contextInfo = contextInfo;\n+        this.bci = bci;\n@@ -64,2 +64,2 @@\n-    public int getContextInfo() {\n-        return contextInfo;\n+    public int getBCI() {\n+        return bci;\n@@ -68,2 +68,2 @@\n-    public void setContextInfo(int contextInfo) {\n-        this.contextInfo = contextInfo;\n+    public void setBCI(int bci) {\n+        this.bci = bci;\n@@ -84,1 +84,1 @@\n-        return String.format(\"Label[context=%s, contextInfo=%d]\", labelContext, contextInfo);\n+        return String.format(\"Label[context=%s, bci=%d]\", labelContext, bci);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-                              assertEquals(((LabelImpl) startEnd[0]).getContextInfo(), 0);\n-                              assertEquals(((LabelImpl) startEnd[1]).getContextInfo(), -1);\n+                              assertEquals(((LabelImpl) startEnd[0]).getBCI(), 0);\n+                              assertEquals(((LabelImpl) startEnd[1]).getBCI(), -1);\n@@ -75,2 +75,2 @@\n-        assertEquals(((LabelImpl) startEnd[0]).getContextInfo(), 0);\n-        assertEquals(((LabelImpl) startEnd[1]).getContextInfo(), 1);\n+        assertEquals(((LabelImpl) startEnd[0]).getBCI(), 0);\n+        assertEquals(((LabelImpl) startEnd[1]).getBCI(), 1);\n@@ -98,4 +98,4 @@\n-        assertEquals(((LabelImpl) startEnd[0]).getContextInfo(), 0);\n-        assertEquals(((LabelImpl) startEnd[1]).getContextInfo(), 3);\n-        assertEquals(((LabelImpl) startEnd[2]).getContextInfo(), 1);\n-        assertEquals(((LabelImpl) startEnd[3]).getContextInfo(), 2);\n+        assertEquals(((LabelImpl) startEnd[0]).getBCI(), 0);\n+        assertEquals(((LabelImpl) startEnd[1]).getBCI(), 3);\n+        assertEquals(((LabelImpl) startEnd[2]).getBCI(), 1);\n+        assertEquals(((LabelImpl) startEnd[3]).getBCI(), 2);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}