{"files":[{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Set;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AttributeMapper.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Set;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/AttributedElement.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.internal.classfile.impl.AbstractInstruction;\n@@ -472,1 +471,1 @@\n-        NameAndTypeEntry nameAndType = constantPool().natEntry(desc.invocationName(), desc.invocationType());\n+        NameAndTypeEntry nameAndType = constantPool().nameAndTypeEntry(desc.invocationName(), desc.invocationType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.function.Predicate;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/CodeTransform.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Set;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/TypeAnnotation.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-                                ? TemporaryConstantPool.INSTANCE.natEntry(methodName.get(), methodType.get())\n+                                ? TemporaryConstantPool.INSTANCE.nameAndTypeEntry(methodName.get(), methodType.get())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Arrays;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/MethodParametersAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Arrays;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RecordAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.Arrays;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Arrays;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.Arrays;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Arrays;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-\n@@ -33,3 +30,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n-import jdk.internal.classfile.impl.Util;\n-\n@@ -64,68 +58,0 @@\n-\n-    \/**\n-     * Return a {@link List} composed by appending the additions to the base list.\n-     * @param base The base elements for the list, must not include null\n-     * @param additions The {@link ClassEntry} instances to add to the list, must not include null\n-     * @return the combined {@link List}\n-     *\/\n-    static List<ClassEntry> adding(List<ClassEntry> base, List<ClassEntry> additions) {\n-        ArrayList<ClassEntry> members = new ArrayList<>(base);\n-        members.addAll(additions);\n-        return List.copyOf(members);\n-    }\n-\n-    \/**\n-     * Return a {@link List} composed by appending the additions to the base list.\n-     * @param base The base elements for the list, must not include null\n-     * @param additions The {@link ClassEntry} instances to add to the list, must not include null\n-     * @return the combined {@link List}\n-     *\/\n-    static List<ClassEntry> adding(List<ClassEntry> base, ClassEntry... additions) {\n-        ArrayList<ClassEntry> members = new ArrayList<>(base);\n-        for (ClassEntry e : additions) {\n-            members.add(e);\n-        }\n-        return List.copyOf(members);\n-    }\n-\n-    \/**\n-     * Return a {@link List} composed by appending the additions to the base list.\n-     * @param base The base elements for the list, must not include null\n-     * @param additions The {@link ClassDesc} instances to add to the list, must not include null\n-     * @return the combined {@link List}\n-     *\/\n-    static List<ClassEntry> addingSymbols(List<ClassEntry> base, List<ClassDesc> additions) {\n-        ArrayList<ClassEntry> members = new ArrayList<>(base);\n-        members.addAll(Util.entryList(additions));\n-        return List.copyOf(members);\n-    }\n-\n-      \/**\n-     * Return a {@link List} composed by appending the additions to the base list.\n-     * @param base The base elements for the list, must not include null\n-     * @param additions The {@link ClassDesc} instances to add to the list, must not include null\n-     * @return the combined {@link List}\n-     *\/\n-    static List<ClassEntry> addingSymbols(List<ClassEntry> base, ClassDesc...additions) {\n-        ArrayList<ClassEntry> members = new ArrayList<>(base);\n-        for (ClassDesc e : additions) {\n-            members.add(TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(Util.toInternalName(e))));\n-        }\n-        return List.copyOf(members);\n-    }\n-\n-    \/**\n-     * Remove duplicate {@link ClassEntry} elements from the {@link List}.\n-     *\n-     * @param original The list to deduplicate\n-     * @return a {@link List} without any duplicate {@link ClassEntry}\n-     *\/\n-    static List<ClassEntry> deduplicate(List<ClassEntry> original) {\n-        ArrayList<ClassEntry> newList = new ArrayList<>(original.size());\n-        for (ClassEntry e : original) {\n-            if (!newList.contains(e)) {\n-                newList.add(e);\n-            }\n-        }\n-        return List.copyOf(newList);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ClassEntry.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -42,0 +42,5 @@\n+    @Override\n+    default ConstantDesc constantValue() {\n+        return asSymbol();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,19 +30,0 @@\n-import jdk.internal.classfile.impl.ClassReaderImpl;\n-\n-import static jdk.internal.classfile.Classfile.TAG_CLASS;\n-import static jdk.internal.classfile.Classfile.TAG_CONSTANTDYNAMIC;\n-import static jdk.internal.classfile.Classfile.TAG_DOUBLE;\n-import static jdk.internal.classfile.Classfile.TAG_FIELDREF;\n-import static jdk.internal.classfile.Classfile.TAG_FLOAT;\n-import static jdk.internal.classfile.Classfile.TAG_INTEGER;\n-import static jdk.internal.classfile.Classfile.TAG_INTERFACEMETHODREF;\n-import static jdk.internal.classfile.Classfile.TAG_INVOKEDYNAMIC;\n-import static jdk.internal.classfile.Classfile.TAG_LONG;\n-import static jdk.internal.classfile.Classfile.TAG_METHODHANDLE;\n-import static jdk.internal.classfile.Classfile.TAG_METHODREF;\n-import static jdk.internal.classfile.Classfile.TAG_METHODTYPE;\n-import static jdk.internal.classfile.Classfile.TAG_MODULE;\n-import static jdk.internal.classfile.Classfile.TAG_NAMEANDTYPE;\n-import static jdk.internal.classfile.Classfile.TAG_PACKAGE;\n-import static jdk.internal.classfile.Classfile.TAG_STRING;\n-import static jdk.internal.classfile.Classfile.TAG_UTF8;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPool.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.classfile.ClassReader;\n@@ -222,1 +221,1 @@\n-    NameAndTypeEntry natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry);\n+    NameAndTypeEntry nameAndTypeEntry(Utf8Entry nameEntry, Utf8Entry typeEntry);\n@@ -233,2 +232,2 @@\n-    default NameAndTypeEntry natEntry(String name, ClassDesc type) {\n-        return natEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+    default NameAndTypeEntry nameAndTypeEntry(String name, ClassDesc type) {\n+        return nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n@@ -246,2 +245,2 @@\n-    default NameAndTypeEntry natEntry(String name, MethodTypeDesc type) {\n-        return natEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+    default NameAndTypeEntry nameAndTypeEntry(String name, MethodTypeDesc type) {\n+        return nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n@@ -272,1 +271,1 @@\n-        return fieldRefEntry(classEntry(owner), natEntry(name, type));\n+        return fieldRefEntry(classEntry(owner), nameAndTypeEntry(name, type));\n@@ -297,1 +296,1 @@\n-        return methodRefEntry(classEntry(owner), natEntry(name, type));\n+        return methodRefEntry(classEntry(owner), nameAndTypeEntry(name, type));\n@@ -322,1 +321,1 @@\n-        return interfaceMethodRefEntry(classEntry(owner), natEntry(name, type));\n+        return interfaceMethodRefEntry(classEntry(owner), nameAndTypeEntry(name, type));\n@@ -355,1 +354,1 @@\n-        var nat = natEntry(utf8Entry(descriptor.methodName()), utf8Entry(descriptor.lookupDescriptor()));\n+        var nat = nameAndTypeEntry(utf8Entry(descriptor.methodName()), utf8Entry(descriptor.lookupDescriptor()));\n@@ -383,1 +382,1 @@\n-        return invokeDynamicEntry(bsmEntry((DirectMethodHandleDesc)dcsd.bootstrapMethod(), List.of(dcsd.bootstrapArgs())), natEntry(dcsd.invocationName(), dcsd.invocationType()));\n+        return invokeDynamicEntry(bsmEntry((DirectMethodHandleDesc)dcsd.bootstrapMethod(), List.of(dcsd.bootstrapArgs())), nameAndTypeEntry(dcsd.invocationName(), dcsd.invocationType()));\n@@ -407,1 +406,1 @@\n-        return constantDynamicEntry(bsmEntry(dcd.bootstrapMethod(), List.of(dcd.bootstrapArgs())), natEntry(dcd.constantName(), dcd.constantType()));\n+        return constantDynamicEntry(bsmEntry(dcd.bootstrapMethod(), List.of(dcd.bootstrapArgs())), nameAndTypeEntry(dcd.constantName(), dcd.constantType()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -39,0 +40,5 @@\n+    @Override\n+    default ConstantDesc constantValue() {\n+        return asSymbol();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodHandleEntry.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -39,0 +40,5 @@\n+    @Override\n+    default ConstantDesc constantValue() {\n+        return asSymbol();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodTypeEntry.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Set;\n-\n@@ -31,1 +29,0 @@\n-import jdk.internal.classfile.AttributedElement;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.classfile.CodeBuilder;\n-import jdk.internal.classfile.CodeElement;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractBoundLocalVariable.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -44,1 +43,0 @@\n-import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n@@ -374,2 +372,0 @@\n-            } else if (o instanceof Utf8Entry u) {\n-                return equalsString(u.stringValue());\n@@ -657,1 +653,1 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.natEntry(ref1, ref2);\n+            return cp.canWriteDirect(constantPool) ? this : cp.nameAndTypeEntry(ref1, ref2);\n@@ -848,12 +844,0 @@\n-\n-        @Override\n-        public ConstantDesc constantValue() {\n-            List<LoadableConstantEntry> args = bootstrap().arguments();\n-            int argsSize =  args.size();\n-            ConstantDesc[] staticArgs = new ConstantDesc[argsSize];\n-            for (int i = 0; i < argsSize; i++)\n-                staticArgs[i] = args.get(i).constantValue();\n-\n-            return DynamicConstantDesc.ofCanonical(bootstrap().bootstrapMethod().asSymbol(),\n-                                                   nameAndType().name().stringValue(), ClassDesc.ofDescriptor(nameAndType().type().stringValue()), staticArgs);\n-        }\n@@ -887,5 +871,0 @@\n-        @Override\n-        public ConstantDesc constantValue() {\n-            return asSymbol();\n-        }\n-\n@@ -947,5 +926,0 @@\n-        @Override\n-        public ConstantDesc constantValue() {\n-            return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.classfile.Instruction;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.ArrayList;\n@@ -31,1 +30,0 @@\n-import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Set;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.classfile.CodeElement;\n@@ -30,1 +29,0 @@\n-import jdk.internal.classfile.Opcode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundCharacterRange.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.classfile.Opcode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundLocalVariable.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.HashMap;\n@@ -37,1 +36,0 @@\n-import java.util.Map;\n@@ -262,1 +260,1 @@\n-        NameAndTypeEntry bsNameAndType = constantPool.natEntry(constantPool.utf8Entry(bootstrapMethod.methodName()),\n+        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(constantPool.utf8Entry(bootstrapMethod.methodName()),\n@@ -286,1 +284,1 @@\n-        NameAndTypeEntry bsNameAndType = constantPool.natEntry(bootstrapDesc.methodName(),\n+        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(bootstrapDesc.methodName(),\n@@ -294,1 +292,1 @@\n-                                                 constantPool.natEntry(desc.constantName(),\n+                                                 constantPool.nameAndTypeEntry(desc.constantName(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.classfile.Opcode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.classfile.Opcode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LineNumberImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -36,1 +35,0 @@\n-import static java.util.Objects.requireNonNull;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-    public AbstractPoolEntry.NameAndTypeEntryImpl natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n+    public AbstractPoolEntry.NameAndTypeEntryImpl nameAndTypeEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n@@ -423,1 +423,1 @@\n-            ne = natEntry(nameAndType.name(), nameAndType.type());\n+            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n@@ -435,1 +435,1 @@\n-            ne = natEntry(nameAndType.name(), nameAndType.type());\n+            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n@@ -447,1 +447,1 @@\n-            ne = natEntry(nameAndType.name(), nameAndType.type());\n+            ne = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n@@ -498,1 +498,1 @@\n-            nameAndType = natEntry(nameAndType.name(), nameAndType.type());\n+            nameAndType = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n@@ -525,1 +525,1 @@\n-            nameAndType = natEntry(nameAndType.name(), nameAndType.type());\n+            nameAndType = nameAndTypeEntry(nameAndType.name(), nameAndType.type());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public NameAndTypeEntry natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n+    public NameAndTypeEntry nameAndTypeEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.internal.classfile.Opcode;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.classfile.CodeElement;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ConstantInstruction.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Objects;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/ExceptionCatch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        return of(op, owner, TemporaryConstantPool.INSTANCE.natEntry(name, type));\n+        return of(op, owner, TemporaryConstantPool.INSTANCE.nameAndTypeEntry(name, type));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/FieldInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        return of(op, owner, TemporaryConstantPool.INSTANCE.natEntry(name, type), isInterface);\n+        return of(op, owner, TemporaryConstantPool.INSTANCE.nameAndTypeEntry(name, type), isInterface);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.classfile.Classfile;\n@@ -32,1 +31,0 @@\n-import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LabelTarget.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.classfile.attribute.CharacterRangeTableAttribute;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LineNumber.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.classfile.CodeBuilder;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/LocalVariable.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -109,13 +108,12 @@\n-        Set<ClassDesc> dependencies = cm.elementStream()\n-                                        .filter(ce -> ce instanceof MethodModel)\n-                                        .flatMap(ce -> ((MethodModel) ce).elementStream())\n-                                        .filter(me -> me instanceof CodeModel)\n-                                        .flatMap(me -> ((CodeModel) me).elementStream())\n-                                        .<ClassDesc>mapMulti((xe, c) -> {\n-                                            switch (xe) {\n-                                                case InvokeInstruction i -> c.accept(i.owner().asSymbol());\n-                                                case FieldInstruction i -> c.accept(i.owner().asSymbol());\n-                                                default -> { }\n-                                            }\n-                                        })\n-                                        .collect(toSet());\n+        Set<ClassDesc> dependencies =\n+              cm.elementStream()\n+                .flatMap(ce -> ce instanceof MethodMethod mm ? mm.elementStream() : Stream.empty())\n+                .flatMap(me -> me instanceof CodeModel com ? com.elementStream() : Stream.empty())\n+                .<ClassDesc>mapMulti((xe, c) -> {\n+                    switch (xe) {\n+                        case InvokeInstruction i -> c.accept(i.owner().asSymbol());\n+                        case FieldInstruction i -> c.accept(i.owner().asSymbol());\n+                        default -> { }\n+                    }\n+                })\n+                .collect(toSet());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                                    ConstantDynamicEntry cde = cpb.constantDynamicEntry(bme, cpb.natEntry(\"name\", CD_String));\n+                                    ConstantDynamicEntry cde = cpb.constantDynamicEntry(bme, cpb.nameAndTypeEntry(\"name\", CD_String));\n","filename":"test\/jdk\/jdk\/classfile\/BSMTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * @test\n- * @summary Testing Classfile ClassEntry lists methods.\n- * @run junit ClassEntryTest\n- *\/\n-import jdk.internal.classfile.constantpool.ClassEntry;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class ClassEntryTest {\n-\n-    static final List<ClassEntry> additionCE = List.copyOf(ClassEntry.addingSymbols(List.of(), new ClassDesc[] {ConstantDescs.CD_Void, ConstantDescs.CD_Enum, ConstantDescs.CD_Class}));\n-    static final List<ClassDesc> additionCD = List.of(ConstantDescs.CD_Void, ConstantDescs.CD_Enum, ConstantDescs.CD_Class);\n-    static final List<ClassEntry> base = List.copyOf(additionCE);\n-\n-    @Test\n-    void testNPECombos() {\n-        \/\/ NPE on first param\n-        try {\n-            ClassEntry.adding(null, additionCE);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.adding(null, additionCE.get(1), additionCE.get(2));\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.addingSymbols(null, additionCD);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.addingSymbols(null, additionCD.get(1), additionCD.get(2));\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        \/\/ NPE on second param\n-        try {\n-            ClassEntry.adding(base, (List<ClassEntry>)null);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.adding(base, (ClassEntry[])null);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.addingSymbols(base, (List<ClassDesc>)null);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.addingSymbols(base, (ClassDesc[])null);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-    }\n-\n-    @Test\n-    void combine() {\n-        List<ClassEntry> expected = new ArrayList<>(base);\n-        expected.addAll(additionCE);\n-        expected = List.copyOf(expected);\n-        \/\/ Ensure inputs are equivalent before using 'expected' as a common result\n-        assertTrue(listCompare(additionCE, ClassEntry.addingSymbols(List.<ClassEntry>of(), additionCD)));\n-        assertTrue(listCompare(expected, ClassEntry.adding(base, additionCE)));\n-        assertTrue(listCompare(expected, ClassEntry.adding(base, additionCE.toArray(new ClassEntry[0]))));\n-        assertTrue(listCompare(expected, ClassEntry.addingSymbols(base, additionCD)));\n-        assertTrue(listCompare(expected, ClassEntry.addingSymbols(base, additionCD.toArray(new ClassDesc[0]))));\n-    }\n-\n-    boolean listCompare(List<ClassEntry> a, List<ClassEntry> b) {\n-        if (a.size() != b.size()) return false;\n-\n-        for (int i = 0; i < a.size(); i++) {\n-            ClassEntry ca = a.get(i);\n-            ClassEntry cb = b.get(i);\n-            if (!ca.asSymbol().equals(cb.asSymbol())) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    @Test\n-    void throwOnNullAdditions() {\n-        \/\/ NPE when adding a null element\n-        ArrayList<ClassEntry> withNullElement = new ArrayList<ClassEntry>(additionCE);\n-        withNullElement.add(null);\n-        try {\n-            ClassEntry.adding(base, withNullElement);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.adding(base, withNullElement.toArray(new ClassEntry[0]));\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        ArrayList<ClassDesc> withNullElementCD = new ArrayList<ClassDesc>(additionCD);\n-        withNullElementCD.add(null);\n-        try {\n-            ClassEntry.addingSymbols(base, withNullElementCD);\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-        try {\n-            ClassEntry.addingSymbols(base, withNullElementCD.toArray(new ClassDesc[0]));\n-            fail(\"NPE expected\");\n-        } catch(NullPointerException e) { }\n-    }\n-\n-    @Test\n-    void addEmpty() {\n-        assertEquals(base, ClassEntry.adding(base, List.of()));\n-        assertEquals(base, ClassEntry.adding(base, new ClassEntry[0]));\n-        assertEquals(base, ClassEntry.addingSymbols(base, List.of()));\n-        assertEquals(base, ClassEntry.addingSymbols(base, new ClassDesc[0]));\n-    }\n-\n-    @Test\n-    void dedup() {\n-        {\n-            List<ClassEntry> duplicates = ClassEntry.adding(base, base);\n-            List<ClassEntry> dedup = ClassEntry.deduplicate(duplicates);\n-            boolean result = listCompare(base, dedup);\n-            if (!result) {\n-                fail(\"Different: \" + Arrays.toString(base.toArray())+ \" : \" + Arrays.toString(dedup.toArray()));\n-            }\n-            assertTrue(result);\n-        }\n-        {\n-            List<ClassEntry> duplicates = ClassEntry.addingSymbols(List.of(), additionCD);\n-            duplicates = ClassEntry.addingSymbols(duplicates, additionCD);\n-            List<ClassEntry> dedup = ClassEntry.deduplicate(duplicates);\n-            boolean result = listCompare(base, dedup);\n-            if (!result) {\n-                fail(\"Different: \" + Arrays.toString(base.toArray())+ \" : \" + Arrays.toString(dedup.toArray()));\n-            }\n-            assertTrue(result);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/classfile\/ClassEntryTest.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"}]}