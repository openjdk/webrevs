{"files":[{"patch":"@@ -85,1 +85,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -782,1 +782,1 @@\n-            map.put(ConcreteEntry.rawUtf8EntryFromStandardAttributeName(am.name()), am);\n+            map.put(AbstractPoolEntry.rawUtf8EntryFromStandardAttributeName(am.name()), am);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Attributes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.internal.classfile.impl.ConcreteBootstrapMethodEntry;\n+import jdk.internal.classfile.impl.BootstrapMethodEntryImpl;\n@@ -43,1 +43,1 @@\n-        permits ConcreteBootstrapMethodEntry {\n+        permits BootstrapMethodEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/BootstrapMethodEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -215,1 +215,1 @@\n-        thisClassEntry = ConcreteEntry.maybeClone(constantPool, thisClassEntry);\n+        thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClassEntry);\n@@ -283,2 +283,2 @@\n-                for (var exp : moduleAttribute.exports()) allPackages.add(ConcreteEntry.maybeClone(cp, exp.exportedPackage()));\n-                for (var opn : moduleAttribute.opens()) allPackages.add(ConcreteEntry.maybeClone(cp, opn.openedPackage()));\n+                for (var exp : moduleAttribute.exports()) allPackages.add(AbstractPoolEntry.maybeClone(cp, exp.exportedPackage()));\n+                for (var opn : moduleAttribute.opens()) allPackages.add(AbstractPoolEntry.maybeClone(cp, opn.openedPackage()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Classfile.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -43,1 +43,1 @@\n-        permits ConcreteEntry.ConcreteClassEntry {\n+        permits AbstractPoolEntry.ClassEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ClassEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -40,1 +40,1 @@\n-        permits ConcreteEntry.ConcreteConstantDynamicEntry {\n+        permits AbstractPoolEntry.ConstantDynamicEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -36,1 +36,1 @@\n-        permits ConcreteEntry.ConcreteDoubleEntry {\n+        permits AbstractPoolEntry.DoubleEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/DoubleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -34,1 +34,1 @@\n-        permits ConcreteEntry.ConcreteFieldRefEntry {\n+        permits AbstractPoolEntry.FieldRefEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/FieldRefEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -36,1 +36,1 @@\n-        permits ConcreteEntry.ConcreteFloatEntry {\n+        permits AbstractPoolEntry.FloatEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/FloatEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -36,1 +36,1 @@\n-        permits ConcreteEntry.ConcreteIntegerEntry {\n+        permits AbstractPoolEntry.IntegerEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/IntegerEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -35,1 +35,1 @@\n-        permits ConcreteEntry.ConcreteInterfaceMethodRefEntry {\n+        permits AbstractPoolEntry.InterfaceMethodRefEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/InterfaceMethodRefEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -38,1 +38,1 @@\n-        permits ConcreteEntry.ConcreteInvokeDynamicEntry {\n+        permits AbstractPoolEntry.InvokeDynamicEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/InvokeDynamicEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -36,1 +36,1 @@\n-        permits ConcreteEntry.ConcreteLongEntry {\n+        permits AbstractPoolEntry.LongEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/LongEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -34,1 +34,1 @@\n-        permits FieldRefEntry, InterfaceMethodRefEntry, MethodRefEntry, ConcreteEntry.MemberRefEntry {\n+        permits FieldRefEntry, InterfaceMethodRefEntry, MethodRefEntry, AbstractPoolEntry.AbstractMemberRefEntry {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MemberRefEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -37,1 +37,1 @@\n-        permits ConcreteEntry.ConcreteMethodHandleEntry {\n+        permits AbstractPoolEntry.MethodHandleEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodHandleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -34,1 +34,1 @@\n-        permits ConcreteEntry.ConcreteMethodRefEntry {\n+        permits AbstractPoolEntry.MethodRefEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodRefEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -37,1 +37,1 @@\n-        permits ConcreteEntry.ConcreteMethodTypeEntry {\n+        permits AbstractPoolEntry.MethodTypeEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodTypeEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -35,1 +35,1 @@\n-        permits ConcreteEntry.ConcreteModuleEntry {\n+        permits AbstractPoolEntry.ModuleEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ModuleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -34,1 +34,1 @@\n-        permits ConcreteEntry.ConcreteNameAndTypeEntry {\n+        permits AbstractPoolEntry.NameAndTypeEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/NameAndTypeEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -35,1 +35,1 @@\n-        permits ConcreteEntry.ConcretePackageEntry {\n+        permits AbstractPoolEntry.PackageEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/PackageEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -35,1 +35,1 @@\n-        permits ConcreteEntry.ConcreteStringEntry {\n+        permits AbstractPoolEntry.StringEntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/StringEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.classfile.impl.ConcreteEntry;\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -35,1 +35,1 @@\n-        permits ConcreteEntry.ConcreteUtf8Entry {\n+        permits AbstractPoolEntry.Utf8EntryImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/Utf8Entry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1173 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.constant.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.constantpool.DoubleEntry;\n+import jdk.internal.classfile.constantpool.FieldRefEntry;\n+import jdk.internal.classfile.constantpool.FloatEntry;\n+import jdk.internal.classfile.constantpool.IntegerEntry;\n+import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n+import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.LongEntry;\n+import jdk.internal.classfile.constantpool.MemberRefEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.MethodRefEntry;\n+import jdk.internal.classfile.constantpool.MethodTypeEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n+import jdk.internal.classfile.constantpool.PoolEntry;\n+import jdk.internal.classfile.constantpool.StringEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+import jdk.internal.classfile.jdktypes.ModuleDesc;\n+import jdk.internal.classfile.jdktypes.PackageDesc;\n+\n+public abstract sealed class AbstractPoolEntry {\n+    \/*\n+    Invariant: a {CP,BSM} entry for pool P refer only to {CP,BSM} entries\n+    from P or P's parent.  This is enforced by the various xxxEntry methods\n+    in SplitConstantPool.  As a result, code in this file can use writeU2\n+    instead of writeIndex.\n+\n+    Cloning of entries may be a no-op if the entry is already on the right pool\n+    (which implies that the referenced entries will also be on the right pool.)\n+     *\/\n+\n+    private static final int TAG_SMEAR = 0x13C4B2D1;\n+    private static final int INT_PHI = 0x9E3779B9;\n+\n+    public static int hash1(int tag, int x1) {\n+        return phiMix(tag * TAG_SMEAR + x1);\n+    }\n+\n+    public static int hash2(int tag, int x1, int x2) {\n+        return phiMix(tag * TAG_SMEAR + x1 + 31*x2);\n+    }\n+\n+    \/\/ Ensure that hash is never zero\n+    public static int hashString(int stringHash) {\n+        return phiMix(stringHash | (1 << 30));\n+    }\n+\n+    public static int phiMix(int x) {\n+        int h = x * INT_PHI;\n+        return h ^ (h >> 16);\n+    }\n+\n+    public static Utf8Entry rawUtf8EntryFromStandardAttributeName(String name) {\n+        \/\/assuming standard attribute names are all US_ASCII\n+        var raw = name.getBytes(StandardCharsets.US_ASCII);\n+        return new Utf8EntryImpl(null, 0, raw, 0, raw.length);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends PoolEntry> T maybeClone(ConstantPoolBuilder cp, T entry) {\n+        return (T)((AbstractPoolEntry)entry).clone(cp);\n+    }\n+\n+    final ConstantPool constantPool;\n+    public final byte tag;\n+    private final int index;\n+    private final int hash;\n+\n+    private AbstractPoolEntry(ConstantPool constantPool, int tag, int index, int hash) {\n+        this.tag = (byte) tag;\n+        this.index = index;\n+        this.hash = hash;\n+        this.constantPool = constantPool;\n+    }\n+\n+    public ConstantPool constantPool() { return constantPool; }\n+\n+    public int index() { return index; }\n+\n+    public int hashCode() {\n+        return hash;\n+    }\n+\n+    public byte tag() {\n+        return tag;\n+    }\n+\n+    public int width() {\n+        return (tag == Classfile.TAG_LONG || tag == Classfile.TAG_DOUBLE) ? 2 : 1;\n+    }\n+\n+    abstract PoolEntry clone(ConstantPoolBuilder cp);\n+\n+    public static final class Utf8EntryImpl extends AbstractPoolEntry implements Utf8Entry {\n+        \/\/ Processing UTF8 from the constant pool is one of the more expensive\n+        \/\/ operations, and often, we don't actually need access to the constant\n+        \/\/ as a string.  So there are multiple layers of laziness in UTF8\n+        \/\/ constants.  In the first stage, all we do is record the range of\n+        \/\/ bytes in the classfile.  If the size or hashCode is needed, then we\n+        \/\/ process the raw bytes into a byte[] or char[], but do not inflate\n+        \/\/ a String.  If a string is needed, it too is inflated lazily.\n+        \/\/ If we construct a Utf8Entry from a string, we generate the encoding\n+        \/\/ at write time.\n+\n+        enum State { RAW, BYTE, CHAR, STRING }\n+\n+        private State state;\n+        private final byte[] rawBytes; \/\/ null if initialized directly from a string\n+        private final int offset;\n+        private final int rawLen;\n+        \/\/ Set in any state other than RAW\n+        private int hash;\n+        private int charLen;\n+        \/\/ Set in CHAR state\n+        private char[] chars;\n+        \/\/ Only set in STRING state\n+        private String stringValue;\n+\n+        Utf8EntryImpl(ConstantPool cpm, int index,\n+                          byte[] rawBytes, int offset, int rawLen) {\n+            super(cpm, Classfile.TAG_UTF8, index, 0);\n+            this.rawBytes = rawBytes;\n+            this.offset = offset;\n+            this.rawLen = rawLen;\n+            this.state = State.RAW;\n+        }\n+\n+        Utf8EntryImpl(ConstantPool cpm, int index, String s) {\n+            super(cpm, Classfile.TAG_UTF8, index, 0);\n+            this.rawBytes = null;\n+            this.offset = 0;\n+            this.rawLen = 0;\n+            this.state = State.STRING;\n+            this.stringValue = s;\n+            this.charLen = s.length();\n+            this.hash = hashString(s.hashCode());\n+        }\n+\n+        Utf8EntryImpl(ConstantPool cpm, int index, Utf8EntryImpl u) {\n+            super(cpm, Classfile.TAG_UTF8, index, 0);\n+            this.rawBytes = u.rawBytes;\n+            this.offset = u.offset;\n+            this.rawLen = u.rawLen;\n+            this.state = u.state;\n+            this.hash = u.hash;\n+            this.charLen = u.charLen;\n+            this.chars = u.chars;\n+            this.stringValue = u.stringValue;\n+        }\n+\n+        \/**\n+         * {@jvms 4.4.7} String content is encoded in modified UTF-8.\n+         *\n+         * Modified UTF-8 strings are encoded so that code point sequences that\n+         * contain only non-null ASCII characters can be represented using only 1\n+         * byte per code point, but all code points in the Unicode codespace can be\n+         * represented.\n+         *\n+         * Modified UTF-8 strings are not null-terminated.\n+         *\n+         * Code points in the range '\\u0001' to '\\u007F' are represented by a single\n+         * byte.\n+         *\n+         * The null code point ('\\u0000') and code points in the range '\\u0080' to\n+         * '\\u07FF' are represented by a pair of bytes.\n+         *\n+         * Code points in the range '\\u0800' to '\\uFFFF' are represented by 3 bytes.\n+         *\n+         * Characters with code points above U+FFFF (so-called supplementary\n+         * characters) are represented by separately encoding the two surrogate code\n+         * units of their UTF-16 representation. Each of the surrogate code units is\n+         * represented by three bytes. This means supplementary characters are\n+         * represented by six bytes.\n+         *\n+         * The bytes of multibyte characters are stored in the class file in\n+         * big-endian (high byte first) order.\n+         *\n+         * There are two differences between this format and the \"standard\" UTF-8\n+         * format. First, the null character (char)0 is encoded using the 2-byte\n+         * format rather than the 1-byte format, so that modified UTF-8 strings\n+         * never have embedded nulls. Second, only the 1-byte, 2-byte, and 3-byte\n+         * formats of standard UTF-8 are used. The Java Virtual Machine does not\n+         * recognize the four-byte format of standard UTF-8; it uses its own\n+         * two-times-three-byte format instead.\n+         *\/\n+        private void inflate() {\n+            int hash = 0;\n+            boolean foundHigh = false;\n+\n+            int px = offset;\n+            int utfend = px + rawLen;\n+            while (px < utfend) {\n+                int c = (int) rawBytes[px] & 0xff;\n+                if (c > 127) {\n+                    foundHigh = true;\n+                    break;\n+                }\n+                hash = 31 * hash + c;\n+                px++;\n+            }\n+\n+            if (!foundHigh) {\n+                this.hash = hashString(hash);\n+                charLen = rawLen;\n+                state = State.BYTE;\n+            }\n+            else {\n+                char[] chararr = new char[rawLen];\n+                int chararr_count = 0;\n+                \/\/ Inflate prefix of bytes to characters\n+                for (int i = offset; i < px; i++) {\n+                    int c = (int) rawBytes[i] & 0xff;\n+                    chararr[chararr_count++] = (char) c;\n+                }\n+                while (px < utfend) {\n+                    int c = (int) rawBytes[px] & 0xff;\n+                    switch (c >> 4) {\n+                        case 0, 1, 2, 3, 4, 5, 6, 7: {\n+                            \/\/ 0xxx xxxx\n+                            px++;\n+                            chararr[chararr_count++] = (char) c;\n+                            hash = 31 * hash + c;\n+                            break;\n+                        }\n+                        case 12, 13: {\n+                            \/\/ 110x xxxx  10xx xxxx\n+                            px += 2;\n+                            if (px > utfend) {\n+                                throw new CpException(\"malformed input: partial character at end\");\n+                            }\n+                            int char2 = rawBytes[px - 1];\n+                            if ((char2 & 0xC0) != 0x80) {\n+                                throw new CpException(\"malformed input around byte \" + px);\n+                            }\n+                            char v = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));\n+                            chararr[chararr_count++] = v;\n+                            hash = 31 * hash + v;\n+                            break;\n+                        }\n+                        case 14: {\n+                            \/\/ 1110 xxxx  10xx xxxx  10xx xxxx\n+                            px += 3;\n+                            if (px > utfend) {\n+                                throw new CpException(\"malformed input: partial character at end\");\n+                            }\n+                            int char2 = rawBytes[px - 2];\n+                            int char3 = rawBytes[px - 1];\n+                            if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {\n+                                throw new CpException(\"malformed input around byte \" + (px - 1));\n+                            }\n+                            char v = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));\n+                            chararr[chararr_count++] = v;\n+                            hash = 31 * hash + v;\n+                            break;\n+                        }\n+                        default:\n+                            \/\/ 10xx xxxx,  1111 xxxx\n+                            throw new CpException(\"malformed input around byte \" + px);\n+                    }\n+                }\n+                this.hash = hashString(hash);\n+                charLen = chararr_count;\n+                this.chars = chararr;\n+                state = State.CHAR;\n+            }\n+\n+        }\n+\n+        @Override\n+        public Utf8EntryImpl clone(ConstantPoolBuilder cp) {\n+            if (cp.canWriteDirect(constantPool))\n+                return this;\n+            return (state == State.STRING && rawBytes == null)\n+                   ? (Utf8EntryImpl) cp.utf8Entry(stringValue)\n+                   : ((SplitConstantPool) cp).maybeCloneUtf8Entry(this);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (state == State.RAW)\n+                inflate();\n+            return hash;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (state == State.RAW)\n+                inflate();\n+            if (state != State.STRING) {\n+                stringValue = (chars != null)\n+                              ? new String(chars, 0, charLen)\n+                              : new String(rawBytes, offset, charLen, StandardCharsets.UTF_8);\n+                state = State.STRING;\n+            }\n+            return stringValue;\n+        }\n+\n+        @Override\n+        public String stringValue() {\n+            return toString();\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return stringValue();\n+        }\n+\n+        @Override\n+        public int length() {\n+            if (state == State.RAW)\n+                inflate();\n+            return charLen;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            if (state == State.STRING)\n+                return stringValue.charAt(index);\n+            if (state == State.RAW)\n+                inflate();\n+            return (chars != null)\n+                   ? chars[index]\n+                   : (char) rawBytes[index + offset];\n+        }\n+\n+        @Override\n+        public CharSequence subSequence(int start, int end) {\n+            return toString().subSequence(start, end);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof Utf8EntryImpl u) {\n+                return equalsUtf8(u);\n+            } else if (o instanceof Utf8Entry u) {\n+                return equalsString(u.stringValue());\n+            }\n+            return false;\n+        }\n+\n+        public boolean equalsUtf8(Utf8EntryImpl u) {\n+            if (hashCode() != u.hashCode()\n+                || length() != u.length())\n+                return false;\n+            if (rawBytes != null && u.rawBytes != null)\n+                return Arrays.equals(rawBytes, offset, offset + rawLen,\n+                                     u.rawBytes, u.offset, u.offset + u.rawLen);\n+            else if ((state == State.STRING && u.state == State.STRING))\n+                return stringValue.equals(u.stringValue);\n+            else\n+                return stringValue().equals(u.stringValue());\n+        }\n+\n+        @Override\n+        public boolean equalsString(String s) {\n+            if (state == State.RAW)\n+                inflate();\n+            switch (state) {\n+                case STRING:\n+                    return stringValue.equals(s);\n+                case CHAR:\n+                    if (charLen != s.length() || hash != hashString(s.hashCode()))\n+                        return false;\n+                    for (int i=0; i<charLen; i++)\n+                        if (chars[i] != s.charAt(i))\n+                            return false;\n+                    stringValue = s;\n+                    state = State.STRING;\n+                    return true;\n+                case BYTE:\n+                    if (rawLen != s.length() || hash != hashString(s.hashCode()))\n+                        return false;\n+                    for (int i=0; i<rawLen; i++)\n+                        if (rawBytes[offset+i] != s.charAt(i))\n+                            return false;\n+                    stringValue = s;\n+                    state = State.STRING;\n+                    return true;\n+            }\n+            throw new IllegalStateException(\"cannot reach here\");\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            if (rawBytes != null) {\n+                pool.writeU1(tag);\n+                pool.writeU2(rawLen);\n+                pool.writeBytes(rawBytes, offset, rawLen);\n+            }\n+            else {\n+                \/\/ state == STRING and no raw bytes\n+                if (stringValue.length() > 65535) {\n+                    throw new IllegalArgumentException(\"string too long\");\n+                }\n+                pool.writeU1(tag);\n+                pool.writeU2(charLen);\n+                for (int i = 0; i < charLen; ++i) {\n+                    char c = stringValue.charAt(i);\n+                    if (c >= '\\001' && c <= '\\177') {\n+                        \/\/ Optimistic writing -- hope everything is bytes\n+                        \/\/ If not, we bail out, and alternate path patches the length\n+                        pool.writeU1((byte) c);\n+                    }\n+                    else {\n+                        int charLength = stringValue.length();\n+                        int byteLength = i;\n+                        char c1;\n+                        for (int j = i; j < charLength; ++j) {\n+                            c1 = (stringValue).charAt(j);\n+                            if (c1 >= '\\001' && c1 <= '\\177') {\n+                                byteLength++;\n+                            } else if (c1 > '\\u07FF') {\n+                                byteLength += 3;\n+                            } else {\n+                                byteLength += 2;\n+                            }\n+                        }\n+                        if (byteLength > 65535) {\n+                            throw new IllegalArgumentException();\n+                        }\n+                        int byteLengthFinal = byteLength;\n+                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n+                        for (int j = i; j < charLength; ++j) {\n+                            c1 = (stringValue).charAt(j);\n+                            if (c1 >= '\\001' && c1 <= '\\177') {\n+                                pool.writeU1((byte) c1);\n+                            } else if (c1 > '\\u07FF') {\n+                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n+                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n+                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n+                            } else {\n+                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n+                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static abstract sealed class AbstractRefEntry<T extends PoolEntry> extends AbstractPoolEntry {\n+        protected final T ref1;\n+\n+        public AbstractRefEntry(ConstantPool constantPool, int tag, int index, T ref1) {\n+            super(constantPool, tag, index, hash1(tag, ref1.index()));\n+            this.ref1 = ref1;\n+        }\n+\n+        public T ref1() {\n+            return ref1;\n+        }\n+\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU2(ref1.index());\n+        }\n+\n+        public String toString() {\n+            return tag() + \" \" + ref1();\n+        }\n+    }\n+\n+    static abstract sealed class AbstractRefsEntry<T extends PoolEntry, U extends PoolEntry>\n+            extends AbstractPoolEntry {\n+        protected final T ref1;\n+        protected final U ref2;\n+\n+        public AbstractRefsEntry(ConstantPool constantPool, int tag, int index, T ref1, U ref2) {\n+            super(constantPool, tag, index, hash2(tag, ref1.index(), ref2.index()));\n+            this.ref1 = ref1;\n+            this.ref2 = ref2;\n+        }\n+\n+        public T ref1() {\n+            return ref1;\n+        }\n+\n+        public U ref2() {\n+            return ref2;\n+        }\n+\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU2(ref1.index());\n+            pool.writeU2(ref2.index());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + ref1 + \"-\" + ref2;\n+        }\n+    }\n+\n+    static abstract sealed class AbstractNamedEntry extends AbstractRefEntry<Utf8EntryImpl> {\n+\n+        public AbstractNamedEntry(ConstantPool constantPool, int tag, int index, Utf8EntryImpl ref1) {\n+            super(constantPool, tag, index, ref1);\n+        }\n+\n+        public Utf8Entry name() {\n+            return ref1;\n+        }\n+\n+        public String asInternalName() {\n+            return ref1.stringValue();\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this) { return true; }\n+            if (o instanceof AbstractNamedEntry ne) {\n+                return tag == ne.tag() && name().equals(ref1());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ClassEntryImpl extends AbstractNamedEntry implements ClassEntry {\n+\n+        ClassEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl name) {\n+            super(cpm, Classfile.TAG_CLASS, index, name);\n+        }\n+\n+        @Override\n+        public ClassEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n+        }\n+\n+        @Override\n+        public ClassDesc asSymbol() {\n+            return Util.toClassDesc(asInternalName());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ClassEntryImpl cce) {\n+                return cce.name().equals(this.name());\n+            } else if (o instanceof ClassEntry c) {\n+                return c.asSymbol().equals(this.asSymbol());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class PackageEntryImpl extends AbstractNamedEntry implements PackageEntry {\n+\n+        PackageEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl name) {\n+            super(cpm, Classfile.TAG_PACKAGE, index, name);\n+        }\n+\n+        @Override\n+        public PackageEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.packageEntry(ref1);\n+        }\n+\n+        @Override\n+        public PackageDesc asSymbol() {\n+            return PackageDesc.ofInternalName(asInternalName());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof PackageEntry p) {\n+                return name().equals(p.name());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class ModuleEntryImpl extends AbstractNamedEntry implements ModuleEntry {\n+\n+        ModuleEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl name) {\n+            super(cpm, Classfile.TAG_MODULE, index, name);\n+        }\n+\n+        @Override\n+        public ModuleEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.moduleEntry(ref1);\n+        }\n+\n+        @Override\n+        public ModuleDesc asSymbol() {\n+            return ModuleDesc.of(asInternalName());\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof ModuleEntryImpl m) {\n+                return name().equals(m.name());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class NameAndTypeEntryImpl extends AbstractRefsEntry<Utf8EntryImpl, Utf8EntryImpl>\n+            implements NameAndTypeEntry {\n+\n+        NameAndTypeEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl name, Utf8EntryImpl type) {\n+            super(cpm, Classfile.TAG_NAMEANDTYPE, index, name, type);\n+        }\n+\n+        @Override\n+        public Utf8Entry name() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public Utf8Entry type() {\n+            return ref2;\n+        }\n+\n+        @Override\n+        public NameAndTypeEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.natEntry(ref1, ref2);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof NameAndTypeEntryImpl nat) {\n+                return name().equals(nat.name()) && type().equals(nat.type());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static abstract sealed class AbstractMemberRefEntry\n+            extends AbstractRefsEntry<ClassEntryImpl, NameAndTypeEntryImpl>\n+            implements MemberRefEntry {\n+\n+        AbstractMemberRefEntry(ConstantPool cpm, int tag, int index, ClassEntryImpl owner,\n+                       NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, tag, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public ClassEntryImpl owner() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public NameAndTypeEntryImpl nameAndType() {\n+            return ref2;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + owner().asInternalName() + \".\" + nameAndType().name().stringValue()\n+                   + \"-\" + nameAndType().type().stringValue();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof AbstractMemberRefEntry m) {\n+                return tag == m.tag()\n+                && owner().equals(m.owner())\n+                && nameAndType().equals(m.nameAndType());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class FieldRefEntryImpl extends AbstractMemberRefEntry implements FieldRefEntry {\n+\n+        FieldRefEntryImpl(ConstantPool cpm, int index,\n+                              ClassEntryImpl owner, NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_FIELDREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public FieldRefEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.fieldRefEntry(ref1, ref2);\n+        }\n+    }\n+\n+    public static final class MethodRefEntryImpl extends AbstractMemberRefEntry implements MethodRefEntry {\n+\n+        MethodRefEntryImpl(ConstantPool cpm, int index,\n+                               ClassEntryImpl owner, NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_METHODREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public MethodRefEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.methodRefEntry(ref1, ref2);\n+        }\n+    }\n+\n+    public static final class InterfaceMethodRefEntryImpl extends AbstractMemberRefEntry implements InterfaceMethodRefEntry {\n+\n+        InterfaceMethodRefEntryImpl(ConstantPool cpm, int index, ClassEntryImpl owner,\n+                                        NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_INTERFACEMETHODREF, index, owner, nameAndType);\n+        }\n+\n+        @Override\n+        public InterfaceMethodRefEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.interfaceMethodRefEntry(ref1, ref2);\n+        }\n+    }\n+\n+    public static abstract sealed class AbstractDynamicConstantPoolEntry extends AbstractPoolEntry {\n+\n+        private final int bsmIndex;\n+        private BootstrapMethodEntryImpl bootstrapMethod;\n+        private final NameAndTypeEntryImpl nameAndType;\n+\n+        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, BootstrapMethodEntryImpl bootstrapMethod,\n+                                         NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, tag, index, hash);\n+            this.bsmIndex = bootstrapMethod.bsmIndex();\n+            this.bootstrapMethod = bootstrapMethod;\n+            this.nameAndType = nameAndType;\n+        }\n+\n+        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, int bsmIndex,\n+                                         NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, tag, index, hash);\n+            this.bsmIndex = bsmIndex;\n+            this.bootstrapMethod = null;\n+            this.nameAndType = nameAndType;\n+        }\n+\n+        \/**\n+         * @return the bootstrapMethod\n+         *\/\n+        public BootstrapMethodEntryImpl bootstrap() {\n+            if (bootstrapMethod == null) {\n+                bootstrapMethod = (BootstrapMethodEntryImpl) constantPool.bootstrapMethodEntry(bsmIndex);\n+            }\n+            return bootstrapMethod;\n+        }\n+\n+        \/**\n+         * @return the nameAndType\n+         *\/\n+        public NameAndTypeEntryImpl nameAndType() {\n+            return nameAndType;\n+        }\n+\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU2(bsmIndex);\n+            pool.writeU2(nameAndType.index());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + bootstrap() + \".\" + nameAndType().name().stringValue()\n+                   + \"-\" + nameAndType().type().stringValue();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof AbstractDynamicConstantPoolEntry d) {\n+                return this.tag() == d.tag()\n+                && bootstrap().equals(d.bootstrap())\n+                && nameAndType.equals(d.nameAndType());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class InvokeDynamicEntryImpl\n+            extends AbstractDynamicConstantPoolEntry\n+            implements InvokeDynamicEntry {\n+\n+        InvokeDynamicEntryImpl(ConstantPool cpm, int index, int hash, BootstrapMethodEntryImpl bootstrapMethod,\n+                                   NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_INVOKEDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n+        }\n+\n+        InvokeDynamicEntryImpl(ConstantPool cpm, int index, int bsmIndex,\n+                                   NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_INVOKEDYNAMIC, index, hash2(Classfile.TAG_INVOKEDYNAMIC, bsmIndex, nameAndType.index()),\n+                  bsmIndex, nameAndType);\n+        }\n+\n+        @Override\n+        public InvokeDynamicEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.invokeDynamicEntry(bootstrap(), nameAndType());\n+        }\n+    }\n+\n+    public static final class ConstantDynamicEntryImpl extends AbstractDynamicConstantPoolEntry\n+            implements ConstantDynamicEntry {\n+\n+        ConstantDynamicEntryImpl(ConstantPool cpm, int index, int hash, BootstrapMethodEntryImpl bootstrapMethod,\n+                                     NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_CONSTANTDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n+        }\n+\n+        ConstantDynamicEntryImpl(ConstantPool cpm, int index, int bsmIndex,\n+                                     NameAndTypeEntryImpl nameAndType) {\n+            super(cpm, Classfile.TAG_CONSTANTDYNAMIC, index, hash2(Classfile.TAG_CONSTANTDYNAMIC, bsmIndex, nameAndType.index()),\n+                  bsmIndex, nameAndType);\n+        }\n+\n+        @Override\n+        public ConstantDynamicEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.constantDynamicEntry(bootstrap(), nameAndType());\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            List<LoadableConstantEntry> args = bootstrap().arguments();\n+            int argsSize =  args.size();\n+            ConstantDesc[] staticArgs = new ConstantDesc[argsSize];\n+            for (int i = 0; i < argsSize; i++)\n+                staticArgs[i] = args.get(i).constantValue();\n+\n+            return DynamicConstantDesc.ofCanonical(bootstrap().bootstrapMethod().asSymbol(),\n+                                                   nameAndType().name().stringValue(), ClassDesc.ofDescriptor(nameAndType().type().stringValue()), staticArgs);\n+        }\n+    }\n+\n+    public static final class MethodHandleEntryImpl extends AbstractPoolEntry\n+            implements MethodHandleEntry {\n+\n+        private final int refKind;\n+        private final AbstractPoolEntry.AbstractMemberRefEntry reference;\n+\n+        MethodHandleEntryImpl(ConstantPool cpm, int index, int hash, int refKind, AbstractPoolEntry.AbstractMemberRefEntry\n+                reference) {\n+            super(cpm, Classfile.TAG_METHODHANDLE, index, hash);\n+            this.refKind = refKind;\n+            this.reference = reference;\n+        }\n+\n+        MethodHandleEntryImpl(ConstantPool cpm, int index, int refKind, AbstractPoolEntry.AbstractMemberRefEntry\n+                reference) {\n+            super(cpm, Classfile.TAG_METHODHANDLE, index, hash2(Classfile.TAG_METHODHANDLE, refKind, reference.index()));\n+            this.refKind = refKind;\n+            this.reference = reference;\n+        }\n+\n+        @Override\n+        public int kind() {\n+            return refKind;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return asSymbol();\n+        }\n+\n+        @Override\n+        public AbstractPoolEntry.AbstractMemberRefEntry reference() {\n+            return reference;\n+        }\n+\n+        @Override\n+        public DirectMethodHandleDesc asSymbol() {\n+            return MethodHandleDesc.of(\n+                    DirectMethodHandleDesc.Kind.valueOf(kind(), reference() instanceof InterfaceMethodRefEntry),\n+                    ((MemberRefEntry) reference()).owner().asSymbol(),\n+                    ((MemberRefEntry) reference()).nameAndType().name().stringValue(),\n+                    ((MemberRefEntry) reference()).nameAndType().type().stringValue());\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeU1(refKind);\n+            pool.writeU2(reference.index());\n+        }\n+\n+        @Override\n+        public MethodHandleEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.methodHandleEntry(refKind, reference);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \" + kind() + \":\" + ((MemberRefEntry) reference()).owner().asInternalName() + \".\" + ((MemberRefEntry) reference()).nameAndType().name().stringValue()\n+                   + \"-\" + ((MemberRefEntry) reference()).nameAndType().type().stringValue();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof MethodHandleEntryImpl m) {\n+                return kind() == m.kind()\n+                && reference.equals(m.reference());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class MethodTypeEntryImpl\n+            extends AbstractRefEntry<Utf8EntryImpl>\n+            implements MethodTypeEntry {\n+\n+        MethodTypeEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl descriptor) {\n+            super(cpm, Classfile.TAG_METHODTYPE, index, descriptor);\n+        }\n+\n+        public Utf8Entry descriptor() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n+        }\n+\n+        @Override\n+        public MethodTypeEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.methodTypeEntry(ref1);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof MethodTypeEntryImpl m) {\n+                return descriptor().equals(m.descriptor());\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class StringEntryImpl\n+            extends AbstractRefEntry<Utf8EntryImpl>\n+            implements StringEntry {\n+\n+        StringEntryImpl(ConstantPool cpm, int index, Utf8EntryImpl utf8) {\n+            super(cpm, Classfile.TAG_STRING, index, utf8);\n+        }\n+\n+        @Override\n+        public Utf8EntryImpl utf8() {\n+            return ref1;\n+        }\n+\n+        @Override\n+        public String stringValue() {\n+            return ref1.toString();\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return stringValue();\n+        }\n+\n+        @Override\n+        public StringEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.stringEntry(ref1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return tag() + \" \\\"\" + stringValue() + \"\\\"\";\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (o instanceof StringEntryImpl s) {\n+                \/\/ check utf8 rather allocating a string\n+                return utf8().equals(s.utf8());\n+            }\n+            return false;\n+        }\n+\n+\n+    }\n+\n+    static abstract sealed class PrimitiveEntry<T extends ConstantDesc>\n+            extends AbstractPoolEntry {\n+        protected final T val;\n+\n+        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n+            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n+            this.val = val;\n+        }\n+\n+        public T value() {\n+            return val;\n+        }\n+\n+        public ConstantDesc constantValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"\" + tag() + value();\n+        }\n+    }\n+\n+    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n+            implements IntegerEntry {\n+\n+        IntegerEntryImpl(ConstantPool cpm, int index, int i) {\n+            super(cpm, Classfile.TAG_INTEGER, index, i);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeInt(val);\n+        }\n+\n+        @Override\n+        public IntegerEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.intEntry(val);\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof IntegerEntryImpl e) {\n+                return intValue() == e.intValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class FloatEntryImpl extends PrimitiveEntry<Float>\n+            implements FloatEntry {\n+\n+        FloatEntryImpl(ConstantPool cpm, int index, float f) {\n+            super(cpm, Classfile.TAG_FLOAT, index, f);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeFloat(val);\n+        }\n+\n+        @Override\n+        public FloatEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.floatEntry(val);\n+        }\n+\n+        @Override\n+        public float floatValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof FloatEntryImpl e) {\n+                return floatValue() == e.floatValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class LongEntryImpl extends PrimitiveEntry<Long> implements LongEntry {\n+\n+        LongEntryImpl(ConstantPool cpm, int index, long l) {\n+            super(cpm, Classfile.TAG_LONG, index, l);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeLong(val);\n+        }\n+\n+        @Override\n+        public LongEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.longEntry(val);\n+        }\n+\n+        @Override\n+        public long longValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof LongEntryImpl e) {\n+                return longValue() == e.longValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class DoubleEntryImpl extends PrimitiveEntry<Double> implements DoubleEntry {\n+\n+        DoubleEntryImpl(ConstantPool cpm, int index, double d) {\n+            super(cpm, Classfile.TAG_DOUBLE, index, d);\n+        }\n+\n+        @Override\n+        public void writeTo(BufWriter pool) {\n+            pool.writeU1(tag);\n+            pool.writeDouble(val);\n+        }\n+\n+        @Override\n+        public DoubleEntry clone(ConstantPoolBuilder cp) {\n+            return cp.canWriteDirect(constantPool) ? this : cp.doubleEntry(val);\n+        }\n+\n+        @Override\n+        public double doubleValue() {\n+            return value();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o instanceof DoubleEntryImpl e) {\n+                return doubleValue() == e.doubleValue();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static class CpException extends RuntimeException {\n+        static final long serialVersionUID = 32L;\n+\n+        CpException(String s) {\n+            super(s);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":1173,"deletions":0,"binary":false,"changes":1173,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.internal.classfile.constantpool.ConstantPool;\n+import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n+import jdk.internal.classfile.BootstrapMethodEntry;\n+import jdk.internal.classfile.BufWriter;\n+import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+\n+import static jdk.internal.classfile.impl.AbstractPoolEntry.MethodHandleEntryImpl;\n+\n+public final class BootstrapMethodEntryImpl implements BootstrapMethodEntry {\n+\n+    final int index;\n+    final int hash;\n+    private final ConstantPool constantPool;\n+    private final MethodHandleEntryImpl handle;\n+    private final List<LoadableConstantEntry> arguments;\n+\n+    BootstrapMethodEntryImpl(ConstantPool constantPool, int bsmIndex, int hash,\n+                                 MethodHandleEntryImpl handle,\n+                                 List<LoadableConstantEntry> arguments) {\n+        this.index = bsmIndex;\n+        this.hash = hash;\n+        this.constantPool = constantPool;\n+        this.handle = handle;\n+        this.arguments = List.copyOf(arguments);\n+    }\n+\n+    @Override\n+    public ConstantPool constantPool() {\n+        return constantPool;\n+    }\n+\n+    @Override\n+    public MethodHandleEntry bootstrapMethod() {\n+        return handle;\n+    }\n+\n+    @Override\n+    public List<LoadableConstantEntry> arguments() {\n+        return arguments;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BootstrapMethodEntry e\n+            && e.bootstrapMethod() == handle\n+            && e.arguments().size() == arguments.size()) {\n+                for (int i = 0; i < arguments.size(); ++i) {\n+                    if (e.arguments().get(i) != arguments.get(i)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        else\n+            return false;\n+    }\n+\n+    static int computeHashCode(MethodHandleEntryImpl handle,\n+                               List<? extends LoadableConstantEntry> arguments) {\n+        int hash = handle.hashCode();\n+        for (LoadableConstantEntry a : arguments) {\n+            hash = 31 * hash + a.hashCode();\n+        }\n+        return AbstractPoolEntry.phiMix(hash);\n+    }\n+\n+    @Override\n+    public int bsmIndex() { return index; }\n+\n+    @Override\n+    public int hashCode() {\n+        return hash;\n+    }\n+\n+    @Override\n+    public void writeTo(BufWriter writer) {\n+        writer.writeIndex(bootstrapMethod());\n+        writer.writeListIndices(arguments());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -764,2 +764,2 @@\n-                    final ConcreteEntry.ConcreteMethodHandleEntry handle\n-                            = (ConcreteEntry.ConcreteMethodHandleEntry) classReader.readMethodHandleEntry(p);\n+                    final AbstractPoolEntry.MethodHandleEntryImpl handle\n+                            = (AbstractPoolEntry.MethodHandleEntryImpl) classReader.readMethodHandleEntry(p);\n@@ -768,2 +768,2 @@\n-                    int hash = ConcreteBootstrapMethodEntry.computeHashCode(handle, args);\n-                    bs[i] = new ConcreteBootstrapMethodEntry(classReader, i, hash, handle, args);\n+                    int hash = BootstrapMethodEntryImpl.computeHashCode(handle, args);\n+                    bs[i] = new BootstrapMethodEntryImpl(classReader, i, hash, handle, args);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-        int idx = ConcreteEntry.maybeClone(constantPool, entry).index();\n+        int idx = AbstractPoolEntry.maybeClone(constantPool, entry).index();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    private List<ConcreteBootstrapMethodEntry> bsmEntries;\n+    private List<BootstrapMethodEntryImpl> bsmEntries;\n@@ -193,1 +193,1 @@\n-    public ConcreteBootstrapMethodEntry bootstrapMethodEntry(int index) {\n+    public BootstrapMethodEntryImpl bootstrapMethodEntry(int index) {\n@@ -259,1 +259,1 @@\n-    List<ConcreteBootstrapMethodEntry> bsmEntries() {\n+    List<BootstrapMethodEntryImpl> bsmEntries() {\n@@ -266,1 +266,1 @@\n-                    ConcreteEntry.ConcreteMethodHandleEntry handle = (ConcreteEntry.ConcreteMethodHandleEntry) bm.bootstrapMethod();\n+                    AbstractPoolEntry.MethodHandleEntryImpl handle = (AbstractPoolEntry.MethodHandleEntryImpl) bm.bootstrapMethod();\n@@ -268,2 +268,2 @@\n-                    int hash = ConcreteBootstrapMethodEntry.computeHashCode(handle, args);\n-                    bsmEntries.add(new ConcreteBootstrapMethodEntry(this, bsmEntries.size(), hash, handle, args));\n+                    int hash = BootstrapMethodEntryImpl.computeHashCode(handle, args);\n+                    bsmEntries.add(new BootstrapMethodEntryImpl(this, bsmEntries.size(), hash, handle, args));\n@@ -314,22 +314,22 @@\n-                case TAG_UTF8 -> new ConcreteEntry.ConcreteUtf8Entry(this, index, buffer, q + 2, readU2(q));\n-                case TAG_INTEGER -> new ConcreteEntry.ConcreteIntegerEntry(this, index, readInt(q));\n-                case TAG_FLOAT -> new ConcreteEntry.ConcreteFloatEntry(this, index, readFloat(q));\n-                case TAG_LONG -> new ConcreteEntry.ConcreteLongEntry(this, index, readLong(q));\n-                case TAG_DOUBLE -> new ConcreteEntry.ConcreteDoubleEntry(this, index, readDouble(q));\n-                case TAG_CLASS -> new ConcreteEntry.ConcreteClassEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n-                case TAG_STRING -> new ConcreteEntry.ConcreteStringEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n-                case TAG_FIELDREF -> new ConcreteEntry.ConcreteFieldRefEntry(this, index, (ConcreteEntry.ConcreteClassEntry) readClassEntry(q),\n-                                                                             (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n-                case TAG_METHODREF -> new ConcreteEntry.ConcreteMethodRefEntry(this, index, (ConcreteEntry.ConcreteClassEntry) readClassEntry(q),\n-                                                                               (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n-                case TAG_INTERFACEMETHODREF -> new ConcreteEntry.ConcreteInterfaceMethodRefEntry(this, index, (ConcreteEntry.ConcreteClassEntry) readClassEntry(q),\n-                                                                                                 (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n-                case TAG_NAMEANDTYPE -> new ConcreteEntry.ConcreteNameAndTypeEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q),\n-                                                                                   (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q + 2));\n-                case TAG_METHODHANDLE -> new ConcreteEntry.ConcreteMethodHandleEntry(this, index, readU1(q),\n-                                                                                     (ConcreteEntry.MemberRefEntry) readEntry(q + 1));\n-                case TAG_METHODTYPE -> new ConcreteEntry.ConcreteMethodTypeEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n-                case TAG_CONSTANTDYNAMIC -> new ConcreteEntry.ConcreteConstantDynamicEntry(this, index, readU2(q), (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n-                case TAG_INVOKEDYNAMIC -> new ConcreteEntry.ConcreteInvokeDynamicEntry(this, index, readU2(q), (ConcreteEntry.ConcreteNameAndTypeEntry) readNameAndTypeEntry(q + 2));\n-                case TAG_MODULE -> new ConcreteEntry.ConcreteModuleEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n-                case TAG_PACKAGE -> new ConcreteEntry.ConcretePackageEntry(this, index, (ConcreteEntry.ConcreteUtf8Entry) readUtf8Entry(q));\n+                case TAG_UTF8 -> new AbstractPoolEntry.Utf8EntryImpl(this, index, buffer, q + 2, readU2(q));\n+                case TAG_INTEGER -> new AbstractPoolEntry.IntegerEntryImpl(this, index, readInt(q));\n+                case TAG_FLOAT -> new AbstractPoolEntry.FloatEntryImpl(this, index, readFloat(q));\n+                case TAG_LONG -> new AbstractPoolEntry.LongEntryImpl(this, index, readLong(q));\n+                case TAG_DOUBLE -> new AbstractPoolEntry.DoubleEntryImpl(this, index, readDouble(q));\n+                case TAG_CLASS -> new AbstractPoolEntry.ClassEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n+                case TAG_STRING -> new AbstractPoolEntry.StringEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n+                case TAG_FIELDREF -> new AbstractPoolEntry.FieldRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n+                                                                             (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n+                case TAG_METHODREF -> new AbstractPoolEntry.MethodRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n+                                                                               (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n+                case TAG_INTERFACEMETHODREF -> new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, index, (AbstractPoolEntry.ClassEntryImpl) readClassEntry(q),\n+                                                                                                 (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n+                case TAG_NAMEANDTYPE -> new AbstractPoolEntry.NameAndTypeEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q),\n+                                                                                   (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q + 2));\n+                case TAG_METHODHANDLE -> new AbstractPoolEntry.MethodHandleEntryImpl(this, index, readU1(q),\n+                                                                                     (AbstractPoolEntry.AbstractMemberRefEntry) readEntry(q + 1));\n+                case TAG_METHODTYPE -> new AbstractPoolEntry.MethodTypeEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n+                case TAG_CONSTANTDYNAMIC -> new AbstractPoolEntry.ConstantDynamicEntryImpl(this, index, readU2(q), (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n+                case TAG_INVOKEDYNAMIC -> new AbstractPoolEntry.InvokeDynamicEntryImpl(this, index, readU2(q), (AbstractPoolEntry.NameAndTypeEntryImpl) readNameAndTypeEntry(q + 2));\n+                case TAG_MODULE -> new AbstractPoolEntry.ModuleEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n+                case TAG_PACKAGE -> new AbstractPoolEntry.PackageEntryImpl(this, index, (AbstractPoolEntry.Utf8EntryImpl) readUtf8Entry(q));\n@@ -345,1 +345,1 @@\n-    public ConcreteEntry.ConcreteUtf8Entry utf8EntryByIndex(int index) {\n+    public AbstractPoolEntry.Utf8EntryImpl utf8EntryByIndex(int index) {\n@@ -355,2 +355,2 @@\n-            ConcreteEntry.ConcreteUtf8Entry uinfo\n-                    = new ConcreteEntry.ConcreteUtf8Entry(this, index, buffer, q + 2, readU2(q));\n+            AbstractPoolEntry.Utf8EntryImpl uinfo\n+                    = new AbstractPoolEntry.Utf8EntryImpl(this, index, buffer, q + 2, readU2(q));\n@@ -360,1 +360,1 @@\n-        return (ConcreteEntry.ConcreteUtf8Entry) info;\n+        return (AbstractPoolEntry.Utf8EntryImpl) info;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.internal.classfile.constantpool.ConstantPool;\n-import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n-import jdk.internal.classfile.BootstrapMethodEntry;\n-import jdk.internal.classfile.BufWriter;\n-import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n-import jdk.internal.classfile.constantpool.MethodHandleEntry;\n-\n-import static jdk.internal.classfile.impl.ConcreteEntry.ConcreteMethodHandleEntry;\n-\n-public final class ConcreteBootstrapMethodEntry implements BootstrapMethodEntry {\n-\n-    final int index;\n-    final int hash;\n-    private final ConstantPool constantPool;\n-    private final ConcreteMethodHandleEntry handle;\n-    private final List<LoadableConstantEntry> arguments;\n-\n-    ConcreteBootstrapMethodEntry(ConstantPool constantPool, int bsmIndex, int hash,\n-                                 ConcreteMethodHandleEntry handle,\n-                                 List<LoadableConstantEntry> arguments) {\n-        this.index = bsmIndex;\n-        this.hash = hash;\n-        this.constantPool = constantPool;\n-        this.handle = handle;\n-        this.arguments = List.copyOf(arguments);\n-    }\n-\n-    @Override\n-    public ConstantPool constantPool() {\n-        return constantPool;\n-    }\n-\n-    @Override\n-    public MethodHandleEntry bootstrapMethod() {\n-        return handle;\n-    }\n-\n-    @Override\n-    public List<LoadableConstantEntry> arguments() {\n-        return arguments;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj instanceof BootstrapMethodEntry e\n-            && e.bootstrapMethod() == handle\n-            && e.arguments().size() == arguments.size()) {\n-                for (int i = 0; i < arguments.size(); ++i) {\n-                    if (e.arguments().get(i) != arguments.get(i)) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-        else\n-            return false;\n-    }\n-\n-    static int computeHashCode(ConcreteMethodHandleEntry handle,\n-                               List<? extends LoadableConstantEntry> arguments) {\n-        int hash = handle.hashCode();\n-        for (LoadableConstantEntry a : arguments) {\n-            hash = 31 * hash + a.hashCode();\n-        }\n-        return ConcreteEntry.phiMix(hash);\n-    }\n-\n-    @Override\n-    public int bsmIndex() { return index; }\n-\n-    @Override\n-    public int hashCode() {\n-        return hash;\n-    }\n-\n-    @Override\n-    public void writeTo(BufWriter writer) {\n-        writer.writeIndex(bootstrapMethod());\n-        writer.writeListIndices(arguments());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ConcreteBootstrapMethodEntry.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,1172 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.lang.constant.*;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import jdk.internal.classfile.Classfile;\n-import jdk.internal.classfile.constantpool.ClassEntry;\n-import jdk.internal.classfile.constantpool.ConstantDynamicEntry;\n-import jdk.internal.classfile.constantpool.ConstantPool;\n-import jdk.internal.classfile.constantpool.ConstantPoolBuilder;\n-import jdk.internal.classfile.BufWriter;\n-import jdk.internal.classfile.constantpool.DoubleEntry;\n-import jdk.internal.classfile.constantpool.FieldRefEntry;\n-import jdk.internal.classfile.constantpool.FloatEntry;\n-import jdk.internal.classfile.constantpool.IntegerEntry;\n-import jdk.internal.classfile.constantpool.InterfaceMethodRefEntry;\n-import jdk.internal.classfile.constantpool.InvokeDynamicEntry;\n-import jdk.internal.classfile.constantpool.LoadableConstantEntry;\n-import jdk.internal.classfile.constantpool.LongEntry;\n-import jdk.internal.classfile.constantpool.MethodHandleEntry;\n-import jdk.internal.classfile.constantpool.MethodRefEntry;\n-import jdk.internal.classfile.constantpool.MethodTypeEntry;\n-import jdk.internal.classfile.constantpool.ModuleEntry;\n-import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n-import jdk.internal.classfile.constantpool.PackageEntry;\n-import jdk.internal.classfile.constantpool.PoolEntry;\n-import jdk.internal.classfile.constantpool.StringEntry;\n-import jdk.internal.classfile.constantpool.Utf8Entry;\n-import jdk.internal.classfile.jdktypes.ModuleDesc;\n-import jdk.internal.classfile.jdktypes.PackageDesc;\n-\n-public abstract sealed class ConcreteEntry {\n-    \/*\n-    Invariant: a {CP,BSM} entry for pool P refer only to {CP,BSM} entries\n-    from P or P's parent.  This is enforced by the various xxxEntry methods\n-    in SplitConstantPool.  As a result, code in this file can use writeU2\n-    instead of writeIndex.\n-\n-    Cloning of entries may be a no-op if the entry is already on the right pool\n-    (which implies that the referenced entries will also be on the right pool.)\n-     *\/\n-\n-    private static final int TAG_SMEAR = 0x13C4B2D1;\n-    private static final int INT_PHI = 0x9E3779B9;\n-\n-    public static int hash1(int tag, int x1) {\n-        return phiMix(tag * TAG_SMEAR + x1);\n-    }\n-\n-    public static int hash2(int tag, int x1, int x2) {\n-        return phiMix(tag * TAG_SMEAR + x1 + 31*x2);\n-    }\n-\n-    \/\/ Ensure that hash is never zero\n-    public static int hashString(int stringHash) {\n-        return phiMix(stringHash | (1 << 30));\n-    }\n-\n-    public static int phiMix(int x) {\n-        int h = x * INT_PHI;\n-        return h ^ (h >> 16);\n-    }\n-\n-    public static Utf8Entry rawUtf8EntryFromStandardAttributeName(String name) {\n-        \/\/assuming standard attribute names are all US_ASCII\n-        var raw = name.getBytes(StandardCharsets.US_ASCII);\n-        return new ConcreteUtf8Entry(null, 0, raw, 0, raw.length);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T extends PoolEntry> T maybeClone(ConstantPoolBuilder cp, T entry) {\n-        return (T)((ConcreteEntry)entry).clone(cp);\n-    }\n-\n-    final ConstantPool constantPool;\n-    public final byte tag;\n-    private final int index;\n-    private final int hash;\n-\n-    private ConcreteEntry(ConstantPool constantPool, int tag, int index, int hash) {\n-        this.tag = (byte) tag;\n-        this.index = index;\n-        this.hash = hash;\n-        this.constantPool = constantPool;\n-    }\n-\n-    public ConstantPool constantPool() { return constantPool; }\n-\n-    public int index() { return index; }\n-\n-    public int hashCode() {\n-        return hash;\n-    }\n-\n-    public byte tag() {\n-        return tag;\n-    }\n-\n-    public int width() {\n-        return (tag == Classfile.TAG_LONG || tag == Classfile.TAG_DOUBLE) ? 2 : 1;\n-    }\n-\n-    abstract PoolEntry clone(ConstantPoolBuilder cp);\n-\n-    public static final class ConcreteUtf8Entry extends ConcreteEntry implements Utf8Entry {\n-        \/\/ Processing UTF8 from the constant pool is one of the more expensive\n-        \/\/ operations, and often, we don't actually need access to the constant\n-        \/\/ as a string.  So there are multiple layers of laziness in UTF8\n-        \/\/ constants.  In the first stage, all we do is record the range of\n-        \/\/ bytes in the classfile.  If the size or hashCode is needed, then we\n-        \/\/ process the raw bytes into a byte[] or char[], but do not inflate\n-        \/\/ a String.  If a string is needed, it too is inflated lazily.\n-        \/\/ If we construct a Utf8Entry from a string, we generate the encoding\n-        \/\/ at write time.\n-\n-        enum State { RAW, BYTE, CHAR, STRING }\n-\n-        private State state;\n-        private final byte[] rawBytes; \/\/ null if initialized directly from a string\n-        private final int offset;\n-        private final int rawLen;\n-        \/\/ Set in any state other than RAW\n-        private int hash;\n-        private int charLen;\n-        \/\/ Set in CHAR state\n-        private char[] chars;\n-        \/\/ Only set in STRING state\n-        private String stringValue;\n-\n-        ConcreteUtf8Entry(ConstantPool cpm, int index,\n-                          byte[] rawBytes, int offset, int rawLen) {\n-            super(cpm, Classfile.TAG_UTF8, index, 0);\n-            this.rawBytes = rawBytes;\n-            this.offset = offset;\n-            this.rawLen = rawLen;\n-            this.state = State.RAW;\n-        }\n-\n-        ConcreteUtf8Entry(ConstantPool cpm, int index, String s) {\n-            super(cpm, Classfile.TAG_UTF8, index, 0);\n-            this.rawBytes = null;\n-            this.offset = 0;\n-            this.rawLen = 0;\n-            this.state = State.STRING;\n-            this.stringValue = s;\n-            this.charLen = s.length();\n-            this.hash = hashString(s.hashCode());\n-        }\n-\n-        ConcreteUtf8Entry(ConstantPool cpm, int index, ConcreteUtf8Entry u) {\n-            super(cpm, Classfile.TAG_UTF8, index, 0);\n-            this.rawBytes = u.rawBytes;\n-            this.offset = u.offset;\n-            this.rawLen = u.rawLen;\n-            this.state = u.state;\n-            this.hash = u.hash;\n-            this.charLen = u.charLen;\n-            this.chars = u.chars;\n-            this.stringValue = u.stringValue;\n-        }\n-\n-        \/**\n-         * {@jvms 4.4.7} String content is encoded in modified UTF-8.\n-         *\n-         * Modified UTF-8 strings are encoded so that code point sequences that\n-         * contain only non-null ASCII characters can be represented using only 1\n-         * byte per code point, but all code points in the Unicode codespace can be\n-         * represented.\n-         *\n-         * Modified UTF-8 strings are not null-terminated.\n-         *\n-         * Code points in the range '\\u0001' to '\\u007F' are represented by a single\n-         * byte.\n-         *\n-         * The null code point ('\\u0000') and code points in the range '\\u0080' to\n-         * '\\u07FF' are represented by a pair of bytes.\n-         *\n-         * Code points in the range '\\u0800' to '\\uFFFF' are represented by 3 bytes.\n-         *\n-         * Characters with code points above U+FFFF (so-called supplementary\n-         * characters) are represented by separately encoding the two surrogate code\n-         * units of their UTF-16 representation. Each of the surrogate code units is\n-         * represented by three bytes. This means supplementary characters are\n-         * represented by six bytes.\n-         *\n-         * The bytes of multibyte characters are stored in the class file in\n-         * big-endian (high byte first) order.\n-         *\n-         * There are two differences between this format and the \"standard\" UTF-8\n-         * format. First, the null character (char)0 is encoded using the 2-byte\n-         * format rather than the 1-byte format, so that modified UTF-8 strings\n-         * never have embedded nulls. Second, only the 1-byte, 2-byte, and 3-byte\n-         * formats of standard UTF-8 are used. The Java Virtual Machine does not\n-         * recognize the four-byte format of standard UTF-8; it uses its own\n-         * two-times-three-byte format instead.\n-         *\/\n-        private void inflate() {\n-            int hash = 0;\n-            boolean foundHigh = false;\n-\n-            int px = offset;\n-            int utfend = px + rawLen;\n-            while (px < utfend) {\n-                int c = (int) rawBytes[px] & 0xff;\n-                if (c > 127) {\n-                    foundHigh = true;\n-                    break;\n-                }\n-                hash = 31 * hash + c;\n-                px++;\n-            }\n-\n-            if (!foundHigh) {\n-                this.hash = hashString(hash);\n-                charLen = rawLen;\n-                state = State.BYTE;\n-            }\n-            else {\n-                char[] chararr = new char[rawLen];\n-                int chararr_count = 0;\n-                \/\/ Inflate prefix of bytes to characters\n-                for (int i = offset; i < px; i++) {\n-                    int c = (int) rawBytes[i] & 0xff;\n-                    chararr[chararr_count++] = (char) c;\n-                }\n-                while (px < utfend) {\n-                    int c = (int) rawBytes[px] & 0xff;\n-                    switch (c >> 4) {\n-                        case 0, 1, 2, 3, 4, 5, 6, 7: {\n-                            \/\/ 0xxx xxxx\n-                            px++;\n-                            chararr[chararr_count++] = (char) c;\n-                            hash = 31 * hash + c;\n-                            break;\n-                        }\n-                        case 12, 13: {\n-                            \/\/ 110x xxxx  10xx xxxx\n-                            px += 2;\n-                            if (px > utfend) {\n-                                throw new CpException(\"malformed input: partial character at end\");\n-                            }\n-                            int char2 = rawBytes[px - 1];\n-                            if ((char2 & 0xC0) != 0x80) {\n-                                throw new CpException(\"malformed input around byte \" + px);\n-                            }\n-                            char v = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));\n-                            chararr[chararr_count++] = v;\n-                            hash = 31 * hash + v;\n-                            break;\n-                        }\n-                        case 14: {\n-                            \/\/ 1110 xxxx  10xx xxxx  10xx xxxx\n-                            px += 3;\n-                            if (px > utfend) {\n-                                throw new CpException(\"malformed input: partial character at end\");\n-                            }\n-                            int char2 = rawBytes[px - 2];\n-                            int char3 = rawBytes[px - 1];\n-                            if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {\n-                                throw new CpException(\"malformed input around byte \" + (px - 1));\n-                            }\n-                            char v = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));\n-                            chararr[chararr_count++] = v;\n-                            hash = 31 * hash + v;\n-                            break;\n-                        }\n-                        default:\n-                            \/\/ 10xx xxxx,  1111 xxxx\n-                            throw new CpException(\"malformed input around byte \" + px);\n-                    }\n-                }\n-                this.hash = hashString(hash);\n-                charLen = chararr_count;\n-                this.chars = chararr;\n-                state = State.CHAR;\n-            }\n-\n-        }\n-\n-        @Override\n-        public ConcreteUtf8Entry clone(ConstantPoolBuilder cp) {\n-            if (cp.canWriteDirect(constantPool))\n-                return this;\n-            return (state == State.STRING && rawBytes == null)\n-                   ? (ConcreteUtf8Entry) cp.utf8Entry(stringValue)\n-                   : ((SplitConstantPool) cp).maybeCloneUtf8Entry(this);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            if (state == State.RAW)\n-                inflate();\n-            return hash;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (state == State.RAW)\n-                inflate();\n-            if (state != State.STRING) {\n-                stringValue = (chars != null)\n-                              ? new String(chars, 0, charLen)\n-                              : new String(rawBytes, offset, charLen, StandardCharsets.UTF_8);\n-                state = State.STRING;\n-            }\n-            return stringValue;\n-        }\n-\n-        @Override\n-        public String stringValue() {\n-            return toString();\n-        }\n-\n-        @Override\n-        public ConstantDesc constantValue() {\n-            return stringValue();\n-        }\n-\n-        @Override\n-        public int length() {\n-            if (state == State.RAW)\n-                inflate();\n-            return charLen;\n-        }\n-\n-        @Override\n-        public char charAt(int index) {\n-            if (state == State.STRING)\n-                return stringValue.charAt(index);\n-            if (state == State.RAW)\n-                inflate();\n-            return (chars != null)\n-                   ? chars[index]\n-                   : (char) rawBytes[index + offset];\n-        }\n-\n-        @Override\n-        public CharSequence subSequence(int start, int end) {\n-            return toString().subSequence(start, end);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof ConcreteUtf8Entry u) {\n-                return equalsUtf8(u);\n-            } else if (o instanceof Utf8Entry u) {\n-                return equalsString(u.stringValue());\n-            }\n-            return false;\n-        }\n-\n-        public boolean equalsUtf8(ConcreteUtf8Entry u) {\n-            if (hashCode() != u.hashCode()\n-                || length() != u.length())\n-                return false;\n-            if (rawBytes != null && u.rawBytes != null)\n-                return Arrays.equals(rawBytes, offset, offset + rawLen,\n-                                     u.rawBytes, u.offset, u.offset + u.rawLen);\n-            else if ((state == State.STRING && u.state == State.STRING))\n-                return stringValue.equals(u.stringValue);\n-            else\n-                return stringValue().equals(u.stringValue());\n-        }\n-\n-        @Override\n-        public boolean equalsString(String s) {\n-            if (state == State.RAW)\n-                inflate();\n-            switch (state) {\n-                case STRING:\n-                    return stringValue.equals(s);\n-                case CHAR:\n-                    if (charLen != s.length() || hash != hashString(s.hashCode()))\n-                        return false;\n-                    for (int i=0; i<charLen; i++)\n-                        if (chars[i] != s.charAt(i))\n-                            return false;\n-                    stringValue = s;\n-                    state = State.STRING;\n-                    return true;\n-                case BYTE:\n-                    if (rawLen != s.length() || hash != hashString(s.hashCode()))\n-                        return false;\n-                    for (int i=0; i<rawLen; i++)\n-                        if (rawBytes[offset+i] != s.charAt(i))\n-                            return false;\n-                    stringValue = s;\n-                    state = State.STRING;\n-                    return true;\n-            }\n-            throw new IllegalStateException(\"cannot reach here\");\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter pool) {\n-            if (rawBytes != null) {\n-                pool.writeU1(tag);\n-                pool.writeU2(rawLen);\n-                pool.writeBytes(rawBytes, offset, rawLen);\n-            }\n-            else {\n-                \/\/ state == STRING and no raw bytes\n-                if (stringValue.length() > 65535) {\n-                    throw new IllegalArgumentException(\"string too long\");\n-                }\n-                pool.writeU1(tag);\n-                pool.writeU2(charLen);\n-                for (int i = 0; i < charLen; ++i) {\n-                    char c = stringValue.charAt(i);\n-                    if (c >= '\\001' && c <= '\\177') {\n-                        \/\/ Optimistic writing -- hope everything is bytes\n-                        \/\/ If not, we bail out, and alternate path patches the length\n-                        pool.writeU1((byte) c);\n-                    }\n-                    else {\n-                        int charLength = stringValue.length();\n-                        int byteLength = i;\n-                        char c1;\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                byteLength++;\n-                            } else if (c1 > '\\u07FF') {\n-                                byteLength += 3;\n-                            } else {\n-                                byteLength += 2;\n-                            }\n-                        }\n-                        if (byteLength > 65535) {\n-                            throw new IllegalArgumentException();\n-                        }\n-                        int byteLengthFinal = byteLength;\n-                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                pool.writeU1((byte) c1);\n-                            } else if (c1 > '\\u07FF') {\n-                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n-                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            } else {\n-                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    static abstract sealed class RefEntry<T extends PoolEntry> extends ConcreteEntry {\n-        protected final T ref1;\n-\n-        public RefEntry(ConstantPool constantPool, int tag, int index, T ref1) {\n-            super(constantPool, tag, index, hash1(tag, ref1.index()));\n-            this.ref1 = ref1;\n-        }\n-\n-        public T ref1() {\n-            return ref1;\n-        }\n-\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeU2(ref1.index());\n-        }\n-\n-        public String toString() {\n-            return tag() + \" \" + ref1();\n-        }\n-    }\n-\n-    static abstract sealed class RefsEntry<T extends PoolEntry, U extends PoolEntry>\n-            extends ConcreteEntry {\n-        protected final T ref1;\n-        protected final U ref2;\n-\n-        public RefsEntry(ConstantPool constantPool, int tag, int index, T ref1, U ref2) {\n-            super(constantPool, tag, index, hash2(tag, ref1.index(), ref2.index()));\n-            this.ref1 = ref1;\n-            this.ref2 = ref2;\n-        }\n-\n-        public T ref1() {\n-            return ref1;\n-        }\n-\n-        public U ref2() {\n-            return ref2;\n-        }\n-\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeU2(ref1.index());\n-            pool.writeU2(ref2.index());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return tag() + \" \" + ref1 + \"-\" + ref2;\n-        }\n-    }\n-\n-    static abstract sealed class NamedEntry extends RefEntry<ConcreteUtf8Entry> {\n-\n-        public NamedEntry(ConstantPool constantPool, int tag, int index, ConcreteUtf8Entry ref1) {\n-            super(constantPool, tag, index, ref1);\n-        }\n-\n-        public Utf8Entry name() {\n-            return ref1;\n-        }\n-\n-        public String asInternalName() {\n-            return ref1.stringValue();\n-        }\n-\n-        public boolean equals(Object o) {\n-            if (o == this) { return true; }\n-            if (o instanceof NamedEntry ne) {\n-                return tag == ne.tag() && name().equals(ref1());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteClassEntry extends NamedEntry implements ClassEntry {\n-\n-        ConcreteClassEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name) {\n-            super(cpm, Classfile.TAG_CLASS, index, name);\n-        }\n-\n-        @Override\n-        public ClassEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n-        }\n-\n-        @Override\n-        public ClassDesc asSymbol() {\n-            return Util.toClassDesc(asInternalName());\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof ConcreteClassEntry cce) {\n-                return cce.name().equals(this.name());\n-            } else if (o instanceof ClassEntry c) {\n-                return c.asSymbol().equals(this.asSymbol());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcretePackageEntry extends NamedEntry implements PackageEntry {\n-\n-        ConcretePackageEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name) {\n-            super(cpm, Classfile.TAG_PACKAGE, index, name);\n-        }\n-\n-        @Override\n-        public PackageEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.packageEntry(ref1);\n-        }\n-\n-        @Override\n-        public PackageDesc asSymbol() {\n-            return PackageDesc.ofInternalName(asInternalName());\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof PackageEntry p) {\n-                return name().equals(p.name());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteModuleEntry extends NamedEntry implements ModuleEntry {\n-\n-        ConcreteModuleEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name) {\n-            super(cpm, Classfile.TAG_MODULE, index, name);\n-        }\n-\n-        @Override\n-        public ModuleEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.moduleEntry(ref1);\n-        }\n-\n-        @Override\n-        public ModuleDesc asSymbol() {\n-            return ModuleDesc.of(asInternalName());\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof ConcreteModuleEntry m) {\n-                return name().equals(m.name());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteNameAndTypeEntry extends RefsEntry<ConcreteUtf8Entry, ConcreteUtf8Entry>\n-            implements NameAndTypeEntry {\n-\n-        ConcreteNameAndTypeEntry(ConstantPool cpm, int index, ConcreteUtf8Entry name, ConcreteUtf8Entry type) {\n-            super(cpm, Classfile.TAG_NAMEANDTYPE, index, name, type);\n-        }\n-\n-        @Override\n-        public Utf8Entry name() {\n-            return ref1;\n-        }\n-\n-        @Override\n-        public Utf8Entry type() {\n-            return ref2;\n-        }\n-\n-        @Override\n-        public NameAndTypeEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.natEntry(ref1, ref2);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof ConcreteNameAndTypeEntry nat) {\n-                return name().equals(nat.name()) && type().equals(nat.type());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static abstract sealed class MemberRefEntry\n-            extends RefsEntry<ConcreteClassEntry, ConcreteNameAndTypeEntry>\n-            implements jdk.internal.classfile.constantpool.MemberRefEntry {\n-\n-        MemberRefEntry(ConstantPool cpm, int tag, int index, ConcreteClassEntry owner,\n-                       ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, tag, index, owner, nameAndType);\n-        }\n-\n-        @Override\n-        public ConcreteClassEntry owner() {\n-            return ref1;\n-        }\n-\n-        @Override\n-        public ConcreteNameAndTypeEntry nameAndType() {\n-            return ref2;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return tag() + \" \" + owner().asInternalName() + \".\" + nameAndType().name().stringValue()\n-                   + \"-\" + nameAndType().type().stringValue();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof MemberRefEntry m) {\n-                return tag == m.tag()\n-                && owner().equals(m.owner())\n-                && nameAndType().equals(m.nameAndType());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteFieldRefEntry extends MemberRefEntry implements FieldRefEntry {\n-\n-        ConcreteFieldRefEntry(ConstantPool cpm, int index,\n-                              ConcreteClassEntry owner, ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_FIELDREF, index, owner, nameAndType);\n-        }\n-\n-        @Override\n-        public FieldRefEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.fieldRefEntry(ref1, ref2);\n-        }\n-    }\n-\n-    public static final class ConcreteMethodRefEntry extends MemberRefEntry implements MethodRefEntry {\n-\n-        ConcreteMethodRefEntry(ConstantPool cpm, int index,\n-                               ConcreteClassEntry owner, ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_METHODREF, index, owner, nameAndType);\n-        }\n-\n-        @Override\n-        public MethodRefEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodRefEntry(ref1, ref2);\n-        }\n-    }\n-\n-    public static final class ConcreteInterfaceMethodRefEntry extends MemberRefEntry implements InterfaceMethodRefEntry {\n-\n-        ConcreteInterfaceMethodRefEntry(ConstantPool cpm, int index, ConcreteClassEntry owner,\n-                                        ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_INTERFACEMETHODREF, index, owner, nameAndType);\n-        }\n-\n-        @Override\n-        public InterfaceMethodRefEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.interfaceMethodRefEntry(ref1, ref2);\n-        }\n-    }\n-\n-    public static abstract sealed class AbstractDynamicConstantPoolEntry extends ConcreteEntry {\n-\n-        private final int bsmIndex;\n-        private ConcreteBootstrapMethodEntry bootstrapMethod;\n-        private final ConcreteNameAndTypeEntry nameAndType;\n-\n-        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, ConcreteBootstrapMethodEntry bootstrapMethod,\n-                                         ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, tag, index, hash);\n-            this.bsmIndex = bootstrapMethod.bsmIndex();\n-            this.bootstrapMethod = bootstrapMethod;\n-            this.nameAndType = nameAndType;\n-        }\n-\n-        AbstractDynamicConstantPoolEntry(ConstantPool cpm, int tag, int index, int hash, int bsmIndex,\n-                                         ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, tag, index, hash);\n-            this.bsmIndex = bsmIndex;\n-            this.bootstrapMethod = null;\n-            this.nameAndType = nameAndType;\n-        }\n-\n-        \/**\n-         * @return the bootstrapMethod\n-         *\/\n-        public ConcreteBootstrapMethodEntry bootstrap() {\n-            if (bootstrapMethod == null) {\n-                bootstrapMethod = (ConcreteBootstrapMethodEntry) constantPool.bootstrapMethodEntry(bsmIndex);\n-            }\n-            return bootstrapMethod;\n-        }\n-\n-        \/**\n-         * @return the nameAndType\n-         *\/\n-        public ConcreteNameAndTypeEntry nameAndType() {\n-            return nameAndType;\n-        }\n-\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeU2(bsmIndex);\n-            pool.writeU2(nameAndType.index());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return tag() + \" \" + bootstrap() + \".\" + nameAndType().name().stringValue()\n-                   + \"-\" + nameAndType().type().stringValue();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof AbstractDynamicConstantPoolEntry d) {\n-                return this.tag() == d.tag()\n-                && bootstrap().equals(d.bootstrap())\n-                && nameAndType.equals(d.nameAndType());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteInvokeDynamicEntry\n-            extends AbstractDynamicConstantPoolEntry\n-            implements InvokeDynamicEntry {\n-\n-        ConcreteInvokeDynamicEntry(ConstantPool cpm, int index, int hash, ConcreteBootstrapMethodEntry bootstrapMethod,\n-                                   ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_INVOKEDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n-        }\n-\n-        ConcreteInvokeDynamicEntry(ConstantPool cpm, int index, int bsmIndex,\n-                                   ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_INVOKEDYNAMIC, index, hash2(Classfile.TAG_INVOKEDYNAMIC, bsmIndex, nameAndType.index()),\n-                  bsmIndex, nameAndType);\n-        }\n-\n-        @Override\n-        public InvokeDynamicEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.invokeDynamicEntry(bootstrap(), nameAndType());\n-        }\n-    }\n-\n-    public static final class ConcreteConstantDynamicEntry extends AbstractDynamicConstantPoolEntry\n-            implements ConstantDynamicEntry {\n-\n-        ConcreteConstantDynamicEntry(ConstantPool cpm, int index, int hash, ConcreteBootstrapMethodEntry bootstrapMethod,\n-                                     ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_CONSTANTDYNAMIC, index, hash, bootstrapMethod, nameAndType);\n-        }\n-\n-        ConcreteConstantDynamicEntry(ConstantPool cpm, int index, int bsmIndex,\n-                                     ConcreteNameAndTypeEntry nameAndType) {\n-            super(cpm, Classfile.TAG_CONSTANTDYNAMIC, index, hash2(Classfile.TAG_CONSTANTDYNAMIC, bsmIndex, nameAndType.index()),\n-                  bsmIndex, nameAndType);\n-        }\n-\n-        @Override\n-        public ConstantDynamicEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.constantDynamicEntry(bootstrap(), nameAndType());\n-        }\n-\n-        @Override\n-        public ConstantDesc constantValue() {\n-            List<LoadableConstantEntry> args = bootstrap().arguments();\n-            int argsSize =  args.size();\n-            ConstantDesc[] staticArgs = new ConstantDesc[argsSize];\n-            for (int i = 0; i < argsSize; i++)\n-                staticArgs[i] = args.get(i).constantValue();\n-\n-            return DynamicConstantDesc.ofCanonical(bootstrap().bootstrapMethod().asSymbol(),\n-                                                   nameAndType().name().stringValue(), ClassDesc.ofDescriptor(nameAndType().type().stringValue()), staticArgs);\n-        }\n-    }\n-\n-    public static final class ConcreteMethodHandleEntry extends ConcreteEntry\n-            implements MethodHandleEntry {\n-\n-        private final int refKind;\n-        private final ConcreteEntry.MemberRefEntry reference;\n-\n-        ConcreteMethodHandleEntry(ConstantPool cpm, int index, int hash, int refKind, ConcreteEntry.MemberRefEntry\n-                reference) {\n-            super(cpm, Classfile.TAG_METHODHANDLE, index, hash);\n-            this.refKind = refKind;\n-            this.reference = reference;\n-        }\n-\n-        ConcreteMethodHandleEntry(ConstantPool cpm, int index, int refKind, ConcreteEntry.MemberRefEntry\n-                reference) {\n-            super(cpm, Classfile.TAG_METHODHANDLE, index, hash2(Classfile.TAG_METHODHANDLE, refKind, reference.index()));\n-            this.refKind = refKind;\n-            this.reference = reference;\n-        }\n-\n-        @Override\n-        public int kind() {\n-            return refKind;\n-        }\n-\n-        @Override\n-        public ConstantDesc constantValue() {\n-            return asSymbol();\n-        }\n-\n-        @Override\n-        public ConcreteEntry.MemberRefEntry reference() {\n-            return reference;\n-        }\n-\n-        @Override\n-        public DirectMethodHandleDesc asSymbol() {\n-            return MethodHandleDesc.of(\n-                    DirectMethodHandleDesc.Kind.valueOf(kind(), reference() instanceof InterfaceMethodRefEntry),\n-                    ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).owner().asSymbol(),\n-                    ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().name().stringValue(),\n-                    ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().type().stringValue());\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeU1(refKind);\n-            pool.writeU2(reference.index());\n-        }\n-\n-        @Override\n-        public MethodHandleEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodHandleEntry(refKind, reference);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return tag() + \" \" + kind() + \":\" + ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).owner().asInternalName() + \".\" + ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().name().stringValue()\n-                   + \"-\" + ((jdk.internal.classfile.constantpool.MemberRefEntry) reference()).nameAndType().type().stringValue();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof ConcreteMethodHandleEntry m) {\n-                return kind() == m.kind()\n-                && reference.equals(m.reference());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteMethodTypeEntry\n-            extends RefEntry<ConcreteUtf8Entry>\n-            implements MethodTypeEntry {\n-\n-        ConcreteMethodTypeEntry(ConstantPool cpm, int index, ConcreteUtf8Entry descriptor) {\n-            super(cpm, Classfile.TAG_METHODTYPE, index, descriptor);\n-        }\n-\n-        public Utf8Entry descriptor() {\n-            return ref1;\n-        }\n-\n-        @Override\n-        public ConstantDesc constantValue() {\n-            return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n-        }\n-\n-        @Override\n-        public MethodTypeEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodTypeEntry(ref1);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof ConcreteMethodTypeEntry m) {\n-                return descriptor().equals(m.descriptor());\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteStringEntry\n-            extends RefEntry<ConcreteUtf8Entry>\n-            implements StringEntry {\n-\n-        ConcreteStringEntry(ConstantPool cpm, int index, ConcreteUtf8Entry utf8) {\n-            super(cpm, Classfile.TAG_STRING, index, utf8);\n-        }\n-\n-        @Override\n-        public ConcreteUtf8Entry utf8() {\n-            return ref1;\n-        }\n-\n-        @Override\n-        public String stringValue() {\n-            return ref1.toString();\n-        }\n-\n-        @Override\n-        public ConstantDesc constantValue() {\n-            return stringValue();\n-        }\n-\n-        @Override\n-        public StringEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.stringEntry(ref1);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return tag() + \" \\\"\" + stringValue() + \"\\\"\";\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            if (o instanceof ConcreteStringEntry s) {\n-                \/\/ check utf8 rather allocating a string\n-                return utf8().equals(s.utf8());\n-            }\n-            return false;\n-        }\n-\n-\n-    }\n-\n-    static abstract sealed class PrimitiveEntry<T extends ConstantDesc>\n-            extends ConcreteEntry {\n-        protected final T val;\n-\n-        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n-            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n-            this.val = val;\n-        }\n-\n-        public T value() {\n-            return val;\n-        }\n-\n-        public ConstantDesc constantValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"\" + tag() + value();\n-        }\n-    }\n-\n-    public static final class ConcreteIntegerEntry extends PrimitiveEntry<Integer>\n-            implements IntegerEntry {\n-\n-        ConcreteIntegerEntry(ConstantPool cpm, int index, int i) {\n-            super(cpm, Classfile.TAG_INTEGER, index, i);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeInt(val);\n-        }\n-\n-        @Override\n-        public IntegerEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.intEntry(val);\n-        }\n-\n-        @Override\n-        public int intValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof ConcreteIntegerEntry e) {\n-                return intValue() == e.intValue();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteFloatEntry extends PrimitiveEntry<Float>\n-            implements FloatEntry {\n-\n-        ConcreteFloatEntry(ConstantPool cpm, int index, float f) {\n-            super(cpm, Classfile.TAG_FLOAT, index, f);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeFloat(val);\n-        }\n-\n-        @Override\n-        public FloatEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.floatEntry(val);\n-        }\n-\n-        @Override\n-        public float floatValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof ConcreteFloatEntry e) {\n-                return floatValue() == e.floatValue();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteLongEntry extends PrimitiveEntry<Long> implements LongEntry {\n-\n-        ConcreteLongEntry(ConstantPool cpm, int index, long l) {\n-            super(cpm, Classfile.TAG_LONG, index, l);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeLong(val);\n-        }\n-\n-        @Override\n-        public LongEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.longEntry(val);\n-        }\n-\n-        @Override\n-        public long longValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof ConcreteLongEntry e) {\n-                return longValue() == e.longValue();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    public static final class ConcreteDoubleEntry extends PrimitiveEntry<Double> implements DoubleEntry {\n-\n-        ConcreteDoubleEntry(ConstantPool cpm, int index, double d) {\n-            super(cpm, Classfile.TAG_DOUBLE, index, d);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriter pool) {\n-            pool.writeU1(tag);\n-            pool.writeDouble(val);\n-        }\n-\n-        @Override\n-        public DoubleEntry clone(ConstantPoolBuilder cp) {\n-            return cp.canWriteDirect(constantPool) ? this : cp.doubleEntry(val);\n-        }\n-\n-        @Override\n-        public double doubleValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o instanceof ConcreteDoubleEntry e) {\n-                return doubleValue() == e.doubleValue();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static class CpException extends RuntimeException {\n-        static final long serialVersionUID = 32L;\n-\n-        CpException(String s) {\n-            super(s);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ConcreteEntry.java","additions":0,"deletions":1172,"binary":false,"changes":1172,"status":"deleted"},{"patch":"@@ -67,1 +67,1 @@\n-        this.thisClassEntry = ConcreteEntry.maybeClone(constantPool, thisClass);\n+        this.thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClass);\n@@ -161,1 +161,1 @@\n-            superclass = ConcreteEntry.maybeClone(constantPool, superclass);\n+            superclass = AbstractPoolEntry.maybeClone(constantPool, superclass);\n@@ -166,1 +166,1 @@\n-            ies.add(ConcreteEntry.maybeClone(constantPool, ce));\n+            ies.add(AbstractPoolEntry.maybeClone(constantPool, ce));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-        int index = ConcreteEntry.maybeClone(constantPool, value).index();\n+        int index = AbstractPoolEntry.maybeClone(constantPool, value).index();\n@@ -724,1 +724,1 @@\n-            el = new AbstractPseudoInstruction.ExceptionCatchImpl(element.handler(), element.tryStart(), element.tryEnd(), ConcreteEntry.maybeClone(constantPool, type));\n+            el = new AbstractPseudoInstruction.ExceptionCatchImpl(element.handler(), element.tryStart(), element.tryEnd(), AbstractPoolEntry.maybeClone(constantPool, type));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    private ConcreteBootstrapMethodEntry[] myBsmEntries;\n+    private BootstrapMethodEntryImpl[] myBsmEntries;\n@@ -94,1 +94,1 @@\n-    private EntryMap<ConcreteBootstrapMethodEntry> bsmMap;\n+    private EntryMap<BootstrapMethodEntryImpl> bsmMap;\n@@ -104,1 +104,1 @@\n-        this.myBsmEntries = new ConcreteBootstrapMethodEntry[8];\n+        this.myBsmEntries = new BootstrapMethodEntryImpl[8];\n@@ -119,1 +119,1 @@\n-        this.myBsmEntries = new ConcreteBootstrapMethodEntry[8];\n+        this.myBsmEntries = new BootstrapMethodEntryImpl[8];\n@@ -140,1 +140,1 @@\n-    public ConcreteBootstrapMethodEntry bootstrapMethodEntry(int index) {\n+    public BootstrapMethodEntryImpl bootstrapMethodEntry(int index) {\n@@ -237,1 +237,1 @@\n-    private EntryMap<ConcreteBootstrapMethodEntry> bsmMap() {\n+    private EntryMap<BootstrapMethodEntryImpl> bsmMap() {\n@@ -241,1 +241,1 @@\n-                protected ConcreteBootstrapMethodEntry fetchElement(int index) {\n+                protected BootstrapMethodEntryImpl fetchElement(int index) {\n@@ -246,1 +246,1 @@\n-                ConcreteBootstrapMethodEntry bsm = parent.bootstrapMethodEntry(i);\n+                BootstrapMethodEntryImpl bsm = parent.bootstrapMethodEntry(i);\n@@ -250,1 +250,1 @@\n-                ConcreteBootstrapMethodEntry bsm = myBsmEntries[i - parentBsmSize];\n+                BootstrapMethodEntryImpl bsm = myBsmEntries[i - parentBsmSize];\n@@ -272,1 +272,1 @@\n-    private ConcreteBootstrapMethodEntry internalAdd(ConcreteBootstrapMethodEntry bsm, int hash) {\n+    private BootstrapMethodEntryImpl internalAdd(BootstrapMethodEntryImpl bsm, int hash) {\n@@ -275,1 +275,1 @@\n-            myBsmEntries = Arrays.copyOf(myBsmEntries, 2 * newIndex, ConcreteBootstrapMethodEntry[].class);\n+            myBsmEntries = Arrays.copyOf(myBsmEntries, 2 * newIndex, BootstrapMethodEntryImpl[].class);\n@@ -284,1 +284,1 @@\n-        int hash = ConcreteEntry.hash1(tag, val.hashCode());\n+        int hash = AbstractPoolEntry.hash1(tag, val.hashCode());\n@@ -289,1 +289,1 @@\n-                && e instanceof ConcreteEntry.PrimitiveEntry<?> ce\n+                && e instanceof AbstractPoolEntry.PrimitiveEntry<?> ce\n@@ -300,1 +300,1 @@\n-    private<T extends ConcreteEntry> ConcreteEntry findEntry(int tag, T ref1) {\n+    private<T extends AbstractPoolEntry> AbstractPoolEntry findEntry(int tag, T ref1) {\n@@ -302,1 +302,1 @@\n-        int hash = ConcreteEntry.hash1(tag, ref1.index());\n+        int hash = AbstractPoolEntry.hash1(tag, ref1.index());\n@@ -307,1 +307,1 @@\n-                && e instanceof ConcreteEntry.RefEntry<?> re\n+                && e instanceof AbstractPoolEntry.AbstractRefEntry<?> re\n@@ -318,2 +318,2 @@\n-    private <T extends ConcreteEntry, U extends ConcreteEntry>\n-            ConcreteEntry findEntry(int tag, T ref1, U ref2) {\n+    private <T extends AbstractPoolEntry, U extends AbstractPoolEntry>\n+            AbstractPoolEntry findEntry(int tag, T ref1, U ref2) {\n@@ -321,1 +321,1 @@\n-        int hash = ConcreteEntry.hash2(tag, ref1.index(), ref2.index());\n+        int hash = AbstractPoolEntry.hash2(tag, ref1.index(), ref2.index());\n@@ -326,1 +326,1 @@\n-                    && e instanceof ConcreteEntry.RefsEntry<?, ?> re\n+                    && e instanceof AbstractPoolEntry.AbstractRefsEntry<?, ?> re\n@@ -339,1 +339,1 @@\n-    private<T> ConcreteEntry.ConcreteUtf8Entry tryFindUtf8(int hash, String target) {\n+    private<T> AbstractPoolEntry.Utf8EntryImpl tryFindUtf8(int hash, String target) {\n@@ -345,1 +345,1 @@\n-                && e instanceof ConcreteEntry.ConcreteUtf8Entry ce\n+                && e instanceof AbstractPoolEntry.Utf8EntryImpl ce\n@@ -357,1 +357,1 @@\n-    private ConcreteEntry.ConcreteUtf8Entry tryFindUtf8(int hash, ConcreteEntry.ConcreteUtf8Entry target) {\n+    private AbstractPoolEntry.Utf8EntryImpl tryFindUtf8(int hash, AbstractPoolEntry.Utf8EntryImpl target) {\n@@ -362,1 +362,1 @@\n-                && e instanceof ConcreteEntry.ConcreteUtf8Entry ce\n+                && e instanceof AbstractPoolEntry.Utf8EntryImpl ce\n@@ -374,3 +374,3 @@\n-    public ConcreteEntry.ConcreteUtf8Entry utf8Entry(String s) {\n-        var ce = tryFindUtf8(ConcreteEntry.hashString(s.hashCode()), s);\n-        return ce == null ? internalAdd(new ConcreteEntry.ConcreteUtf8Entry(this, size, s)) : ce;\n+    public AbstractPoolEntry.Utf8EntryImpl utf8Entry(String s) {\n+        var ce = tryFindUtf8(AbstractPoolEntry.hashString(s.hashCode()), s);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s)) : ce;\n@@ -379,2 +379,2 @@\n-    ConcreteEntry.ConcreteUtf8Entry maybeCloneUtf8Entry(Utf8Entry entry) {\n-        ConcreteEntry.ConcreteUtf8Entry e = (ConcreteEntry.ConcreteUtf8Entry) entry;\n+    AbstractPoolEntry.Utf8EntryImpl maybeCloneUtf8Entry(Utf8Entry entry) {\n+        AbstractPoolEntry.Utf8EntryImpl e = (AbstractPoolEntry.Utf8EntryImpl) entry;\n@@ -383,2 +383,2 @@\n-        ConcreteEntry.ConcreteUtf8Entry ce = tryFindUtf8(e.hashCode(), e);\n-        return ce == null ? internalAdd(new ConcreteEntry.ConcreteUtf8Entry(this, size, e)) : ce;\n+        AbstractPoolEntry.Utf8EntryImpl ce = tryFindUtf8(e.hashCode(), e);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, e)) : ce;\n@@ -388,4 +388,4 @@\n-    public ConcreteEntry.ConcreteClassEntry classEntry(Utf8Entry nameEntry) {\n-        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n-        var e = (ConcreteEntry.ConcreteClassEntry) findEntry(TAG_CLASS, ne);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteClassEntry(this, size, ne)) : e;\n+    public AbstractPoolEntry.ClassEntryImpl classEntry(Utf8Entry nameEntry) {\n+        AbstractPoolEntry.Utf8EntryImpl ne = maybeCloneUtf8Entry(nameEntry);\n+        var e = (AbstractPoolEntry.ClassEntryImpl) findEntry(TAG_CLASS, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.ClassEntryImpl(this, size, ne)) : e;\n@@ -396,3 +396,3 @@\n-        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n-        var e = (ConcreteEntry.ConcretePackageEntry) findEntry(TAG_PACKAGE, ne);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcretePackageEntry(this, size, ne)) : e;\n+        AbstractPoolEntry.Utf8EntryImpl ne = maybeCloneUtf8Entry(nameEntry);\n+        var e = (AbstractPoolEntry.PackageEntryImpl) findEntry(TAG_PACKAGE, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.PackageEntryImpl(this, size, ne)) : e;\n@@ -403,3 +403,3 @@\n-        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n-        var e = (ConcreteEntry.ConcreteModuleEntry) findEntry(TAG_MODULE, ne);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteModuleEntry(this, size, ne)) : e;\n+        AbstractPoolEntry.Utf8EntryImpl ne = maybeCloneUtf8Entry(nameEntry);\n+        var e = (AbstractPoolEntry.ModuleEntryImpl) findEntry(TAG_MODULE, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.ModuleEntryImpl(this, size, ne)) : e;\n@@ -409,5 +409,5 @@\n-    public ConcreteEntry.ConcreteNameAndTypeEntry natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n-        ConcreteEntry.ConcreteUtf8Entry ne = maybeCloneUtf8Entry(nameEntry);\n-        ConcreteEntry.ConcreteUtf8Entry te = maybeCloneUtf8Entry(typeEntry);\n-        var e = (ConcreteEntry.ConcreteNameAndTypeEntry) findEntry(TAG_NAMEANDTYPE, ne, te);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteNameAndTypeEntry(this, size, ne, te)) : e;\n+    public AbstractPoolEntry.NameAndTypeEntryImpl natEntry(Utf8Entry nameEntry, Utf8Entry typeEntry) {\n+        AbstractPoolEntry.Utf8EntryImpl ne = maybeCloneUtf8Entry(nameEntry);\n+        AbstractPoolEntry.Utf8EntryImpl te = maybeCloneUtf8Entry(typeEntry);\n+        var e = (AbstractPoolEntry.NameAndTypeEntryImpl) findEntry(TAG_NAMEANDTYPE, ne, te);\n+        return e == null ? internalAdd(new AbstractPoolEntry.NameAndTypeEntryImpl(this, size, ne, te)) : e;\n@@ -418,2 +418,2 @@\n-        ConcreteEntry.ConcreteClassEntry oe = (ConcreteEntry.ConcreteClassEntry) owner;\n-        ConcreteEntry.ConcreteNameAndTypeEntry ne = (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType;\n+        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n+        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n@@ -424,2 +424,2 @@\n-        var e = (ConcreteEntry.ConcreteFieldRefEntry) findEntry(TAG_FIELDREF, oe, ne);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteFieldRefEntry(this, size, oe, ne)) : e;\n+        var e = (AbstractPoolEntry.FieldRefEntryImpl) findEntry(TAG_FIELDREF, oe, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.FieldRefEntryImpl(this, size, oe, ne)) : e;\n@@ -430,2 +430,2 @@\n-        ConcreteEntry.ConcreteClassEntry oe = (ConcreteEntry.ConcreteClassEntry) owner;\n-        ConcreteEntry.ConcreteNameAndTypeEntry ne = (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType;\n+        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n+        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n@@ -436,2 +436,2 @@\n-        var e = (ConcreteEntry.ConcreteMethodRefEntry) findEntry(TAG_METHODREF, oe, ne);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteMethodRefEntry(this, size, oe, ne)) : e;\n+        var e = (AbstractPoolEntry.MethodRefEntryImpl) findEntry(TAG_METHODREF, oe, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.MethodRefEntryImpl(this, size, oe, ne)) : e;\n@@ -442,2 +442,2 @@\n-        ConcreteEntry.ConcreteClassEntry oe = (ConcreteEntry.ConcreteClassEntry) owner;\n-        ConcreteEntry.ConcreteNameAndTypeEntry ne = (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType;\n+        AbstractPoolEntry.ClassEntryImpl oe = (AbstractPoolEntry.ClassEntryImpl) owner;\n+        AbstractPoolEntry.NameAndTypeEntryImpl ne = (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType;\n@@ -448,2 +448,2 @@\n-        var e = (ConcreteEntry.ConcreteInterfaceMethodRefEntry) findEntry(TAG_INTERFACEMETHODREF, oe, ne);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteInterfaceMethodRefEntry(this, size, oe, ne)) : e;\n+        var e = (AbstractPoolEntry.InterfaceMethodRefEntryImpl) findEntry(TAG_INTERFACEMETHODREF, oe, ne);\n+        return e == null ? internalAdd(new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, size, oe, ne)) : e;\n@@ -459,3 +459,3 @@\n-        ConcreteEntry.ConcreteUtf8Entry de = maybeCloneUtf8Entry(descriptor);\n-        var e = (ConcreteEntry.ConcreteMethodTypeEntry) findEntry(TAG_METHODTYPE, de);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteMethodTypeEntry(this, size, de)) : e;\n+        AbstractPoolEntry.Utf8EntryImpl de = maybeCloneUtf8Entry(descriptor);\n+        var e = (AbstractPoolEntry.MethodTypeEntryImpl) findEntry(TAG_METHODTYPE, de);\n+        return e == null ? internalAdd(new AbstractPoolEntry.MethodTypeEntryImpl(this, size, de)) : e;\n@@ -475,1 +475,1 @@\n-        int hash = ConcreteEntry.hash2(TAG_METHODHANDLE, refKind, reference.index());\n+        int hash = AbstractPoolEntry.hash2(TAG_METHODHANDLE, refKind, reference.index());\n@@ -480,1 +480,1 @@\n-                && e instanceof ConcreteEntry.ConcreteMethodHandleEntry ce\n+                && e instanceof AbstractPoolEntry.MethodHandleEntryImpl ce\n@@ -488,1 +488,1 @@\n-        return internalAdd(new ConcreteEntry.ConcreteMethodHandleEntry(this, size, hash, refKind, (ConcreteEntry.MemberRefEntry) reference), hash);\n+        return internalAdd(new AbstractPoolEntry.MethodHandleEntryImpl(this, size, hash, refKind, (AbstractPoolEntry.AbstractMemberRefEntry) reference), hash);\n@@ -499,1 +499,1 @@\n-        int hash = ConcreteEntry.hash2(TAG_INVOKEDYNAMIC, bootstrapMethodEntry.bsmIndex(), nameAndType.index());\n+        int hash = AbstractPoolEntry.hash2(TAG_INVOKEDYNAMIC, bootstrapMethodEntry.bsmIndex(), nameAndType.index());\n@@ -504,1 +504,1 @@\n-                && e instanceof ConcreteEntry.ConcreteInvokeDynamicEntry ce\n+                && e instanceof AbstractPoolEntry.InvokeDynamicEntryImpl ce\n@@ -513,1 +513,1 @@\n-        ConcreteEntry.ConcreteInvokeDynamicEntry ce = new ConcreteEntry.ConcreteInvokeDynamicEntry(this, size, hash, (ConcreteBootstrapMethodEntry) bootstrapMethodEntry, (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        AbstractPoolEntry.InvokeDynamicEntryImpl ce = new AbstractPoolEntry.InvokeDynamicEntryImpl(this, size, hash, (BootstrapMethodEntryImpl) bootstrapMethodEntry, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -526,1 +526,1 @@\n-        int hash = ConcreteEntry.hash2(TAG_CONSTANTDYNAMIC, bootstrapMethodEntry.bsmIndex(), nameAndType.index());\n+        int hash = AbstractPoolEntry.hash2(TAG_CONSTANTDYNAMIC, bootstrapMethodEntry.bsmIndex(), nameAndType.index());\n@@ -531,1 +531,1 @@\n-                && e instanceof ConcreteEntry.ConcreteConstantDynamicEntry ce\n+                && e instanceof AbstractPoolEntry.ConstantDynamicEntryImpl ce\n@@ -540,1 +540,1 @@\n-        ConcreteEntry.ConcreteConstantDynamicEntry ce = new ConcreteEntry.ConcreteConstantDynamicEntry(this, size, hash, (ConcreteBootstrapMethodEntry) bootstrapMethodEntry, (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        AbstractPoolEntry.ConstantDynamicEntryImpl ce = new AbstractPoolEntry.ConstantDynamicEntryImpl(this, size, hash, (BootstrapMethodEntryImpl) bootstrapMethodEntry, (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -548,1 +548,1 @@\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteIntegerEntry(this, size, value)) : e;\n+        return e == null ? internalAdd(new AbstractPoolEntry.IntegerEntryImpl(this, size, value)) : e;\n@@ -554,1 +554,1 @@\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteFloatEntry(this, size, value)) : e;\n+        return e == null ? internalAdd(new AbstractPoolEntry.FloatEntryImpl(this, size, value)) : e;\n@@ -560,1 +560,1 @@\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteLongEntry(this, size, value)) : e;\n+        return e == null ? internalAdd(new AbstractPoolEntry.LongEntryImpl(this, size, value)) : e;\n@@ -566,1 +566,1 @@\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteDoubleEntry(this, size, value)) : e;\n+        return e == null ? internalAdd(new AbstractPoolEntry.DoubleEntryImpl(this, size, value)) : e;\n@@ -571,3 +571,3 @@\n-        ConcreteEntry.ConcreteUtf8Entry ue = maybeCloneUtf8Entry(utf8);\n-        var e = (ConcreteEntry.ConcreteStringEntry) findEntry(TAG_STRING, ue);\n-        return e == null ? internalAdd(new ConcreteEntry.ConcreteStringEntry(this, size, ue)) : e;\n+        AbstractPoolEntry.Utf8EntryImpl ue = maybeCloneUtf8Entry(utf8);\n+        var e = (AbstractPoolEntry.StringEntryImpl) findEntry(TAG_STRING, ue);\n+        return e == null ? internalAdd(new AbstractPoolEntry.StringEntryImpl(this, size, ue)) : e;\n@@ -586,1 +586,1 @@\n-                    arr[i] = ConcreteEntry.maybeClone(this, arr[i]);\n+                    arr[i] = AbstractPoolEntry.maybeClone(this, arr[i]);\n@@ -592,3 +592,3 @@\n-        ConcreteEntry.ConcreteMethodHandleEntry mre = (ConcreteEntry.ConcreteMethodHandleEntry) methodReference;\n-        int hash = ConcreteBootstrapMethodEntry.computeHashCode(mre, arguments);\n-        EntryMap<ConcreteBootstrapMethodEntry> map = bsmMap();\n+        AbstractPoolEntry.MethodHandleEntryImpl mre = (AbstractPoolEntry.MethodHandleEntryImpl) methodReference;\n+        int hash = BootstrapMethodEntryImpl.computeHashCode(mre, arguments);\n+        EntryMap<BootstrapMethodEntryImpl> map = bsmMap();\n@@ -596,1 +596,1 @@\n-            ConcreteBootstrapMethodEntry e = map.getElementByToken(token);\n+            BootstrapMethodEntryImpl e = map.getElementByToken(token);\n@@ -601,1 +601,1 @@\n-        ConcreteBootstrapMethodEntry ne = new ConcreteBootstrapMethodEntry(this, bsmSize, hash, mre, arguments);\n+        BootstrapMethodEntryImpl ne = new BootstrapMethodEntryImpl(this, bsmSize, hash, mre, arguments);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import java.util.Collections;\n@@ -55,2 +54,0 @@\n-import static jdk.internal.classfile.Classfile.TAG_METHODTYPE;\n-\n@@ -65,1 +62,1 @@\n-        return new ConcreteEntry.ConcreteUtf8Entry(this, -1, s);\n+        return new AbstractPoolEntry.Utf8EntryImpl(this, -1, s);\n@@ -70,1 +67,1 @@\n-        return new ConcreteEntry.ConcreteIntegerEntry(this, -1, value);\n+        return new AbstractPoolEntry.IntegerEntryImpl(this, -1, value);\n@@ -75,1 +72,1 @@\n-        return new ConcreteEntry.ConcreteFloatEntry(this, -1, value);\n+        return new AbstractPoolEntry.FloatEntryImpl(this, -1, value);\n@@ -80,1 +77,1 @@\n-        return new ConcreteEntry.ConcreteLongEntry(this, -1, value);\n+        return new AbstractPoolEntry.LongEntryImpl(this, -1, value);\n@@ -85,1 +82,1 @@\n-        return new ConcreteEntry.ConcreteDoubleEntry(this, -1, value);\n+        return new AbstractPoolEntry.DoubleEntryImpl(this, -1, value);\n@@ -90,1 +87,1 @@\n-        return new ConcreteEntry.ConcreteClassEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) name);\n+        return new AbstractPoolEntry.ClassEntryImpl(this, -2, (AbstractPoolEntry.Utf8EntryImpl) name);\n@@ -95,1 +92,1 @@\n-        return new ConcreteEntry.ConcretePackageEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) name);\n+        return new AbstractPoolEntry.PackageEntryImpl(this, -2, (AbstractPoolEntry.Utf8EntryImpl) name);\n@@ -100,1 +97,1 @@\n-        return new ConcreteEntry.ConcreteModuleEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) name);\n+        return new AbstractPoolEntry.ModuleEntryImpl(this, -2, (AbstractPoolEntry.Utf8EntryImpl) name);\n@@ -105,3 +102,3 @@\n-        return new ConcreteEntry.ConcreteNameAndTypeEntry(this, -3,\n-                                                          (ConcreteEntry.ConcreteUtf8Entry) nameEntry,\n-                                                          (ConcreteEntry.ConcreteUtf8Entry) typeEntry);\n+        return new AbstractPoolEntry.NameAndTypeEntryImpl(this, -3,\n+                                                          (AbstractPoolEntry.Utf8EntryImpl) nameEntry,\n+                                                          (AbstractPoolEntry.Utf8EntryImpl) typeEntry);\n@@ -112,3 +109,3 @@\n-        return new ConcreteEntry.ConcreteFieldRefEntry(this, -3,\n-                                                       (ConcreteEntry.ConcreteClassEntry) owner,\n-                                                       (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        return new AbstractPoolEntry.FieldRefEntryImpl(this, -3,\n+                                                       (AbstractPoolEntry.ClassEntryImpl) owner,\n+                                                       (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -119,3 +116,3 @@\n-        return new ConcreteEntry.ConcreteMethodRefEntry(this, -3,\n-                                                        (ConcreteEntry.ConcreteClassEntry) owner,\n-                                                        (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        return new AbstractPoolEntry.MethodRefEntryImpl(this, -3,\n+                                                        (AbstractPoolEntry.ClassEntryImpl) owner,\n+                                                        (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -126,3 +123,3 @@\n-        return new ConcreteEntry.ConcreteInterfaceMethodRefEntry(this, -3,\n-                                                                 (ConcreteEntry.ConcreteClassEntry) owner,\n-                                                                 (ConcreteEntry.ConcreteNameAndTypeEntry) nameAndType);\n+        return new AbstractPoolEntry.InterfaceMethodRefEntryImpl(this, -3,\n+                                                                 (AbstractPoolEntry.ClassEntryImpl) owner,\n+                                                                 (AbstractPoolEntry.NameAndTypeEntryImpl) nameAndType);\n@@ -158,1 +155,1 @@\n-        return new ConcreteEntry.ConcreteStringEntry(this, -2, (ConcreteEntry.ConcreteUtf8Entry) utf8);\n+        return new AbstractPoolEntry.StringEntryImpl(this, -2, (AbstractPoolEntry.Utf8EntryImpl) utf8);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"}]}