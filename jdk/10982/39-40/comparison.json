{"files":[{"patch":"@@ -103,1 +103,1 @@\n-            permits ArrayTypeSig, ClassTypeSig, TypeArg, TypeVarSig {\n+            permits ArrayTypeSig, ClassTypeSig, TypeVarSig {\n@@ -125,1 +125,1 @@\n-        List<Signature> typeArgs();\n+        List<TypeArg> typeArgs();\n@@ -132,1 +132,1 @@\n-        public static ClassTypeSig of(ClassDesc className, Signature... typeArgs) {\n+        public static ClassTypeSig of(ClassDesc className, TypeArg... typeArgs) {\n@@ -142,1 +142,1 @@\n-        public static ClassTypeSig of(ClassTypeSig outerType, ClassDesc className, Signature... typeArgs) {\n+        public static ClassTypeSig of(ClassTypeSig outerType, ClassDesc className, TypeArg... typeArgs) {\n@@ -152,1 +152,1 @@\n-        public static ClassTypeSig of(String className, Signature... typeArgs) {\n+        public static ClassTypeSig of(String className, TypeArg... typeArgs) {\n@@ -162,1 +162,1 @@\n-        public static ClassTypeSig of(ClassTypeSig outerType, String className, Signature... typeArgs) {\n+        public static ClassTypeSig of(ClassTypeSig outerType, String className, TypeArg... typeArgs) {\n@@ -169,1 +169,1 @@\n-     * Models the signature of a type argument.\n+     * Models the type argument.\n@@ -171,1 +171,1 @@\n-    public sealed interface TypeArg extends RefTypeSig\n+    public sealed interface TypeArg\n@@ -175,1 +175,2 @@\n-         * Indicator for whether a wildcard has no bound, an upper bound, or a lower bound\n+         * Indicator for whether a wildcard has default bound, no bound,\n+         * an upper bound, or a lower bound\n@@ -178,7 +179,1 @@\n-            UNBOUNDED('*'), EXTENDS('+'), SUPER('-');\n-\n-            public final char indicator;\n-\n-            WildcardIndicator(char indicator) {\n-                this.indicator = indicator;\n-            }\n+            DEFAULT, UNBOUNDED, EXTENDS, SUPER;\n@@ -194,1 +189,10 @@\n-         * {@return a signature for an unbounded wildcard}\n+         * {@return a bounded type arg}\n+         * @param boundType the bound\n+         *\/\n+        public static TypeArg of(RefTypeSig boundType) {\n+            requireNonNull(boundType);\n+            return of(WildcardIndicator.DEFAULT, Optional.of(boundType));\n+        }\n+\n+        \/**\n+         * {@return an unbounded type arg}\n@@ -197,1 +201,1 @@\n-            return new SignaturesImpl.TypeArgImpl(WildcardIndicator.UNBOUNDED, Optional.empty());\n+            return of(WildcardIndicator.UNBOUNDED, Optional.empty());\n@@ -201,1 +205,1 @@\n-         * {@return a signature for an upper-bounded wildcard}\n+         * {@return an upper-bounded type arg}\n@@ -206,1 +210,1 @@\n-            return new SignaturesImpl.TypeArgImpl(WildcardIndicator.EXTENDS, Optional.of(boundType));\n+            return of(WildcardIndicator.EXTENDS, Optional.of(boundType));\n@@ -210,1 +214,1 @@\n-         * {@return a signature for a lower-bounded wildcard}\n+         * {@return a lower-bounded type arg}\n@@ -215,1 +219,10 @@\n-            return new SignaturesImpl.TypeArgImpl(WildcardIndicator.SUPER, Optional.of(boundType));\n+            return of(WildcardIndicator.SUPER, Optional.of(boundType));\n+        }\n+\n+        \/**\n+         * {@return a bounded type arg}\n+         * @param wildcard the wild card\n+         * @param boundType optional bound type\n+         *\/\n+        public static TypeArg of(WildcardIndicator wildcard, Optional<RefTypeSig> boundType) {\n+            return new SignaturesImpl.TypeArgImpl(wildcard, boundType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/Signature.java","additions":35,"deletions":22,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -445,3 +445,8 @@\n-                    Signature.ClassTypeSig.of(cts.outerType().map(this::mapSignature).orElse(null),\n-                            map(cts.classDesc()), cts.typeArgs().stream()\n-                                    .map(this::mapSignature).toArray(Signature[]::new));\n+                    Signature.ClassTypeSig.of(\n+                            cts.outerType().map(this::mapSignature).orElse(null),\n+                            map(cts.classDesc()),\n+                            cts.typeArgs().stream()\n+                                    .map(ta -> Signature.TypeArg.of(\n+                                            ta.wildcardIndicator(),\n+                                            ta.boundType().map(this::mapSignature)))\n+                                    .toArray(Signature.TypeArg[]::new));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/ClassRemapper.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-                ArrayList<Signature> argTypes = null;\n+                ArrayList<TypeArg> argTypes = null;\n@@ -141,1 +141,1 @@\n-                                argTypes.add(typeSig());\n+                                argTypes.add(typeArg());\n@@ -159,0 +159,7 @@\n+        }\n+        throw new IllegalStateException(\"not a valid type signature: \" + sig);\n+    }\n+\n+    private TypeArg typeArg() {\n+        char c = sig.charAt(sigp++);\n+        switch (c) {\n@@ -162,0 +169,3 @@\n+            default:\n+                sigp--;\n+                return TypeArg.of(referenceTypeSig());\n@@ -163,1 +173,0 @@\n-        throw new IllegalStateException(\"not a valid type signature: \" + sig);\n@@ -195,1 +204,1 @@\n-    public static record ClassTypeSigImpl(Optional<ClassTypeSig> outerType, String className, List<Signature> typeArgs)\n+    public static record ClassTypeSigImpl(Optional<ClassTypeSig> outerType, String className, List<Signature.TypeArg> typeArgs)\n@@ -211,1 +220,1 @@\n-                    sb.append(ta.signatureString());\n+                    sb.append(((TypeArgImpl)ta).signatureString());\n@@ -220,1 +229,0 @@\n-        @Override\n@@ -223,1 +231,3 @@\n-                case EXTENDS, SUPER -> wildcardIndicator.indicator + boundType.get().signatureString();\n+                case DEFAULT -> boundType.get().signatureString();\n+                case EXTENDS -> \"+\" + boundType.get().signatureString();\n+                case SUPER -> \"-\" + boundType.get().signatureString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                                ClassTypeSig.of(ClassDesc.of(\"java.util.LinkedHashMap\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")),\n+                                ClassTypeSig.of(ClassDesc.of(\"java.util.LinkedHashMap\"), TypeArg.of(TypeVarSig.of(\"K\")), TypeArg.of(TypeVarSig.of(\"V\"))),\n@@ -64,1 +64,1 @@\n-                                ClassTypeSig.of(ClassDesc.of(\"java.util.Map$Entry\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")))),\n+                                TypeArg.of(ClassTypeSig.of(ClassDesc.of(\"java.util.Map$Entry\"), TypeArg.of(TypeVarSig.of(\"K\")), TypeArg.of(TypeVarSig.of(\"V\")))))),\n@@ -72,2 +72,2 @@\n-                        ClassTypeSig.of(ClassDesc.of(\"java.util.AbstractMap\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")),\n-                        ClassTypeSig.of(ClassDesc.of(\"java.util.concurrent.ConcurrentMap\"), TypeVarSig.of(\"K\"), TypeVarSig.of(\"V\")),\n+                        ClassTypeSig.of(ClassDesc.of(\"java.util.AbstractMap\"), TypeArg.of(TypeVarSig.of(\"K\")), TypeArg.of(TypeVarSig.of(\"V\"))),\n+                        ClassTypeSig.of(ClassDesc.of(\"java.util.concurrent.ConcurrentMap\"), TypeArg.of(TypeVarSig.of(\"K\")), TypeArg.of(TypeVarSig.of(\"V\"))),\n@@ -81,1 +81,1 @@\n-                                ClassTypeSig.of(\n+                                TypeArg.of(ClassTypeSig.of(\n@@ -84,2 +84,2 @@\n-                                                    ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\")))),\n-                                ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\"))),\n+                                                    ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\"))))),\n+                                TypeArg.of(ClassTypeSig.of(ClassDesc.of(\"java.lang.annotation.Annotation\")))),\n@@ -103,1 +103,1 @@\n-                        ClassTypeSig.of(CD_Class, TypeVarSig.of(\"T\"))),\n+                        ClassTypeSig.of(CD_Class, TypeArg.of(TypeVarSig.of(\"T\")))),\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.classfile.Signature.TypeArg;\n@@ -184,1 +185,1 @@\n-                                                                      ClassTypeSig.of(ClassDesc.of(\"impl.Cow\"))),\n+                                                                      TypeArg.of(ClassTypeSig.of(ClassDesc.of(\"impl.Cow\")))),\n","filename":"test\/jdk\/jdk\/classfile\/examples\/ExampleGallery.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}