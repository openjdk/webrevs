{"files":[{"patch":"@@ -24,0 +24,2 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n@@ -27,0 +29,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -29,0 +33,1 @@\n+import java.util.Optional;\n@@ -35,1 +40,16 @@\n-        lines.forEach(System.out::println);\n+        Optional.ofNullable(System.getProperty(\"jpackage.test.appOutput\")).map(Path::of).ifPresentOrElse(outputFilePath -> {\n+            Optional.ofNullable(outputFilePath.getParent()).ifPresent(dir -> {\n+                try {\n+                    Files.createDirectories(dir);\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+            try {\n+                Files.write(outputFilePath, lines);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            lines.forEach(System.out::println);\n+        });\n@@ -48,1 +68,1 @@\n-            } else if (arg.startsWith(PRINT_MODULES)) {\n+            } else if (arg.equals(PRINT_MODULES)) {\n@@ -53,0 +73,2 @@\n+            } else if (arg.equals(PRINT_WORK_DIR)) {\n+                lines.add(\"$CD=\" + Path.of(\"\").toAbsolutePath());\n@@ -61,3 +83,4 @@\n-    private final static String PRINT_ENV_VAR = \"--print-env-var=\";\n-    private final static String PRINT_SYS_PROP = \"--print-sys-prop=\";\n-    private final static String PRINT_MODULES = \"--print-modules\";\n+    private static final String PRINT_ENV_VAR = \"--print-env-var=\";\n+    private static final String PRINT_SYS_PROP = \"--print-sys-prop=\";\n+    private static final String PRINT_MODULES = \"--print-modules\";\n+    private static final String PRINT_WORK_DIR = \"--print-workdir\";\n","filename":"test\/jdk\/tools\/jpackage\/apps\/PrintEnv.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+#!\/bin\/bash\n+\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+#\n+# Filters output produced by running jpackage test(s).\n+#\n+\n+set -eu\n+set -o pipefail\n+\n+\n+sed_inplace_option=-i\n+sed_version_string=$(sed --version 2>&1 | head -1 || true)\n+if [ \"${sed_version_string#sed (GNU sed)}\" != \"$sed_version_string\" ]; then\n+  # GNU sed, the default\n+  :\n+elif [ \"${sed_version_string#sed: illegal option}\" != \"$sed_version_string\" ]; then\n+  # Macos sed\n+  sed_inplace_option=\"-i ''\"\n+else\n+  echo 'WARNING: Unknown sed variant, assume it is GNU compatible'\n+fi\n+\n+\n+filterFile () {\n+  local expressions=(\n+      # Strip leading log message timestamp `[19:33:44.713] `\n+      -e 's\/^\\[[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\.[0-9]\\{3\\}\\] \/\/'\n+\n+      # Strip log message timestamps `[19:33:44.713]`\n+      -e 's\/\\[[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\.[0-9]\\{3\\}\\]\/\/g'\n+\n+      # Convert variable part of R\/O directory path timestamp `#2025-07-24T16:38:13.3589878Z`\n+      -e 's\/#[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}T[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\.[0-9]\\{1,\\}Z\/#<ts>Z\/'\n+\n+      # Strip variable part of temporary directory name `jdk.jpackage5060841750457404688`\n+      -e 's|\\([\\\/]\\)jdk\\.jpackage[0-9]\\{1,\\}\\b|\\1jdk.jpackage|g'\n+\n+      # Convert PID value `[PID: 131561]`\n+      -e 's\/\\[PID: [0-9]\\{1,\\}\\]\/[PID: <pid>]\/'\n+\n+      # Strip a warning message `Windows Defender may prevent jpackage from functioning`\n+      -e '\/Windows Defender may prevent jpackage from functioning\/d'\n+\n+      # Convert variable part of test output directory `out-6268`\n+      -e 's|\\bout-[0-9]\\{1,\\}\\b|out-N|g'\n+\n+      # Convert variable part of test summary `[       OK ] IconTest(AppImage, ResourceDirIcon, DefaultIcon).test; checks=39`\n+      -e 's\/^\\(.*\\bchecks=\\)[0-9]\\{1,\\}\\(\\r\\{0,1\\}\\)$\/\\1N\\2\/'\n+\n+      # Convert variable part of ldd output `libdl.so.2 => \/lib64\/libdl.so.2 (0x00007fbf63c81000)`\n+      -e 's\/(0x[[:xdigit:]]\\{1,\\})$\/(0xHEX)\/'\n+\n+      # Convert variable part of rpmbuild output `Executing(%build): \/bin\/sh -e \/var\/tmp\/rpm-tmp.CMO6a9`\n+      -e 's|\/rpm-tmp\\...*$|\/rpm-tmp.V|'\n+\n+      # Convert variable part of stack trace entry `at jdk.jpackage.test.JPackageCommand.execute(JPackageCommand.java:863)`\n+      -e 's\/^\\(.*\\b\\.java:\\)[0-9]\\{1,\\}\\()\\r\\{0,1\\}\\)$\/\\1N\\2\/'\n+  )\n+\n+  sed $sed_inplace_option \"$1\" \"${expressions[@]}\"\n+}\n+\n+\n+for f in \"$@\"; do\n+  filterFile \"$f\"\n+done\n","filename":"test\/jdk\/tools\/jpackage\/clean_test_output.sh","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -25,2 +25,4 @@\n-import static java.util.stream.Collectors.toMap;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.LauncherShortcut.LINUX_SHORTCUT;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_START_MENU_SHORTCUT;\n@@ -33,0 +35,3 @@\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -37,0 +42,2 @@\n+import java.util.Properties;\n+import java.util.Set;\n@@ -38,4 +45,0 @@\n-import java.util.function.Supplier;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n@@ -43,0 +46,3 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n@@ -44,1 +50,1 @@\n-public class AdditionalLauncher {\n+public final class AdditionalLauncher {\n@@ -47,2 +53,1 @@\n-        this.name = name;\n-        this.rawProperties = new ArrayList<>();\n+        this.name = Objects.requireNonNull(name);\n@@ -52,1 +57,11 @@\n-    public final AdditionalLauncher setDefaultArguments(String... v) {\n+    public AdditionalLauncher withVerifyActions(Action... actions) {\n+        verifyActions.addAll(List.of(actions));\n+        return this;\n+    }\n+\n+    public AdditionalLauncher withoutVerifyActions(Action... actions) {\n+        verifyActions.removeAll(List.of(actions));\n+        return this;\n+    }\n+\n+    public AdditionalLauncher setDefaultArguments(String... v) {\n@@ -57,1 +72,1 @@\n-    public final AdditionalLauncher addDefaultArguments(String... v) {\n+    public AdditionalLauncher addDefaultArguments(String... v) {\n@@ -66,1 +81,1 @@\n-    public final AdditionalLauncher setJavaOptions(String... v) {\n+    public AdditionalLauncher setJavaOptions(String... v) {\n@@ -71,1 +86,1 @@\n-    public final AdditionalLauncher addJavaOptions(String... v) {\n+    public AdditionalLauncher addJavaOptions(String... v) {\n@@ -80,2 +95,2 @@\n-    public final AdditionalLauncher setVerifyUninstalled(boolean value) {\n-        verifyUninstalled = value;\n+    public AdditionalLauncher setProperty(String name, Object value) {\n+        rawProperties.put(Objects.requireNonNull(name), Objects.requireNonNull(value.toString()));\n@@ -85,17 +100,7 @@\n-    public final AdditionalLauncher setLauncherAsService() {\n-        return addRawProperties(LAUNCHER_AS_SERVICE);\n-    }\n-\n-    public final AdditionalLauncher addRawProperties(\n-            Map.Entry<String, String> v) {\n-        return addRawProperties(List.of(v));\n-    }\n-\n-    public final AdditionalLauncher addRawProperties(\n-            Map.Entry<String, String> v, Map.Entry<String, String> v2) {\n-        return addRawProperties(List.of(v, v2));\n-    }\n-\n-    public final AdditionalLauncher addRawProperties(\n-            Collection<Map.Entry<String, String>> v) {\n-        rawProperties.addAll(v);\n+    public AdditionalLauncher setShortcuts(boolean menu, boolean desktop) {\n+        if (TKit.isLinux()) {\n+            setShortcut(LINUX_SHORTCUT, desktop);\n+        } else if (TKit.isWindows()) {\n+            setShortcut(WIN_DESKTOP_SHORTCUT, desktop);\n+            setShortcut(WIN_START_MENU_SHORTCUT, menu);\n+        }\n@@ -105,5 +110,7 @@\n-    public final String getRawPropertyValue(\n-            String key, Supplier<String> getDefault) {\n-        return rawProperties.stream()\n-                .filter(item -> item.getKey().equals(key))\n-                .map(e -> e.getValue()).findAny().orElseGet(getDefault);\n+    public AdditionalLauncher setShortcut(LauncherShortcut shortcut, StartupDirectory value) {\n+        if (value != null) {\n+            setProperty(shortcut.propertyName(), value.asStringValue());\n+        } else {\n+            setProperty(shortcut.propertyName(), false);\n+        }\n+        return this;\n@@ -112,3 +119,7 @@\n-    private String getDesciption(JPackageCommand cmd) {\n-        return getRawPropertyValue(\"description\", () -> cmd.getArgumentValue(\n-                \"--description\", unused -> cmd.name()));\n+    public AdditionalLauncher setShortcut(LauncherShortcut shortcut, boolean value) {\n+        if (value) {\n+            setShortcut(shortcut, StartupDirectory.DEFAULT);\n+        } else {\n+            setShortcut(shortcut, null);\n+        }\n+        return this;\n@@ -117,3 +128,2 @@\n-    public final AdditionalLauncher setShortcuts(boolean menu, boolean shortcut) {\n-        withMenuShortcut = menu;\n-        withShortcut = shortcut;\n+    public AdditionalLauncher removeShortcut(LauncherShortcut shortcut) {\n+        rawProperties.remove(shortcut.propertyName());\n@@ -123,2 +133,2 @@\n-    public final AdditionalLauncher setIcon(Path iconPath) {\n-        if (iconPath == NO_ICON) {\n+    public AdditionalLauncher setIcon(Path iconPath) {\n+        if (iconPath.equals(NO_ICON)) {\n@@ -132,1 +142,1 @@\n-    public final AdditionalLauncher setNoIcon() {\n+    public AdditionalLauncher setNoIcon() {\n@@ -137,2 +147,2 @@\n-    public final AdditionalLauncher setPersistenceHandler(\n-            ThrowingBiConsumer<Path, List<Map.Entry<String, String>>> handler) {\n+    public AdditionalLauncher setPersistenceHandler(\n+            ThrowingBiConsumer<Path, Collection<Map.Entry<String, String>>> handler) {\n@@ -147,1 +157,1 @@\n-    public final void applyTo(JPackageCommand cmd) {\n+    public void applyTo(JPackageCommand cmd) {\n@@ -149,1 +159,1 @@\n-        cmd.addVerifyAction(this::verify);\n+        cmd.addVerifyAction(createVerifierAsConsumer());\n@@ -152,1 +162,1 @@\n-    public final void applyTo(PackageTest test) {\n+    public void applyTo(PackageTest test) {\n@@ -154,4 +164,1 @@\n-        test.addInstallVerifier(this::verify);\n-        if (verifyUninstalled) {\n-            test.addUninstallVerifier(this::verifyUninstalled);\n-        }\n+        test.addInstallVerifier(createVerifierAsConsumer());\n@@ -161,1 +168,14 @@\n-        test.addInstallVerifier(this::verifyUninstalled);\n+        test.addInstallVerifier(cmd -> {\n+            createVerifier().verify(cmd, LauncherVerifier.Action.VERIFY_UNINSTALLED);\n+        });\n+    }\n+\n+    private LauncherVerifier createVerifier() {\n+        return new LauncherVerifier(name, Optional.ofNullable(javaOptions),\n+                Optional.ofNullable(defaultArguments), Optional.ofNullable(icon), rawProperties);\n+    }\n+\n+    private ThrowingConsumer<JPackageCommand> createVerifierAsConsumer() {\n+        return cmd -> {\n+            createVerifier().verify(cmd, verifyActions.stream().sorted(Comparator.comparing(Action::ordinal)).toArray(Action[]::new));\n+        };\n@@ -182,2 +202,3 @@\n-                shell[0] = toFunction(PropertyFile::new).apply(\n-                        propertiesFilePath);\n+                shell[0] = toSupplier(() -> {\n+                    return new PropertyFile(propertiesFilePath);\n+                }).get();\n@@ -186,1 +207,1 @@\n-        return Optional.of(shell[0]).get();\n+        return Objects.requireNonNull(shell[0]);\n@@ -194,1 +215,1 @@\n-        List<Map.Entry<String, String>> properties = new ArrayList<>();\n+        Map<String, String> properties = new HashMap<>();\n@@ -196,2 +217,1 @@\n-            properties.add(Map.entry(\"arguments\",\n-                    JPackageCommand.escapeAndJoin(defaultArguments)));\n+            properties.put(\"arguments\", JPackageCommand.escapeAndJoin(defaultArguments));\n@@ -201,2 +221,1 @@\n-            properties.add(Map.entry(\"java-options\",\n-                    JPackageCommand.escapeAndJoin(javaOptions)));\n+            properties.put(\"java-options\", JPackageCommand.escapeAndJoin(javaOptions));\n@@ -207,1 +226,1 @@\n-            if (icon == NO_ICON) {\n+            if (icon.equals(NO_ICON)) {\n@@ -212,136 +231,1 @@\n-            properties.add(Map.entry(\"icon\", iconPath));\n-        }\n-\n-        if (withShortcut != null) {\n-            if (TKit.isLinux()) {\n-                properties.add(Map.entry(\"linux-shortcut\", withShortcut.toString()));\n-            } else if (TKit.isWindows()) {\n-                properties.add(Map.entry(\"win-shortcut\", withShortcut.toString()));\n-            }\n-        }\n-\n-        if (TKit.isWindows() && withMenuShortcut != null)  {\n-            properties.add(Map.entry(\"win-menu\", withMenuShortcut.toString()));\n-        }\n-\n-        properties.addAll(rawProperties);\n-\n-        createFileHandler.accept(propsFile, properties);\n-    }\n-\n-    private static Path iconInResourceDir(JPackageCommand cmd,\n-            String launcherName) {\n-        Path resourceDir = cmd.getArgumentValue(\"--resource-dir\", () -> null,\n-                Path::of);\n-        if (resourceDir != null) {\n-            Path icon = resourceDir.resolve(\n-                    Optional.ofNullable(launcherName).orElseGet(() -> cmd.name())\n-                    + TKit.ICON_SUFFIX);\n-            if (Files.exists(icon)) {\n-                return icon;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private void verifyIcon(JPackageCommand cmd) throws IOException {\n-        var verifier = new LauncherIconVerifier().setLauncherName(name);\n-\n-        if (TKit.isOSX()) {\n-            \/\/ On Mac should be no icon files for additional launchers.\n-            verifier.applyTo(cmd);\n-            return;\n-        }\n-\n-        boolean withLinuxDesktopFile = false;\n-\n-        final Path effectiveIcon = Optional.ofNullable(icon).orElseGet(\n-                () -> iconInResourceDir(cmd, name));\n-        while (effectiveIcon != NO_ICON) {\n-            if (effectiveIcon != null) {\n-                withLinuxDesktopFile = Boolean.FALSE != withShortcut;\n-                verifier.setExpectedIcon(effectiveIcon);\n-                break;\n-            }\n-\n-            Path customMainLauncherIcon = cmd.getArgumentValue(\"--icon\",\n-                    () -> iconInResourceDir(cmd, null), Path::of);\n-            if (customMainLauncherIcon != null) {\n-                withLinuxDesktopFile = Boolean.FALSE != withShortcut;\n-                verifier.setExpectedIcon(customMainLauncherIcon);\n-                break;\n-            }\n-\n-            verifier.setExpectedDefaultIcon();\n-            break;\n-        }\n-\n-        if (TKit.isLinux() && !cmd.isImagePackageType()) {\n-            if (effectiveIcon != NO_ICON && !withLinuxDesktopFile) {\n-                withLinuxDesktopFile = (Boolean.FALSE != withShortcut) &&\n-                        Stream.of(\"--linux-shortcut\").anyMatch(cmd::hasArgument);\n-                verifier.setExpectedDefaultIcon();\n-            }\n-            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            if (withLinuxDesktopFile) {\n-                TKit.assertFileExists(desktopFile);\n-            } else {\n-                TKit.assertPathExists(desktopFile, false);\n-            }\n-        }\n-\n-        verifier.applyTo(cmd);\n-    }\n-\n-    private void verifyShortcuts(JPackageCommand cmd) throws IOException {\n-        if (TKit.isLinux() && !cmd.isImagePackageType()\n-                && withShortcut != null) {\n-            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            if (withShortcut) {\n-                TKit.assertFileExists(desktopFile);\n-            } else {\n-                TKit.assertPathExists(desktopFile, false);\n-            }\n-        }\n-    }\n-\n-    private void verifyDescription(JPackageCommand cmd) throws IOException {\n-        if (TKit.isWindows()) {\n-            String expectedDescription = getDesciption(cmd);\n-            Path launcherPath = cmd.appLauncherPath(name);\n-            String actualDescription =\n-                    WindowsHelper.getExecutableDesciption(launcherPath);\n-            TKit.assertEquals(expectedDescription, actualDescription,\n-                    String.format(\"Check file description of [%s]\", launcherPath));\n-        } else if (TKit.isLinux() && !cmd.isImagePackageType()) {\n-            String expectedDescription = getDesciption(cmd);\n-            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            if (Files.exists(desktopFile)) {\n-                TKit.assertTextStream(\"Comment=\" + expectedDescription)\n-                        .label(String.format(\"[%s] file\", desktopFile))\n-                        .predicate(String::equals)\n-                        .apply(Files.readAllLines(desktopFile));\n-            }\n-        }\n-    }\n-\n-    private void verifyInstalled(JPackageCommand cmd, boolean installed) throws IOException {\n-        if (TKit.isLinux() && !cmd.isImagePackageType() && !cmd.\n-                isPackageUnpacked(String.format(\n-                        \"Not verifying package and system .desktop files for [%s] launcher\",\n-                        cmd.appLauncherPath(name)))) {\n-            Path packageDesktopFile = LinuxHelper.getDesktopFile(cmd, name);\n-            Path systemDesktopFile = LinuxHelper.getSystemDesktopFilesFolder().\n-                    resolve(packageDesktopFile.getFileName());\n-            if (Files.exists(packageDesktopFile) && installed) {\n-                TKit.assertFileExists(systemDesktopFile);\n-                TKit.assertStringListEquals(Files.readAllLines(\n-                        packageDesktopFile),\n-                        Files.readAllLines(systemDesktopFile), String.format(\n-                        \"Check [%s] and [%s] files are equal\",\n-                        packageDesktopFile,\n-                        systemDesktopFile));\n-            } else {\n-                TKit.assertPathExists(packageDesktopFile, false);\n-                TKit.assertPathExists(systemDesktopFile, false);\n-            }\n+            properties.put(\"icon\", iconPath);\n@@ -349,1 +233,0 @@\n-    }\n@@ -351,20 +234,1 @@\n-    protected void verifyUninstalled(JPackageCommand cmd) throws IOException {\n-        verifyInstalled(cmd, false);\n-        Path launcherPath = cmd.appLauncherPath(name);\n-        TKit.assertPathExists(launcherPath, false);\n-    }\n-\n-    protected void verify(JPackageCommand cmd) throws IOException {\n-        verifyIcon(cmd);\n-        verifyShortcuts(cmd);\n-        verifyDescription(cmd);\n-        verifyInstalled(cmd, true);\n-\n-        Path launcherPath = cmd.appLauncherPath(name);\n-\n-        TKit.assertExecutableFileExists(launcherPath);\n-\n-        if (!cmd.canRunLauncher(String.format(\n-                \"Not running %s launcher\", launcherPath))) {\n-            return;\n-        }\n+        properties.putAll(rawProperties);\n@@ -372,17 +236,1 @@\n-        var appVerifier = HelloApp.assertApp(launcherPath)\n-                .addDefaultArguments(Optional\n-                        .ofNullable(defaultArguments)\n-                        .orElseGet(() -> List.of(cmd.getAllArgumentValues(\"--arguments\"))))\n-                .addJavaOptions(Optional\n-                        .ofNullable(javaOptions)\n-                        .orElseGet(() -> List.of(cmd.getAllArgumentValues(\n-                        \"--java-options\"))).stream().map(\n-                        str -> resolveVariables(cmd, str)).toList());\n-\n-        if (!rawProperties.contains(LAUNCHER_AS_SERVICE)) {\n-            appVerifier.executeAndVerifyOutput();\n-        } else if (!cmd.isPackageUnpacked(String.format(\n-                \"Not verifying contents of test output file for [%s] launcher\",\n-                launcherPath))) {\n-            appVerifier.verifyOutput();\n-        }\n+        createFileHandler.accept(propsFile, properties.entrySet());\n@@ -393,12 +241,3 @@\n-        PropertyFile(Path path) throws IOException {\n-            data = Files.readAllLines(path).stream().map(str -> {\n-                return str.split(\"=\", 2);\n-            }).collect(toMap(tokens -> tokens[0], tokens -> {\n-                if (tokens.length == 1) {\n-                    return \"\";\n-                } else {\n-                    return tokens[1];\n-                }\n-            }, (oldValue, newValue) -> {\n-                return newValue;\n-            }));\n+        PropertyFile(Map<String, String> data) {\n+            this.data = new Properties();\n+            this.data.putAll(data);\n@@ -407,3 +246,5 @@\n-        public boolean isPropertySet(String name) {\n-            Objects.requireNonNull(name);\n-            return data.containsKey(name);\n+        PropertyFile(Path path) throws IOException {\n+            data = new Properties();\n+            try (var reader = Files.newBufferedReader(path)) {\n+                data.load(reader);\n+            }\n@@ -412,1 +253,1 @@\n-        public Optional<String> getPropertyValue(String name) {\n+        public Optional<String> findProperty(String name) {\n@@ -414,1 +255,1 @@\n-            return Optional.of(data.get(name));\n+            return Optional.ofNullable(data.getProperty(name));\n@@ -417,3 +258,2 @@\n-        public Optional<Boolean> getPropertyBooleanValue(String name) {\n-            Objects.requireNonNull(name);\n-            return Optional.ofNullable(data.get(name)).map(Boolean::parseBoolean);\n+        public Optional<Boolean> findBooleanProperty(String name) {\n+            return findProperty(name).map(Boolean::parseBoolean);\n@@ -422,1 +262,1 @@\n-        private final Map<String, String> data;\n+        private final Properties data;\n@@ -425,12 +265,0 @@\n-    private static String resolveVariables(JPackageCommand cmd, String str) {\n-        var map = Stream.of(JPackageCommand.Macro.values()).collect(toMap(x -> {\n-            return String.format(\"$%s\", x.name());\n-        }, cmd::macroValue));\n-        for (var e : map.entrySet()) {\n-            str = str.replaceAll(Pattern.quote(e.getKey()),\n-                    Matcher.quoteReplacement(e.getValue().toString()));\n-        }\n-        return str;\n-    }\n-\n-    private boolean verifyUninstalled;\n@@ -441,8 +269,5 @@\n-    private final List<Map.Entry<String, String>> rawProperties;\n-    private BiConsumer<Path, List<Map.Entry<String, String>>> createFileHandler;\n-    private Boolean withMenuShortcut;\n-    private Boolean withShortcut;\n-\n-    private static final Path NO_ICON = Path.of(\"\");\n-    private static final Map.Entry<String, String> LAUNCHER_AS_SERVICE = Map.entry(\n-            \"launcher-as-service\", \"true\");\n+    private final Map<String, String> rawProperties = new HashMap<>();\n+    private BiConsumer<Path, Collection<Map.Entry<String, String>>> createFileHandler;\n+    private final Set<Action> verifyActions = new HashSet<>(Action.VERIFY_DEFAULTS);\n+\n+    static final Path NO_ICON = Path.of(\"\");\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":105,"deletions":280,"binary":false,"changes":385,"status":"modified"},{"patch":"@@ -25,0 +25,4 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n@@ -28,0 +32,1 @@\n+import java.util.HashMap;\n@@ -29,0 +34,1 @@\n+import java.util.Objects;\n@@ -30,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -34,1 +41,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -36,0 +42,2 @@\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n@@ -38,1 +46,1 @@\n-        String version, boolean macSigned, boolean macAppStore) {\n+        String version, boolean macSigned, boolean macAppStore, Map<String, Map<String, String>> launchers) {\n@@ -47,0 +55,9 @@\n+    public AppImageFile {\n+        Objects.requireNonNull(mainLauncherName);\n+        Objects.requireNonNull(mainLauncherClassName);\n+        Objects.requireNonNull(version);\n+        if (!launchers.containsKey(mainLauncherName)) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n@@ -48,1 +65,7 @@\n-        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, false);\n+        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, false, Map.of(mainLauncherName, Map.of()));\n+    }\n+\n+    public Map<String, Map<String, String>> addLaunchers() {\n+        return launchers.entrySet().stream().filter(e -> {\n+            return !e.getKey().equals(mainLauncherName);\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -76,0 +99,12 @@\n+\n+            for (var al : addLaunchers().keySet().stream().sorted().toList()) {\n+                xml.writeStartElement(\"add-launcher\");\n+                xml.writeAttribute(\"name\", al);\n+                var props = launchers.get(al);\n+                for (var prop : props.keySet().stream().sorted().toList()) {\n+                    xml.writeStartElement(prop);\n+                    xml.writeCharacters(props.get(prop));\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            }\n@@ -102,0 +137,26 @@\n+            var addLaunchers = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/add-launcher\").map(Element.class::cast).map(toFunction(addLauncher -> {\n+                Map<String, String> launcherProps = new HashMap<>();\n+\n+                \/\/ @name and @service attributes.\n+                XmlUtils.toStream(addLauncher.getAttributes()).forEach(attr -> {\n+                    launcherProps.put(attr.getNodeName(), attr.getNodeValue());\n+                });\n+\n+                \/\/ Extra properties.\n+                XmlUtils.queryNodes(addLauncher, xPath, \"*[count(*) = 0]\").map(Element.class::cast).forEach(e -> {\n+                    launcherProps.put(e.getNodeName(), e.getTextContent());\n+                });\n+\n+                return launcherProps;\n+            }));\n+\n+            var mainLauncherProperties = Map.of(\"name\", mainLauncherName);\n+\n+            var launchers = Stream.concat(Stream.of(mainLauncherProperties), addLaunchers).collect(toMap(attrs -> {\n+                return Objects.requireNonNull(attrs.get(\"name\"));\n+            }, attrs -> {\n+                Map<String, String> copy = new HashMap<>(attrs);\n+                copy.remove(\"name\");\n+                return Map.copyOf(copy);\n+            }));\n+\n@@ -103,1 +164,1 @@\n-                    version, macSigned, macAppStore);\n+                    version, macSigned, macAppStore, launchers);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AppImageFile.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+        verifyMutable();\n@@ -43,2 +44,1 @@\n-        args.add(v);\n-        return thiz();\n+        return addArguments(v);\n@@ -48,0 +48,1 @@\n+        verifyMutable();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CommandArguments.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-                            .getPropertyBooleanValue(\"launcher-as-service\").orElse(false);\n+                            .findBooleanProperty(\"launcher-as-service\").orElse(false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    public JPackageCommand(JPackageCommand cmd) {\n+    private JPackageCommand(JPackageCommand cmd, boolean immutable) {\n@@ -84,1 +84,1 @@\n-        immutable = cmd.immutable;\n+        this.immutable = immutable;\n@@ -93,0 +93,1 @@\n+        unpackedPackageDirectory = cmd.unpackedPackageDirectory;\n@@ -96,3 +97,5 @@\n-        JPackageCommand reply = new JPackageCommand(this);\n-        reply.immutable = true;\n-        return reply;\n+        return new JPackageCommand(this, true);\n+    }\n+\n+    JPackageCommand createMutableCopy() {\n+        return new JPackageCommand(this, false);\n@@ -319,1 +322,0 @@\n-        verifyMutable();\n@@ -325,1 +327,0 @@\n-        verifyMutable();\n@@ -487,1 +488,1 @@\n-        return getArgumentValue(UNPACKED_PATH_ARGNAME, () -> null, Path::of);\n+        return unpackedPackageDirectory;\n@@ -665,1 +666,1 @@\n-        return hasArgument(UNPACKED_PATH_ARGNAME);\n+        return unpackedPackageDirectory != null;\n@@ -794,5 +795,0 @@\n-    public JPackageCommand executeVerifyActions() {\n-        verifyActions.run();\n-        return this;\n-    }\n-\n@@ -823,0 +819,1 @@\n+        verifyMutable();\n@@ -862,1 +859,1 @@\n-        final var copy = new JPackageCommand(this).adjustArgumentsBeforeExecution();\n+        final var copy = createMutableCopy().adjustArgumentsBeforeExecution();\n@@ -879,1 +876,1 @@\n-            executeVerifyActions();\n+            verifyActions.run();\n@@ -887,1 +884,1 @@\n-        HelloApp.executeLauncherAndVerifyOutput(this);\n+        LauncherVerifier.executeMainLauncherAndVerifyOutput(this);\n@@ -1049,0 +1046,1 @@\n+        verifyMutable();\n@@ -1062,1 +1060,1 @@\n-        MAIN_LAUNCHER(cmd -> {\n+        NO_MAIN_LAUNCHER_IN_RUNTIME(cmd -> {\n@@ -1065,2 +1063,0 @@\n-            } else {\n-                TKit.assertExecutableFileExists(cmd.appLauncherPath());\n@@ -1069,1 +1065,1 @@\n-        MAIN_LAUNCHER_CFG_FILE(cmd -> {\n+        NO_MAIN_LAUNCHER_CFG_FILE_IN_RUNTIME(cmd -> {\n@@ -1072,2 +1068,5 @@\n-            } else {\n-                TKit.assertFileExists(cmd.appLauncherCfgPath(null));\n+            }\n+        }),\n+        MAIN_LAUNCHER_FILES(cmd -> {\n+            if (!cmd.isRuntime()) {\n+                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_INSTALLED);\n@@ -1100,1 +1099,1 @@\n-            var copy = new JPackageCommand(cmd);\n+            var copy = cmd.createMutableCopy();\n@@ -1114,0 +1113,1 @@\n+        verifyMutable();\n@@ -1160,3 +1160,2 @@\n-            if (TKit.isOSX()) {\n-                final Path rootDir = isImagePackageType() ? outputBundle() :\n-                        pathToUnpackedPackageFile(appInstallationDirectory());\n+            final Path rootDir = isImagePackageType() ? outputBundle() :\n+                pathToUnpackedPackageFile(appInstallationDirectory());\n@@ -1164,1 +1163,1 @@\n-                AppImageFile aif = AppImageFile.load(rootDir);\n+            final AppImageFile aif = AppImageFile.load(rootDir);\n@@ -1166,0 +1165,1 @@\n+            if (TKit.isOSX()) {\n@@ -1176,0 +1176,5 @@\n+\n+            TKit.assertStringListEquals(\n+                    addLauncherNames().stream().sorted().toList(),\n+                    aif.addLaunchers().keySet().stream().sorted().toList(),\n+                    \"Check additional launcher names\");\n@@ -1257,0 +1262,1 @@\n+        verifyMutable();\n@@ -1258,5 +1264,1 @@\n-        if (path != null) {\n-            setArgumentValue(UNPACKED_PATH_ARGNAME, path);\n-        } else {\n-            removeArgumentWithValue(UNPACKED_PATH_ARGNAME);\n-        }\n+        unpackedPackageDirectory = path;\n@@ -1267,0 +1269,1 @@\n+        verifyMutable();\n@@ -1289,0 +1292,1 @@\n+        verifyMutable();\n@@ -1472,0 +1476,1 @@\n+    private Path unpackedPackageDirectory;\n@@ -1499,2 +1504,0 @@\n-    private static final String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":38,"deletions":35,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -25,0 +25,7 @@\n+import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n+import static jdk.jpackage.test.PackageType.LINUX;\n+import static jdk.jpackage.test.PackageType.MAC_PKG;\n+import static jdk.jpackage.test.PackageType.WINDOWS;\n+\n@@ -30,0 +37,1 @@\n+import java.util.Collection;\n@@ -39,2 +47,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -42,3 +48,2 @@\n-import static jdk.jpackage.test.PackageType.LINUX;\n-import static jdk.jpackage.test.PackageType.MAC_PKG;\n-import static jdk.jpackage.test.PackageType.WINDOWS;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n@@ -114,0 +119,1 @@\n+        pkg.addInstallVerifier(this::verifyLauncherExecuted);\n@@ -130,1 +136,0 @@\n-\n@@ -191,17 +196,5 @@\n-        AdditionalLauncher.forEachAdditionalLauncher(cmd,\n-                ThrowingBiConsumer.toBiConsumer(\n-                        (launcherName, propFilePath) -> {\n-                            if (Files.readAllLines(propFilePath).stream().anyMatch(\n-                                    line -> {\n-                                        if (line.startsWith(\n-                                                \"launcher-as-service=\")) {\n-                                            return Boolean.parseBoolean(\n-                                                    line.substring(\n-                                                            \"launcher-as-service=\".length()));\n-                                        } else {\n-                                            return false;\n-                                        }\n-                                    })) {\n-                                launcherNames.add(launcherName);\n-                            }\n-                        }));\n+        forEachAdditionalLauncher(cmd, toBiConsumer((launcherName, propFilePath) -> {\n+            if (new PropertyFile(propFilePath).findBooleanProperty(\"launcher-as-service\").orElse(false)) {\n+                launcherNames.add(launcherName);\n+            }\n+        }));\n@@ -240,15 +233,0 @@\n-        pkg.addInstallVerifier(cmd -> {\n-            if (canVerifyInstall(cmd)) {\n-                delayInstallVerify();\n-                Path outputFilePath = appOutputFilePathVerify(cmd);\n-                HelloApp.assertApp(cmd.appLauncherPath())\n-                        .addParam(\"jpackage.test.appOutput\",\n-                                outputFilePath.toString())\n-                        .addDefaultArguments(expectedValue)\n-                        .verifyOutput();\n-                deleteOutputFile(outputFilePath);\n-            }\n-        });\n-        pkg.addInstallVerifier(cmd -> {\n-            verify(cmd, launcherName);\n-        });\n@@ -258,13 +236,3 @@\n-        AdditionalLauncher al = new AdditionalLauncher(launcherName) {\n-            @Override\n-            protected void verify(JPackageCommand cmd) throws IOException {\n-                if (canVerifyInstall(cmd)) {\n-                    delayInstallVerify();\n-                    super.verify(cmd);\n-                    deleteOutputFile(appOutputFilePathVerify(cmd));\n-                }\n-                LauncherAsServiceVerifier.verify(cmd, launcherName);\n-            }\n-        }.setLauncherAsService()\n-                .addJavaOptions(\"-Djpackage.test.appOutput=\"\n-                        + appOutputFilePathInitialize().toString())\n+        var al = new AdditionalLauncher(launcherName)\n+                .setProperty(\"launcher-as-service\", true)\n+                .addJavaOptions(\"-Djpackage.test.appOutput=\" + appOutputFilePathInitialize().toString())\n@@ -272,1 +240,2 @@\n-                .addDefaultArguments(expectedValue);\n+                .addDefaultArguments(expectedValue)\n+                .withoutVerifyActions(Action.EXECUTE_LAUNCHER);\n@@ -279,0 +248,12 @@\n+    private void verifyLauncherExecuted(JPackageCommand cmd) throws IOException {\n+        if (canVerifyInstall(cmd)) {\n+            delayInstallVerify();\n+            Path outputFilePath = appOutputFilePathVerify(cmd);\n+            HelloApp.assertApp(cmd.appLauncherPath())\n+                    .addParam(\"jpackage.test.appOutput\", outputFilePath.toString())\n+                    .addDefaultArguments(expectedValue)\n+                    .verifyOutput();\n+            deleteOutputFile(outputFilePath);\n+        }\n+    }\n+\n@@ -294,2 +275,1 @@\n-    private static void verify(JPackageCommand cmd, String launcherName) throws\n-            IOException {\n+    private static void verify(JPackageCommand cmd, String launcherName) throws IOException {\n@@ -373,2 +353,5 @@\n-    static final Set<PackageType> SUPPORTED_PACKAGES = Stream.of(LINUX, WINDOWS,\n-            Set.of(MAC_PKG)).flatMap(x -> x.stream()).collect(Collectors.toSet());\n+    static final Set<PackageType> SUPPORTED_PACKAGES = Stream.of(\n+            LINUX,\n+            WINDOWS,\n+            Set.of(MAC_PKG)\n+    ).flatMap(Collection::stream).collect(Collectors.toSet());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":39,"deletions":56,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -49,0 +49,5 @@\n+    public LauncherIconVerifier verifyFileInAppImageOnly(boolean v) {\n+        verifyFileInAppImageOnly = true;\n+        return this;\n+    }\n+\n@@ -65,2 +70,3 @@\n-            WinExecutableIconVerifier.verifyLauncherIcon(cmd, launcherName,\n-                    expectedIcon, expectedDefault);\n+            if (!verifyFileInAppImageOnly) {\n+                WinExecutableIconVerifier.verifyLauncherIcon(cmd, launcherName, expectedIcon, expectedDefault);\n+            }\n@@ -73,4 +79,6 @@\n-            TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n-                    String.format(\n-                    \"Check icon file [%s] of %s launcher is a copy of source icon file [%s]\",\n-                    iconPath, label, expectedIcon));\n+            if (!verifyFileInAppImageOnly) {\n+                TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n+                        String.format(\n+                        \"Check icon file [%s] of %s launcher is a copy of source icon file [%s]\",\n+                        iconPath, label, expectedIcon));\n+            }\n@@ -83,0 +91,1 @@\n+    private boolean verifyFileInAppImageOnly;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+\n+public enum LauncherShortcut {\n+\n+    LINUX_SHORTCUT(\"linux-shortcut\"),\n+\n+    WIN_DESKTOP_SHORTCUT(\"win-shortcut\"),\n+\n+    WIN_START_MENU_SHORTCUT(\"win-menu\");\n+\n+    public enum StartupDirectory {\n+        DEFAULT(\"true\"),\n+        ;\n+\n+        StartupDirectory(String stringValue) {\n+            this.stringValue = Objects.requireNonNull(stringValue);\n+        }\n+\n+        public String asStringValue() {\n+            return stringValue;\n+        }\n+\n+        \/**\n+         * Returns shortcut startup directory or an empty {@link Optional} instance if\n+         * the value of the {@code str} parameter evaluates to {@code false}.\n+         *\n+         * @param str the value of a shortcut startup directory\n+         * @return shortcut startup directory or an empty {@link Optional} instance\n+         * @throws IllegalArgumentException if the value of the {@code str} parameter is\n+         *                                  unrecognized\n+         *\/\n+        static Optional<StartupDirectory> parse(String str) {\n+            Objects.requireNonNull(str);\n+            return Optional.ofNullable(VALUE_MAP.get(str)).or(() -> {\n+                if (Boolean.TRUE.toString().equals(str)) {\n+                    return Optional.of(StartupDirectory.DEFAULT);\n+                } else if (Boolean.FALSE.toString().equals(str)) {\n+                    return Optional.empty();\n+                } else {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Unrecognized launcher shortcut startup directory: [%s]\", str));\n+                }\n+            });\n+        }\n+\n+        private final String stringValue;\n+\n+        private final static Map<String, StartupDirectory> VALUE_MAP =\n+                Stream.of(values()).collect(toMap(StartupDirectory::asStringValue, x -> x));\n+    }\n+\n+    LauncherShortcut(String propertyName) {\n+        this.propertyName = Objects.requireNonNull(propertyName);\n+    }\n+\n+    public String propertyName() {\n+        return propertyName;\n+    }\n+\n+    public String appImageFilePropertyName() {\n+        return propertyName.substring(propertyName.indexOf('-') + 1);\n+    }\n+\n+    public String optionName() {\n+        return \"--\" + propertyName;\n+    }\n+\n+    Optional<StartupDirectory> expectShortcut(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, String launcherName) {\n+        Objects.requireNonNull(predefinedAppImage);\n+\n+        final var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+\n+        if (name.equals(cmd.name())) {\n+            return findMainLauncherShortcut(cmd);\n+        } else {\n+            String[] propertyName = new String[1];\n+            return findAddLauncherShortcut(cmd, predefinedAppImage.map(appImage -> {\n+                propertyName[0] = appImageFilePropertyName();\n+                return new PropertyFile(appImage.addLaunchers().get(launcherName));\n+            }).orElseGet(() -> {\n+                propertyName[0] = this.propertyName;\n+                return getAdditionalLauncherProperties(cmd, launcherName);\n+            })::findProperty, propertyName[0]);\n+        }\n+    }\n+\n+\n+    public interface InvokeShortcutSpec {\n+        String launcherName();\n+        LauncherShortcut shortcut();\n+        Optional<Path> expectedWorkDirectory();\n+        List<String> commandLine();\n+\n+        default Executor.Result execute() {\n+            return HelloApp.configureAndExecute(0, Executor.of(commandLine()).dumpOutput());\n+        }\n+\n+        record Stub(\n+                String launcherName,\n+                LauncherShortcut shortcut,\n+                Optional<Path> expectedWorkDirectory,\n+                List<String> commandLine) implements InvokeShortcutSpec {\n+\n+            public Stub {\n+                Objects.requireNonNull(launcherName);\n+                Objects.requireNonNull(shortcut);\n+                Objects.requireNonNull(expectedWorkDirectory);\n+                Objects.requireNonNull(commandLine);\n+            }\n+        }\n+    }\n+\n+\n+    private Optional<StartupDirectory> findMainLauncherShortcut(JPackageCommand cmd) {\n+        if (cmd.hasArgument(optionName())) {\n+            return Optional.of(StartupDirectory.DEFAULT);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Optional<StartupDirectory> findAddLauncherShortcut(JPackageCommand cmd,\n+            Function<String, Optional<String>> addlauncherProperties, String propertyName) {\n+        var explicit = addlauncherProperties.apply(propertyName);\n+        if (explicit.isPresent()) {\n+            return explicit.flatMap(StartupDirectory::parse);\n+        } else {\n+            return findMainLauncherShortcut(cmd);\n+        }\n+    }\n+\n+    private final String propertyName;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,326 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.test.AdditionalLauncher.NO_ICON;\n+import static jdk.jpackage.test.LauncherShortcut.LINUX_SHORTCUT;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+\n+public final class LauncherVerifier {\n+\n+    LauncherVerifier(JPackageCommand cmd) {\n+        name = cmd.name();\n+        javaOptions = Optional.empty();\n+        arguments = Optional.empty();\n+        icon = Optional.empty();\n+        properties = Optional.empty();\n+    }\n+\n+    LauncherVerifier(String name,\n+            Optional<List<String>> javaOptions,\n+            Optional<List<String>> arguments,\n+            Optional<Path> icon,\n+            Map<String, String> properties) {\n+        this.name = Objects.requireNonNull(name);\n+        this.javaOptions = javaOptions.map(List::copyOf);\n+        this.arguments = arguments.map(List::copyOf);\n+        this.icon = icon;\n+        this.properties = Optional.of(new PropertyFile(properties));\n+    }\n+\n+    static void executeMainLauncherAndVerifyOutput(JPackageCommand cmd) {\n+        new LauncherVerifier(cmd).verify(cmd, Action.EXECUTE_LAUNCHER);\n+    }\n+\n+\n+    public enum Action {\n+        VERIFY_ICON(LauncherVerifier::verifyIcon),\n+        VERIFY_DESCRIPTION(LauncherVerifier::verifyDescription),\n+        VERIFY_INSTALLED((verifier, cmd) -> {\n+            verifier.verifyInstalled(cmd, true);\n+        }),\n+        VERIFY_UNINSTALLED((verifier, cmd) -> {\n+            verifier.verifyInstalled(cmd, false);\n+        }),\n+        EXECUTE_LAUNCHER(LauncherVerifier::executeLauncher),\n+        ;\n+\n+        Action(ThrowingBiConsumer<LauncherVerifier, JPackageCommand> action) {\n+            this.action = ThrowingBiConsumer.toBiConsumer(action);\n+        }\n+\n+        private void apply(LauncherVerifier verifier, JPackageCommand cmd) {\n+            action.accept(verifier, cmd);\n+        }\n+\n+        private final BiConsumer<LauncherVerifier, JPackageCommand> action;\n+\n+        static final List<Action> VERIFY_APP_IMAGE = List.of(\n+                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED\n+        );\n+\n+        static final List<Action> VERIFY_DEFAULTS = Stream.concat(\n+                VERIFY_APP_IMAGE.stream(), Stream.of(EXECUTE_LAUNCHER)\n+        ).toList();\n+    }\n+\n+\n+    void verify(JPackageCommand cmd, Action... actions) {\n+        verify(cmd, List.of(actions));\n+    }\n+\n+    void verify(JPackageCommand cmd, Iterable<Action> actions) {\n+        Objects.requireNonNull(cmd);\n+        for (var a : actions) {\n+            a.apply(this, cmd);\n+        }\n+    }\n+\n+    private boolean isMainLauncher() {\n+        return properties.isEmpty();\n+    }\n+\n+    private Optional<String> findProperty(String key) {\n+        return properties.flatMap(v -> {\n+            return v.findProperty(key);\n+        });\n+    }\n+\n+    private String getDescription(JPackageCommand cmd) {\n+        return findProperty(\"description\").orElseGet(() -> {\n+            return cmd.getArgumentValue(\"--description\", cmd::name);\n+        });\n+    }\n+\n+    private List<String> getArguments(JPackageCommand cmd) {\n+        return getStringArrayProperty(cmd, \"--arguments\", arguments);\n+    }\n+\n+    private List<String> getJavaOptions(JPackageCommand cmd) {\n+        return getStringArrayProperty(cmd, \"--java-options\", javaOptions);\n+    }\n+\n+    private List<String> getStringArrayProperty(JPackageCommand cmd, String optionName, Optional<List<String>> items) {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(optionName);\n+        Objects.requireNonNull(items);\n+        if (isMainLauncher()) {\n+            return List.of(cmd.getAllArgumentValues(optionName));\n+        } else {\n+            return items.orElseGet(() -> {\n+                return List.of(cmd.getAllArgumentValues(optionName));\n+            });\n+        }\n+    }\n+\n+    private boolean explicitlyNoShortcut(LauncherShortcut shortcut) {\n+        var explicit = findProperty(shortcut.propertyName());\n+        if (explicit.isPresent()) {\n+            return explicit.flatMap(StartupDirectory::parse).isEmpty();\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private static boolean explicitShortcutForMainLauncher(JPackageCommand cmd, LauncherShortcut shortcut) {\n+        return cmd.hasArgument(shortcut.optionName());\n+    }\n+\n+    private void verifyIcon(JPackageCommand cmd) throws IOException {\n+        initIconVerifier(cmd).applyTo(cmd);\n+    }\n+\n+    private LauncherIconVerifier initIconVerifier(JPackageCommand cmd) {\n+        var verifier = new LauncherIconVerifier().setLauncherName(name);\n+\n+        var mainLauncherIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of).or(() -> {\n+            return iconInResourceDir(cmd, cmd.name());\n+        });\n+\n+        if (TKit.isOSX()) {\n+            \/\/ There should be no icon files on Mac for additional launchers,\n+            \/\/ and always an icon file for the main launcher.\n+            if (isMainLauncher()) {\n+                mainLauncherIcon.ifPresentOrElse(verifier::setExpectedIcon, verifier::setExpectedDefaultIcon);\n+            }\n+            return verifier;\n+        }\n+\n+        if (isMainLauncher()) {\n+            mainLauncherIcon.ifPresentOrElse(verifier::setExpectedIcon, verifier::setExpectedDefaultIcon);\n+        } else {\n+            icon.ifPresentOrElse(icon -> {\n+                if (!NO_ICON.equals(icon)) {\n+                    verifier.setExpectedIcon(icon);\n+                }\n+            }, () -> {\n+                \/\/ No \"icon\" property in the property file\n+                iconInResourceDir(cmd, name).ifPresentOrElse(verifier::setExpectedIcon, () -> {\n+                    \/\/ No icon for this additional launcher in the resource directory.\n+                    mainLauncherIcon.ifPresentOrElse(verifier::setExpectedIcon, verifier::setExpectedDefaultIcon);\n+                });\n+            });\n+        }\n+\n+        return verifier;\n+    }\n+\n+    private static boolean withLinuxMainLauncherDesktopFile(JPackageCommand cmd) {\n+        if (!TKit.isLinux() || cmd.isImagePackageType()) {\n+            return false;\n+        }\n+\n+        return explicitShortcutForMainLauncher(cmd, LINUX_SHORTCUT)\n+                || cmd.hasArgument(\"--icon\")\n+                || cmd.hasArgument(\"--file-associations\")\n+                || iconInResourceDir(cmd, cmd.name()).isPresent();\n+    }\n+\n+    private boolean withLinuxDesktopFile(JPackageCommand cmd) {\n+        if (!TKit.isLinux() || cmd.isImagePackageType()) {\n+            return false;\n+        }\n+\n+        if (isMainLauncher()) {\n+            return withLinuxMainLauncherDesktopFile(cmd);\n+        } else if (explicitlyNoShortcut(LINUX_SHORTCUT) || icon.map(icon -> {\n+            return icon.equals(NO_ICON);\n+        }).orElse(false)) {\n+            return false;\n+        } else if (iconInResourceDir(cmd, name).isPresent() || icon.map(icon -> {\n+            return !icon.equals(NO_ICON);\n+        }).orElse(false)) {\n+            return true;\n+        } else if (findProperty(LINUX_SHORTCUT.propertyName()).flatMap(StartupDirectory::parse).isPresent()) {\n+            return true;\n+        } else {\n+            return withLinuxMainLauncherDesktopFile(cmd.createMutableCopy().removeArgument(\"--file-associations\"));\n+        }\n+    }\n+\n+    private void verifyDescription(JPackageCommand cmd) throws IOException {\n+        if (TKit.isWindows()) {\n+            String expectedDescription = getDescription(cmd);\n+            Path launcherPath = cmd.appLauncherPath(name);\n+            String actualDescription =\n+                    WindowsHelper.getExecutableDescription(launcherPath);\n+            TKit.assertEquals(expectedDescription, actualDescription,\n+                    String.format(\"Check file description of [%s]\", launcherPath));\n+        } else if (TKit.isLinux() && !cmd.isImagePackageType()) {\n+            String expectedDescription = getDescription(cmd);\n+            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            if (Files.exists(desktopFile)) {\n+                TKit.assertTextStream(\"Comment=\" + expectedDescription)\n+                        .label(String.format(\"[%s] file\", desktopFile))\n+                        .predicate(String::equals)\n+                        .apply(Files.readAllLines(desktopFile));\n+            }\n+        }\n+    }\n+\n+    private void verifyInstalled(JPackageCommand cmd, boolean installed) throws IOException {\n+        var launcherPath = cmd.appLauncherPath(name);\n+        var launcherCfgFilePath = cmd.appLauncherCfgPath(name);\n+        if (installed) {\n+            TKit.assertExecutableFileExists(launcherPath);\n+            TKit.assertFileExists(launcherCfgFilePath);\n+        } else {\n+            TKit.assertPathExists(launcherPath, false);\n+            TKit.assertPathExists(launcherCfgFilePath, false);\n+        }\n+\n+        if (TKit.isLinux() && !cmd.isImagePackageType()) {\n+            final var packageDesktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            final var withLinuxDesktopFile = withLinuxDesktopFile(cmd) && installed;\n+            if (withLinuxDesktopFile) {\n+                TKit.assertFileExists(packageDesktopFile);\n+            } else {\n+                TKit.assertPathExists(packageDesktopFile, false);\n+            }\n+        }\n+\n+        if (installed) {\n+            initIconVerifier(cmd).verifyFileInAppImageOnly(true).applyTo(cmd);\n+        }\n+    }\n+\n+    private void executeLauncher(JPackageCommand cmd) throws IOException {\n+        Path launcherPath = cmd.appLauncherPath(name);\n+\n+        if (!cmd.canRunLauncher(String.format(\"Not running [%s] launcher\", launcherPath))) {\n+            return;\n+        }\n+\n+        var appVerifier = HelloApp.assertApp(launcherPath)\n+                .addDefaultArguments(getArguments(cmd))\n+                .addJavaOptions(getJavaOptions(cmd).stream().map(str -> {\n+                    return resolveVariables(cmd, str);\n+                }).toList());\n+\n+        appVerifier.executeAndVerifyOutput();\n+    }\n+\n+    private static String resolveVariables(JPackageCommand cmd, String str) {\n+        var map = Stream.of(JPackageCommand.Macro.values()).collect(toMap(x -> {\n+            return String.format(\"$%s\", x.name());\n+        }, cmd::macroValue));\n+        for (var e : map.entrySet()) {\n+            str = str.replaceAll(Pattern.quote(e.getKey()),\n+                    Matcher.quoteReplacement(e.getValue().toString()));\n+        }\n+        return str;\n+    }\n+\n+    private static Optional<Path> iconInResourceDir(JPackageCommand cmd, String launcherName) {\n+        Objects.requireNonNull(launcherName);\n+        return Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).map(resourceDir -> {\n+            Path icon = resourceDir.resolve(launcherName + TKit.ICON_SUFFIX);\n+            if (Files.exists(icon)) {\n+                return icon;\n+            } else {\n+                return null;\n+            }\n+        });\n+    }\n+\n+    private final String name;\n+    private final Optional<List<String>> javaOptions;\n+    private final Optional<List<String>> arguments;\n+    private final Optional<Path> icon;\n+    private final Optional<PropertyFile> properties;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.UncheckedIOException;\n@@ -32,0 +33,1 @@\n+import java.util.Collection;\n@@ -36,0 +38,1 @@\n+import java.util.Objects;\n@@ -39,0 +42,1 @@\n+import java.util.function.Predicate;\n@@ -45,0 +49,1 @@\n+import jdk.jpackage.test.LauncherShortcut.InvokeShortcutSpec;\n@@ -311,2 +316,2 @@\n-        String packageName = LinuxHelper.getPackageName(cmd);\n-        long packageSize = LinuxHelper.getInstalledPackageSizeKB(cmd);\n+        String packageName = getPackageName(cmd);\n+        long packageSize = getInstalledPackageSizeKB(cmd);\n@@ -333,1 +338,1 @@\n-        List<String> prerequisites = LinuxHelper.getPrerequisitePackages(cmd);\n+        List<String> prerequisites = getPrerequisitePackages(cmd);\n@@ -343,1 +348,1 @@\n-                    \"Not cheking %s required packages of [%s] package\",\n+                    \"Not checking %s required packages of [%s] package\",\n@@ -348,2 +353,17 @@\n-    static void addBundleDesktopIntegrationVerifier(PackageTest test,\n-            boolean integrated) {\n+    public static Collection<? extends InvokeShortcutSpec> getInvokeShortcutSpecs(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.LINUX);\n+\n+        final var desktopFiles = getDesktopFiles(cmd);\n+        final var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n+\n+        return desktopFiles.stream().map(desktopFile -> {\n+            var systemDesktopFile = getSystemDesktopFilesFolder().resolve(desktopFile.getFileName());\n+            return new InvokeShortcutSpec.Stub(\n+                    launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile),\n+                    LauncherShortcut.LINUX_SHORTCUT,\n+                    new DesktopFile(systemDesktopFile, false).findQuotedValue(\"Path\").map(Path::of),\n+                    List.of(\"gtk-launch\", PathUtils.replaceSuffix(systemDesktopFile.getFileName(), \"\").toString()));\n+        }).toList();\n+    }\n+\n+    static void addBundleDesktopIntegrationVerifier(PackageTest test, boolean integrated) {\n@@ -395,14 +415,5 @@\n-            \/\/ Verify .desktop files.\n-            try (var files = Files.list(cmd.appLayout().desktopIntegrationDirectory())) {\n-                List<Path> desktopFiles = files\n-                        .filter(path -> path.getFileName().toString().endsWith(\".desktop\"))\n-                        .toList();\n-                if (!integrated) {\n-                    TKit.assertStringListEquals(List.of(),\n-                            desktopFiles.stream().map(Path::toString).collect(\n-                                    Collectors.toList()),\n-                            \"Check there are no .desktop files in the package\");\n-                }\n-                for (var desktopFile : desktopFiles) {\n-                    verifyDesktopFile(cmd, desktopFile);\n-                }\n+            if (!integrated) {\n+                TKit.assertStringListEquals(\n+                        List.of(),\n+                        getDesktopFiles(cmd).stream().map(Path::toString).toList(),\n+                        \"Check there are no .desktop files in the package\");\n@@ -413,3 +424,8 @@\n-    private static void verifyDesktopFile(JPackageCommand cmd, Path desktopFile)\n-            throws IOException {\n-        TKit.trace(String.format(\"Check [%s] file BEGIN\", desktopFile));\n+    static void verifyDesktopFiles(JPackageCommand cmd, boolean installed) {\n+        final var desktopFiles = getDesktopFiles(cmd);\n+        try {\n+            if (installed) {\n+                var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n+                for (var desktopFile : desktopFiles) {\n+                    verifyDesktopFile(cmd, predefinedAppImage, desktopFile);\n+                }\n@@ -417,6 +433,18 @@\n-        var launcherName = Stream.of(List.of(cmd.name()), cmd.addLauncherNames()).flatMap(List::stream).filter(name -> {\n-            return getDesktopFile(cmd, name).equals(desktopFile);\n-        }).findAny();\n-        if (!cmd.hasArgument(\"--app-image\")) {\n-            TKit.assertTrue(launcherName.isPresent(),\n-                    \"Check the desktop file corresponds to one of app launchers\");\n+                if (!cmd.isPackageUnpacked(\"Not verifying system .desktop files\")) {\n+                    for (var desktopFile : desktopFiles) {\n+                        Path systemDesktopFile = getSystemDesktopFilesFolder().resolve(desktopFile.getFileName());\n+                            TKit.assertFileExists(systemDesktopFile);\n+                            TKit.assertStringListEquals(\n+                                    Files.readAllLines(desktopFile),\n+                                    Files.readAllLines(systemDesktopFile),\n+                                    String.format(\"Check [%s] and [%s] files are equal\", desktopFile, systemDesktopFile));\n+                    }\n+                }\n+            } else {\n+                for (var desktopFile : getDesktopFiles(cmd)) {\n+                    Path systemDesktopFile = getSystemDesktopFilesFolder().resolve(desktopFile.getFileName());\n+                    TKit.assertPathExists(systemDesktopFile, false);\n+                }\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -424,0 +452,1 @@\n+    }\n@@ -425,2 +454,7 @@\n-        List<String> lines = Files.readAllLines(desktopFile);\n-        TKit.assertEquals(\"[Desktop Entry]\", lines.get(0), \"Check file header\");\n+    private static Collection<Path> getDesktopFiles(JPackageCommand cmd) {\n+        var unpackedDir = cmd.appLayout().desktopIntegrationDirectory();\n+        var packageDir = cmd.pathToPackageFile(unpackedDir);\n+        return getPackageFiles(cmd).filter(path -> {\n+            return path.getParent().equals(packageDir) && path.getFileName().toString().endsWith(\".desktop\");\n+        }).map(Path::getFileName).map(unpackedDir::resolve).toList();\n+    }\n@@ -428,11 +462,14 @@\n-        Map<String, String> data = lines.stream()\n-        .skip(1)\n-        .peek(str -> TKit.assertTextStream(\"=\").predicate(String::contains).apply(List.of(str)))\n-        .map(str -> {\n-            String components[] = str.split(\"=(?=.+)\");\n-            if (components.length == 1) {\n-                return Map.entry(str.substring(0, str.length() - 1), \"\");\n-            }\n-            return Map.entry(components[0], components[1]);\n-        }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (a, b) -> {\n-            TKit.assertUnexpected(\"Multiple values of the same key\");\n+    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(predefinedAppImage);\n+        Objects.requireNonNull(desktopFile);\n+\n+        return predefinedAppImage.map(v -> {\n+            return v.launchers().keySet().stream();\n+        }).orElseGet(() -> {\n+            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n+        }).filter(name-> {\n+            return getDesktopFile(cmd, name).equals(desktopFile);\n+        }).findAny().orElseThrow(() -> {\n+            TKit.assertUnexpected(String.format(\"Failed to find launcher corresponding to [%s] file\", desktopFile));\n+            \/\/ Unreachable\n@@ -440,1 +477,13 @@\n-        }));\n+        });\n+    }\n+\n+    private static void verifyDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) throws IOException {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(predefinedAppImage);\n+        Objects.requireNonNull(desktopFile);\n+\n+        TKit.trace(String.format(\"Check [%s] file BEGIN\", desktopFile));\n+\n+        var launcherName = launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile);\n+\n+        var data = new DesktopFile(desktopFile, true);\n@@ -450,1 +499,1 @@\n-            TKit.assertEquals(e.getValue(), data.get(key), String.format(\n+            TKit.assertEquals(e.getValue(), data.find(key).orElseThrow(), String.format(\n@@ -454,8 +503,1 @@\n-        \/\/ Verify the value of `Exec` key is escaped if required\n-        String launcherPath = data.get(\"Exec\");\n-        if (Pattern.compile(\"\\\\s\").matcher(launcherPath).find()) {\n-            TKit.assertTrue(launcherPath.startsWith(\"\\\"\")\n-                    && launcherPath.endsWith(\"\\\"\"),\n-                    \"Check path to the launcher is enclosed in double quotes\");\n-            launcherPath = launcherPath.substring(1, launcherPath.length() - 1);\n-        }\n+        String launcherPath = data.findQuotedValue(\"Exec\").orElseThrow();\n@@ -463,7 +505,23 @@\n-        if (launcherName.isPresent()) {\n-            TKit.assertEquals(launcherPath, cmd.pathToPackageFile(\n-                    cmd.appLauncherPath(launcherName.get())).toString(),\n-                    String.format(\n-                            \"Check the value of [Exec] key references [%s] app launcher\",\n-                            launcherName.get()));\n-        }\n+        TKit.assertEquals(\n+                launcherPath,\n+                cmd.pathToPackageFile(cmd.appLauncherPath(launcherName)).toString(),\n+                String.format(\"Check the value of [Exec] key references [%s] app launcher\", launcherName));\n+\n+        var appLayout = cmd.appLayout();\n+\n+        LauncherShortcut.LINUX_SHORTCUT.expectShortcut(cmd, predefinedAppImage, launcherName).map(shortcutWorkDirType -> {\n+            switch (shortcutWorkDirType) {\n+                case DEFAULT -> {\n+                    return (Path)null;\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        }).map(Path::toString).ifPresentOrElse(shortcutWorkDir -> {\n+            var actualShortcutWorkDir = data.find(\"Path\");\n+            TKit.assertTrue(actualShortcutWorkDir.isPresent(), \"Check [Path] key exists\");\n+            TKit.assertEquals(actualShortcutWorkDir.get(), shortcutWorkDir, \"Check the value of [Path] key\");\n+        }, () -> {\n+            TKit.assertTrue(data.find(\"Path\").isEmpty(), \"Check there is no [Path] key\");\n+        });\n@@ -474,2 +532,3 @@\n-            var path = e.getKey().getValue().or(() -> Optional.of(data.get(\n-                    e.getKey().getKey()))).map(Path::of).get();\n+            var path = e.getKey().getValue().or(() -> {\n+                return data.findQuotedValue(e.getKey().getKey());\n+            }).map(Path::of).get();\n@@ -477,1 +536,1 @@\n-            Path expectedDir = cmd.pathToPackageFile(e.getValue().apply(cmd.appLayout()));\n+            Path expectedDir = cmd.pathToPackageFile(e.getValue().apply(appLayout));\n@@ -764,0 +823,56 @@\n+\n+    private static final class DesktopFile {\n+        DesktopFile(Path path, boolean verify) {\n+            try {\n+                List<String> lines = Files.readAllLines(path);\n+                if (verify) {\n+                    TKit.assertEquals(\"[Desktop Entry]\", lines.getFirst(), \"Check file header\");\n+                }\n+\n+                var stream = lines.stream().skip(1).filter(Predicate.not(String::isEmpty));\n+                if (verify) {\n+                    stream = stream.peek(str -> {\n+                        TKit.assertTextStream(\"=\").predicate(String::contains).apply(List.of(str));\n+                    });\n+                }\n+\n+                data = stream.map(str -> {\n+                    String components[] = str.split(\"=(?=.+)\");\n+                    if (components.length == 1) {\n+                        return Map.entry(str.substring(0, str.length() - 1), \"\");\n+                    } else {\n+                        return Map.entry(components[0], components[1]);\n+                    }\n+                }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        Set<String> keySet() {\n+            return data.keySet();\n+        }\n+\n+        Optional<String> find(String property) {\n+            return Optional.ofNullable(data.get(Objects.requireNonNull(property)));\n+        }\n+\n+        Optional<String> findQuotedValue(String property) {\n+            return find(property).map(value -> {\n+                if (Pattern.compile(\"\\\\s\").matcher(value).find()) {\n+                    boolean quotesMatched = value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\");\n+                    if (!quotesMatched) {\n+                        TKit.assertTrue(quotesMatched,\n+                                String.format(\"Check the value of key [%s] is enclosed in double quotes\", property));\n+                    }\n+                    return value.substring(1, value.length() - 1);\n+                } else {\n+                    return value;\n+                }\n+            });\n+        }\n+\n+        private final Map<String, String> data;\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":177,"deletions":62,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\n+final class MsiDatabase {\n+\n+    static MsiDatabase load(Path msiFile, Path idtFileOutputDir, Set<Table> tableNames) {\n+        try {\n+            Files.createDirectories(idtFileOutputDir);\n+\n+            var orderedTableNames = tableNames.stream().sorted().toList();\n+\n+            Executor.of(\"cscript.exe\", \"\/\/Nologo\")\n+                    .addArgument(TKit.TEST_SRC_ROOT.resolve(\"resources\/msi-export.js\"))\n+                    .addArgument(msiFile)\n+                    .addArgument(idtFileOutputDir)\n+                    .addArguments(orderedTableNames.stream().map(Table::tableName).toList())\n+                    .dumpOutput()\n+                    .execute(0);\n+\n+            var tables = orderedTableNames.stream().map(tableName -> {\n+                return Map.entry(tableName, idtFileOutputDir.resolve(tableName + \".idt\"));\n+            }).filter(e -> {\n+                return Files.exists(e.getValue());\n+            }).collect(Collectors.toMap(Map.Entry::getKey, e -> {\n+                return MsiTable.loadFromTextArchiveFile(e.getValue());\n+            }));\n+\n+            return new MsiDatabase(tables);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+\n+    enum Table {\n+        COMPONENT(\"Component\"),\n+        DIRECTORY(\"Directory\"),\n+        FILE(\"File\"),\n+        PROPERTY(\"Property\"),\n+        SHORTCUT(\"Shortcut\"),\n+        ;\n+\n+        Table(String name) {\n+            this.tableName = Objects.requireNonNull(name);\n+        }\n+\n+        String tableName() {\n+            return tableName;\n+        }\n+\n+        private final String tableName;\n+\n+        static final Set<Table> FIND_PROPERTY_REQUIRED_TABLES = Set.of(PROPERTY);\n+        static final Set<Table> LIST_SHORTCUTS_REQUIRED_TABLES = Set.of(COMPONENT, DIRECTORY, FILE, SHORTCUT);\n+    }\n+\n+\n+    private MsiDatabase(Map<Table, MsiTable> tables) {\n+        this.tables = Map.copyOf(tables);\n+    }\n+\n+    Set<Table> tableNames() {\n+        return tables.keySet();\n+    }\n+\n+    MsiDatabase append(MsiDatabase other) {\n+        Map<Table, MsiTable> newTables = new HashMap<>(tables);\n+        newTables.putAll(other.tables);\n+        return new MsiDatabase(newTables);\n+    }\n+\n+    Optional<String> findProperty(String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        return tables.get(Table.PROPERTY).findRow(\"Property\", propertyName).map(row -> {\n+            return row.apply(\"Value\");\n+        });\n+    }\n+\n+    Collection<Shortcut> listShortcuts() {\n+        var shortcuts = tables.get(Table.SHORTCUT);\n+        if (shortcuts == null) {\n+            return List.of();\n+        }\n+        return IntStream.range(0, shortcuts.rowCount()).mapToObj(i -> {\n+            var row = shortcuts.row(i);\n+            var shortcutPath = directoryPath(row.apply(\"Directory_\")).resolve(fileNameFromFieldValue(row.apply(\"Name\")));\n+            var workDir = directoryPath(row.apply(\"WkDir\"));\n+            var shortcutTarget = Path.of(expandFormattedString(row.apply(\"Target\")));\n+            return new Shortcut(shortcutPath, shortcutTarget, workDir);\n+        }).toList();\n+    }\n+\n+    record Shortcut(Path path, Path target, Path workDir) {\n+\n+        Shortcut {\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(target);\n+            Objects.requireNonNull(workDir);\n+        }\n+\n+        void assertEquals(Shortcut expected) {\n+            TKit.assertEquals(expected.path, path, \"Check the shortcut path\");\n+            TKit.assertEquals(expected.target, target, \"Check the shortcut target\");\n+            TKit.assertEquals(expected.workDir, workDir, \"Check the shortcut work directory\");\n+        }\n+    }\n+\n+    private Path directoryPath(String directoryId) {\n+        var table = tables.get(Table.DIRECTORY);\n+        Path result = null;\n+        for (var row = table.findRow(\"Directory\", directoryId);\n+                row.isPresent();\n+                directoryId = row.get().apply(\"Directory_Parent\"), row = table.findRow(\"Directory\", directoryId)) {\n+\n+            Path pathComponent;\n+            if (DIRECTORY_PROPERTIES.contains(directoryId)) {\n+                pathComponent = Path.of(directoryId);\n+                directoryId = null;\n+            } else {\n+                pathComponent = fileNameFromFieldValue(row.get().apply(\"DefaultDir\"));\n+            }\n+\n+            if (result != null) {\n+                result = pathComponent.resolve(result);\n+            } else {\n+                result = pathComponent;\n+            }\n+\n+            if (directoryId == null) {\n+                break;\n+            }\n+        }\n+\n+        return Objects.requireNonNull(result);\n+    }\n+\n+    private String expandFormattedString(String str) {\n+        return expandFormattedString(str, token -> {\n+            if (token.charAt(0) == '#') {\n+                var filekey = token.substring(1);\n+                var fileRow = tables.get(Table.FILE).findRow(\"File\", filekey).orElseThrow();\n+\n+                var component = fileRow.apply(\"Component_\");\n+                var componentRow = tables.get(Table.COMPONENT).findRow(\"Component\", component).orElseThrow();\n+\n+                var fileName = fileNameFromFieldValue(fileRow.apply(\"FileName\"));\n+                var filePath = directoryPath(componentRow.apply(\"Directory_\"));\n+\n+                return filePath.resolve(fileName).toString();\n+            } else {\n+                throw new UnsupportedOperationException(String.format(\n+                        \"Unrecognized token [%s] in formatted string [%s]\", token, str));\n+            }\n+        });\n+    }\n+\n+    private static Path fileNameFromFieldValue(String fieldValue) {\n+        var pipeIdx = fieldValue.indexOf('|');\n+        if (pipeIdx < 0) {\n+            return Path.of(fieldValue);\n+        } else {\n+            return Path.of(fieldValue.substring(pipeIdx + 1));\n+        }\n+    }\n+\n+    private static String expandFormattedString(String str, Function<String, String> callback) {\n+        \/\/ Naive implementation of https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/formatted\n+        \/\/  - No recursive property expansion.\n+        \/\/  - No curly brakes ({}) handling.\n+\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(callback);\n+        var sb = new StringBuffer();\n+        var m = FORMATTED_STRING_TOKEN.matcher(str);\n+        while (m.find()) {\n+            var token = m.group();\n+            token = token.substring(1, token.length() - 1);\n+            if (token.equals(\"~\")) {\n+                m.appendReplacement(sb, \"\\0\");\n+            } else {\n+                var replacement = Matcher.quoteReplacement(callback.apply(token));\n+                m.appendReplacement(sb, replacement);\n+            }\n+        }\n+        m.appendTail(sb);\n+        return sb.toString();\n+    }\n+\n+\n+    private record MsiTable(Map<String, List<String>> columns) {\n+\n+        MsiTable {\n+            Objects.requireNonNull(columns);\n+            if (columns.isEmpty()) {\n+                throw new IllegalArgumentException(\"Table should have columns\");\n+            }\n+        }\n+\n+        Optional<Function<String, String>> findRow(String columnName, String fieldValue) {\n+            Objects.requireNonNull(columnName);\n+            Objects.requireNonNull(fieldValue);\n+            var column = columns.get(columnName);\n+            for (int i = 0; i != column.size(); i++) {\n+                if (fieldValue.equals(column.get(i))) {\n+                    return Optional.of(row(i));\n+                }\n+            }\n+            return Optional.empty();\n+        }\n+\n+        \/**\n+         * Loads a table from a text archive file.\n+         * @param idtFile path to the input text archive file\n+         * @return the table\n+         *\/\n+        static MsiTable loadFromTextArchiveFile(Path idtFile) {\n+\n+            var header = IdtFileHeader.loadFromTextArchiveFile(idtFile);\n+\n+            Map<String, List<String>> columns = new HashMap<>();\n+            header.columns.forEach(column -> {\n+                columns.put(column, new ArrayList<>());\n+            });\n+\n+            try {\n+                var lines = Files.readAllLines(idtFile, header.charset()).toArray(String[]::new);\n+                for (int i = 3; i != lines.length; i++) {\n+                    var line = lines[i];\n+                    var row = line.split(\"\\t\", -1);\n+                    if (row.length != header.columns().size()) {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Expected %d columns. Actual is %d in line %d in [%s] file\",\n+                                header.columns().size(), row.length, i, idtFile));\n+                    }\n+                    for (int j = 0; j != row.length; j++) {\n+                        var field = row[j];\n+                        \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/archive-file-format\n+                        field = field.replace((char)21, (char)0);\n+                        field = field.replace((char)27, '\\b');\n+                        field = field.replace((char)16, '\\t');\n+                        field = field.replace((char)25, '\\n');\n+                        field = field.replace((char)24, '\\f');\n+                        field = field.replace((char)17, '\\r');\n+                        columns.get(header.columns.get(j)).add(field);\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+\n+            return new MsiTable(columns);\n+        }\n+\n+        int columnCount() {\n+            return columns.size();\n+        }\n+\n+        int rowCount() {\n+            return columns.values().stream().findAny().orElseThrow().size();\n+        }\n+\n+        Function<String, String> row(int rowIndex) {\n+            return columnName -> {\n+                var column = Objects.requireNonNull(columns.get(Objects.requireNonNull(columnName)));\n+                return column.get(rowIndex);\n+            };\n+        }\n+    }\n+\n+\n+    private record IdtFileHeader(Charset charset, List<String> columns) {\n+\n+        IdtFileHeader {\n+            Objects.requireNonNull(charset);\n+            columns.forEach(Objects::requireNonNull);\n+            if (columns.isEmpty()) {\n+                throw new IllegalArgumentException(\"Table should have columns\");\n+            }\n+        }\n+\n+        \/**\n+         * Loads a table header from a text archive (.idt) file.\n+         * @see <a href=\"https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/archive-file-format\">https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/archive-file-format<\/a>\n+         * @see <a href=\"https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/ascii-data-in-text-archive-files\">https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/ascii-data-in-text-archive-files<\/a>\n+         * @param path path to the input text archive file\n+         * @return the table header\n+         *\/\n+        static IdtFileHeader loadFromTextArchiveFile(Path idtFile) {\n+            var charset = StandardCharsets.US_ASCII;\n+            try (var stream = Files.lines(idtFile, charset)) {\n+                var headerLines = stream.limit(3).toList();\n+                if (headerLines.size() != 3) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"[%s] file should have at least three text lines\", idtFile));\n+                }\n+\n+                var columns = headerLines.get(0).split(\"\\t\");\n+\n+                var header = headerLines.get(2).split(\"\\t\", 4);\n+                if (header.length == 3) {\n+                    if (Pattern.matches(\"^[1-9]\\\\d+$\", header[0])) {\n+                        charset = Charset.forName(header[0]);\n+                    } else {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unexpected charset name [%s] in [%s] file\", header[0], idtFile));\n+                    }\n+                } else if (header.length != 2) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Unexpected number of fields (%d) in the 3rd line of [%s] file\",\n+                            header.length, idtFile));\n+                }\n+\n+                return new IdtFileHeader(charset, List.of(columns));\n+\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+\n+    private final Map<Table, MsiTable> tables;\n+\n+    \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/formatted\n+    private static final Pattern FORMATTED_STRING_TOKEN = Pattern.compile(\"\\\\[[^\\\\]]+\\\\]\");\n+\n+    \/\/ https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/property-reference#system-folder-properties\n+    private final Set<String> DIRECTORY_PROPERTIES = Set.of(\n+            \"DesktopFolder\",\n+            \"LocalAppDataFolder\",\n+            \"ProgramFiles64Folder\",\n+            \"ProgramMenuFolder\"\n+    );\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MsiDatabase.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import static jdk.jpackage.test.PackageType.WIN_MSI;\n@@ -38,0 +39,1 @@\n+import java.time.Duration;\n@@ -273,2 +275,1 @@\n-        \/\/ Setup test app to have valid jpackage command line before\n-        \/\/ running check of type of environment.\n+        \/\/ Setup test app to have valid jpackage command line before running the check.\n@@ -299,1 +300,1 @@\n-                TKit.waitForFileCreated(appOutput, 7);\n+                TKit.waitForFileCreated(appOutput, Duration.ofSeconds(7), Duration.ofSeconds(3));\n@@ -301,5 +302,1 @@\n-                \/\/ Wait a little bit after file has been created to\n-                \/\/ make sure there are no pending writes into it.\n-                Thread.sleep(3000);\n-                HelloApp.verifyOutputFile(appOutput, expectedArgs,\n-                        Collections.emptyMap());\n+                HelloApp.verifyOutputFile(appOutput, expectedArgs, Map.of());\n@@ -363,1 +360,1 @@\n-        addInstallVerifier(HelloApp::executeLauncherAndVerifyOutput);\n+        addInstallVerifier(LauncherVerifier::executeMainLauncherAndVerifyOutput);\n@@ -368,4 +365,3 @@\n-        addInitializer(\n-                cmd -> new HelloApp(JavaAppDesc.parse(javaAppDesc)).addTo(cmd),\n-                \"HelloApp\");\n-        return this;\n+        return addInitializer(cmd -> {\n+            new HelloApp(JavaAppDesc.parse(javaAppDesc)).addTo(cmd);\n+        }, \"HelloApp\");\n@@ -614,5 +610,1 @@\n-                    if (unpackNotSupported()) {\n-                        return ActionAction.SKIP;\n-                    }\n-\n-                    if (installFailed()) {\n+                    if (unpackNotSupported() || installFailed()) {\n@@ -756,0 +748,2 @@\n+                } else if (isOfType(cmd, WIN_MSI)) {\n+                    WinShortcutVerifier.verifyBundleShortcuts(cmd);\n@@ -777,6 +771,5 @@\n-                    \/\/ Check main launcher\n-                    WindowsHelper.verifyDesktopIntegration(cmd, null);\n-                    \/\/ Check additional launchers\n-                    cmd.addLauncherNames().forEach(name -> {\n-                        WindowsHelper.verifyDesktopIntegration(cmd, name);\n-                    });\n+                    WindowsHelper.verifyDeployedDesktopIntegration(cmd, true);\n+                }\n+\n+                if (isOfType(cmd, LINUX)) {\n+                    LinuxHelper.verifyDesktopFiles(cmd, true);\n@@ -859,6 +852,5 @@\n-                    \/\/ Check main launcher\n-                    WindowsHelper.verifyDesktopIntegration(cmd, null);\n-                    \/\/ Check additional launchers\n-                    cmd.addLauncherNames().forEach(name -> {\n-                        WindowsHelper.verifyDesktopIntegration(cmd, name);\n-                    });\n+                    WindowsHelper.verifyDeployedDesktopIntegration(cmd, false);\n+                }\n+\n+                if (isOfType(cmd, LINUX)) {\n+                    LinuxHelper.verifyDesktopFiles(cmd, false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":22,"deletions":30,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import java.time.Duration;\n+import java.time.Instant;\n@@ -600,2 +602,8 @@\n-    static void waitForFileCreated(Path fileToWaitFor,\n-            long timeoutSeconds) throws IOException {\n+    public static void waitForFileCreated(Path fileToWaitFor,\n+            Duration timeout, Duration afterCreatedTimeout) throws IOException {\n+        waitForFileCreated(fileToWaitFor, timeout);\n+        \/\/ Wait after the file has been created to ensure it is fully written.\n+        ThrowingConsumer.<Duration>toConsumer(Thread::sleep).accept(afterCreatedTimeout);\n+    }\n+\n+    private static void waitForFileCreated(Path fileToWaitFor, Duration timeout) throws IOException {\n@@ -611,1 +619,1 @@\n-        long waitUntil = System.currentTimeMillis() + timeoutSeconds * 1000;\n+        var waitUntil = Instant.now().plus(timeout);\n@@ -613,3 +621,3 @@\n-            long timeout = waitUntil - System.currentTimeMillis();\n-            assertTrue(timeout > 0, String.format(\n-                    \"Check timeout value %d is positive\", timeout));\n+            var remainderTimeout = Instant.now().until(waitUntil);\n+            assertTrue(remainderTimeout.isPositive(), String.format(\n+                    \"Check timeout value %dms is positive\", remainderTimeout.toMillis()));\n@@ -617,2 +625,3 @@\n-            WatchKey key = ThrowingSupplier.toSupplier(() -> ws.poll(timeout,\n-                    TimeUnit.MILLISECONDS)).get();\n+            WatchKey key = ThrowingSupplier.toSupplier(() -> {\n+                return ws.poll(remainderTimeout.toMillis(), TimeUnit.MILLISECONDS);\n+            }).get();\n@@ -620,1 +629,1 @@\n-                if (fileToWaitFor.toFile().exists()) {\n+                if (Files.exists(fileToWaitFor)) {\n@@ -626,1 +635,1 @@\n-                assertUnexpected(String.format(\"Timeout expired\", timeout));\n+                assertUnexpected(String.format(\"Timeout %dms expired\", remainderTimeout.toMillis()));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.test.LauncherShortcut.WIN_START_MENU_SHORTCUT;\n+import static jdk.jpackage.test.WindowsHelper.getInstallationSubDirectory;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.PathUtils;\n+import jdk.jpackage.test.LauncherShortcut.InvokeShortcutSpec;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+import jdk.jpackage.test.MsiDatabase.Shortcut;\n+import jdk.jpackage.test.WindowsHelper.SpecialFolder;\n+\n+\n+public final class WinShortcutVerifier {\n+\n+    static void verifyBundleShortcuts(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.WIN_MSI);\n+\n+        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames().isEmpty()) {\n+            return;\n+        }\n+\n+        var actualShortcuts = WindowsHelper.getMsiShortcuts(cmd).stream().collect(groupingBy(shortcut -> {\n+            return PathUtils.replaceSuffix(shortcut.target().getFileName(), \"\").toString();\n+        }));\n+\n+        var expectedShortcuts = expectShortcuts(cmd);\n+\n+        var launcherNames = expectedShortcuts.keySet().stream().sorted().toList();\n+\n+        TKit.assertStringListEquals(\n+                launcherNames,\n+                actualShortcuts.keySet().stream().sorted().toList(),\n+                \"Check the list of launchers with shortcuts\");\n+\n+        Function<Collection<Shortcut>, List<Shortcut>> sorter = shortcuts -> {\n+            return shortcuts.stream().sorted(SHORTCUT_COMPARATOR).toList();\n+        };\n+\n+        for (var name : launcherNames) {\n+            var actualLauncherShortcuts = sorter.apply(actualShortcuts.get(name));\n+            var expectedLauncherShortcuts = sorter.apply(expectedShortcuts.get(name));\n+\n+            TKit.assertEquals(expectedLauncherShortcuts.size(), actualLauncherShortcuts.size(),\n+                    String.format(\"Check the number of shortcuts of launcher [%s]\", name));\n+\n+            for (int i = 0; i != expectedLauncherShortcuts.size(); i++) {\n+                TKit.trace(String.format(\"Verify shortcut #%d of launcher [%s]\", i + 1, name));\n+                actualLauncherShortcuts.get(i).assertEquals(expectedLauncherShortcuts.get(i));\n+                TKit.trace(\"Done\");\n+            }\n+        }\n+    }\n+\n+    static void verifyDeployedShortcuts(JPackageCommand cmd, boolean installed) {\n+        cmd.verifyIsOfType(PackageType.WINDOWS);\n+\n+        verifyDeployedShortcutsInternal(cmd, installed);\n+        var copyCmd = cmd.createMutableCopy();\n+        if (copyCmd.hasArgument(\"--win-per-user-install\")) {\n+            copyCmd.removeArgument(\"--win-per-user-install\");\n+        } else {\n+            copyCmd.addArgument(\"--win-per-user-install\");\n+        }\n+        verifyDeployedShortcutsInternal(copyCmd, false);\n+    }\n+\n+    public static Collection<? extends InvokeShortcutSpec> getInvokeShortcutSpecs(JPackageCommand cmd) {\n+        return expectShortcuts(cmd).entrySet().stream().map(e -> {\n+            return e.getValue().stream().map(shortcut -> {\n+                return convert(cmd, e.getKey(), shortcut);\n+            });\n+        }).flatMap(x -> x).toList();\n+    }\n+\n+    private static void verifyDeployedShortcutsInternal(JPackageCommand cmd, boolean installed) {\n+\n+        var expectedShortcuts = expectShortcuts(cmd).values().stream().flatMap(Collection::stream).toList();\n+\n+        var isUserLocalInstall = WindowsHelper.isUserLocalInstall(cmd);\n+\n+        expectedShortcuts.stream().map(Shortcut::path).sorted().map(path -> {\n+            return resolvePath(path, !isUserLocalInstall);\n+        }).map(path -> {\n+            return PathUtils.addSuffix(path, \".lnk\");\n+        }).forEach(path -> {\n+            if (installed) {\n+                TKit.assertFileExists(path);\n+            } else {\n+                TKit.assertPathExists(path, false);\n+            }\n+        });\n+\n+        if (!installed) {\n+            expectedShortcuts.stream().map(Shortcut::path).filter(path -> {\n+                return Stream.of(ShortcutType.COMMON_START_MENU, ShortcutType.USER_START_MENU).anyMatch(type -> {\n+                    return path.startsWith(Path.of(type.rootFolder().getMsiPropertyName()));\n+                });\n+            }).map(Path::getParent).distinct().map(unresolvedShortcutDir -> {\n+                return resolvePath(unresolvedShortcutDir, !isUserLocalInstall);\n+            }).forEach(shortcutDir -> {\n+                if (Files.isDirectory(shortcutDir)) {\n+                    TKit.assertDirectoryNotEmpty(shortcutDir);\n+                } else {\n+                    TKit.assertPathExists(shortcutDir, false);\n+                }\n+            });\n+        }\n+    }\n+\n+    private enum ShortcutType {\n+        COMMON_START_MENU(SpecialFolder.COMMON_START_MENU_PROGRAMS),\n+        USER_START_MENU(SpecialFolder.USER_START_MENU_PROGRAMS),\n+        COMMON_DESKTOP(SpecialFolder.COMMON_DESKTOP),\n+        USER_DESKTOP(SpecialFolder.USER_DESKTOP),\n+        ;\n+\n+        ShortcutType(SpecialFolder rootFolder) {\n+            this.rootFolder = Objects.requireNonNull(rootFolder);\n+        }\n+\n+        SpecialFolder rootFolder() {\n+            return rootFolder;\n+        }\n+\n+        private final SpecialFolder rootFolder;\n+    }\n+\n+    private static Path resolvePath(Path path, boolean allUsers) {\n+        var root = path.getName(0);\n+        var resolvedRoot = SpecialFolder.findMsiProperty(root.toString(), allUsers).orElseThrow().getPath();\n+        return resolvedRoot.resolve(root.relativize(path));\n+    }\n+\n+    private static Shortcut createLauncherShortcutSpec(JPackageCommand cmd, String launcherName,\n+            SpecialFolder installRoot, Path workDir, ShortcutType type) {\n+\n+        var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+\n+        var appLayout = ApplicationLayout.windowsAppImage().resolveAt(\n+                Path.of(installRoot.getMsiPropertyName()).resolve(getInstallationSubDirectory(cmd)));\n+\n+        Path path;\n+        switch (type) {\n+            case COMMON_START_MENU, USER_START_MENU -> {\n+                path = Path.of(cmd.getArgumentValue(\"--win-menu-group\", () -> \"Unknown\"), name);\n+            }\n+            default -> {\n+                path = Path.of(name);\n+            }\n+        }\n+\n+        return new Shortcut(\n+                Path.of(type.rootFolder().getMsiPropertyName()).resolve(path),\n+                appLayout.launchersDirectory().resolve(name + \".exe\"),\n+                workDir);\n+    }\n+\n+    private static Collection<Shortcut> expectLauncherShortcuts(JPackageCommand cmd,\n+            Optional<AppImageFile> predefinedAppImage, String launcherName) {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(predefinedAppImage);\n+\n+        final List<Shortcut> shortcuts = new ArrayList<>();\n+\n+        final var winMenu = WIN_START_MENU_SHORTCUT.expectShortcut(cmd, predefinedAppImage, launcherName);\n+        final var desktop = WIN_DESKTOP_SHORTCUT.expectShortcut(cmd, predefinedAppImage, launcherName);\n+\n+        final var isUserLocalInstall = WindowsHelper.isUserLocalInstall(cmd);\n+\n+        final SpecialFolder installRoot;\n+        if (isUserLocalInstall) {\n+            installRoot = SpecialFolder.LOCAL_APPLICATION_DATA;\n+        } else {\n+            installRoot = SpecialFolder.PROGRAM_FILES;\n+        }\n+\n+        final var installDir = Path.of(installRoot.getMsiPropertyName()).resolve(getInstallationSubDirectory(cmd));\n+\n+        final Function<StartupDirectory, Path> workDir = startupDirectory -> {\n+            return installDir;\n+        };\n+\n+        if (winMenu.isPresent()) {\n+            ShortcutType type;\n+            if (isUserLocalInstall) {\n+                type = ShortcutType.USER_START_MENU;\n+            } else {\n+                type = ShortcutType.COMMON_START_MENU;\n+            }\n+            shortcuts.add(createLauncherShortcutSpec(cmd, launcherName, installRoot, winMenu.map(workDir).orElseThrow(), type));\n+        }\n+\n+        if (desktop.isPresent()) {\n+            ShortcutType type;\n+            if (isUserLocalInstall) {\n+                type = ShortcutType.USER_DESKTOP;\n+            } else {\n+                type = ShortcutType.COMMON_DESKTOP;\n+            }\n+            shortcuts.add(createLauncherShortcutSpec(cmd, launcherName, installRoot, desktop.map(workDir).orElseThrow(), type));\n+        }\n+\n+        return shortcuts;\n+    }\n+\n+    private static Map<String, Collection<Shortcut>> expectShortcuts(JPackageCommand cmd) {\n+        Map<String, Collection<Shortcut>> expectedShortcuts = new HashMap<>();\n+\n+        var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n+\n+        predefinedAppImage.map(v -> {\n+            return v.launchers().keySet().stream();\n+        }).orElseGet(() -> {\n+            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n+        }).forEach(launcherName -> {\n+            var shortcuts = expectLauncherShortcuts(cmd, predefinedAppImage, launcherName);\n+            if (!shortcuts.isEmpty()) {\n+                expectedShortcuts.put(launcherName, shortcuts);\n+            }\n+        });\n+\n+        return expectedShortcuts;\n+    }\n+\n+    private static InvokeShortcutSpec convert(JPackageCommand cmd, String launcherName, Shortcut shortcut) {\n+        LauncherShortcut launcherShortcut;\n+        if (Stream.of(ShortcutType.COMMON_START_MENU, ShortcutType.USER_START_MENU).anyMatch(type -> {\n+            return shortcut.path().startsWith(Path.of(type.rootFolder().getMsiPropertyName()));\n+        })) {\n+            launcherShortcut = WIN_START_MENU_SHORTCUT;\n+        } else {\n+            launcherShortcut = WIN_DESKTOP_SHORTCUT;\n+        }\n+\n+        var isUserLocalInstall = WindowsHelper.isUserLocalInstall(cmd);\n+        return new InvokeShortcutSpec.Stub(\n+                launcherName,\n+                launcherShortcut,\n+                Optional.of(resolvePath(shortcut.workDir(), !isUserLocalInstall)),\n+                List.of(\"cmd\", \"\/c\", \"start\", \"\/wait\", PathUtils.addSuffix(resolvePath(shortcut.path(), !isUserLocalInstall), \".lnk\").toString()));\n+    }\n+\n+\n+    private static final Comparator<Shortcut> SHORTCUT_COMPARATOR = Comparator.comparing(Shortcut::target)\n+            .thenComparing(Comparator.comparing(Shortcut::path))\n+            .thenComparing(Comparator.comparing(Shortcut::workDir));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -29,0 +29,2 @@\n+import java.io.UncheckedIOException;\n+import java.lang.ref.SoftReference;\n@@ -32,0 +34,3 @@\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.HashMap;\n@@ -37,0 +42,1 @@\n+import java.util.Properties;\n@@ -41,1 +47,0 @@\n-import java.util.stream.Collectors;\n@@ -66,1 +71,1 @@\n-    private static Path getInstallationSubDirectory(JPackageCommand cmd) {\n+    static Path getInstallationSubDirectory(JPackageCommand cmd) {\n@@ -266,3 +271,3 @@\n-    static void verifyDesktopIntegration(JPackageCommand cmd,\n-            String launcherName) {\n-        new DesktopIntegrationVerifier(cmd, launcherName);\n+    static void verifyDeployedDesktopIntegration(JPackageCommand cmd, boolean installed) {\n+        WinShortcutVerifier.verifyDeployedShortcuts(cmd, installed);\n+        DesktopIntegrationVerifier.verify(cmd, installed);\n@@ -273,6 +278,1 @@\n-        return Executor.of(\"cscript.exe\", \"\/\/Nologo\")\n-        .addArgument(TKit.TEST_SRC_ROOT.resolve(\"resources\/query-msi-property.js\"))\n-        .addArgument(cmd.outputBundle())\n-        .addArgument(propertyName)\n-        .dumpOutput()\n-        .executeAndGetOutput().stream().collect(Collectors.joining(\"\\n\"));\n+        return MsiDatabaseCache.INSTANCE.findProperty(cmd.outputBundle(), propertyName).orElseThrow();\n@@ -281,1 +281,6 @@\n-    public static String getExecutableDesciption(Path pathToExeFile) {\n+    static Collection<MsiDatabase.Shortcut> getMsiShortcuts(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.WIN_MSI);\n+        return MsiDatabaseCache.INSTANCE.listShortcuts(cmd.outputBundle());\n+    }\n+\n+    public static String getExecutableDescription(Path pathToExeFile) {\n@@ -389,1 +394,1 @@\n-    private static boolean isUserLocalInstall(JPackageCommand cmd) {\n+    static boolean isUserLocalInstall(JPackageCommand cmd) {\n@@ -397,0 +402,1 @@\n+\n@@ -399,1 +405,1 @@\n-        DesktopIntegrationVerifier(JPackageCommand cmd, String launcherName) {\n+        static void verify(JPackageCommand cmd, boolean installed) {\n@@ -401,90 +407,2 @@\n-\n-            name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n-\n-            isUserLocalInstall = isUserLocalInstall(cmd);\n-\n-            appInstalled = cmd.appLauncherPath(launcherName).toFile().exists();\n-\n-            desktopShortcutPath = Path.of(name + \".lnk\");\n-\n-            startMenuShortcutPath = Path.of(cmd.getArgumentValue(\n-                    \"--win-menu-group\", () -> \"Unknown\"), name + \".lnk\");\n-\n-            if (name.equals(cmd.name())) {\n-                isWinMenu = cmd.hasArgument(\"--win-menu\");\n-                isDesktop = cmd.hasArgument(\"--win-shortcut\");\n-            } else {\n-                var props = AdditionalLauncher.getAdditionalLauncherProperties(cmd,\n-                        launcherName);\n-                isWinMenu = props.getPropertyBooleanValue(\"win-menu\").orElseGet(\n-                        () -> cmd.hasArgument(\"--win-menu\"));\n-                isDesktop = props.getPropertyBooleanValue(\"win-shortcut\").orElseGet(\n-                        () -> cmd.hasArgument(\"--win-shortcut\"));\n-            }\n-\n-            verifyStartMenuShortcut();\n-\n-            verifyDesktopShortcut();\n-\n-            Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(\n-                    Path::of).forEach(this::verifyFileAssociationsRegistry);\n-        }\n-\n-        private void verifyDesktopShortcut() {\n-            if (isDesktop) {\n-                if (isUserLocalInstall) {\n-                    verifyUserLocalDesktopShortcut(appInstalled);\n-                    verifySystemDesktopShortcut(false);\n-                } else {\n-                    verifySystemDesktopShortcut(appInstalled);\n-                    verifyUserLocalDesktopShortcut(false);\n-                }\n-            } else {\n-                verifySystemDesktopShortcut(false);\n-                verifyUserLocalDesktopShortcut(false);\n-            }\n-        }\n-\n-        private void verifyShortcut(Path path, boolean exists) {\n-            if (exists) {\n-                TKit.assertFileExists(path);\n-            } else {\n-                TKit.assertPathExists(path, false);\n-            }\n-        }\n-\n-        private void verifySystemDesktopShortcut(boolean exists) {\n-            Path dir = SpecialFolder.COMMON_DESKTOP.getPath();\n-            verifyShortcut(dir.resolve(desktopShortcutPath), exists);\n-        }\n-\n-        private void verifyUserLocalDesktopShortcut(boolean exists) {\n-            Path dir = SpecialFolder.USER_DESKTOP.getPath();\n-            verifyShortcut(dir.resolve(desktopShortcutPath), exists);\n-        }\n-\n-        private void verifyStartMenuShortcut() {\n-            if (isWinMenu) {\n-                if (isUserLocalInstall) {\n-                    verifyUserLocalStartMenuShortcut(appInstalled);\n-                    verifySystemStartMenuShortcut(false);\n-                } else {\n-                    verifySystemStartMenuShortcut(appInstalled);\n-                    verifyUserLocalStartMenuShortcut(false);\n-                }\n-            } else {\n-                verifySystemStartMenuShortcut(false);\n-                verifyUserLocalStartMenuShortcut(false);\n-            }\n-        }\n-\n-        private void verifyStartMenuShortcut(Path shortcutsRoot, boolean exists) {\n-            Path shortcutPath = shortcutsRoot.resolve(startMenuShortcutPath);\n-            verifyShortcut(shortcutPath, exists);\n-            if (!exists) {\n-                final var parentDir = shortcutPath.getParent();\n-                if (Files.isDirectory(parentDir)) {\n-                    TKit.assertDirectoryNotEmpty(parentDir);\n-                } else {\n-                    TKit.assertPathExists(parentDir, false);\n-                }\n+            for (var faFile : cmd.getAllArgumentValues(\"--file-associations\")) {\n+                verifyFileAssociationsRegistry(Path.of(faFile), installed);\n@@ -494,2 +412,1 @@\n-        private void verifySystemStartMenuShortcut(boolean exists) {\n-            verifyStartMenuShortcut(SpecialFolder.COMMON_START_MENU_PROGRAMS.getPath(), exists);\n+        private static void verifyFileAssociationsRegistry(Path faFile, boolean installed) {\n@@ -497,1 +414,3 @@\n-        }\n+            TKit.trace(String.format(\n+                    \"Get file association properties from [%s] file\",\n+                    faFile));\n@@ -499,3 +418,1 @@\n-        private void verifyUserLocalStartMenuShortcut(boolean exists) {\n-            verifyStartMenuShortcut(SpecialFolder.USER_START_MENU_PROGRAMS.getPath(), exists);\n-        }\n+            var faProps = new Properties();\n@@ -503,16 +420,4 @@\n-        private void verifyFileAssociationsRegistry(Path faFile) {\n-            try {\n-                TKit.trace(String.format(\n-                        \"Get file association properties from [%s] file\",\n-                        faFile));\n-                Map<String, String> faProps = Files.readAllLines(faFile).stream().filter(\n-                        line -> line.trim().startsWith(\"extension=\") || line.trim().startsWith(\n-                        \"mime-type=\")).map(\n-                                line -> {\n-                                    String[] keyValue = line.trim().split(\"=\", 2);\n-                                    return Map.entry(keyValue[0], keyValue[1]);\n-                                }).collect(Collectors.toMap(\n-                                entry -> entry.getKey(),\n-                                entry -> entry.getValue()));\n-                String suffix = faProps.get(\"extension\");\n-                String contentType = faProps.get(\"mime-type\");\n+            try (var reader = Files.newBufferedReader(faFile)) {\n+                faProps.load(reader);\n+                String suffix = faProps.getProperty(\"extension\");\n+                String contentType = faProps.getProperty(\"mime-type\");\n@@ -525,1 +430,2 @@\n-                verifyFileAssociations(appInstalled, \".\" + suffix, contentType);\n+                verifyFileAssociations(installed, \".\" + suffix, contentType);\n+\n@@ -527,1 +433,1 @@\n-                throw new RuntimeException(ex);\n+                throw new UncheckedIOException(ex);\n@@ -531,1 +437,1 @@\n-        private void verifyFileAssociations(boolean exists, String suffix,\n+        private static void verifyFileAssociations(boolean exists, String suffix,\n@@ -552,8 +458,0 @@\n-\n-        private final Path desktopShortcutPath;\n-        private final Path startMenuShortcutPath;\n-        private final boolean isUserLocalInstall;\n-        private final boolean appInstalled;\n-        private final boolean isWinMenu;\n-        private final boolean isDesktop;\n-        private final String name;\n@@ -562,0 +460,1 @@\n+\n@@ -614,1 +513,6 @@\n-        CommonPrograms;\n+        CommonPrograms,\n+\n+        ProgramFiles,\n+\n+        LocalApplicationData,\n+        ;\n@@ -639,9 +543,30 @@\n-    private enum SpecialFolder {\n-        COMMON_START_MENU_PROGRAMS(SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Programs\", SpecialFolderDotNet.CommonPrograms),\n-        USER_START_MENU_PROGRAMS(USER_SHELL_FOLDERS_REGKEY, \"Programs\", SpecialFolderDotNet.Programs),\n-\n-        COMMON_DESKTOP(SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Desktop\", SpecialFolderDotNet.CommonDesktop),\n-        USER_DESKTOP(USER_SHELL_FOLDERS_REGKEY, \"Desktop\", SpecialFolderDotNet.Desktop);\n-\n-        SpecialFolder(String keyPath, String valueName) {\n-            reg = new RegValuePath(keyPath, valueName);\n+    enum SpecialFolder {\n+        COMMON_START_MENU_PROGRAMS(\n+                SYSTEM_SHELL_FOLDERS_REGKEY,\n+                \"Common Programs\",\n+                \"ProgramMenuFolder\",\n+                SpecialFolderDotNet.CommonPrograms),\n+        USER_START_MENU_PROGRAMS(\n+                USER_SHELL_FOLDERS_REGKEY,\n+                \"Programs\",\n+                \"ProgramMenuFolder\",\n+                SpecialFolderDotNet.Programs),\n+\n+        COMMON_DESKTOP(\n+                SYSTEM_SHELL_FOLDERS_REGKEY,\n+                \"Common Desktop\",\n+                \"DesktopFolder\",\n+                SpecialFolderDotNet.CommonDesktop),\n+        USER_DESKTOP(\n+                USER_SHELL_FOLDERS_REGKEY,\n+                \"Desktop\",\n+                \"DesktopFolder\",\n+                SpecialFolderDotNet.Desktop),\n+\n+        PROGRAM_FILES(\"ProgramFiles64Folder\", SpecialFolderDotNet.ProgramFiles),\n+\n+        LOCAL_APPLICATION_DATA(\"LocalAppDataFolder\", SpecialFolderDotNet.LocalApplicationData),\n+        ;\n+\n+        SpecialFolder(String keyPath, String valueName, String msiPropertyName) {\n+            reg = Optional.of(new RegValuePath(keyPath, valueName));\n@@ -649,0 +574,1 @@\n+            this.msiPropertyName = Objects.requireNonNull(msiPropertyName);\n@@ -651,2 +577,2 @@\n-        SpecialFolder(String keyPath, String valueName, SpecialFolderDotNet alt) {\n-            reg = new RegValuePath(keyPath, valueName);\n+        SpecialFolder(String keyPath, String valueName, String msiPropertyName, SpecialFolderDotNet alt) {\n+            reg = Optional.of(new RegValuePath(keyPath, valueName));\n@@ -654,0 +580,27 @@\n+            this.msiPropertyName = Objects.requireNonNull(msiPropertyName);\n+        }\n+\n+        SpecialFolder(String msiPropertyName, SpecialFolderDotNet alt) {\n+            reg = Optional.empty();\n+            this.alt = Optional.of(alt);\n+            this.msiPropertyName = Objects.requireNonNull(msiPropertyName);\n+        }\n+\n+        static Optional<SpecialFolder> findMsiProperty(String pathComponent, boolean allUsers) {\n+            Objects.requireNonNull(pathComponent);\n+            String regPath;\n+            if (allUsers) {\n+                regPath = SYSTEM_SHELL_FOLDERS_REGKEY;\n+            } else {\n+                regPath = USER_SHELL_FOLDERS_REGKEY;\n+            }\n+            return Stream.of(values())\n+                    .filter(v -> v.msiPropertyName.equals(pathComponent))\n+                    .filter(v -> {\n+                        return v.reg.map(r -> r.keyPath().equals(regPath)).orElse(true);\n+                    })\n+                    .findFirst();\n+        }\n+\n+        String getMsiPropertyName() {\n+            return msiPropertyName;\n@@ -657,1 +610,1 @@\n-            return CACHE.computeIfAbsent(this, k -> reg.findValue().map(Path::of).orElseGet(() -> {\n+            return CACHE.computeIfAbsent(this, k -> reg.flatMap(RegValuePath::findValue).map(Path::of).orElseGet(() -> {\n@@ -664,1 +617,1 @@\n-        private final RegValuePath reg;\n+        private final Optional<RegValuePath> reg;\n@@ -666,0 +619,2 @@\n+        \/\/ One of \"System Folder Properties\" from https:\/\/learn.microsoft.com\/en-us\/windows\/win32\/msi\/property-reference\n+        private final String msiPropertyName;\n@@ -696,0 +651,57 @@\n+\n+    private static final class MsiDatabaseCache {\n+\n+        Optional<String> findProperty(Path msiPath, String propertyName) {\n+            return ensureTables(msiPath, MsiDatabase.Table.FIND_PROPERTY_REQUIRED_TABLES).findProperty(propertyName);\n+        }\n+\n+        Collection<MsiDatabase.Shortcut> listShortcuts(Path msiPath) {\n+            return ensureTables(msiPath, MsiDatabase.Table.LIST_SHORTCUTS_REQUIRED_TABLES).listShortcuts();\n+        }\n+\n+        MsiDatabase ensureTables(Path msiPath, Set<MsiDatabase.Table> tableNames) {\n+            Objects.requireNonNull(msiPath);\n+            try {\n+                synchronized (items) {\n+                    var value = Optional.ofNullable(items.get(msiPath)).map(SoftReference::get).orElse(null);\n+                    if (value != null) {\n+                        var lastModifiedTime = Files.getLastModifiedTime(msiPath).toInstant();\n+                        if (lastModifiedTime.isAfter(value.timestamp())) {\n+                            value = null;\n+                        } else {\n+                            tableNames = Comm.compare(value.db().tableNames(), tableNames).unique2();\n+                        }\n+                    }\n+\n+                    if (!tableNames.isEmpty()) {\n+                        var idtOutputDir = TKit.createTempDirectory(\"msi-db\");\n+                        var db = MsiDatabase.load(msiPath, idtOutputDir, tableNames);\n+                        if (value != null) {\n+                            value = new MsiDatabaseWithTimestamp(db.append(value.db()), value.timestamp());\n+                        } else {\n+                            value = new MsiDatabaseWithTimestamp(db, Files.getLastModifiedTime(msiPath).toInstant());\n+                        }\n+                        items.put(msiPath, new SoftReference<>(value));\n+                    }\n+\n+                    return value.db();\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private record MsiDatabaseWithTimestamp(MsiDatabase db, Instant timestamp) {\n+\n+            MsiDatabaseWithTimestamp {\n+                Objects.requireNonNull(db);\n+                Objects.requireNonNull(timestamp);\n+            }\n+        }\n+\n+        private final Map<Path, SoftReference<MsiDatabaseWithTimestamp>> items = new HashMap<>();\n+\n+        static final MsiDatabaseCache INSTANCE = new MsiDatabaseCache();\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":163,"deletions":151,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-        createAdditionalLauncher(\"launcherB\").addRawProperties(Map.entry(\n-                \"description\", \"Foo\")).applyTo(pkg);\n+        createAdditionalLauncher(\"launcherB\").setProperty(\n+                \"description\", \"Foo\").applyTo(pkg);\n@@ -71,2 +71,2 @@\n-        createAdditionalLauncher(\"launcherB\").addRawProperties(Map.entry(\n-                \"description\", \"Bar\")).applyTo(pkg2);\n+        createAdditionalLauncher(\"launcherB\").setProperty(\n+                \"description\", \"Bar\").applyTo(pkg2);\n@@ -91,1 +91,1 @@\n-    private final static Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n+    private static final Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n","filename":"test\/jdk\/tools\/jpackage\/linux\/UpgradeTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+function readMsi(msiPath, callback) {\n+  var installer = new ActiveXObject('WindowsInstaller.Installer')\n+  var database = installer.OpenDatabase(msiPath, 0 \/* msiOpenDatabaseModeReadOnly *\/)\n+\n+  return callback(database)\n+}\n+\n+\n+function exportTables(db, outputDir, requestedTableNames) {\n+  var tables = {}\n+\n+  var view = db.OpenView(\"SELECT `Name` FROM _Tables\")\n+  view.Execute()\n+\n+  try {\n+    while (true) {\n+      var record = view.Fetch()\n+      if (!record) {\n+          break\n+      }\n+\n+      var name = record.StringData(1)\n+\n+      if (requestedTableNames.hasOwnProperty(name)) {\n+        tables[name] = name\n+      }\n+    }\n+  } finally {\n+    view.Close()\n+  }\n+\n+  var fso = new ActiveXObject(\"Scripting.FileSystemObject\")\n+  for (var table in tables) {\n+    var idtFileName = table + \".idt\"\n+    var idtFile = outputDir + \"\/\" + idtFileName\n+    if (fso.FileExists(idtFile)) {\n+      WScript.Echo(\"Delete [\" + idtFile + \"]\")\n+      fso.DeleteFile(idtFile)\n+    }\n+    WScript.Echo(\"Export table [\" + table + \"] in [\" + idtFile + \"] file\")\n+    db.Export(table, fso.GetFolder(outputDir).Path, idtFileName)\n+  }\n+}\n+\n+\n+(function () {\n+  var msi = WScript.arguments(0)\n+  var outputDir = WScript.arguments(1)\n+  var tables = {}\n+  for (var i = 0; i !== WScript.arguments.Count(); i++) {\n+    tables[WScript.arguments(i)] = true\n+  }\n+\n+  readMsi(msi, function (db) {\n+    exportTables(db, outputDir, tables)\n+  })\n+})()\n","filename":"test\/jdk\/tools\/jpackage\/resources\/msi-export.js","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-function readMsi(msiPath, callback) {\n-    var installer = new ActiveXObject('WindowsInstaller.Installer')\n-    var database = installer.OpenDatabase(msiPath, 0 \/* msiOpenDatabaseModeReadOnly *\/)\n-\n-    return callback(database)\n-}\n-\n-\n-function queryAllProperties(db) {\n-    var reply = {}\n-\n-    var view = db.OpenView(\"SELECT `Property`, `Value` FROM Property\")\n-    view.Execute()\n-\n-    try {\n-        while(true) {\n-            var record = view.Fetch()\n-            if (!record) {\n-                break\n-            }\n-\n-            var name = record.StringData(1)\n-            var value = record.StringData(2)\n-\n-            reply[name] = value\n-        }\n-    } finally {\n-        view.Close()\n-    }\n-\n-    return reply\n-}\n-\n-\n-(function () {\n-    var msi = WScript.arguments(0)\n-    var propName = WScript.arguments(1)\n-\n-    var props = readMsi(msi, queryAllProperties)\n-    WScript.Echo(props[propName])\n-})()\n","filename":"test\/jdk\/tools\/jpackage\/resources\/query-msi-property.js","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import java.io.IOException;\n@@ -26,2 +26,9 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.FileAssociations;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.internal.util.OperatingSystem;\n@@ -29,1 +36,2 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n@@ -31,0 +39,11 @@\n+import jdk.jpackage.test.FileAssociations;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.LauncherShortcut;\n+import jdk.jpackage.test.LauncherShortcut.InvokeShortcutSpec;\n+import jdk.jpackage.test.LauncherShortcut.StartupDirectory;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n+import jdk.jpackage.test.LinuxHelper;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.RunnablePackageTest;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.WinShortcutVerifier;\n@@ -47,0 +66,1 @@\n+ * @requires (jpackage.test.SQETest != null)\n@@ -50,0 +70,13 @@\n+ *  --jpt-run=AddLShortcutTest.test\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --add-launcher\n+ * @key jpackagePlatformPackage\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @requires (jpackage.test.SQETest == null)\n+ * @compile -Xlint:all -Werror AddLShortcutTest.java\n+ * @run main\/othervm\/timeout=1080 -Xmx512m\n+ *  jdk.jpackage.test.Main\n@@ -110,0 +143,281 @@\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @ParameterSupplier(ifOS = OperatingSystem.LINUX, value = \"testShortcutStartupDirectoryLinux\")\n+    @ParameterSupplier(ifOS = OperatingSystem.WINDOWS, value = \"testShortcutStartupDirectoryWindows\")\n+    public void testStartupDirectory(LauncherShortcutStartupDirectoryConfig... cfgs) {\n+\n+        var test = new PackageTest().addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDirTest\");\n+        }).addInitializer(JPackageCommand::setFakeRuntime).addHelloAppInitializer(null);\n+\n+        test.addInitializer(cfgs[0]::applyToMainLauncher);\n+        for (var i = 1; i != cfgs.length; ++i) {\n+            var al = new AdditionalLauncher(\"launcher-\" + i);\n+            cfgs[i].applyToAdditionalLauncher(al);\n+            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        }\n+\n+        test.run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @ParameterSupplier(ifOS = OperatingSystem.LINUX, value = \"testShortcutStartupDirectoryLinux\")\n+    @ParameterSupplier(ifOS = OperatingSystem.WINDOWS, value = \"testShortcutStartupDirectoryWindows\")\n+    public void testStartupDirectory2(LauncherShortcutStartupDirectoryConfig... cfgs) {\n+\n+        \/\/\n+        \/\/ Launcher shortcuts in the predefined app image.\n+        \/\/\n+        \/\/ Shortcut configuration for the main launcher is not supported when building an app image.\n+        \/\/ However, shortcut configuration for additional launchers is supported.\n+        \/\/ The test configures shortcuts for additional launchers in the app image building jpackage command\n+        \/\/ and applies shortcut configuration to the main launcher in the native packaging jpackage command.\n+        \/\/\n+\n+        Path[] predefinedAppImage = new Path[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            var cmd = JPackageCommand.helloAppImage()\n+                    .setArgumentValue(\"--name\", \"foo\")\n+                    .setFakeRuntime();\n+\n+            for (var i = 1; i != cfgs.length; ++i) {\n+                var al = new AdditionalLauncher(\"launcher-\" + i);\n+                cfgs[i].applyToAdditionalLauncher(al);\n+                al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(cmd);\n+            }\n+\n+            cmd.execute();\n+\n+            predefinedAppImage[0] = cmd.outputBundle();\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDir2Test\");\n+            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n+            cfgs[0].applyToMainLauncher(cmd);\n+        }).run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    public static Collection<Object[]> testShortcutStartupDirectoryLinux() {\n+        return testShortcutStartupDirectory(LauncherShortcut.LINUX_SHORTCUT);\n+    }\n+\n+    public static Collection<Object[]> testShortcutStartupDirectoryWindows() {\n+        return testShortcutStartupDirectory(LauncherShortcut.WIN_DESKTOP_SHORTCUT, LauncherShortcut.WIN_START_MENU_SHORTCUT);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @Parameter(value = \"DEFAULT\")\n+    public void testInvokeShortcuts(StartupDirectory startupDirectory) {\n+\n+        var testApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+\n+        var name = \"AddLShortcutRunTest\";\n+\n+        var test = new PackageTest().addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", name);\n+        }).addInitializer(cmd -> {\n+            cmd.addArguments(\"--arguments\", \"--print-workdir\");\n+        }).addInitializer(JPackageCommand::ignoreFakeRuntime).addHelloAppInitializer(testApp + \"*Hello\");\n+\n+        var shortcutStartupDirectoryVerifier = new ShortcutStartupDirectoryVerifier(name, \"a\");\n+\n+        shortcutStartupDirectoryVerifier.applyTo(test, startupDirectory);\n+\n+        test.addInstallVerifier(cmd -> {\n+            if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n+                Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n+                if (TKit.isLinux()) {\n+                    invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n+                } else if (TKit.isWindows()) {\n+                    invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n+                } else {\n+                    throw new UnsupportedOperationException();\n+                }\n+                shortcutStartupDirectoryVerifier.verify(invokeShortcutSpecs);\n+            }\n+        });\n+\n+        test.run();\n+    }\n+\n+\n+    private record ShortcutStartupDirectoryVerifier(String packageName, String launcherName) {\n+        ShortcutStartupDirectoryVerifier {\n+            Objects.requireNonNull(packageName);\n+            Objects.requireNonNull(launcherName);\n+        }\n+\n+        void applyTo(PackageTest test, StartupDirectory startupDirectory) {\n+            var al = new AdditionalLauncher(launcherName);\n+            al.setShortcut(shortcut(), Objects.requireNonNull(startupDirectory));\n+            al.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n+                    outputDirVarName(), expectedOutputFilename()));\n+            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        }\n+\n+        void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+\n+            TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName));\n+\n+            var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n+\n+            TKit.deleteIfExists(expectedOutputFile);\n+\n+            var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n+                return launcherName.equals(v.launcherName());\n+            }).findAny().orElseThrow();\n+\n+            invokeShortcutSpec.execute();\n+\n+            \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n+            \/\/ way to make it wait for exit of a process it triggers.\n+            TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+\n+            TKit.assertFileExists(expectedOutputFile);\n+            var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+\n+            var outputPrefix = \"$CD=\";\n+\n+            TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+\n+            invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n+                TKit.assertEquals(\n+                        expectedWorkDirectory,\n+                        Path.of(actualStr.substring(outputPrefix.length())),\n+                        String.format(\"Check work directory of %s of launcher [%s]\",\n+                                invokeShortcutSpec.shortcut().propertyName(),\n+                                invokeShortcutSpec.launcherName()));\n+            });\n+        }\n+\n+        private String expectedOutputFilename() {\n+            return String.format(\"%s-%s.out\", packageName, launcherName);\n+        }\n+\n+        private String outputDirVarName() {\n+            if (TKit.isLinux()) {\n+                return \"HOME\";\n+            } else if (TKit.isWindows()) {\n+                return \"LOCALAPPDATA\";\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        private LauncherShortcut shortcut() {\n+            if (TKit.isLinux()) {\n+                return LauncherShortcut.LINUX_SHORTCUT;\n+            } else if (TKit.isWindows()) {\n+                return LauncherShortcut.WIN_DESKTOP_SHORTCUT;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+\n+    private static Collection<Object[]> testShortcutStartupDirectory(LauncherShortcut... shortcuts) {\n+        List<List<LauncherShortcutStartupDirectoryConfig>> items = new ArrayList<>();\n+\n+        for (var shortcut : shortcuts) {\n+            List<LauncherShortcutStartupDirectoryConfig> mainLauncherVariants = new ArrayList<>();\n+            for (var valueSetter : StartupDirectoryValueSetter.MAIN_LAUNCHER_VALUES) {\n+                mainLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut, valueSetter));\n+            }\n+            mainLauncherVariants.stream().map(List::of).forEach(items::add);\n+            mainLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut));\n+\n+            List<LauncherShortcutStartupDirectoryConfig> addLauncherVariants = new ArrayList<>();\n+            addLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut));\n+            for (var valueSetter : StartupDirectoryValueSetter.ADD_LAUNCHER_VALUES) {\n+                addLauncherVariants.add(new LauncherShortcutStartupDirectoryConfig(shortcut, valueSetter));\n+            }\n+\n+            for (var mainLauncherVariant : mainLauncherVariants) {\n+                for (var addLauncherVariant : addLauncherVariants) {\n+                    if (mainLauncherVariant.valueSetter().isPresent() || addLauncherVariant.valueSetter().isPresent()) {\n+                        items.add(List.of(mainLauncherVariant, addLauncherVariant));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return items.stream().map(List::toArray).toList();\n+    }\n+\n+\n+    private enum StartupDirectoryValueSetter {\n+        DEFAULT(\"\"),\n+        TRUE(\"true\"),\n+        FALSE(\"false\"),\n+        ;\n+\n+        StartupDirectoryValueSetter(String value) {\n+            this.value = Objects.requireNonNull(value);\n+        }\n+\n+        void applyToMainLauncher(LauncherShortcut shortcut, JPackageCommand cmd) {\n+            switch (this) {\n+                case TRUE, FALSE -> {\n+                    throw new UnsupportedOperationException();\n+                }\n+                case DEFAULT -> {\n+                    cmd.addArgument(shortcut.optionName());\n+                }\n+                default -> {\n+                    cmd.addArguments(shortcut.optionName(), value);\n+                }\n+            }\n+        }\n+\n+        void applyToAdditionalLauncher(LauncherShortcut shortcut, AdditionalLauncher addLauncher) {\n+            addLauncher.setProperty(shortcut.propertyName(), value);\n+        }\n+\n+        private final String value;\n+\n+        static final List<StartupDirectoryValueSetter> MAIN_LAUNCHER_VALUES = List.of(\n+                StartupDirectoryValueSetter.DEFAULT\n+        );\n+\n+        static final List<StartupDirectoryValueSetter> ADD_LAUNCHER_VALUES = List.of(\n+                StartupDirectoryValueSetter.TRUE,\n+                StartupDirectoryValueSetter.FALSE\n+        );\n+    }\n+\n+\n+    record LauncherShortcutStartupDirectoryConfig(LauncherShortcut shortcut, Optional<StartupDirectoryValueSetter> valueSetter) {\n+\n+        LauncherShortcutStartupDirectoryConfig {\n+            Objects.requireNonNull(shortcut);\n+            Objects.requireNonNull(valueSetter);\n+        }\n+\n+        LauncherShortcutStartupDirectoryConfig(LauncherShortcut shortcut, StartupDirectoryValueSetter valueSetter) {\n+            this(shortcut, Optional.of(valueSetter));\n+        }\n+\n+        LauncherShortcutStartupDirectoryConfig(LauncherShortcut shortcut) {\n+            this(shortcut, Optional.empty());\n+        }\n+\n+        void applyToMainLauncher(JPackageCommand target) {\n+            valueSetter.ifPresent(valueSetter -> {\n+                valueSetter.applyToMainLauncher(shortcut, target);\n+            });\n+        }\n+\n+        void applyToAdditionalLauncher(AdditionalLauncher target) {\n+            valueSetter.ifPresent(valueSetter -> {\n+                valueSetter.applyToAdditionalLauncher(shortcut, target);\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return shortcut + \"=\" + valueSetter.map(Object::toString).orElse(\"\");\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":318,"deletions":4,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-                .addRawProperties(Map.entry(\"description\", \"Baz2 Description\"))\n+                .setProperty(\"description\", \"Baz2 Description\")\n@@ -97,1 +97,1 @@\n-                .addRawProperties(Map.entry(\"description\", \"foo Description\"))\n+                .setProperty(\"description\", \"foo Description\")\n@@ -102,1 +102,1 @@\n-                .addRawProperties(Map.entry(\"description\", \"Bar Description\"))\n+                .setProperty(\"description\", \"Bar Description\")\n@@ -197,2 +197,2 @@\n-        .addRawProperties(Map.entry(\"module\", expectedMod))\n-        .addRawProperties(Map.entry(\"main-jar\", \"\"))\n+        .setProperty(\"module\", expectedMod)\n+        .setProperty(\"main-jar\", \"\")\n@@ -207,2 +207,2 @@\n-        .addRawProperties(Map.entry(\"main-class\", nonModularAppDesc.className()))\n-        .addRawProperties(Map.entry(\"main-jar\", nonModularAppDesc.jarFileName()))\n+        .setProperty(\"main-class\", nonModularAppDesc.className())\n+        .setProperty(\"main-jar\", nonModularAppDesc.jarFileName())\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -31,1 +32,0 @@\n-import jdk.jpackage.test.PackageTest;\n@@ -33,1 +33,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -36,0 +35,1 @@\n+import jdk.jpackage.test.LauncherVerifier.Action;\n@@ -37,0 +37,1 @@\n+import jdk.jpackage.test.PackageTest;\n@@ -68,1 +69,1 @@\n-        new PackageTest().configureHelloApp().addInstallVerifier(cmd -> {\n+        new PackageTest().addHelloAppInitializer(null).addInstallVerifier(cmd -> {\n@@ -147,4 +148,1 @@\n-        new AdditionalLauncher(name) {\n-            @Override\n-            protected void verify(JPackageCommand cmd) {}\n-        }.setDefaultArguments(name).applyTo(cmd);\n+        new AdditionalLauncher(name).setDefaultArguments(name).withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(cmd);\n","filename":"test\/jdk\/tools\/jpackage\/share\/PerUserCfgTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"}]}