{"files":[{"patch":"@@ -321,1 +321,1 @@\n-  address call = __ trampoline_call(resolve);\n+  address call = __ patchable_far_call(resolve);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1348,1 +1348,1 @@\n-  address call = __ trampoline_call(Address(op->addr(), rtype));\n+  address call = __ patchable_far_call(Address(op->addr(), rtype));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-                      (NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size),\n+                      (NativeInstruction::instruction_size + NativeShortCall::trampoline_size),\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1043,1 +1043,1 @@\n-  address call = trampoline_call(stub);\n+  address call = patchable_far_call(stub);\n@@ -1481,1 +1481,1 @@\n-  address call = trampoline_call(stub);\n+  address call = patchable_far_call(stub);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  assert(UseTrampolines, \"We are not using trampolines\");\n@@ -57,1 +58,1 @@\n-    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_patchable_far_call_stub_size(), \"pre-allocated trampolines\");\n@@ -63,1 +64,1 @@\n-    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    address reloc_pc = cb->stubs()->end() - NativeShortCall::trampoline_size;\n@@ -73,1 +74,1 @@\n-  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  const int total_requested_size = MacroAssembler::max_patchable_far_call_stub_size() * requests->number_of_entries();\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static constexpr bool supports_shared_stubs() { return true; }\n+  static bool supports_shared_stubs() { return UseTrampolines; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  return MacroAssembler::max_trampoline_stub_size();\n+  return MacroAssembler::max_patchable_far_call_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,3 @@\n-          \"Use RVV instructions for left\/right shift of BigInteger\")\n+          \"Use RVV instructions for left\/right shift of BigInteger\")             \\\n+  product(bool, UseTrampolines, false, EXPERIMENTAL,                             \\\n+          \"Far calls uses jal to trampoline.\")\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -850,0 +850,11 @@\n+void MacroAssembler::load_link(const address source, Register temp) {\n+  assert(temp != noreg && temp != x0, \"expecting a register\");\n+  assert(temp == x5, \"expecting a register\");\n+  assert_cond(source != nullptr);\n+  int64_t distance = source - pc();\n+  assert(is_simm32(distance), \"Must be\");\n+  Assembler::auipc(temp, (int32_t)distance + 0x800);\n+  Assembler::_ld(temp, temp, ((int32_t)distance << 20) >> 20);\n+  Assembler::jalr(x1, temp, 0);\n+}\n+\n@@ -3587,1 +3598,1 @@\n-address MacroAssembler::trampoline_call(Address entry) {\n+address MacroAssembler::patchable_far_call(Address entry) {\n@@ -3595,1 +3606,0 @@\n-  \/\/ We need a trampoline if branches are far.\n@@ -3597,1 +3607,1 @@\n-    if (entry.rspec().type() == relocInfo::runtime_call_type) {\n+    if (entry.rspec().type() == relocInfo::runtime_call_type && UseTrampolines) {\n@@ -3601,1 +3611,7 @@\n-      address stub = emit_trampoline_stub(offset(), target);\n+      address stub = nullptr;\n+      if (UseTrampolines) {\n+        \/\/ We need a trampoline if branches are far.\n+        stub = emit_trampoline_stub(offset(), target);\n+      } else {\n+        stub = emit_address_stub(offset(), target);\n+      }\n@@ -3617,1 +3633,5 @@\n-    jump_link(target, t0);\n+    if (UseTrampolines) {\n+      jump_link(target, t0);\n+    } else {\n+      load_link(target, t0);\n+    }\n@@ -3629,1 +3649,1 @@\n-  return trampoline_call(Address(entry, rh));\n+  return patchable_far_call(Address(entry, rh));\n@@ -3674,0 +3694,28 @@\n+address MacroAssembler::emit_address_stub(int insts_call_instruction_offset, address dest) {\n+  address stub = start_a_stub(max_patchable_far_call_stub_size());\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n+  }\n+\n+  \/\/ We are always 4-byte aligned here.\n+  assert_alignment(pc());\n+\n+  \/\/ Make sure the address of destination 8-byte aligned.\n+  align(wordSize, 0);\n+\n+  RelocationHolder rh = trampoline_stub_Relocation::spec(code()->insts()->start() +\n+                                                         insts_call_instruction_offset);\n+  const int stub_start_offset = offset();\n+  relocate(rh, [&] {\n+    assert(offset() - stub_start_offset == 0,\n+           \"%ld - %ld == %ld : should be\", (long)offset(), (long)stub_start_offset, (long)0);\n+    assert(offset() % wordSize == 0, \"bad alignment\");\n+    emit_int64((int64_t)dest);\n+  });\n+\n+  const address stub_start_addr = addr_at(stub_start_offset);\n+  end_a_stub();\n+\n+  return stub_start_addr;\n+}\n+\n@@ -3688,1 +3736,1 @@\n-  address stub = start_a_stub(max_trampoline_stub_size());\n+  address stub = start_a_stub(max_patchable_far_call_stub_size());\n@@ -3693,0 +3741,2 @@\n+  assert(UseTrampolines, \"Must be using trampos.\");\n+\n@@ -3701,1 +3751,1 @@\n-  align(wordSize, NativeCallTrampolineStub::data_offset);\n+  align(wordSize, NativeShortCall::trampoline_data_offset);\n@@ -3714,1 +3764,1 @@\n-    assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,\n+    assert(offset() - stub_start_offset == NativeShortCall::trampoline_data_offset,\n@@ -3722,2 +3772,0 @@\n-  assert(is_NativeCallTrampolineStub_at(stub_start_addr), \"doesn't look like a trampoline\");\n-\n@@ -3725,0 +3773,1 @@\n+\n@@ -3728,1 +3777,1 @@\n-int MacroAssembler::max_trampoline_stub_size() {\n+int MacroAssembler::max_patchable_far_call_stub_size() {\n@@ -3730,1 +3779,4 @@\n-  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+  if (UseTrampolines) {\n+    return NativeInstruction::instruction_size + NativeShortCall::trampoline_size;\n+  }\n+  return 2 * wordSize;\n@@ -4449,1 +4501,1 @@\n-      address tpc = trampoline_call(zero_blocks);\n+      address tpc = patchable_far_call(zero_blocks);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":66,"deletions":14,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -439,0 +439,1 @@\n+  address emit_address_stub(int insts_call_instruction_offset, address target);\n@@ -440,1 +441,2 @@\n-  static int max_trampoline_stub_size();\n+  static int max_patchable_far_call_stub_size();\n+\n@@ -596,0 +598,1 @@\n+  void load_link(const address source, Register temp);\n@@ -1178,0 +1181,21 @@\n+  \/\/   - indirect call: movptr + jalr\n+  \/\/     This too can reach anywhere in the address space, but it cannot be\n+  \/\/     patched while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses, which\n+  \/\/     will never be patched.\n+  \/\/\n+  \/\/   - patchable far call:\n+  \/\/     This is only available in C1\/C2-generated code (nmethod).\n+  \/\/\n+  \/\/     [Main code section]\n+  \/\/       auipc\n+  \/\/       ld <address_from_stub_section>\n+  \/\/       jalr\n+  \/\/     [Stub section]\n+  \/\/     trampoline:\n+  \/\/       <64-bit destination address>\n+  \/\/\n+  \/\/    To change the destination we simply atomically store the new\n+  \/\/    address in the stub section.\n+  \/\/\n+  \/\/ Old patchable far calls: (-XX:+UseTrampolines)\n@@ -1197,1 +1221,1 @@\n-\n+  \/\/\n@@ -1202,7 +1226,0 @@\n-  \/\/   - indirect call: movptr + jalr\n-  \/\/     This too can reach anywhere in the address space, but it cannot be\n-  \/\/     patched while code is running, so it must only be modified at a safepoint.\n-  \/\/     This form of call is most suitable for targets at fixed addresses, which\n-  \/\/     will never be patched.\n-  \/\/\n-  \/\/\n@@ -1221,0 +1238,1 @@\n+  \/\/ --\n@@ -1223,1 +1241,1 @@\n-  \/\/ otherwise a trampoline call.\n+  \/\/ otherwise a patachable far call.\n@@ -1231,1 +1249,1 @@\n-  address trampoline_call(Address entry);\n+  address patchable_far_call(Address entry);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeInstruction\n@@ -87,0 +89,4 @@\n+bool NativeInstruction::is_call_at(address addr) {\n+  return NativeCall::is_at(addr);\n+}\n+\n@@ -134,3 +140,2 @@\n-void NativeCall::verify() {\n-  assert(NativeCall::is_call_at((address)this), \"unexpected code at call site\");\n-}\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCall\n@@ -138,2 +143,2 @@\n-address NativeCall::destination() const {\n-  address addr = (address)this;\n+address NativeShortCall::destination() const {\n+  address addr = addr_at(0);\n@@ -141,0 +146,1 @@\n+\n@@ -147,1 +153,1 @@\n-  if (nm != nullptr && nm->stub_contains(destination) && is_NativeCallTrampolineStub_at(destination)) {\n+  if (nm != nullptr && nm->stub_contains(destination) && NativeShortCallTrampolineStub::is_at(destination)) {\n@@ -150,1 +156,1 @@\n-    destination = nativeCallTrampolineStub_at(trampoline_stub_addr)->destination();\n+    destination = NativeShortCallTrampolineStub::at(trampoline_stub_addr)->destination();\n@@ -156,3 +162,49 @@\n-\/\/ Similar to replace_mt_safe, but just changes the destination. The\n-\/\/ important thing is that free-running threads are able to execute this\n-\/\/ call instruction at all times.\n+address NativeShortCall::reloc_destination(address orig_address) {\n+  address addr = addr_at(0);\n+  if (NativeShortCall::is_at(addr)) {\n+    NativeShortCall* call = NativeShortCall::at(addr);\n+    if (call->has_trampoline()) {\n+      return call->trampoline_destination();\n+    }\n+  }\n+  if (orig_address != nullptr) {\n+    \/\/ the extracted address from the instructions in address orig_addr\n+    address new_addr = MacroAssembler::pd_call_destination(orig_address);\n+    \/\/ If call is branch to self, don't try to relocate it, just leave it\n+    \/\/ as branch to self. This happens during code generation if the code\n+    \/\/ buffer expands. It will be relocated to the trampoline above once\n+    \/\/ code generation is complete.\n+    new_addr = (new_addr == orig_address) ? addr : new_addr;\n+    return new_addr;\n+  }\n+  return MacroAssembler::pd_call_destination(addr);\n+}\n+\n+void NativeShortCall::set_destination(address dest) {\n+  assert(NativeShortCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+  assert(is_jal(), \"Should be jal instruction!\");\n+  intptr_t offset = (intptr_t)(dest - instruction_address());\n+  assert((offset & 0x1) == 0, \"bad alignment\");\n+  assert(Assembler::is_simm21(offset), \"encoding constraint\");\n+  unsigned int insn = 0b1101111; \/\/ jal\n+  address pInsn = (address)(&insn);\n+  Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n+  Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n+  Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n+  Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n+  Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n+  set_int_at(0, insn);\n+}\n+\n+void NativeShortCall::verify() {\n+  assert(NativeShortCall::is_at(addr_at(0)),\n+         \"unexpected code at call site: %p\", addr_at(0));\n+}\n+\n+void NativeShortCall::print() {\n+  assert(NativeShortCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+  tty->print_cr(PTR_FORMAT \": jal\/auipc,ld,jalr x1, offset\/reg\", p2i(instruction_address()));\n+}\n+\n+\/\/ The important thing is that threads are able to execute this\n+\/\/ call instruction at all times. (cmodx)\n@@ -164,1 +216,1 @@\n-void NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+bool NativeShortCall::set_destination_mt_safe(address dest, bool assert_lock) {\n@@ -170,2 +222,2 @@\n-  address addr_call = addr_at(0);\n-  assert(NativeCall::is_call_at(addr_call), \"unexpected code at call site\");\n+  address call_addr = addr_at(0);\n+  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n@@ -176,2 +228,2 @@\n-    assert (!is_NativeCallTrampolineStub_at(dest), \"chained trampolines\");\n-    nativeCallTrampolineStub_at(trampoline_stub_addr)->set_destination(dest);\n+    assert (!NativeShortCallTrampolineStub::is_at(dest), \"chained trampolines\");\n+    NativeShortCallTrampolineStub::at(trampoline_stub_addr)->set_destination(dest);\n@@ -181,1 +233,1 @@\n-  if (Assembler::reachable_from_branch_at(addr_call, dest)) {\n+  if (Assembler::reachable_from_branch_at(call_addr, dest)) {\n@@ -188,1 +240,2 @@\n-  ICache::invalidate_range(addr_call, instruction_size);\n+  ICache::invalidate_range(call_addr, instruction_size);\n+  return true;\n@@ -191,1 +244,23 @@\n-address NativeCall::get_trampoline() {\n+bool NativeShortCall::reloc_set_destination(address dest) {\n+  address call_addr = addr_at(0);\n+  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  \/\/ Patch the constant in the call's trampoline stub.\n+  address trampoline_stub_addr = get_trampoline();\n+  if (trampoline_stub_addr != nullptr) {\n+    assert(!NativeShortCallTrampolineStub::is_at(dest), \"chained trampolines\");\n+    NativeShortCallTrampolineStub::at(trampoline_stub_addr)->set_destination(dest);\n+  }\n+\n+  \/\/ Patch the call.\n+  if (Assembler::reachable_from_branch_at(call_addr, dest)) {\n+    set_destination(dest);\n+  } else {\n+    assert (trampoline_stub_addr != nullptr, \"we need a trampoline\");\n+    set_destination(trampoline_stub_addr);\n+  }\n+\n+  return true;\n+}\n+\n+address NativeShortCall::get_trampoline() {\n@@ -198,1 +273,1 @@\n-  if (code != nullptr && code->contains(jal_destination) && is_NativeCallTrampolineStub_at(jal_destination)) {\n+  if (code != nullptr && code->contains(jal_destination) && NativeShortCallTrampolineStub::is_at(jal_destination)) {\n@@ -203,1 +278,2 @@\n-    return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+    address ret = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+    return ret;\n@@ -209,2 +285,338 @@\n-\/\/ Inserts a native call instruction at a given pc\n-void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }\n+bool NativeShortCall::has_trampoline() {\n+  return NativeShortCall::get_trampoline() != nullptr;\n+}\n+\n+address NativeShortCall::trampoline_destination() {\n+  return NativeShortCallTrampolineStub::at(get_trampoline())->destination();\n+}\n+\n+NativeShortCall* NativeShortCall::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n+  NativeShortCall* call = (NativeShortCall*)(addr);\n+  return call;\n+}\n+\n+bool NativeShortCall::is_at(address addr) {\n+  if (is_jal_at(addr)) {\n+    if (NativeInstruction::extract_rd(addr)  == x1) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool NativeShortCall::is_call_before(address return_address) {\n+  return NativeShortCall::is_at(return_address - Assembler::instruction_size);\n+}\n+\n+void NativeShortCall::insert(address code_pos, address entry) {\n+  Unimplemented();\n+}\n+\n+void NativeShortCall::replace_mt_safe(address instr_addr, address code_buffer) {\n+  Unimplemented();\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCallTrampoline\n+\n+address NativeShortCallTrampolineStub::destination(nmethod *nm) const {\n+  return ptr_at(NativeShortCall::trampoline_data_offset);\n+}\n+\n+void NativeShortCallTrampolineStub::set_destination(address new_destination) {\n+  set_ptr_at(NativeShortCall::trampoline_data_offset, new_destination);\n+  OrderAccess::release();\n+}\n+\n+bool NativeShortCallTrampolineStub::is_at(address addr) {\n+  \/\/ Ensure that the stub is exactly\n+  \/\/      ld   t0, L--->auipc + ld\n+  \/\/      jr   t0\n+  \/\/ L:\n+\n+  \/\/ judge inst + register + imm\n+  \/\/ 1). check the instructions: auipc + ld + jalr\n+  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n+  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (NativeInstruction::is_auipc_at(addr) &&\n+      NativeInstruction::is_ld_at(addr + instr_size) &&\n+      NativeInstruction::is_jalr_at(addr + 2 * instr_size) &&\n+      (NativeInstruction::extract_rd(addr)                    == x5) &&\n+      (NativeInstruction::extract_rd(addr + instr_size)       == x5) &&\n+      (NativeInstruction::extract_rs1(addr + instr_size)      == x5) &&\n+      (NativeInstruction::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == NativeShortCall::trampoline_data_offset)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+NativeShortCallTrampolineStub* NativeShortCallTrampolineStub::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCallTrampolineStub::is_at(addr), \"no call trampoline found\");\n+  return (NativeShortCallTrampolineStub*)addr;\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeFarCall\n+\n+address NativeFarCall::destination() const {\n+  address addr = addr_at(0);\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site\");\n+\n+  address destination = MacroAssembler::target_addr_for_insn(addr);\n+\n+  CodeBlob* cb = CodeCache::find_blob(addr);\n+  assert(cb && cb->is_nmethod(), \"sanity\");\n+  nmethod *nm = (nmethod *)cb;\n+  assert(nm != nullptr, \"Sanity\");\n+  assert(nm->stub_contains(destination), \"Sanity\");\n+  assert(destination != nullptr, \"Sanity\");\n+  return stub_address_destination_at(destination);\n+}\n+\n+address NativeFarCall::reloc_destination(address orig_address) {\n+  address call_addr = addr_at(0);\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+  address stub_addr = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+\n+  if (stub_addr != nullptr) {\n+    stub_addr = MacroAssembler::target_addr_for_insn(call_addr);\n+  }\n+  return stub_addr;\n+}\n+\n+void NativeFarCall::set_destination(address dest) {\n+  address addr = addr_at(0);\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site\");\n+  Unimplemented();\n+}\n+\n+void NativeFarCall::verify() {\n+  assert(NativeFarCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+}\n+\n+void NativeFarCall::print() {\n+  assert(NativeFarCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+  tty->print_cr(PTR_FORMAT \": auipc,ld,jalr x1, offset\/reg, \", p2i(addr_at(0)));\n+}\n+\n+bool NativeFarCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+  assert(NativeFarCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+  assert(!assert_lock ||\n+         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+         CompiledICLocker::is_safe(addr_at(0)),\n+         \"concurrent code patching\");\n+\n+  address call_addr = addr_at(0);\n+  assert(NativeFarCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  address stub_addr = stub_address();\n+\n+  if (stub_addr != nullptr) {\n+    set_stub_address_destination_at(stub_addr, dest);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool NativeFarCall::reloc_set_destination(address dest) {\n+  address call_addr = addr_at(0);\n+  assert(NativeFarCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+  address stub_addr = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+\n+  if (stub_addr != nullptr) {\n+    MacroAssembler::pd_patch_instruction_size(call_addr, stub_addr);\n+  }\n+\n+  return true;\n+}\n+\n+void NativeFarCall::set_stub_address_destination_at(address dest, address value) {\n+  assert_cond(dest != nullptr);\n+  assert_cond(value != nullptr);\n+\n+  set_data64_at(dest, (uint64_t)value);\n+  OrderAccess::release();\n+}\n+\n+address NativeFarCall::stub_address_destination_at(address src) {\n+  assert_cond(src != nullptr);\n+  address dest = (address)get_data64_at(src);\n+  return dest;\n+}\n+\n+address NativeFarCall::stub_address() {\n+  address call_addr = addr_at(0);\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address dest = MacroAssembler::pd_call_destination(call_addr);\n+  assert(code->contains(dest), \"Sanity\");\n+  return dest;\n+\n+}\n+\n+bool NativeFarCall::has_address_stub() {\n+  return stub_address() != nullptr;\n+}\n+\n+address NativeFarCall::stub_address_destination() {\n+  return stub_address_destination_at(stub_address());\n+}\n+\n+NativeFarCall* NativeFarCall::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n+  NativeFarCall* call = (NativeFarCall*)(addr);\n+  return call;\n+}\n+\n+bool NativeFarCall::is_at(address addr) {\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (NativeInstruction::is_auipc_at(addr) &&\n+      NativeInstruction::is_ld_at(addr + instr_size) &&\n+      NativeInstruction::is_jalr_at(addr + 2 * instr_size) &&\n+      (NativeInstruction::extract_rd(addr)                    == x5) &&\n+      (NativeInstruction::extract_rd(addr + instr_size)       == x5) &&\n+      (NativeInstruction::extract_rs1(addr + instr_size)      == x5) &&\n+      (NativeInstruction::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (NativeInstruction::extract_rd(addr + 2 * instr_size)  == x1)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool NativeFarCall::is_call_before(address return_address) {\n+  return NativeFarCall::is_at(return_address - return_address_offset);\n+}\n+\n+void NativeFarCall::insert(address code_pos, address entry) {\n+  Unimplemented();\n+}\n+\n+void NativeFarCall::replace_mt_safe(address instr_addr, address code_buffer) {\n+  assert(NativeFarCall::is_at((address)instr_addr), \"unexpected code at call site\");\n+  Unimplemented();\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeCall\n+\n+address NativeCall::instruction_address() const {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->instruction_address();\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->instruction_address();\n+  }\n+}\n+\n+address NativeCall::next_instruction_address() const {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->next_instruction_address();\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->next_instruction_address();\n+  }\n+}\n+\n+address NativeCall::return_address() const {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->return_address();\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->return_address();\n+  }\n+}\n+\n+address NativeCall::destination() const {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->destination();\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->destination();\n+  }\n+}\n+\n+address NativeCall::reloc_destination(address orig_address) {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->reloc_destination(orig_address);\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->reloc_destination(orig_address);\n+  }\n+}\n+\n+void NativeCall::set_destination(address dest) {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    NativeFarCall::at(addr_at(0))->set_destination(dest);\n+  } else {\n+    NativeShortCall::at(addr_at(0))->set_destination(dest);\n+  }\n+}\n+\n+void NativeCall::verify() {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    NativeFarCall::at(addr_at(0))->verify();;\n+  } else {\n+    NativeShortCall::at(addr_at(0))->verify();\n+  }\n+}\n+\n+void NativeCall::print() {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    NativeFarCall::at(addr_at(0))->print();;\n+  } else {\n+    NativeShortCall::at(addr_at(0))->print();\n+  }\n+}\n+\n+bool NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n+  }\n+}\n+\n+bool NativeCall::reloc_set_destination(address dest) {\n+  if (!UseTrampolines && NativeFarCall::is_at(addr_at(0))) {\n+    return NativeFarCall::at(addr_at(0))->reloc_set_destination(dest);\n+  } else {\n+    return NativeShortCall::at(addr_at(0))->reloc_set_destination(dest);\n+  }\n+}\n+\n+\n+bool NativeCall::is_call_before(address return_address) {\n+  if (!UseTrampolines) {\n+    return NativeFarCall::is_call_before(return_address) ||\n+           NativeShortCall::is_call_before(return_address);\n+  } else {\n+    return NativeShortCall::is_call_before(return_address);\n+  }\n+}\n+\n+void NativeCall::insert(address code_pos, address entry) {\n+  if (!UseTrampolines && NativeFarCall::is_at(code_pos)) {\n+    NativeFarCall::insert(code_pos, entry);\n+  } else {\n+    NativeShortCall::insert(code_pos, entry);\n+  }\n+}\n+\n+void NativeCall::replace_mt_safe(address instr_addr, address code_buffer) {\n+  if (!UseTrampolines && NativeFarCall::is_at(instr_addr)) {\n+    NativeFarCall::replace_mt_safe(instr_addr, code_buffer);\n+  } else {\n+    NativeShortCall::replace_mt_safe(instr_addr, code_buffer);\n+  }\n+}\n@@ -344,1 +756,1 @@\n-  return is_lwu_to_zr(address(this));\n+  return is_lwu_to_zr(addr_at(0));\n@@ -427,11 +839,0 @@\n-\/\/-------------------------------------------------------------------\n-\n-address NativeCallTrampolineStub::destination(nmethod *nm) const {\n-  return ptr_at(data_offset);\n-}\n-\n-void NativeCallTrampolineStub::set_destination(address new_destination) {\n-  set_ptr_at(data_offset, new_destination);\n-  OrderAccess::release();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":435,"deletions":34,"binary":false,"changes":469,"status":"modified"},{"patch":"@@ -239,7 +239,1 @@\n-\n-  static bool is_call_at(address instr) {\n-    if (is_jal_at(instr) || is_jalr_at(instr)) {\n-      return true;\n-    }\n-    return false;\n-  }\n+  static bool is_call_at(address addr);\n@@ -247,1 +241,0 @@\n-\n@@ -255,6 +248,5 @@\n-  address addr_at(int offset) const    { return address(this) + offset; }\n-\n-  jint int_at(int offset) const        { return (jint)Bytes::get_native_u4(addr_at(offset)); }\n-  juint uint_at(int offset) const      { return Bytes::get_native_u4(addr_at(offset)); }\n-\n-  address ptr_at(int offset) const     { return (address)Bytes::get_native_u8(addr_at(offset)); }\n+  address addr_at(int offset) const { return address(this) + offset; }\n+  jint     int_at(int offset) const { return (jint)      Bytes::get_native_u4(addr_at(offset));  }\n+  juint   uint_at(int offset) const { return             Bytes::get_native_u4(addr_at(offset));  }\n+  address  ptr_at(int offset) const { return (address)   Bytes::get_native_u8(addr_at(offset));  }\n+  oop      oop_at(int offset) const { return cast_to_oop(Bytes::get_native_u8(addr_at(offset))); }\n@@ -262,1 +254,0 @@\n-  oop  oop_at (int offset) const       { return cast_to_oop(Bytes::get_native_u8(addr_at(offset))); }\n@@ -264,0 +255,4 @@\n+  void  set_int_at(int offset, jint i)      { Bytes::put_native_u4(addr_at(offset), i); }\n+  void set_uint_at(int offset, jint i)      { Bytes::put_native_u4(addr_at(offset), i); }\n+  void  set_ptr_at(int offset, address ptr) { Bytes::put_native_u8(addr_at(offset), (u8)ptr); }\n+  void  set_oop_at(int offset, oop o)       { Bytes::put_native_u8(addr_at(offset), cast_from_oop<u8>(o)); }\n@@ -265,4 +260,2 @@\n-  void set_int_at(int offset, jint i)        { Bytes::put_native_u4(addr_at(offset), i); }\n-  void set_uint_at(int offset, jint i)       { Bytes::put_native_u4(addr_at(offset), i); }\n-  void set_ptr_at (int offset, address ptr)  { Bytes::put_native_u8(addr_at(offset), (u8)ptr); }\n-  void set_oop_at (int offset, oop o)        { Bytes::put_native_u8(addr_at(offset), cast_from_oop<u8>(o)); }\n+  static void     set_data64_at(address dest, uint64_t data) { Bytes::put_native_u8(dest, (u8)data); }\n+  static uint64_t get_data64_at(address src)                 { return Bytes::get_native_u8(src); }\n@@ -283,1 +276,1 @@\n-inline NativeInstruction* nativeInstruction_at(address addr) {\n+NativeInstruction* nativeInstruction_at(address addr) {\n@@ -287,9 +280,2 @@\n-\/\/ The natural type of an RISCV instruction is uint32_t\n-inline NativeInstruction* nativeInstruction_at(uint32_t *addr) {\n-  return (NativeInstruction*)addr;\n-}\n-\n-inline NativeCall* nativeCall_at(address addr);\n-\/\/ The NativeCall is an abstraction for accessing\/manipulating native\n-\/\/ call instructions (used to manipulate inline caches, primitive &\n-\/\/ DSO calls, etc.).\n+NativeCall* nativeCall_at(address addr);\n+NativeCall* nativeCall_before(address return_address);\n@@ -297,1 +283,1 @@\n-class NativeCall: public NativeInstruction {\n+class NativeShortCall: private NativeInstruction {\n@@ -300,4 +286,2 @@\n-    instruction_size            =    4,\n-    instruction_offset          =    0,\n-    displacement_offset         =    0,\n-    return_address_offset       =    4\n+    trampoline_size        = 3 * NativeInstruction::instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n+    trampoline_data_offset = 3 * NativeInstruction::instruction_size             \/\/ auipc + ld + jr\n@@ -306,4 +290,3 @@\n-  address instruction_address() const       { return addr_at(instruction_offset); }\n-  address next_instruction_address() const  { return addr_at(return_address_offset); }\n-  address return_address() const            { return addr_at(return_address_offset); }\n-  address destination() const;\n+  \/\/ Creation\n+  inline friend NativeCall* nativeCall_at(address addr);\n+  inline friend NativeCall* nativeCall_before(address return_address);\n@@ -311,14 +294,5 @@\n-  void set_destination(address dest) {\n-    assert(is_jal(), \"Should be jal instruction!\");\n-    intptr_t offset = (intptr_t)(dest - instruction_address());\n-    assert((offset & 0x1) == 0, \"bad alignment\");\n-    assert(Assembler::is_simm21(offset), \"encoding constraint\");\n-    unsigned int insn = 0b1101111; \/\/ jal\n-    address pInsn = (address)(&insn);\n-    Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n-    Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n-    Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n-    Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n-    Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n-    set_int_at(displacement_offset, insn);\n-  }\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(NativeInstruction::instruction_size); }\n+  address return_address() const            { return addr_at(NativeInstruction::instruction_size); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n@@ -326,0 +300,1 @@\n+  void set_destination(address dest);\n@@ -330,0 +305,30 @@\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address get_trampoline();\n+  bool has_trampoline();\n+  address trampoline_destination();\n+ public:\n+\n+  static NativeShortCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+  static void insert(address code_pos, address entry);\n+  static void replace_mt_safe(address instr_addr, address code_buffer);\n+};\n+\n+class NativeShortCallTrampolineStub : public NativeInstruction {\n+ private:\n+  friend NativeShortCall;\n+\n+  address destination(nmethod *nm = nullptr) const;\n+  void set_destination(address new_destination);\n+  ptrdiff_t destination_offset() const;\n+\n+  static bool is_at(address addr);\n+  static NativeShortCallTrampolineStub* at(address addr);\n+};\n+\n+class NativeFarCall: public NativeInstruction {\n+ public:\n@@ -334,3 +339,4 @@\n-  static bool is_call_before(address return_address) {\n-    return is_call_at(return_address - NativeCall::return_address_offset);\n-  }\n+  enum RISCV_specific_constants {\n+    instruction_size            =    3 * NativeInstruction::instruction_size, \/\/ ld auipc jalr\n+    return_address_offset       =    3 * NativeInstruction::instruction_size, \/\/ ld auipc jalr\n+  };\n@@ -338,2 +344,13 @@\n-  \/\/ MT-safe patching of a call instruction.\n-  static void insert(address code_pos, address entry);\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(return_address_offset); }\n+  address return_address() const            { return addr_at(return_address_offset); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify_alignment() {} \/\/ do nothing on riscv\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n@@ -341,0 +358,13 @@\n+ private:\n+  address stub_address();\n+  address stub_address_destination();\n+  bool has_address_stub();\n+\n+  static void set_stub_address_destination_at(address dest, address value);\n+  static address stub_address_destination_at(address src);\n+ public:\n+\n+  static NativeFarCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+  static void insert(address code_pos, address entry);\n@@ -342,0 +372,1 @@\n+};\n@@ -343,5 +374,8 @@\n-  \/\/ Similar to replace_mt_safe, but just changes the destination.  The\n-  \/\/ important thing is that free-running threads are able to execute\n-  \/\/ this call instruction at all times.  If the call is an immediate BL\n-  \/\/ instruction we can simply rely on atomicity of 32-bit writes to\n-  \/\/ make sure other threads will see no intermediate states.\n+\/\/ The NativeCall is an abstraction for accessing\/manipulating native\n+\/\/ call instructions (used to manipulate inline caches, primitive &\n+\/\/ DSO calls, etc.).\n+class NativeCall: private NativeInstruction {\n+ public:\n+  enum {\n+    instruction_size = 3 * Assembler::instruction_size,\n+  };\n@@ -349,5 +383,3 @@\n-  \/\/ We cannot rely on locks here, since the free-running threads must run at\n-  \/\/ full speed.\n-  \/\/\n-  \/\/ Used in the runtime linkage of calls; see class CompiledIC.\n-  \/\/ (Cf. 4506997 and 4479829, where threads witnessed garbage displacements.)\n+  \/\/ Creation\n+  inline friend NativeCall* nativeCall_at(address addr);\n+  inline friend NativeCall* nativeCall_before(address return_address);\n@@ -355,2 +387,5 @@\n-  \/\/ The parameter assert_lock disables the assertion during code generation.\n-  void set_destination_mt_safe(address dest, bool assert_lock = true);\n+  address instruction_address() const;\n+  address next_instruction_address() const;\n+  address return_address() const;\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n@@ -358,1 +393,13 @@\n-  address get_trampoline();\n+  void verify_alignment() {} \/\/ do nothing on riscv\n+  void verify();\n+  void print();\n+\n+  void set_destination(address dest);\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+  static bool is_at(address addr) { return NativeShortCall::is_at(addr) ||\n+                                           NativeFarCall::is_at(addr); }\n+  static bool is_call_before(address return_address);\n+  static void insert(address code_pos, address entry);\n+  static void replace_mt_safe(address instr_addr, address code_buffer);\n@@ -363,1 +410,1 @@\n-  NativeCall* call = (NativeCall*)(addr - NativeCall::instruction_offset);\n+  NativeCall* call = (NativeCall*)(addr);\n@@ -370,1 +417,6 @@\n-  NativeCall* call = (NativeCall*)(return_address - NativeCall::return_address_offset);\n+  NativeCall* call = nullptr;\n+  if (NativeFarCall::is_call_before(return_address)) {\n+    call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n+  } else {\n+    call = (NativeCall*)(return_address - NativeInstruction::instruction_size);\n+  }\n@@ -545,45 +597,0 @@\n-\/\/ Call trampoline stubs.\n-class NativeCallTrampolineStub : public NativeInstruction {\n- public:\n-\n-  enum RISCV_specific_constants {\n-    \/\/ Refer to function emit_trampoline_stub.\n-    instruction_size = 3 * NativeInstruction::instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n-    data_offset      = 3 * NativeInstruction::instruction_size,            \/\/ auipc + ld + jr\n-  };\n-\n-  address destination(nmethod *nm = nullptr) const;\n-  void set_destination(address new_destination);\n-  ptrdiff_t destination_offset() const;\n-};\n-\n-inline bool is_NativeCallTrampolineStub_at(address addr) {\n-  \/\/ Ensure that the stub is exactly\n-  \/\/      ld   t0, L--->auipc + ld\n-  \/\/      jr   t0\n-  \/\/ L:\n-\n-  \/\/ judge inst + register + imm\n-  \/\/ 1). check the instructions: auipc + ld + jalr\n-  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-  assert_cond(addr != nullptr);\n-  const int instr_size = NativeInstruction::instruction_size;\n-  if (NativeInstruction::is_auipc_at(addr) &&\n-      NativeInstruction::is_ld_at(addr + instr_size) &&\n-      NativeInstruction::is_jalr_at(addr + 2 * instr_size) &&\n-      (NativeInstruction::extract_rd(addr)                    == x5) &&\n-      (NativeInstruction::extract_rd(addr + instr_size)       == x5) &&\n-      (NativeInstruction::extract_rs1(addr + instr_size)      == x5) &&\n-      (NativeInstruction::extract_rs1(addr + 2 * instr_size)  == x5) &&\n-      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == NativeCallTrampolineStub::data_offset)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-inline NativeCallTrampolineStub* nativeCallTrampolineStub_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(is_NativeCallTrampolineStub_at(addr), \"no call trampoline found\");\n-  return (NativeCallTrampolineStub*)addr;\n-}\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":124,"deletions":117,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -63,5 +63,2 @@\n-  if (NativeCall::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline != nullptr) {\n-      return nativeCallTrampolineStub_at(trampoline)->destination();\n-    }\n+  if (NativeCall::is_at(addr())) {\n+    return nativeCall_at(addr())->reloc_destination(orig_addr);\n@@ -69,0 +66,1 @@\n+  \/\/ Non call reloc\n@@ -84,4 +82,3 @@\n-  if (NativeCall::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline != nullptr) {\n-      nativeCall_at(addr())->set_destination_mt_safe(x, \/* assert_lock *\/false);\n+  if (NativeCall::is_at(addr())) {\n+    NativeCall* nc = nativeCall_at(addr());\n+    if (nc->reloc_set_destination(x)) {\n@@ -97,1 +94,1 @@\n-  assert(NativeCall::is_load_pc_relative_at(addr()), \"Not the expected instruction sequence!\");\n+  assert(NativeInstruction::is_load_pc_relative_at(addr()), \"Not the expected instruction sequence!\");\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1241,2 +1241,4 @@\n-  \/\/ jal\n-  return 1 * NativeInstruction::instruction_size;\n+  if (UseTrampolines) {\n+    return 1 * NativeInstruction::instruction_size; \/\/ jal\n+  }\n+  return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n@@ -1247,1 +1249,4 @@\n-  return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n+  if (UseTrampolines) {\n+    return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n+  }\n+  return NativeMovConstReg::movptr2_instruction_size + (3 * NativeInstruction::instruction_size); \/\/ movptr2, auipc + ld + jal\n@@ -1251,1 +1256,3 @@\n-  \/\/ for generated stubs the call will be\n+  \/\/ For generated stubs the call will be:\n+  \/\/   auipc + ld + jalr\n+  \/\/ Using trampos:\n@@ -1264,1 +1271,4 @@\n-    return 1 * NativeInstruction::instruction_size;\n+    if (UseTrampolines) {\n+      return 1 * NativeInstruction::instruction_size;\n+    }\n+    return 3 * NativeInstruction::instruction_size;\n@@ -2389,1 +2399,1 @@\n-      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type));\n+      call = __ patchable_far_call(Address(addr, relocInfo::runtime_call_type));\n@@ -2398,0 +2408,4 @@\n+      if (!UseTrampolines) {\n+        __ nop();\n+        __ nop();\n+      }\n@@ -2403,1 +2417,1 @@\n-      call = __ trampoline_call(Address(addr, rspec));\n+      call = __ patchable_far_call(Address(addr, rspec));\n@@ -2455,1 +2469,1 @@\n-      address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));\n+      address call = __ patchable_far_call(Address(entry, relocInfo::runtime_call_type));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1008,1 +1008,1 @@\n-    const address tr_call = __ trampoline_call(resolve);\n+    const address tr_call = __ patchable_far_call(resolve);\n@@ -1040,1 +1040,1 @@\n-  const address tr_call = __ trampoline_call(resolve);\n+  const address tr_call = __ patchable_far_call(resolve);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}