{"files":[{"patch":"@@ -321,1 +321,1 @@\n-  address call = __ trampoline_call(resolve);\n+  address call = __ patchable_far_call(resolve);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1349,1 +1349,1 @@\n-  address call = __ trampoline_call(Address(op->addr(), rtype));\n+  address call = __ patchable_far_call(Address(op->addr(), rtype));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    _call_stub_size = 14 * NativeInstruction::instruction_size +\n-                      (NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size),\n+    _call_stub_size = 14 * MacroAssembler::instruction_size +\n+                      (MacroAssembler::instruction_size + MacroAssembler::NativeShortCall::trampoline_size),\n@@ -79,2 +79,2 @@\n-    _deopt_handler_size = 1 * NativeInstruction::instruction_size +\n-                          6 * NativeInstruction::instruction_size \/\/ or smaller\n+    _deopt_handler_size = 1 * MacroAssembler::instruction_size +\n+                          6 * MacroAssembler::instruction_size \/\/ or smaller\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1043,1 +1043,1 @@\n-  address call = trampoline_call(stub);\n+  address call = patchable_far_call(stub);\n@@ -1481,1 +1481,1 @@\n-  address call = trampoline_call(stub);\n+  address call = patchable_far_call(stub);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  assert(UseTrampolines, \"We are not using trampolines\");\n@@ -57,1 +58,1 @@\n-    assert(cb->stubs()->remaining() >= MacroAssembler::max_trampoline_stub_size(), \"pre-allocated trampolines\");\n+    assert(cb->stubs()->remaining() >= MacroAssembler::max_patchable_far_call_stub_size(), \"pre-allocated trampolines\");\n@@ -63,1 +64,1 @@\n-    address reloc_pc = cb->stubs()->end() - NativeCallTrampolineStub::instruction_size;\n+    address reloc_pc = cb->stubs()->end() - MacroAssembler::NativeShortCall::trampoline_size;\n@@ -73,1 +74,1 @@\n-  const int total_requested_size = MacroAssembler::max_trampoline_stub_size() * requests->number_of_entries();\n+  const int total_requested_size = MacroAssembler::max_patchable_far_call_stub_size() * requests->number_of_entries();\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static constexpr bool supports_shared_stubs() { return true; }\n+  static bool supports_shared_stubs() { return UseTrampolines; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  return MacroAssembler::max_trampoline_stub_size();\n+  return MacroAssembler::max_patchable_far_call_stub_size();\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,3 @@\n-          \"Use RVV instructions for left\/right shift of BigInteger\")\n+          \"Use RVV instructions for left\/right shift of BigInteger\")             \\\n+  product(bool, UseTrampolines, false, EXPERIMENTAL,                             \\\n+          \"Far calls uses jal to trampoline.\")\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    return pc_offset + NativeCall::instruction_size;\n+    return pc_offset + NativeCall::byte_size();\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -981,0 +981,10 @@\n+void MacroAssembler::load_link_jump(const address source, Register temp) {\n+  assert(temp != noreg && temp != x0, \"expecting a register\");\n+  assert_cond(source != nullptr);\n+  int64_t distance = source - pc();\n+  assert(is_simm32(distance), \"Must be\");\n+  Assembler::auipc(temp, (int32_t)distance + 0x800);\n+  Assembler::_ld(temp, temp, ((int32_t)distance << 20) >> 20);\n+  Assembler::jalr(x1, temp, 0);\n+}\n+\n@@ -982,0 +992,1 @@\n+  assert(UseTrampolines, \"Must be\");\n@@ -984,27 +995,3 @@\n-  if (is_simm21(distance) && ((distance % 2) == 0)) {\n-    Assembler::jal(x1, distance);\n-  } else {\n-    assert(temp != noreg && temp != x0, \"expecting a register\");\n-    int32_t offset = 0;\n-    la(temp, dest, offset);\n-    jalr(temp, offset);\n-  }\n-}\n-\n-void MacroAssembler::jump_link(const Address &adr, Register temp) {\n-  switch (adr.getMode()) {\n-    case Address::literal: {\n-      relocate(adr.rspec(), [&] {\n-        jump_link(adr.target(), temp);\n-      });\n-      break;\n-    }\n-    case Address::base_plus_offset: {\n-      int32_t offset = ((int32_t)adr.offset() << 20) >> 20;\n-      la(temp, Address(adr.base(), adr.offset() - offset));\n-      jalr(temp, offset);\n-      break;\n-    }\n-    default:\n-      ShouldNotReachHere();\n-  }\n+  assert(is_simm21(distance), \"Must be\");\n+  assert((distance % 2) == 0, \"Must be\");\n+  Assembler::jal(x1, distance);\n@@ -3776,0 +3763,30 @@\n+address MacroAssembler::load_call(Address entry) {\n+  assert(entry.rspec().type() == relocInfo::runtime_call_type ||\n+         entry.rspec().type() == relocInfo::opt_virtual_call_type ||\n+         entry.rspec().type() == relocInfo::static_call_type ||\n+         entry.rspec().type() == relocInfo::virtual_call_type, \"wrong reloc type\");\n+\n+  address target = entry.target();\n+\n+  if (!in_scratch_emit_size()) {\n+    address stub = emit_address_stub(offset(), target);\n+    if (stub == nullptr) {\n+      postcond(pc() == badAddress);\n+      return nullptr; \/\/ CodeCache is full\n+    }\n+  }\n+\n+  address call_pc = pc();\n+#ifdef ASSERT\n+  if (entry.rspec().type() != relocInfo::runtime_call_type) {\n+    assert_alignment(call_pc);\n+  }\n+#endif\n+  relocate(entry.rspec(), [&] {\n+    load_link_jump(target);\n+  });\n+\n+  postcond(pc() != badAddress);\n+  return call_pc;\n+}\n+\n@@ -3781,1 +3798,1 @@\n-  return trampoline_call(Address(entry, rh));\n+  return patchable_far_call(Address(entry, rh));\n@@ -3826,0 +3843,28 @@\n+address MacroAssembler::emit_address_stub(int insts_call_instruction_offset, address dest) {\n+  address stub = start_a_stub(max_patchable_far_call_stub_size());\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n+  }\n+\n+  \/\/ We are always 4-byte aligned here.\n+  assert_alignment(pc());\n+\n+  \/\/ Make sure the address of destination 8-byte aligned.\n+  align(wordSize, 0);\n+\n+  RelocationHolder rh = trampoline_stub_Relocation::spec(code()->insts()->start() +\n+                                                         insts_call_instruction_offset);\n+  const int stub_start_offset = offset();\n+  relocate(rh, [&] {\n+    assert(offset() - stub_start_offset == 0,\n+           \"%ld - %ld == %ld : should be\", (long)offset(), (long)stub_start_offset, (long)0);\n+    assert(offset() % wordSize == 0, \"bad alignment\");\n+    emit_int64((int64_t)dest);\n+  });\n+\n+  const address stub_start_addr = addr_at(stub_start_offset);\n+  end_a_stub();\n+\n+  return stub_start_addr;\n+}\n+\n@@ -3840,1 +3885,1 @@\n-  address stub = start_a_stub(max_trampoline_stub_size());\n+  address stub = start_a_stub(max_patchable_far_call_stub_size());\n@@ -3845,0 +3890,2 @@\n+  assert(UseTrampolines, \"Must be using trampos.\");\n+\n@@ -3853,1 +3900,1 @@\n-  align(wordSize, MacroAssembler::trampoline_stub_data_offset);\n+  align(wordSize, MacroAssembler::NativeShortCall::trampoline_data_offset);\n@@ -3866,1 +3913,1 @@\n-    assert(offset() - stub_start_offset == MacroAssembler::trampoline_stub_data_offset,\n+    assert(offset() - stub_start_offset == MacroAssembler::NativeShortCall::trampoline_data_offset,\n@@ -3874,2 +3921,0 @@\n-  assert(MacroAssembler::is_trampoline_stub_at(stub_start_addr), \"doesn't look like a trampoline\");\n-\n@@ -3877,0 +3922,1 @@\n+\n@@ -3880,1 +3926,1 @@\n-int MacroAssembler::max_trampoline_stub_size() {\n+int MacroAssembler::max_patchable_far_call_stub_size() {\n@@ -3882,1 +3928,4 @@\n-  return MacroAssembler::instruction_size + MacroAssembler::trampoline_stub_instruction_size;\n+  if (UseTrampolines) {\n+    return instruction_size + MacroAssembler::NativeShortCall::trampoline_size;\n+  }\n+  return 2 * wordSize;\n@@ -4601,1 +4650,1 @@\n-      address tpc = trampoline_call(zero_blocks);\n+      address tpc = patchable_far_call(zero_blocks);\n@@ -4608,1 +4657,1 @@\n-      jump_link(zero_blocks, t0);\n+      rt_call(zero_blocks.target());\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":86,"deletions":37,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -439,0 +439,1 @@\n+  address emit_address_stub(int insts_call_instruction_offset, address target);\n@@ -440,1 +441,2 @@\n-  static int max_trampoline_stub_size();\n+  static int max_patchable_far_call_stub_size();\n+\n@@ -596,0 +598,1 @@\n+  void load_link_jump(const address source, Register temp = t0);\n@@ -597,1 +600,0 @@\n-  void jump_link(const Address &adr, Register temp);\n@@ -1178,1 +1180,21 @@\n-  \/\/   - trampoline call:\n+  \/\/   - indirect call: movptr + jalr\n+  \/\/     This too can reach anywhere in the address space, but it cannot be\n+  \/\/     patched while code is running, so it must only be modified at a safepoint.\n+  \/\/     This form of call is most suitable for targets at fixed addresses, which\n+  \/\/     will never be patched.\n+  \/\/\n+  \/\/   - patchable far call:\n+  \/\/     This is only available in C1\/C2-generated code (nmethod).\n+  \/\/\n+  \/\/     [Main code section]\n+  \/\/       auipc\n+  \/\/       ld <address_from_stub_section>\n+  \/\/       jalr\n+  \/\/     [Stub section]\n+  \/\/     trampoline:\n+  \/\/       <64-bit destination address>\n+  \/\/\n+  \/\/    To change the destination we simply atomically store the new\n+  \/\/    address in the stub section.\n+  \/\/\n+  \/\/ - trampoline call (old patchable far call \/ -XX:+UseTrampolines):\n@@ -1197,1 +1219,1 @@\n-\n+  \/\/\n@@ -1202,7 +1224,0 @@\n-  \/\/   - indirect call: movptr + jalr\n-  \/\/     This too can reach anywhere in the address space, but it cannot be\n-  \/\/     patched while code is running, so it must only be modified at a safepoint.\n-  \/\/     This form of call is most suitable for targets at fixed addresses, which\n-  \/\/     will never be patched.\n-  \/\/\n-  \/\/\n@@ -1221,0 +1236,1 @@\n+  \/\/ --\n@@ -1223,1 +1239,1 @@\n-  \/\/ otherwise a trampoline call.\n+  \/\/ otherwise a patchable far call.\n@@ -1231,0 +1247,4 @@\n+  address patchable_far_call(Address entry) {\n+    return UseTrampolines ? trampoline_call(entry) : load_call(entry);\n+  }\n+ private:\n@@ -1232,0 +1252,2 @@\n+  address load_call(Address entry);\n+ public:\n@@ -1548,4 +1570,0 @@\n-    \/\/ Refer to function emit_trampoline_stub.\n-    trampoline_stub_instruction_size = 3 * instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n-    trampoline_stub_data_offset      = 3 * instruction_size,            \/\/ auipc + ld + jr\n-\n@@ -1558,0 +1576,5 @@\n+  enum NativeShortCall {\n+    trampoline_size        = 3 * instruction_size + wordSize,\n+    trampoline_data_offset = 3 * instruction_size\n+  };\n+\n@@ -1561,32 +1584,0 @@\n-  static bool is_trampoline_stub_at(address addr) {\n-    \/\/ Ensure that the stub is exactly\n-    \/\/      ld   t0, L--->auipc + ld\n-    \/\/      jr   t0\n-    \/\/ L:\n-\n-    \/\/ judge inst + register + imm\n-    \/\/ 1). check the instructions: auipc + ld + jalr\n-    \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-    \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-    assert_cond(addr != nullptr);\n-    const int instr_size = instruction_size;\n-    if (is_auipc_at(addr) &&\n-        is_ld_at(addr + instr_size) &&\n-        is_jalr_at(addr + 2 * instr_size) &&\n-        (extract_rd(addr)                    == x5) &&\n-        (extract_rd(addr + instr_size)       == x5) &&\n-        (extract_rs1(addr + instr_size)      == x5) &&\n-        (extract_rs1(addr + 2 * instr_size)  == x5) &&\n-        (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_stub_data_offset)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_call_at(address instr) {\n-    if (is_jal_at(instr) || is_jalr_at(instr)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n@@ -1627,1 +1618,0 @@\n-private:\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":39,"deletions":49,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -42,2 +42,5 @@\n-void NativeCall::verify() {\n-  assert(MacroAssembler::is_call_at((address)this), \"unexpected code at call site\");\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeInstruction\n+\n+bool NativeInstruction::is_call_at(address addr) {\n+  return NativeCall::is_at(addr);\n@@ -46,2 +49,92 @@\n-address NativeCall::destination() const {\n-  address addr = (address)this;\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCallTrampoline\n+class NativeShortCall;\n+\n+class NativeShortCallTrampolineStub : public NativeInstruction {\n+ private:\n+  friend NativeShortCall;\n+  enum RISCV_specific_constants {\n+    trampoline_data_offset = 3 * NativeInstruction::instruction_size \/\/ auipc + ld + jr\n+  };\n+\n+  address destination() const;\n+  void set_destination(address new_destination);\n+\n+  static bool is_at(address addr);\n+  static NativeShortCallTrampolineStub* at(address addr);\n+};\n+\n+address NativeShortCallTrampolineStub::destination() const {\n+  return ptr_at(trampoline_data_offset);\n+}\n+\n+void NativeShortCallTrampolineStub::set_destination(address new_destination) {\n+  set_ptr_at(trampoline_data_offset, new_destination);\n+  OrderAccess::release();\n+}\n+\n+bool NativeShortCallTrampolineStub::is_at(address addr) {\n+  \/\/ Ensure that the stub is exactly\n+  \/\/      ld   t0, L--->auipc + ld\n+  \/\/      jr   t0\n+  \/\/ L:\n+\n+  \/\/ judge inst + register + imm\n+  \/\/ 1). check the instructions: auipc + ld + jalr\n+  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n+  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x5) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_data_offset)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+NativeShortCallTrampolineStub* NativeShortCallTrampolineStub::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCallTrampolineStub::is_at(addr), \"no call trampoline found\");\n+  return (NativeShortCallTrampolineStub*)addr;\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCall\n+class NativeShortCall: private NativeInstruction {\n+ public:\n+  enum RISCV_specific_constants {\n+    return_address_offset       =    1 * NativeInstruction::instruction_size \/\/ jal\n+  };\n+\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(return_address_offset); }\n+  address return_address() const            { return addr_at(return_address_offset); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address get_trampoline();\n+  bool has_trampoline();\n+  address trampoline_destination();\n+ public:\n+\n+  static NativeShortCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+};\n+\n+address NativeShortCall::destination() const {\n+  address addr = instruction_address();\n@@ -49,0 +142,1 @@\n+\n@@ -55,1 +149,1 @@\n-  if (nm != nullptr && nm->stub_contains(destination) && MacroAssembler::is_trampoline_stub_at(destination)) {\n+  if (nm != nullptr && nm->stub_contains(destination) && NativeShortCallTrampolineStub::is_at(destination)) {\n@@ -58,1 +152,1 @@\n-    destination = nativeCallTrampolineStub_at(trampoline_stub_addr)->destination();\n+    destination = NativeShortCallTrampolineStub::at(trampoline_stub_addr)->destination();\n@@ -64,3 +158,49 @@\n-\/\/ Similar to replace_mt_safe, but just changes the destination. The\n-\/\/ important thing is that free-running threads are able to execute this\n-\/\/ call instruction at all times.\n+address NativeShortCall::reloc_destination(address orig_address) {\n+  address addr = instruction_address();\n+  if (NativeShortCall::is_at(addr)) {\n+    NativeShortCall* call = NativeShortCall::at(addr);\n+    if (call->has_trampoline()) {\n+      return call->trampoline_destination();\n+    }\n+  }\n+  if (orig_address != nullptr) {\n+    \/\/ the extracted address from the instructions in address orig_addr\n+    address new_addr = MacroAssembler::pd_call_destination(orig_address);\n+    \/\/ If call is branch to self, don't try to relocate it, just leave it\n+    \/\/ as branch to self. This happens during code generation if the code\n+    \/\/ buffer expands. It will be relocated to the trampoline above once\n+    \/\/ code generation is complete.\n+    new_addr = (new_addr == orig_address) ? addr : new_addr;\n+    return new_addr;\n+  }\n+  return MacroAssembler::pd_call_destination(addr);\n+}\n+\n+void NativeShortCall::set_destination(address dest) {\n+  assert(NativeShortCall::is_at(instruction_address()), \"unexpected code at call site\");\n+  assert(is_jal(), \"Should be jal instruction!\");\n+  intptr_t offset = (intptr_t)(dest - instruction_address());\n+  assert((offset & 0x1) == 0, \"bad alignment\");\n+  assert(Assembler::is_simm21(offset), \"encoding constraint\");\n+  unsigned int insn = 0b1101111; \/\/ jal\n+  address pInsn = (address)(&insn);\n+  Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n+  Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n+  Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n+  Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n+  Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n+  set_int_at(0, insn);\n+}\n+\n+void NativeShortCall::verify() {\n+  assert(NativeShortCall::is_at(instruction_address()),\n+         \"unexpected code at call site: %p\", instruction_address());\n+}\n+\n+void NativeShortCall::print() {\n+  assert(NativeShortCall::is_at(instruction_address()), \"unexpected code at call site\");\n+  tty->print_cr(PTR_FORMAT \": jal\/auipc,ld,jalr x1, offset\/reg\", p2i(instruction_address()));\n+}\n+\n+\/\/ The important thing is that threads are able to execute this\n+\/\/ call instruction at all times. (cmodx)\n@@ -72,1 +212,1 @@\n-void NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+bool NativeShortCall::set_destination_mt_safe(address dest, bool assert_lock) {\n@@ -75,1 +215,1 @@\n-         CompiledICLocker::is_safe(addr_at(0)),\n+         CompiledICLocker::is_safe(instruction_address()),\n@@ -78,2 +218,12 @@\n-  address addr_call = addr_at(0);\n-  assert(MacroAssembler::is_call_at(addr_call), \"unexpected code at call site\");\n+  address call_addr = instruction_address();\n+  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  reloc_set_destination(dest);\n+\n+  ICache::invalidate_range(call_addr, instruction_size);\n+  return true;\n+}\n+\n+bool NativeShortCall::reloc_set_destination(address dest) {\n+  address call_addr = instruction_address();\n+  assert(NativeCall::is_at(call_addr), \"unexpected code at call site\");\n@@ -84,2 +234,2 @@\n-    assert (!MacroAssembler::is_trampoline_stub_at(dest), \"chained trampolines\");\n-    nativeCallTrampolineStub_at(trampoline_stub_addr)->set_destination(dest);\n+    assert(!NativeShortCallTrampolineStub::is_at(dest), \"chained trampolines\");\n+    NativeShortCallTrampolineStub::at(trampoline_stub_addr)->set_destination(dest);\n@@ -89,1 +239,1 @@\n-  if (Assembler::reachable_from_branch_at(addr_call, dest)) {\n+  if (Assembler::reachable_from_branch_at(call_addr, dest)) {\n@@ -96,1 +246,1 @@\n-  ICache::invalidate_range(addr_call, instruction_size);\n+  return true;\n@@ -99,2 +249,2 @@\n-address NativeCall::get_trampoline() {\n-  address call_addr = addr_at(0);\n+address NativeShortCall::get_trampoline() {\n+  address call_addr = instruction_address();\n@@ -106,1 +256,1 @@\n-  if (code != nullptr && code->contains(jal_destination) && MacroAssembler::is_trampoline_stub_at(jal_destination)) {\n+  if (code != nullptr && code->contains(jal_destination) && NativeShortCallTrampolineStub::is_at(jal_destination)) {\n@@ -117,2 +267,316 @@\n-\/\/ Inserts a native call instruction at a given pc\n-void NativeCall::insert(address code_pos, address entry) { Unimplemented(); }\n+bool NativeShortCall::has_trampoline() {\n+  return NativeShortCall::get_trampoline() != nullptr;\n+}\n+\n+address NativeShortCall::trampoline_destination() {\n+  return NativeShortCallTrampolineStub::at(get_trampoline())->destination();\n+}\n+\n+NativeShortCall* NativeShortCall::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n+  NativeShortCall* call = (NativeShortCall*)(addr);\n+  return call;\n+}\n+\n+bool NativeShortCall::is_at(address addr) {\n+  if (MacroAssembler::is_jal_at(addr)) {\n+    if (MacroAssembler::extract_rd(addr)  == x1) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool NativeShortCall::is_call_before(address return_address) {\n+  return NativeShortCall::is_at(return_address - instruction_size);\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeFarCall\n+class NativeFarCall: public NativeInstruction {\n+ public:\n+  enum RISCV_specific_constants {\n+    return_address_offset       =    3 * NativeInstruction::instruction_size, \/\/ auipc + ld + jalr\n+  };\n+\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(return_address_offset); }\n+  address return_address() const            { return addr_at(return_address_offset); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address stub_address();\n+\n+  static void set_stub_address_destination_at(address dest, address value);\n+  static address stub_address_destination_at(address src);\n+ public:\n+\n+  static NativeFarCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+};\n+\n+address NativeFarCall::destination() const {\n+  address addr = instruction_address();\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site\");\n+\n+  address destination = MacroAssembler::target_addr_for_insn(addr);\n+\n+  CodeBlob* cb = CodeCache::find_blob(addr);\n+  assert(cb && cb->is_nmethod(), \"sanity\");\n+  nmethod *nm = (nmethod *)cb;\n+  assert(nm != nullptr, \"Sanity\");\n+  assert(nm->stub_contains(destination), \"Sanity\");\n+  assert(destination != nullptr, \"Sanity\");\n+  return stub_address_destination_at(destination);\n+}\n+\n+address NativeFarCall::reloc_destination(address orig_address) {\n+  address call_addr = instruction_address();\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address stub_addr = nullptr;\n+  if (code != nullptr && code->is_nmethod()) {\n+    stub_addr = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+  }\n+\n+  if (stub_addr != nullptr) {\n+    stub_addr = MacroAssembler::target_addr_for_insn(call_addr);\n+  }\n+  return stub_addr;\n+}\n+\n+void NativeFarCall::set_destination(address dest) {\n+  address addr = instruction_address();\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site\");\n+  Unimplemented();\n+}\n+\n+void NativeFarCall::verify() {\n+  assert(NativeFarCall::is_at(instruction_address()), \"unexpected code at call site\");\n+}\n+\n+void NativeFarCall::print() {\n+  assert(NativeFarCall::is_at(instruction_address()), \"unexpected code at call site\");\n+  tty->print_cr(PTR_FORMAT \": auipc,ld,jalr x1, offset\/reg, \", p2i(addr_at(0)));\n+}\n+\n+bool NativeFarCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+  assert(NativeFarCall::is_at(addr_at(0)), \"unexpected code at call site\");\n+  assert(!assert_lock ||\n+         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+         CompiledICLocker::is_safe(addr_at(0)),\n+         \"concurrent code patching\");\n+\n+  address call_addr = addr_at(0);\n+  assert(NativeFarCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  address stub_addr = stub_address();\n+\n+  if (stub_addr != nullptr) {\n+    set_stub_address_destination_at(stub_addr, dest);\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool NativeFarCall::reloc_set_destination(address dest) {\n+  address call_addr = addr_at(0);\n+  assert(NativeFarCall::is_at(call_addr), \"unexpected code at call site\");\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address stub_addr = nullptr;\n+  if (code != nullptr && code->is_nmethod()) {\n+    stub_addr = trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n+  }\n+\n+  if (stub_addr != nullptr) {\n+    MacroAssembler::pd_patch_instruction_size(call_addr, stub_addr);\n+  }\n+\n+  return true;\n+}\n+\n+void NativeFarCall::set_stub_address_destination_at(address dest, address value) {\n+  assert_cond(dest != nullptr);\n+  assert_cond(value != nullptr);\n+\n+  set_data64_at(dest, (uint64_t)value);\n+  OrderAccess::release();\n+}\n+\n+address NativeFarCall::stub_address_destination_at(address src) {\n+  assert_cond(src != nullptr);\n+  address dest = (address)get_data64_at(src);\n+  return dest;\n+}\n+\n+address NativeFarCall::stub_address() {\n+  address call_addr = addr_at(0);\n+\n+  CodeBlob *code = CodeCache::find_blob(call_addr);\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n+\n+  address dest = MacroAssembler::pd_call_destination(call_addr);\n+  assert(code->contains(dest), \"Sanity\");\n+  return dest;\n+}\n+\n+NativeFarCall* NativeFarCall::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeFarCall::is_at(addr), \"unexpected code at call site: %p\", addr);\n+  NativeFarCall* call = (NativeFarCall*)(addr);\n+  return call;\n+}\n+\n+bool NativeFarCall::is_at(address addr) {\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x5) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (MacroAssembler::extract_rd(addr + 2 * instr_size)  == x1)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool NativeFarCall::is_call_before(address return_address) {\n+  return NativeFarCall::is_at(return_address - return_address_offset);\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeCall\n+\n+address NativeCall::instruction_address() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->instruction_address();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->instruction_address();\n+  }\n+}\n+\n+address NativeCall::next_instruction_address() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->next_instruction_address();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->next_instruction_address();\n+  }\n+}\n+\n+address NativeCall::return_address() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->return_address();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->return_address();\n+  }\n+}\n+\n+address NativeCall::destination() const {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->destination();\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->destination();\n+  }\n+}\n+\n+address NativeCall::reloc_destination(address orig_address) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->reloc_destination(orig_address);\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->reloc_destination(orig_address);\n+  }\n+}\n+\n+void NativeCall::set_destination(address dest) {\n+  if (UseTrampolines) {\n+    NativeShortCall::at(addr_at(0))->set_destination(dest);\n+  } else {\n+    NativeFarCall::at(addr_at(0))->set_destination(dest);\n+  }\n+}\n+\n+void NativeCall::verify() {\n+  if (UseTrampolines) {\n+    NativeShortCall::at(addr_at(0))->verify();\n+  } else {\n+    NativeFarCall::at(addr_at(0))->verify();;\n+  }\n+}\n+\n+void NativeCall::print() {\n+  if (UseTrampolines) {\n+    NativeShortCall::at(addr_at(0))->print();\n+  } else {\n+    NativeFarCall::at(addr_at(0))->print();;\n+  }\n+}\n+\n+bool NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->set_destination_mt_safe(dest, assert_lock);\n+  }\n+}\n+\n+bool NativeCall::reloc_set_destination(address dest) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::at(addr_at(0))->reloc_set_destination(dest);\n+  } else {\n+    return NativeFarCall::at(addr_at(0))->reloc_set_destination(dest);\n+  }\n+}\n+\n+bool NativeCall::is_at(address addr) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::is_at(addr);\n+  } else {\n+    return NativeFarCall::is_at(addr);\n+  }\n+}\n+\n+bool NativeCall::is_call_before(address return_address) {\n+  if (UseTrampolines) {\n+    return NativeShortCall::is_call_before(return_address);\n+  } else {\n+    return NativeFarCall::is_call_before(return_address);\n+  }\n+}\n+\n+NativeCall* nativeCall_at(address addr) {\n+  assert_cond(addr != nullptr);\n+  NativeCall* call = (NativeCall*)(addr);\n+  DEBUG_ONLY(call->verify());\n+  return call;\n+}\n+\n+NativeCall* nativeCall_before(address return_address) {\n+  assert_cond(return_address != nullptr);\n+  NativeCall* call = nullptr;\n+  if (UseTrampolines) {\n+    call = (NativeCall*)(return_address - NativeShortCall::return_address_offset);\n+  } else {\n+    call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n+  }\n+  DEBUG_ONLY(call->verify());\n+  return call;\n+}\n@@ -330,9 +794,0 @@\n-address NativeCallTrampolineStub::destination(nmethod *nm) const {\n-  return ptr_at(data_offset);\n-}\n-\n-void NativeCallTrampolineStub::set_destination(address new_destination) {\n-  set_ptr_at(data_offset, new_destination);\n-  OrderAccess::release();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":486,"deletions":31,"binary":false,"changes":517,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\/\/ - - NativeCallTrampolineStub\n-\/\/ - - NativeMembar\n@@ -72,1 +70,0 @@\n-  bool is_call()                            const { return MacroAssembler::is_call_at(addr_at(0));        }\n@@ -74,0 +71,2 @@\n+  bool is_call()                            const { return is_call_at(addr_at(0));                        }\n+  static bool is_call_at(address addr);\n@@ -75,2 +74,2 @@\n-  inline bool is_nop() const;\n-  inline bool is_jump_or_nop();\n+  bool is_nop() const;\n+  bool is_jump_or_nop();\n@@ -82,1 +81,5 @@\n-  address addr_at(int offset) const    { return address(this) + offset; }\n+  address addr_at(int offset) const { return address(this) + offset; }\n+  jint     int_at(int offset) const { return (jint)      Bytes::get_native_u4(addr_at(offset));  }\n+  juint   uint_at(int offset) const { return             Bytes::get_native_u4(addr_at(offset));  }\n+  address  ptr_at(int offset) const { return (address)   Bytes::get_native_u8(addr_at(offset));  }\n+  oop      oop_at(int offset) const { return cast_to_oop(Bytes::get_native_u8(addr_at(offset))); }\n@@ -84,2 +87,0 @@\n-  jint int_at(int offset) const        { return (jint)Bytes::get_native_u4(addr_at(offset)); }\n-  juint uint_at(int offset) const      { return Bytes::get_native_u4(addr_at(offset)); }\n@@ -87,1 +88,4 @@\n-  address ptr_at(int offset) const     { return (address)Bytes::get_native_u8(addr_at(offset)); }\n+  void  set_int_at(int offset, jint i)      { Bytes::put_native_u4(addr_at(offset), i); }\n+  void set_uint_at(int offset, jint i)      { Bytes::put_native_u4(addr_at(offset), i); }\n+  void  set_ptr_at(int offset, address ptr) { Bytes::put_native_u8(addr_at(offset), (u8)ptr); }\n+  void  set_oop_at(int offset, oop o)       { Bytes::put_native_u8(addr_at(offset), cast_from_oop<u8>(o)); }\n@@ -89,7 +93,2 @@\n-  oop  oop_at (int offset) const       { return cast_to_oop(Bytes::get_native_u8(addr_at(offset))); }\n-\n-\n-  void set_int_at(int offset, jint i)        { Bytes::put_native_u4(addr_at(offset), i); }\n-  void set_uint_at(int offset, jint i)       { Bytes::put_native_u4(addr_at(offset), i); }\n-  void set_ptr_at (int offset, address ptr)  { Bytes::put_native_u8(addr_at(offset), (u8)ptr); }\n-  void set_oop_at (int offset, oop o)        { Bytes::put_native_u8(addr_at(offset), cast_from_oop<u8>(o)); }\n+  static void     set_data64_at(address dest, uint64_t data) { Bytes::put_native_u8(dest, (u8)data); }\n+  static uint64_t get_data64_at(address src)                 { return Bytes::get_native_u8(src); }\n@@ -106,1 +105,1 @@\n-inline NativeInstruction* nativeInstruction_at(address addr) {\n+NativeInstruction* nativeInstruction_at(address addr) {\n@@ -110,4 +109,2 @@\n-\/\/ The natural type of an RISCV instruction is uint32_t\n-inline NativeInstruction* nativeInstruction_at(uint32_t *addr) {\n-  return (NativeInstruction*)addr;\n-}\n+NativeCall* nativeCall_at(address addr);\n+NativeCall* nativeCall_before(address return_address);\n@@ -115,1 +112,0 @@\n-inline NativeCall* nativeCall_at(address addr);\n@@ -119,8 +115,8 @@\n-\n-class NativeCall: public NativeInstruction {\n- public:\n-  enum RISCV_specific_constants {\n-    instruction_size            =    4,\n-    instruction_offset          =    0,\n-    displacement_offset         =    0,\n-    return_address_offset       =    4\n+class NativeCall: private NativeInstruction {\n+ \/\/ private: when common code is using byte_size()\n+ private:\n+  enum {\n+    \/\/ Use byte_size() as it can be changed in runtime\n+    \/\/ Since instruction_size exists on NativeInstruction we need\n+    \/\/ to overload and hide it.\n+    instruction_size = 3 * Assembler::instruction_size \/\/ auipc + ld + jalr\n@@ -128,0 +124,1 @@\n+ public:\n@@ -129,19 +126,6 @@\n-  static int byte_size()                    { return instruction_size; }\n-  address instruction_address() const       { return addr_at(instruction_offset); }\n-  address next_instruction_address() const  { return addr_at(return_address_offset); }\n-  address return_address() const            { return addr_at(return_address_offset); }\n-  address destination() const;\n-\n-  void set_destination(address dest) {\n-    assert(is_jal(), \"Should be jal instruction!\");\n-    intptr_t offset = (intptr_t)(dest - instruction_address());\n-    assert((offset & 0x1) == 0, \"bad alignment\");\n-    assert(Assembler::is_simm21(offset), \"encoding constraint\");\n-    unsigned int insn = 0b1101111; \/\/ jal\n-    address pInsn = (address)(&insn);\n-    Assembler::patch(pInsn, 31, 31, (offset >> 20) & 0x1);\n-    Assembler::patch(pInsn, 30, 21, (offset >> 1) & 0x3ff);\n-    Assembler::patch(pInsn, 20, 20, (offset >> 11) & 0x1);\n-    Assembler::patch(pInsn, 19, 12, (offset >> 12) & 0xff);\n-    Assembler::patch(pInsn, 11, 7, ra->encoding()); \/\/ Rd must be x1, need ra\n-    set_int_at(displacement_offset, insn);\n+  static int byte_size() {\n+    if (UseTrampolines) {\n+      return NativeInstruction::instruction_size; \/\/ jal\n+    } else {\n+      return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n+    }\n@@ -149,0 +133,9 @@\n+  \/\/ Creation\n+  friend NativeCall* nativeCall_at(address addr);\n+  friend NativeCall* nativeCall_before(address return_address);\n+\n+  address instruction_address() const;\n+  address next_instruction_address() const;\n+  address return_address() const;\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n@@ -154,3 +147,3 @@\n-  \/\/ Creation\n-  inline friend NativeCall* nativeCall_at(address addr);\n-  inline friend NativeCall* nativeCall_before(address return_address);\n+  void set_destination(address dest);\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n@@ -158,25 +151,2 @@\n-  static bool is_call_before(address return_address) {\n-    return MacroAssembler::is_call_at(return_address - NativeCall::return_address_offset);\n-  }\n-\n-  \/\/ MT-safe patching of a call instruction.\n-  static void insert(address code_pos, address entry);\n-\n-  static void replace_mt_safe(address instr_addr, address code_buffer);\n-\n-  \/\/ Similar to replace_mt_safe, but just changes the destination.  The\n-  \/\/ important thing is that free-running threads are able to execute\n-  \/\/ this call instruction at all times.  If the call is an immediate BL\n-  \/\/ instruction we can simply rely on atomicity of 32-bit writes to\n-  \/\/ make sure other threads will see no intermediate states.\n-\n-  \/\/ We cannot rely on locks here, since the free-running threads must run at\n-  \/\/ full speed.\n-  \/\/\n-  \/\/ Used in the runtime linkage of calls; see class CompiledIC.\n-  \/\/ (Cf. 4506997 and 4479829, where threads witnessed garbage displacements.)\n-\n-  \/\/ The parameter assert_lock disables the assertion during code generation.\n-  void set_destination_mt_safe(address dest, bool assert_lock = true);\n-\n-  address get_trampoline();\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n@@ -185,14 +155,0 @@\n-inline NativeCall* nativeCall_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  NativeCall* call = (NativeCall*)(addr - NativeCall::instruction_offset);\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n-inline NativeCall* nativeCall_before(address return_address) {\n-  assert_cond(return_address != nullptr);\n-  NativeCall* call = (NativeCall*)(return_address - NativeCall::return_address_offset);\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n@@ -369,21 +325,0 @@\n-\/\/ Call trampoline stubs.\n-class NativeCallTrampolineStub : public NativeInstruction {\n- public:\n-\n-  enum RISCV_specific_constants {\n-    \/\/ Refer to function emit_trampoline_stub.\n-    instruction_size = MacroAssembler::trampoline_stub_instruction_size, \/\/ auipc + ld + jr + target address\n-    data_offset      = MacroAssembler::trampoline_stub_data_offset,      \/\/ auipc + ld + jr\n-  };\n-\n-  address destination(nmethod *nm = nullptr) const;\n-  void set_destination(address new_destination);\n-  ptrdiff_t destination_offset() const;\n-};\n-\n-inline NativeCallTrampolineStub* nativeCallTrampolineStub_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(MacroAssembler::is_trampoline_stub_at(addr), \"no call trampoline found\");\n-  return (NativeCallTrampolineStub*)addr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":47,"deletions":112,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -63,5 +63,2 @@\n-  if (MacroAssembler::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline != nullptr) {\n-      return nativeCallTrampolineStub_at(trampoline)->destination();\n-    }\n+  if (NativeCall::is_at(addr())) {\n+    return nativeCall_at(addr())->reloc_destination(orig_addr);\n@@ -69,0 +66,1 @@\n+  \/\/ Non call reloc\n@@ -84,4 +82,3 @@\n-  if (MacroAssembler::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline != nullptr) {\n-      nativeCall_at(addr())->set_destination_mt_safe(x, \/* assert_lock *\/false);\n+  if (NativeCall::is_at(addr())) {\n+    NativeCall* nc = nativeCall_at(addr());\n+    if (nc->reloc_set_destination(x)) {\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1241,2 +1241,4 @@\n-  \/\/ jal\n-  return 1 * NativeInstruction::instruction_size;\n+  if (UseTrampolines) {\n+    return 1 * NativeInstruction::instruction_size; \/\/ jal\n+  }\n+  return 3 * NativeInstruction::instruction_size; \/\/ auipc + ld + jalr\n@@ -1247,1 +1249,4 @@\n-  return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n+  if (UseTrampolines) {\n+    return NativeMovConstReg::movptr2_instruction_size +  NativeInstruction::instruction_size; \/\/ movptr2, jal\n+  }\n+  return NativeMovConstReg::movptr2_instruction_size + (3 * NativeInstruction::instruction_size); \/\/ movptr2, auipc + ld + jal\n@@ -1251,1 +1256,3 @@\n-  \/\/ for generated stubs the call will be\n+  \/\/ For generated stubs the call will be:\n+  \/\/   auipc + ld + jalr\n+  \/\/ Using trampos:\n@@ -1264,1 +1271,4 @@\n-    return 1 * NativeInstruction::instruction_size;\n+    if (UseTrampolines) {\n+      return 1 * NativeInstruction::instruction_size;\n+    }\n+    return 3 * NativeInstruction::instruction_size;\n@@ -2401,1 +2411,1 @@\n-      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type));\n+      call = __ patchable_far_call(Address(addr, relocInfo::runtime_call_type));\n@@ -2410,0 +2420,4 @@\n+      if (!UseTrampolines) {\n+        __ nop();\n+        __ nop();\n+      }\n@@ -2415,1 +2429,1 @@\n-      call = __ trampoline_call(Address(addr, rspec));\n+      call = __ patchable_far_call(Address(addr, rspec));\n@@ -2467,1 +2481,1 @@\n-      address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));\n+      address call = __ patchable_far_call(Address(entry, relocInfo::runtime_call_type));\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1008,1 +1008,1 @@\n-    const address tr_call = __ trampoline_call(resolve);\n+    const address tr_call = __ patchable_far_call(resolve);\n@@ -1040,1 +1040,1 @@\n-  const address tr_call = __ trampoline_call(resolve);\n+  const address tr_call = __ patchable_far_call(resolve);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}