{"files":[{"patch":"@@ -72,2 +72,2 @@\n-    _call_stub_size = 14 * NativeInstruction::instruction_size +\n-                      (NativeInstruction::instruction_size + NativeShortCall::trampoline_size),\n+    _call_stub_size = 14 * MacroAssembler::instruction_size +\n+                      (MacroAssembler::instruction_size + MacroAssembler::NativeShortCall::trampoline_size),\n@@ -79,2 +79,2 @@\n-    _deopt_handler_size = 1 * NativeInstruction::instruction_size +\n-                          6 * NativeInstruction::instruction_size \/\/ or smaller\n+    _deopt_handler_size = 1 * MacroAssembler::instruction_size +\n+                          6 * MacroAssembler::instruction_size \/\/ or smaller\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    address reloc_pc = cb->stubs()->end() - NativeShortCall::trampoline_size;\n+    address reloc_pc = cb->stubs()->end() - MacroAssembler::NativeShortCall::trampoline_size;\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeInstruction\n+\n@@ -46,0 +49,59 @@\n+\/\/-----------------------------------------------------------------------------\n+\/\/ NativeShortCallTrampoline\n+class NativeShortCall;\n+\n+class NativeShortCallTrampolineStub : public NativeInstruction {\n+ private:\n+  friend NativeShortCall;\n+  enum RISCV_specific_constants {\n+    trampoline_data_offset = 3 * NativeInstruction::instruction_size \/\/ auipc + ld + jr\n+  };\n+\n+  address destination(nmethod *nm = nullptr) const;\n+  void set_destination(address new_destination);\n+  ptrdiff_t destination_offset() const;\n+\n+  static bool is_at(address addr);\n+  static NativeShortCallTrampolineStub* at(address addr);\n+};\n+\n+address NativeShortCallTrampolineStub::destination(nmethod *nm) const {\n+  return ptr_at(trampoline_data_offset);\n+}\n+\n+void NativeShortCallTrampolineStub::set_destination(address new_destination) {\n+  set_ptr_at(trampoline_data_offset, new_destination);\n+  OrderAccess::release();\n+}\n+\n+bool NativeShortCallTrampolineStub::is_at(address addr) {\n+  \/\/ Ensure that the stub is exactly\n+  \/\/      ld   t0, L--->auipc + ld\n+  \/\/      jr   t0\n+  \/\/ L:\n+\n+  \/\/ judge inst + register + imm\n+  \/\/ 1). check the instructions: auipc + ld + jalr\n+  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n+  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n+  assert_cond(addr != nullptr);\n+  const int instr_size = NativeInstruction::instruction_size;\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x5) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n+      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n+      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_data_offset)) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+NativeShortCallTrampolineStub* NativeShortCallTrampolineStub::at(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(NativeShortCallTrampolineStub::is_at(addr), \"no call trampoline found\");\n+  return (NativeShortCallTrampolineStub*)addr;\n+}\n+\n@@ -48,0 +110,32 @@\n+class NativeShortCall: private NativeInstruction {\n+ public:\n+  \/\/ Creation\n+  friend NativeCall* nativeCall_at(address addr);\n+  friend NativeCall* nativeCall_before(address return_address);\n+\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(NativeInstruction::instruction_size); }\n+  address return_address() const            { return addr_at(NativeInstruction::instruction_size); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify_alignment() {} \/\/ do nothing on riscv\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address get_trampoline();\n+  bool has_trampoline();\n+  address trampoline_destination();\n+ public:\n+\n+  static NativeShortCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+  static void insert(address code_pos, address entry);\n+  static void replace_mt_safe(address instr_addr, address code_buffer);\n+};\n@@ -216,1 +310,1 @@\n-  return NativeShortCall::is_at(return_address - Assembler::instruction_size);\n+  return NativeShortCall::is_at(return_address - instruction_size);\n@@ -227,43 +321,0 @@\n-\/\/-----------------------------------------------------------------------------\n-\/\/ NativeShortCallTrampoline\n-\n-address NativeShortCallTrampolineStub::destination(nmethod *nm) const {\n-  return ptr_at(NativeShortCall::trampoline_data_offset);\n-}\n-\n-void NativeShortCallTrampolineStub::set_destination(address new_destination) {\n-  set_ptr_at(NativeShortCall::trampoline_data_offset, new_destination);\n-  OrderAccess::release();\n-}\n-\n-bool NativeShortCallTrampolineStub::is_at(address addr) {\n-  \/\/ Ensure that the stub is exactly\n-  \/\/      ld   t0, L--->auipc + ld\n-  \/\/      jr   t0\n-  \/\/ L:\n-\n-  \/\/ judge inst + register + imm\n-  \/\/ 1). check the instructions: auipc + ld + jalr\n-  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-  assert_cond(addr != nullptr);\n-  const int instr_size = NativeInstruction::instruction_size;\n-  if (MacroAssembler::is_auipc_at(addr) &&\n-      MacroAssembler::is_ld_at(addr + instr_size) &&\n-      MacroAssembler::is_jalr_at(addr + 2 * instr_size) &&\n-      (MacroAssembler::extract_rd(addr)                    == x5) &&\n-      (MacroAssembler::extract_rd(addr + instr_size)       == x5) &&\n-      (MacroAssembler::extract_rs1(addr + instr_size)      == x5) &&\n-      (MacroAssembler::extract_rs1(addr + 2 * instr_size)  == x5) &&\n-      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == NativeShortCall::trampoline_data_offset)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-NativeShortCallTrampolineStub* NativeShortCallTrampolineStub::at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(NativeShortCallTrampolineStub::is_at(addr), \"no call trampoline found\");\n-  return (NativeShortCallTrampolineStub*)addr;\n-}\n-\n@@ -272,0 +323,39 @@\n+class NativeFarCall: public NativeInstruction {\n+ public:\n+  \/\/ Creation\n+  friend NativeCall* nativeCall_at(address addr);\n+  friend NativeCall* nativeCall_before(address return_address);\n+\n+  enum RISCV_specific_constants {\n+    return_address_offset       =    3 * NativeInstruction::instruction_size, \/\/ ld auipc jalr\n+  };\n+\n+  address instruction_address() const       { return addr_at(0); }\n+  address next_instruction_address() const  { return addr_at(return_address_offset); }\n+  address return_address() const            { return addr_at(return_address_offset); }\n+  address destination() const;\n+  address reloc_destination(address orig_address);\n+\n+  void set_destination(address dest);\n+  void verify_alignment() {} \/\/ do nothing on riscv\n+  void verify();\n+  void print();\n+\n+  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n+  bool reloc_set_destination(address dest);\n+\n+ private:\n+  address stub_address();\n+  address stub_address_destination();\n+  bool has_address_stub();\n+\n+  static void set_stub_address_destination_at(address dest, address value);\n+  static address stub_address_destination_at(address src);\n+ public:\n+\n+  static NativeFarCall* at(address addr);\n+  static bool is_at(address addr);\n+  static bool is_call_before(address return_address);\n+  static void insert(address code_pos, address entry);\n+  static void replace_mt_safe(address instr_addr, address code_buffer);\n+};\n@@ -504,0 +594,4 @@\n+bool NativeCall::is_at(address addr) {\n+  return NativeShortCall::is_at(addr) || NativeFarCall::is_at(addr);\n+}\n+\n@@ -529,0 +623,19 @@\n+NativeCall* nativeCall_at(address addr) {\n+  assert_cond(addr != nullptr);\n+  NativeCall* call = (NativeCall*)(addr);\n+  DEBUG_ONLY(call->verify());\n+  return call;\n+}\n+\n+NativeCall* nativeCall_before(address return_address) {\n+  assert_cond(return_address != nullptr);\n+  NativeCall* call = nullptr;\n+  if (NativeFarCall::is_call_before(return_address)) {\n+    call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n+  } else {\n+    call = (NativeCall*)(return_address - NativeShortCall::instruction_size);\n+  }\n+  DEBUG_ONLY(call->verify());\n+  return call;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":157,"deletions":44,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-\/\/ - - NativeCallTrampolineStub\n-\/\/ - - NativeMembar\n@@ -76,2 +74,2 @@\n-  inline bool is_nop() const;\n-  inline bool is_jump_or_nop();\n+  bool is_nop() const;\n+  bool is_jump_or_nop();\n@@ -114,91 +112,0 @@\n-class NativeShortCall: private NativeInstruction {\n- public:\n-  enum RISCV_specific_constants {\n-    trampoline_size        = 3 * NativeInstruction::instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n-    trampoline_data_offset = 3 * NativeInstruction::instruction_size             \/\/ auipc + ld + jr\n-  };\n-\n-  \/\/ Creation\n-  inline friend NativeCall* nativeCall_at(address addr);\n-  inline friend NativeCall* nativeCall_before(address return_address);\n-\n-  address instruction_address() const       { return addr_at(0); }\n-  address next_instruction_address() const  { return addr_at(NativeInstruction::instruction_size); }\n-  address return_address() const            { return addr_at(NativeInstruction::instruction_size); }\n-  address destination() const;\n-  address reloc_destination(address orig_address);\n-\n-  void set_destination(address dest);\n-  void verify_alignment() {} \/\/ do nothing on riscv\n-  void verify();\n-  void print();\n-\n-  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n-  bool reloc_set_destination(address dest);\n-\n- private:\n-  address get_trampoline();\n-  bool has_trampoline();\n-  address trampoline_destination();\n- public:\n-\n-  static NativeShortCall* at(address addr);\n-  static bool is_at(address addr);\n-  static bool is_call_before(address return_address);\n-  static void insert(address code_pos, address entry);\n-  static void replace_mt_safe(address instr_addr, address code_buffer);\n-};\n-\n-class NativeShortCallTrampolineStub : public NativeInstruction {\n- private:\n-  friend NativeShortCall;\n-\n-  address destination(nmethod *nm = nullptr) const;\n-  void set_destination(address new_destination);\n-  ptrdiff_t destination_offset() const;\n-\n-  static bool is_at(address addr);\n-  static NativeShortCallTrampolineStub* at(address addr);\n-};\n-\n-class NativeFarCall: public NativeInstruction {\n- public:\n-  \/\/ Creation\n-  inline friend NativeCall* nativeCall_at(address addr);\n-  inline friend NativeCall* nativeCall_before(address return_address);\n-\n-  enum RISCV_specific_constants {\n-    instruction_size            =    3 * NativeInstruction::instruction_size, \/\/ ld auipc jalr\n-    return_address_offset       =    3 * NativeInstruction::instruction_size, \/\/ ld auipc jalr\n-  };\n-\n-  address instruction_address() const       { return addr_at(0); }\n-  address next_instruction_address() const  { return addr_at(return_address_offset); }\n-  address return_address() const            { return addr_at(return_address_offset); }\n-  address destination() const;\n-  address reloc_destination(address orig_address);\n-\n-  void set_destination(address dest);\n-  void verify_alignment() {} \/\/ do nothing on riscv\n-  void verify();\n-  void print();\n-\n-  bool set_destination_mt_safe(address dest, bool assert_lock = true);\n-  bool reloc_set_destination(address dest);\n-\n- private:\n-  address stub_address();\n-  address stub_address_destination();\n-  bool has_address_stub();\n-\n-  static void set_stub_address_destination_at(address dest, address value);\n-  static address stub_address_destination_at(address src);\n- public:\n-\n-  static NativeFarCall* at(address addr);\n-  static bool is_at(address addr);\n-  static bool is_call_before(address return_address);\n-  static void insert(address code_pos, address entry);\n-  static void replace_mt_safe(address instr_addr, address code_buffer);\n-};\n-\n@@ -215,2 +122,2 @@\n-  inline friend NativeCall* nativeCall_at(address addr);\n-  inline friend NativeCall* nativeCall_before(address return_address);\n+  friend NativeCall* nativeCall_at(address addr);\n+  friend NativeCall* nativeCall_before(address return_address);\n@@ -232,2 +139,1 @@\n-  static bool is_at(address addr) { return NativeShortCall::is_at(addr) ||\n-                                           NativeFarCall::is_at(addr); }\n+  static bool is_at(address addr);\n@@ -239,19 +145,0 @@\n-inline NativeCall* nativeCall_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  NativeCall* call = (NativeCall*)(addr);\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n-inline NativeCall* nativeCall_before(address return_address) {\n-  assert_cond(return_address != nullptr);\n-  NativeCall* call = nullptr;\n-  if (NativeFarCall::is_call_before(return_address)) {\n-    call = (NativeCall*)(return_address - NativeFarCall::return_address_offset);\n-  } else {\n-    call = (NativeCall*)(return_address - NativeInstruction::instruction_size);\n-  }\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":5,"deletions":118,"binary":false,"changes":123,"status":"modified"}]}