{"files":[{"patch":"@@ -361,1 +361,1 @@\n-            Type outerThisType = types.erasure(owner.type.getEnclosingType());\n+            Type outerThisType = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -509,1 +509,17 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD)) == 0 &&\n+                    ((flags() & NOOUTERTHIS) == 0 || type.getEnclosingType().tsym.hasOuterInstance());\n+    }\n+\n+    \/** If the class containing this symbol is a local or an anonymous class, then it might be\n+     *  defined inside one or more pre-construction contexts, for which the corresponding enclosing\n+     *  instance is considered inaccessible. This method return the class symbol corresponding to the\n+     *  innermost enclosing type that is accessible from this symbol's class. Note: this method should\n+     *  only be called after checking that {@link #hasOuterInstance()} returns {@code true}.\n+     *\/\n+    public ClassSymbol innermostAccessibleEnclosingClass() {\n+        Assert.check(enclClass().hasOuterInstance());\n+        Type current = enclClass().type;\n+        while ((current.tsym.flags() & NOOUTERTHIS) != 0) {\n+            current = current.getEnclosingType();\n+        }\n+        return (ClassSymbol) current.getEnclosingType().tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -373,4 +373,0 @@\n-                } else {\n-                    if (outerThisStack.head != null &&\n-                        outerThisStack.head != _sym)\n-                        visitSymbol(outerThisStack.head);\n@@ -380,40 +376,0 @@\n-\n-        \/** If tree refers to a class instance creation expression\n-         *  add all free variables of the freshly created class.\n-         *\/\n-        public void visitNewClass(JCNewClass tree) {\n-            ClassSymbol c = (ClassSymbol)tree.constructor.owner;\n-            if (tree.encl == null &&\n-                c.hasOuterInstance() &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitNewClass(tree);\n-        }\n-\n-        \/** If tree refers to a qualified this or super expression\n-         *  for anything but the current class, add the outer this\n-         *  stack as a free variable.\n-         *\/\n-        public void visitSelect(JCFieldAccess tree) {\n-            if ((tree.name == names._this || tree.name == names._super) &&\n-                tree.selected.type.tsym != clazz &&\n-                outerThisStack.head != null)\n-                visitSymbol(outerThisStack.head);\n-            super.visitSelect(tree);\n-        }\n-\n-        \/** If tree refers to a superclass constructor call,\n-         *  add all free variables of the superclass.\n-         *\/\n-        public void visitApply(JCMethodInvocation tree) {\n-            if (TreeInfo.name(tree.meth) == names._super) {\n-                Symbol constructor = TreeInfo.symbol(tree.meth);\n-                ClassSymbol c = (ClassSymbol)constructor.owner;\n-                if (c.hasOuterInstance() &&\n-                    !tree.meth.hasTag(SELECT) &&\n-                    outerThisStack.head != null)\n-                    visitSymbol(outerThisStack.head);\n-            }\n-            super.visitApply(tree);\n-        }\n-\n@@ -1593,1 +1549,1 @@\n-        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n+        Type target = owner.innermostAccessibleEnclosingClass().erasure(types);\n@@ -3104,1 +3060,1 @@\n-                thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);\n+                thisArg = makeThis(tree.pos(), c.innermostAccessibleEnclosingClass());\n@@ -3310,1 +3266,1 @@\n-                    thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);\n+                    thisArg = makeThis(tree.meth.pos(), c.innermostAccessibleEnclosingClass());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-LocalClassTest$1CapturingLocal$1.<init>(final val$this$0\/*synthetic*\/, final val$val$i\/*synthetic*\/)\n+LocalClassTest$1CapturingLocal$1.<init>(final this$0\/*implicit*\/, final val$val$i\/*synthetic*\/)\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LocalClassTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334121\n+ * @summary Anonymous class capturing two enclosing instances fails to compile\n+ * @enablePreview\n+ *\/\n+\n+public class MultiLevelOuterInstance {\n+\n+    interface A {\n+        void run();\n+    }\n+    interface B {\n+        void run();\n+    }\n+\n+    class Inner1 {\n+        Inner1() {\n+            this(new A() {\n+                class Inner2 {\n+                    Inner2() {\n+                        this(new B() {\n+                            public void run() {\n+                                m();\n+                                g();\n+                            }\n+                        });\n+                    }\n+\n+                    Inner2(B o) {\n+                        o.run();\n+                    }\n+                }\n+\n+                public void run() {\n+                    new Inner2();\n+                }\n+\n+                void m() { }\n+            });\n+        }\n+\n+        Inner1(A o) { }\n+    }\n+    void g() { }\n+\n+    public static void main(String[] args) {\n+        new MultiLevelOuterInstance().new Inner1();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/MultiLevelOuterInstance.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}