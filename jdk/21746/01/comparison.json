{"files":[{"patch":"@@ -1379,1 +1379,2 @@\n-    method_data->initialize();\n+    CompilerThreadCanCallJava canCallJava(THREAD, true);\n+    method_data->reinitialize();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,3 +62,8 @@\n-  _header._bits = (intptr_t)0;\n-  _header._struct._tag = tag;\n-  _header._struct._bci = bci;\n+  DataLayout temp;\n+  temp._header._bits = (intptr_t)0;\n+  temp._header._struct._tag = tag;\n+  temp._header._struct._bci = bci;\n+  \/\/ Write the header using a single intptr_t write.  This ensures that if the layout is\n+  \/\/ reinitialized readers will never see the transient state where the header is 0.\n+  _header = temp._header;\n+\n@@ -1227,0 +1232,22 @@\n+\/\/ Reinitialize the storage of an existing MDO at a safepoint.  Doing it this way will ensure it's\n+\/\/ not being accessed while the contents are being rewritten.\n+class VM_ReinitializeMDO: public VM_Operation {\n+ private:\n+  MethodData* _mdo;\n+ public:\n+  VM_ReinitializeMDO(MethodData* mdo): _mdo(mdo) {}\n+  VMOp_Type type() const                         { return VMOp_ReinitializeMDO; }\n+  void doit() {\n+    \/\/ The extra data is being zero'd, we'd like to acquire the extra_data_lock but it can't be held\n+    \/\/ over a safepoint.  This means that we don't actually need to acquire the lock.\n+    _mdo->initialize();\n+  }\n+  bool allow_nested_vm_operations() const        { return true; }\n+};\n+\n+void MethodData::reinitialize() {\n+  VM_ReinitializeMDO op(this);\n+  VMThread::execute(&op);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1952,0 +1952,1 @@\n+  friend class VM_ReinitializeMDO;\n@@ -1968,0 +1969,3 @@\n+\n+  void initialize();\n+\n@@ -1972,1 +1976,5 @@\n-  void initialize();\n+\n+  \/\/ Safely reinitialize the data in the MDO.  This is intended as a testing facility as the\n+  \/\/ reinitialization is performed at a safepoint so it's isn't cheap and it doesn't ensure that all\n+  \/\/ readers will see consistent profile data.\n+  void reinitialize();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,1 +117,2 @@\n-  template(RendezvousGCThreads)\n+  template(RendezvousGCThreads)                   \\\n+  template(ReinitializeMDO)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}