{"files":[{"patch":"@@ -1911,1 +1911,12 @@\n-    \/\/ it would make trip_count == 2^31 which causes overflow and the situation is overall weird\n+    \/\/ it would be an overall weird situation:\n+    \/\/ - the case that would make old_trip_count not smaller than max_juint would make\n+    \/\/   the new trip_count as big as 2^31 (due to the ceiling involving stride_m)\n+    \/\/   which makes the multiplication in the rhs of adjust_min_trip's assignment would overflow\n+    \/\/ - the old trip count has its default value (which should not be assigned otherwise\n+    \/\/   since the assignment of the trip count either decrease it, or is guarded with\n+    \/\/   trip_count < max_juint) meaning that it hasn't been assigned, so we can't really\n+    \/\/   trust the current state and compare the old trip count with the new one in a\n+    \/\/   meaningful way. It is not clear what would be the correct behavior wrt adjust_min_trip.\n+    \/\/ Let's check we are in a surprise-free situation, that should be the only one reachable\n+    \/\/ here. => old_trip_count was set, is reliable, and is small enough to be sure that `stride_con`\n+    \/\/ will also be small enough, and no overflow risk.\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary C2's unrolling code has a too strict assert when a counted loop's range as wide as int's.\n+ * @summary C2's unrolling code has a too strict assert when a counted loop's range is as wide as int's.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/UnrollWideLoopHitsTooStrictAssert.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}