{"files":[{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageTypeSpecifier;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.metadata.IIOMetadata;\n+import javax.imageio.metadata.IIOMetadataNode;\n+import javax.imageio.stream.ImageOutputStream;\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+\n+\/**\n+ * This constructs sample gif files used to test different combinations\n+ * of gif frame disposal methods and transparent pixel indices.\n+ *\/\n+public class GifBuilder {\n+\n+    \/**\n+     * Different disposal methods for gif frames. These names exactly\n+     * correspond to the String identifier ImageIO uses.\n+     *\/\n+    public enum Disposal {none, doNotDispose, restoreToBackgroundColor, restoreToPrevious};\n+\n+\n+    \/**\n+     * @param disposal the frame disposal method\n+     * @param isFirstTableIndexTransparent if true then the transparent pixel\n+     *                                     is set to 0. If false then the\n+     *                                     transparent pixel is set to the\n+     *                                     last index.\n+     *\/\n+    public record FrameDescription(Disposal disposal, boolean isFirstTableIndexTransparent) {}\n+\n+    \/**\n+     * This creates a sample gif image based on a series of FrameDescriptions, and the\n+     * calls {@link GifComparison#run(URL)}\n+     *\/\n+    public static void test(FrameDescription... frameDescriptions) throws Throwable {\n+        File file = createTestFile(frameDescriptions);\n+        try {\n+            GifComparison.run(file.toURI().toURL());\n+        } finally {\n+            file.delete();\n+        }\n+    }\n+\n+    private static File createTestFile(FrameDescription... frameDescriptions) throws IOException {\n+        Color[] colors = new Color[] {\n+                Color.red,\n+                Color.yellow,\n+                Color.green,\n+                Color.cyan\n+        };\n+        File file = File.createTempFile(\"GifBuilder\", \".gif\");\n+        ImageOutputStream ios = ImageIO.createImageOutputStream(file);\n+        ImageWriter gifWriter = ImageIO.getImageWritersByFormatName(\"GIF\").next();\n+        gifWriter.setOutput(ios);\n+        ImageWriteParam wparam = gifWriter.getDefaultWriteParam();\n+        IIOMetadata streamMetadata = gifWriter.getDefaultStreamMetadata(wparam);\n+        gifWriter.prepareWriteSequence(streamMetadata);\n+\n+        IndexColorModel icm = createIndexColorModel(colors, colors.length - 1);\n+\n+        ImageTypeSpecifier s = ImageTypeSpecifier.createFromBufferedImageType(BufferedImage.TYPE_BYTE_INDEXED);\n+        IIOMetadata metadata = gifWriter.getDefaultImageMetadata(s, wparam);\n+        String metaFormatName = metadata.getNativeMetadataFormatName();\n+\n+        for (FrameDescription frameDescription : frameDescriptions) {\n+\n+            \/\/ prepare the image:\n+            int width = 100 + 50 * (icm.getMapSize() - 2);\n+            BufferedImage bi = new BufferedImage(width, 100,\n+                    BufferedImage.TYPE_BYTE_INDEXED, icm);\n+            Graphics2D g = bi.createGraphics();\n+            g.setComposite(AlphaComposite.Clear);\n+            g.fillRect(0, 0, bi.getWidth(), bi.getHeight());\n+            g.setComposite(AlphaComposite.SrcOver);\n+            int x = 0;\n+            for (int a = 0; a < icm.getMapSize() - 1; a++) {\n+                if (a != icm.getTransparentPixel()) {\n+                    Color color = new Color(icm.getRGB(a));\n+                    g.setColor(color);\n+                    g.fillOval(x, 0, 100, 100);\n+                    x += 50;\n+                }\n+            }\n+            g.dispose();\n+\n+            \/\/ wrap attributes for gifWriter:\n+            int transparentPixel = frameDescription.isFirstTableIndexTransparent ? 0 : icm.getMapSize() - 1;\n+            IIOMetadata frameMetadata = gifWriter.getDefaultImageMetadata(ImageTypeSpecifier.createFromRenderedImage(bi), wparam);\n+            IIOMetadataNode root = new IIOMetadataNode(metaFormatName);\n+            IIOMetadataNode gce = new IIOMetadataNode(\"GraphicControlExtension\");\n+            gce.setAttribute(\"disposalMethod\", frameDescription.disposal.name());\n+            gce.setAttribute(\"userInputFlag\", \"FALSE\");\n+            gce.setAttribute(\"transparentColorFlag\", \"TRUE\");\n+            gce.setAttribute(\"delayTime\", \"0\");\n+            gce.setAttribute(\"transparentColorIndex\", Integer.toString(transparentPixel));\n+            root.appendChild(gce);\n+            frameMetadata.mergeTree(metaFormatName, root);\n+            IIOImage img = new IIOImage(bi,  null, frameMetadata);\n+            gifWriter.writeToSequence(img, wparam);\n+        }\n+        gifWriter.endWriteSequence();\n+        ios.flush();\n+        ios.close();\n+\n+        return file;\n+    }\n+\n+    private static IndexColorModel createIndexColorModel(Color[] colors, int transparentIndex) {\n+        byte[] r = new byte[colors.length];\n+        byte[] g = new byte[colors.length];\n+        byte[] b = new byte[colors.length];\n+        for (int a = 0; a < colors.length; a++) {\n+            r[a] = (byte) colors[a].getRed();\n+            g[a] = (byte) colors[a].getGreen();\n+            b[a] = (byte) colors[a].getBlue();\n+        }\n+        int bits = (int)(Math.log(colors.length) \/ Math.log(2) + .5);\n+        return new IndexColorModel(bits, colors.length, r, g, b, transparentIndex);\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifBuilder.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -41,2 +41,0 @@\n-import java.io.File;\n-import java.io.IOException;\n@@ -44,2 +42,0 @@\n-import java.nio.file.*;\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -51,1 +47,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -55,2 +50,2 @@\n- * This compares the ImageIO rendering of a gif with the ToolkitImage\n- * rendering.\n+ * This compares the last frame of ImageIO's rendering of a gif with the\n+ * ToolkitImage's rendering.\n@@ -59,1 +54,0 @@\n- * However this does have its own main method that inspects a folder of gifs.\n@@ -64,44 +58,1 @@\n-     * This inspects a folder and calls {@link #run(URL)} for each gif file.\n-     *\/\n-    public static void main(String[] args) throws Exception {\n-        AtomicInteger successCtr = new AtomicInteger();\n-        AtomicInteger failureCtr = new AtomicInteger();\n-        File dir = new File(args[0]);\n-        Files.walkFileTree(dir.toPath(), new FileVisitor<>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n-                String s = file.toString();\n-                if (s.endsWith(\".gif\")) {\n-                    try {\n-                        run(file.toFile().toURI().toURL());\n-                        successCtr.incrementAndGet();\n-                    } catch (Throwable t) {\n-                        failureCtr.incrementAndGet();\n-                        t.printStackTrace();\n-                    }\n-                }\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult visitFileFailed(Path file, IOException exc) {\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-\n-        System.out.println(\"Done. Successes = \" + successCtr.get() +\n-                \" Failures = \" + failureCtr.get());\n-    }\n-\n-    \/**\n-     * This iterates over every frame a gif and throws an Error \/ Exception\n+     * This inspects the last frame of a gif and throws an Error \/ Exception\n@@ -124,39 +75,35 @@\n-        for (int a = 0; a < ioModel.frames.size(); a++) {\n-            BufferedImage ioImg = ioModel.getFrame(a);\n-            BufferedImage awtImage = awtModel.getFrame(a);\n-\n-            \/\/ We could make this method much faster if we only iterated\n-            \/\/ through the gif file once (for each model). But this\n-            \/\/ slow implementation is probably more readable for developers.\n-\n-            lastImage = awtImage;\n-\n-            if (!(ioImg.getWidth() == awtImage.getWidth() &&\n-                    ioImg.getHeight() == awtImage.getHeight()))\n-                throw new Error(\"These images are not the same size: \" +\n-                        ioImg.getWidth() + \"x\" + ioImg.getHeight() + \" vs \" +\n-                        awtImage.getWidth() + \"x\" + awtImage.getHeight());\n-\n-            for (int y = 0; y < ioImg.getHeight(); y++) {\n-                for (int x = 0; x < ioImg.getWidth(); x++) {\n-                    int argb1 = ioImg.getRGB(x, y);\n-                    int argb2 = awtImage.getRGB(x, y);\n-\n-                    int alpha1 = (argb1 & 0xff000000) >> 24;\n-                    int alpha2 = (argb2 & 0xff000000) >> 24;\n-                    if (alpha1 == 0 && alpha2 == 0) {\n-                        continue;\n-                    } else if (alpha1 == 0 || alpha2 == 0) {\n-                        throw new Error(\"pixels at (\" + x + \", \" + y +\n-                                \") have different opacities: \" +\n-                                Integer.toUnsignedString(argb1, 16) + \" vs \" +\n-                                Integer.toUnsignedString(argb2, 16));\n-                    }\n-                    int rgb1 = argb1 & 0xffffff;\n-                    int rgb2 = argb2 & 0xffffff;\n-                    if (rgb1 != rgb2) {\n-                        throw new Error(\"pixels at (\" + x + \", \" + y +\n-                                \") have different opaque RGB values: \" +\n-                                Integer.toUnsignedString(rgb1, 16) + \" vs \" +\n-                                Integer.toUnsignedString(rgb2, 16));\n-                    }\n+\n+        int a = ioModel.frames.size() - 1;\n+        BufferedImage ioImg = ioModel.getFrame(a);\n+        BufferedImage awtImage = awtModel.getFrame(a);\n+\n+        lastImage = awtImage;\n+\n+        if (!(ioImg.getWidth() == awtImage.getWidth() &&\n+                ioImg.getHeight() == awtImage.getHeight()))\n+            throw new Error(\"These images are not the same size: \" +\n+                    ioImg.getWidth() + \"x\" + ioImg.getHeight() + \" vs \" +\n+                    awtImage.getWidth() + \"x\" + awtImage.getHeight());\n+\n+        for (int y = 0; y < ioImg.getHeight(); y++) {\n+            for (int x = 0; x < ioImg.getWidth(); x++) {\n+                int argb1 = ioImg.getRGB(x, y);\n+                int argb2 = awtImage.getRGB(x, y);\n+\n+                int alpha1 = (argb1 & 0xff000000) >> 24;\n+                int alpha2 = (argb2 & 0xff000000) >> 24;\n+                if (alpha1 == 0 && alpha2 == 0) {\n+                    continue;\n+                } else if (alpha1 == 0 || alpha2 == 0) {\n+                    throw new Error(\"pixels at (\" + x + \", \" + y +\n+                            \") have different opacities: \" +\n+                            Integer.toUnsignedString(argb1, 16) + \" vs \" +\n+                            Integer.toUnsignedString(argb2, 16));\n+                }\n+                int rgb1 = argb1 & 0xffffff;\n+                int rgb2 = argb2 & 0xffffff;\n+                if (rgb1 != rgb2) {\n+                    throw new Error(\"pixels at (\" + x + \", \" + y +\n+                            \") have different opaque RGB values: \" +\n+                            Integer.toUnsignedString(rgb1, 16) + \" vs \" +\n+                            Integer.toUnsignedString(rgb2, 16));\n@@ -166,1 +113,1 @@\n-        System.out.println(\"Passed (\" + ioModel.frames.size() + \" frames)\");\n+        System.out.println(\"Passed\");\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifComparison.java","additions":39,"deletions":92,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.awt.Color;\n-import java.awt.image.BufferedImage;\n-import java.net.URL;\n@@ -37,15 +34,4 @@\n-        URL srcURL = GifSavedImageTransparentTest.class.getResource(\"ukraine-flag.gif\");\n-        BufferedImage bi = GifComparison.run(srcURL);\n-\n-        Color topLeftPixel = new Color(bi.getRGB(3, 3), true);\n-        if (topLeftPixel.getAlpha() != 0) {\n-            throw new Error(\"The top left corner should be transparent\");\n-        }\n-\n-        Color topStripePixel = new Color(bi.getRGB(30, 30), true);\n-        if (topStripePixel.getAlpha() != 255) {\n-            throw new Error(\"The top stripe should be opaque\");\n-        }\n-        if (!topStripePixel.equals(new Color(0, 91, 187))) {\n-            throw new Error(\"The top stripe should be blue\");\n-        }\n+        GifBuilder.test(\n+                new GifBuilder.FrameDescription(GifBuilder.Disposal.doNotDispose, false),\n+                new GifBuilder.FrameDescription(GifBuilder.Disposal.doNotDispose, true),\n+                new GifBuilder.FrameDescription(GifBuilder.Disposal.doNotDispose, true) );\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifSavedImageTransparentTest.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"filename":"test\/jdk\/sun\/awt\/image\/gif\/ukraine-flag.gif","binary":true,"status":"deleted"}]}