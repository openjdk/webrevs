{"files":[{"patch":"@@ -4,1 +4,0 @@\n- * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -74,49 +73,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj);\n-      ldrb(hdr, Address(hdr, Klass::misc_flags_offset()));\n-      tst(hdr, KlassFlags::_misc_is_value_based_class);\n-      br(Assembler::NE, slow_case);\n-    }\n-\n-    Label done;\n-    \/\/ Load object header\n-    ldr(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    orr(hdr, hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    str(hdr, Address(disp_hdr, 0));\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    lea(rscratch2, Address(obj, hdr_offset));\n-    cmpxchgptr_barrier(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/nullptr);\n-    \/\/ if the object header was the same, we're done\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) sp <= hdr\n-    \/\/ 3) hdr <= sp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr - sp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    mov(rscratch1, sp);\n-    sub(hdr, hdr, rscratch1);\n-    ands(hdr, hdr, aligned_mask - (int)os::vm_page_size());\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    str(hdr, Address(disp_hdr, 0));\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    cbnz(hdr, slow_case);\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count(rscratch1);\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n+\n@@ -134,18 +86,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    if (hdr_offset) {\n-      lea(rscratch1, Address(obj, hdr_offset));\n-      cmpxchgptr_barrier(disp_hdr, hdr, rscratch1, rscratch2, done, &slow_case);\n-    } else {\n-      cmpxchgptr_barrier(disp_hdr, hdr, obj, rscratch2, done, &slow_case);\n-    }\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count(rscratch1);\n-  }\n+  lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":68,"binary":false,"changes":71,"status":"modified"}]}