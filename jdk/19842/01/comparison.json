{"files":[{"patch":"@@ -1545,1 +1545,1 @@\n-        AddOption(\"--add-modules=ALL-DEFAULT\", NULL);\n+        AddOption(\"--add-modules=ALL-DEFAULT,ALL-MODULE-PATH\", NULL);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    ClassLoader newClassLoaderFor(ClassLoader parent, String mainClassName) throws ClassNotFoundException, Fault {\n+    ClassLoader newClassLoaderFor(ClassLoader parentLoader, String mainClassName) throws ClassNotFoundException, Fault {\n@@ -194,1 +194,1 @@\n-            return new MemoryClassLoader(inMemoryClasses, parent, null, descriptor, this::compileJavaFileByName);\n+            return new MemoryClassLoader(inMemoryClasses, parentLoader, null, descriptor, this::compileJavaFileByName);\n@@ -203,14 +203,0 @@\n-        var bootLayer = ModuleLayer.boot();\n-        var parentLayer = bootLayer;\n-        var parentLoader = parent;\n-\n-        \/\/ Optionally create module layer for all modules on the module path.\n-        var modulePathFinder = createModuleFinderFromModulePath();\n-        var modulePathModules = modulePathFinder.findAll().stream().map(ModuleReference::descriptor).map(ModuleDescriptor::name).toList();\n-        if (!modulePathModules.isEmpty()) {\n-            var modulePathConfiguration = bootLayer.configuration().resolveAndBind(modulePathFinder, ModuleFinder.of(), Set.copyOf(modulePathModules));\n-            var modulePathLayer = ModuleLayer.defineModulesWithOneLoader(modulePathConfiguration, List.of(bootLayer), parent).layer();\n-            parentLayer = modulePathLayer;\n-            parentLoader = modulePathLayer.findLoader(modulePathModules.getFirst());\n-        }\n-\n@@ -218,0 +204,1 @@\n+        var bootLayer = ModuleLayer.boot();\n@@ -220,1 +207,1 @@\n-        var memoryConfig = parentLayer.configuration().resolveAndBind(memoryFinder, ModuleFinder.of(), Set.of(applicationModule.name()));\n+        var memoryConfig = bootLayer.configuration().resolveAndBind(memoryFinder, ModuleFinder.of(), Set.of(applicationModule.name()));\n@@ -222,1 +209,1 @@\n-        var memoryController = ModuleLayer.defineModules(memoryConfig, List.of(parentLayer), __ -> memoryClassLoader);\n+        var memoryController = ModuleLayer.defineModules(memoryConfig, List.of(bootLayer), __ -> memoryClassLoader);\n@@ -233,9 +220,0 @@\n-    private static ModuleFinder createModuleFinderFromModulePath() {\n-        var elements = System.getProperty(\"jdk.module.path\");\n-        if (elements == null) {\n-            return ModuleFinder.of();\n-        }\n-        var paths = Arrays.stream(elements.split(File.pathSeparator)).map(Path::of);\n-        return ModuleFinder.of(paths.toArray(Path[]::new));\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8304400 8332226\n+ * @bug 8304400 8332226 8334761\n@@ -224,0 +224,62 @@\n+    @Test\n+    void testAutomaticModuleAlreadyInModuleGraph(@TempDir Path base) throws Exception {\n+        Files.createDirectories(base.resolve(\"foo\", \"foo\"));\n+        Files.writeString(base.resolve(\"foo\", \"module-info.java\"),\n+                \"\"\"\n+                module foo {\n+                  exports foo;\n+                }\n+                \"\"\");\n+        Files.writeString(base.resolve(\"foo\", \"foo\", \"Foo.java\"),\n+                \"\"\"\n+                package foo;\n+                public record Foo() {}\n+                \"\"\");\n+        var javac = ToolProvider.findFirst(\"javac\").orElseThrow();\n+        javac.run(System.out, System.err, \"--module-source-path\", base.toString(), \"--module\", \"foo\", \"-d\", base.toString());\n+        var jar =  ToolProvider.findFirst(\"jar\").orElseThrow();\n+        jar.run(System.out, System.err, \"--create\", \"--file\", base.resolve(\"foo.jar\").toString(), \"-C\", base.resolve(\"foo\").toString(), \"foo\/Foo.class\");\n+\n+        Files.createDirectories(base.resolve(\"bar\", \"bar\"));\n+        Files.writeString(base.resolve(\"bar\", \"module-info.java\"),\n+                \"\"\"\n+                module bar {\n+                  requires foo;\n+                }\n+                \"\"\");\n+        Files.writeString(base.resolve(\"bar\", \"bar\",\"Prog1.java\"),\n+                \"\"\"\n+                package bar;\n+                class Prog1 {\n+                  public static void main(String... args) {\n+                    System.out.println(new foo.Foo());\n+                  }\n+                }\n+                \"\"\");\n+\n+        var command = List.of(\n+                Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n+                \"-p\", base.resolve(\"foo.jar\").toString(),\n+                \"--add-modules\", \"foo\", \/\/ JDK-8334761\n+                \"bar\/bar\/Prog1.java\");\n+        var redirectedOut = base.resolve(\"out.redirected\");\n+        var redirectedErr = base.resolve(\"err.redirected\");\n+        var process = new ProcessBuilder(command)\n+                .directory(base.toFile())\n+                .redirectOutput(redirectedOut.toFile())\n+                .redirectError(redirectedErr.toFile())\n+                .start();\n+        var code = process.waitFor();\n+        var out = Files.readAllLines(redirectedOut);\n+        var err = Files.readAllLines(redirectedErr);\n+\n+        assertAll(\n+                () -> assertEquals(0, code, out + \"\\n\" + err),\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Foo[]\n+                        \"\"\".lines(), out.stream()),\n+                () -> assertTrue(err.isEmpty())\n+        );\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/ModuleSourceLauncherTests.java","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"}]}