{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static jdk.test.lib.NetworkConfiguration.isSameInterface;\n@@ -298,2 +299,2 @@\n-        assertTrue(s.getNetworkInterface().equals(ni));\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n@@ -318,2 +319,2 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n-        assertTrue(s.getNetworkInterface().equals(ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n@@ -415,1 +416,2 @@\n-        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+        String msg = \"AdaptorMulticasting:  \" + System.nanoTime();\n+        byte[] message = msg.getBytes(\"UTF-8\");\n@@ -424,2 +426,16 @@\n-        p = new DatagramPacket(new byte[1024], 100);\n-        s.receive(p);\n+        while (true) {\n+            p = new DatagramPacket(new byte[1024], 100);\n+            s.receive(p);\n+            if (p.getPort() == s.getLocalPort()) {\n+                String str = new String(p.getData(), p.getOffset(), p.getLength(), \"UTF-8\");\n+                if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {\n+                    System.out.format(\"Got expected message \\\"%s\\\" from %s%n\", str, p.getSocketAddress());\n+                    break;\n+                }\n+                System.out.println(\"Unexpected message received. Expected: \" + msg);\n+                System.out.println(\"Received message doesn't match - skipping: \" + str);\n+            } else {\n+                System.out.println(\"Unexpected message received. Expected message from: \" + s.getLocalAddress());\n+                System.out.println(\"Received message sender doesn't match - skipping: \" + p.getSocketAddress());\n+            }\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.net.BindException;\n@@ -49,0 +50,1 @@\n+import java.util.function.Predicate;\n@@ -57,0 +59,32 @@\n+    interface RetryableTest<T extends Exception> {\n+        public void runTest() throws T;\n+    }\n+\n+    \/\/ retry the given lambda (RetryableTest) if an exception\n+    \/\/ that satisfies the predicate (retryOn) is caught.\n+    <T extends Exception> void testWithRetry(RetryableTest<T> test,\n+                                             Predicate<Throwable> retryOn,\n+                                             int max) throws T {\n+        for (int i=0; i < max; i++) {\n+            try {\n+                test.runTest();\n+                break;\n+            } catch (Throwable t) {\n+                if (i < max -1 && retryOn.test(t)) {\n+                    System.out.println(\"Got \" + t + \"; will retry\");\n+                } else throw t;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * When calling {@link DatagramChannel#disconnect()} a {@link BindException}\n+     * may occur. In which case we want to retry the test.\n+     *\/\n+    class BindExceptionOnDisconnect extends BindException {\n+        BindExceptionOnDisconnect(BindException x) {\n+            super(x.getMessage());\n+            initCause(x);\n+        }\n+    }\n+\n@@ -64,11 +98,3 @@\n-        try (DatagramChannel dc = DatagramChannel.open()) {\n-            System.out.println(\"Test with default\");\n-            dc.bind(new InetSocketAddress(lb, 0));\n-            test(dc);\n-            test(dc);\n-        }\n-\n-        \/\/ test with IPv6 socket\n-        if (IPSupport.hasIPv6()) {\n-            System.out.println(\"Test with IPv6 socket\");\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+        System.out.println(\"Test with default\");\n+        testWithRetry(() -> {\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -79,0 +105,12 @@\n+        }, BindExceptionOnDisconnect.class::isInstance, 5);\n+\n+        \/\/ test with IPv6 socket\n+        if (IPSupport.hasIPv6()) {\n+            System.out.println(\"Test with IPv6 socket\");\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -84,5 +122,7 @@\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n-                dc.bind(new InetSocketAddress(lb, 0));\n-                test(dc);\n-                test(dc);\n-            }\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -92,0 +132,1 @@\n+\n@@ -114,1 +155,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -137,1 +182,5 @@\n-        dc.disconnect();\n+        try {\n+            dc.disconnect();\n+        } catch (BindException x) {\n+            throw new BindExceptionOnDisconnect(x);\n+        }\n@@ -171,1 +220,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -213,1 +266,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java","additions":78,"deletions":21,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Connect\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -117,0 +121,11 @@\n+                \/\/ When connecting an unbound datagram channel, the underlying\n+                \/\/ socket will first be bound to the wildcard address. On macOS,\n+                \/\/ the system may allocate the same port on which another socket\n+                \/\/ is already bound with a more specific address. This may prevent\n+                \/\/ datagrams directed at the connected socket to reach it.\n+                \/\/ To avoid this, when on macOS, we preemptively bind `dc` to the\n+                \/\/ specific address instead of letting it bind to the wildcard.\n+                if (Platform.isOSX()) {\n+                    dc.bind(new InetSocketAddress(((InetSocketAddress)connectSocketAddress).getAddress(), 0));\n+                    err.println(\"Initiator bound to: \" + connectSocketAddress);\n+                }\n@@ -120,0 +135,1 @@\n+                assert !connectSocketAddress.equals(dc.getLocalAddress());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Connect.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *     sender address\n+ *     sender address.\n@@ -66,0 +66,1 @@\n+            System.out.println(\"\\nReader bound to: \" + reader.getLocalAddress());\n@@ -78,0 +79,1 @@\n+            System.out.println(\"\\nSender bound to: \" + sender.getLocalAddress());\n@@ -100,0 +102,5 @@\n+            System.out.println(\"Sender bound to: \" + local);\n+            if (((InetSocketAddress)local).getPort() == remotePort) {\n+                System.out.println(\"testSend: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -108,0 +115,2 @@\n+                System.out.format(\"testSend: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -141,0 +150,5 @@\n+            System.out.println(\"Reader bound to: \" + remote);\n+            if (((InetSocketAddress)local).getPort() == ((InetSocketAddress)remote).getPort()) {\n+                System.out.println(\"testReceive: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -146,0 +160,2 @@\n+                System.out.format(\"testReceive: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -168,1 +184,6 @@\n-            return Optional.ofNullable(NetworkInterface.getByInetAddress(ia));\n+            NetworkInterface nif = NetworkInterface.getByInetAddress(ia);\n+            if (nif != null) {\n+                System.out.format(\"Selecting interface %s[%d]%n\\twith addresses:%n\\t%s%n\",\n+                    nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n+            }\n+            return Optional.ofNullable(nif);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ManySourcesAndTargets.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,1 @@\n+            long elapsed = 0;\n@@ -104,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -105,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -110,1 +115,6 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            continue;\n+                        }\n@@ -126,2 +136,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -145,1 +155,0 @@\n-                buf.rewind();\n@@ -163,0 +172,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- *     the channel's socket to be bound to a local address\n+ *     the channel's socket to be bound to a local address.\n+ * @run main\/othervm NotBound\n@@ -34,0 +35,3 @@\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +41,2 @@\n+    static final CountDownLatch received = new CountDownLatch(1);\n+\n@@ -40,0 +46,1 @@\n+        System.out.println(\"Bound to: \" + dc.getLocalAddress());\n@@ -54,0 +61,1 @@\n+                    System.out.format(\"receiver bound to: %s%n\", local);\n@@ -55,10 +63,35 @@\n-                    \/\/ send message to channel to wakeup receiver\n-                    DatagramChannel sender = DatagramChannel.open();\n-                    try {\n-                        ByteBuffer bb = ByteBuffer.wrap(\"hello\".getBytes());\n-                        InetAddress lh = InetAddress.getLocalHost();\n-                        SocketAddress target =\n-                            new InetSocketAddress(lh, local.getPort());\n-                        sender.send(bb, target);\n-                    } finally {\n-                        sender.close();\n+                    boolean isAnyLocal = local.getAddress().isAnyLocalAddress();\n+                    int maxAttempts = 5;\n+                    int localPort = 0;\n+                    List<InetAddress> llh = isAnyLocal\n+                            ? List.of(InetAddress.getLocalHost(), InetAddress.getLoopbackAddress())\n+                            : List.of(local.getAddress());\n+                    SocketAddress target = null;\n+                    for (int i = 0 ; i < maxAttempts ; i++) {\n+                        InetAddress lh = llh.get(i % llh.size());\n+                        target = new InetSocketAddress(lh, local.getPort());\n+                        \/\/ send message to channel to wakeup receiver\n+                        try (DatagramChannel sender = DatagramChannel.open()) {\n+                            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: hello\".getBytes());\n+                            sender.send(bb, target);\n+                            System.out.format(\"Woke up receiver: sent datagram to %s from %s%n\",\n+                                    target, sender.getLocalAddress());\n+                            localPort = ((InetSocketAddress)sender.getLocalAddress()).getPort();\n+                        }\n+                        if (received.await(250, TimeUnit.MILLISECONDS)) {\n+                            \/\/ The datagram has been received: no need to continue\n+                            \/\/ sending\n+                            break;\n+                        }\n+                        \/\/ if sender port and destination port were identical, which\n+                        \/\/ could happen on some systems, the receiver might not receive\n+                        \/\/ the datagram. So in that case we try again, bailing out if\n+                        \/\/ we had to retry too many times\n+                        if (localPort == local.getPort()) {\n+                            System.out.println(\"Local port and peer port are identical. Retrying...\");\n+                        } else {\n+                            System.out.println(\"Datagram not received after 250ms. Retrying...\");\n+                        }\n+                    }\n+                    if (localPort == local.getPort()) {\n+                        System.out.println(\"Couldn't find a port to send to \" + target);\n@@ -66,1 +99,0 @@\n-\n@@ -80,4 +112,4 @@\n-            DatagramChannel peer = DatagramChannel.open()\n-                .bind(new InetSocketAddress(0));\n-            int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n-            try {\n+            System.out.println(\"Check that connect() binds the socket\");\n+            try (DatagramChannel peer = DatagramChannel.open()) {\n+                peer.bind(new InetSocketAddress(0));\n+                int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n@@ -86,2 +118,0 @@\n-            } finally {\n-                peer.close();\n@@ -96,1 +126,2 @@\n-            ByteBuffer bb = ByteBuffer.wrap(\"ignore this\".getBytes());\n+            System.out.println(\"Check that send() binds the socket\");\n+            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: ignore this\".getBytes());\n@@ -108,0 +139,1 @@\n+            System.out.println(\"Check that blocking receive() binds the socket\");\n@@ -111,0 +143,1 @@\n+            received.countDown();\n@@ -121,0 +154,1 @@\n+            System.out.println(\"Check that non-blocking receive() binds the socket\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/NotBound.java","additions":54,"deletions":20,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,3 @@\n-            System.out.format(\"Send message -> group %s (id=0x%x)\\n\",\n-                    group.getHostAddress(), id);\n+            System.out.format(\"Send message -> group [%s]:%d (id=0x%x) nif:%s[%s]%n\",\n+                    group.getHostAddress(), port, id, nif.getDisplayName(), nif.getIndex());\n+            System.out.format(\"bound address before send: %s%n\", dc.getLocalAddress());\n@@ -77,0 +78,1 @@\n+            System.out.format(\"bound address after send: %s%n\", dc.getLocalAddress());\n@@ -100,0 +102,1 @@\n+            long elapsed = 0;\n@@ -102,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -103,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -108,1 +115,7 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            \/\/ We haven't waited long enough,\n+                            continue;\n+                        }\n@@ -124,2 +137,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -143,1 +156,0 @@\n-                buf.rewind();\n@@ -158,0 +170,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n@@ -159,4 +173,4 @@\n-        DatagramChannel dc1 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n-        DatagramChannel dc2 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n+        try (DatagramChannel dc1 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+            DatagramChannel dc2 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family)) {\n@@ -164,1 +178,0 @@\n-        try {\n@@ -187,1 +200,0 @@\n-            receiveDatagram(dc1, \"dc1\", false, id);\n@@ -189,4 +201,1 @@\n-\n-        } finally {\n-            dc1.close();\n-            dc2.close();\n+            receiveDatagram(dc1, \"dc1\", false, id);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Promiscuous.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ *        ReceiveISA\n+ * @run main\/othervm ReceiveISA\n+ *\n@@ -34,0 +40,3 @@\n+\n+import jdk.test.lib.Platform;\n+\n@@ -47,1 +56,5 @@\n-            dc3.socket().bind((SocketAddress) null); \/\/ bind server to any port\n+            InetAddress lh = InetAddress.getLocalHost();\n+            InetSocketAddress dest = Platform.isOSX()\n+                    ? new InetSocketAddress(lh, 0)\n+                    : null;\n+            dc3.socket().bind(dest); \/\/ bind server to any port\n@@ -50,1 +63,0 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ReceiveISA.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    static final int MAX_TRIES = 3;\n-    static final String GREETINGS_MESSAGE = \"Greetings from SelectWhenRefused!\";\n+    static final int MAX_TRIES = 10;\n+    static final String GREETINGS_MESSAGE = System.nanoTime() + \": Greetings from SelectWhenRefused!\";\n@@ -52,0 +52,1 @@\n+        System.err.println(\"Refuser is: \" + refuser);\n@@ -53,1 +54,29 @@\n-        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+        DatagramChannel dc = null;\n+        for (int i=0; i < MAX_TRIES; i++) {\n+            dc = DatagramChannel.open();\n+            try {\n+                dc.bind(new InetSocketAddress(0));\n+            } catch (Throwable t) {\n+                dc.close();\n+                throw t;\n+            }\n+\n+            \/\/ check the port assigned to dc\n+            if (((InetSocketAddress)dc.getLocalAddress()).getPort() != port) {\n+                \/\/ We got a good port. Do not retry\n+                break;\n+            }\n+\n+            \/\/ We bound to the same port that the refuser is using, This will not\n+            \/\/ work. Retry binding if possible.\n+            if (i < MAX_TRIES - 1) {\n+                \/\/ we will retry...\n+                System.err.format(\"Refuser port has been reused by dc: %s, retrying...%n\",\n+                        dc.getLocalAddress());\n+            } else {\n+                \/\/ that was the last attempt... Skip the test\n+                System.err.format(\"Skipping test: refuser port has been reused by dc: %s%n\",\n+                        dc.getLocalAddress());\n+                return;\n+            }\n+        }\n@@ -55,0 +84,1 @@\n+        assert dc != null;\n@@ -91,1 +121,1 @@\n-            System.out.println(\"Skipping test: refuser port has been reused: \" + e);\n+            System.err.println(\"Skipping test: refuser port has been reused: \" + e);\n@@ -122,1 +152,3 @@\n-            DatagramChannel.open().bind(refuser).close();\n+            try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                dc2.bind(refuser);\n+            }\n@@ -154,1 +186,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n@@ -169,1 +201,3 @@\n-                DatagramChannel.open().bind(refuser).close();\n+                try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                    dc2.bind(refuser);\n+                }\n@@ -172,1 +206,1 @@\n-                System.out.println(\"Got expected PortUnreachableException \" + pue);\n+                System.err.println(\"Got expected PortUnreachableException \" + pue);\n@@ -218,1 +252,1 @@\n-        System.out.format(\"Received %d keys%n\", selectedKeys.size());\n+        System.err.format(\"Received %d keys%n\", selectedKeys.size());\n@@ -222,1 +256,1 @@\n-                System.out.println(\"Invalid or unreadable key: \" + key);\n+                System.err.println(\"Invalid or unreadable key: \" + key);\n@@ -227,1 +261,1 @@\n-                System.out.println(\"Attempting to read datagram from key: \" + key);\n+                System.err.println(\"Attempting to read datagram from key: \" + key);\n@@ -237,1 +271,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n@@ -246,1 +280,1 @@\n-                System.out.println(\"Unable to read from datagram \" + io);\n+                System.err.println(\"Unable to read from datagram \" + io);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SelectWhenRefused.java","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import org.testng.Assert;\n@@ -49,0 +50,1 @@\n+import java.net.SocketAddress;\n@@ -142,1 +144,3 @@\n-                sender.bind(null);\n+                sender.bind(new InetSocketAddress(host, 0));\n+                System.out.format(\"testSendReceiveMaxSize: sender: %s -> receiver: %s%n\",\n+                        sender.getLocalAddress(), receiver.getLocalAddress());\n@@ -153,1 +157,12 @@\n-                receiver.receive(receiveBuf);\n+                SocketAddress src;\n+                int count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n@@ -170,1 +185,11 @@\n-                receiver.receive(receiveBuf);\n+                count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SendReceiveMaxSize.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Sender\n+ * @run main Sender\n@@ -39,0 +42,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -49,2 +54,2 @@\n-        Server server = new Server();\n-        Client client = new Client(server.port());\n+        try (Server server = new Server()) {\n+            Client client = new Client(server.port());\n@@ -52,2 +57,2 @@\n-        Thread serverThread = new Thread(server);\n-        serverThread.start();\n+            Thread serverThread = new Thread(server);\n+            serverThread.start();\n@@ -55,2 +60,2 @@\n-        Thread clientThread = new Thread(client);\n-        clientThread.start();\n+            Thread clientThread = new Thread(client);\n+            clientThread.start();\n@@ -58,2 +63,2 @@\n-        serverThread.join();\n-        clientThread.join();\n+            serverThread.join();\n+            clientThread.join();\n@@ -61,2 +66,3 @@\n-        server.throwException();\n-        client.throwException();\n+            server.throwException();\n+            client.throwException();\n+        }\n@@ -67,1 +73,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -79,2 +85,1 @@\n-            try {\n-                DatagramChannel dc = DatagramChannel.open();\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -87,0 +92,4 @@\n+                if (Platform.isOSX()) {\n+                    \/\/ avoid binding on wildcard on macOS\n+                    dc.bind(new InetSocketAddress(address, 0));\n+                }\n@@ -96,1 +105,1 @@\n-    public static class Server implements Runnable {\n+    public static class Server implements Runnable, AutoCloseable {\n@@ -98,1 +107,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -101,1 +110,5 @@\n-            dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+            \/\/ avoid binding to wildcard address on macOS\n+            InetSocketAddress lo = Platform.isOSX()\n+                    ? new InetSocketAddress(InetAddress.getLocalHost(), 0)\n+                    : new InetSocketAddress(0);\n+            dc = DatagramChannel.open().bind(lo);\n@@ -152,0 +165,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Sender.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"}]}