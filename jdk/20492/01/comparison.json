{"files":[{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in(loc)) return;\n+  if (!heap->is_in_bounds(loc)) return;\n@@ -80,1 +80,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_bounds(loc)) {\n@@ -99,1 +99,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_bounds(loc)) {\n@@ -116,1 +116,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_bounds(loc));\n@@ -169,1 +169,1 @@\n-void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds(void* interior_loc, oop obj, const char *file, int line) {\n@@ -172,3 +172,3 @@\n-  if (!heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap failed\",\n-                  \"oop must point to a heap address\",\n+  if (!heap->is_in_bounds(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds failed\",\n+                  \"oop must be in heap bounds\",\n@@ -179,1 +179,1 @@\n-void ShenandoahAsserts::assert_in_heap_or_null(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char *file, int line) {\n@@ -182,3 +182,3 @@\n-  if (obj != nullptr && !heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_or_null failed\",\n-                  \"oop must point to a heap address\",\n+  if (obj != nullptr && !heap->is_in_bounds(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds_or_null failed\",\n+                  \"oop must be in heap bounds\",\n@@ -194,1 +194,1 @@\n-  if (!heap->is_in(obj)) {\n+  if (!heap->is_in_bounds(obj)) {\n@@ -196,1 +196,1 @@\n-                  \"oop must point to a heap address\",\n+                  \"oop must be in heap bounds\",\n@@ -213,0 +213,7 @@\n+  ShenandoahHeapRegion* obj_reg = heap->heap_region_containing(obj);\n+  if (!heap->is_full_gc_move_in_progress() && !obj_reg->is_active()) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object should be in active region\",\n+                  file, line);\n+  }\n+\n@@ -226,1 +233,1 @@\n-    if (!heap->is_in(fwd)) {\n+    if (!heap->is_in_bounds(fwd)) {\n@@ -228,1 +235,1 @@\n-                    \"Forwardee must point to a heap address\",\n+                    \"Forwardee must be in heap bounds\",\n@@ -238,5 +245,15 @@\n-    \/\/ Step 3. Check that forwardee points to correct region\n-    if (heap->heap_region_index_containing(fwd) == heap->heap_region_index_containing(obj)) {\n-      print_failure(_safe_all, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n-                    \"Non-trivial forwardee should in another region\",\n-                    file, line);\n+    ShenandoahHeapRegion* fwd_reg = heap->heap_region_containing(fwd);\n+\n+    \/\/ Step 3. Check that forwardee points to correct region, unless we are in Full GC.\n+    if (!heap->is_full_gc_move_in_progress()) {\n+      if (!fwd_reg->is_active()) {\n+        print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                      \"Forwardee should be in active region\",\n+                      file, line);\n+      }\n+\n+      if (fwd_reg == obj_reg) {\n+        print_failure(_safe_all, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                      \"Non-trivial forwardee should be in another region\",\n+                      file, line);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":38,"deletions":21,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-  static void assert_in_heap(void* interior_loc, oop obj, const char* file, int line);\n-  static void assert_in_heap_or_null(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char* file, int line);\n@@ -77,4 +77,4 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap(interior_loc, obj, __FILE__, __LINE__)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap_or_null(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds_or_null(interior_loc, obj, __FILE__, __LINE__)\n@@ -167,2 +167,2 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  shenandoah_assert_in_heap_or_null(nullptr, p);\n+  shenandoah_assert_in_heap_bounds_or_null(nullptr, p);\n@@ -49,1 +49,1 @@\n-  assert(p == nullptr || _heap->is_in(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_bounds(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -721,1 +721,1 @@\n-      shenandoah_assert_correct(p, obj);\n+      \/\/ Note: The obj is dead here. Do not touch it, just clear.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  shenandoah_assert_in_heap(nullptr, obj);\n+  shenandoah_assert_in_heap_bounds(nullptr, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -748,1 +748,1 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n+bool ShenandoahHeap::is_in_bounds(const void* p) const {\n@@ -754,0 +754,11 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  if (is_in_bounds(p)) {\n+    \/\/ Now check if region is in active state, unless we are moving\n+    \/\/ objects during Full GC across the regions in not yet determinate state.\n+    return is_full_gc_move_in_progress() ||\n+           heap_region_containing(p)->is_active();\n+  } else {\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -496,0 +496,1 @@\n+  \/\/ Check the pointer is in active part of Java heap.\n@@ -498,0 +499,3 @@\n+  \/\/ Check the pointer is within Java heap bounds.\n+  bool is_in_bounds(const void* p) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  assert(ShenandoahHeap::heap()->is_in(addr),\n+  assert(ShenandoahHeap::heap()->is_in_bounds(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,11 @@\n+inline oop reference_coop_decode_raw(narrowOop v) {\n+  return CompressedOops::is_null(v) ? nullptr : CompressedOops::decode_raw(v);\n+}\n+\n+inline oop reference_coop_decode_raw(oop v) {\n+  return v;\n+}\n+\n+\/\/ Raw referent, it can be dead. You cannot dereference it, only use for nullptr\n+\/\/ and bitmap checks. The decoding uses a special-case inlined CompressedOops::decode\n+\/\/ method that bypasses normal oop-ness checks.\n@@ -87,1 +98,1 @@\n-static oop reference_referent(oop reference) {\n+static oop reference_referent_raw(oop reference) {\n@@ -89,1 +100,1 @@\n-  return CompressedOops::decode(heap_oop);\n+  return reference_coop_decode_raw(heap_oop);\n@@ -281,1 +292,1 @@\n-  const oop referent = reference_referent<T>(reference);\n+  const oop referent = reference_referent_raw<T>(reference);\n@@ -306,1 +317,1 @@\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent<T>(reference)), \"only make inactive final refs with alive referents\");\n+    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -379,1 +390,1 @@\n-  oop referent = reference_referent<T>(reference);\n+  oop referent = reference_referent_raw<T>(reference);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n-class ShenandoahIgnoreReferenceDiscoverer : public ReferenceDiscoverer {\n-public:\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    return true;\n-  }\n-};\n-\n@@ -71,0 +64,1 @@\n+  ReferenceIterationMode _ref_mode;\n@@ -85,1 +79,7 @@\n-      set_ref_discoverer_internal(new ShenandoahIgnoreReferenceDiscoverer());\n+      \/\/ Unknown status for Reference.referent field. Do not touch it, it might be dead.\n+      \/\/ Normally, barriers would prevent us from seeing the dead referents, but verifier\n+      \/\/ runs with barriers disabled.\n+      _ref_mode = DO_FIELDS_EXCEPT_REFERENT;\n+    } else {\n+      \/\/ Otherwise do all fields.\n+      _ref_mode = DO_FIELDS;\n@@ -89,0 +89,4 @@\n+  ReferenceIterationMode reference_iteration_mode() {\n+    return _ref_mode;\n+  }\n+\n@@ -122,2 +126,2 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),\n-              \"oop must be in heap\");\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_bounds(obj),\n+              \"oop must be in heap bounds\");\n@@ -180,2 +184,2 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),\n-             \"Forwardee must be in heap\");\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_bounds(fwd),\n+             \"Forwardee must be in heap bounds\");\n@@ -198,0 +202,3 @@\n+      check(ShenandoahAsserts::_safe_oop, obj, fwd_reg->is_active(),\n+            \"Forwardee should be in active region\");\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"}]}