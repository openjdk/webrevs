{"files":[{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in_bounds(loc)) return;\n+  if (!heap->is_in_reserved(loc)) return;\n@@ -80,1 +80,1 @@\n-  if (heap->is_in_bounds(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -99,1 +99,1 @@\n-  if (heap->is_in_bounds(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -116,1 +116,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in_bounds(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_reserved(loc));\n@@ -172,1 +172,1 @@\n-  if (!heap->is_in_bounds(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -182,1 +182,1 @@\n-  if (obj != nullptr && !heap->is_in_bounds(obj)) {\n+  if (obj != nullptr && !heap->is_in_reserved(obj)) {\n@@ -194,1 +194,1 @@\n-  if (!heap->is_in_bounds(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -233,1 +233,1 @@\n-    if (!heap->is_in_bounds(fwd)) {\n+    if (!heap->is_in_reserved(fwd)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  assert(p == nullptr || _heap->is_in_bounds(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_reserved(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -731,6 +731,0 @@\n-bool ShenandoahHeap::is_in_bounds(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n@@ -738,5 +732,9 @@\n-  if (is_in_bounds(p)) {\n-    \/\/ Now check if region is in active state, unless we are moving\n-    \/\/ objects during Full GC across the regions in not yet determinate state.\n-    return is_full_gc_move_in_progress() ||\n-           heap_region_containing(p)->is_active();\n+  if (is_in_reserved(p)) {\n+    if (is_full_gc_move_in_progress()) {\n+      \/\/ Full GC move is running, we do not have a consistent region\n+      \/\/ information yet. But we know the pointer is in heap.\n+      return true;\n+    }\n+    \/\/ Now check if we point to a live section in active region.\n+    ShenandoahHeapRegion* r = heap_region_containing(p);\n+    return (r->is_active() && p < r->top());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -497,0 +497,1 @@\n+  \/\/ Use is_in_reserved to check if object is within heap bounds.\n@@ -499,3 +500,0 @@\n-  \/\/ Check the pointer is within Java heap bounds.\n-  bool is_in_bounds(const void* p) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  assert(ShenandoahHeap::heap()->is_in_bounds(addr),\n+  assert(ShenandoahHeap::heap()->is_in_reserved(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  inline bool is_marked(oop) const;\n+  inline bool is_marked(oop obj) const;\n+  inline bool is_marked(HeapWord* raw_obj) const;\n@@ -68,0 +69,1 @@\n+  inline bool is_marked_strong(HeapWord* raw_obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n+  return is_marked(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked(raw_obj);\n@@ -45,1 +49,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+  return is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked_strong(raw_obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -94,3 +94,3 @@\n-\/\/ Raw referent, it can be dead. You cannot dereference it, only use for nullptr\n-\/\/ and bitmap checks. The decoding uses a special-case inlined CompressedOops::decode\n-\/\/ method that bypasses normal oop-ness checks.\n+\/\/ Raw referent, it can be dead. You cannot treat it as oop without additional safety\n+\/\/ checks, this is why it is HeapWord*. The decoding uses a special-case inlined\n+\/\/ CompressedOops::decode method that bypasses normal oop-ness checks.\n@@ -98,3 +98,3 @@\n-static oop reference_referent_raw(oop reference) {\n-  T heap_oop = Atomic::load(reference_referent_addr<T>(reference));\n-  return reference_coop_decode_raw(heap_oop);\n+static HeapWord* reference_referent_raw(oop reference) {\n+  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  return cast_from_oop<HeapWord*>(reference_coop_decode_raw(raw_oop));\n@@ -292,2 +292,2 @@\n-  const oop referent = reference_referent_raw<T>(reference);\n-  if (referent == nullptr) {\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  if (raw_referent == nullptr) {\n@@ -303,1 +303,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(raw_referent);\n@@ -305,1 +305,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -390,2 +390,2 @@\n-  oop referent = reference_referent_raw<T>(reference);\n-  assert(referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(referent),\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(raw_referent),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  ReferenceIterationMode reference_iteration_mode() {\n+  ReferenceIterationMode reference_iteration_mode() override {\n@@ -126,1 +126,1 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_bounds(obj),\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_reserved(obj),\n@@ -184,1 +184,1 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_bounds(fwd),\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_reserved(fwd),\n@@ -334,2 +334,2 @@\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(oop* p) override { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) override { do_oop_work(p); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}