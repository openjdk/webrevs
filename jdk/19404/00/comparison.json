{"files":[{"patch":"@@ -165,24 +165,0 @@\n-    \/**\n-     * Set the TTL (time-to-live) option.\n-     * @param ttl a byte specifying the TTL value\n-     *\n-     * @deprecated use setTimeToLive instead.\n-     * @throws    IOException if an I\/O exception occurs while setting\n-     * the time-to-live option.\n-     * @see #getTTL()\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    protected abstract void setTTL(byte ttl) throws IOException;\n-\n-    \/**\n-     * Retrieve the TTL (time-to-live) option.\n-     *\n-     * @throws    IOException if an I\/O exception occurs\n-     * while retrieving the time-to-live option\n-     * @deprecated use getTimeToLive instead.\n-     * @return a byte representing the TTL value\n-     * @see #setTTL(byte)\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    protected abstract byte getTTL() throws IOException;\n-\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -214,20 +214,0 @@\n-    \/**\n-     * Set the default time-to-live for multicast packets sent out\n-     * on this {@code MulticastSocket} in order to control the\n-     * scope of the multicasts.\n-     *\n-     * <p>The ttl is an <b>unsigned<\/b> 8-bit quantity, and so <B>must<\/B> be\n-     * in the range {@code 0 <= ttl <= 0xFF }.\n-     *\n-     * @param      ttl the time-to-live\n-     * @throws     IOException if an I\/O exception occurs\n-     *             while setting the default time-to-live value\n-     * @deprecated use the {@link #setTimeToLive(int)} method instead, which uses\n-     *             <b>int<\/b> instead of <b>byte<\/b> as the type for ttl.\n-     * @see #getTTL()\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    public void setTTL(byte ttl) throws IOException {\n-        delegate().setTTL(ttl);\n-    }\n-\n@@ -263,16 +243,0 @@\n-    \/**\n-     * Get the default time-to-live for multicast packets sent out on\n-     * the socket.\n-     *\n-     * @throws    IOException if an I\/O exception occurs\n-     * while getting the default time-to-live value\n-     * @return the default time-to-live value\n-     * @deprecated use the {@link #getTimeToLive()} method instead,\n-     * which returns an <b>int<\/b> instead of a <b>byte<\/b>.\n-     * @see #setTTL(byte)\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.2\")\n-    public byte getTTL() throws IOException {\n-        return delegate().getTTL();\n-    }\n-\n@@ -508,61 +472,0 @@\n-\n-    \/**\n-     * Sends a datagram packet to the destination, with a TTL (time-to-live)\n-     * other than the default for the socket.  This method\n-     * need only be used in instances where a particular TTL is desired;\n-     * otherwise it is preferable to set a TTL once on the socket, and\n-     * use that default TTL for all packets.  This method does <B>not\n-     * <\/B> alter the default TTL for the socket. Its behavior may be\n-     * affected by {@code setInterface}.\n-     *\n-     * <p>If there is a security manager, this method first performs some\n-     * security checks. First, if {@code p.getAddress().isMulticastAddress()}\n-     * is true, this method calls the\n-     * security manager's {@code checkMulticast} method\n-     * with {@code p.getAddress()} and {@code ttl} as its arguments.\n-     * If the evaluation of that expression is false,\n-     * this method instead calls the security manager's\n-     * {@code checkConnect} method with arguments\n-     * {@code p.getAddress().getHostAddress()} and\n-     * {@code p.getPort()}. Each call to a security manager method\n-     * could result in a SecurityException if the operation is not allowed.\n-     *\n-     * @param p is the packet to be sent. The packet should contain\n-     * the destination multicast ip address and the data to be sent.\n-     * One does not need to be the member of the group to send\n-     * packets to a destination multicast address.\n-     * @param ttl optional time to live for multicast packet.\n-     * default ttl is 1.\n-     *\n-     * @throws     IOException is raised if an error occurs i.e\n-     *             error while setting ttl.\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkMulticast} or {@code checkConnect}\n-     *             method doesn't allow the send.\n-     * @throws     PortUnreachableException may be thrown if the socket is connected\n-     *             to a currently unreachable destination. Note, there is no\n-     *             guarantee that the exception will be thrown.\n-     * @throws     IllegalArgumentException if the socket is connected,\n-     *             and connected address and packet address differ, or\n-     *             if the socket is not connected and the packet address\n-     *             is not set or if its port is out of range.\n-     *\n-     *\n-     * @deprecated Use the following code or its equivalent instead:\n-     *  <pre>{@code   ......\n-     *  int ttl = mcastSocket.getOption(StandardSocketOptions.IP_MULTICAST_TTL);\n-     *  mcastSocket.setOption(StandardSocketOptions.IP_MULTICAST_TTL, newttl);\n-     *  mcastSocket.send(p);\n-     *  mcastSocket.setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n-     *  ......}<\/pre>\n-     *\n-     * @see DatagramSocket#send\n-     * @see DatagramSocket#receive\n-     * @see SecurityManager#checkMulticast(java.net.InetAddress, byte)\n-     * @see SecurityManager#checkConnect\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"1.4\")\n-    public void send(DatagramPacket p, byte ttl)\n-        throws IOException {\n-        delegate().send(p, ttl);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import java.nio.channels.DatagramChannel;\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n@@ -653,8 +650,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public void setTTL(byte ttl) throws IOException {\n-        if (isClosed())\n-            throw new SocketException(\"Socket is closed\");\n-        getImpl().setTTL(ttl);\n-    }\n-\n@@ -671,8 +660,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public byte getTTL() throws IOException {\n-        if (isClosed())\n-            throw new SocketException(\"Socket is closed\");\n-        return getImpl().getTTL();\n-    }\n-\n@@ -885,58 +866,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    @Override\n-    public void send(DatagramPacket p, byte ttl)\n-            throws IOException {\n-        if (isClosed())\n-            throw new SocketException(\"Socket is closed\");\n-        synchronized(ttlLock) {\n-            synchronized(p) {\n-                InetAddress packetAddress = p.getAddress();\n-                checkAddress(packetAddress, \"send\");\n-                if (connectState == NetMulticastSocket.ST_NOT_CONNECTED) {\n-                    if (packetAddress == null) {\n-                        throw new IllegalArgumentException(\"Address not set\");\n-                    }\n-                    \/\/ Security manager makes sure that the multicast address\n-                    \/\/ is allowed one and that the ttl used is less\n-                    \/\/ than the allowed maxttl.\n-                    SecurityManager security = System.getSecurityManager();\n-                    if (security != null) {\n-                        if (packetAddress.isMulticastAddress()) {\n-                            security.checkMulticast(packetAddress, ttl);\n-                        } else {\n-                            security.checkConnect(packetAddress.getHostAddress(),\n-                                    p.getPort());\n-                        }\n-                    }\n-                } else {\n-                    \/\/ we're connected\n-                    if (packetAddress == null) {\n-                        p.setAddress(connectedAddress);\n-                        p.setPort(connectedPort);\n-                    } else if ((!packetAddress.equals(connectedAddress)) ||\n-                            p.getPort() != connectedPort) {\n-                        throw new IllegalArgumentException(\"connected address and packet address\" +\n-                                \" differ\");\n-                    }\n-                }\n-                byte dttl = getTTL();\n-                try {\n-                    if (ttl != dttl) {\n-                        \/\/ set the ttl\n-                        getImpl().setTTL(ttl);\n-                    }\n-                    if (p.getPort() == 0) {\n-                        throw new SocketException(\"Can't send to port 0\");\n-                    }\n-                    \/\/ call the datagram method to send\n-                    getImpl().send(p);\n-                } finally {\n-                    \/\/ set it back to default\n-                    if (ttl != dttl) {\n-                        getImpl().setTTL(dttl);\n-                    }\n-                }\n-            } \/\/ synch p\n-        }  \/\/synch ttl\n-    } \/\/method\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetMulticastSocket.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -403,6 +403,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public void setTTL(byte ttl) throws IOException {\n-        setTimeToLive(Byte.toUnsignedInt(ttl));\n-    }\n-\n@@ -419,6 +413,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public byte getTTL() throws IOException {\n-        return (byte) getTimeToLive();\n-    }\n-\n@@ -594,17 +582,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    public void send(DatagramPacket p, byte ttl) throws IOException {\n-        sendLock.lock();\n-        try {\n-            int oldValue = getTimeToLive();\n-            try {\n-                setTTL(ttl);\n-                send(p);\n-            } finally {\n-                setTimeToLive(oldValue);\n-            }\n-        } finally {\n-            sendLock.unlock();\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"}]}