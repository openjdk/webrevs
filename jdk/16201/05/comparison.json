{"files":[{"patch":"@@ -39,57 +39,0 @@\n-class DowncallStubGenerator : public StubCodeGenerator {\n-  BasicType* _signature;\n-  int _num_args;\n-  BasicType _ret_bt;\n-  const ABIDescriptor& _abi;\n-\n-  const GrowableArray<VMStorage>& _input_registers;\n-  const GrowableArray<VMStorage>& _output_registers;\n-\n-  bool _needs_return_buffer;\n-  int _captured_state_mask;\n-  bool _needs_transition;\n-\n-  int _frame_complete;\n-  int _frame_size_slots;\n-  OopMapSet* _oop_maps;\n-public:\n-  DowncallStubGenerator(CodeBuffer* buffer,\n-                         BasicType* signature,\n-                         int num_args,\n-                         BasicType ret_bt,\n-                         const ABIDescriptor& abi,\n-                         const GrowableArray<VMStorage>& input_registers,\n-                         const GrowableArray<VMStorage>& output_registers,\n-                         bool needs_return_buffer,\n-                         int captured_state_mask,\n-                         bool needs_transition)\n-   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n-     _signature(signature),\n-     _num_args(num_args),\n-     _ret_bt(ret_bt),\n-     _abi(abi),\n-     _input_registers(input_registers),\n-     _output_registers(output_registers),\n-     _needs_return_buffer(needs_return_buffer),\n-     _captured_state_mask(captured_state_mask),\n-     _needs_transition(needs_transition),\n-     _frame_complete(0),\n-     _frame_size_slots(0),\n-     _oop_maps(nullptr) {\n-  }\n-\n-  void generate();\n-\n-  int frame_complete() const {\n-    return _frame_complete;\n-  }\n-\n-  int framesize() const {\n-    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n-  }\n-\n-  OopMapSet* oop_maps() const {\n-    return _oop_maps;\n-  }\n-};\n-\n@@ -111,4 +54,4 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n-                          input_registers, output_registers,\n-                          needs_return_buffer, captured_state_mask,\n-                          needs_transition);\n+  StubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                  input_registers, output_registers,\n+                  needs_return_buffer, captured_state_mask,\n+                  needs_transition);\n@@ -137,1 +80,33 @@\n-void DowncallStubGenerator::generate() {\n+static constexpr int RFP_BIAS = 16; \/\/ skip old rbp and return address\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset, VMStorage tmp1, VMStorage tmp2) const {\n+  Register r_tmp1 = as_Register(tmp1);\n+  Register r_tmp2 = as_Register(tmp2);\n+  if (reg_oop.is_reg()) {\n+    assert(reg_oop.type() == StorageType::INTEGER, \"expected\");\n+    Register reg_oop_reg = as_Register(reg_oop);\n+    if (reg_offset.is_reg()) {\n+      assert(reg_offset.type() == StorageType::INTEGER, \"expected\");\n+      __ add(reg_oop_reg, reg_oop_reg, as_Register(reg_offset));\n+    } else {\n+      assert(reg_offset.is_stack(), \"expected\");\n+      assert(reg_offset.stack_size() == 8, \"expected long\");\n+      Address offset_addr(rfp, RFP_BIAS + reg_offset.offset());\n+      __ ldr (r_tmp1, offset_addr);\n+      __ add(reg_oop_reg, reg_oop_reg, r_tmp1);\n+    }\n+  } else {\n+    assert(reg_oop.is_stack(), \"expected\");\n+    assert(reg_oop.stack_size() == 8, \"expected long\");\n+    assert(reg_offset.is_stack(), \"expected\");\n+    assert(reg_offset.stack_size() == 8, \"expected long\");\n+    Address offset_addr(rfp, RFP_BIAS + reg_offset.offset());\n+    Address oop_addr(rfp, RFP_BIAS + reg_oop.offset());\n+    __ ldr(r_tmp1, offset_addr);\n+    __ ldr(r_tmp2, oop_addr);\n+    __ add(r_tmp1, r_tmp1, r_tmp2);\n+    __ str(r_tmp1, oop_addr);\n+  }\n+}\n+\n+void DowncallLinker::StubGenerator::generate() {\n@@ -153,13 +128,6 @@\n-  VMStorage shuffle_reg = as_VMStorage(r19);\n-  JavaCallingConvention in_conv;\n-  NativeCallingConvention out_conv(_input_registers);\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, downcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n+  GrowableArray<VMStorage> java_regs;\n+  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n+  bool has_objects = false;\n+  GrowableArray<VMStorage> filtered_java_regs = ForeignGlobals::downcall_filter_offset_regs(java_regs, _signature,\n+                                                                                             _num_args, has_objects);\n+  assert(!(_needs_transition && has_objects), \"can not pass objects when doing transition\");\n@@ -169,1 +137,1 @@\n-  allocated_frame_size += arg_shuffle.out_arg_bytes();\n+  allocated_frame_size += ForeignGlobals::compute_out_arg_bytes(_input_registers);\n@@ -196,0 +164,27 @@\n+  \/\/ The space we have allocated will look like:\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      | (optional)          |\n+  \/\/      | capture state buf   |\n+  \/\/      |---------------------| = StubLocations::CAPTURED_STATE_BUFFER\n+  \/\/      | (optional)          |\n+  \/\/      | return buffer       |\n+  \/\/      |---------------------| = StubLocations::RETURN_BUFFER\n+  \/\/ SP-> | out\/stack args      | or | out_reg_spiller area |\n+  \/\/\n+  \/\/ Note how the last chunk can be shared, since the 3 uses occur at different times.\n+\n+  VMStorage shuffle_reg = as_VMStorage(r19);\n+  GrowableArray<VMStorage> out_regs = ForeignGlobals::replace_place_holders(_input_registers, locs);\n+  ArgumentShuffle arg_shuffle(filtered_java_regs, out_regs, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -221,0 +216,4 @@\n+  if (has_objects) {\n+    add_offsets_to_oops(java_regs, as_VMStorage(tmp1), as_VMStorage(tmp2));\n+  }\n+\n@@ -222,1 +221,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":76,"deletions":77,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -210,8 +210,0 @@\n-    \/\/ replace any placeholders\n-    if (from_reg.type() == StorageType::PLACEHOLDER) {\n-      from_reg = locs.get(from_reg);\n-    }\n-    if (to_reg.type() == StorageType::PLACEHOLDER) {\n-      to_reg = locs.get(to_reg);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n@@ -129,1 +128,1 @@\n-  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  int code_size = upcall_stub_code_base_size + (total_out_args * upcall_stub_size_per_arg);\n@@ -132,4 +131,2 @@\n-  Register shuffle_reg = r19;\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, as_VMStorage(shuffle_reg));\n+  GrowableArray<VMStorage> unfiltered_out_regs;\n+  int out_arg_bytes = ForeignGlobals::java_calling_convention(out_sig_bt, total_out_args, unfiltered_out_regs);\n@@ -137,1 +134,1 @@\n-  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int stack_bytes = preserved_bytes + out_arg_bytes;\n@@ -140,9 +137,0 @@\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n@@ -156,1 +144,1 @@\n-  RegSpiller arg_spilller(call_regs._arg_regs);\n+  RegSpiller arg_spiller(call_regs._arg_regs);\n@@ -162,1 +150,1 @@\n-  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_spiller.spill_size_bytes();\n@@ -176,0 +164,14 @@\n+  Register shuffle_reg = r19;\n+  GrowableArray<VMStorage> in_regs = ForeignGlobals::replace_place_holders(call_regs._arg_regs, locs);\n+  GrowableArray<VMStorage> filtered_out_regs = ForeignGlobals::upcall_filter_receiver_reg(unfiltered_out_regs);\n+  ArgumentShuffle arg_shuffle(in_regs, filtered_out_regs, as_VMStorage(shuffle_reg));\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -215,1 +217,1 @@\n-  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n+  arg_spiller.generate_spill(_masm, arg_save_area_offset);\n@@ -227,1 +229,1 @@\n-  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n+  arg_spiller.generate_fill(_masm, arg_save_area_offset);\n@@ -232,1 +234,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0, locs);\n+  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -41,0 +41,5 @@\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n","filename":"src\/hotspot\/cpu\/arm\/upcallLinker_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,57 +39,0 @@\n-class DowncallStubGenerator : public StubCodeGenerator {\n-  BasicType* _signature;\n-  int _num_args;\n-  BasicType _ret_bt;\n-  const ABIDescriptor& _abi;\n-\n-  const GrowableArray<VMStorage>& _input_registers;\n-  const GrowableArray<VMStorage>& _output_registers;\n-\n-  bool _needs_return_buffer;\n-  int _captured_state_mask;\n-  bool _needs_transition;\n-\n-  int _frame_complete;\n-  int _frame_size_slots;\n-  OopMapSet* _oop_maps;\n-public:\n-  DowncallStubGenerator(CodeBuffer* buffer,\n-                         BasicType* signature,\n-                         int num_args,\n-                         BasicType ret_bt,\n-                         const ABIDescriptor& abi,\n-                         const GrowableArray<VMStorage>& input_registers,\n-                         const GrowableArray<VMStorage>& output_registers,\n-                         bool needs_return_buffer,\n-                         int captured_state_mask,\n-                         bool needs_transition)\n-   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n-     _signature(signature),\n-     _num_args(num_args),\n-     _ret_bt(ret_bt),\n-     _abi(abi),\n-     _input_registers(input_registers),\n-     _output_registers(output_registers),\n-     _needs_return_buffer(needs_return_buffer),\n-     _captured_state_mask(captured_state_mask),\n-     _needs_transition(needs_transition),\n-     _frame_complete(0),\n-     _frame_size_slots(0),\n-     _oop_maps(nullptr) {\n-  }\n-\n-  void generate();\n-\n-  int frame_complete() const {\n-    return _frame_complete;\n-  }\n-\n-  int framesize() const {\n-    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n-  }\n-\n-  OopMapSet* oop_maps() const {\n-    return _oop_maps;\n-  }\n-};\n-\n@@ -111,4 +54,4 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n-                          input_registers, output_registers,\n-                          needs_return_buffer, captured_state_mask,\n-                          needs_transition);\n+  StubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                  input_registers, output_registers,\n+                  needs_return_buffer, captured_state_mask,\n+                  needs_transition);\n@@ -137,15 +80,28 @@\n-void DowncallStubGenerator::generate() {\n-  Register callerSP            = R2, \/\/ C\/C++ uses R2 as TOC, but we can reuse it here\n-           tmp                 = R11_scratch1, \/\/ same as shuffle_reg\n-           call_target_address = R12_scratch2; \/\/ same as _abi._scratch2 (ABIv2 requires this reg!)\n-  VMStorage shuffle_reg = _abi._scratch1;\n-  JavaCallingConvention in_conv;\n-  NativeCallingConvention out_conv(_input_registers);\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, downcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n+static constexpr int FP_BIAS = frame::jit_out_preserve_size;\n+static const Register callerSP = R2; \/\/ C\/C++ uses R2 as TOC, but we can reuse it here\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Register r_tmp1 = as_Register(tmp1);\n+  Register r_tmp2 = as_Register(tmp2);\n+  if (reg_oop.is_reg()) {\n+    assert(reg_oop.type() == StorageType::INTEGER, \"expected\");\n+    Register reg_oop_reg = as_Register(reg_oop);\n+    if (reg_offset.is_reg()) {\n+      assert(reg_offset.type() == StorageType::INTEGER, \"expected\");\n+      __ add(reg_oop_reg, reg_oop_reg, as_Register(reg_offset));\n+    } else {\n+      assert(reg_offset.is_stack(), \"expected\");\n+      assert(reg_offset.stack_size() == 8, \"expected long\");\n+      __ ld(r_tmp1, reg_offset.offset() + FP_BIAS, callerSP);\n+      __ add(reg_oop_reg, reg_oop_reg, r_tmp1);\n+    }\n+  } else {\n+    assert(reg_oop.is_stack(), \"expected\");\n+    assert(reg_oop.stack_size() == 8, \"expected long\");\n+    assert(reg_offset.is_stack(), \"expected\");\n+    assert(reg_offset.stack_size() == 8, \"expected long\");\n+    __ ld(r_tmp1, reg_offset.offset() + FP_BIAS, callerSP);\n+    __ ld(r_tmp2, reg_oop.offset() + FP_BIAS, callerSP);\n+    __ add(r_tmp1, r_tmp2, r_tmp1);\n+    __ std(r_tmp1, reg_oop.offset() + FP_BIAS, callerSP);\n@@ -153,1 +109,5 @@\n-#endif\n+}\n+\n+void DowncallLinker::StubGenerator::generate() {\n+  Register tmp                 = R11_scratch1, \/\/ same as shuffle_reg\n+           call_target_address = R12_scratch2; \/\/ same as _abi._scratch2 (ABIv2 requires this reg!)\n@@ -194,0 +154,20 @@\n+  GrowableArray<VMStorage> java_regs;\n+  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n+  bool has_objects = false;\n+  GrowableArray<VMStorage> filtered_java_regs = ForeignGlobals::downcall_filter_offset_regs(java_regs, _signature,\n+                                                                                             _num_args, has_objects);\n+  assert(!(_needs_transition && has_objects), \"can not pass objects when doing transition\");\n+\n+  GrowableArray<VMStorage> out_regs = ForeignGlobals::replace_place_holders(_input_registers, locs);\n+\n+  ArgumentShuffle arg_shuffle(filtered_java_regs, out_regs, _abi._scratch1);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -219,0 +199,4 @@\n+  if (has_objects) {\n+    add_offsets_to_oops(java_regs, _abi._scratch1, _abi._scratch2);\n+  }\n+\n@@ -220,1 +204,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(callerSP), frame::jit_out_preserve_size, frame::native_abi_minframe_size, locs);\n+  arg_shuffle.generate(_masm, as_VMStorage(callerSP), frame::jit_out_preserve_size, frame::native_abi_minframe_size);\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":62,"deletions":78,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -240,8 +240,0 @@\n-    \/\/ replace any placeholders\n-    if (from_reg.type() == StorageType::PLACEHOLDER) {\n-      from_reg = locs.get(from_reg);\n-    }\n-    if (to_reg.type() == StorageType::PLACEHOLDER) {\n-      to_reg = locs.get(to_reg);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n@@ -130,1 +129,1 @@\n-  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  int code_size = upcall_stub_code_base_size + (total_out_args * upcall_stub_size_per_arg);\n@@ -136,4 +135,2 @@\n-  VMStorage shuffle_reg = abi._scratch1;\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg);\n+  GrowableArray<VMStorage> unfiltered_out_regs;\n+  int out_arg_bytes = ForeignGlobals::java_calling_convention(out_sig_bt, total_out_args, unfiltered_out_regs);\n@@ -141,10 +138,1 @@\n-  int out_arg_area = MAX2(frame::jit_out_preserve_size + arg_shuffle.out_arg_bytes(), (int)frame::native_abi_reg_args_size);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n+  int out_arg_area = MAX2(frame::jit_out_preserve_size + out_arg_bytes, (int)frame::native_abi_reg_args_size);\n@@ -172,0 +160,13 @@\n+  GrowableArray<VMStorage> in_regs = ForeignGlobals::replace_place_holders(call_regs._arg_regs, locs);\n+  GrowableArray<VMStorage> filtered_out_regs = ForeignGlobals::upcall_filter_receiver_reg(unfiltered_out_regs);\n+  ArgumentShuffle arg_shuffle(in_regs, filtered_out_regs, abi._scratch1);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -231,1 +232,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(callerSP), frame::native_abi_minframe_size, frame::jit_out_preserve_size, locs);\n+  arg_shuffle.generate(_masm, as_VMStorage(callerSP), frame::native_abi_minframe_size, frame::jit_out_preserve_size);\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Unimplemented();\n+}\n+\n@@ -150,14 +155,0 @@\n-  VMStorage shuffle_reg = as_VMStorage(x9);\n-  JavaCallingConvention in_conv;\n-  NativeCallingConvention out_conv(_input_registers);\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, downcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n@@ -166,1 +157,1 @@\n-  allocated_frame_size += arg_shuffle.out_arg_bytes();\n+  allocated_frame_size += ForeignGlobals::compute_out_arg_bytes(_input_registers);\n@@ -193,0 +184,15 @@\n+  VMStorage shuffle_reg = as_VMStorage(x9);\n+  GrowableArray<VMStorage> java_regs;\n+  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n+  GrowableArray<VMStorage> out_regs = ForeignGlobals::replace_place_holders(_input_registers, locs);\n+  ArgumentShuffle arg_shuffle(java_regs, out_regs, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -223,1 +229,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -173,8 +173,0 @@\n-    \/\/ replace any placeholders\n-    if (from_reg.type() == StorageType::PLACEHOLDER) {\n-      from_reg = locs.get(from_reg);\n-    }\n-    if (to_reg.type() == StorageType::PLACEHOLDER) {\n-      to_reg = locs.get(to_reg);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n@@ -130,1 +129,1 @@\n-  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  int code_size = upcall_stub_code_base_size + (total_out_args * upcall_stub_size_per_arg);\n@@ -133,4 +132,2 @@\n-  Register shuffle_reg = x9;\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, as_VMStorage(shuffle_reg));\n+  GrowableArray<VMStorage> unfiltered_out_regs;\n+  int out_arg_bytes = ForeignGlobals::java_calling_convention(out_sig_bt, total_out_args, unfiltered_out_regs);\n@@ -138,1 +135,1 @@\n-  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int stack_bytes = preserved_bytes + out_arg_bytes;\n@@ -141,9 +138,0 @@\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n@@ -177,0 +165,14 @@\n+  Register shuffle_reg = x9;\n+  GrowableArray<VMStorage> in_regs = ForeignGlobals::replace_place_holders(call_regs._arg_regs, locs);\n+  GrowableArray<VMStorage> filtered_out_regs = ForeignGlobals::upcall_filter_receiver_reg(unfiltered_out_regs);\n+  ArgumentShuffle arg_shuffle(in_regs, filtered_out_regs, as_VMStorage(shuffle_reg));\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -254,1 +256,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0, locs);\n+  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0);\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -94,0 +94,5 @@\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Unimplemented();\n+}\n+\n@@ -141,15 +146,0 @@\n-  VMStorage shuffle_reg = _abi._scratch1;\n-\n-  JavaCallingConvention in_conv;\n-  NativeCallingConvention out_conv(_input_registers);\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, downcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n@@ -158,1 +148,1 @@\n-  allocated_frame_size += arg_shuffle.out_arg_bytes();\n+  allocated_frame_size += ForeignGlobals::compute_out_arg_bytes(_input_registers);\n@@ -175,0 +165,15 @@\n+  VMStorage shuffle_reg = _abi._scratch1;\n+  GrowableArray<VMStorage> java_regs;\n+  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n+  GrowableArray<VMStorage> out_regs = ForeignGlobals::replace_place_holders(_input_registers, locs);\n+  ArgumentShuffle arg_shuffle(java_regs, out_regs, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -200,1 +205,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, frame::z_jit_out_preserve_size, _abi._shadow_space_bytes, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, frame::z_jit_out_preserve_size, _abi._shadow_space_bytes);\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -210,8 +210,0 @@\n-    \/\/ replace any placeholders\n-    if (from_reg.type() == StorageType::PLACEHOLDER) {\n-      from_reg = locs.get(from_reg);\n-    }\n-    if (to_reg.type() == StorageType::PLACEHOLDER) {\n-      to_reg = locs.get(to_reg);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n@@ -128,1 +127,1 @@\n-  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  int code_size = upcall_stub_code_base_size + (total_out_args * upcall_stub_size_per_arg);\n@@ -133,4 +132,2 @@\n-  VMStorage shuffle_reg = abi._scratch1;\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg);\n+  GrowableArray<VMStorage> unfiltered_out_regs;\n+  int out_arg_bytes = ForeignGlobals::java_calling_convention(out_sig_bt, total_out_args, unfiltered_out_regs);\n@@ -139,11 +136,1 @@\n-  int out_arg_area = MAX2(frame::z_jit_out_preserve_size + arg_shuffle.out_arg_bytes(), (int)frame::z_abi_160_size);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n+  int out_arg_area = MAX2(frame::z_jit_out_preserve_size + out_arg_bytes, (int)frame::z_abi_160_size);\n@@ -161,1 +148,0 @@\n-  int frame_size = align_up(frame_bottom_offset, StackAlignmentInBytes);\n@@ -163,0 +149,15 @@\n+  VMStorage shuffle_reg = abi._scratch1;\n+  GrowableArray<VMStorage> in_regs = ForeignGlobals::replace_place_holders(call_regs._arg_regs, locs);\n+  GrowableArray<VMStorage> filtered_out_regs = ForeignGlobals::upcall_filter_receiver_reg(unfiltered_out_regs);\n+  ArgumentShuffle arg_shuffle(in_regs, filtered_out_regs, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n+  int frame_size = align_up(frame_bottom_offset, StackAlignmentInBytes);\n@@ -211,1 +212,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, frame::z_jit_out_preserve_size, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, frame::z_jit_out_preserve_size);\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -38,57 +37,0 @@\n-class DowncallStubGenerator : public StubCodeGenerator {\n-  BasicType* _signature;\n-  int _num_args;\n-  BasicType _ret_bt;\n-\n-  const ABIDescriptor& _abi;\n-  const GrowableArray<VMStorage>& _input_registers;\n-  const GrowableArray<VMStorage>& _output_registers;\n-\n-  bool _needs_return_buffer;\n-  int _captured_state_mask;\n-  bool _needs_transition;\n-\n-  int _frame_complete;\n-  int _frame_size_slots;\n-  OopMapSet* _oop_maps;\n-public:\n-  DowncallStubGenerator(CodeBuffer* buffer,\n-                         BasicType* signature,\n-                         int num_args,\n-                         BasicType ret_bt,\n-                         const ABIDescriptor& abi,\n-                         const GrowableArray<VMStorage>& input_registers,\n-                         const GrowableArray<VMStorage>& output_registers,\n-                         bool needs_return_buffer,\n-                         int captured_state_mask,\n-                         bool needs_transition)\n-   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n-     _signature(signature),\n-     _num_args(num_args),\n-     _ret_bt(ret_bt),\n-     _abi(abi),\n-     _input_registers(input_registers),\n-     _output_registers(output_registers),\n-     _needs_return_buffer(needs_return_buffer),\n-     _captured_state_mask(captured_state_mask),\n-     _needs_transition(needs_transition),\n-     _frame_complete(0),\n-     _frame_size_slots(0),\n-     _oop_maps(nullptr) {\n-  }\n-\n-  void generate();\n-\n-  int frame_complete() const {\n-    return _frame_complete;\n-  }\n-\n-  int framesize() const { \/\/ frame size in 64-bit words\n-    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n-  }\n-\n-  OopMapSet* oop_maps() const {\n-    return _oop_maps;\n-  }\n-};\n-\n@@ -110,4 +52,4 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n-                          input_registers, output_registers,\n-                          needs_return_buffer, captured_state_mask,\n-                          needs_transition);\n+  StubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                  input_registers, output_registers,\n+                  needs_return_buffer, captured_state_mask,\n+                  needs_transition);\n@@ -136,1 +78,35 @@\n-void DowncallStubGenerator::generate() {\n+static constexpr int RBP_BIAS = 16; \/\/ skip old rbp and return address\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  if (reg_oop.is_reg()) {\n+    assert(reg_oop.type() == StorageType::INTEGER, \"expected\");\n+    if (reg_offset.is_reg()) {\n+      assert(reg_offset.type() == StorageType::INTEGER, \"expected\");\n+      __ addptr(as_Register(reg_oop), as_Register(reg_offset));\n+    } else {\n+      assert(reg_offset.is_stack(), \"expected\");\n+      Address offset_addr(rbp, RBP_BIAS + reg_offset.offset());\n+      __ addptr(as_Register(reg_oop), offset_addr);\n+    }\n+  } else {\n+    assert(reg_oop.is_stack(), \"expected\");\n+    assert(reg_offset.is_stack(), \"expected\");\n+    Address offset_addr(rbp, RBP_BIAS + reg_offset.offset());\n+    Address oop_addr(rbp, RBP_BIAS + reg_oop.offset());\n+    __ movptr(as_Register(tmp1), offset_addr);\n+    __ addptr(oop_addr, as_Register(tmp1));\n+  }\n+}\n+\n+static void runtime_call(MacroAssembler* _masm, address target) {\n+  __ vzeroupper();\n+  __ mov(r12, rsp); \/\/ remember sp\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+  __ call(RuntimeAddress(target));\n+  __ mov(rsp, r12); \/\/ restore sp\n+  __ reinit_heapbase();\n+}\n+\n+void DowncallLinker::StubGenerator::generate() {\n@@ -149,13 +125,6 @@\n-  VMStorage shuffle_reg = as_VMStorage(rbx);\n-  JavaCallingConvention in_conv;\n-  NativeCallingConvention out_conv(_input_registers);\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, downcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n+  GrowableArray<VMStorage> java_regs;\n+  ForeignGlobals::java_calling_convention(_signature, _num_args, java_regs);\n+  bool has_objects = false;\n+  GrowableArray<VMStorage> filtered_java_regs = ForeignGlobals::downcall_filter_offset_regs(java_regs, _signature,\n+                                                                                             _num_args, has_objects);\n+  assert(!(_needs_transition && has_objects), \"can not pass objects when doing transition\");\n@@ -166,1 +135,1 @@\n-  allocated_frame_size += arg_shuffle.out_arg_bytes();\n+  allocated_frame_size += ForeignGlobals::compute_out_arg_bytes(_input_registers);\n@@ -194,0 +163,29 @@\n+  \/\/ The space we have allocated will look like:\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      | (optional)          |\n+  \/\/      | capture state buf   |\n+  \/\/      |---------------------| = StubLocations::CAPTURED_STATE_BUFFER\n+  \/\/      | (optional)          |\n+  \/\/      | return buffer       |\n+  \/\/      |---------------------| = StubLocations::RETURN_BUFFER\n+  \/\/      | out\/stack args      |    |                      |\n+  \/\/      |---------------------| or | ret. val. spill area |\n+  \/\/ SP-> | shadow space        |    |                      |\n+  \/\/\n+  \/\/ Note how the last chunk can be shared, since the 3 uses occur at different times.\n+\n+  GrowableArray<VMStorage> out_regs = ForeignGlobals::replace_place_holders(_input_registers, locs);\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n+  ArgumentShuffle arg_shuffle(filtered_java_regs, out_regs, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, downcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -222,0 +220,4 @@\n+  if (has_objects) {\n+    add_offsets_to_oops(java_regs, as_VMStorage(rscratch1), VMStorage::invalid());\n+  }\n+\n@@ -223,1 +225,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n@@ -227,1 +229,1 @@\n-  \/\/ this call is assumed not to have killed r15_thread\n+  assert(!_abi.is_volatile_reg(r15_thread), \"Call assumed not to kill r15\");\n@@ -250,1 +252,0 @@\n-    __ vzeroupper();\n@@ -258,6 +259,1 @@\n-    __ mov(r12, rsp); \/\/ remember sp\n-    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, DowncallLinker::capture_state)));\n-    __ mov(rsp, r12); \/\/ restore sp\n-    __ reinit_heapbase();\n+    runtime_call(_masm, CAST_FROM_FN_PTR(address, DowncallLinker::capture_state));\n@@ -317,1 +313,0 @@\n-    __ vzeroupper();\n@@ -324,6 +319,1 @@\n-    __ mov(r12, rsp); \/\/ remember sp\n-    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-    __ mov(rsp, r12); \/\/ restore sp\n-    __ reinit_heapbase();\n+    runtime_call(_masm, CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n@@ -342,1 +332,0 @@\n-    __ vzeroupper();\n@@ -348,6 +337,1 @@\n-    __ mov(r12, rsp); \/\/ remember sp\n-    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-    __ mov(rsp, r12); \/\/ restore sp\n-    __ reinit_heapbase();\n+    runtime_call(_masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":84,"deletions":100,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -172,8 +172,0 @@\n-    \/\/ replace any placeholders\n-    if (from_reg.type() == StorageType::PLACEHOLDER) {\n-      from_reg = locs.get(from_reg);\n-    }\n-    if (to_reg.type() == StorageType::PLACEHOLDER) {\n-      to_reg = locs.get(to_reg);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_32.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,0 @@\n-                                       BasicType* in_sig_bt, int total_in_args,\n@@ -179,1 +178,1 @@\n-  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  int code_size = upcall_stub_code_base_size + (total_out_args * upcall_stub_size_per_arg);\n@@ -182,4 +181,2 @@\n-  VMStorage shuffle_reg = as_VMStorage(rbx);\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg);\n+  GrowableArray<VMStorage> unfiltered_out_regs;\n+  int out_arg_bytes = ForeignGlobals::java_calling_convention(out_sig_bt, total_out_args, unfiltered_out_regs);\n@@ -187,1 +184,1 @@\n-  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int stack_bytes = preserved_bytes + out_arg_bytes;\n@@ -190,9 +187,0 @@\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n@@ -206,1 +194,1 @@\n-  RegSpiller arg_spilller(call_regs._arg_regs);\n+  RegSpiller arg_spiller(call_regs._arg_regs);\n@@ -212,1 +200,1 @@\n-  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_spiller.spill_size_bytes();\n@@ -226,0 +214,14 @@\n+  VMStorage shuffle_reg = as_VMStorage(rbx);\n+  GrowableArray<VMStorage> in_regs = ForeignGlobals::replace_place_holders(call_regs._arg_regs, locs);\n+  GrowableArray<VMStorage> filtered_out_regs = ForeignGlobals::upcall_filter_receiver_reg(unfiltered_out_regs);\n+  ArgumentShuffle arg_shuffle(in_regs, filtered_out_regs, shuffle_reg);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n@@ -268,1 +270,1 @@\n-  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n+  arg_spiller.generate_spill(_masm, arg_save_area_offset);\n@@ -282,1 +284,1 @@\n-  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n+  arg_spiller.generate_fill(_masm, arg_save_area_offset);\n@@ -287,1 +289,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, 0, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, 0);\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+\n+void DowncallLinker::StubGenerator::pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset,\n+                                                         VMStorage tmp1, VMStorage tmp2) const {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n-                                       BasicType* in_sig_bt, int total_in_args,\n+address UpcallLinker::make_upcall_stub(jobject mh, Method* entry,\n","filename":"src\/hotspot\/cpu\/zero\/upcallLinker_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    log_debug_jni(\"Blocked from entering critical section while waiting on GC.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -33,1 +35,2 @@\n-void DowncallLinker::capture_state(int32_t* value_ptr, int captured_state_mask) {\n+\/\/ We call this from _thread_in_native, right after a downcall\n+JVM_LEAF(void, DowncallLinker::capture_state(int32_t* value_ptr, int captured_state_mask))\n@@ -54,0 +57,15 @@\n+JVM_END\n+\n+void DowncallLinker::StubGenerator::add_offsets_to_oops(GrowableArray<VMStorage>& java_regs, VMStorage tmp1, VMStorage tmp2) const {\n+  int reg_idx = 0;\n+  for (int sig_idx = 0; sig_idx < _num_args; sig_idx++) {\n+    if (_signature[sig_idx] == T_OBJECT) {\n+      assert(_signature[sig_idx + 1] == T_LONG, \"expected offset after oop\");\n+      VMStorage reg_oop = java_regs.at(reg_idx++);\n+      VMStorage reg_offset = java_regs.at(reg_idx++);\n+      sig_idx++; \/\/ skip offset\n+      pd_add_offset_to_oop(reg_oop, reg_offset, tmp1, tmp2);\n+    } else if (_signature[sig_idx] != T_VOID) {\n+      reg_idx++;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -44,0 +45,54 @@\n+\n+  class StubGenerator : public StubCodeGenerator {\n+    BasicType* _signature;\n+    int _num_args;\n+    BasicType _ret_bt;\n+\n+    const ABIDescriptor& _abi;\n+    const GrowableArray<VMStorage>& _input_registers;\n+    const GrowableArray<VMStorage>& _output_registers;\n+\n+    bool _needs_return_buffer;\n+    int _captured_state_mask;\n+    bool _needs_transition;\n+\n+    int _frame_complete;\n+    int _frame_size_slots;\n+    OopMapSet* _oop_maps;\n+  public:\n+    StubGenerator(CodeBuffer* buffer,\n+                  BasicType* signature,\n+                  int num_args,\n+                  BasicType ret_bt,\n+                  const ABIDescriptor& abi,\n+                  const GrowableArray<VMStorage>& input_registers,\n+                  const GrowableArray<VMStorage>& output_registers,\n+                  bool needs_return_buffer,\n+                  int captured_state_mask,\n+                  bool needs_transition)\n+    : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n+      _signature(signature),\n+      _num_args(num_args),\n+      _ret_bt(ret_bt),\n+      _abi(abi),\n+      _input_registers(input_registers),\n+      _output_registers(output_registers),\n+      _needs_return_buffer(needs_return_buffer),\n+      _captured_state_mask(captured_state_mask),\n+      _needs_transition(needs_transition),\n+      _frame_complete(0),\n+      _frame_size_slots(0),\n+      _oop_maps(nullptr) {\n+    }\n+\n+    void generate();\n+\n+    int frame_complete() const { return _frame_complete; }\n+    \/\/ frame size in words\n+    int framesize() const { return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt)); }\n+\n+    OopMapSet* oop_maps() const { return _oop_maps; }\n+\n+    void pd_add_offset_to_oop(VMStorage reg_oop, VMStorage reg_offset, VMStorage tmp1, VMStorage tmp2) const;\n+    void add_offsets_to_oops(GrowableArray<VMStorage>& java_regs, VMStorage tmp1, VMStorage tmp2) const;\n+  };\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-  os->print_cr(\"Stack argument bytes: %d\", _out_arg_bytes);\n@@ -133,2 +132,1 @@\n-int NativeCallingConvention::calling_convention(const BasicType* sig_bt, VMStorage* out_regs, int num_args) const {\n-  int src_pos = 0;\n+int ForeignGlobals::compute_out_arg_bytes(const GrowableArray<VMStorage>& out_regs) {\n@@ -136,31 +134,3 @@\n-  for (int i = 0; i < num_args; i++) {\n-    switch (sig_bt[i]) {\n-      case T_BOOLEAN:\n-      case T_CHAR:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_INT:\n-      case T_FLOAT: {\n-        VMStorage reg = _input_regs.at(src_pos++);\n-        out_regs[i] = reg;\n-        if (reg.is_stack())\n-          max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n-        break;\n-      }\n-      case T_LONG:\n-      case T_DOUBLE: {\n-        assert((i + 1) < num_args && sig_bt[i + 1] == T_VOID, \"expecting half\");\n-        VMStorage reg = _input_regs.at(src_pos++);\n-        out_regs[i] = reg;\n-        if (reg.is_stack())\n-          max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n-        break;\n-      }\n-      case T_VOID: \/\/ Halves of longs and doubles\n-        assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n-        out_regs[i] = VMStorage::invalid();\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-        break;\n-    }\n+  for (VMStorage reg : out_regs) {\n+    if (reg.is_stack())\n+      max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n@@ -171,1 +141,1 @@\n-int JavaCallingConvention::calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const {\n+int ForeignGlobals::java_calling_convention(const BasicType* signature, int num_args, GrowableArray<VMStorage>& out_regs) {\n@@ -173,1 +143,1 @@\n-  int slots = SharedRuntime::java_calling_convention(sig_bt, vm_regs, num_args);\n+  int slots = SharedRuntime::java_calling_convention(signature, vm_regs, num_args);\n@@ -178,2 +148,3 @@\n-    \/\/assert(!pair.first()->is_valid() || pair.is_single_reg(), \"must be: %s\");\n-    regs[i] = as_VMStorage(pair.first(), sig_bt[i]);\n+    if (signature[i] != T_VOID) {\n+      out_regs.push(as_VMStorage(pair.first(), signature[i]));\n+    }\n@@ -184,1 +155,38 @@\n-class ComputeMoveOrder: public StackObj {\n+GrowableArray<VMStorage> ForeignGlobals::replace_place_holders(const GrowableArray<VMStorage>& regs, const StubLocations& locs) {\n+  GrowableArray<VMStorage> result(regs.length());\n+  for (VMStorage reg : regs) {\n+    result.push(reg.type() == StorageType::PLACEHOLDER ? locs.get(reg) : reg);\n+  }\n+  return result;\n+}\n+\n+GrowableArray<VMStorage> ForeignGlobals::upcall_filter_receiver_reg(const GrowableArray<VMStorage>& unfiltered_regs) {\n+  GrowableArray<VMStorage> out(unfiltered_regs.length() - 1);\n+  \/\/ drop first arg reg\n+  for (int i = 1; i < unfiltered_regs.length(); i++) {\n+    out.push(unfiltered_regs.at(i));\n+  }\n+  return out;\n+}\n+\n+GrowableArray<VMStorage> ForeignGlobals::downcall_filter_offset_regs(const GrowableArray<VMStorage>& regs,\n+                                                                     BasicType* signature, int num_args,\n+                                                                     bool& has_objects) {\n+  GrowableArray<VMStorage> result(regs.length());\n+  int reg_idx = 0;\n+  for (int sig_idx = 0; sig_idx < num_args; sig_idx++) {\n+    if (signature[sig_idx] == T_VOID) {\n+      continue; \/\/ ignore upper halves\n+    }\n+\n+    result.push(regs.at(reg_idx++));\n+    if (signature[sig_idx] == T_OBJECT) {\n+      has_objects = true;\n+      sig_idx++; \/\/ skip offset\n+      reg_idx++;\n+    }\n+  }\n+  return result;\n+}\n+\n+class ArgumentShuffle::ComputeMoveOrder: public StackObj {\n@@ -261,5 +269,2 @@\n-  int _total_in_args;\n-  const VMStorage* _in_regs;\n-  int _total_out_args;\n-  const VMStorage* _out_regs;\n-  const BasicType* _in_sig_bt;\n+  const GrowableArray<VMStorage>& _in_regs;\n+  const GrowableArray<VMStorage>& _out_regs;\n@@ -271,3 +276,3 @@\n-  ComputeMoveOrder(int total_in_args, const VMStorage* in_regs, int total_out_args, VMStorage* out_regs,\n-                   const BasicType* in_sig_bt, VMStorage tmp_vmreg) :\n-      _total_in_args(total_in_args),\n+  ComputeMoveOrder(const GrowableArray<VMStorage>& in_regs,\n+                   const GrowableArray<VMStorage>& out_regs,\n+                   VMStorage tmp_vmreg) :\n@@ -275,1 +280,0 @@\n-      _total_out_args(total_out_args),\n@@ -277,1 +281,0 @@\n-      _in_sig_bt(in_sig_bt),\n@@ -279,2 +282,4 @@\n-      _edges(total_in_args),\n-      _moves(total_in_args) {\n+      _edges(in_regs.length()),\n+      _moves(in_regs.length()) {\n+    assert(in_regs.length() == out_regs.length(),\n+      \"stray registers? %d != %d\", in_regs.length(), out_regs.length());\n@@ -284,13 +289,3 @@\n-    assert(_total_out_args >= _total_in_args, \"can only add prefix args\");\n-    \/\/ Note that total_out_args args can be greater than total_in_args in the case of upcalls.\n-    \/\/ There will be a leading MH receiver arg in the out args in that case.\n-    \/\/\n-    \/\/ Leading args in the out args will be ignored below because we iterate from the end of\n-    \/\/ the register arrays until !(in_idx >= 0), and total_in_args is smaller.\n-    \/\/\n-    \/\/ Stub code adds a move for the receiver to j_rarg0 (and potential other prefix args) manually.\n-    for (int in_idx = _total_in_args - 1, out_idx = _total_out_args - 1; in_idx >= 0; in_idx--, out_idx--) {\n-      BasicType bt = _in_sig_bt[in_idx];\n-      assert(bt != T_ARRAY, \"array not expected\");\n-      VMStorage in_reg = _in_regs[in_idx];\n-      VMStorage out_reg = _out_regs[out_idx];\n+    for (int i = 0; i < _in_regs.length(); i++) {\n+      VMStorage in_reg = _in_regs.at(i);\n+      VMStorage out_reg = _out_regs.at(i);\n@@ -304,6 +299,2 @@\n-      } else if (in_reg == out_reg\n-                 || bt == T_VOID) {\n-        \/\/ 1. Can skip non-stack identity moves.\n-        \/\/\n-        \/\/ 2. Upper half of long or double (T_VOID).\n-        \/\/    Don't need to do anything.\n+      } else if (in_reg == out_reg) {\n+        \/\/ Can skip non-stack identity moves.\n@@ -317,1 +308,1 @@\n-    compute_store_order(_tmp_vmreg);\n+    compute_store_order();\n@@ -322,1 +313,1 @@\n-  void compute_store_order(VMStorage temp_register) {\n+  void compute_store_order() {\n@@ -331,1 +322,1 @@\n-    assert(!killer.contains(temp_register),\n+    assert(!killer.contains(_tmp_vmreg),\n@@ -353,1 +344,1 @@\n-          start->break_cycle(temp_register);\n+          start->break_cycle(_tmp_vmreg);\n@@ -367,4 +358,4 @@\n-  static GrowableArray<Move> compute_move_order(int total_in_args, const VMStorage* in_regs,\n-                                                int total_out_args, VMStorage* out_regs,\n-                                                const BasicType* in_sig_bt, VMStorage tmp_vmreg) {\n-    ComputeMoveOrder cmo(total_in_args, in_regs, total_out_args, out_regs, in_sig_bt, tmp_vmreg);\n+  static GrowableArray<Move> compute_move_order(const GrowableArray<VMStorage>& in_regs,\n+                                                const GrowableArray<VMStorage>& out_regs,\n+                                                VMStorage tmp_vmreg) {\n+    ComputeMoveOrder cmo(in_regs, out_regs, tmp_vmreg);\n@@ -377,6 +368,2 @@\n-    BasicType* in_sig_bt,\n-    int num_in_args,\n-    BasicType* out_sig_bt,\n-    int num_out_args,\n-    const CallingConventionClosure* input_conv,\n-    const CallingConventionClosure* output_conv,\n+    const GrowableArray<VMStorage>& in_regs,\n+    const GrowableArray<VMStorage>& out_regs,\n@@ -384,10 +371,1 @@\n-\n-  VMStorage* in_regs = NEW_RESOURCE_ARRAY(VMStorage, num_in_args);\n-  input_conv->calling_convention(in_sig_bt, in_regs, num_in_args);\n-\n-  VMStorage* out_regs = NEW_RESOURCE_ARRAY(VMStorage, num_out_args);\n-  _out_arg_bytes = output_conv->calling_convention(out_sig_bt, out_regs, num_out_args);\n-\n-  _moves = ComputeMoveOrder::compute_move_order(num_in_args, in_regs,\n-                                                num_out_args, out_regs,\n-                                                in_sig_bt, shuffle_temp);\n+  _moves = ComputeMoveOrder::compute_move_order(in_regs, out_regs, shuffle_temp);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":72,"deletions":94,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -36,3 +36,2 @@\n-\/\/ needs to match StubLocations in Java code.\n-\/\/ placeholder locations to be filled in by\n-\/\/ the code gen code\n+\/\/ Needs to match jdk.internal.foreign.abi.StubLocations in Java code.\n+\/\/ Placeholder locations to be filled in by the code gen code.\n@@ -59,5 +58,1 @@\n-class CallingConventionClosure {\n-public:\n-  virtual int calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const = 0;\n-};\n-\n+\/\/ C++ 'mirror' of jdk.internal.foreign.abi.UpcallLinker.CallRegs\n@@ -81,0 +76,1 @@\n+  \/\/ Helpers for translating from the Java to C++ representation\n@@ -84,1 +80,0 @@\n-};\n@@ -86,4 +81,3 @@\n-class JavaCallingConvention : public CallingConventionClosure {\n-public:\n-  int calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const override;\n-};\n+  \/\/ Adapter from SharedRuntime::java_calling_convention to a 'single VMStorage per value' form.\n+  \/\/ Doesn't assign (invalid) storage for T_VOID entries in the signature, which are instead ignored.\n+  static int java_calling_convention(const BasicType* signature, int num_args, GrowableArray<VMStorage>& out_regs);\n@@ -91,5 +85,2 @@\n-class NativeCallingConvention : public CallingConventionClosure {\n-  GrowableArray<VMStorage> _input_regs;\n-public:\n-  NativeCallingConvention(const GrowableArray<VMStorage>& input_regs)\n-   : _input_regs(input_regs) {}\n+  \/\/ Computes the space (in bytes) that is taken up by stack arguments\n+  static int compute_out_arg_bytes(const GrowableArray<VMStorage>& out_regs);\n@@ -97,1 +88,11 @@\n-  int calling_convention(const BasicType* sig_bt, VMStorage* out_regs, int num_args) const override;\n+  \/\/ Replace placeholders (see class StubLocations above) with actual locations in a stub frame\n+  static GrowableArray<VMStorage> replace_place_holders(const GrowableArray<VMStorage>& regs, const StubLocations& locs);\n+\n+  \/\/ The receiver method handle for upcalls is injected manually into the argument list by the upcall stub. We need a\n+  \/\/ filtered list to generate an argument shuffle for the rest of the arguments.\n+  static GrowableArray<VMStorage> upcall_filter_receiver_reg(const GrowableArray<VMStorage>& unfiltered_regs);\n+\n+  \/\/ Oop offsets are not passed on to native code.\n+  \/\/ Filter out the registers of oop offsets to create a list that we can pass to ArgumentShuffle.\n+  static GrowableArray<VMStorage> downcall_filter_offset_regs(const GrowableArray<VMStorage>& regs, BasicType* signature,\n+                                                              int num_args, bool& has_objects);\n@@ -100,0 +101,1 @@\n+\/\/ Helper class useful for generating spills and fills of a set of registers.\n@@ -120,5 +122,7 @@\n-struct Move {\n-  VMStorage from;\n-  VMStorage to;\n-};\n-\n+\/\/ Class used to compute and generate a shuffle between 2 lists of VMStorages.\n+\/\/ The lists must have the same size.\n+\/\/ Each VMStorage in the source list (in_regs) is shuffled into the\n+\/\/ the VMStorage at the same index in the destination list (out_regs).\n+\/\/ This class helps to automatically compute an order of moves that makes\n+\/\/ sure not to destroy values accidentally by interfering moves, in case the\n+\/\/ source and destination registers overlap.\n@@ -127,0 +131,6 @@\n+  class ComputeMoveOrder;\n+  struct Move {\n+    VMStorage from;\n+    VMStorage to;\n+  };\n+\n@@ -128,1 +138,0 @@\n-  int _out_arg_bytes;\n@@ -131,3 +140,2 @@\n-    BasicType* in_sig_bt, int num_in_args,\n-    BasicType* out_sig_bt, int num_out_args,\n-    const CallingConventionClosure* input_conv, const CallingConventionClosure* output_conv,\n+    const GrowableArray<VMStorage>& in_regs,\n+    const GrowableArray<VMStorage>& out_regs,\n@@ -136,3 +144,2 @@\n-  int out_arg_bytes() const { return _out_arg_bytes; }\n-  void generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n-    pd_generate(masm, tmp, in_stk_bias, out_stk_bias, locs);\n+  void generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+    pd_generate(masm, tmp, in_stk_bias, out_stk_bias);\n@@ -143,1 +150,1 @@\n-  void pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const;\n+  void pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const;\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-    assert(java_lang_Class::is_primitive(type_oop), \"Only primitives expected\");\n-    BasicType bt = java_lang_Class::primitive_type(type_oop);\n+    BasicType bt = java_lang_Class::as_BasicType(type_oop);\n@@ -58,1 +57,4 @@\n-    input_regs.push(ForeignGlobals::parse_vmstorage(arg_moves_oop->obj_at(i)));\n+    oop reg_oop = arg_moves_oop->obj_at(i);\n+    if (reg_oop != nullptr) {\n+      input_regs.push(ForeignGlobals::parse_vmstorage(reg_oop));\n+    }\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -179,3 +179,0 @@\n-  \/\/ skip receiver\n-  BasicType* in_sig_bt = out_sig_bt + 1;\n-  int total_in_args = total_out_args - 1;\n@@ -184,1 +181,2 @@\n-    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type, abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n+    mh_j, entry, out_sig_bt, total_out_args, ret_type,\n+    abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-                                  BasicType* in_sig_bt, int total_in_args,\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -791,0 +791,9 @@\n+         * <p>\n+         * Critical functions can optionally allow access to the Java heap. This allows clients to pass heap\n+         * memory segments as addresses, where normally only off-heap memory segments would be allowed. The memory region\n+         * inside the Java heap is exposed through a temporary native address that is valid for the duration of the\n+         * function call. Use of this mechanism is therefore only recommend when a function needs to do\n+         * short-lived access to Java heap memory, and copying the relevant data to an off-heap memory segment would be\n+         * prohibitive in terms of performance.\n+         *\n+         * @param allowHeapAccess whether the linked function should allow access to the Java heap.\n@@ -792,2 +801,2 @@\n-        static Option critical() {\n-            return LinkerOptions.Critical.INSTANCE;\n+        static Option critical(boolean allowHeapAccess) {\n+            return allowHeapAccess ? LinkerOptions.Critical.ALLOW_HEAP : LinkerOptions.Critical.DONT_ALLOW_HEAP;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -80,1 +80,2 @@\n-              || pType == void.class);\n+              || pType == void.class\n+              || pType == Object.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -205,1 +206,1 @@\n-        if (!type.isPrimitive() || type == void.class)\n+        if (type != Object.class && (!type.isPrimitive() || type == void.class))\n@@ -271,2 +272,15 @@\n-    static UnboxAddress unboxAddress() {\n-        return UnboxAddress.INSTANCE;\n+    \/\/ alias\n+    static SegmentOffset unboxAddress() {\n+        return segmentOffsetNoAllowHeap();\n+    }\n+\n+    static SegmentBase segmentBase() {\n+        return SegmentBase.INSTANCE;\n+    }\n+\n+    static SegmentOffset segmentOffsetAllowHeap() {\n+        return SegmentOffset.INSTANCE_ALLOW_HEAP;\n+    }\n+\n+    static SegmentOffset segmentOffsetNoAllowHeap() {\n+        return SegmentOffset.INSTANCE_NO_ALLOW_HEAP;\n@@ -417,0 +431,15 @@\n+        public Binding.Builder segmentBase() {\n+            bindings.add(Binding.segmentBase());\n+            return this;\n+        }\n+\n+        public Binding.Builder segmentOffsetAllowHeap() {\n+            bindings.add(Binding.segmentOffsetAllowHeap());\n+            return this;\n+        }\n+\n+        public Binding.Builder segmentOffsetNoAllowHeap() {\n+            bindings.add(Binding.segmentOffsetNoAllowHeap());\n+            return this;\n+        }\n+\n@@ -452,2 +481,4 @@\n-     * Pops a [type] from the operand stack, and moves it to [storage location]\n-     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *   Pops a [type] from the operand stack, and moves it to [storage location]\n+     *   The [type] must be one of byte, short, char, int, long, float, or double.\n+     *   [storage location] may be 'null', indicating that this value should be passed\n+     *   to the VM stub, but does not have an explicit target register (e.g. oop offsets)\n@@ -473,2 +504,2 @@\n-     * Loads a [type] from [storage location], and pushes it onto the operand stack.\n-     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *   Loads a [type] from [storage location], and pushes it onto the operand stack.\n+     *   The [type] must be one of byte, short, char, int, long, float, or double\n@@ -497,3 +528,3 @@\n-     * Pops a [type] from the operand stack, then pops a MemorySegment from the operand stack.\n-     * Stores [width] bytes of the value contained in the [type] to [offset into memory region].\n-     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *   Pops a [type] from the operand stack, then pops a MemorySegment from the operand stack.\n+     *   Stores [width] bytes of the value contained in the [type] to [offset into memory region].\n+     *   The [type] must be one of byte, short, char, int, long, float, or double\n@@ -554,3 +585,3 @@\n-     * Pops a MemorySegment from the operand stack,\n-     * and then loads [width] bytes from it at [offset into memory region], into a [type].\n-     * The [type] must be one of byte, short, char, int, long, float, or double\n+     *   Pops a MemorySegment from the operand stack,\n+     *   and then loads [width] bytes from it at [offset into memory region], into a [type].\n+     *   The [type] must be one of byte, short, char, int, long, float, or double\n@@ -610,2 +641,2 @@\n-     *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,\n-     *     and pushes the new buffer onto the operand stack\n+     *   and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,\n+     *   and pushes the new buffer onto the operand stack\n@@ -657,3 +688,27 @@\n-     * UNBOX_ADDRESS()\n-     * Pops a 'MemoryAddress' from the operand stack, converts it to a 'long',\n-     * with the given size, and pushes that onto the operand stack\n+     * SEGMENT_BASE()\n+     *   Pops a MemorySegment from the stack, retrieves the heap base object from it, or null if there is none\n+     *   (See: AbstractMemorySegmentImpl::unsafeGetBase), and pushes the result onto the operand stack.\n+     *\/\n+    record SegmentBase() implements Binding {\n+        static final SegmentBase INSTANCE = new SegmentBase();\n+\n+        @Override\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, MemorySegment.class);\n+            stack.push(Object.class);\n+        }\n+\n+        @Override\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(((AbstractMemorySegmentImpl)stack.pop()).unsafeGetBase());\n+        }\n+    }\n+\n+    \/**\n+     * SEGMENT_OFFSET([allowHeap])\n+     *   Pops a MemorySegment from the stack, retrieves the offset from it,\n+     *   (See: AbstractMemorySegmentImpl::unsafeGetOffset), and pushes the result onto the operand stack.\n+     *   Note that for heap segments, the offset is a virtual address into the heap base object.\n+     *   If [allowHeap] is 'false' an exception will be thrown for heap segments (See SharedUtils::checkNative).\n@@ -661,2 +716,3 @@\n-    record UnboxAddress() implements Binding {\n-        static final UnboxAddress INSTANCE = new UnboxAddress();\n+    record SegmentOffset(boolean allowHeap) implements Binding {\n+        static final SegmentOffset INSTANCE_NO_ALLOW_HEAP = new SegmentOffset(false);\n+        static final SegmentOffset INSTANCE_ALLOW_HEAP = new SegmentOffset(true);\n@@ -674,1 +730,5 @@\n-            stack.push(SharedUtils.unboxSegment((MemorySegment)stack.pop()));\n+            MemorySegment operand = (MemorySegment) stack.pop();\n+            if (!allowHeap) {\n+                SharedUtils.checkNative(operand);\n+            }\n+            stack.push(((AbstractMemorySegmentImpl)operand).unsafeGetOffset());\n@@ -680,2 +740,2 @@\n-     * Pops a 'long' from the operand stack, converts it to a 'MemorySegment', with the given size and memory scope\n-     * (either the context scope, or the global scope), and pushes that onto the operand stack.\n+     *   Pops a 'long' from the operand stack, converts it to a 'MemorySegment', with the given size and memory scope\n+     *   (either the context scope, or the global scope), and pushes that onto the operand stack.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":83,"deletions":23,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.LinkedList;\n@@ -35,1 +36,1 @@\n-        Deque<Object> stack = new ArrayDeque<>();\n+        Deque<Object> stack = new LinkedList<>(); \/\/ Use LinkedList as a null-friendly Deque for null segment bases\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.internal.foreign.abi.Binding.SegmentBase;\n+import jdk.internal.foreign.abi.Binding.SegmentOffset;\n@@ -44,1 +46,0 @@\n-import jdk.internal.foreign.abi.Binding.UnboxAddress;\n@@ -106,1 +107,3 @@\n-    private static final MethodTypeDesc MTD_UNBOX_SEGMENT = MethodTypeDesc.of(CD_long, CD_MemorySegment);\n+    private static final MethodTypeDesc MTD_CHECK_NATIVE = MethodTypeDesc.of(CD_void, CD_MemorySegment);\n+    private static final MethodTypeDesc MTD_UNSAFE_GET_BASE = MethodTypeDesc.of(CD_Object);\n+    private static final MethodTypeDesc MTD_UNSAFE_GET_OFFSET = MethodTypeDesc.of(CD_long);\n@@ -459,12 +462,13 @@\n-                case VMStore vmStore         -> emitVMStore(vmStore);\n-                case VMLoad vmLoad           -> emitVMLoad(vmLoad);\n-                case BufferStore bufferStore -> emitBufferStore(bufferStore);\n-                case BufferLoad bufferLoad   -> emitBufferLoad(bufferLoad);\n-                case Copy copy               -> emitCopyBuffer(copy);\n-                case Allocate allocate       -> emitAllocBuffer(allocate);\n-                case BoxAddress boxAddress   -> emitBoxAddress(boxAddress);\n-                case UnboxAddress unused     -> emitUnboxAddress();\n-                case Dup unused              -> emitDupBinding();\n-                case ShiftLeft shiftLeft     -> emitShiftLeft(shiftLeft);\n-                case ShiftRight shiftRight   -> emitShiftRight(shiftRight);\n-                case Cast cast               -> emitCast(cast);\n+                case VMStore vmStore             -> emitVMStore(vmStore);\n+                case VMLoad vmLoad               -> emitVMLoad(vmLoad);\n+                case BufferStore bufferStore     -> emitBufferStore(bufferStore);\n+                case BufferLoad bufferLoad       -> emitBufferLoad(bufferLoad);\n+                case Copy copy                   -> emitCopyBuffer(copy);\n+                case Allocate allocate           -> emitAllocBuffer(allocate);\n+                case BoxAddress boxAddress       -> emitBoxAddress(boxAddress);\n+                case SegmentBase unused          -> emitSegmentBase();\n+                case SegmentOffset segmentOffset -> emitSegmentOffset(segmentOffset);\n+                case Dup unused                  -> emitDupBinding();\n+                case ShiftLeft shiftLeft         -> emitShiftLeft(shiftLeft);\n+                case ShiftRight shiftRight       -> emitShiftRight(shiftRight);\n+                case Cast cast                   -> emitCast(cast);\n@@ -778,1 +782,1 @@\n-    private void emitUnboxAddress() {\n+    private void emitSegmentBase() {\n@@ -780,1 +784,15 @@\n-        cb.invokestatic(CD_SharedUtils, \"unboxSegment\", MTD_UNBOX_SEGMENT);\n+        cb.checkcast(CD_AbstractMemorySegmentImpl);\n+        cb.invokevirtual(CD_AbstractMemorySegmentImpl, \"unsafeGetBase\", MTD_UNSAFE_GET_BASE);\n+        pushType(Object.class);\n+    }\n+\n+    private void emitSegmentOffset(SegmentOffset segmentOffset) {\n+        popType(MemorySegment.class);\n+\n+        if (!segmentOffset.allowHeap()) {\n+            cb.dup();\n+            cb.invokestatic(CD_SharedUtils, \"checkNative\", MTD_CHECK_NATIVE);\n+        }\n+        cb.checkcast(CD_AbstractMemorySegmentImpl);\n+        cb.invokevirtual(CD_AbstractMemorySegmentImpl, \"unsafeGetOffset\", MTD_UNSAFE_GET_OFFSET);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":34,"deletions":16,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.foreign.abi.Binding.Allocate;\n+import jdk.internal.foreign.abi.Binding.*;\n@@ -35,0 +35,2 @@\n+import jdk.internal.foreign.abi.Binding.SegmentBase;\n+import jdk.internal.foreign.abi.Binding.SegmentOffset;\n@@ -37,1 +39,0 @@\n-import jdk.internal.foreign.abi.Binding.UnboxAddress;\n@@ -220,13 +221,13 @@\n-            case VMStore      unused -> true;\n-            case BufferLoad   unused -> true;\n-            case Copy         unused -> true;\n-            case UnboxAddress unused -> true;\n-            case Dup          unused -> true;\n-            case ShiftLeft    unused -> true;\n-            case ShiftRight   unused -> true;\n-            case Cast         unused -> true;\n-\n-            case VMLoad       unused -> false;\n-            case BufferStore  unused -> false;\n-            case Allocate     unused -> false;\n-            case BoxAddress   unused -> false;\n+            case VMStore       unused -> true;\n+            case BufferLoad    unused -> true;\n+            case Copy          unused -> true;\n+            case Dup           unused -> true;\n+            case SegmentBase   unused -> true;\n+            case SegmentOffset unused -> true;\n+            case ShiftLeft     unused -> true;\n+            case ShiftRight    unused -> true;\n+            case Cast          unused -> true;\n+            case VMLoad        unused -> false;\n+            case BufferStore   unused -> false;\n+            case Allocate      unused -> false;\n+            case BoxAddress    unused -> false;\n@@ -255,13 +256,14 @@\n-            case VMLoad       unused -> true;\n-            case BufferStore  unused -> true;\n-            case Copy         unused -> true;\n-            case Allocate     unused -> true;\n-            case BoxAddress   unused -> true;\n-            case Dup          unused -> true;\n-            case ShiftLeft    unused -> true;\n-            case ShiftRight   unused -> true;\n-            case Cast         unused -> true;\n-\n-            case VMStore      unused -> false;\n-            case BufferLoad   unused -> false;\n-            case UnboxAddress unused -> false;\n+            case VMLoad        unused -> true;\n+            case BufferStore   unused -> true;\n+            case Copy          unused -> true;\n+            case Allocate      unused -> true;\n+            case BoxAddress    unused -> true;\n+            case Dup           unused -> true;\n+            case ShiftLeft     unused -> true;\n+            case ShiftRight    unused -> true;\n+            case Cast          unused -> true;\n+\n+            case VMStore       unused -> false;\n+            case BufferLoad    unused -> false;\n+            case SegmentBase   unused -> false;\n+            case SegmentOffset unused -> false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -101,3 +101,1 @@\n-            Map<VMStorage, Integer> argIndexMap = SharedUtils.indexMap(argMoves);\n-\n-            InvocationData invData = new InvocationData(handle, callingSequence, argIndexMap);\n+            InvocationData invData = new InvocationData(handle, callingSequence);\n@@ -154,1 +152,1 @@\n-    private record InvocationData(MethodHandle leaf, CallingSequence callingSequence, Map<VMStorage, Integer> argIndexMap) {}\n+    private record InvocationData(MethodHandle leaf, CallingSequence callingSequence) {}\n@@ -175,0 +173,7 @@\n+            BindingInterpreter.StoreFunc storeFunc = new BindingInterpreter.StoreFunc() {\n+                    int argOffset = 0;\n+                    @Override\n+                    public void store(VMStorage storage, Object o) {\n+                        leafArgs[argOffset++] = o;\n+                    }\n+                };\n@@ -186,2 +191,1 @@\n-                BindingInterpreter.unbox(arg, callingSequence.argumentBindings(i),\n-                    (storage, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n+                BindingInterpreter.unbox(arg, callingSequence.argumentBindings(i), storeFunc, unboxArena);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -109,0 +109,5 @@\n+    public boolean allowsHeapAccess() {\n+        Critical c = getOption(Critical.class);\n+        return c != null && c.allowHeapAccess();\n+    }\n+\n@@ -148,2 +153,3 @@\n-    public record Critical() implements LinkerOptionImpl {\n-        public static Critical INSTANCE = new Critical();\n+    public record Critical(boolean allowHeapAccess) implements LinkerOptionImpl {\n+        public static Critical ALLOW_HEAP = new Critical(true);\n+        public static Critical DONT_ALLOW_HEAP = new Critical(false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-    public static long unboxSegment(MemorySegment segment) {\n+    public static void checkNative(MemorySegment segment) {\n@@ -319,0 +319,4 @@\n+    }\n+\n+    public static long unboxSegment(MemorySegment segment) {\n+        checkNative(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,2 +155,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, forVariadicFunction);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, forVariadicFunction) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, forVariadicFunction, options.allowsHeapAccess());\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, forVariadicFunction, false) : new BoxBindingCalculator(false);\n@@ -392,0 +392,1 @@\n+        private final boolean useAddressPairs;\n@@ -393,1 +394,1 @@\n-        UnboxBindingCalculator(boolean forArguments, boolean forVariadicFunction) {\n+        UnboxBindingCalculator(boolean forArguments, boolean forVariadicFunction, boolean useAddressPairs) {\n@@ -397,0 +398,1 @@\n+            this.useAddressPairs = useAddressPairs;\n@@ -436,1 +438,0 @@\n-                    bindings.unboxAddress();\n@@ -438,1 +439,10 @@\n-                    bindings.vmStore(storage, long.class);\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,7 +27,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.abi.AbstractLinker;\n-import jdk.internal.foreign.abi.CapturableState;\n-import jdk.internal.foreign.abi.LinkerOptions;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n@@ -42,10 +35,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.ref.Reference;\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-\n@@ -61,0 +44,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -62,0 +47,12 @@\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.Reference;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.CapturableState;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -98,1 +95,1 @@\n-                function.argumentLayouts(), capturedStateMask);\n+                function.argumentLayouts(), capturedStateMask, options.allowsHeapAccess());\n@@ -158,1 +155,1 @@\n-                                int capturedStateMask) {}\n+                                int capturedStateMask, boolean allowsHeapAccess) {}\n@@ -164,0 +161,1 @@\n+            Object[] heapBases = invData.allowsHeapAccess() ? new Object[args.length] : null;\n@@ -183,3 +181,4 @@\n-                MemorySegment argSeg = arena.allocate(layout);\n-                writeValue(arg, layout, argSeg, addr -> {\n-                    MemorySessionImpl sessionImpl = ((AbstractMemorySegmentImpl) addr).sessionImpl();\n+\n+                if (layout instanceof AddressLayout) {\n+                    AbstractMemorySegmentImpl ms = (AbstractMemorySegmentImpl) arg;\n+                    MemorySessionImpl sessionImpl = ms.sessionImpl();\n@@ -188,1 +187,10 @@\n-                });\n+                    if (invData.allowsHeapAccess() && !ms.isNative()) {\n+                        heapBases[i] = ms.unsafeGetBase();\n+                        \/\/ write the offset to the arg segment, add array ptr to it in native code\n+                        layout = JAVA_LONG;\n+                        arg = ms.address();\n+                    }\n+                }\n+\n+                MemorySegment argSeg = arena.allocate(layout);\n+                writeValue(arg, layout, argSeg);\n@@ -197,1 +205,2 @@\n-            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs, capturedState, invData.capturedStateMask());\n+            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs, capturedState, invData.capturedStateMask(),\n+                                   heapBases, args.length);\n@@ -238,29 +247,15 @@\n-        writeValue(arg, layout, argSeg, addr -> {});\n-    }\n-\n-    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg,\n-                                   Consumer<MemorySegment> acquireCallback) {\n-        if (layout instanceof ValueLayout.OfBoolean bl) {\n-            argSeg.set(bl, 0, (Boolean) arg);\n-        } else if (layout instanceof ValueLayout.OfByte bl) {\n-            argSeg.set(bl, 0, (Byte) arg);\n-        } else if (layout instanceof ValueLayout.OfShort sl) {\n-            argSeg.set(sl, 0, (Short) arg);\n-        } else if (layout instanceof ValueLayout.OfChar cl) {\n-            argSeg.set(cl, 0, (Character) arg);\n-        } else if (layout instanceof ValueLayout.OfInt il) {\n-            argSeg.set(il, 0, (Integer) arg);\n-        } else if (layout instanceof ValueLayout.OfLong ll) {\n-            argSeg.set(ll, 0, (Long) arg);\n-        } else if (layout instanceof ValueLayout.OfFloat fl) {\n-            argSeg.set(fl, 0, (Float) arg);\n-        } else if (layout instanceof ValueLayout.OfDouble dl) {\n-            argSeg.set(dl, 0, (Double) arg);\n-        } else if (layout instanceof AddressLayout al) {\n-            MemorySegment addrArg = (MemorySegment) arg;\n-            acquireCallback.accept(addrArg);\n-            argSeg.set(al, 0, addrArg);\n-        } else if (layout instanceof GroupLayout) {\n-            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n-        } else {\n-            assert layout == null;\n+        switch (layout) {\n+            case ValueLayout.OfBoolean bl -> argSeg.set(bl, 0, (Boolean) arg);\n+            case ValueLayout.OfByte    bl -> argSeg.set(bl, 0, (Byte) arg);\n+            case ValueLayout.OfShort   sl -> argSeg.set(sl, 0, (Short) arg);\n+            case ValueLayout.OfChar    cl -> argSeg.set(cl, 0, (Character) arg);\n+            case ValueLayout.OfInt     il -> argSeg.set(il, 0, (Integer) arg);\n+            case ValueLayout.OfLong    ll -> argSeg.set(ll, 0, (Long) arg);\n+            case ValueLayout.OfFloat   fl -> argSeg.set(fl, 0, (Float) arg);\n+            case ValueLayout.OfDouble  dl -> argSeg.set(dl, 0, (Double) arg);\n+            case AddressLayout         al -> argSeg.set(al, 0, (MemorySegment) arg);\n+            case GroupLayout           __ ->\n+                    MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n+            case null, default -> {\n+                assert layout == null;\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":48,"deletions":53,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-                                  MemorySegment capturedState, int capturedStateMask) {\n+                           MemorySegment capturedState, int capturedStateMask,\n+                           Object[] heapBases, int numArgs) {\n@@ -95,2 +96,3 @@\n-                    retPtr == null ? 0 : retPtr.address(), argPtrs.address(),\n-                    capturedState == null ? 0 : capturedState.address(), capturedStateMask);\n+                       retPtr == null ? 0 : retPtr.address(), argPtrs.address(),\n+                       capturedState == null ? 0 : capturedState.address(), capturedStateMask,\n+                       heapBases, numArgs);\n@@ -210,1 +212,3 @@\n-    private static native void doDowncall(long cif, long fn, long rvalue, long avalues, long capturedState, int capturedStateMask);\n+    private static native void doDowncall(long cif, long fn, long rvalue, long avalues,\n+                                          long capturedState, int capturedStateMask,\n+                                          Object[] heapBases, int numArgs);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, options.allowsHeapAccess());\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, false) : new BoxBindingCalculator(false);\n@@ -340,1 +340,3 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+        private final boolean useAddressPairs;\n+\n+        UnboxBindingCalculator(boolean forArguments, boolean useAddressPairs) {\n@@ -342,0 +344,1 @@\n+            this.useAddressPairs = useAddressPairs;\n@@ -407,2 +410,10 @@\n-                    bindings.unboxAddress()\n-                            .vmStore(storage, long.class);\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, options.allowsHeapAccess());\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, false) : new BoxBindingCalculator(false);\n@@ -248,0 +248,1 @@\n+        private final boolean useAddressPairs;\n@@ -249,1 +250,1 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+        UnboxBindingCalculator(boolean forArguments, boolean useAddressPairs) {\n@@ -251,0 +252,1 @@\n+            this.useAddressPairs = useAddressPairs;\n@@ -277,1 +279,0 @@\n-                    bindings.unboxAddress();\n@@ -279,2 +280,11 @@\n-                    bindings.vmStore(storage, long.class);\n-                                    }\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                    forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n+                    forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, options.allowsHeapAccess());\n@@ -92,1 +92,1 @@\n-                    forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+                    forUpcall ? new UnboxBindingCalculator(false, false) : new BoxBindingCalculator(false);\n@@ -187,0 +187,1 @@\n+        private final boolean useAddressPairs;\n@@ -188,1 +189,1 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+        UnboxBindingCalculator(boolean forArguments, boolean useAddressPairs) {\n@@ -190,0 +191,2 @@\n+            assert !useAddressPairs || forArguments;\n+            this.useAddressPairs = useAddressPairs;\n@@ -212,1 +215,0 @@\n-                    bindings.unboxAddress();\n@@ -214,1 +216,10 @@\n-                    bindings.vmStore(storage, long.class);\n+                    if (useAddressPairs) {\n+                        bindings.dup()\n+                                .segmentBase()\n+                                .vmStore(storage, Object.class)\n+                                .segmentOffsetAllowHeap()\n+                                .vmStore(null, long.class);\n+                    } else {\n+                        bindings.unboxAddress();\n+                        bindings.vmStore(storage, long.class);\n+                    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <malloc.h>\n@@ -95,1 +96,21 @@\n-Java_jdk_internal_foreign_abi_fallback_LibFallback_doDowncall(JNIEnv* env, jclass cls, jlong cif, jlong fn, jlong rvalue, jlong avalues, jlong jcaptured_state, jint captured_state_mask) {\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_doDowncall(JNIEnv* env, jclass cls, jlong cif, jlong fn, jlong rvalue,\n+                                                              jlong avalues, jlong jcaptured_state, jint captured_state_mask,\n+                                                              jarray heapBases, jint numArgs) {\n+  void** carrays;\n+  if (heapBases != NULL) {\n+    void** aptrs = jlong_to_ptr(avalues);\n+    carrays = malloc(sizeof(void*) * numArgs);\n+    for (int i = 0; i < numArgs; i++) {\n+      jarray hb = (jarray) (*env)->GetObjectArrayElement(env, heapBases, i);\n+      if (hb != NULL) {\n+        \/\/ *(aptrs[i]) is the offset into the segment (from MS::address)\n+        \/\/ we add the base address of the array to it here\n+        jboolean isCopy;\n+        jbyte* arrayPtr = (*env)->GetPrimitiveArrayCritical(env, hb, &isCopy);\n+        carrays[i] = arrayPtr;\n+        int offset = *((int*)aptrs[i]);\n+        *((void**)aptrs[i]) = arrayPtr + offset;\n+      }\n+    }\n+  }\n+\n@@ -98,0 +119,10 @@\n+  if (heapBases != NULL) {\n+    for (int i = 0; i < numArgs; i++) {\n+      jarray hb = (jarray) (*env)->GetObjectArrayElement(env, heapBases, i);\n+      if (hb != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, hb, carrays[i], JNI_COMMIT);\n+      }\n+    }\n+    free(carrays);\n+  }\n+\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -198,1 +198,3 @@\n-    public record TestValue (Object value, Consumer<Object> check) {}\n+    public record TestValue (Object value, Consumer<Object> check) {\n+        public void check(Object actual) { check.accept(actual); }\n+    }\n@@ -240,0 +242,3 @@\n+        } else if (layout instanceof ValueLayout.OfChar) {\n+            char value = (char) random.nextInt();\n+            return new TestValue(value, actual -> assertEquals(actual, value));\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-            { Linker.Option.critical() },\n+            { Linker.Option.critical(false) },\n@@ -197,1 +197,1 @@\n-                    new Linker.Option[]{Linker.Option.critical(), Linker.Option.captureCallState(\"errno\")},\n+                    new Linker.Option[]{Linker.Option.critical(false), Linker.Option.captureCallState(\"errno\")},\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ *\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCritical\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCritical extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Critical\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.critical(false));\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.critical(false));\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.critical(false));\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result, 0L);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result, 0L);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+    public record AllowHeapCase(IntFunction<MemorySegment> newArraySegment, ValueLayout elementLayout,\n+                                String fName, FunctionDescriptor fDesc, boolean readOnly) {}\n+\n+    @Test(dataProvider = \"allowHeapCases\")\n+    public void testAllowHeap(AllowHeapCase testCase) throws Throwable {\n+        MethodHandle handle = downcallHandle(testCase.fName(), testCase.fDesc(), Linker.Option.critical(true));\n+        int elementCount = 10;\n+        MemorySegment heapSegment = testCase.newArraySegment().apply(elementCount);\n+        if (testCase.readOnly()) {\n+            heapSegment = heapSegment.asReadOnly();\n+        }\n+        SequenceLayout sequence = MemoryLayout.sequenceLayout(elementCount, testCase.elementLayout());\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            TestValue[] tvs = genTestArgs(testCase.fDesc(), arena);\n+            Object[] args = Stream.of(tvs).map(TestValue::value).toArray();\n+\n+            \/\/ inject our custom last three arguments\n+            args[args.length - 1] = (int) sequence.byteSize();\n+            TestValue sourceSegment = genTestValue(sequence, arena);\n+            args[args.length - 2] = sourceSegment.value();\n+            args[args.length - 3] = heapSegment;\n+\n+            if (handle.type().parameterType(0) == SegmentAllocator.class) {\n+                Object[] newArgs = new Object[args.length + 1];\n+                newArgs[0] = arena;\n+                System.arraycopy(args, 0, newArgs, 1, args.length);\n+                args = newArgs;\n+            }\n+\n+            Object o = handle.invokeWithArguments(args);\n+\n+            if (o != null) {\n+                tvs[0].check(o);\n+            }\n+\n+            \/\/ check that writes went through to array\n+            sourceSegment.check(heapSegment);\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] allowHeapCases() {\n+        FunctionDescriptor voidDesc = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        FunctionDescriptor intDesc = voidDesc.changeReturnLayout(C_INT).insertArgumentLayouts(0, C_INT);\n+        StructLayout L2 = MemoryLayout.structLayout(\n+            C_LONG_LONG.withName(\"x\"),\n+            C_LONG_LONG.withName(\"y\")\n+        );\n+        FunctionDescriptor L2Desc = voidDesc.changeReturnLayout(L2).insertArgumentLayouts(0, L2);\n+        StructLayout L3 = MemoryLayout.structLayout(\n+            C_LONG_LONG.withName(\"x\"),\n+            C_LONG_LONG.withName(\"y\"),\n+            C_LONG_LONG.withName(\"z\")\n+        );\n+        FunctionDescriptor L3Desc = voidDesc.changeReturnLayout(L3).insertArgumentLayouts(0, L3);\n+        FunctionDescriptor stackDesc = voidDesc.insertArgumentLayouts(0,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_CHAR, C_SHORT, C_INT);\n+\n+        List<AllowHeapCase> cases = new ArrayList<>();\n+\n+        for (HeapSegmentFactory hsf : HeapSegmentFactory.values()) {\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_int\", intDesc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_return_buffer\", L2Desc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_imr\", L3Desc, false));\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void_stack\", stackDesc, false));\n+            \/\/ readOnly\n+            cases.add(new AllowHeapCase(hsf.newArray, hsf.elementLayout, \"test_allow_heap_void\", voidDesc, true));\n+        }\n+\n+        return cases.stream().map(e -> new Object[]{ e }).toArray(Object[][]::new);\n+    }\n+\n+    private enum HeapSegmentFactory {\n+        BYTE(i -> MemorySegment.ofArray(new byte[i]), ValueLayout.JAVA_BYTE),\n+        SHORT(i -> MemorySegment.ofArray(new short[i]), ValueLayout.JAVA_SHORT),\n+        CHAR(i -> MemorySegment.ofArray(new char[i]), ValueLayout.JAVA_CHAR),\n+        INT(i -> MemorySegment.ofArray(new int[i]), ValueLayout.JAVA_INT),\n+        LONG(i -> MemorySegment.ofArray(new long[i]), ValueLayout.JAVA_LONG),\n+        FLOAT(i -> MemorySegment.ofArray(new float[i]), ValueLayout.JAVA_FLOAT),\n+        DOUBLE(i -> MemorySegment.ofArray(new double[i]), ValueLayout.JAVA_DOUBLE);\n+\n+        IntFunction<MemorySegment> newArray;\n+        ValueLayout elementLayout;\n+\n+        private HeapSegmentFactory(IntFunction<MemorySegment> newArray, ValueLayout elementLayout) {\n+            this.newArray = newArray;\n+            this.elementLayout = elementLayout;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/critical\/TestCritical.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.critical());\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.critical(false));\n","filename":"test\/jdk\/java\/foreign\/critical\/TestCriticalUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/trivial\/TestCriticalUpcall.java","status":"renamed"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @requires vm.debug\n+ * @run main\/othervm\n+ *   -Xms1g -Xmx1g\n+ *   -XX:+CheckUnhandledOops\n+ *   -Xlog:gc -Xlog:gc+jni=debug\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestStressAllowHeap\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * Test verifies the GCLocker::lock_critical slow path with FFM.\n+ * This is the case where we enter a critical section with _needs_gc == true,\n+ * and need to take a safepoint.\n+ *\n+ * Based on gc\/TestJNICriticalStressTest\n+ *\/\n+public class TestStressAllowHeap {\n+    private static final long DURATION_SECONDS = 30;\n+\n+    public static void main(String... args) throws Exception {\n+        System.out.println(\"Running for \" + DURATION_SECONDS + \" secs\");\n+\n+        int numCriticalThreads = Runtime.getRuntime().availableProcessors();\n+        System.out.println(\"Starting \" + numCriticalThreads + \" critical threads\");\n+        for (int i = 0; i < numCriticalThreads; i += 1) {\n+            Thread.ofPlatform().start(new CriticalWorker());\n+        }\n+\n+        long durationMS = 1000L * DURATION_SECONDS;\n+        try {\n+            Thread.sleep(durationMS);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+            System.exit(-1);\n+        }\n+\n+        \/\/ hitting the problematic code path doesn't seem to be guaranteed\n+        \/\/ and we can not guarantee it by, e.g. stalling in a critical method\n+        \/\/ since that can lock up the VM (and our test code)\n+    }\n+\n+    private static class CriticalWorker extends NativeTestHelper implements Runnable {\n+        static {\n+            System.loadLibrary(\"Critical\");\n+        }\n+\n+        private void doStep(MethodHandle handle, SequenceLayout sequence) throws Throwable {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment heapSegment = MemorySegment.ofArray(new int[(int) sequence.elementCount()]);\n+                TestValue sourceSegment = genTestValue(sequence, arena);\n+\n+                handle.invokeExact(heapSegment, (MemorySegment) sourceSegment.value(), (int) sequence.byteSize());\n+\n+                \/\/ check that writes went through to array\n+                sourceSegment.check(heapSegment);\n+            }\n+        }\n+\n+        @Override\n+        public void run() {\n+            FunctionDescriptor fDesc = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+            MethodHandle handle = Linker.nativeLinker().downcallHandle(\n+                SymbolLookup.loaderLookup().find(\"test_allow_heap_void\").get(),\n+                fDesc,\n+                Linker.Option.critical(true));\n+            int elementCount = 10;\n+            SequenceLayout sequence = MemoryLayout.sequenceLayout(elementCount, C_INT);\n+            while (true) {\n+                try {\n+                    doStep(handle, sequence);\n+                } catch(Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/critical\/TestStressAllowHeap.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void empty() {}\n+\n+EXPORT int identity(int value) {\n+    return value;\n+}\n+\n+\/\/ 128 bit struct returned in buffer on SysV\n+struct Big {\n+    long long x;\n+    long long y;\n+};\n+\n+EXPORT struct Big with_return_buffer() {\n+    struct Big b;\n+    b.x = 10;\n+    b.y = 11;\n+    return b;\n+}\n+\n+EXPORT void do_upcall(void(*f)(void)) {\n+    f();\n+}\n+\n+\/\/ copy bytes into heap array\n+EXPORT void test_allow_heap_void(unsigned char* heapArr, unsigned char* nativeArr, int numBytes) {\n+    for (int i = 0; i < numBytes; i++) {\n+        heapArr[i] = nativeArr[i];\n+    }\n+}\n+\n+EXPORT int test_allow_heap_int(int a0, unsigned char* heapArr, unsigned char* nativeArr, int numBytes) {\n+    for (int i = 0; i < numBytes; i++) {\n+        heapArr[i] = nativeArr[i];\n+    }\n+    return a0;\n+}\n+\n+struct L2 {\n+    long long x;\n+    long long y;\n+};\n+\n+EXPORT struct L2 test_allow_heap_return_buffer(struct L2 a0, unsigned char* heapArr, unsigned char* nativeArr, int numBytes) {\n+    for (int i = 0; i < numBytes; i++) {\n+        heapArr[i] = nativeArr[i];\n+    }\n+    return a0;\n+}\n+\n+struct L3 {\n+    long long x;\n+    long long y;\n+    long long z;\n+};\n+\n+EXPORT struct L3 test_allow_heap_imr(struct L3 a0, unsigned char* heapArr, unsigned char* nativeArr, int numBytes) {\n+    for (int i = 0; i < numBytes; i++) {\n+        heapArr[i] = nativeArr[i];\n+    }\n+    return a0;\n+}\n+\n+\/\/ copy bytes into heap array\n+EXPORT void test_allow_heap_void_stack(long long a0, long long a1, long long a2, long long a3, long long a4, long long a5,\n+                                       long long a6, long long a7, char c0, short s0, int i0,\n+                                       unsigned char* heapArr, unsigned char* nativeArr, int numBytes) {\n+    for (int i = 0; i < numBytes; i++) {\n+        heapArr[i] = nativeArr[i];\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/critical\/libCritical.c","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @library ..\/ \/test\/lib\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCritical\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestCritical extends NativeTestHelper {\n-\n-    static {\n-        System.loadLibrary(\"Critical\");\n-    }\n-\n-    @Test\n-    public void testEmpty() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.critical());\n-        handle.invokeExact();\n-    }\n-\n-    @Test\n-    public void testIdentity() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.critical());\n-        int result = (int) handle.invokeExact(42);\n-        assertEquals(result, 42);\n-    }\n-\n-    @Test\n-    public void testWithReturnBuffer() throws Throwable {\n-        StructLayout bigLayout = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"));\n-\n-        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.critical());\n-        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n-            long x = (long) vhX.get(result, 0L);\n-            assertEquals(x, 10);\n-            long y = (long) vhY.get(result, 0L);\n-            assertEquals(y, 11);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCritical.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <errno.h>\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-EXPORT void empty() {}\n-\n-EXPORT int identity(int value) {\n-    return value;\n-}\n-\n-\/\/ 128 bit struct returned in buffer on SysV\n-struct Big {\n-    long long x;\n-    long long y;\n-};\n-\n-EXPORT struct Big with_return_buffer() {\n-    struct Big b;\n-    b.x = 10;\n-    b.y = 11;\n-    return b;\n-}\n-\n-EXPORT void do_upcall(void(*f)(void)) {\n-    f();\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/libCritical.c","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -116,1 +116,1 @@\n-            func_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n+            func_critical_v = abi.downcallHandle(fd, Linker.Option.critical(false));\n@@ -124,1 +124,1 @@\n-            identity_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n+            identity_critical_v = abi.downcallHandle(fd, Linker.Option.critical(false));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.SymbolLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class CriticalCalls {\n+\n+    static final MethodHandle PINNED;\n+    static final MethodHandle NOT_PINNED;\n+\n+    static {\n+        System.loadLibrary(\"CriticalCalls\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+        MemorySegment sumIntsSym = lookup.find(\"sum_ints\").get();\n+        FunctionDescriptor sumIntsDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT);\n+\n+        PINNED = Linker.nativeLinker().downcallHandle(\n+            sumIntsSym,\n+            sumIntsDesc,\n+            Linker.Option.critical(true));\n+        NOT_PINNED = Linker.nativeLinker().downcallHandle(\n+            sumIntsSym,\n+            sumIntsDesc,\n+            Linker.Option.critical(false));\n+    }\n+\n+    @Param({\"100\", \"10000\", \"1000000\"})\n+    int size;\n+\n+    int[] arr;\n+    SegmentAllocator recycler;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            arr[i] = i;\n+        }\n+\n+        recycler = SegmentAllocator.prefixAllocator(Arena.ofAuto().allocate(JAVA_INT, arr.length));\n+    }\n+\n+    @Benchmark\n+    public int callPinned() throws Throwable {\n+        return (int) PINNED.invokeExact(MemorySegment.ofArray(arr), arr.length);\n+    }\n+\n+    @Benchmark\n+    public int callNotPinned() throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment nativeArr = arena.allocateFrom(JAVA_INT, arr);\n+            return (int) NOT_PINNED.invokeExact(nativeArr, arr.length);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int callRecycled() throws Throwable {\n+        MemorySegment nativeArr = recycler.allocateFrom(JAVA_INT, arr);\n+        return (int) NOT_PINNED.invokeExact(nativeArr, arr.length);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CriticalCalls.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-    static final Unsafe unsafe;\n+    public static final Unsafe unsafe;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int sum_ints(int* arr, int size) {\n+  int sum = 0;\n+  for (int i = 0; i < size; i++) {\n+    sum += arr[i];\n+  }\n+  return sum;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libCriticalCalls.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"jlong.h\"\n+\n@@ -30,1 +32,1 @@\n-    jlong addr = (jlong)(void*)str;\n+    jlong addr = ptr_to_jlong(str);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToCString.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"jlong.h\"\n+\n@@ -31,1 +33,1 @@\n-    return (*env)->NewStringUTF(env, (char*)(void*)addr);\n+    return (*env)->NewStringUTF(env, jlong_to_ptr(addr));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayCriticalXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Release}PrimitiveArrayCritical to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayCriticalXorOpImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayElementsXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Release}ByteArrayElements to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayElementsXorOpImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayForeignXorOpCriticalImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(true));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayForeignXorOpCriticalImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        xor_op.invokeExact(MemorySegment.ofArray(src).asSlice(sOff), MemorySegment.ofArray(dst).asSlice(dOff), len);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpCriticalImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayForeignXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayForeignXorOpImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment srcBuf = arena.allocateFrom(JAVA_BYTE, MemorySegment.ofArray(src), JAVA_BYTE, sOff, len);\n+            MemorySegment dstBuf = arena.allocateFrom(JAVA_BYTE, MemorySegment.ofArray(dst), JAVA_BYTE, dOff, len);\n+            xor_op.invokeExact(srcBuf, dstBuf, len);\n+            MemorySegment.copy(dstBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpImpl.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_INT;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.C_POINTER;\n+\n+public class GetArrayForeignXorOpInitImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayForeignXorOpInitImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment srcBuf = arena.allocate(len);\n+            MemorySegment.copy(src, sOff, srcBuf, JAVA_BYTE, 0, len);\n+            MemorySegment dstBuf = arena.allocate(len);\n+            MemorySegment.copy(dst, dOff, dstBuf, JAVA_BYTE, 0, len);\n+            xor_op.invokeExact(srcBuf, dstBuf, len);\n+            MemorySegment.copy(dstBuf, JAVA_BYTE, 0, dst, dOff, len);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayForeignXorOpInitImpl.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public class GetArrayRegionXorOpImpl implements XorOp {\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+    }\n+\n+    \/\/ Uses {Get|Set}ByteArrayRegion to access the byte arrays\n+    public native void xor(byte[] src, int sOff, byte[] dst, int dOff, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayRegionXorOpImpl.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import org.openjdk.bench.java.lang.foreign.Utils;\n+import sun.misc.Unsafe;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+\n+import static java.lang.foreign.Linker.Option.critical;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.openjdk.bench.java.lang.foreign.CLayouts.*;\n+\n+public class GetArrayUnsafeXorOpImpl implements XorOp {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    static final int BYTE_ARR_OFFSET = Utils.unsafe.arrayBaseOffset(byte[].class);\n+\n+    static {\n+        System.loadLibrary(\"jnitest\");\n+\n+        Linker linker;\n+        linker = Linker.nativeLinker();\n+        FunctionDescriptor xor_op_func = FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT);\n+        xor_op = linker.downcallHandle(SymbolLookup.loaderLookup().find(\"xor_op\").orElseThrow(), xor_op_func, critical(false));\n+    }\n+\n+    static final MethodHandle xor_op;\n+    GetArrayUnsafeXorOpImpl() {\n+    }\n+\n+    public void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable {\n+        long srcBuf = UNSAFE.allocateMemory(len);\n+        long dstBuf = UNSAFE.allocateMemory(len);\n+        UNSAFE.copyMemory(src, sOff + BYTE_ARR_OFFSET, null, srcBuf, len);\n+        UNSAFE.copyMemory(dst, dOff + BYTE_ARR_OFFSET, null, dstBuf, len);\n+        xorOp(srcBuf, dstBuf, len);\n+        UNSAFE.copyMemory(null, dstBuf, dst, dOff + BYTE_ARR_OFFSET, len);\n+        UNSAFE.freeMemory(srcBuf);\n+        UNSAFE.freeMemory(dstBuf);\n+    }\n+\n+    native void xorOp(long src, long dst, int len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/GetArrayUnsafeXorOpImpl.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+public interface XorOp {\n+\n+    void xor(byte[] src, int sOff, byte[] dst, int dOff, int len) throws Throwable;\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorOp.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+package org.openjdk.bench.java.lang.foreign.xor;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+\n+public class XorTest {\n+\n+    XorOp impl = null;\n+    int alen;\n+    int off;\n+    int len;\n+    byte[] src, dst;\n+\n+    @Param\n+    SizeKind sizeKind;\n+\n+    @Param\n+    ArrayKind arrayKind;\n+\n+    public enum SizeKind {\n+        SMALL,\n+        MEDIUM,\n+        LARGE;\n+    }\n+\n+    public enum ArrayKind {\n+        JNI_ELEMENTS,\n+        JNI_REGION,\n+        JNI_CRITICAL,\n+        FOREIGN_NO_INIT,\n+        FOREIGN_INIT,\n+        FOREIGN_CRITICAL,\n+        UNSAFE;\n+    }\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        switch (arrayKind) {\n+            case JNI_CRITICAL:\n+                impl = new GetArrayCriticalXorOpImpl();\n+                break;\n+            case JNI_ELEMENTS:\n+                impl = new GetArrayElementsXorOpImpl();\n+                break;\n+            case JNI_REGION:\n+                impl = new GetArrayRegionXorOpImpl();\n+                break;\n+            case FOREIGN_NO_INIT:\n+                impl = new GetArrayForeignXorOpImpl();\n+                break;\n+            case FOREIGN_INIT:\n+                impl = new GetArrayForeignXorOpInitImpl();\n+                break;\n+            case FOREIGN_CRITICAL:\n+                impl = new GetArrayForeignXorOpCriticalImpl();\n+                break;\n+            case UNSAFE:\n+                impl = new GetArrayUnsafeXorOpImpl();\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(arrayKind.toString());\n+        }\n+\n+        switch (sizeKind) {\n+            case SMALL:\n+                alen = 1048576;             \/\/ 1 MB\n+                off = 1024 * 10;\n+                len = 1024 * 100;           \/\/ 100 KB\n+                break;\n+            case MEDIUM:\n+                alen = 1048576 * 8;         \/\/ 8 MB\n+                off = 1048576 * 1;\n+                len = 1048576 * 2;          \/\/ 2 MB\n+                break;\n+            case LARGE:\n+                alen = 1048576 * 100;       \/\/ 100 MB\n+                off = 1048576 * 5;\n+                len = 1048576 * 10;         \/\/ 10 MB\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(sizeKind.toString());\n+        }\n+\n+        src = new byte[alen];\n+        dst = new byte[alen];\n+        Arrays.fill(src, off, off + len, (byte)0xaa);\n+        Arrays.fill(dst, off, off + len, (byte)0x5a);\n+        check();\n+    }\n+\n+    void check() throws Throwable {\n+        impl.xor(src, off, dst, off, len);\n+        if (!verify(dst, off, off + len, (byte)0xf0)) {\n+            throw new IllegalStateException(\"Failed to verify\");\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void xor() throws Throwable {\n+        impl.xor(src, off, dst, off, len);\n+    }\n+\n+    static boolean verify(byte[] buf, int start, int end, byte val) {\n+        for (int i = start; i < end; ++i) {\n+            if (buf[i] != val)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/XorTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+#include <stdlib.h>\n+#include <jni.h>\n+\n+JNIEXPORT void xor_op(jbyte *restrict src, jbyte *restrict dst, jint len) {\n+    for (int i = 0; i < len; ++i) {\n+        dst[i] ^= src[i];\n+    }\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayCriticalXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayCriticalXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len) {\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    sbuf = (*env)->GetPrimitiveArrayCritical(env, src, &sIsCopy);\n+    dbuf = (*env)->GetPrimitiveArrayCritical(env, dst, &dIsCopy);\n+    xor_op(&sbuf[sOff], &dbuf[dOff], len);\n+    (*env)->ReleasePrimitiveArrayCritical(env, dst, dbuf, 0);\n+    (*env)->ReleasePrimitiveArrayCritical(env, src, sbuf, JNI_ABORT);\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayElementsXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayElementsXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len) {\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+    jboolean sIsCopy = JNI_FALSE;\n+    jboolean dIsCopy = JNI_FALSE;\n+\n+    sbuf = (*env)->GetByteArrayElements(env, src, &sIsCopy);\n+    dbuf = (*env)->GetByteArrayElements(env, dst, &dIsCopy);\n+    xor_op(&sbuf[sOff], &dbuf[dOff], len);\n+    (*env)->ReleaseByteArrayElements(env, dst, dbuf, 0);\n+    (*env)->ReleaseByteArrayElements(env, src, sbuf, JNI_ABORT);\n+}\n+\n+\/*\n+ * Class:     com_oracle_jnitest_GetArrayRegionXorOpImpl\n+ * Method:    xor\n+ * Signature: ([BI[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayRegionXorOpImpl_xor\n+  (JNIEnv *env, jobject obj, jbyteArray src, jint sOff, jbyteArray dst, jint dOff, jint len) {\n+    jbyte *sbuf = NULL;\n+    jbyte *dbuf = NULL;\n+\n+    sbuf = malloc(len);\n+    dbuf = malloc(len);\n+\n+    (*env)->GetByteArrayRegion(env, src, sOff, len, sbuf);\n+    (*env)->GetByteArrayRegion(env, dst, dOff, len, dbuf);\n+    xor_op(sbuf, dbuf, len);\n+    (*env)->SetByteArrayRegion(env, dst, dOff, len, dbuf);\n+\n+    free(dbuf);\n+    free(sbuf);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_java_lang_foreign_xor_GetArrayUnsafeXorOpImpl_xorOp\n+  (JNIEnv *env, jobject obj, jlong src, jlong dst, jint len) {\n+    jbyte *sbuf = (jbyte*)(void*)src;\n+    jbyte *dbuf = (jbyte*)(void*)dst;\n+    xor_op(sbuf, dbuf, len);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/xor\/libjnitest.c","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}