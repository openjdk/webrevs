{"files":[{"patch":"@@ -390,6 +390,12 @@\n-  \/\/ Return true if the input\/output mask of the operation must be a packed\n-  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n-  \/\/\n-  \/\/ By default, all the mask query operations without predicate support\n-  \/\/ requires the mask to be saved in a boolean vector.\n-  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+    \/\/ Only SVE supports the predicate feature.\n+    if (UseSVE == 0) {\n+      \/\/ On architectures that do not support the predicate feature, vector\n+      \/\/ mask is stored in a normal vector with the type of \"TypeVect\" varing\n+      \/\/ from \"TypeVectA\" to \"TypeVectZ\" based on the vector length in bytes.\n+      \/\/ It cannot be a \"TypeVectMask\".\n+      assert(vt->isa_vectmask() == nullptr, \"mask type not match\");\n+      return false;\n+    }\n+\n+    assert(vt->isa_vectmask(), \"The mask type must be a TypeVectMask on SVE\");\n@@ -397,6 +403,0 @@\n-      case Op_VectorMaskFirstTrue:\n-      case Op_VectorMaskLastTrue:\n-      case Op_VectorMaskTrueCount:\n-        \/\/ These ops are implemented with predicate instructions if input\n-        \/\/ mask is a predciate.\n-        return vt->isa_vectmask() == nullptr;\n@@ -405,2 +405,8 @@\n-        \/\/ These two ops are implemented with vector instructions on all\n-        \/\/ architectures. SVE does not have native predicate instructions.\n+        \/\/ SVE does not have native predicate instructions for these two ops.\n+        \/\/ Instead, they are implemented with vector instructions. Hence, to\n+        \/\/ improve the performance, we prefer saving the mask in a vector as\n+        \/\/ the input\/output of these IRs.\n+        return false;\n+      default:\n+        \/\/ By default, all the mask operations are implemented with predicate\n+        \/\/ instructions with a predicate input\/output.\n@@ -409,1 +415,0 @@\n-    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -380,6 +380,12 @@\n-  \/\/ Return true if the input\/output mask of the operation must be a packed\n-  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n-  \/\/\n-  \/\/ By default, all the mask query operations without predicate support\n-  \/\/ requires the mask to be saved in a boolean vector.\n-  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+    \/\/ Only SVE supports the predicate feature.\n+    if (UseSVE == 0) {\n+      \/\/ On architectures that do not support the predicate feature, vector\n+      \/\/ mask is stored in a normal vector with the type of \"TypeVect\" varing\n+      \/\/ from \"TypeVectA\" to \"TypeVectZ\" based on the vector length in bytes.\n+      \/\/ It cannot be a \"TypeVectMask\".\n+      assert(vt->isa_vectmask() == nullptr, \"mask type not match\");\n+      return false;\n+    }\n+\n+    assert(vt->isa_vectmask(), \"The mask type must be a TypeVectMask on SVE\");\n@@ -387,6 +393,0 @@\n-      case Op_VectorMaskFirstTrue:\n-      case Op_VectorMaskLastTrue:\n-      case Op_VectorMaskTrueCount:\n-        \/\/ These ops are implemented with predicate instructions if input\n-        \/\/ mask is a predciate.\n-        return vt->isa_vectmask() == nullptr;\n@@ -395,2 +395,8 @@\n-        \/\/ These two ops are implemented with vector instructions on all\n-        \/\/ architectures. SVE does not have native predicate instructions.\n+        \/\/ SVE does not have native predicate instructions for these two ops.\n+        \/\/ Instead, they are implemented with vector instructions. Hence, to\n+        \/\/ improve the performance, we prefer saving the mask in a vector as\n+        \/\/ the input\/output of these IRs.\n+        return false;\n+      default:\n+        \/\/ By default, all the mask operations are implemented with predicate\n+        \/\/ instructions with a predicate input\/output.\n@@ -399,1 +405,0 @@\n-    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1006,2 +1006,2 @@\n-bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n-  return vt->isa_vectmask() == nullptr;\n+bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2295,2 +2295,2 @@\n-bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n-  return vt->isa_vectmask() == nullptr;\n+bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,2 +168,3 @@\n-  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n-    return vt->isa_vectmask() == nullptr;\n+  bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+    \/\/ Prefer predicate if the mask type is \"TypeVectMask\".\n+    return vt->isa_vectmask() != nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1812,2 +1812,2 @@\n-bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n-  return vt->isa_vectmask() == nullptr;\n+bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2106,2 +2106,3 @@\n-bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n-  return vt->isa_vectmask() == nullptr;\n+bool Matcher::mask_op_prefers_predicate(int opcode, const TypeVect* vt) {\n+  \/\/ Prefer predicate if the mask type is \"TypeVectMask\".\n+  return vt->isa_vectmask() != nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -336,3 +336,4 @@\n-  \/\/ Return true if the input\/output mask of the operation must be a packed\n-  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n-  static bool mask_op_uses_packed_vector(int opcode, const TypeVect* vt);\n+  \/\/ Identify if a vector mask operation requires the input\/output mask to be\n+  \/\/ saved with a predicate type (i.e. TypeVectMask) or not. Return true if it\n+  \/\/ requires a predicate type. And return false if it requires a vector type.\n+  static bool mask_op_prefers_predicate(int opcode, const TypeVect* vt);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-  if (Matcher::mask_op_uses_packed_vector(mopc, mask_vec->bottom_type()->is_vect())) {\n+  if (!Matcher::mask_op_prefers_predicate(mopc, mask_vec->bottom_type()->is_vect())) {\n@@ -711,1 +711,1 @@\n-    if (!Matcher::mask_op_uses_packed_vector(opc, vt)) {\n+    if (Matcher::mask_op_prefers_predicate(opc, vt)) {\n@@ -2548,1 +2548,1 @@\n-      if (Matcher::mask_op_uses_packed_vector(Op_VectorMaskToLong, opd->bottom_type()->is_vect())) {\n+      if (!Matcher::mask_op_prefers_predicate(Op_VectorMaskToLong, opd->bottom_type()->is_vect())) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1907,1 +1907,1 @@\n-    assert(Matcher::mask_op_uses_packed_vector(Opcode(), mask->bottom_type()->is_vect()), \"sanity\");\n+    assert(!Matcher::mask_op_prefers_predicate(Opcode(), mask->bottom_type()->is_vect()), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}