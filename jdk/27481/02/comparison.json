{"files":[{"patch":"@@ -390,0 +390,22 @@\n+  \/\/ Return true if the input\/output mask of the operation must be a packed\n+  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n+  \/\/\n+  \/\/ By default, all the mask query operations without predicate support\n+  \/\/ requires the mask to be saved in a boolean vector.\n+  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+    switch (opcode) {\n+      case Op_VectorMaskFirstTrue:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskTrueCount:\n+        \/\/ These ops are implemented with predicate instructions if input\n+        \/\/ mask is a predciate.\n+        return vt->isa_vectmask() == nullptr;\n+      case Op_VectorMaskToLong:\n+      case Op_VectorLongToMask:\n+        \/\/ These two ops are implemented with vector instructions on all\n+        \/\/ architectures. SVE does not have native predicate instructions.\n+        return true;\n+    }\n+    return false;\n+  }\n+\n@@ -6246,2 +6268,16 @@\n-instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n-  predicate(UseSVE > 0);\n+instruct vmask_tolong_sve(iRegLNoSp dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 && !VM_Version::supports_svebitperm());\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    __ sve_vmask_tolong($dst$$Register, $src$$FloatRegister,\n+                        $tmp$$FloatRegister, Matcher::vector_length(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_tolong_sve2(iRegLNoSp dst, vReg src, vReg tmp1, vReg tmp2) %{\n+  predicate(VM_Version::supports_svebitperm());\n@@ -6250,1 +6286,1 @@\n-  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n+  format %{ \"vmask_tolong_sve2 $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n@@ -6252,4 +6288,5 @@\n-    __ sve_vmask_tolong($dst$$Register, $src$$PRegister,\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    __ sve2_vmask_tolong($dst$$Register, $src$$FloatRegister,\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                         Matcher::vector_length(this, $src));\n@@ -6262,1 +6299,1 @@\n-instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(vReg dst, iRegL src, vReg tmp) %{\n@@ -6264,2 +6301,2 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n-  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp\" %}\n@@ -6267,4 +6304,2 @@\n-    __ sve_vmask_fromlong($dst$$PRegister, $src$$Register,\n-                          Matcher::vector_element_basic_type(this),\n-                          Matcher::vector_length(this),\n-                          $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    __ sve_vmask_fromlong($dst$$FloatRegister, $src$$Register,\n+                          $tmp$$FloatRegister, Matcher::vector_length(this));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -380,0 +380,22 @@\n+  \/\/ Return true if the input\/output mask of the operation must be a packed\n+  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n+  \/\/\n+  \/\/ By default, all the mask query operations without predicate support\n+  \/\/ requires the mask to be saved in a boolean vector.\n+  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+    switch (opcode) {\n+      case Op_VectorMaskFirstTrue:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskTrueCount:\n+        \/\/ These ops are implemented with predicate instructions if input\n+        \/\/ mask is a predciate.\n+        return vt->isa_vectmask() == nullptr;\n+      case Op_VectorMaskToLong:\n+      case Op_VectorLongToMask:\n+        \/\/ These two ops are implemented with vector instructions on all\n+        \/\/ architectures. SVE does not have native predicate instructions.\n+        return true;\n+    }\n+    return false;\n+  }\n+\n@@ -4300,2 +4322,16 @@\n-instruct vmask_tolong_sve(iRegLNoSp dst, pReg src, vReg tmp1, vReg tmp2) %{\n-  predicate(UseSVE > 0);\n+instruct vmask_tolong_sve(iRegLNoSp dst, vReg src, vReg tmp) %{\n+  predicate(UseSVE > 0 && !VM_Version::supports_svebitperm());\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP tmp);\n+  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    __ sve_vmask_tolong($dst$$Register, $src$$FloatRegister,\n+                        $tmp$$FloatRegister, Matcher::vector_length(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_tolong_sve2(iRegLNoSp dst, vReg src, vReg tmp1, vReg tmp2) %{\n+  predicate(VM_Version::supports_svebitperm());\n@@ -4304,1 +4340,1 @@\n-  format %{ \"vmask_tolong_sve $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n+  format %{ \"vmask_tolong_sve2 $dst, $src\\t# KILL $tmp1, $tmp2\" %}\n@@ -4306,4 +4342,5 @@\n-    __ sve_vmask_tolong($dst$$Register, $src$$PRegister,\n-                        Matcher::vector_element_basic_type(this, $src),\n-                        Matcher::vector_length(this, $src),\n-                        $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    \/\/ Input \"src\" is a vector of boolean represented as\n+    \/\/ bytes with 0x00\/0x01 as element values.\n+    __ sve2_vmask_tolong($dst$$Register, $src$$FloatRegister,\n+                         $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n+                         Matcher::vector_length(this, $src));\n@@ -4316,1 +4353,1 @@\n-instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(vReg dst, iRegL src, vReg tmp) %{\n@@ -4318,2 +4355,2 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n-  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vmask_fromlong $dst, $src\\t# vector (sve2). KILL $tmp\" %}\n@@ -4321,4 +4358,2 @@\n-    __ sve_vmask_fromlong($dst$$PRegister, $src$$Register,\n-                          Matcher::vector_element_basic_type(this),\n-                          Matcher::vector_length(this),\n-                          $tmp1$$FloatRegister, $tmp2$$FloatRegister);\n+    __ sve_vmask_fromlong($dst$$FloatRegister, $src$$Register,\n+                          $tmp$$FloatRegister, Matcher::vector_length(this));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1402,5 +1402,11 @@\n-\/\/ Pack the lowest-numbered bit of each mask element in src into a long value\n-\/\/ in dst, at most the first 64 lane elements.\n-\/\/ Clobbers: rscratch1, if UseSVE=1 or the hardware doesn't support FEAT_BITPERM.\n-void C2_MacroAssembler::sve_vmask_tolong(Register dst, PRegister src, BasicType bt, int lane_cnt,\n-                                         FloatRegister vtmp1, FloatRegister vtmp2) {\n+\/\/ Pack the value of each mask element in \"src\" into a long value in \"dst\", at most\n+\/\/ the first 64 lane elements. The input \"src\" is a vector of boolean represented as\n+\/\/ bytes with 0x00\/0x01 as element values. Each lane value from \"src\" is packed into\n+\/\/ one bit in \"dst\".\n+\/\/\n+\/\/ Example:   src = 0x0001010000010001 0100000001010001, lane_cnt = 16\n+\/\/ Expected:  dst = 0x658D\n+\/\/\n+\/\/ Clobbers: rscratch1\n+void C2_MacroAssembler::sve_vmask_tolong(Register dst, FloatRegister src,\n+                                         FloatRegister vtmp, int lane_cnt) {\n@@ -1409,1 +1415,16 @@\n-  assert_different_registers(vtmp1, vtmp2);\n+  assert_different_registers(src, vtmp);\n+  assert(UseSVE > 0, \"must be\");\n+\n+  \/\/ Compress the lowest 8 bytes.\n+  fmovd(dst, src);\n+  bytemask_compress(dst);\n+  if (lane_cnt <= 8) return;\n+\n+  \/\/ Repeat on higher bytes and join the results.\n+  \/\/ Compress 8 bytes in each iteration.\n+  for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n+    sve_extract_integral(rscratch1, T_LONG, src, idx, vtmp);\n+    bytemask_compress(rscratch1);\n+    orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+  }\n+}\n@@ -1411,3 +1432,8 @@\n-  Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n-  \/\/ Example:   src = 0b01100101 10001101, bt = T_BYTE, lane_cnt = 16\n-  \/\/ Expected:  dst = 0x658D\n+\/\/ The function is same as above \"sve_vmask_tolong\", but it uses SVE2's BEXT\n+\/\/ instruction which requires the FEAT_BITPERM feature.\n+void C2_MacroAssembler::sve2_vmask_tolong(Register dst, FloatRegister src,\n+                                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                                          int lane_cnt) {\n+  assert(lane_cnt <= 64 && is_power_of_2(lane_cnt), \"Unsupported lane count\");\n+  assert_different_registers(src, vtmp1, vtmp2);\n+  assert(UseSVE > 1 && VM_Version::supports_svebitperm(), \"must be\");\n@@ -1415,6 +1441,5 @@\n-  \/\/ Convert the mask into vector with sequential bytes.\n-  \/\/ vtmp1 = 0x00010100 0x00010001 0x01000000 0x01010001\n-  sve_cpy(vtmp1, size, src, 1, false);\n-  if (bt != T_BYTE) {\n-    sve_vector_narrow(vtmp1, B, vtmp1, size, vtmp2);\n-  }\n+  \/\/ Given a vector with the value 0x00 or 0x01 in each byte, the basic idea\n+  \/\/ is to compress each significant bit of the byte in a cross-lane way. Due\n+  \/\/ to the lack of a cross-lane bit-compress instruction, we use BEXT\n+  \/\/ (bit-compress in each lane) with the biggest lane size (T = D) then\n+  \/\/ concatenate the results.\n@@ -1422,47 +1447,21 @@\n-  if (UseSVE > 1 && VM_Version::supports_svebitperm()) {\n-    \/\/ Given a vector with the value 0x00 or 0x01 in each byte, the basic idea\n-    \/\/ is to compress each significant bit of the byte in a cross-lane way. Due\n-    \/\/ to the lack of a cross-lane bit-compress instruction, we use BEXT\n-    \/\/ (bit-compress in each lane) with the biggest lane size (T = D) then\n-    \/\/ concatenate the results.\n-\n-    \/\/ The second source input of BEXT, initialized with 0x01 in each byte.\n-    \/\/ vtmp2 = 0x01010101 0x01010101 0x01010101 0x01010101\n-    sve_dup(vtmp2, B, 1);\n-\n-    \/\/ BEXT vtmp1.D, vtmp1.D, vtmp2.D\n-    \/\/ vtmp1 = 0x0001010000010001 | 0x0100000001010001\n-    \/\/ vtmp2 = 0x0101010101010101 | 0x0101010101010101\n-    \/\/         ---------------------------------------\n-    \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n-    sve_bext(vtmp1, D, vtmp1, vtmp2);\n-\n-    \/\/ Concatenate the lowest significant 8 bits in each 8 bytes, and extract the\n-    \/\/ result to dst.\n-    \/\/ vtmp1 = 0x0000000000000000 | 0x000000000000658D\n-    \/\/ dst   = 0x658D\n-    if (lane_cnt <= 8) {\n-      \/\/ No need to concatenate.\n-      umov(dst, vtmp1, B, 0);\n-    } else if (lane_cnt <= 16) {\n-      ins(vtmp1, B, vtmp1, 1, 8);\n-      umov(dst, vtmp1, H, 0);\n-    } else {\n-      \/\/ As the lane count is 64 at most, the final expected value must be in\n-      \/\/ the lowest 64 bits after narrowing vtmp1 from D to B.\n-      sve_vector_narrow(vtmp1, B, vtmp1, D, vtmp2);\n-      umov(dst, vtmp1, D, 0);\n-    }\n-  } else if (UseSVE > 0) {\n-    \/\/ Compress the lowest 8 bytes.\n-    fmovd(dst, vtmp1);\n-    bytemask_compress(dst);\n-    if (lane_cnt <= 8) return;\n-\n-    \/\/ Repeat on higher bytes and join the results.\n-    \/\/ Compress 8 bytes in each iteration.\n-    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n-      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n-      bytemask_compress(rscratch1);\n-      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n-    }\n+  \/\/ The second source input of BEXT, initialized with 0x01 in each byte.\n+  \/\/ vtmp2 = 0x01010101 0x01010101 0x01010101 0x01010101\n+  sve_dup(vtmp2, B, 1);\n+\n+  \/\/ BEXT vtmp1.D, src.D, vtmp2.D\n+  \/\/ src   = 0x0001010000010001 | 0x0100000001010001\n+  \/\/ vtmp2 = 0x0101010101010101 | 0x0101010101010101\n+  \/\/         ---------------------------------------\n+  \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n+  sve_bext(vtmp1, D, src, vtmp2);\n+\n+  \/\/ Concatenate the lowest significant 8 bits in each 8 bytes, and extract the\n+  \/\/ result to dst.\n+  \/\/ vtmp1 = 0x0000000000000000 | 0x000000000000658D\n+  \/\/ dst   = 0x658D\n+  if (lane_cnt <= 8) {\n+    \/\/ No need to concatenate.\n+    umov(dst, vtmp1, B, 0);\n+  } else if (lane_cnt <= 16) {\n+    ins(vtmp1, B, vtmp1, 1, 8);\n+    umov(dst, vtmp1, H, 0);\n@@ -1470,2 +1469,4 @@\n-    assert(false, \"unsupported\");\n-    ShouldNotReachHere();\n+    \/\/ As the lane count is 64 at most, the final expected value must be in\n+    \/\/ the lowest 64 bits after narrowing vtmp1 from D to B.\n+    sve_vector_narrow(vtmp1, B, vtmp1, D, vtmp2);\n+    umov(dst, vtmp1, D, 0);\n@@ -1475,8 +1476,4 @@\n-\/\/ Unpack the mask, a long value in src, into predicate register dst based on the\n-\/\/ corresponding data type. Note that dst can support at most 64 lanes.\n-\/\/ Below example gives the expected dst predicate register in different types, with\n-\/\/ a valid src(0x658D) on a 1024-bit vector size machine.\n-\/\/ BYTE:  dst = 0x00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 8D\n-\/\/ SHORT: dst = 0x00 00 00 00 00 00 00 00 00 00 00 00 14 11 40 51\n-\/\/ INT:   dst = 0x00 00 00 00 00 00 00 00 01 10 01 01 10 00 11 01\n-\/\/ LONG:  dst = 0x00 01 01 00 00 01 00 01 01 00 00 00 01 01 00 01\n+\/\/ Unpack the mask, a long value in \"src\", into a vector register of boolean\n+\/\/ represented as bytes with 0x00\/0x01 as element values in \"dst\".  Each bit in\n+\/\/ \"src\" is unpacked into one byte lane in \"dst\". Note that \"dst\" can support at\n+\/\/ most 64 lanes.\n@@ -1484,5 +1481,6 @@\n-\/\/ The number of significant bits of src must be equal to lane_cnt. E.g., 0xFF658D which\n-\/\/ has 24 significant bits would be an invalid input if dst predicate register refers to\n-\/\/ a LONG type 1024-bit vector, which has at most 16 lanes.\n-void C2_MacroAssembler::sve_vmask_fromlong(PRegister dst, Register src, BasicType bt, int lane_cnt,\n-                                           FloatRegister vtmp1, FloatRegister vtmp2) {\n+\/\/ Below example gives the expected dst vector register, with a valid src(0x658D)\n+\/\/ on a 128-bit vector size machine.\n+\/\/ dst = 0x00 01 01 00 00 01 00 01 01 00 00 00 01 01 00 01\n+void C2_MacroAssembler::sve_vmask_fromlong(FloatRegister dst, Register src,\n+                                           FloatRegister vtmp, int lane_cnt) {\n+  assert_different_registers(dst, vtmp);\n@@ -1491,3 +1489,3 @@\n-  Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n-  \/\/ Example:   src = 0x658D, bt = T_BYTE, size = B, lane_cnt = 16\n-  \/\/ Expected:  dst = 0b01101001 10001101\n+\n+  \/\/ Example:   src = 0x658D, lane_cnt = 16\n+  \/\/ Expected:  dst = 0x00 01 01 00 00 01 00 01 01 00 00 00 01 01 00 01\n@@ -1496,3 +1494,3 @@\n-  \/\/ vtmp1 = 0x0000000000000000 | 0x000000000000658D\n-  sve_dup(vtmp1, B, 0);\n-  mov(vtmp1, D, 0, src);\n+  \/\/ vtmp = 0x0000000000000000 | 0x000000000000658D\n+  sve_dup(vtmp, B, 0);\n+  mov(vtmp, D, 0, src);\n@@ -1500,3 +1498,2 @@\n-  \/\/ As sve_cmp generates mask value with the minimum unit in byte, we should\n-  \/\/ transform the value in the first lane which is mask in bit now to the\n-  \/\/ mask in byte, which can be done by SVE2's BDEP instruction.\n+  \/\/ Transform the value in the first lane which is mask in bit now to the mask in\n+  \/\/ byte, which can be done by SVE2's BDEP instruction.\n@@ -1505,1 +1502,1 @@\n-  \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n+  \/\/ vtmp = 0x0000000000000065 | 0x000000000000008D\n@@ -1509,2 +1506,1 @@\n-    ins(vtmp1, B, vtmp1, 8, 1);\n-    mov(vtmp1, B, 1, zr);\n+    ins(vtmp, B, vtmp, 8, 1);\n@@ -1512,1 +1508,1 @@\n-    sve_vector_extend(vtmp1, D, vtmp1, B);\n+    sve_vector_extend(vtmp, D, vtmp, B);\n@@ -1516,17 +1512,9 @@\n-  \/\/ vtmp2 = 0x01010101 0x01010101 0x01010101 0x01010101\n-  sve_dup(vtmp2, B, 1);\n-\n-  \/\/ BDEP vtmp1.D, vtmp1.D, vtmp2.D\n-  \/\/ vtmp1 = 0x0000000000000065 | 0x000000000000008D\n-  \/\/ vtmp2 = 0x0101010101010101 | 0x0101010101010101\n-  \/\/         ---------------------------------------\n-  \/\/ vtmp1 = 0x0001010000010001 | 0x0100000001010001\n-  sve_bdep(vtmp1, D, vtmp1, vtmp2);\n-\n-  if (bt != T_BYTE) {\n-    sve_vector_extend(vtmp1, size, vtmp1, B);\n-  }\n-  \/\/ Generate mask according to the given vector, in which the elements have been\n-  \/\/ extended to expected type.\n-  \/\/ dst = 0b01101001 10001101\n-  sve_cmp(Assembler::NE, dst, size, ptrue, vtmp1, 0);\n+  \/\/ dst = 0x01010101 0x01010101 0x01010101 0x01010101\n+  sve_dup(dst, B, 1);\n+\n+  \/\/ BDEP dst.D, vtmp.D, dst.D\n+  \/\/ vtmp = 0x0000000000000065 | 0x000000000000008D\n+  \/\/ dst  = 0x0101010101010101 | 0x0101010101010101\n+  \/\/        ---------------------------------------\n+  \/\/ dst  = 0x0001010000010001 | 0x0100000001010001\n+  sve_bdep(dst, D, vtmp, dst);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":95,"deletions":107,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -88,9 +88,13 @@\n-  \/\/ Pack the lowest-numbered bit of each mask element in src into a long value\n-  \/\/ in dst, at most the first 64 lane elements.\n-  void sve_vmask_tolong(Register dst, PRegister src, BasicType bt, int lane_cnt,\n-                        FloatRegister vtmp1, FloatRegister vtmp2);\n-\n-  \/\/ Unpack the mask, a long value in src, into predicate register dst based on the\n-  \/\/ corresponding data type. Note that dst can support at most 64 lanes.\n-  void sve_vmask_fromlong(PRegister dst, Register src, BasicType bt, int lane_cnt,\n-                          FloatRegister vtmp1, FloatRegister vtmp2);\n+  \/\/ Pack the value of each mask element in \"src\" into a long value in \"dst\", at most the\n+  \/\/ first 64 lane elements. The input \"src\" is a vector of boolean represented as bytes\n+  \/\/ with 0x00\/0x01 as element values. Each lane value from \"src\" is packed into one bit in\n+  \/\/ \"dst\".\n+  void sve_vmask_tolong(Register dst, FloatRegister src, FloatRegister vtmp, int lane_cnt);\n+\n+  void sve2_vmask_tolong(Register dst, FloatRegister src, FloatRegister vtmp1,\n+                         FloatRegister vtmp2, int lane_cnt);\n+\n+  \/\/ Unpack the mask, a long value in \"src\", into vector register \"dst\" with boolean type.\n+  \/\/ Each bit in \"src\" is unpacked into one byte lane in \"dst\". Note that \"dst\" can support\n+  \/\/ at most 64 lanes.\n+  void sve_vmask_fromlong(FloatRegister dst, Register src, FloatRegister vtmp, int lane_cnt);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2295,0 +2295,4 @@\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,0 +167,4 @@\n+\n+  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+    return vt->isa_vectmask() == nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1812,0 +1812,4 @@\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2106,0 +2106,4 @@\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -336,0 +336,4 @@\n+  \/\/ Return true if the input\/output mask of the operation must be a packed\n+  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n+  static bool mask_op_uses_packed_vector(int opcode, const TypeVect* vt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-  if (mask_vec->bottom_type()->isa_vectmask() == nullptr) {\n+  if (Matcher::mask_op_uses_packed_vector(mopc, mask_vec->bottom_type()->is_vect())) {\n@@ -711,1 +711,1 @@\n-    if (vt->isa_vectmask()) {\n+    if (!Matcher::mask_op_uses_packed_vector(opc, vt)) {\n@@ -2548,1 +2548,1 @@\n-      if (opd->bottom_type()->isa_vectmask() == nullptr) {\n+      if (Matcher::mask_op_uses_packed_vector(Op_VectorMaskToLong, opd->bottom_type()->is_vect())) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1406,1 +1406,1 @@\n-Node* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, bool is_mask, const TypeVect* vt) {\n+static Node* convertFromLongToMaskAll(PhaseGVN* phase, const TypeLong* bits_type, const TypeVect* vt) {\n@@ -1421,1 +1421,1 @@\n-    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, is_mask);\n+    Node* res = VectorNode::scalar2vector(con, vlen, maskall_bt, vt->isa_vectmask() != nullptr);\n@@ -1435,1 +1435,1 @@\n-    Node* res = convertFromLongToMaskAll(phase, in(1)->in(1)->bottom_type()->isa_long(), false, vt);\n+    Node* res = convertFromLongToMaskAll(phase, in(1)->in(1)->bottom_type()->isa_long(), vt);\n@@ -1903,1 +1903,2 @@\n-  \/\/ VectorMaskToLong follows a VectorStoreMask if predicate is not supported.\n+  \/\/ VectorMaskToLong follows a VectorStoreMask if it doesn't require the mask\n+  \/\/ saved with a predicate type.\n@@ -1905,2 +1906,3 @@\n-    assert(!in1->in(1)->bottom_type()->isa_vectmask(), \"sanity\");\n-    in1 = in1->in(1);\n+    Node* mask = in1->in(1);\n+    assert(Matcher::mask_op_uses_packed_vector(Opcode(), mask->bottom_type()->is_vect()), \"sanity\");\n+    in1 = mask;\n@@ -1963,1 +1965,1 @@\n-    Node* res = convertFromLongToMaskAll(phase, bits_type, true, dst_type);\n+    Node* res = convertFromLongToMaskAll(phase, bits_type, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2058,0 +2058,10 @@\n+    public static final String VECTOR_LOAD_MASK = PREFIX + \"VECTOR_LOAD_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_LOAD_MASK, \"VectorLoadMask\");\n+    }\n+\n+    public static final String VECTOR_STORE_MASK = PREFIX + \"VECTOR_STORE_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_STORE_MASK, \"VectorStoreMask\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+        \"svebitperm\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,8 +25,8 @@\n-* @test\n-* @bug 8356760 8367391\n-* @library \/test\/lib \/\n-* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n-* @modules jdk.incubator.vector\n-*\n-* @run driver compiler.vectorapi.VectorMaskFromLongTest\n-*\/\n+ * @test\n+ * @bug 8356760 8367391 8367292\n+ * @library \/test\/lib \/\n+ * @summary IR test for VectorMask.fromLong()\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskFromLongTest\n+ *\/\n@@ -50,5 +50,0 @@\n-    @ForceInline\n-    public static void maskFromLongKernel(VectorSpecies<?> species, long inputLong) {\n-        VectorMask.fromLong(species, inputLong).intoArray(mr, 0);\n-    }\n-\n@@ -66,0 +61,2 @@\n+    \/\/ Tests for \"VectorLongToMask(-1\/0) => MaskAll(-1\/0)\"\n+\n@@ -67,2 +64,2 @@\n-    public static void testMaskFromLong(VectorSpecies<?> species, long inputLong ) {\n-        maskFromLongKernel(species, inputLong);\n+    public static void fromLongMaskAllKernel(VectorSpecies<?> species, long inputLong ) {\n+        VectorMask.fromLong(species, inputLong).intoArray(mr, 0);\n@@ -76,1 +73,1 @@\n-        testMaskFromLong(species, inputLong);\n+        fromLongMaskAllKernel(species, inputLong);\n@@ -79,1 +76,1 @@\n-        testMaskFromLong(species, inputLong);\n+        fromLongMaskAllKernel(species, inputLong);\n@@ -82,1 +79,1 @@\n-        testMaskFromLong(species, inputLong);\n+        fromLongMaskAllKernel(species, inputLong);\n@@ -85,1 +82,1 @@\n-        testMaskFromLong(species, inputLong);\n+        fromLongMaskAllKernel(species, inputLong);\n@@ -172,1 +169,15 @@\n-    \/\/ Tests for general input long values\n+    \/\/ Tests for general input long values. The purpose is to test the IRs\n+    \/\/ for API VectorMask.fromLong(). To avoid any IR being optimized out by\n+    \/\/ compiler, we insert a VectorMask.not() after fromLong().\n+\n+    @ForceInline\n+    public static void fromLongGeneralKernel(VectorSpecies<?> species, long inputLong) {\n+        VectorMask.fromLong(species, inputLong).not().intoArray(mr, 0);\n+        verifyMaskFromLong(species, inputLong ^ -1L);\n+    }\n+\n+    @ForceInline\n+    public static void testMaskFromLongGeneral(VectorSpecies<?> species) {\n+        fromLongGeneralKernel(species, (-1L >>> (64 - species.length())) - 1);\n+        fromLongGeneralKernel(species, (-1L >>> (64 - species.length())) >>> 1);\n+    }\n@@ -175,1 +186,1 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n@@ -177,5 +188,2 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n-    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n-                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n-    @IR(counts = { IRNode.REPLICATE_B, \"= 0\",\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n@@ -184,0 +192,3 @@\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -185,3 +196,1 @@\n-        \/\/ Test cases where some but not all bits are set.\n-        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length())) - 1);\n-        testMaskFromLong(B_SPECIES, (-1L >>> (64 - B_SPECIES.length())) >>> 1);\n+        testMaskFromLongGeneral(B_SPECIES);\n@@ -191,1 +200,1 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n@@ -193,5 +202,2 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n-    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n-                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n-    @IR(counts = { IRNode.REPLICATE_S, \"= 0\",\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n@@ -200,0 +206,3 @@\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -201,3 +210,1 @@\n-        \/\/ Test cases where some but not all bits are set.\n-        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length())) - 1);\n-        testMaskFromLong(S_SPECIES, (-1L >>> (64 - S_SPECIES.length())) >>> 1);\n+        testMaskFromLongGeneral(S_SPECIES);\n@@ -207,1 +214,1 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n@@ -209,5 +216,2 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n-    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n-                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n-    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n@@ -216,0 +220,3 @@\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -217,3 +224,1 @@\n-        \/\/ Test cases where some but not all bits are set.\n-        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length())) - 1);\n-        testMaskFromLong(I_SPECIES, (-1L >>> (64 - I_SPECIES.length())) >>> 1);\n+        testMaskFromLongGeneral(I_SPECIES);\n@@ -223,1 +228,1 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n@@ -225,5 +230,2 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n-    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n-                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n-    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n@@ -232,0 +234,3 @@\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -233,3 +238,1 @@\n-        \/\/ Test cases where some but not all bits are set.\n-        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length())) - 1);\n-        testMaskFromLong(L_SPECIES, (-1L >>> (64 - L_SPECIES.length())) >>> 1);\n+        testMaskFromLongGeneral(L_SPECIES);\n@@ -239,1 +242,1 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n@@ -241,5 +244,2 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n-    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n-                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n-    @IR(counts = { IRNode.REPLICATE_I, \"= 0\",\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n@@ -248,0 +248,3 @@\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -249,3 +252,1 @@\n-        \/\/ Test cases where some but not all bits are set.\n-        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length())) - 1);\n-        testMaskFromLong(F_SPECIES, (-1L >>> (64 - F_SPECIES.length())) >>> 1);\n+        testMaskFromLongGeneral(F_SPECIES);\n@@ -255,1 +256,1 @@\n-    @IR(counts = { IRNode.MASK_ALL, \"= 0\",\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 0\",\n@@ -257,5 +258,2 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\" })\n-    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n-                   IRNode.VECTOR_LONG_TO_MASK, \"= 0\" },\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n-    @IR(counts = { IRNode.REPLICATE_L, \"= 0\",\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n@@ -264,0 +262,3 @@\n+    @IR(counts = { IRNode.VECTOR_LOAD_MASK, \"= 2\",\n+                   IRNode.VECTOR_LONG_TO_MASK, \"= 2\" },\n+        applyIfCPUFeature = { \"svebitperm\", \"true\" })\n@@ -265,3 +266,1 @@\n-        \/\/ Test cases where some but not all bits are set.\n-        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length())) - 1);\n-        testMaskFromLong(D_SPECIES, (-1L >>> (64 - D_SPECIES.length())) >>> 1);\n+        testMaskFromLongGeneral(D_SPECIES);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskFromLongTest.java","additions":73,"deletions":74,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -25,8 +25,8 @@\n-* @test\n-* @bug 8356760\n-* @library \/test\/lib \/\n-* @summary Optimize VectorMask.fromLong for all-true\/all-false cases\n-* @modules jdk.incubator.vector\n-*\n-* @run driver compiler.vectorapi.VectorMaskToLongTest\n-*\/\n+ * @test\n+ * @bug 8356760 8367292\n+ * @library \/test\/lib \/\n+ * @summary IR test for VectorMask.toLong()\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskToLongTest\n+ *\/\n@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -48,0 +49,7 @@\n+    private static boolean[] m;\n+\n+    static {\n+        m = new boolean[B_SPECIES.length()];\n+        Arrays.fill(m, true);\n+    }\n+\n@@ -54,0 +62,2 @@\n+    \/\/ Tests for \"VectorMaskToLong(MaskAll(0\/-1)) => ((0\/-1) & (-1ULL >> (64 - vlen)))\"\n+\n@@ -176,1 +186,1 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n@@ -179,1 +189,1 @@\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"svebitperm\", \"false\" })\n@@ -181,1 +191,1 @@\n-        \/\/ Test the case where some but not all bits are set.\n+       \/\/ Test the case where some but not all bits are set.\n@@ -190,1 +200,1 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n@@ -193,1 +203,1 @@\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"svebitperm\", \"false\" })\n@@ -204,1 +214,1 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n@@ -207,1 +217,1 @@\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"svebitperm\", \"false\" })\n@@ -218,1 +228,1 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n@@ -221,1 +231,1 @@\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"svebitperm\", \"false\" })\n@@ -232,1 +242,1 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n@@ -235,1 +245,1 @@\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"svebitperm\", \"false\" })\n@@ -246,1 +256,1 @@\n-        applyIfCPUFeatureOr = { \"sve2\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+        applyIfCPUFeatureOr = { \"svebitperm\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n@@ -249,1 +259,1 @@\n-        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"svebitperm\", \"false\" })\n@@ -257,0 +267,94 @@\n+    \/\/ General cases for VectorMask.toLong(). The main purpose is to test the IRs\n+    \/\/ for API VectorMask.toLong(). To avoid the IRs being optimized out by compiler,\n+    \/\/ we insert a VectorMask.not() before toLong().\n+\n+    @ForceInline\n+    public static void testToLongGeneral(VectorSpecies<?> species) {\n+        long got = VectorMask.fromArray(species, m, 0).not().toLong();\n+        verifyMaskToLong(species, 0, got);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeature = { \"asimd\", \"true\" })\n+    public static void testToLongByte() {\n+        testToLongGeneral(B_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeature = { \"asimd\", \"true\" })\n+    public static void testToLongShort() {\n+        testToLongGeneral(S_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeature = { \"asimd\", \"true\" })\n+    public static void testToLongInt() {\n+        testToLongGeneral(I_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeature = { \"asimd\", \"true\" })\n+    public static void testToLongLong() {\n+        testToLongGeneral(L_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeature = { \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    public static void testToLongFloat() {\n+        testToLongGeneral(F_SPECIES);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 0\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\", \"rvv\", \"true\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\", \"avx512\", \"false\" })\n+    @IR(counts = { IRNode.VECTOR_STORE_MASK, \"= 1\",\n+                   IRNode.VECTOR_MASK_TO_LONG, \"= 1\" },\n+        applyIfCPUFeature = { \"asimd\", \"true\" })\n+    public static void testToLongDouble() {\n+        testToLongGeneral(D_SPECIES);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskToLongTest.java","additions":125,"deletions":21,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6928,3 +6928,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6928,3 +6928,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6928,3 +6928,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6928,3 +6928,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5323,3 +5323,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5323,3 +5323,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5323,3 +5323,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5323,3 +5323,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5302,3 +5302,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5302,3 +5302,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5302,3 +5302,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -5302,3 +5302,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6961,3 +6961,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6961,3 +6961,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6961,3 +6961,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6961,3 +6961,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6847,3 +6847,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6847,3 +6847,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6847,3 +6847,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6847,3 +6847,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6908,3 +6908,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6908,3 +6908,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6908,3 +6908,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -6908,3 +6908,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -611,3 +611,6 @@\n-        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n-        long outputLong = vmask.toLong();\n-        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+            \/\/ Insert \"not()\" to avoid the \"fromLong\/toLong\" being optimized out by compiler.\n+            long outputLong = vmask.not().toLong();\n+            Assert.assertEquals(outputLong, ((inputLong ^ -1L) & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}