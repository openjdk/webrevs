{"files":[{"patch":"@@ -390,5 +390,6 @@\n-  bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-    if (vt->isa_vectmask() == nullptr) {\n-      return false;\n-    }\n-\n+  \/\/ Return true if the input\/output mask of the operation must be a packed\n+  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n+  \/\/\n+  \/\/ By default, all the mask query operations without predicate support\n+  \/\/ requires the mask to be saved in a boolean vector.\n+  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n@@ -396,1 +397,6 @@\n-      case Op_VectorLongToMask:\n+      case Op_VectorMaskFirstTrue:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskTrueCount:\n+        \/\/ These ops are implemented with predicate instructions if input\n+        \/\/ mask is a predciate.\n+        return vt->isa_vectmask() == nullptr;\n@@ -398,5 +404,3 @@\n-        \/\/ These ops do not have native predicate instructions on SVE. Instead,\n-        \/\/ they are implemented with vector instructions. Using the packed vector\n-        \/\/ layout for the input\/output mask is more efficient in these cases.\n-        return false;\n-      default:\n+      case Op_VectorLongToMask:\n+        \/\/ These two ops are implemented with vector instructions on all\n+        \/\/ architectures. SVE does not have native predicate instructions.\n@@ -405,0 +409,1 @@\n+    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -380,5 +380,6 @@\n-  bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-    if (vt->isa_vectmask() == nullptr) {\n-      return false;\n-    }\n-\n+  \/\/ Return true if the input\/output mask of the operation must be a packed\n+  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n+  \/\/\n+  \/\/ By default, all the mask query operations without predicate support\n+  \/\/ requires the mask to be saved in a boolean vector.\n+  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n@@ -386,1 +387,6 @@\n-      case Op_VectorLongToMask:\n+      case Op_VectorMaskFirstTrue:\n+      case Op_VectorMaskLastTrue:\n+      case Op_VectorMaskTrueCount:\n+        \/\/ These ops are implemented with predicate instructions if input\n+        \/\/ mask is a predciate.\n+        return vt->isa_vectmask() == nullptr;\n@@ -388,5 +394,3 @@\n-        \/\/ These ops do not have native predicate instructions on SVE. Instead,\n-        \/\/ they are implemented with vector instructions. Using the packed vector\n-        \/\/ layout for the input\/output mask is more efficient in these cases.\n-        return false;\n-      default:\n+      case Op_VectorLongToMask:\n+        \/\/ These two ops are implemented with vector instructions on all\n+        \/\/ architectures. SVE does not have native predicate instructions.\n@@ -395,0 +399,1 @@\n+    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1432,1 +1432,1 @@\n-\/\/ The function is same as above \"sve_vmask_tolong\", but it uses SVE2's BDEP\n+\/\/ The function is same as above \"sve_vmask_tolong\", but it uses SVE2's BEXT\n@@ -1507,1 +1507,0 @@\n-    mov(vtmp, B, 1, zr);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1006,2 +1006,2 @@\n-bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-  return false;\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2295,2 +2295,2 @@\n-bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-  return false;\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,2 +168,2 @@\n-  bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-    return vt->isa_vectmask() != nullptr;\n+  bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+    return vt->isa_vectmask() == nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1812,2 +1812,2 @@\n-bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-  return false;\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2106,2 +2106,2 @@\n-bool Matcher::vector_mask_requires_predicate(int opcode, const TypeVect* vt) {\n-  return vt->isa_vectmask() != nullptr;\n+bool Matcher::mask_op_uses_packed_vector(int opcode, const TypeVect* vt) {\n+  return vt->isa_vectmask() == nullptr;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -336,4 +336,3 @@\n-  \/\/ Identify if a vector mask operation requires the input mask to be saved\n-  \/\/ with a predicate type (i.e. TypeVectMask) or a vector type. Return true\n-  \/\/ if it requires a predicate type.\n-  static bool vector_mask_requires_predicate(int opcode, const TypeVect* vt);\n+  \/\/ Return true if the input\/output mask of the operation must be a packed\n+  \/\/ boolean vector represented as bytes with 0x00\/0x01 as element values.\n+  static bool mask_op_uses_packed_vector(int opcode, const TypeVect* vt);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-  if (!Matcher::vector_mask_requires_predicate(mopc, mask_vec->bottom_type()->is_vect())) {\n+  if (Matcher::mask_op_uses_packed_vector(mopc, mask_vec->bottom_type()->is_vect())) {\n@@ -711,1 +711,1 @@\n-    if (Matcher::vector_mask_requires_predicate(opc, vt)) {\n+    if (!Matcher::mask_op_uses_packed_vector(opc, vt)) {\n@@ -2548,1 +2548,1 @@\n-      if (!Matcher::vector_mask_requires_predicate(Op_VectorMaskToLong, opd->bottom_type()->is_vect())) {\n+      if (Matcher::mask_op_uses_packed_vector(Op_VectorMaskToLong, opd->bottom_type()->is_vect())) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1906,3 +1906,3 @@\n-    assert(!Matcher::vector_mask_requires_predicate(Opcode(),\n-              in1->in(1)->bottom_type()->is_vect()), \"sanity\");\n-    in1 = in1->in(1);\n+    Node* mask = in1->in(1);\n+    assert(Matcher::mask_op_uses_packed_vector(Opcode(), mask->bottom_type()->is_vect()), \"sanity\");\n+    in1 = mask;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}