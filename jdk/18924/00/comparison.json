{"files":[{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.KDFSpi;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/**\n+ * KeyDerivation implementation for the HKDF function.\n+ * <p>\n+ * This class implements the HKDF-Extract and HKDF-Expand functions from RFC 5869.  This\n+ * implementation provides the complete Extract-then-Expand HKDF function as well as Extract-only\n+ * and Expand-only variants.\n+ *\/\n+abstract class HkdfKeyDerivation extends KDFSpi {\n+\n+    protected Mac hmacObj;\n+    protected int hmacLen;\n+    protected String hmacAlgName;\n+    protected List<SecretKey> ikms;\n+    protected List<SecretKey> salts;\n+    protected SecretKey initialKeyMaterial;\n+    protected SecretKey salt;\n+    protected SecretKey pseudoRandomKey;\n+    protected byte[] info;\n+    protected int length;\n+\n+    protected enum HKDFTYPES {\n+        EXTRACT, EXPAND, EXTRACTEXPAND\n+    }\n+\n+    protected HKDFTYPES HKDFTYPE;\n+\n+    \/**\n+     * The sole constructor.\n+     *\n+     * @param algParameterSpec\n+     *     the initialization parameters (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this {@code KDFSpi}\n+     *\/\n+    protected HkdfKeyDerivation(AlgorithmParameterSpec algParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+        super(algParameterSpec);\n+    }\n+\n+    \/**\n+     * TODO: description\n+     *\n+     * @return a derived {@code SecretKey} object of the specified algorithm\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the current {@code KDFParameterSpec} is invalid or\n+     *     incorrect for the type of key to be derived\n+     * @throws IllegalStateException\n+     *     if the key derivation implementation cannot support additional calls to\n+     *     {@code deriveKey}\n+     *\/\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg, KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+\n+        \/\/ inspect KDFParameterSpec object\n+        inspectKDFParameterSpec(kdfParameterSpec);\n+\n+        try {\n+            \/\/ set up the HMAC instance\n+            hmacLen = setupHMAC(hmacAlgName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new ProviderException(nsae);\n+        }\n+\n+        if (HKDFTYPE == HKDFTYPES.EXTRACT) {\n+            \/\/ perform extract\n+            try {\n+                byte[] extractResult = hkdfExtract(initialKeyMaterial,\n+                                                   (salt == null) ? null : salt.getEncoded());\n+                return new SecretKeySpec(extractResult, alg);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Extract could not be initialized with the given key or salt material\");\n+            }\n+\n+        } else if (HKDFTYPE == HKDFTYPES.EXPAND) {\n+            \/\/ perform expand\n+            try {\n+                byte[] expandResult = hkdfExpand(this.pseudoRandomKey, this.info, this.length);\n+                return new SecretKeySpec(expandResult, 0, this.length, alg);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Expand could not be initialized with the given key material\");\n+            }\n+\n+        } else if (HKDFTYPE == HKDFTYPES.EXTRACTEXPAND) {\n+            \/\/ perform extract and then expand\n+            try {\n+                byte[] extractResult = hkdfExtract(initialKeyMaterial,\n+                                                   (salt == null) ? null : salt.getEncoded());\n+                this.pseudoRandomKey = new SecretKeySpec(extractResult, alg);\n+                byte[] expandResult = hkdfExpand(this.pseudoRandomKey, this.info, this.length);\n+                return new SecretKeySpec(expandResult, 0, this.length, alg);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF ExtractExpand could not be initialized with the given key or salt \"\n+                    + \"material\");\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * TODO: description\n+     *\n+     * @return a derived {@code byte[]}\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the current {@code KDFParameterSpec} is invalid or\n+     *     incorrect\n+     * @throws IllegalStateException\n+     *     if the key derivation implementation cannot support additional calls to\n+     *     {@code deriveData}\n+     *\/\n+    @Override\n+    protected byte[] engineDeriveData(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+\n+        \/\/ inspect KDFParameterSpec object\n+        inspectKDFParameterSpec(kdfParameterSpec);\n+\n+        try {\n+            \/\/ set up the HMAC instance\n+            hmacLen = setupHMAC(hmacAlgName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new ProviderException(nsae);\n+        }\n+\n+        if (HKDFTYPE == HKDFTYPES.EXTRACT) {\n+            \/\/ perform extract\n+            try {\n+                return hkdfExtract(initialKeyMaterial, (salt == null) ? null : salt.getEncoded());\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Extract could not be initialized with the given key or salt material\");\n+            }\n+\n+        } else if (HKDFTYPE == HKDFTYPES.EXPAND) {\n+            \/\/ perform expand\n+            try {\n+                return Arrays.copyOf(hkdfExpand(this.pseudoRandomKey, this.info, this.length),\n+                                     this.length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Expand could not be initialized with the given key material\");\n+            }\n+\n+        } else if (HKDFTYPE == HKDFTYPES.EXTRACTEXPAND) {\n+            \/\/ perform extract and then expand\n+            try {\n+                byte[] extractResult = hkdfExtract(initialKeyMaterial,\n+                                                   (salt == null) ? null : salt.getEncoded());\n+                this.pseudoRandomKey = new SecretKeySpec(extractResult, \"RAW\");\n+                return Arrays.copyOf(hkdfExpand(this.pseudoRandomKey, this.info, this.length),\n+                                     this.length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF ExtractExpand could not be initialized with the given key or salt \"\n+                    + \"material\");\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    protected int setupHMAC(String hmacAlgName) throws NoSuchAlgorithmException {\n+        hmacObj = Mac.getInstance(hmacAlgName);\n+        return hmacObj.getMacLength();\n+    }\n+\n+    protected void inspectKDFParameterSpec(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+        \/\/ A switch would be nicer, but we may need to backport this before JDK 17\n+        \/\/ Also, JEP 305 came out in JDK 14, so we can't declare a variable in instanceof either\n+        if (kdfParameterSpec instanceof HKDFParameterSpec.Extract) {\n+            HKDFParameterSpec.Extract anExtract = (HKDFParameterSpec.Extract) kdfParameterSpec;\n+            this.ikms = anExtract.ikms();\n+            this.salts = anExtract.salts();\n+            if (isNullOrEmpty(ikms) && isNullOrEmpty(salts)) {\n+                throw new InvalidParameterSpecException(\n+                    \"IKM and salt cannot both be null or empty for HKDFParameterSpec.Extract\");\n+            }\n+            \/\/ we should be able to combine these Lists of keys into single SecretKey Objects,\n+            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            try {\n+                this.initialKeyMaterial = consolidateKeyMaterial(ikms);\n+                this.salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"Issue encountered when combining ikm or salt values into single keys\");\n+            }\n+            HKDFTYPE = HKDFTYPES.EXTRACT;\n+        } else if (kdfParameterSpec instanceof HKDFParameterSpec.Expand) {\n+            HKDFParameterSpec.Expand anExpand = (HKDFParameterSpec.Expand) kdfParameterSpec;\n+            \/\/ set this value in the \"if\"\n+            if ((pseudoRandomKey = anExpand.prk()) == null) {\n+                throw new InvalidParameterSpecException(\n+                    \"PRK is required for HKDFParameterSpec.Expand\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((length = anExpand.length()) <= 0) {\n+                throw new InvalidParameterSpecException(\"length cannot be <= 0\");\n+            }\n+            HKDFTYPE = HKDFTYPES.EXPAND;\n+        } else if (kdfParameterSpec instanceof HKDFParameterSpec.ExtractExpand) {\n+            HKDFParameterSpec.ExtractExpand anExtractExpand =\n+                (HKDFParameterSpec.ExtractExpand) kdfParameterSpec;\n+            ikms = anExtractExpand.ikms();\n+            salts = anExtractExpand.salts();\n+            if (isNullOrEmpty(ikms) && isNullOrEmpty(salts)) {\n+                throw new InvalidParameterSpecException(\n+                    \"IKM and salt cannot both be null for HKDFParameterSpec.ExtractExpand\");\n+            }\n+            \/\/ we should be able to combine these Lists of keys into single SecretKey Objects,\n+            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            try {\n+                this.initialKeyMaterial = consolidateKeyMaterial(ikms);\n+                this.salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"Issue encountered when combining ikm or salt values into single keys\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExtractExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((length = anExtractExpand.length()) <= 0) {\n+                throw new InvalidParameterSpecException(\"length cannot be <= 0\");\n+            }\n+            HKDFTYPE = HKDFTYPES.EXTRACTEXPAND;\n+        } else {\n+            throw new InvalidParameterSpecException(\n+                \"The KDFParameterSpec object was not of a recognized type\");\n+        }\n+    }\n+\n+    private static boolean isNullOrEmpty(Collection<?> c) {\n+        return c == null || c.isEmpty();\n+    }\n+\n+    private SecretKey consolidateKeyMaterial(List<SecretKey> keys) throws InvalidKeyException {\n+        if (keys != null && !keys.isEmpty()) {\n+            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n+            if (localKeys.size() == 1) {\n+                \/\/ return this element\n+                return localKeys.get(0);\n+            } else {\n+                byte[] bb = new byte[0];\n+                for (SecretKey workItem : localKeys) {\n+                    byte[] workItemBytes = CipherCore.getKeyBytes(workItem);\n+\n+                    bb = Arrays.copyOf(bb, bb.length + workItemBytes.length);\n+                    System.arraycopy(workItemBytes, 0, bb, bb.length - workItemBytes.length,\n+                                     workItemBytes.length);\n+                }\n+                return new SecretKeySpec(bb, \"RAW\");\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HMAC-Extract operation.\n+     *\n+     * @param inputKey\n+     *     the input keying material used for the HKDF-Extract operation.\n+     * @param salt\n+     *     the salt value used for HKDF-Extract.  If no salt is to be used a {@code null} value\n+     *     should be provided.\n+     *\n+     * @return a byte array containing the pseudorandom key (PRK)\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid salt was provided through the {@code HkdfParameterSpec}\n+     *\/\n+    protected byte[] hkdfExtract(SecretKey inputKey, byte[] salt) throws InvalidKeyException {\n+\n+        if (salt == null) {\n+            salt = new byte[hmacLen];\n+        }\n+        hmacObj.init(new SecretKeySpec(salt, \"HKDF-Salt\"));\n+\n+        return hmacObj.doFinal(inputKey.getEncoded());\n+    }\n+\n+    \/**\n+     * Perform the HMAC-Expand operation.  At the end of the operation, the keyStream instance\n+     * variable will contain the complete KDF output based on the input values and desired length.\n+     *\n+     * @param prk\n+     *     the pseudorandom key used for HKDF-Expand\n+     * @param info\n+     *     optional context and application specific information or {@code null} if no info data is\n+     *     provided.\n+     * @param outLen\n+     *     the length in bytes of the required output\n+     *\n+     * @return a byte array containing the complete KDF output.  This will be at least as long as\n+     * the requested length in the {@code outLen} parameter, but will be rounded up to the nearest\n+     * multiple of the HMAC output length.\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid key was provided through the {@code HkdfParameterSpec} or derived during\n+     *     the generation of the PRK.\n+     *\/\n+    protected byte[] hkdfExpand(SecretKey prk, byte[] info, int outLen) throws InvalidKeyException {\n+        byte[] kdfOutput;\n+\n+        \/\/ Calculate the number of rounds of HMAC that are needed to\n+        \/\/ meet the requested data.  Then set up the buffers we will need.\n+        hmacObj.init(prk);\n+        if (info == null) {\n+            info = new byte[0];\n+        }\n+        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n+        kdfOutput = new byte[rounds * hmacLen];\n+        int offset = 0;\n+        int tLength = 0;\n+\n+        for (int i = 0; i < rounds; i++) {\n+\n+            \/\/ Calculate this round\n+            try {\n+                \/\/ Add T(i).  This will be an empty string on the first\n+                \/\/ iteration since tLength starts at zero.  After the first\n+                \/\/ iteration, tLength is changed to the HMAC length for the\n+                \/\/ rest of the loop.\n+                hmacObj.update(kdfOutput, Math.max(0, offset - hmacLen), tLength);\n+                hmacObj.update(info);                       \/\/ Add info\n+                hmacObj.update((byte) (i + 1));              \/\/ Add round number\n+                hmacObj.doFinal(kdfOutput, offset);\n+\n+                tLength = hmacLen;\n+                offset += hmacLen;                       \/\/ For next iteration\n+            } catch (ShortBufferException sbe) {\n+                \/\/ This really shouldn't happen given that we've\n+                \/\/ sized the buffers to their largest possible size up-front,\n+                \/\/ but just in case...\n+                throw new RuntimeException(sbe);\n+            }\n+        }\n+\n+        return kdfOutput;\n+    }\n+\n+    public static final class HkdfSHA256 extends HkdfKeyDerivation {\n+        public HkdfSHA256(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA256\";\n+        }\n+    }\n+\n+    public static final class HkdfSHA384 extends HkdfKeyDerivation {\n+        public HkdfSHA384(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA384\";\n+        }\n+    }\n+\n+    public static final class HkdfSHA512 extends HkdfKeyDerivation {\n+        public HkdfSHA512(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA512\";\n+        }\n+    }\n+\n+    public static final class HkdfExtractSHA256 extends HkdfKeyDerivation {\n+        public HkdfExtractSHA256(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA256\";\n+        }\n+    }\n+\n+    public static final class HkdfExtractSHA384 extends HkdfKeyDerivation {\n+        public HkdfExtractSHA384(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA384\";\n+        }\n+    }\n+\n+    public static final class HkdfExtractSHA512 extends HkdfKeyDerivation {\n+        public HkdfExtractSHA512(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA512\";\n+        }\n+    }\n+\n+    public static final class HkdfExpandSHA256 extends HkdfKeyDerivation {\n+        public HkdfExpandSHA256(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA256\";\n+        }\n+    }\n+\n+    public static final class HkdfExpandSHA384 extends HkdfKeyDerivation {\n+        public HkdfExpandSHA384(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA384\";\n+        }\n+    }\n+\n+    public static final class HkdfExpandSHA512 extends HkdfKeyDerivation {\n+        public HkdfExpandSHA512(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA512\";\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"},{"patch":"@@ -460,0 +460,24 @@\n+        \/*\n+         * Key Derivation engines\n+         *\/\n+        ps(\"KDF\", \"HKDF\/HmacSHA256\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA256\");\n+        ps(\"KDF\", \"HKDF\/HmacSHA384\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA384\");\n+        ps(\"KDF\", \"HKDF\/HmacSHA512\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA512\");\n+\n+        ps(\"KDF\", \"HKDF-Extract\/HmacSHA256\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfExtractSHA256\");\n+        ps(\"KDF\", \"HKDF-Extract\/HmacSHA384\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfExtractSHA384\");\n+        ps(\"KDF\", \"HKDF-Extract\/HmacSHA512\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfExtractSHA512\");\n+\n+        ps(\"KDF\", \"HKDF-Expand\/HmacSHA256\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfExpandSHA256\");\n+        ps(\"KDF\", \"HKDF-Expand\/HmacSHA384\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfExpandSHA384\");\n+        ps(\"KDF\", \"HKDF-Expand\/HmacSHA512\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfExpandSHA512\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1607,0 +1607,2 @@\n+        addEngine(\"KDF\",                                true,\n+                            java.security.spec.AlgorithmParameterSpec.class);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.Provider.Service;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+import sun.security.util.Debug;\n+import sun.security.jca.*;\n+import sun.security.jca.GetInstance.Instance;\n+\n+import javax.crypto.spec.KDFParameterSpec;\n+\n+\/**\n+ * This class provides the functionality of a key derivation algorithm for the Java Cryptographic\n+ * Extension (JCE) framework.\n+ * <p>\n+ * {@code KeyDerivation} objects will be instantiated through the {@code getInstance} family of\n+ * methods.  Key derivation algorithm names will follow a naming convention of\n+ * <I>algorithm<\/I>\/<I>PRF<\/I>.  The algorithm field will be the KDF name\n+ * (e.g. HKDF, TLS-PRF, PBKDF2, etc.), while the PRF specifier identifies the underlying\n+ * pseudorandom function (e.g. HmacSHA256).  For instance, a KDF implementation of HKDF using\n+ * HMAC-SHA256 will have an algorithm string of \"HKDF\/HmacSHA256\".  In some cases the PRF portion of\n+ * the algorithm specifier may be omitted if the KDF algorithm has a fixed or default PRF.\n+ * <p>\n+ * TODO: finish this javadoc\n+ *\/\n+\n+public final class KDF {\n+    private static final Debug debug = Debug.getInstance(\"jca\", \"KeyDerivation\");\n+\n+    private static final Debug pdebug = Debug.getInstance(\"provider\", \"Provider\");\n+    private static final boolean skipDebug = Debug.isOn(\"engine=\") && !Debug.isOn(\"keyderive\");\n+\n+    \/\/ The provider\n+    private Provider provider;\n+\n+    \/\/ The provider implementation (delegate)\n+    private KDFSpi spi;\n+\n+    \/\/ The name of the MAC algorithm.\n+    private final String algorithm;\n+\n+    \/\/ Additional KDF configuration parameters\n+    private final AlgorithmParameterSpec algorithmParameterSpec;\n+\n+    \/\/ Has this object been initialized?\n+    private boolean initialized = false;\n+\n+    \/\/ next service to try in provider selection\n+    \/\/ null once provider is selected\n+    private Service firstService;\n+\n+    \/\/ remaining services to try in provider selection\n+    \/\/ null once provider is selected\n+    private Iterator<Service> serviceIterator;\n+\n+    private final Object lock;\n+\n+    \/**\n+     * Instantiates a KeyDerivation object.\n+     *\n+     * @param keyDerivSpi\n+     *     the delegate\n+     * @param provider\n+     *     the provider\n+     * @param algorithm\n+     *     the algorithm\n+     * @param algParameterSpec\n+     *     the algorithm parameters\n+     *\/\n+    protected KDF(KDFSpi keyDerivSpi, Provider provider, String algorithm,\n+                  AlgorithmParameterSpec algParameterSpec) {\n+        this.spi = keyDerivSpi;\n+        this.provider = provider;\n+        this.algorithm = algorithm;\n+        this.algorithmParameterSpec = algParameterSpec;\n+        this.lock = null;\n+    }\n+\n+    \/**\n+     * Returns the algorithm name of this {@code KeyDerivation} object.\n+     *\n+     * <p>This is the same name that was specified in one of the\n+     * {@code getInstance} calls that created this {@code KeyDerivation} object.\n+     *\n+     * @return the algorithm name of this {@code KeyDerivation} object.\n+     *\/\n+    public final String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+\n+    \/**\n+     * Returns the provider of this {@code KeyDerivation} object.\n+     *\n+     * @return the provider of this {@code KeyDerivation} object.\n+     *\/\n+    private final Provider getProvider() {\n+        chooseFirstProvider();\n+        return this.provider;\n+    }\n+\n+    private String getProviderName() {\n+        return (provider == null) ? \"(no provider)\" : provider.getName();\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for the specified\n+     *     algorithm.\n+     *\/\n+    public static KDF getInstance(String algorithm) throws NoSuchAlgorithmException {\n+        KDF instance = null;\n+        try {\n+            instance = getInstance(algorithm, (AlgorithmParameterSpec) null);\n+        } catch (InvalidParameterSpecException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidParameterSpecException. Does this algorithm require an \"\n+                + \"AlgorithmParameterSpec?\");\n+        }\n+        return instance;\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object with a specific {@code Provider}.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for the specified\n+     *     algorithm.\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider list.\n+     *\/\n+    public static KDF getInstance(String algorithm, String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException {\n+        KDF instance = null;\n+        try {\n+            instance = getInstance(algorithm, (AlgorithmParameterSpec) null, provider);\n+        } catch (InvalidParameterSpecException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidParameterSpecException. Does this algorithm require an \"\n+                + \"AlgorithmParameterSpec?\");\n+        }\n+        return instance;\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object using a supplied {@code Provider} instance.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param provider\n+     *     the provider\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for the specified\n+     *     algorithm.\n+     *\/\n+    public static KDF getInstance(String algorithm, Provider provider)\n+        throws NoSuchAlgorithmException {\n+        KDF instance = null;\n+        try {\n+            instance = getInstance(algorithm, (AlgorithmParameterSpec) null, provider);\n+        } catch (InvalidParameterSpecException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidParameterSpecException. Does this algorithm require an \"\n+                + \"AlgorithmParameterSpec?\");\n+        }\n+        return instance;\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param algParameterSpec\n+     *     the {@code AlgorithmParameterSpec} used to configure this KDF's algorithm or {@code null}\n+     *     if no additional parameters were provided.\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for the specified\n+     *     algorithm.\n+     * @throws InvalidParameterSpecException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     *\/\n+    public static KDF getInstance(String algorithm, AlgorithmParameterSpec algParameterSpec)\n+        throws NoSuchAlgorithmException, InvalidParameterSpecException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class, algorithm,\n+                                                        algParameterSpec);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \" + instance.provider.getName();\n+                throw new SecurityException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm, algParameterSpec);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new NoSuchAlgorithmException(\"Algorithm \" + algorithm + \" not available\", nsae);\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object with a specific {@code Provider}.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param algParameterSpec\n+     *     the {@code AlgorithmParameterSpec} used to configure this KDF's algorithm or {@code null}\n+     *     if no additional parameters were provided.\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for the specified\n+     *     algorithm.\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider list.\n+     * @throws InvalidParameterSpecException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     *\/\n+    public static KDF getInstance(String algorithm, AlgorithmParameterSpec algParameterSpec,\n+                                  String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidParameterSpecException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class, algorithm,\n+                                                        algParameterSpec, provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \" + instance.provider.getName();\n+                throw new NoSuchProviderException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm, algParameterSpec);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new NoSuchAlgorithmException(\"Algorithm \" + algorithm + \" not available\", nsae);\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object using a supplied {@code Provider} instance.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param algParameterSpec\n+     *     the {@code AlgorithmParameterSpec} used to configure this KDF's algorithm or {@code null}\n+     *     if no additional parameters were provided.\n+     * @param provider\n+     *     the provider\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for the specified\n+     *     algorithm.\n+     * @throws InvalidParameterSpecException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     *\/\n+    public static KDF getInstance(String algorithm, AlgorithmParameterSpec algParameterSpec,\n+                                  Provider provider)\n+        throws NoSuchAlgorithmException, InvalidParameterSpecException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class, algorithm,\n+                                                        algParameterSpec, provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \" + instance.provider.getName();\n+                throw new SecurityException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm, algParameterSpec);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new NoSuchAlgorithmException(\"Algorithm \" + algorithm + \" not available\", nsae);\n+        }\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code Key}.\n+     * <p>\n+     * TODO: additional description\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant {@code Key} object\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a {@code SecretKey} object corresponding to a key built from the KDF output and according\n+     * to the derivation parameters.\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is invalid or incorrect\n+     *     for the type of key to be derived, or specifies a type of output that is not a key (e.g.\n+     *     raw data)\n+     * @throws IllegalStateException\n+     *     if the key derivation implementation cannot support additional calls to {@code deriveKey}\n+     *     or if all {@code KDFParameterSpec} objects provided at initialization have been\n+     *     processed.\n+     * @throws InvalidAlgorithmParameterException\n+     *     TODO: fill this in\n+     *\/\n+    public SecretKey deriveKey(String alg, KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException, InvalidAlgorithmParameterException {\n+        return spi.engineDeriveKey(alg, kdfParameterSpec);\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     * <p>\n+     * TODO: additional description\n+     *\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a byte array whose length matches the length field in the processed\n+     * {@code DerivationParameterSpec} and containing the next bytes of output from the key\n+     * derivation function.\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the {@code DerivationParameterSpec} being applied to this method is of a type other\n+     *     than \"data\".\n+     * @throws IllegalStateException\n+     *     if the key derivation implementation cannot support additional calls to\n+     *     {@code deriveData } or if all {@code DerivationParameterSpec} objects have been\n+     *     processed.\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     *\/\n+    public byte[] deriveData(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+        return spi.engineDeriveData(kdfParameterSpec);\n+    }\n+\n+    \/\/ max number of debug warnings to print from chooseFirstProvider()\n+    private static int warnCount = 10;\n+\n+    \/**\n+     * Choose the Spi from the first provider available. Used if delayed provider selection is not\n+     * possible because init() is not the first method called.\n+     *\/\n+    void chooseFirstProvider() {\n+        if ((spi != null) || (serviceIterator == null)) {\n+            return;\n+        }\n+        synchronized (lock) {\n+            if (spi != null) {\n+                return;\n+            }\n+            if (debug != null) {\n+                int w = --warnCount;\n+                if (w >= 0) {\n+                    debug.println(\"KeyDerivation.init() not first method called, disabling delayed \"\n+                                  + \"provider selection\");\n+                    if (w == 0) {\n+                        debug.println(\"Further warnings of this type will be suppressed\");\n+                    }\n+                    new Exception(\"Call trace\").printStackTrace();\n+                }\n+            }\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (JceSecurity.canUseProvider(s.getProvider()) == false) {\n+                    continue;\n+                }\n+                try {\n+                    Object obj = s.newInstance(null);\n+                    if (obj instanceof KDFSpi == false) {\n+                        continue;\n+                    }\n+                    spi = (KDFSpi) obj;\n+                    provider = s.getProvider();\n+                    \/\/ not needed any more\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return;\n+                } catch (NoSuchAlgorithmException e) {\n+                    lastException = e;\n+                }\n+            }\n+            ProviderException e = new ProviderException(\n+                \"Could not construct KeyDerivationSpi instance\");\n+            if (lastException != null) {\n+                e.initCause(lastException);\n+            }\n+            throw e;\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class defines the <i>Service Provider Interface<\/i> (<b>SPI<\/b>) for the\n+ * <code>KeyDerivation<\/code> class.\n+ * <p>\n+ * All the abstract methods in this class must be implemented by each cryptographic service provider\n+ * who wishes to supply the implementation of a particular key derivation algorithm.\n+ *\/\n+public abstract class KDFSpi {\n+\n+    \/**\n+     * provides access to the KDF alg params for implementers of the Spi\n+     *\/\n+    protected final AlgorithmParameterSpec algorithmParameterSpec;\n+\n+    \/**\n+     * The sole constructor.\n+     * <p>\n+     * TODO: additional description\n+     *\n+     * @param algParameterSpec\n+     *     the initialization parameters for the KDF algorithm (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this {@code KDFSpi}\n+     *\/\n+    protected KDFSpi(AlgorithmParameterSpec algParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+        this.algorithmParameterSpec = algParameterSpec;\n+    }\n+\n+\n+    \/**\n+     * Derive a key, returned as a {@code Key}.\n+     * <p>\n+     * TODO: additional description\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant key object\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a {@code SecretKey} object corresponding to a key built from the KDF output and according\n+     * to the derivation parameters.\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code DerivationParameterSpec} is invalid or\n+     *     incorrect for the type of key to be derived, or specifies a type of output that is not a\n+     *     key (e.g. raw data)\n+     * @throws IllegalStateException\n+     *     if the key derivation implementation cannot support additional calls to {@code deriveKey}\n+     *     or if all {@code DerivationParameterSpec} objects provided at initialization have been\n+     *     processed.\n+     *\/\n+    protected abstract SecretKey engineDeriveKey(String alg, KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException;\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     * <p>\n+     * TODO: additional description\n+     *\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a byte array whose length matches the length field in the processed\n+     * {@code DerivationParameterSpec} and containing the next bytes of output from the key\n+     * derivation function.\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the {@code DerivationParameterSpec} being applied to this method is of a type other\n+     *     than \"data\".\n+     * @throws IllegalStateException\n+     *     if the key derivation implementation cannot support additional calls to\n+     *     {@code deriveData } or if all {@code DerivationParameterSpec} objects have been\n+     *     processed.\n+     *\/\n+    protected abstract byte[] engineDeriveData(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException;\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFSpi.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,401 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+import javax.crypto.SecretKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * Parameters for the combined Extract-Only, Expand-Only, or Extract-then-Expand operations of the\n+ * HMAC-based Key Derivation Function (HKDF). The HKDF function is defined in <a\n+ * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+ *\n+ * @since 23\n+ *\/\n+public interface HKDFParameterSpec extends KDFParameterSpec {\n+\n+    \/**\n+     * This builder helps with the mutation required by the {@code Extract} scenario.\n+     *\/\n+    final class Builder {\n+\n+        Extract extract = null;\n+        List<SecretKey> ikms = new ArrayList<>();\n+        List<SecretKey> salts = new ArrayList<>();\n+        SecretKey prk = null;\n+\n+        Builder() {}\n+\n+        \/**\n+         * Creates a {@code Builder} for an {@code Extract}\n+         *\n+         * @return a {@code Builder} to mutate\n+         *\/\n+        private Builder createExtract() {\n+            extract = new Extract();\n+            return this;\n+        }\n+\n+        \/**\n+         * Akin to a {@code Builder.build()} method for an {@code Extract}\n+         *\n+         * @return an immutable {@code Extract}\n+         *\/\n+        public Extract extractOnly() {\n+            if (this.ikms.isEmpty() && this.salts.isEmpty()) {\n+                throw new IllegalStateException(\n+                    \"this `Builder` must have either at least one IKM value, at least one salt \"\n+                    + \"value, or values for both before calling `extractOnly`\");\n+            } else {\n+                this.extract = new Extract(List.copyOf(ikms), List.copyOf(salts));\n+                return this.extract;\n+            }\n+        }\n+\n+        \/**\n+         * Akin to a {@code Builder.build()} method for an {@code ExtractExpand}\n+         *\n+         * @param info\n+         *     the info\n+         * @param length\n+         *     the length\n+         *\n+         * @return an {@code ExtractExpand}\n+         *\/\n+        public ExtractExpand andExpand(byte[] info, int length) {\n+            if (extract == null) {\n+                throw new IllegalStateException(\n+                    \"`thenExpand` can only be called on a `Builder` when `ofTypeExtract` has \"\n+                    + \"been called\");\n+            }\n+            return extractExpand(new Extract(List.copyOf(ikms), List.copyOf(salts)), info, length);\n+        }\n+\n+        \/**\n+         * {@code addIKM} may be called when the ikm value is to be assembled piece-meal or if part\n+         * of the IKM is to be supplied by a hardware crypto device. This method appends to the\n+         * existing list of values or creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the IKM but the actual value\n+         * of the IKM is not yet available.\n+         *\n+         * @param ikm\n+         *     the ikm value (null values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addIKM(SecretKey ikm) {\n+            if (ikm != null) {\n+                ikms.add(ikm);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * {@code addIKM} may be called when the ikm value is to be assembled piece-meal or if part\n+         * of the IKM is to be supplied by a hardware crypto device. This method appends to the\n+         * existing list of values or creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the IKM but the actual value\n+         * of the IKM is not yet available.\n+         *\n+         * @param ikm\n+         *     the ikm value (null or empty values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addIKM(byte[] ikm) {\n+            if (ikm != null && ikm.length != 0) {\n+                return addIKM(new SecretKeySpec(ikm, \"RAW\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * {@code addSalt} may be called when the salt value is to be assembled piece-meal or if\n+         * part of the salt is to be supplied by a hardware crypto device. This method appends to\n+         * the existing list of values or creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the salt but the actual value\n+         * of the salt is not yet available.\n+         *\n+         * @param salt\n+         *     the salt value (null values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addSalt(SecretKey salt) {\n+            if (salt != null) {\n+                salts.add(salt);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * {@code addSalt} may be called when the salt value is to be assembled piece-meal or if\n+         * part of the salt is to be supplied by a hardware crypto device. This method appends to\n+         * the existing list of values or creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the salt but the actual value\n+         * of the salt is not yet available.\n+         *\n+         * @param salt\n+         *     the salt value (null or empty values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addSalt(byte[] salt) {\n+            if (salt != null && salt.length != 0) {\n+                return addSalt(new SecretKeySpec(salt, \"RAW\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Static helper-method that may be used to initialize a {@code Builder} with an empty\n+     * {@code Extract}\n+     * <p>\n+     * Note: one or more of the methods {@code addIKM} or {@code addSalt} should be called next,\n+     * before calling build methods, such as {@code Builder.extractOnly()}\n+     *\n+     * @return a {@code Builder} to mutate\n+     *\/\n+    static Builder extract() {\n+        return new Builder().createExtract();\n+    }\n+\n+    \/**\n+     * Static helper-method that may be used to initialize an {@code Expand} object\n+     *\n+     * @param prk\n+     *     the PRK (may be null)\n+     * @param info\n+     *     the info (may be null)\n+     * @param length\n+     *     the length\n+     *\n+     * @return a new {@code Expand} object\n+     *\/\n+    static Expand expand(SecretKey prk, byte[] info, int length) {\n+        return new Expand(prk, info, length);\n+    }\n+\n+    \/**\n+     * Static helper-method that may be used to initialize an {@code ExtractExpand} object\n+     * <p>\n+     * Note: one or more of the methods {@code addIKM} or {@code addSalt} should be called on the\n+     * {@code Extract} parameter, before calling this method, since {@code ExtractExpand} is\n+     * immutable\n+     *\n+     * @param ext\n+     *     a pre-generated {@code Extract}\n+     * @param info\n+     *     the info (may be {@code null})\n+     * @param length\n+     *     the length\n+     *\n+     * @return a new {@code ExtractExpand} object\n+     *\/\n+    static ExtractExpand extractExpand(Extract ext, byte[] info, int length) {\n+        return new ExtractExpand(ext, info, length);\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Extract operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    class Extract implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Extract(salt, IKM) -> PRK\n+        private final List<SecretKey> ikms;\n+        private final List<SecretKey> salts;\n+\n+        private Extract() {\n+            this(new ArrayList<>(), new ArrayList<>());\n+        }\n+\n+        private Extract(List<SecretKey> ikms, List<SecretKey> salts) {\n+            this.ikms = ikms;\n+            this.salts = salts;\n+        }\n+\n+        \/**\n+         * Gets the unmodifiable {@code List} of IKM values\n+         *\n+         * @return the unmodifiable {@code List} of IKM values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return Collections.unmodifiableList(ikms);\n+        }\n+\n+        \/**\n+         * Gets the unmodifiable {@code List} of salt values\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return Collections.unmodifiableList(salts);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Expand operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    class Expand implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Expand(PRK, info, L) -> OKM\n+        private SecretKey pseudoRandomKey = null;\n+        private byte[] info = null;\n+        private int length = -1;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code Expand} object\n+         *\n+         * @param prk\n+         *     the PRK; may be {@code null}\n+         * @param info\n+         *     the info\n+         * @param length\n+         *     the length\n+         *\/\n+        private Expand(SecretKey prk, byte[] info, int length) {\n+            \/\/ a null prk could be indicative of ExtractExpand\n+            this.pseudoRandomKey = prk;\n+            this.info = (info == null) ? null : info.clone();\n+            if (length < 1) {\n+                throw new IllegalArgumentException(\"length must be >= 1\");\n+            }\n+            this.length = length;\n+        }\n+\n+        \/**\n+         * gets the PRK\n+         *\n+         * @return the PRK value\n+         *\/\n+        public SecretKey prk() {\n+            return pseudoRandomKey;\n+        }\n+\n+        \/**\n+         * gets the info\n+         *\n+         * @return the info value\n+         *\/\n+        public byte[] info() {\n+            return info;\n+        }\n+\n+        \/**\n+         * gets the length\n+         *\n+         * @return the length value\n+         *\/\n+        public int length() {\n+            return length;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an ExtractExpand operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    class ExtractExpand implements HKDFParameterSpec {\n+        private final Extract ext;\n+        private final Expand exp;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code ExtractExpand} object\n+         * <p>\n+         * Note: {@code addIKMValue} and {@code addSaltValue} may be called afterward to supply\n+         * additional values, if desired\n+         *\n+         * @param ext\n+         *     a pre-generated {@code Extract}\n+         * @param info\n+         *     the info (may be {@code null})\n+         * @param length\n+         *     the length\n+         *\/\n+        private ExtractExpand(Extract ext, byte[] info, int length) {\n+            if (ext == null) {\n+                throw new IllegalArgumentException(\"ext (the Extract parameter) must not be null\");\n+            } else {\n+                this.ext = ext;\n+            }\n+            if (length < 1) {\n+                throw new IllegalArgumentException(\"length must be >= 1\");\n+            }\n+            this.exp = expand(null, info, length);\n+        }\n+\n+        \/**\n+         * Gets the {@code List} of IKM values\n+         *\n+         * @return the IKM values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ext.ikms();\n+        }\n+\n+        \/**\n+         * Gets the {@code List} of salt values\n+         *\n+         * @return the salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return ext.salts();\n+        }\n+\n+        \/**\n+         * Gets the info\n+         *\n+         * @return the info value\n+         *\/\n+        public byte[] info() {\n+            return exp.info();\n+        }\n+\n+        \/**\n+         * Gets the length\n+         *\n+         * @return the length value\n+         *\/\n+        public int length() {\n+            return exp.length();\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":401,"deletions":0,"binary":false,"changes":401,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+\/**\n+ * A (transparent) specification of key derivation parameters.\n+ *\n+ * <P> This interface contains no methods or constants. Its only purpose\n+ * is to group (and provide type safety for) all parameter specifications. All KDF parameter\n+ * specifications must implement this interface.\n+ *\n+ * @since 23\n+ *\/\n+public interface KDFParameterSpec {}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/KDFParameterSpec.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+public class TestHKDFInitialization {\n+    public static void main(String[] args)\n+        throws NoSuchAlgorithmException, InvalidParameterSpecException,\n+               InvalidAlgorithmParameterException {\n+\n+        byte[] ikm = new BigInteger(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                                    16).toByteArray();\n+        byte[] salt = new BigInteger(\"000102030405060708090a0b0c\", 16).toByteArray();\n+        byte[] info = new BigInteger(\"f0f1f2f3f4f5f6f7f8f9\", 16).toByteArray();\n+\n+        KDFParameterSpec kdfParameterSpec = HKDFParameterSpec.extractExpand(\n+            HKDFParameterSpec.extract().addIKM(ikm).addSalt(salt).extractOnly(), info, 42);\n+\n+        \/\/ OR THIS WAY NOW\n+        \/*KDFParameterSpec kdfParameterSpec2 =\n+            HKDFParameterSpec.extract()\n+                             .addIKM(ikm)\n+                             .addSalt(salt).andExpand(info, 42);*\/\n+\n+        KDF kdfHkdf = KDF.getInstance(\"HKDF\/HmacSHA256\", (AlgorithmParameterSpec) null);\n+\n+        kdfHkdf.deriveKey(\"AES\", kdfParameterSpec);\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/TestHKDFInitialization.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class TestHkdf {\n+    public static class TestData {\n+        public TestData(String name, String algStr, String ikmStr,\n+                        String saltStr, String infoStr, int oLen, String expPrkStr,\n+                        String expOkmStr) {\n+            testName = Objects.requireNonNull(name);\n+            algName = Objects.requireNonNull(algStr);\n+            IKM = hex2bin(Objects.requireNonNull(ikmStr));\n+            if ((outLen = oLen) <= 0) {\n+                throw new IllegalArgumentException(\n+                    \"Output length must be greater than 0\");\n+            }\n+            expectedPRK = hex2bin(Objects.requireNonNull(expPrkStr));\n+            expectedOKM = hex2bin(Objects.requireNonNull(expOkmStr));\n+\n+            \/\/ Non-mandatory fields - may be null\n+            salt = (saltStr != null) ? hex2bin(saltStr) : null;\n+            info = (infoStr != null) ? hex2bin(infoStr) : null;\n+        }\n+\n+        public final String testName;\n+        public final String algName;\n+        public final byte[] IKM;\n+        public final byte[] salt;\n+        public final byte[] info;\n+        public final int outLen;\n+        public final byte[] expectedPRK;\n+        public final byte[] expectedOKM;\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 5689 Test Case 1\", \"HKDF\/HmacSHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         \"000102030405060708090a0b0c\",\n+                         \"f0f1f2f3f4f5f6f7f8f9\",\n+                         42,\n+                         \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n+                         \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\" +\n+                         \"34007208d5b887185865\"));\n+        add(new TestData(\"RFC 5689 Test Case 2\", \"HKDF\/HmacSHA256\",\n+                         \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" +\n+                         \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" +\n+                         \"404142434445464748494a4b4c4d4e4f\",\n+                         \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" +\n+                         \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" +\n+                         \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                         \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" +\n+                         \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" +\n+                         \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n+                         82,\n+                         \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n+                         \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\" +\n+                         \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\" +\n+                         \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n+        add(new TestData(\"RFC 5689 Test Case 3\", \"HKDF\/HmacSHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         null, null, 42,\n+                         \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n+                         \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\" +\n+                         \"9d201395faa4b61a96c8\"));\n+    }};\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+\n+        int testNo = 0;\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNo + \": \" +\n+                               test.testName);\n+            if (runVector(test)) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total tests: \" + testList.size() +\n+                           \", Passed: \" + testsPassed + \", Failed: \" +\n+                           (testList.size() - testsPassed));\n+        if (testsPassed != testList.size()) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                                       \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runVector(TestData testData)\n+        throws InvalidParameterSpecException, InvalidAlgorithmParameterException,\n+               InvalidKeyException {\n+        String kdfName, prfName;\n+        KDF kdfHkdf, kdfExtract, kdfExpand;\n+        boolean result = true;\n+        SecretKey actualPRK;\n+        SecretKey actualOKM;\n+        byte[] deriveData;\n+\n+        \/\/ Get an instance of the HKDF Extract\/Expand derivation engine\n+        String[] tokens = testData.algName.split(\"\/\");\n+        kdfName = tokens[0];\n+        prfName = tokens[1];\n+        try {\n+            kdfHkdf = KDF.getInstance(testData.algName);\n+            kdfExtract = KDF.getInstance(\"HKDF-Extract\/\" + prfName);\n+            kdfExpand = KDF.getInstance(\"HKDF-Expand\/\" + prfName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            InvalidParameterSpecException exc =\n+                new InvalidParameterSpecException();\n+            exc.initCause(nsae);\n+            throw exc;\n+        }\n+\n+        \/\/ Set up the input keying material\n+        SecretKey ikmKey = new SecretKeySpec(testData.IKM, \"HKDF-IKM\");\n+\n+        \/\/ *** HKDF-Extract-only testing\n+        \/\/ Create KDFParameterSpec for the Extract-only operation\n+        KDFParameterSpec kdfParameterSpecExtract = HKDFParameterSpec.extract().addIKM(ikmKey)\n+                                                                    .addSalt(testData.salt)\n+                                                                    .extractOnly();\n+        actualPRK = kdfExtract.deriveKey(\"RAW\", kdfParameterSpecExtract);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExtract.deriveData(kdfParameterSpecExtract);\n+\n+        System.out.println(\"* HKDF-Extract-Only:\");\n+        result &= compareKeyAndData(actualPRK, deriveData,\n+                                    testData.expectedPRK);\n+\n+        \/\/ *** HKDF Expand-Only testing\n+        \/\/ For these tests, we'll use the actualPRK as the input key\n+        \/\/ Create KDFParameterSpec for key output and raw byte output\n+        KDFParameterSpec kdfParameterSpecExpand = HKDFParameterSpec.expand(actualPRK, testData.info,\n+                                                                           testData.outLen);\n+        actualOKM = kdfExpand.deriveKey(\"RAW\", kdfParameterSpecExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExpand.deriveData(kdfParameterSpecExpand);\n+\n+        System.out.println(\"* HKDF-Expand-Only:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        \/\/ *** HKDF Extract-then-Expand testing\n+        \/\/ We can reuse the KDFParameterSpec from the Expand-only test\n+\n+        \/\/ Use the KDF to make us a key\n+        KDFParameterSpec kdfParameterSpecExtractExpand = HKDFParameterSpec.extract().addIKM(ikmKey)\n+                                                                          .addSalt(testData.salt)\n+                                                                          .andExpand(testData.info,\n+                                                                                     testData.outLen);\n+        actualOKM = kdfHkdf.deriveKey(\"RAW\", kdfParameterSpecExtractExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfHkdf.deriveData(kdfParameterSpecExtractExpand);\n+\n+        System.out.println(\"* HKDF-Extract-then-Expand:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Compare key-based and data-based productions from the KDF against an expected output value.\n+     *\n+     * @param outKey\n+     *     the KDF output in key form\n+     * @param outData\n+     *     the KDF output as raw bytes\n+     * @param expectedOut\n+     *     the expected value\n+     *\n+     * @return true if the underlying data for outKey, outData and expectedOut are the same.\n+     *\/\n+    private static boolean compareKeyAndData(Key outKey, byte[] outData,\n+                                             byte[] expectedOut) {\n+        boolean result = true;\n+\n+        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n+            System.out.println(\"\\t* Key output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Key output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outKey.getEncoded(), 16, \"\\n\", \" \"));\n+            System.out.println();\n+        }\n+\n+        if (Arrays.equals(outData, expectedOut)) {\n+            System.out.println(\"\\t* Data output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Data output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data\n+     *     The array of bytes to dump to stdout.\n+     * @param itemsPerLine\n+     *     The number of bytes to display per line if the {@code lineDelim} character is blank then\n+     *     all bytes will be printed on a single line.\n+     * @param lineDelim\n+     *     The delimiter between lines\n+     * @param itemDelim\n+     *     The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+                                       String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static byte[] hex2bin(String hex) {\n+        int i;\n+        int len = hex.length();\n+        byte[] data = new byte[len \/ 2];\n+        for (i = 0; i < len; i += 2) {\n+            data[i \/ 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4) +\n+                                  Character.digit(hex.charAt(i + 1), 16));\n+        }\n+        return data;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/TestHkdf.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"}]}