{"files":[{"patch":"@@ -0,0 +1,429 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.KDFSpi;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/**\n+ * KeyDerivation implementation for the HKDF function.\n+ * <p>\n+ * This class implements the HKDF-Extract and HKDF-Expand functions from RFC 5869.  This\n+ * implementation provides the complete Extract-then-Expand HKDF function as well as Extract-only\n+ * and Expand-only variants.\n+ *\/\n+abstract class HkdfKeyDerivation extends KDFSpi {\n+\n+    protected Mac hmacObj;\n+    protected int hmacLen;\n+    protected String hmacAlgName;\n+    protected List<SecretKey> ikms;\n+    protected List<SecretKey> salts;\n+    protected SecretKey initialKeyMaterial;\n+    protected SecretKey salt;\n+    protected SecretKey pseudoRandomKey;\n+    protected byte[] info;\n+    protected int length;\n+\n+    protected enum HKDF_TYPE {\n+        EXTRACT, EXPAND, EXTRACTEXPAND\n+    }\n+\n+    protected HKDF_TYPE hkdfType;\n+\n+    \/**\n+     * The sole constructor.\n+     *\n+     * @param algParameterSpec\n+     *     the initialization parameters (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this {@code KDFSpi}\n+     *\/\n+    protected HkdfKeyDerivation(AlgorithmParameterSpec algParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+        super(algParameterSpec);\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey}.\n+     *\n+     * @return a derived {@code SecretKey} object of the specified algorithm\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived, or specifies\n+     *     a type of output that is not a key (e.g. raw data)\n+     *\/\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg, KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+\n+        try {\n+            \/\/ set up the HMAC instance\n+            hmacLen = setupHMAC(hmacAlgName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new ProviderException(nsae);\n+        }\n+\n+        \/\/ inspect KDFParameterSpec object\n+        inspectKDFParameterSpec(kdfParameterSpec);\n+\n+        if (hkdfType == HKDF_TYPE.EXTRACT) {\n+            \/\/ perform extract\n+            try {\n+                byte[] extractResult = hkdfExtract(initialKeyMaterial,\n+                                                   (salt == null) ? null : salt.getEncoded());\n+                return new SecretKeySpec(extractResult, alg);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Extract could not be initialized with the given key or salt material\");\n+            }\n+\n+        } else if (hkdfType == HKDF_TYPE.EXPAND) {\n+            \/\/ perform expand\n+            try {\n+                byte[] expandResult = hkdfExpand(this.pseudoRandomKey, this.info, this.length);\n+                return new SecretKeySpec(expandResult, 0, this.length, alg);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Expand could not be initialized with the given key material\");\n+            }\n+\n+        } else if (hkdfType == HKDF_TYPE.EXTRACTEXPAND) {\n+            \/\/ perform extract and then expand\n+            try {\n+                byte[] extractResult = hkdfExtract(initialKeyMaterial,\n+                                                   (salt == null) ? null : salt.getEncoded());\n+                this.pseudoRandomKey = new SecretKeySpec(extractResult, alg);\n+                byte[] expandResult = hkdfExpand(this.pseudoRandomKey, this.info, this.length);\n+                return new SecretKeySpec(expandResult, 0, this.length, alg);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF ExtractExpand could not be initialized with the given key or salt \"\n+                    + \"material\");\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     *\n+     * @return a derived {@code byte[]}\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     *\/\n+    @Override\n+    protected byte[] engineDeriveData(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+\n+        try {\n+            \/\/ set up the HMAC instance\n+            hmacLen = setupHMAC(hmacAlgName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new ProviderException(nsae);\n+        }\n+\n+        \/\/ inspect KDFParameterSpec object\n+        inspectKDFParameterSpec(kdfParameterSpec);\n+\n+        if (hkdfType == HKDF_TYPE.EXTRACT) {\n+            \/\/ perform extract\n+            try {\n+                return hkdfExtract(initialKeyMaterial, (salt == null) ? null : salt.getEncoded());\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Extract could not be initialized with the given key or salt material\");\n+            }\n+\n+        } else if (hkdfType == HKDF_TYPE.EXPAND) {\n+            \/\/ perform expand\n+            try {\n+                return Arrays.copyOf(hkdfExpand(this.pseudoRandomKey, this.info, this.length),\n+                                     this.length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF Expand could not be initialized with the given key material\");\n+            }\n+\n+        } else if (hkdfType == HKDF_TYPE.EXTRACTEXPAND) {\n+            \/\/ perform extract and then expand\n+            try {\n+                byte[] extractResult = hkdfExtract(initialKeyMaterial,\n+                                                   (salt == null) ? null : salt.getEncoded());\n+                this.pseudoRandomKey = new SecretKeySpec(extractResult, \"RAW\");\n+                return Arrays.copyOf(hkdfExpand(this.pseudoRandomKey, this.info, this.length),\n+                                     this.length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"an HKDF ExtractExpand could not be initialized with the given key or salt \"\n+                    + \"material\");\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    protected int setupHMAC(String hmacAlgName) throws NoSuchAlgorithmException {\n+        hmacObj = Mac.getInstance(hmacAlgName);\n+        return hmacObj.getMacLength();\n+    }\n+\n+    protected void inspectKDFParameterSpec(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+        \/\/ A switch would be nicer, but we may need to backport this before JDK 17\n+        \/\/ Also, JEP 305 came out in JDK 14, so we can't declare a variable in instanceof either\n+        if (kdfParameterSpec instanceof HKDFParameterSpec.Extract) {\n+            HKDFParameterSpec.Extract anExtract = (HKDFParameterSpec.Extract) kdfParameterSpec;\n+            this.ikms = anExtract.ikms();\n+            this.salts = anExtract.salts();\n+            if (isNullOrEmpty(ikms) && isNullOrEmpty(salts)) {\n+                throw new InvalidParameterSpecException(\n+                    \"IKM and salt cannot both be null or empty for HKDFParameterSpec.Extract\");\n+            }\n+            \/\/ we should be able to combine these Lists of keys into single SecretKey Objects,\n+            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            try {\n+                this.initialKeyMaterial = consolidateKeyMaterial(ikms);\n+                this.salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"Issue encountered when combining ikm or salt values into single keys\");\n+            }\n+            hkdfType = HKDF_TYPE.EXTRACT;\n+        } else if (kdfParameterSpec instanceof HKDFParameterSpec.Expand) {\n+            HKDFParameterSpec.Expand anExpand = (HKDFParameterSpec.Expand) kdfParameterSpec;\n+            \/\/ set this value in the \"if\"\n+            if ((pseudoRandomKey = anExpand.prk()) == null) {\n+                throw new InvalidParameterSpecException(\n+                    \"PRK is required for HKDFParameterSpec.Expand\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((length = anExpand.length()) <= 0) {\n+                throw new InvalidParameterSpecException(\"length cannot be <= 0\");\n+            }\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidParameterSpecException(\"Requested length \" +\n+                                                        \"exceeds maximum allowed key stream length\");\n+            }\n+            hkdfType = HKDF_TYPE.EXPAND;\n+        } else if (kdfParameterSpec instanceof HKDFParameterSpec.ExtractExpand) {\n+            HKDFParameterSpec.ExtractExpand anExtractExpand =\n+                (HKDFParameterSpec.ExtractExpand) kdfParameterSpec;\n+            ikms = anExtractExpand.ikms();\n+            salts = anExtractExpand.salts();\n+            if (isNullOrEmpty(ikms) && isNullOrEmpty(salts)) {\n+                throw new InvalidParameterSpecException(\n+                    \"IKM and salt cannot both be null for HKDFParameterSpec.ExtractExpand\");\n+            }\n+            \/\/ we should be able to combine these Lists of keys into single SecretKey Objects,\n+            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            try {\n+                this.initialKeyMaterial = consolidateKeyMaterial(ikms);\n+                this.salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidParameterSpecException(\n+                    \"Issue encountered when combining ikm or salt values into single keys\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExtractExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((length = anExtractExpand.length()) <= 0) {\n+                throw new InvalidParameterSpecException(\"length cannot be <= 0\");\n+            }\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidParameterSpecException(\"Requested length \" +\n+                                                        \"exceeds maximum allowed key stream length\");\n+            }\n+            hkdfType = HKDF_TYPE.EXTRACTEXPAND;\n+        } else {\n+            throw new InvalidParameterSpecException(\n+                \"The KDFParameterSpec object was not of a recognized type\");\n+        }\n+    }\n+\n+    private static boolean isNullOrEmpty(Collection<?> c) {\n+        return c == null || c.isEmpty();\n+    }\n+\n+    private SecretKey consolidateKeyMaterial(List<SecretKey> keys) throws InvalidKeyException {\n+        if (keys != null && !keys.isEmpty()) {\n+            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n+            if (localKeys.size() == 1) {\n+                \/\/ return this element\n+                return localKeys.get(0);\n+            } else {\n+                byte[] bb = new byte[0];\n+                for (SecretKey workItem : localKeys) {\n+                    byte[] workItemBytes = CipherCore.getKeyBytes(workItem);\n+\n+                    bb = Arrays.copyOf(bb, bb.length + workItemBytes.length);\n+                    System.arraycopy(workItemBytes, 0, bb, bb.length - workItemBytes.length,\n+                                     workItemBytes.length);\n+                }\n+                return new SecretKeySpec(bb, \"RAW\");\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HMAC-Extract operation.\n+     *\n+     * @param inputKey\n+     *     the input keying material used for the HKDF-Extract operation.\n+     * @param salt\n+     *     the salt value used for HKDF-Extract.  If no salt is to be used a {@code null} value\n+     *     should be provided.\n+     *\n+     * @return a byte array containing the pseudorandom key (PRK)\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid salt was provided through the {@code HkdfParameterSpec}\n+     *\/\n+    protected byte[] hkdfExtract(SecretKey inputKey, byte[] salt) throws InvalidKeyException {\n+\n+        if (salt == null) {\n+            salt = new byte[hmacLen];\n+        }\n+        hmacObj.init(new SecretKeySpec(salt, \"HKDF-Salt\"));\n+\n+        return hmacObj.doFinal(inputKey.getEncoded());\n+    }\n+\n+    \/**\n+     * Perform the HMAC-Expand operation.  At the end of the operation, the keyStream instance\n+     * variable will contain the complete KDF output based on the input values and desired length.\n+     *\n+     * @param prk\n+     *     the pseudorandom key used for HKDF-Expand\n+     * @param info\n+     *     optional context and application specific information or {@code null} if no info data is\n+     *     provided.\n+     * @param outLen\n+     *     the length in bytes of the required output\n+     *\n+     * @return a byte array containing the complete KDF output.  This will be at least as long as\n+     * the requested length in the {@code outLen} parameter, but will be rounded up to the nearest\n+     * multiple of the HMAC output length.\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid key was provided through the {@code HkdfParameterSpec} or derived during\n+     *     the generation of the PRK.\n+     *\/\n+    protected byte[] hkdfExpand(SecretKey prk, byte[] info, int outLen) throws InvalidKeyException {\n+        byte[] kdfOutput;\n+\n+        \/\/ Calculate the number of rounds of HMAC that are needed to\n+        \/\/ meet the requested data.  Then set up the buffers we will need.\n+        hmacObj.init(prk);\n+        if (info == null) {\n+            info = new byte[0];\n+        }\n+        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n+        kdfOutput = new byte[rounds * hmacLen];\n+        int offset = 0;\n+        int tLength = 0;\n+\n+        for (int i = 0; i < rounds; i++) {\n+\n+            \/\/ Calculate this round\n+            try {\n+                \/\/ Add T(i).  This will be an empty string on the first\n+                \/\/ iteration since tLength starts at zero.  After the first\n+                \/\/ iteration, tLength is changed to the HMAC length for the\n+                \/\/ rest of the loop.\n+                hmacObj.update(kdfOutput, Math.max(0, offset - hmacLen), tLength);\n+                hmacObj.update(info);                       \/\/ Add info\n+                hmacObj.update((byte) (i + 1));              \/\/ Add round number\n+                hmacObj.doFinal(kdfOutput, offset);\n+\n+                tLength = hmacLen;\n+                offset += hmacLen;                       \/\/ For next iteration\n+            } catch (ShortBufferException sbe) {\n+                \/\/ This really shouldn't happen given that we've\n+                \/\/ sized the buffers to their largest possible size up-front,\n+                \/\/ but just in case...\n+                throw new RuntimeException(sbe);\n+            }\n+        }\n+\n+        return kdfOutput;\n+    }\n+\n+    public static final class HkdfSHA256 extends HkdfKeyDerivation {\n+        public HkdfSHA256(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA256\";\n+        }\n+    }\n+\n+    public static final class HkdfSHA384 extends HkdfKeyDerivation {\n+        public HkdfSHA384(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA384\";\n+        }\n+    }\n+\n+    public static final class HkdfSHA512 extends HkdfKeyDerivation {\n+        public HkdfSHA512(AlgorithmParameterSpec algParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            super(algParameterSpec);\n+            hmacAlgName = \"HmacSHA512\";\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":429,"deletions":0,"binary":false,"changes":429,"status":"added"},{"patch":"@@ -460,0 +460,10 @@\n+        \/*\n+         * Key Derivation engines\n+         *\/\n+        ps(\"KDF\", \"HKDFWithHmacSHA256\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA256\");\n+        ps(\"KDF\", \"HKDFWithHmacSHA384\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA384\");\n+        ps(\"KDF\", \"HKDFWithHmacSHA512\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA512\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1607,0 +1607,2 @@\n+        addEngine(\"KDF\",                                false,\n+                            java.security.spec.AlgorithmParameterSpec.class);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,575 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import sun.security.jca.GetInstance;\n+import sun.security.jca.GetInstance.Instance;\n+import sun.security.util.Debug;\n+\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Provider.Service;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a key derivation algorithm for JCE.\n+ * <p>\n+ * {@code KDF} objects are instantiated through the {@code getInstance} family\n+ * of methods.  Key derivation algorithm names follow a naming convention of\n+ * <I>Algorithm<\/I>with<I>PRF<\/I>.  The algorithm field is the KDF algorithm (e.g.\n+ * HKDF, etc.), while the PRF specifier identifies the\n+ * underlying pseudorandom function (e.g. HmacSHA256).  For instance, a KDF\n+ * implementation of HKDF using HMAC-SHA256 will have an algorithm string of\n+ * \"HKDFwithHmacSHA256\".  In some cases the PRF portion of the algorithm specifier\n+ * may be omitted if the KDF algorithm has a fixed or default PRF.\n+ * <p>\n+ *\n+ * Example:\n+ *  {@snippet lang = java:\n+ *    KDF kdfHkdf = KDF.getInstance(\"HKDFWithHmacSHA256\",\n+ *                                       (AlgorithmParameterSpec) null);\n+ *\n+ *    KDFParameterSpec kdfParameterSpec =\n+ *             HKDFParameterSpec.extract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).andExpand(info, 42);\n+ *\n+ *    kdfHkdf.deriveKey(\"AES\", kdfParameterSpec);\n+ *}\n+ *\n+ *\n+ * @see SecretKey\n+ *\n+ * @since 23\n+ *\/\n+\/\/@PreviewFeature(feature=PreviewFeature.Feature.KEY_DERIVATION)\n+public final class KDF {\n+    private static final Debug debug = Debug.getInstance(\"jca\",\n+                                                         \"KDF\");\n+\n+    private static final Debug pdebug = Debug.getInstance(\"provider\",\n+                                                          \"Provider\");\n+    private static final boolean skipDebug = Debug.isOn(\"engine=\")\n+                                             && !Debug.isOn(\"kdf\");\n+\n+    \/\/ The provider\n+    private Provider provider;\n+\n+    \/\/ The provider implementation (delegate)\n+    private KDFSpi spi;\n+\n+    \/\/ The name of the MAC algorithm.\n+    private final String algorithm;\n+\n+    \/\/ Additional KDF configuration parameters\n+    private final AlgorithmParameterSpec algorithmParameterSpec;\n+\n+    \/\/ next service to try in provider selection\n+    \/\/ null once provider is selected\n+    private Service firstService;\n+\n+    \/\/ remaining services to try in provider selection\n+    \/\/ null once provider is selected\n+    private Iterator<Service> serviceIterator;\n+\n+    private final Object lock;\n+\n+    \/**\n+     * Instantiates a KDF object.\n+     *\n+     * @param keyDerivSpi\n+     *     the delegate\n+     * @param provider\n+     *     the provider\n+     * @param algorithm\n+     *     the algorithm\n+     * @param algParameterSpec\n+     *     the algorithm parameters\n+     *\/\n+    private KDF(KDFSpi keyDerivSpi, Provider provider, String algorithm,\n+                AlgorithmParameterSpec algParameterSpec) {\n+        this.spi = keyDerivSpi;\n+        this.provider = provider;\n+        this.algorithm = algorithm;\n+        this.algorithmParameterSpec = algParameterSpec;\n+        \/\/ the lock is not needed, because the Spi will already be set in\n+        \/\/ chooseProvider\n+        lock = null;\n+    }\n+\n+    private KDF(Service s, Iterator<Service> t, String algorithm,\n+                AlgorithmParameterSpec algParameterSpec) {\n+        firstService = s;\n+        serviceIterator = t;\n+        this.algorithm = algorithm;\n+        this.algorithmParameterSpec = algParameterSpec;\n+        lock = new Object();\n+    }\n+\n+    \/**\n+     * Returns the algorithm name of this {@code KDF} object.\n+     *\n+     * <p>This is the same name that was specified in one of the\n+     * {@code getInstance} calls that created this {@code KDF} object.\n+     *\n+     * @return the algorithm name of this {@code KDF} object\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+\n+    \/**\n+     * Returns the name of the provider.\n+     *\n+     * @return the name of the provider\n+     *\/\n+    public String getProviderName() {\n+        chooseFirstProvider();\n+        return provider.getName();\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm)\n+        throws NoSuchAlgorithmException {\n+        try {\n+            return getInstance(algorithm, (AlgorithmParameterSpec) null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidParameterSpecException. Does this \"\n+                + \"algorithm require an \"\n+                + \"AlgorithmParameterSpec?\");\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object with a specific\n+     * {@code Provider}.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider\n+     *     list\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException {\n+        try {\n+            return getInstance(algorithm, null,\n+                               provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidParameterSpecException. Does this \"\n+                + \"algorithm require an \"\n+                + \"AlgorithmParameterSpec?\");\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object using a supplied\n+     * {@code Provider} instance.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param provider\n+     *     the provider\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, Provider provider)\n+        throws NoSuchAlgorithmException {\n+        try {\n+            return getInstance(algorithm, null,\n+                               provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidParameterSpecException. Does this \"\n+                + \"algorithm require an \"\n+                + \"AlgorithmParameterSpec?\");\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param algParameterSpec\n+     *     the {@code AlgorithmParameterSpec} used to configure this KDF's\n+     *     algorithm or {@code null} if no additional parameters were provided.\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  AlgorithmParameterSpec algParameterSpec)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        \/\/ make sure there is at least one service from a signed provider\n+        Iterator<Service> t = GetInstance.getServices(\"KDF\", algorithm);\n+        while (t.hasNext()) {\n+            Service s = t.next();\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                continue;\n+            }\n+            return new KDF(s, t, algorithm, algParameterSpec);\n+        }\n+        throw new NoSuchAlgorithmException\n+                  (\"Algorithm \" + algorithm + \" not available\");\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object with a specific\n+     * {@code Provider}.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param algParameterSpec\n+     *     the {@code AlgorithmParameterSpec} used to configure this KDF's\n+     *     algorithm or {@code null} if no additional parameters were provided.\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm.\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider\n+     *     list\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  AlgorithmParameterSpec algParameterSpec,\n+                                  String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException,\n+               InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                        algorithm,\n+                                                        algParameterSpec,\n+                                                        provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \"\n+                             + instance.provider.getName();\n+                throw new NoSuchProviderException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm,\n+                           algParameterSpec);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            return handleException(nsae);\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code KDF} object using a supplied\n+     * {@code Provider} instance.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param algParameterSpec\n+     *     the {@code AlgorithmParameterSpec} used to configure this KDF's\n+     *     algorithm or {@code null} if no additional parameters were provided.\n+     * @param provider\n+     *     the provider\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  AlgorithmParameterSpec algParameterSpec,\n+                                  Provider provider)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                        algorithm,\n+                                                        algParameterSpec,\n+                                                        provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \"\n+                             + instance.provider.getName();\n+                throw new SecurityException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm,\n+                           algParameterSpec);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            return handleException(nsae);\n+        }\n+    }\n+\n+    private static KDF handleException(NoSuchAlgorithmException e)\n+        throws NoSuchAlgorithmException,\n+               InvalidAlgorithmParameterException {\n+        Throwable cause = e.getCause();\n+        if (cause instanceof InvalidAlgorithmParameterException) {\n+            throw (InvalidAlgorithmParameterException) cause;\n+        }\n+        throw e;\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey}.\n+     * <p>\n+     * The {@code deriveKey} method may be called multiple times once a\n+     * {@code KDF} object is initialized.\n+     * <p>\n+     * Delayed provider selection is also supported such that the provider\n+     * performing the derive is not selected until the method is called.\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant {@code SecretKey} object\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a {@code SecretKey} object corresponding to a key built from the\n+     *     KDF output and according to the derivation parameters\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived, or specifies\n+     *     a type of output that is not a key (e.g. raw data)\n+     *\n+     *\/\n+    public SecretKey deriveKey(String alg, KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+        synchronized (lock) {\n+            if (spi != null) {\n+                return spi.engineDeriveKey(alg, kdfParameterSpec);\n+            }\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                    continue;\n+                }\n+                try {\n+                    KDFSpi spi = (KDFSpi) s.newInstance(algorithmParameterSpec);\n+                    SecretKey result = spi.engineDeriveKey(alg, kdfParameterSpec);\n+                    provider = s.getProvider();\n+                    this.spi = spi;\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return result;\n+                } catch (Exception e) {\n+                    if (lastException == null) {\n+                        lastException = e;\n+                    }\n+                }\n+            }\n+            \/\/ no working provider found, fail\n+            if (lastException instanceof InvalidParameterSpecException) {\n+                throw (InvalidParameterSpecException) lastException;\n+            }\n+            if (lastException instanceof RuntimeException) {\n+                throw (RuntimeException) lastException;\n+            }\n+        }\n+        \/\/ should never reach here\n+        return null;\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     * <p>\n+     * The {@code deriveData} method may be called multiple times once a\n+     * {@code KDF} object is initialized.\n+     * <p>\n+     * Delayed provider selection is also supported such that the provider\n+     * performing the derive is not selected until the method is called.\n+     *\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a byte array whose length matches the length field in the\n+     *     processed {@code KDFParameterSpec} and containing the next\n+     *     bytes of output from the key derivation function\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     *\/\n+    public byte[] deriveData(KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException {\n+        synchronized (lock) {\n+            if (spi != null) {\n+                return spi.engineDeriveData(kdfParameterSpec);\n+            }\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                    continue;\n+                }\n+                try {\n+                    KDFSpi spi = (KDFSpi) s.newInstance(algorithmParameterSpec);\n+                    byte[] result = spi.engineDeriveData(kdfParameterSpec);\n+                    provider = s.getProvider();\n+                    this.spi = spi;\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return result;\n+                } catch (Exception e) {\n+                    if (lastException == null) {\n+                        lastException = e;\n+                    }\n+                }\n+            }\n+            \/\/ no working provider found, fail\n+            if (lastException instanceof InvalidParameterSpecException) {\n+                throw (InvalidParameterSpecException) lastException;\n+            }\n+            if (lastException instanceof RuntimeException) {\n+                throw (RuntimeException) lastException;\n+            }\n+        }\n+        \/\/ should never reach here\n+        return null;\n+    }\n+\n+    \/\/ max number of debug warnings to print from chooseFirstProvider()\n+    private static int warnCount = 10;\n+\n+    \/**\n+     * Choose the Spi from the first provider available. Used if delayed\n+     * provider selection is not possible because init() is not the first method\n+     * called.\n+     *\/\n+    void chooseFirstProvider() {\n+        if ((spi != null) || (serviceIterator == null)) {\n+            return;\n+        }\n+        synchronized (lock) {\n+            if (spi != null) {\n+                return;\n+            }\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                    continue;\n+                }\n+                try {\n+                    Object obj = s.newInstance(algorithmParameterSpec);\n+                    if (!(obj instanceof KDFSpi)) {\n+                        continue;\n+                    }\n+                    spi = (KDFSpi) obj;\n+                    provider = s.getProvider();\n+                    \/\/ not needed any more\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return;\n+                } catch (NoSuchAlgorithmException e) {\n+                    lastException = e;\n+                }\n+            }\n+            ProviderException e = new ProviderException(\n+                \"Could not construct KDFSpi instance\");\n+            if (lastException != null) {\n+                e.initCause(lastException);\n+            }\n+            throw e;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":575,"deletions":0,"binary":false,"changes":575,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class defines the <i>Service Provider Interface<\/i> (<b>SPI<\/b>) for the\n+ * {@code KDF} class.\n+ * <p>\n+ * All the abstract methods in this class must be implemented by each\n+ * cryptographic service provider who wishes to supply the implementation of a\n+ * particular key derivation algorithm.\n+ *\n+ * @see KDF\n+ * @see SecretKey\n+ * @since 23\n+ *\/\n+\/\/@PreviewFeature(feature=PreviewFeature.Feature.KEY_DERIVATION)\n+public abstract class KDFSpi {\n+\n+    \/**\n+     * provides access to the KDF alg params for implementers of the Spi\n+     *\/\n+    protected final AlgorithmParameterSpec algorithmParameterSpec;\n+\n+    \/**\n+     * The sole constructor.\n+     * <p>\n+     * An {@code AlgorithmParameterSpec} may be specified for PRF algorithms that\n+     * may require this. Though no such KDF algorithms are currently defined,\n+     * this parameter is held for future use.\n+     *\n+     * @param algParameterSpec\n+     *     the initialization parameters for the {@code KDF} algorithm (may be\n+     *     {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this\n+     *     {@code KDFSpi}\n+     *\/\n+    protected KDFSpi(AlgorithmParameterSpec algParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+        this.algorithmParameterSpec = algParameterSpec;\n+    }\n+\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey}.\n+     * <p>\n+     * The {@code deriveKey} method may be called multiple times once a\n+     * {@code KDF} object is initialized.\n+     * <p>\n+     * Delayed provider selection is also supported such that the provider\n+     * performing the derive is not selected until the method is called.\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant key object\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a {@code SecretKey} object corresponding to a key built from the\n+     *     KDF output and according to the derivation parameters.\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived, or specifies\n+     *     a type of output that is not a key (e.g. raw data)\n+     *\/\n+    protected abstract SecretKey engineDeriveKey(String alg,\n+                                                 KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException;\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     * <p>\n+     * The {@code deriveData} method may be called multiple times once a\n+     * {@code KDF} object is initialized.\n+     * <p>\n+     * Delayed provider selection is also supported such that the provider\n+     * performing the derive is not selected until the method is called.\n+     *\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a byte array whose length matches the length field in the\n+     *     processed {@code KDFParameterSpec} and containing the next bytes of\n+     *     output from the key derivation function.\n+     *\n+     * @throws InvalidParameterSpecException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     *\/\n+    protected abstract byte[] engineDeriveData(\n+        KDFParameterSpec kdfParameterSpec)\n+        throws InvalidParameterSpecException;\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFSpi.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.SecretKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/**\n+ * Parameters for the combined Extract-Only, Expand-Only, or Extract-then-Expand\n+ * operations of the HMAC-based Key Derivation Function (HKDF). The HKDF\n+ * function is defined in <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC\n+ * 5869<\/a>.\n+ *\n+ * @since 23\n+ *\/\n+\/\/@PreviewFeature(feature=PreviewFeature.Feature.KEY_DERIVATION)\n+public interface HKDFParameterSpec extends KDFParameterSpec {\n+\n+    \/**\n+     * This builder helps with the mutation required by the {@code Extract}\n+     * scenario.\n+     *\/\n+    final class Builder {\n+\n+        Extract extract = null;\n+        List<SecretKey> ikms = new ArrayList<>();\n+        List<SecretKey> salts = new ArrayList<>();\n+\n+        Builder() {}\n+\n+        \/**\n+         * Creates a {@code Builder} for an {@code Extract}.\n+         *\n+         * @return a {@code Builder} to mutate\n+         *\/\n+        private Builder createExtract() {\n+            extract = new Extract();\n+            return this;\n+        }\n+\n+        \/**\n+         * Akin to a {@code Builder.build()} method for an {@code Extract}\n+         *\n+         * @return an immutable {@code Extract}\n+         *\/\n+        public Extract extractOnly() {\n+            if (this.ikms.isEmpty() && this.salts.isEmpty()) {\n+                throw new IllegalStateException(\n+                    \"this `Builder` must have either at least one IKM value, \"\n+                    + \"at least one salt \"\n+                    + \"value, or values for both before calling `extractOnly`\");\n+            } else {\n+                this.extract = new Extract(List.copyOf(ikms),\n+                                           List.copyOf(salts));\n+                return this.extract;\n+            }\n+        }\n+\n+        \/**\n+         * Akin to a {@code Builder.build()} method for an\n+         * {@code ExtractExpand}\n+         *\n+         * @param info\n+         *     the optional context and application specific information\n+         * @param length\n+         *     the length of output keying material\n+         *\n+         * @return an {@code ExtractExpand}\n+         *\/\n+        public ExtractExpand andExpand(byte[] info, int length) {\n+            if (extract == null) {\n+                throw new IllegalStateException(\n+                    \"`thenExpand` can only be called on a `Builder` when \"\n+                    + \"`ofTypeExtract` has \"\n+                    + \"been called\");\n+            }\n+            return extractExpand(\n+                new Extract(List.copyOf(ikms), List.copyOf(salts)), info,\n+                length);\n+        }\n+\n+        \/**\n+         * {@code addIKM} may be called when the initial key material value is to be assembled\n+         * piece-meal or if part of the IKM is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the IKM\n+         * but the actual value of the IKM is not yet available.\n+         *\n+         * @param ikm\n+         *     the initial key material value (null values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addIKM(SecretKey ikm) {\n+            if (ikm != null) {\n+                ikms.add(ikm);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * {@code addIKM} may be called when the initial key material value is to be assembled\n+         * piece-meal or if part of the IKM is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the IKM\n+         * but the actual value of the IKM is not yet available.\n+         *\n+         * @param ikm\n+         *     the initial key material value (null or empty values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addIKM(byte[] ikm) {\n+            if (ikm != null && ikm.length != 0) {\n+                return addIKM(new SecretKeySpec(ikm, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * {@code addSalt} may be called when the salt value is to be assembled\n+         * piece-meal or if part of the salt is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the salt\n+         * but the actual value of the salt is not yet available.\n+         *\n+         * @param salt\n+         *     the salt value (null values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addSalt(SecretKey salt) {\n+            if (salt != null) {\n+                salts.add(salt);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * {@code addSalt} may be called when the salt value is to be assembled\n+         * piece-meal or if part of the salt is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there are none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the salt\n+         * but the actual value of the salt is not yet available.\n+         *\n+         * @param salt\n+         *     the salt value (null or empty values will not be added)\n+         *\n+         * @return a new {@code Extract} object\n+         *\/\n+        public Builder addSalt(byte[] salt) {\n+            if (salt != null && salt.length != 0) {\n+                return addSalt(new SecretKeySpec(salt, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Static helper-method that may be used to initialize a {@code Builder}\n+     * with an empty {@code Extract}\n+     * <p>\n+     * Note: one or more of the methods {@code addIKM} or {@code addSalt} should\n+     * be called next, before calling build methods, such as\n+     * {@code Builder.extractOnly()}\n+     *\n+     * @return a {@code Builder} to mutate\n+     *\/\n+    static Builder extract() {\n+        return new Builder().createExtract();\n+    }\n+\n+    \/**\n+     * Static helper-method that may be used to initialize an {@code Expand}\n+     * object\n+     *\n+     * @param prk\n+     *     the pseudorandom key (may be null)\n+     * @param info\n+     *     the optional context and application specific information (may be null)\n+     * @param length\n+     *     the length of output keying material\n+     *\n+     * @return a new {@code Expand} object\n+     *\/\n+    static Expand expand(SecretKey prk, byte[] info, int length) {\n+        return new Expand(prk, info, length);\n+    }\n+\n+    \/**\n+     * Static helper-method that may be used to initialize an\n+     * {@code ExtractExpand} object\n+     * <p>\n+     * Note: one or more of the methods {@code addIKM} or {@code addSalt} should\n+     * be called on the {@code Extract} parameter, before calling this method,\n+     * since {@code ExtractExpand} is immutable\n+     *\n+     * @param ext\n+     *     a pre-generated {@code Extract}\n+     * @param info\n+     *     the optional context and application specific information (may be {@code null})\n+     * @param length\n+     *     the length of output keying material\n+     *\n+     * @return a new {@code ExtractExpand} object\n+     *\/\n+    static ExtractExpand extractExpand(Extract ext, byte[] info, int length) {\n+        return new ExtractExpand(ext, info, length);\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Extract operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    final class Extract implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Extract(salt, IKM) -> PRK\n+        private final List<SecretKey> ikms;\n+        private final List<SecretKey> salts;\n+\n+        private Extract() {\n+            this(new ArrayList<>(), new ArrayList<>());\n+        }\n+\n+        private Extract(List<SecretKey> ikms, List<SecretKey> salts) {\n+            this.ikms = ikms;\n+            this.salts = salts;\n+        }\n+\n+        \/**\n+         * Returns the unmodifiable {@code List} of initial key material values.\n+         *\n+         * @return the unmodifiable {@code List} of initial key material values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return Collections.unmodifiableList(ikms);\n+        }\n+\n+        \/**\n+         * Returns the unmodifiable {@code List} of salt values.\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return Collections.unmodifiableList(salts);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Expand operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    final class Expand implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Expand(PRK, info, L) -> OKM\n+        private final SecretKey prk;\n+        private final byte[] info;\n+        private final int length;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code Expand} object\n+         *\n+         * @param prk\n+         *     the pseudorandom key; may be {@code null}\n+         * @param info\n+         *     the optional context and application specific information\n+         * @param length\n+         *     the length of output keying material\n+         *\/\n+        private Expand(SecretKey prk, byte[] info, int length) {\n+            \/\/ a null prk could be indicative of ExtractExpand\n+            this.prk = prk;\n+            this.info = (info == null) ? null : info.clone();\n+            if (length < 1) {\n+                throw new IllegalArgumentException(\"length must be >= 1\");\n+            }\n+            this.length = length;\n+        }\n+\n+        \/**\n+         * Returns the pseudorandom key.\n+         *\n+         * @return the pseudorandom key\n+         *\/\n+        public SecretKey prk() {\n+            return prk;\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return the optional context and application specific information\n+         *\/\n+        public byte[] info() {\n+            return (info == null)? null : info.clone();\n+        }\n+\n+        \/**\n+         * Returns the length of output keying material.\n+         *\n+         * @return the length of output keying material\n+         *\/\n+        public int length() {\n+            return length;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an ExtractExpand operation as defined in\n+     * <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    final class ExtractExpand implements HKDFParameterSpec {\n+        private final Extract ext;\n+        private final Expand exp;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code ExtractExpand}\n+         * object\n+         * <p>\n+         * Note: {@code addIKMValue} and {@code addSaltValue} may be called\n+         * afterward to supply additional values, if desired\n+         *\n+         * @param ext\n+         *     a pre-generated {@code Extract}\n+         * @param info\n+         *     the optional context and application specific information (may be {@code null})\n+         * @param length\n+         *     the length of output keying material\n+         *\/\n+        private ExtractExpand(Extract ext, byte[] info, int length) {\n+            if (ext == null) {\n+                throw new IllegalArgumentException(\n+                    \"ext (the Extract parameter) must not be null\");\n+            } else {\n+                this.ext = ext;\n+            }\n+            if (length < 1) {\n+                throw new IllegalArgumentException(\"length must be >= 1\");\n+            }\n+            this.exp = expand(null, info, length);\n+        }\n+\n+        \/**\n+         * Returns the {@code List} of initial key material values.\n+         *\n+         * @return the initial key material values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ext.ikms();\n+        }\n+\n+        \/**\n+         * Returns the {@code List} of salt values.\n+         *\n+         * @return the salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return ext.salts();\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return the optional context and application specific information\n+         *\/\n+        public byte[] info() {\n+            return exp.info();\n+        }\n+\n+        \/**\n+         * Returns the length of output keying material.\n+         *\n+         * @return the length of output keying material\n+         *\/\n+        public int length() {\n+            return exp.length();\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A (transparent) specification of key derivation parameters.\n+ *\n+ * <P> This interface contains no methods or constants. Its only purpose\n+ * is to group (and provide type safety for) all KDF parameter specifications.\n+ *\n+ * @since 23\n+ *\/\n+\/\/@PreviewFeature(feature=PreviewFeature.Feature.KEY_DERIVATION)\n+public interface KDFParameterSpec {}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/KDFParameterSpec.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -86,0 +86,2 @@\n+        \/\/@JEP(number=478, title=\"Key Derivation\", status=\"Preview\")\n+        \/\/KEY_DERIVATION,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        System.err.println(\"              Cipher, KeyAgreement, KeyGenerator,\");\n+        System.err.println(\"              Cipher, KDF, KeyAgreement, KeyGenerator,\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+            \/\/case KEY_DERIVATION -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -258,1 +258,2 @@\n-        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n+        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL)\/*,\n+        KEY_DERIVATION(JDK23, Fragments.FeatureKeyDerivation, DiagKind.NORMAL)*\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3224,0 +3224,3 @@\n+#compiler.misc.feature.key.derivation=\\\n+#    key derivation\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @run main TestHKDF\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class TestHKDF {\n+    public static class TestData {\n+        public TestData(String name, String algStr, String ikmStr,\n+                        String saltStr, String infoStr, int oLen,\n+                        String expPrkStr,\n+                        String expOkmStr) {\n+            testName = Objects.requireNonNull(name);\n+            algName = Objects.requireNonNull(algStr);\n+            IKM = hex2bin(Objects.requireNonNull(ikmStr));\n+            if ((outLen = oLen) <= 0) {\n+                throw new IllegalArgumentException(\n+                    \"Output length must be greater than 0\");\n+            }\n+            expectedPRK = hex2bin(Objects.requireNonNull(expPrkStr));\n+            expectedOKM = hex2bin(Objects.requireNonNull(expOkmStr));\n+\n+            \/\/ Non-mandatory fields - may be null\n+            salt = (saltStr != null) ? hex2bin(saltStr) : null;\n+            info = (infoStr != null) ? hex2bin(infoStr) : null;\n+        }\n+\n+        public final String testName;\n+        public final String algName;\n+        public final byte[] IKM;\n+        public final byte[] salt;\n+        public final byte[] info;\n+        public final int outLen;\n+        public final byte[] expectedPRK;\n+        public final byte[] expectedOKM;\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 5689 Test Case 1\", \"HKDFWithHmacSHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         \"000102030405060708090a0b0c\",\n+                         \"f0f1f2f3f4f5f6f7f8f9\",\n+                         42,\n+                         \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n+                         \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\"\n+                         +\n+                         \"34007208d5b887185865\"));\n+        add(new TestData(\"RFC 5689 Test Case 2\", \"HKDFWithHmacSHA256\",\n+                         \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"\n+                         +\n+                         \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n+                         +\n+                         \"404142434445464748494a4b4c4d4e4f\",\n+                         \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\"\n+                         +\n+                         \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\"\n+                         +\n+                         \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                         \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\"\n+                         +\n+                         \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\"\n+                         +\n+                         \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n+                         82,\n+                         \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n+                         \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\"\n+                         +\n+                         \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\"\n+                         +\n+                         \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n+        add(new TestData(\"RFC 5689 Test Case 3\", \"HKDFWithHmacSHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         null, null, 42,\n+                         \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n+                         \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\"\n+                         +\n+                         \"9d201395faa4b61a96c8\"));\n+    }};\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+\n+        int testNo = 0;\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNo + \": \" +\n+                               test.testName);\n+            if (runVector(test)) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total tests: \" + testList.size() +\n+                           \", Passed: \" + testsPassed + \", Failed: \" +\n+                           (testList.size() - testsPassed));\n+        if (testsPassed != testList.size()) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                                       \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runVector(TestData testData)\n+        throws InvalidParameterSpecException,\n+               InvalidAlgorithmParameterException,\n+               InvalidKeyException {\n+        String kdfName, prfName;\n+        KDF kdfHkdf, kdfExtract, kdfExpand;\n+        boolean result = true;\n+        SecretKey actualPRK;\n+        SecretKey actualOKM;\n+        byte[] deriveData;\n+\n+        try {\n+            kdfHkdf = KDF.getInstance(testData.algName);\n+            kdfExtract = KDF.getInstance(testData.algName);\n+            kdfExpand = KDF.getInstance(testData.algName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            InvalidParameterSpecException exc =\n+                new InvalidParameterSpecException();\n+            exc.initCause(nsae);\n+            throw exc;\n+        }\n+\n+        \/\/ Set up the input keying material\n+        SecretKey ikmKey = new SecretKeySpec(testData.IKM, \"HKDF-IKM\");\n+\n+        \/\/ *** HKDF-Extract-only testing\n+        \/\/ Create KDFParameterSpec for the Extract-only operation\n+        KDFParameterSpec kdfParameterSpecExtract =\n+            HKDFParameterSpec.extract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .extractOnly();\n+        actualPRK = kdfExtract.deriveKey(\"RAW\", kdfParameterSpecExtract);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExtract.deriveData(kdfParameterSpecExtract);\n+\n+        System.out.println(\"* HKDF-Extract-Only:\");\n+        result &= compareKeyAndData(actualPRK, deriveData,\n+                                    testData.expectedPRK);\n+\n+        \/\/ *** HKDF Expand-Only testing\n+        \/\/ For these tests, we'll use the actualPRK as the input key\n+        \/\/ Create KDFParameterSpec for key output and raw byte output\n+        KDFParameterSpec kdfParameterSpecExpand = HKDFParameterSpec.expand(\n+            actualPRK, testData.info,\n+            testData.outLen);\n+        actualOKM = kdfExpand.deriveKey(\"RAW\", kdfParameterSpecExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExpand.deriveData(kdfParameterSpecExpand);\n+\n+        System.out.println(\"* HKDF-Expand-Only:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        \/\/ *** HKDF Extract-then-Expand testing\n+        \/\/ We can reuse the KDFParameterSpec from the Expand-only test\n+\n+        \/\/ Use the KDF to make us a key\n+        KDFParameterSpec kdfParameterSpecExtractExpand =\n+            HKDFParameterSpec.extract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .andExpand(testData.info,\n+                                        testData.outLen);\n+        actualOKM = kdfHkdf.deriveKey(\"RAW\", kdfParameterSpecExtractExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfHkdf.deriveData(kdfParameterSpecExtractExpand);\n+\n+        System.out.println(\"* HKDF-Extract-then-Expand:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Compare key-based and data-based productions from the KDF against an\n+     * expected output value.\n+     *\n+     * @param outKey\n+     *     the KDF output in key form\n+     * @param outData\n+     *     the KDF output as raw bytes\n+     * @param expectedOut\n+     *     the expected value\n+     *\n+     * @return true if the underlying data for outKey, outData and expectedOut\n+     * are the same.\n+     *\/\n+    private static boolean compareKeyAndData(Key outKey, byte[] outData,\n+                                             byte[] expectedOut) {\n+        boolean result = true;\n+\n+        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n+            System.out.println(\"\\t* Key output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Key output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outKey.getEncoded(), 16, \"\\n\",\n+                                            \" \"));\n+            System.out.println();\n+        }\n+\n+        if (Arrays.equals(outData, expectedOut)) {\n+            System.out.println(\"\\t* Data output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Data output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data\n+     *     The array of bytes to dump to stdout.\n+     * @param itemsPerLine\n+     *     The number of bytes to display per line if the {@code lineDelim}\n+     *     character is blank then all bytes will be printed on a single line.\n+     * @param lineDelim\n+     *     The delimiter between lines\n+     * @param itemDelim\n+     *     The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+                                       String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static byte[] hex2bin(String hex) {\n+        int i;\n+        int len = hex.length();\n+        byte[] data = new byte[len \/ 2];\n+        for (i = 0; i < len; i += 2) {\n+            data[i \/ 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4) +\n+                                  Character.digit(hex.charAt(i + 1), 16));\n+        }\n+        return data;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/TestHKDF.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @run main TestHKDFInitialization\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+public class TestHKDFInitialization {\n+    public static void main(String[] args)\n+        throws NoSuchAlgorithmException, InvalidParameterSpecException,\n+               InvalidAlgorithmParameterException {\n+\n+        byte[] ikm = new BigInteger(\n+            \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+            16).toByteArray();\n+        byte[] salt = new BigInteger(\"000102030405060708090a0b0c\",\n+                                     16).toByteArray();\n+        byte[] info = new BigInteger(\"f0f1f2f3f4f5f6f7f8f9\", 16).toByteArray();\n+\n+        KDFParameterSpec kdfParameterSpec = HKDFParameterSpec.extractExpand(\n+            HKDFParameterSpec.extract().addIKM(ikm).addSalt(salt).extractOnly(),\n+            info, 42);\n+\n+        \/\/ OR THIS WAY NOW\n+        \/*KDFParameterSpec kdfParameterSpec2 =\n+            HKDFParameterSpec.extract()\n+                             .addIKM(ikm)\n+                             .addSalt(salt).andExpand(info, 42);*\/\n+\n+        KDF kdfHkdf = KDF.getInstance(\"HKDFWithHmacSHA256\",\n+                                      (AlgorithmParameterSpec) null);\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/TestHKDFInitialization.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @run main Delayed\n+ * @summary delayed provider selection\n+ * @enablePreview\n+ *\/\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Objects;\n+\n+public class Delayed {\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new Provider1());\n+        Security.addProvider(new Provider2());\n+        Security.addProvider(new Provider3());\n+        KDF kdf;\n+\n+        kdf = KDF.getInstance(\"X\", NamedParameterSpec.X448);\n+        kdf.deriveData(new KDFParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P1\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new KDFParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P2\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(null);\n+        Asserts.assertEquals(kdf.getProviderName(), \"P3\");\n+    }\n+    public static class Provider1 extends Provider {\n+        public Provider1() {\n+            super(\"P1\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF1.class.getName());\n+        }\n+    }\n+    public static class KDF1 extends KDF0 {\n+        public KDF1(AlgorithmParameterSpec e) throws InvalidAlgorithmParameterException {\n+            super(Objects.requireNonNull(e));\n+        }\n+    }\n+    public static class Provider2 extends Provider {\n+        public Provider2() {\n+            super(\"P2\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF2.class.getName());\n+        }\n+    }\n+    public static class KDF2 extends KDF0 {\n+        public KDF2(AlgorithmParameterSpec e) throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+        @Override\n+        protected byte[] engineDeriveData(KDFParameterSpec kdfParameterSpec) throws InvalidParameterSpecException {\n+            Objects.requireNonNull(kdfParameterSpec);\n+            return null;\n+        }\n+    }\n+    public static class Provider3 extends Provider {\n+        public Provider3() {\n+            super(\"P3\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF3.class.getName());\n+        }\n+    }\n+    public static class KDF3 extends KDF0 {\n+        public KDF3(AlgorithmParameterSpec e) throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+    }\n+\n+    public abstract static class KDF0 extends KDFSpi {\n+        public KDF0(AlgorithmParameterSpec a) throws InvalidAlgorithmParameterException {\n+            super(a);\n+        }\n+        protected SecretKey engineDeriveKey(String alg, KDFParameterSpec kdfParameterSpec) throws InvalidParameterSpecException {\n+            return null;\n+        }\n+        protected byte[] engineDeriveData(KDFParameterSpec kdfParameterSpec) throws InvalidParameterSpecException {\n+            return new byte[0];\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/Delayed.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary basic HKDF operations\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+public class Functions {\n+    public static void main(String[] args) throws Exception {\n+        var ikm = HexFormat.of().parseHex(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\");\n+        var salt = HexFormat.of().parseHex(\"000102030405060708090a0b0c\");\n+        var info = HexFormat.of().parseHex(\"f0f1f2f3f4f5f6f7f8f9\");\n+        var len = 42;\n+\n+        var kdf = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+        var expectedPrk = HexFormat.of().parseHex(\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\");\n+        var expectedOkm = HexFormat.of().parseHex(\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865\");\n+\n+        var extractOnly = HKDFParameterSpec.extract().addIKM(ikm).addSalt(salt).extractOnly();\n+        var prk = kdf.deriveKey(\"PRK\", extractOnly);\n+        var expandOnly = HKDFParameterSpec.expand(prk, info, len);\n+        var okm1 = kdf.deriveKey(\"OKM\", expandOnly);\n+        var extractAndExpand = HKDFParameterSpec.extract().addIKM(ikm).addSalt(salt).andExpand(info, len);\n+        var okm2 = kdf.deriveKey(\"OKM\", extractAndExpand);\n+\n+        if (!Arrays.equals(prk.getEncoded(), expectedPrk)) {\n+            throw new Exception();\n+        }\n+        if (!Arrays.equals(okm1.getEncoded(), expectedOkm)) {\n+            throw new Exception();\n+        }\n+        if (!Arrays.equals(okm2.getEncoded(), expectedOkm)) {\n+            throw new Exception();\n+        }\n+\n+\/\/        test(HKDFParameterSpec.extract().extractOnly());\n+\/\/        test(HKDFParameterSpec.extract().andExpand(new byte[0], 32));\n+        test(HKDFParameterSpec.extract().addIKM(ikm).addSalt(new byte[0]).extractOnly());\n+    }\n+\n+    static void test(HKDFParameterSpec p) throws Exception {\n+        var kdf = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+        System.out.println(HexFormat.of().formatHex(kdf.deriveData(p)));\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/Functions.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib\n+ * @run testng Threading\n+ * @summary multi-threading test for KDF\n+ * @enablePreview\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.KDFParameterSpec;\n+import java.math.BigInteger;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.HexFormat;\n+\n+public class Threading {\n+    KDF kdfUnderTest;\n+    byte[] ikm = new BigInteger(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                                16).toByteArray();\n+    byte[] salt = new BigInteger(\"000102030405060708090a0b0c\",\n+                                 16).toByteArray();\n+    byte[] info = new BigInteger(\"f0f1f2f3f4f5f6f7f8f9\", 16).toByteArray();\n+    KDFParameterSpec kdfParameterSpec = HKDFParameterSpec.extractExpand(\n+        HKDFParameterSpec.extract().addIKM(ikm).addSalt(salt).extractOnly(),\n+        info, 42);\n+    String expectedResult =\n+        \"666b33562ebc5e2f041774192e0534efca06f82a5fca17ec8c6ae1b9f5466adba1d77d06480567ddd2d1\";\n+\n+    @BeforeClass\n+    public void setUp() throws NoSuchAlgorithmException {\n+        kdfUnderTest = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+    }\n+\n+    @Test(threadPoolSize = 50, invocationCount = 10000, timeOut = 10)\n+    public void testDeriveKey() throws InvalidParameterSpecException {\n+        SecretKey result = kdfUnderTest.deriveKey(\"AES\", kdfParameterSpec);\n+        assert (HexFormat.of().formatHex(result.getEncoded()).equals(\n+            expectedResult));\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/Threading.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"","filename":"test\/jdk\/security\/unsignedjce\/java.base\/javax\/crypto\/ProviderVerifier.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/classes\/javax\/crypto\/ProviderVerifier.java","status":"copied"}]}