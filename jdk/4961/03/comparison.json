{"files":[{"patch":"@@ -118,1 +118,1 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n@@ -126,9 +126,9 @@\n-        int n = (attributes == null) ? 0 : attributes.length;\n-        for (int i = 0; i < n; i++) {\n-            CK_ATTRIBUTE attr = attributes[i];\n-            if (attr.type == CKA_TOKEN) {\n-                tokenObject = attr.getBoolean();\n-            } else if (attr.type == CKA_SENSITIVE) {\n-                sensitive = attr.getBoolean();\n-            } else if (attr.type == CKA_EXTRACTABLE) {\n-                extractable = attr.getBoolean();\n+        if (attrs != null) {\n+            for (CK_ATTRIBUTE attr : attrs) {\n+                if (attr.type == CKA_TOKEN) {\n+                    tokenObject = attr.getBoolean();\n+                } else if (attr.type == CKA_SENSITIVE) {\n+                    sensitive = attr.getBoolean();\n+                } else if (attr.type == CKA_EXTRACTABLE) {\n+                    extractable = attr.getBoolean();\n+                }\n@@ -250,1 +250,1 @@\n-                + \" key, \" + keyLength + \" bits\";\n+                + \" key, \" + keyLength + \" bits \";\n@@ -281,1 +281,2 @@\n-    void fetchAttributes(CK_ATTRIBUTE[] attributes) {\n+    CK_ATTRIBUTE[] fetchAttributes(CK_ATTRIBUTE[] attrs) {\n+        Objects.requireNonNull(attrs, \"attrs must be non-null\");\n@@ -287,1 +288,1 @@\n-                        attributes);\n+                    attrs);\n@@ -294,0 +295,11 @@\n+        return attrs;\n+    }\n+\n+    \/\/ convenience method which returns the attribute values as BigInteger[]\n+    BigInteger[] fetchAttributesAsInts(CK_ATTRIBUTE[] attrs) {\n+        attrs = fetchAttributes(attrs);\n+        BigInteger[] res = new BigInteger[attrs.length];\n+        for (int i = 0; i < attrs.length; i++) {\n+            res[i] = attrs[i].getBigInteger();\n+        }\n+        return res;\n@@ -332,5 +344,5 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n-        attributes = getAttributes(session, keyID, attributes, new CK_ATTRIBUTE[] {\n-            new CK_ATTRIBUTE(CKA_TOKEN),\n-            new CK_ATTRIBUTE(CKA_SENSITIVE),\n-            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_TOKEN),\n+                    new CK_ATTRIBUTE(CKA_SENSITIVE),\n+                    new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n@@ -338,2 +350,1 @@\n-        return new P11SecretKey(session, keyID, algorithm, keyLength,\n-                attributes);\n+        return new P11SecretKey(session, keyID, algorithm, keyLength, attrs);\n@@ -342,6 +353,7 @@\n-    static SecretKey masterSecretKey(Session session, long keyID, String algorithm,\n-            int keyLength, CK_ATTRIBUTE[] attributes, int major, int minor) {\n-        attributes = getAttributes(session, keyID, attributes, new CK_ATTRIBUTE[] {\n-            new CK_ATTRIBUTE(CKA_TOKEN),\n-            new CK_ATTRIBUTE(CKA_SENSITIVE),\n-            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+    static SecretKey masterSecretKey(Session session, long keyID,\n+            String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+            int major, int minor) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_TOKEN),\n+                    new CK_ATTRIBUTE(CKA_SENSITIVE),\n+                    new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n@@ -349,3 +361,2 @@\n-        return new P11TlsMasterSecretKey(\n-                session, keyID, algorithm, keyLength, attributes, major,\n-                minor);\n+        return new P11TlsMasterSecretKey(session, keyID, algorithm, keyLength,\n+                attrs, major, minor);\n@@ -356,1 +367,1 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n@@ -360,1 +371,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -363,1 +374,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -366,1 +377,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -369,1 +380,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -377,5 +388,5 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n-        attributes = getAttributes(session, keyID, attributes, new CK_ATTRIBUTE[] {\n-            new CK_ATTRIBUTE(CKA_TOKEN),\n-            new CK_ATTRIBUTE(CKA_SENSITIVE),\n-            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_TOKEN),\n+                    new CK_ATTRIBUTE(CKA_SENSITIVE),\n+                    new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n@@ -383,50 +394,20 @@\n-        if (attributes[1].getBoolean() || (attributes[2].getBoolean() == false)) {\n-            return new P11PrivateKey\n-                (session, keyID, algorithm, keyLength, attributes);\n-        } else {\n-            switch (algorithm) {\n-                case \"RSA\":\n-                    \/\/ In order to decide if this is RSA CRT key, we first query\n-                    \/\/ and see if all extra CRT attributes are available.\n-                    CK_ATTRIBUTE[] attrs2 = new CK_ATTRIBUTE[] {\n-                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                        new CK_ATTRIBUTE(CKA_PRIME_1),\n-                        new CK_ATTRIBUTE(CKA_PRIME_2),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-                    };\n-                    boolean crtKey;\n-                    try {\n-                        session.token.p11.C_GetAttributeValue\n-                            (session.id(), keyID, attrs2);\n-                        crtKey = ((attrs2[0].pValue instanceof byte[]) &&\n-                                  (attrs2[1].pValue instanceof byte[]) &&\n-                                  (attrs2[2].pValue instanceof byte[]) &&\n-                                  (attrs2[3].pValue instanceof byte[]) &&\n-                                  (attrs2[4].pValue instanceof byte[]) &&\n-                                  (attrs2[5].pValue instanceof byte[])) ;\n-                    } catch (PKCS11Exception e) {\n-                        \/\/ ignore, assume not available\n-                        crtKey = false;\n-                    }\n-                    if (crtKey) {\n-                        return new P11RSAPrivateKey(session, keyID, algorithm,\n-                                keyLength, attributes, attrs2);\n-                    } else {\n-                        return new P11RSAPrivateNonCRTKey(session, keyID,\n-                                algorithm, keyLength, attributes);\n-                    }\n-                case \"DSA\":\n-                    return new P11DSAPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"DH\":\n-                    return new P11DHPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"EC\":\n-                    return new P11ECPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                default:\n-                    throw new ProviderException\n-                            (\"Unknown private key algorithm \" + algorithm);\n-            }\n+\n+        boolean keySensitive = (attrs[0].getBoolean() ||\n+                attrs[1].getBoolean() || !attrs[2].getBoolean());\n+\n+        switch (algorithm) {\n+        case \"RSA\":\n+            return P11RSAPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        case \"DSA\":\n+            return P11DSAPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        case \"DH\":\n+            return P11DHPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        case \"EC\":\n+            return P11ECPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        default:\n+            throw new ProviderException\n+                    (\"Unknown private key algorithm \" + algorithm);\n@@ -436,3 +417,3 @@\n-    \/\/ class for sensitive and unextractable private keys\n-    private static final class P11PrivateKey extends P11Key\n-                                                implements PrivateKey {\n+    \/\/ base class for all PKCS11 private keys\n+    private static abstract class P11PrivateKey extends P11Key implements\n+            PrivateKey {\n@@ -441,0 +422,2 @@\n+        protected byte[] encoded; \/\/ guard by synchronized\n+\n@@ -442,2 +425,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(PRIVATE, session, keyID, algorithm, keyLength, attrs);\n@@ -458,1 +441,3 @@\n-        private volatile byte[] encoded;\n+\n+        private volatile byte[] encoded; \/\/ guard by double-checked locking\n+\n@@ -460,2 +445,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(SECRET, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(SECRET, session, keyID, algorithm, keyLength, attrs);\n@@ -463,0 +448,1 @@\n+\n@@ -471,0 +457,1 @@\n+\n@@ -476,0 +463,1 @@\n+\n@@ -481,5 +469,1 @@\n-                        Session tempSession = null;\n-                        long keyID = this.getKeyID();\n-                        try {\n-                            tempSession = token.getOpSession();\n-                            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+                        b = fetchAttributes(new CK_ATTRIBUTE[] {\n@@ -487,10 +471,1 @@\n-                            };\n-                            token.p11.C_GetAttributeValue\n-                                    (tempSession.id(), keyID, attributes);\n-                            b = attributes[0].getByteArray();\n-                        } catch (PKCS11Exception e) {\n-                            throw new ProviderException(e);\n-                        } finally {\n-                            this.releaseKeyID();\n-                            token.releaseSession(tempSession);\n-                        }\n+                        })[0].getByteArray();\n@@ -505,0 +480,13 @@\n+    \/\/ base class for all PKCS11 public keys\n+    private static abstract class P11PublicKey extends P11Key implements\n+            PublicKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected byte[] encoded; \/\/ guard by synchronized\n+\n+        P11PublicKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(PUBLIC, session, keyID, algorithm, keyLength, attrs);\n+        }\n+    }\n+\n@@ -512,2 +500,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes, int major, int minor) {\n-            super(session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs, int major, int minor) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -526,0 +514,72 @@\n+    \/\/ impl class for sensitive\/unextractable RSA private keys\n+    static class P11RSAPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = -2138581185214187615L;\n+\n+        static P11RSAPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11RSAPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                CK_ATTRIBUTE[] rsaAttrs = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_MODULUS),\n+                        new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                        new CK_ATTRIBUTE(CKA_PRIME_1),\n+                        new CK_ATTRIBUTE(CKA_PRIME_2),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n+                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n+                };\n+                boolean isCRT = true;\n+                Session tempSession = null;\n+                try {\n+                    tempSession = session.token.getOpSession();\n+                    session.token.p11.C_GetAttributeValue(tempSession.id(),\n+                            keyID, rsaAttrs);\n+                    for (CK_ATTRIBUTE attr : rsaAttrs) {\n+                        isCRT &= (attr.pValue instanceof byte[]);\n+                        if (!isCRT) break;\n+                    }\n+                } catch (PKCS11Exception e) {\n+                    \/\/ ignore, assume not available\n+                    isCRT = false;\n+                } finally {\n+                    session.token.releaseSession(tempSession);\n+                }\n+                BigInteger n = rsaAttrs[0].getBigInteger();\n+                BigInteger d = rsaAttrs[1].getBigInteger();\n+                if (isCRT) {\n+                    return new P11RSAPrivateKey(session, keyID, algorithm,\n+                           keyLength, attrs, n, d,\n+                           Arrays.copyOfRange(rsaAttrs, 2, rsaAttrs.length));\n+                } else {\n+                    return new P11RSAPrivateNonCRTKey(session, keyID,\n+                           algorithm, keyLength, attrs, n, d);\n+                }\n+            }\n+        }\n+\n+        protected transient BigInteger n;\n+\n+        private P11RSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (n != null) return;\n+\n+            n = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_MODULUS)\n+            })[0];\n+        }\n+\n+        public BigInteger getModulus() {\n+            fetchValues();\n+            return n;\n+        }\n+    }\n+\n@@ -527,2 +587,2 @@\n-    private static final class P11RSAPrivateKey extends P11Key\n-                implements RSAPrivateCrtKey {\n+    private static final class P11RSAPrivateKey extends P11RSAPrivateKeyInternal\n+            implements RSAPrivateCrtKey {\n@@ -531,5 +591,6 @@\n-        private BigInteger n, e, d, p, q, pe, qe, coeff;\n-        private byte[] encoded;\n-        P11RSAPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attrs, CK_ATTRIBUTE[] crtAttrs) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attrs);\n+        private transient BigInteger e, d, p, q, pe, qe, coeff;\n+\n+        private P11RSAPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attrs, BigInteger n, BigInteger d,\n+                CK_ATTRIBUTE[] crtAttrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -537,0 +598,2 @@\n+            this.n = n;\n+            this.d = d;\n@@ -553,13 +616,0 @@\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n-        }\n@@ -571,0 +621,1 @@\n+\n@@ -574,1 +625,0 @@\n-                fetchValues();\n@@ -585,0 +635,2 @@\n+\n+        @Override\n@@ -586,1 +638,0 @@\n-            fetchValues();\n@@ -593,1 +644,0 @@\n-            fetchValues();\n@@ -614,2 +664,2 @@\n-    private static final class P11RSAPrivateNonCRTKey extends P11Key\n-                implements RSAPrivateKey {\n+    private static final class P11RSAPrivateNonCRTKey extends\n+            P11RSAPrivateKeyInternal implements RSAPrivateKey {\n@@ -618,2 +668,2 @@\n-        private BigInteger n, d;\n-        private byte[] encoded;\n+        private transient BigInteger d;\n+\n@@ -621,15 +671,5 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n+                int keyLength, CK_ATTRIBUTE[] attrs, BigInteger n,\n+                BigInteger d) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+            this.n = n;\n+            this.d = d;\n@@ -637,0 +677,1 @@\n+\n@@ -641,0 +682,1 @@\n+\n@@ -644,1 +686,0 @@\n-                fetchValues();\n@@ -658,0 +699,2 @@\n+\n+        @Override\n@@ -659,1 +702,0 @@\n-            fetchValues();\n@@ -663,1 +705,0 @@\n-            fetchValues();\n@@ -668,1 +709,1 @@\n-    private static final class P11RSAPublicKey extends P11Key\n+    private static final class P11RSAPublicKey extends P11PublicKey\n@@ -671,2 +712,2 @@\n-        private BigInteger n, e;\n-        private byte[] encoded;\n+        private transient BigInteger n, e;\n+\n@@ -674,2 +715,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -677,0 +718,1 @@\n+\n@@ -679,4 +721,3 @@\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (n != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n@@ -684,5 +725,4 @@\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            e = attributes[1].getBigInteger();\n+                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT)\n+            });\n+            n = res[0];\n+            e = res[1];\n@@ -690,0 +730,1 @@\n+\n@@ -694,0 +735,1 @@\n+\n@@ -707,0 +749,1 @@\n+\n@@ -722,1 +765,1 @@\n-    private static final class P11DSAPublicKey extends P11Key\n+    private static final class P11DSAPublicKey extends P11PublicKey\n@@ -726,4 +769,3 @@\n-        private BigInteger y;\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private DSAParams params;\n-        private byte[] encoded;\n+        private transient BigInteger y;\n+        private transient DSAParams params;\n+\n@@ -731,2 +773,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -734,0 +776,1 @@\n+\n@@ -736,4 +779,3 @@\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (y != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n@@ -743,9 +785,4 @@\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+                new CK_ATTRIBUTE(CKA_BASE)\n+            });\n+            y = res[0];\n+            params = new DSAParameterSpec(res[1], res[2], res[3]);\n@@ -753,0 +790,1 @@\n+\n@@ -757,0 +795,1 @@\n+\n@@ -786,2 +825,1 @@\n-    private static final class P11DSAPrivateKey extends P11Key\n-                                                implements DSAPrivateKey {\n+    static class P11DSAPrivateKeyInternal extends P11PrivateKey {\n@@ -790,4 +828,43 @@\n-        private BigInteger x;\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private DSAParams params;\n-        private byte[] encoded;\n+        protected transient DSAParams params;\n+\n+        static P11DSAPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DSAPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                return new P11DSAPrivateKey(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            }\n+        }\n+\n+        private P11DSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (params != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            params = new DSAParameterSpec(res[0], res[1], res[2]);\n+        }\n+\n+        protected DSAParams getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    private static final class P11DSAPrivateKey extends P11DSAPrivateKeyInternal\n+                                        implements DSAPrivateKey {\n+        private static final long serialVersionUID = 3119629997181999389L;\n+\n+        private transient BigInteger x; \/\/ params inside P11DSAPrivateKeyInternal\n+\n@@ -795,2 +872,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -798,0 +875,1 @@\n+\n@@ -800,16 +878,10 @@\n-            if (x != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            x = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+            if (x != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            x = res[0];\n+            params = new DSAParameterSpec(res[1], res[2], res[3]);\n@@ -817,0 +889,1 @@\n+\n@@ -821,0 +894,1 @@\n+\n@@ -831,0 +905,1 @@\n+\n@@ -835,0 +910,2 @@\n+\n+        @Override\n@@ -841,1 +918,40 @@\n-    private static final class P11DHPrivateKey extends P11Key\n+    static class P11DHPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected transient DHParameterSpec params;\n+\n+        static P11DHPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DHPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                return new P11DHPrivateKey(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            }\n+        }\n+\n+        private P11DHPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (params != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            params = new DHParameterSpec(res[0], res[1]);\n+        }\n+\n+        public DHParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    private static final class P11DHPrivateKey extends P11DHPrivateKeyInternal\n@@ -845,4 +961,2 @@\n-        private BigInteger x;\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private DHParameterSpec params;\n-        private byte[] encoded;\n+        private transient BigInteger x; \/\/ params in P11DHPrivateKeyInternal\n+\n@@ -850,2 +964,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -853,0 +967,1 @@\n+\n@@ -855,14 +970,9 @@\n-            if (x != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            x = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            if (x != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            x = res[0];\n+            params = new DHParameterSpec(res[1], res[2]);\n@@ -870,0 +980,1 @@\n+\n@@ -874,0 +985,1 @@\n+\n@@ -900,0 +1012,1 @@\n+            fetchValues();\n@@ -903,1 +1016,0 @@\n-            fetchValues();\n@@ -924,1 +1036,1 @@\n-    private static final class P11DHPublicKey extends P11Key\n+    private static final class P11DHPublicKey extends P11PublicKey\n@@ -928,4 +1040,3 @@\n-        private BigInteger y;\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private DHParameterSpec params;\n-        private byte[] encoded;\n+        private transient BigInteger y;\n+        private transient DHParameterSpec params;\n+\n@@ -933,2 +1044,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -936,0 +1047,1 @@\n+\n@@ -938,14 +1050,9 @@\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            if (y != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            y = res[0];\n+            params = new DHParameterSpec(res[1], res[2]);\n@@ -953,0 +1060,1 @@\n+\n@@ -957,0 +1065,1 @@\n+\n@@ -1012,1 +1121,45 @@\n-    private static final class P11ECPrivateKey extends P11Key\n+    static class P11ECPrivateKeyInternal extends P11PrivateKey {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        protected transient ECParameterSpec params;\n+\n+        static P11ECPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11ECPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                return new P11ECPrivateKey(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            }\n+        }\n+\n+        private P11ECPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (params != null) return;\n+\n+            try {\n+                byte[] paramBytes = fetchAttributes(new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS)\n+                })[0].getByteArray();\n+\n+                params = P11ECKeyFactory.decodeParameters(paramBytes);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not parse key values\", e);\n+            }\n+        }\n+\n+        protected ECParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    private static final class P11ECPrivateKey extends P11ECPrivateKeyInternal\n@@ -1016,4 +1169,2 @@\n-        private BigInteger s;\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private ECParameterSpec params;\n-        private byte[] encoded;\n+        private transient BigInteger s; \/\/ params in P11ECPrivateKeyInternal\n+\n@@ -1021,2 +1172,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -1024,0 +1175,1 @@\n+\n@@ -1026,4 +1178,3 @@\n-            if (s != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (s != null) return;\n+\n+            CK_ATTRIBUTE[] attrs = fetchAttributes(new CK_ATTRIBUTE[] {\n@@ -1031,4 +1182,4 @@\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n-            };\n-            fetchAttributes(attributes);\n-            s = attributes[0].getBigInteger();\n+                new CK_ATTRIBUTE(CKA_EC_PARAMS),\n+            });\n+\n+            s = attrs[0].getBigInteger();\n@@ -1037,1 +1188,1 @@\n-                            (attributes[1].getByteArray());\n+                            (attrs[1].getByteArray());\n@@ -1042,0 +1193,1 @@\n+\n@@ -1046,0 +1198,1 @@\n+\n@@ -1047,1 +1200,0 @@\n-            token.ensureValid();\n@@ -1049,1 +1201,0 @@\n-                fetchValues();\n@@ -1051,0 +1202,1 @@\n+                    fetchValues();\n@@ -1059,0 +1211,1 @@\n+\n@@ -1063,0 +1216,1 @@\n+\n@@ -1069,1 +1223,1 @@\n-    private static final class P11ECPublicKey extends P11Key\n+    private static final class P11ECPublicKey extends P11PublicKey\n@@ -1073,5 +1227,3 @@\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private ECPoint w;\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        private ECParameterSpec params;\n-        private byte[] encoded;\n+        private transient ECPoint w;\n+        private transient ECParameterSpec params;\n+\n@@ -1079,2 +1231,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -1082,0 +1234,1 @@\n+\n@@ -1084,4 +1237,3 @@\n-            if (w != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (w != null) return;\n+\n+            CK_ATTRIBUTE[] attrs = fetchAttributes(new CK_ATTRIBUTE[] {\n@@ -1090,2 +1242,1 @@\n-            };\n-            fetchAttributes(attributes);\n+            });\n@@ -1095,2 +1246,2 @@\n-                            (attributes[1].getByteArray());\n-                byte[] ecKey = attributes[0].getByteArray();\n+                            (attrs[1].getByteArray());\n+                byte[] ecKey = attrs[0].getByteArray();\n@@ -1118,0 +1269,1 @@\n+\n@@ -1122,0 +1274,1 @@\n+\n@@ -1420,0 +1573,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":448,"deletions":294,"binary":false,"changes":742,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+    \/\/ signature length expected or 0 for unknown\n+    private int sigLen;\n+\n@@ -288,1 +291,1 @@\n-                    token.p11.C_SignFinal(session.id(), 0);\n+                    token.p11.C_SignFinal(session.id(), sigLen);\n@@ -299,6 +302,1 @@\n-                byte[] signature;\n-                if (mechanism == CKM_DSA) {\n-                    signature = new byte[64]; \/\/ assume N = 256\n-                } else {\n-                    signature = new byte[(p11Key.length() + 7) >> 3];\n-                }\n+                byte[] signature = new byte[sigLen];\n@@ -375,0 +373,9 @@\n+        sigLen = 0;\n+        if (\"DSA\".equals(p11Key.getAlgorithm())) {\n+            if (p11Key instanceof P11Key.P11DSAPrivateKeyInternal) {\n+                sigLen = ((P11Key.P11DSAPrivateKeyInternal)p11Key).getParams()\n+                        .getQ().bitLength() >> 2;\n+            } else if (p11Key instanceof DSAKey) {\n+                sigLen = ((DSAKey)p11Key).getParams().getQ().bitLength() >> 2;\n+            }\n+        }\n@@ -620,1 +627,1 @@\n-                signature = token.p11.C_SignFinal(session.id(), 0);\n+                signature = token.p11.C_SignFinal(session.id(), sigLen);\n@@ -687,1 +694,1 @@\n-                    signature = asn1ToDSA(signature);\n+                    signature = asn1ToDSA(signature, sigLen);\n@@ -804,1 +811,2 @@\n-    private static byte[] asn1ToDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToDSA(byte[] sig, int sigLen)\n+            throws SignatureException {\n@@ -819,2 +827,2 @@\n-            byte[] br = toByteArray(r, 20);\n-            byte[] bs = toByteArray(s, 20);\n+            byte[] br = toByteArray(r, sigLen\/2);\n+            byte[] bs = toByteArray(s, sigLen\/2);\n@@ -832,1 +840,1 @@\n-    private byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n@@ -912,0 +920,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.security.AlgorithmParameterGenerator;\n+import java.security.AlgorithmParameters;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.Signature;\n+import java.security.spec.DSAGenParameterSpec;\n+import java.security.spec.DSAParameterSpec;\n+\n+\/*\n+ * @test\n+ * @bug 8271566\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm\/timeout=30 LargeDSAKey\n+ *\/\n+\n+public final class LargeDSAKey extends PKCS11Test {\n+\n+    private static final boolean enableDebug = false;\n+\n+    private static final String knownText =\n+            \"Known text known text known text\";\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\", p);\n+        AlgorithmParameterGenerator dsaParGen =\n+                AlgorithmParameterGenerator.getInstance(\"DSA\");\n+        DSAGenParameterSpec dsaParGenSpec =\n+                new DSAGenParameterSpec(2048, 256);\n+        dsaParGen.init(dsaParGenSpec, new SecureRandom());\n+        AlgorithmParameters params = dsaParGen.generateParameters();\n+        DSAParameterSpec dsaParams =\n+                params.getParameterSpec(DSAParameterSpec.class);\n+        kpg.initialize(dsaParams);\n+        KeyPair kp = kpg.generateKeyPair();\n+        doTestSignature(kp, p);\n+    }\n+\n+    private static void doTestSignature(KeyPair kp, Provider p)\n+            throws Exception {\n+        byte[] knownTextSig = null;\n+        Signature s = Signature.getInstance(\"SHA1withDSA\", p);\n+        PrivateKey privKey = kp.getPrivate();\n+        PublicKey pubKey = kp.getPublic();\n+        if (enableDebug) {\n+            System.out.println(\"Signature algorithm: \" + s.getAlgorithm());\n+            System.out.println(\"Signature Provider: \" + s.getProvider());\n+            System.out.println(\"Private key for signature: \" + privKey);\n+            System.out.println(\"Public key for signature: \" + pubKey);\n+        }\n+        s.initSign(privKey);\n+        s.update(knownText.getBytes());\n+        knownTextSig = s.sign();\n+        s.initVerify(pubKey);\n+        s.update(knownText.getBytes());\n+        if (s.verify(knownTextSig) == false) {\n+            throw new Exception(\"Could not verify signature\");\n+        }\n+        if (enableDebug) {\n+            System.out.println(\"Signature verified\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        main(new LargeDSAKey());\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/LargeDSAKey.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}