{"files":[{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides an any-bits double distribution random generator, i.e. the bits are uniformly sampled,\n+ * thus creating any possible double value, including the multiple different NaN representations.\n+ *\/\n+final class AnyBitsDoubleGenerator extends BoundGenerator<Double> {\n+    \/**\n+     * Create a new {@link AnyBitsDoubleGenerator}.\n+     *\/\n+    public AnyBitsDoubleGenerator(Generators g) {\n+        super(g);\n+    }\n+\n+    @Override\n+    public Double next() {\n+        return Double.longBitsToDouble(g.random.nextLong());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/AnyBitsDoubleGenerator.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides an any-bits float distribution random generator, i.e. the bits are uniformly sampled,\n+ * thus creating any possible float value, including the multiple different NaN representations.\n+ *\/\n+final class AnyBitsFloatGenerator extends BoundGenerator<Float> {\n+\n+    \/**\n+     * Creates a new {@link AnyBitsFloatGenerator}.\n+     *\/\n+    public AnyBitsFloatGenerator(Generators g) {\n+        super(g);\n+    }\n+\n+    @Override\n+    public Float next() {\n+        return Float.intBitsToFloat(g.random.nextInt());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/AnyBitsFloatGenerator.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * This is a common superclass for all generators that maintain a reference to the Generators object that created them.\n+ * This allows internally creating other generators or using the {@link RandomnessSource} provided in\n+ * {@link Generators#random}.\n+ *\/\n+abstract class BoundGenerator<T> implements Generator<T> {\n+    Generators g;\n+\n+    BoundGenerator(Generators g) {\n+        this.g = g;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/BoundGenerator.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * An EmptyGeneratorException is thrown if a generator configuration is requested that would result in an empty\n+ * set of values. For example, bounds such as [1, 0] cause an EmptyGeneratorException. Another example would be\n+ * restricting a uniform integer generator over the range [0, 1] to [10, 11].\n+ *\/\n+public class EmptyGeneratorException extends RuntimeException {\n+    public EmptyGeneratorException() {}\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/EmptyGeneratorException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * A stream of values according to a specific distribution.\n+ *\/\n+public interface Generator<T> {\n+    \/**\n+     * Returns the next value from the stream.\n+     *\/\n+    T next();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generator.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,520 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.*;\n+\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * The generators class provides a set of random generator functions for testing.\n+ * The goal is to cover many special cases, such as NaNs in Floats or values\n+ * close to overflow in ints. They should produce values from specific\n+ * \"interesting\" distributions which might trigger various behaviours in\n+ * optimizations.\n+ * <p>\n+ * Normally, clients get the default Generators instance by referring to the static variable {@link #G}.\n+ * <p>\n+ * Generators offers generators with essential distributions, for example, {@link #uniformInts(int, int)},\n+ * {@link #uniformLongs(long, long)}, {@link #uniformDoubles(double, double)} or {@link #uniformFloats()}. For floating\n+ * points, you may choose to get random bit patterns uniformly at random, rather than the values they represent.\n+ * Generators also offers special generators of interesting values such as {@link #specialInts(int)},\n+ * {@link #specialLongs(int)}, which are values close to the powers of 2, or {@link #SPECIAL_DOUBLES} and\n+ * {@link #SPECIAL_FLOATS}, which are values such as infinity, NaN, zero or the maximum and minimum values.\n+ * <p>\n+ * Many distributions are <i>restrictable<\/i>. For example, if you first create a uniform integer generator over [1, 10],\n+ * you can obtain a new generator by further restricting this range to [1, 5]. This is useful in cases where a function\n+ * should be tested with different distributions. For example, a function <code>h(int, int, int)<\/code> under test might\n+ * be worthwhile to test not only with uniformly sampled integers but might also exhibit interesting behavior if tested\n+ * specifically with powers of two. Suppose further that each argument has a different range of allowed values. We\n+ * can write a test function as below:\n+ *\n+ * <pre><code>\n+ * void test(Generator<Integer> g) {\n+ *     h(g.restricted(1, 10).next(), g.next(), g.restricted(-10, 100).next());\n+ * }\n+ * <\/code><\/pre>\n+ *\n+ * Then <code>test<\/code> can be called with different distributions, for example:\n+ *\n+ * <pre><code>\n+ * test(G.uniformInts());\n+ * test(G.specialInts(0));\n+ * <\/code><\/pre>\n+ * <p>\n+ * If there is a single value that is interesting as an argument to all three parameters, we might even call this\n+ * method with a single generator, ensuring that the single value is within the restriction ranges:\n+ *\n+ * <pre><code>\n+ * test(G.single(1));\n+ * <\/code><\/pre>\n+ *\n+ * <p>\n+ * Furthermore, this class offers utility generators, such as {@link #randomElement(Collection)} or\n+ * {@link #orderedRandomElement(Collection)} for sampling from a list of elements; {@link #single(Object)} for a\n+ * generator that only produces a single value; and {@link #mixed(Generator, Generator, int, int)} which combines\n+ * two generators with the provided weights.\n+ * <p>\n+ * Thus, the generators provided by this class are composable and therefore extensible. This allows to easily\n+ * create random generators even with types and distributions that are not predefined. For example, to create a\n+ * generator that provides true with 60 percent probably and false with 40 percent probably, one can simply write:\n+ * <p>\n+ * <pre><code>G.mixed(G.single(true), G.single(false), 60, 40)<\/code><\/pre>\n+ * <p>\n+ * Generators are also by no means limited to work with numbers. Restrictable generators can work with any type that\n+ * implements {@link Comparable} while generators such as {@link #randomElement(Collection)} and {@link #single(Object)}\n+ * work with any type. Note that there are separate restrictable versions of the last two generators\n+ * (namely, {@link #orderedRandomElement(Collection)} and {@link #single(Comparable)}) that work with comparable types.\n+ * For example, you might restrict a generator choosing strings at random:\n+ * <pre><code>G.orderedRandomElement(List.of(\"Bob\", \"Alice\", \"Carol\")).restricted(\"Al\", \"Bz\")<\/code><\/pre>\n+ * <p>\n+ * For all the generators created by instances of this class, the following rule applies: Integral generators are\n+ * always inclusive of both the lower and upper bound, while floating point generators are always inclusive of the\n+ * lower bound but always exclusive of the upper bound. This also applies to all generators obtained by restricting\n+ * these generators further.\n+ *\/\n+public final class Generators {\n+    \/**\n+     * This is the default Generators instance that should be used by tests normally.\n+     *\/\n+    public static final Generators G = new Generators(new RandomnessSourceAdapter(Utils.getRandomInstance()));\n+\n+    final RandomnessSource random;\n+\n+    public Generators(RandomnessSource random) {\n+        this.random = random;\n+    }\n+\n+    \/**\n+     * Returns a generator that generates integers in the range [lo, hi] (inclusive of both lo and hi).\n+     *\/\n+    public RestrictableGenerator<Integer> uniformInts(int lo, int hi) {\n+        return new UniformIntGenerator(this, lo, hi);\n+    }\n+\n+    \/**\n+     * Returns a generator that generates integers over the entire range of int.\n+     *\/\n+    public RestrictableGenerator<Integer> uniformInts() {\n+        return uniformInts(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    \/**\n+     * Returns a generator that generates longs in the range [lo, hi] (inclusive of both lo and hi).\n+     *\/\n+    public RestrictableGenerator<Long> uniformLongs(long lo, long hi) {\n+        return new UniformLongGenerator(this, lo, hi);\n+    }\n+\n+    \/**\n+     * Returns a generator that generates integers over the entire range of int.\n+     *\/\n+    public RestrictableGenerator<Long> uniformLongs() {\n+        return uniformLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n+    }\n+\n+    \/**\n+     * Generates uniform doubles in the range of [lo, hi) (inclusive of lo, exclusive of hi).\n+     *\/\n+    public RestrictableGenerator<Double> uniformDoubles(double lo, double hi) {\n+        return new UniformDoubleGenerator(this, lo, hi);\n+    }\n+\n+    \/**\n+     * Generates uniform doubles in the range of [0, 1) (inclusive of 0, exclusive of 1).\n+     *\/\n+    public RestrictableGenerator<Double> uniformDoubles() {\n+        return uniformDoubles(0, 1);\n+    }\n+\n+    \/**\n+     * Provides an any-bits double distribution random generator, i.e. the bits are uniformly sampled,\n+     * thus creating any possible double value, including the multiple different NaN representations.\n+     *\/\n+    public Generator<Double> anyBitsDouble() {\n+        return new AnyBitsDoubleGenerator(this);\n+    }\n+\n+    \/**\n+     * Generates uniform doubles in the range of [lo, hi) (inclusive of lo, exclusive of hi).\n+     *\/\n+    public RestrictableGenerator<Float> uniformFloats(float lo, float hi) {\n+        return new UniformFloatGenerator(this, lo, hi);\n+    }\n+\n+    \/**\n+     * Generates uniform floats in the range of [0, 1) (inclusive of 0, exclusive of 1).\n+     *\/\n+    public RestrictableGenerator<Float> uniformFloats() {\n+        return uniformFloats(0, 1);\n+    }\n+\n+    \/**\n+     * Provides an any-bits float distribution random generator, i.e. the bits are uniformly sampled,\n+     * thus creating any possible float value, including the multiple different NaN representations.\n+     *\/\n+    public Generator<Float> anyBitsFloats() {\n+        return new AnyBitsFloatGenerator(this);\n+    }\n+\n+    \/**\n+     * Returns a generator that uniformly randomly samples elements from the provided collection.\n+     * Each element in the collection is treated as a separate, unique value, even if equals might be true.\n+     * The result is an unrestrictable generator. If you want a restrictable generator that selects values from a\n+     * list and are working with Comparable values, use {@link #orderedRandomElement(Collection)}.\n+     *\/\n+    public <T> Generator<T> randomElement(Collection<T> list) {\n+        return new RandomElementGenerator<>(this, list);\n+    }\n+\n+    \/**\n+     * Returns a restrictable generator that uniformly randomly samples elements from the provided collection.\n+     * Duplicate elements are discarded from the collection.\n+     *\/\n+    public <T extends Comparable<T>> RestrictableGenerator<T> orderedRandomElement(Collection<T> list) {\n+        NavigableSet<T> set = list instanceof NavigableSet<T> ? (NavigableSet<T>) list : new TreeSet<>(list);\n+        return new RestrictableRandomElementGenerator<>(this, set);\n+    }\n+\n+    \/**\n+     * Returns a generator that always generate the provided value.\n+     *\/\n+    public <T> Generator<T> single(T value) {\n+        return new SingleValueGenerator<>(value);\n+    }\n+\n+    \/**\n+     * Returns a restrictable generator that always generate the provided value.\n+     *\/\n+    public <T extends Comparable<T>> RestrictableGenerator<T> single(T value) {\n+        return new RestrictableSingleValueGenerator<>(value);\n+    }\n+\n+    \/**\n+     * Returns a new generator that samples its next element from either generator A or B, with assignable weights.\n+     * An overload for restrictable generators exists.\n+     *\/\n+    public <T> Generator<T> mixed(Generator<T> a, Generator<T> b, int weightA, int weightB) {\n+        return new MixedGenerator<>(this, List.of(a, b), List.of(weightA, weightB));\n+    }\n+\n+    \/**\n+     * Returns a new generator that samples its next element randomly from one of the provided generators with\n+     * assignable weights.\n+     * An overload for restrictable generators exists.\n+     *\/\n+    @SafeVarargs\n+    public final <T> Generator<T> mixed(List<Integer> weights, Generator<T>... generators) {\n+        return new MixedGenerator<>(this, Arrays.asList(generators), weights);\n+    }\n+\n+    \/**\n+     * Returns a new restrictable generator that samples its next element from either generator A or B, with assignable weights.\n+     * Restricting this generator restricts each subgenerator. Generators which become empty by the restriction are\n+     * removed from the new mixed generator. Weights stay their original value if a generator is removed. If the mixed\n+     * generator would become empty by applying a restriction {@link EmptyGeneratorException} is thrown.\n+     *\/\n+    public <T extends Comparable<T>> RestrictableGenerator<T> mixed(RestrictableGenerator<T> a, RestrictableGenerator<T> b, int weightA, int weightB) {\n+        return new RestrictableMixedGenerator<>(this, List.of(a, b), List.of(weightA, weightB));\n+    }\n+\n+    \/**\n+     * Returns a new restrictable generator that samples its next element randomly from one of the provided restrictable\n+     * generators with assignable weights.\n+     * See {@link #mixed(RestrictableGenerator, RestrictableGenerator, int, int)} for details about restricting this\n+     * generator.\n+     *\/\n+    @SafeVarargs\n+    public final <T extends Comparable<T>> RestrictableGenerator<T> mixed(List<Integer> weights, RestrictableGenerator<T>... generators) {\n+        return new RestrictableMixedGenerator<>(this, Arrays.asList(generators), weights);\n+    }\n+\n+    \/**\n+     * Randomly pick an int generator.\n+     *\n+     * @return Random int generator.\n+     *\/\n+    public RestrictableGenerator<Integer> ints() {\n+        switch(random.nextInt(0, 6)) {\n+            case 0  -> { return uniformInts(); }\n+            case 1  -> { return specialInts(0); }\n+            case 2  -> { return specialInts(2); }\n+            case 3  -> { return specialInts(16); }\n+            case 4  -> { return mixedWithSpecialInts(1, 1, 16); }\n+            case 5  -> { return mixedWithSpecialInts(1, 2, 2); }\n+            default -> { throw new RuntimeException(\"impossible\"); }\n+        }\n+    }\n+\n+    \/**\n+     * A generator of special ints. Special ints are powers of two or values close to powers of 2, where a value\n+     * is close to a power of two p if it is in the interval [p - range, p + range]. Note that we also consider negative\n+     * values as powers of two.\n+     *\/\n+    public RestrictableGenerator<Integer> specialInts(int range) {\n+        TreeSet<Integer> set = new TreeSet<>();\n+        for (int i = 0; i < 32; i++) {\n+            int pow2 = 1 << i;\n+            for (int j = -range; j <= range; j++) {\n+                set.add(+pow2 + j);\n+                set.add(-pow2 + j);\n+            }\n+        }\n+        return orderedRandomElement(set);\n+    }\n+\n+    public RestrictableGenerator<Integer> mixedWithSpecialInts(int weightA, int weightB, int rangeSpecial) {\n+        return mixed(uniformInts(), specialInts(rangeSpecial), weightA, weightB);\n+    }\n+\n+    \/**\n+     * Randomly pick a long generator.\n+     *\n+     * @return Random long generator.\n+     *\/\n+    public RestrictableGenerator<Long> longs() {\n+        switch(random.nextInt(0, 6)) {\n+            case 0  -> { return uniformLongs(); }\n+            case 1  -> { return specialLongs(0); }\n+            case 2  -> { return specialLongs(2); }\n+            case 3  -> { return specialLongs(16); }\n+            case 4  -> { return mixedWithSpecialLongs(1, 1, 16); }\n+            case 5  -> { return mixedWithSpecialLongs(1, 2, 2); }\n+            default -> { throw new RuntimeException(\"impossible\"); }\n+        }\n+    }\n+\n+    \/**\n+     * A generator of special longs. Special longs are powers of two or values close to powers of 2, where a value\n+     * is close to a power of two p if it is in the interval [p - range, p + range]. Note that we also consider negative\n+     * values as powers of two.\n+     *\/\n+    public RestrictableGenerator<Long> specialLongs(int range) {\n+        TreeSet<Long> set = new TreeSet<>();\n+        for (int i = 0; i < 64; i++) {\n+            long pow2 = 1L << i;\n+            for (int j = -range; j <= range; j++) {\n+                set.add(+pow2 + j);\n+                set.add(-pow2 + j);\n+            }\n+        }\n+        return orderedRandomElement(set);\n+    }\n+\n+    public RestrictableGenerator<Long> mixedWithSpecialLongs(int weightA, int weightB, int rangeSpecial) {\n+        return mixed(uniformLongs(), specialLongs(rangeSpecial), weightA, weightB);\n+    }\n+\n+    \/**\n+     * Randomly pick a float generator.\n+     *\n+     * @return Random float generator.\n+     *\/\n+    public Generator<Float> floats() {\n+        switch(random.nextInt(0, 5)) {\n+            case 0  -> { return uniformFloats(-1, 1); }\n+            \/\/ Well-balanced, so that multiplication reduction never explodes or collapses to zero:\n+            case 1  -> { return uniformFloats(0.999f, 1.001f); }\n+            case 2  -> { return anyBitsFloats(); }\n+            \/\/ A tame distribution, mixed in with the occasional special float value:\n+            case 3  -> { return mixedWithSpecialFloats(uniformFloats(0.999f, 1.001f), 10, 1000); }\n+            \/\/ Generating any bits, but special values are more frequent.\n+            case 4  -> { return mixedWithSpecialFloats(anyBitsFloats(), 100, 200); }\n+            default -> { throw new RuntimeException(\"impossible\"); }\n+        }\n+    }\n+\n+    \/**\n+     * Randomly pick a double generator.\n+     *\n+     * @return Random double generator.\n+     *\/\n+    public Generator<Double> doubles() {\n+        switch(random.nextInt(0, 5)) {\n+            case 0  -> { return uniformDoubles(-1, 1); }\n+            \/\/ Well-balanced, so that multiplication reduction never explodes or collapses to zero:\n+            case 1  -> { return uniformDoubles(0.999f, 1.001f); }\n+            case 2  -> { return anyBitsDouble(); }\n+            \/\/ A tame distribution, mixed in with the occasional special double value:\n+            case 3  -> { return mixedWithSpecialDoubles(uniformDoubles(0.999f, 1.001f), 10, 1000); }\n+            \/\/ Generating any bits, but special values are more frequent.\n+            case 4  -> { return mixedWithSpecialDoubles(anyBitsDouble(), 100, 200); }\n+            default -> { throw new RuntimeException(\"impossible\"); }\n+        }\n+    }\n+\n+    \/*\n+     * Generates interesting double values, which often are corner cases such as, 0, 1, -1, NaN, +\/- Infinity, Min,\n+     * Max.\n+     *\/\n+    public final RestrictableGenerator<Double> SPECIAL_DOUBLES = orderedRandomElement(List.of(\n+        0d,\n+        1d,\n+        -1d,\n+        Double.POSITIVE_INFINITY,\n+        Double.NEGATIVE_INFINITY,\n+        Double.NaN,\n+        Double.MAX_VALUE,\n+        Double.MIN_NORMAL,\n+        Double.MIN_VALUE\n+    ));\n+\n+    \/**\n+     * Returns a mixed generator that mixes the provided background generator and SPECIAL_DOUBLES with the provided\n+     * weights.\n+     *\/\n+    public Generator<Double> mixedWithSpecialDoubles(Generator<Double> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_DOUBLES, weightNormal, weightSpecial);\n+    }\n+\n+    \/**\n+     * Returns a restrictable mixed generator that mixes the provided background generator and SPECIAL_DOUBLES with the provided\n+     * weights.\n+     *\/\n+    public RestrictableGenerator<Double> mixedWithSpecialDoubles(RestrictableGenerator<Double> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_DOUBLES, weightNormal, weightSpecial);\n+    }\n+\n+    \/*\n+     * Generates interesting double values, which often are corner cases such as, 0, 1, -1, NaN, +\/- Infinity, Min,\n+     * Max.\n+     *\/\n+    public final RestrictableGenerator<Float> SPECIAL_FLOATS = orderedRandomElement(List.of(\n+        0f,\n+        1f,\n+        -1f,\n+        Float.POSITIVE_INFINITY,\n+        Float.NEGATIVE_INFINITY,\n+        Float.NaN,\n+        Float.MAX_VALUE,\n+        Float.MIN_NORMAL,\n+        Float.MIN_VALUE\n+    ));\n+\n+    \/**\n+     * Returns a mixed generator that mixes the provided background generator and SPECIAL_FLOATS with the provided\n+     * weights.\n+     *\/\n+    public Generator<Float> mixedWithSpecialFloats(Generator<Float> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_FLOATS, weightNormal, weightSpecial);\n+    }\n+\n+    \/**\n+     * Returns a restrictable mixed generator that mixes the provided background generator and SPECIAL_FLOATS with the provided\n+     * weights.\n+     *\/\n+    public RestrictableGenerator<Float> mixedWithSpecialFloats(RestrictableGenerator<Float> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_FLOATS, weightNormal, weightSpecial);\n+    }\n+\n+    \/**\n+     * Fills the memory segments with doubles obtained by calling next on the generator.\n+     *\n+     * @param generator The generator from which to source the values.\n+     * @param ms Memory segment to be filled with random values.\n+     *\/\n+    public void fillDouble(Generator<Double> generator, MemorySegment ms) {\n+        var layout = ValueLayout.JAVA_DOUBLE_UNALIGNED;\n+        for (long i = 0; i < ms.byteSize() \/ layout.byteSize(); i++) {\n+            ms.setAtIndex(layout, i, generator.next());\n+        }\n+    }\n+\n+    \/**\n+     * Fill the array with doubles using the distribution of nextDouble.\n+     *\n+     * @param a Array to be filled with random values.\n+     *\/\n+    public void fill(Generator<Double> generator, double[] a) {\n+        fillDouble(generator, MemorySegment.ofArray(a));\n+    }\n+\n+    \/**\n+     * Fills the memory segments with floats obtained by calling next on the generator.\n+     *\n+     * @param generator The generator from which to source the values.\n+     * @param ms Memory segment to be filled with random values.\n+     *\/\n+    public void fillFloat(Generator<Float> generator, MemorySegment ms) {\n+        var layout = ValueLayout.JAVA_FLOAT_UNALIGNED;\n+        for (long i = 0; i < ms.byteSize() \/ layout.byteSize(); i++) {\n+            ms.setAtIndex(layout, i, generator.next());\n+        }\n+    }\n+\n+    \/**\n+     * Fill the array with floats using the distribution of nextDouble.\n+     *\n+     * @param a Array to be filled with random values.\n+     *\/\n+    public void fill(Generator<Float> generator, float[] a) {\n+        fillFloat(generator, MemorySegment.ofArray(a));\n+    }\n+\n+    \/**\n+     * Fills the memory segments with ints obtained by calling next on the generator.\n+     *\n+     * @param generator The generator from which to source the values.\n+     * @param ms Memory segment to be filled with random values.\n+     *\/\n+    public void fillInt(Generator<Integer> generator, MemorySegment ms) {\n+        var layout = ValueLayout.JAVA_INT_UNALIGNED;\n+        for (long i = 0; i < ms.byteSize() \/ layout.byteSize(); i++) {\n+            ms.setAtIndex(layout, i, generator.next());\n+        }\n+    }\n+\n+    \/**\n+     * Fill the array with ints using the distribution of nextDouble.\n+     *\n+     * @param a Array to be filled with random values.\n+     *\/\n+    public void fill(Generator<Integer> generator, int[] a) {\n+        fillInt(generator, MemorySegment.ofArray(a));\n+    }\n+\n+    \/**\n+     * Fills the memory segments with longs obtained by calling next on the generator.\n+     *\n+     * @param generator The generator from which to source the values.\n+     * @param ms Memory segment to be filled with random values.\n+     *\/\n+    public void fillLong(Generator<Long> generator, MemorySegment ms) {\n+        var layout = ValueLayout.JAVA_LONG_UNALIGNED;\n+        for (long i = 0; i < ms.byteSize() \/ layout.byteSize(); i++) {\n+            ms.setAtIndex(layout, i, generator.next());\n+        }\n+    }\n+\n+    \/**\n+     * Fill the array with longs using the distribution of nextDouble.\n+     *\n+     * @param a Array to be filled with random values.\n+     *\/\n+    public void fill(Generator<Long> generator, long[] a) {\n+        fillLong(generator, MemorySegment.ofArray(a));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generators.java","additions":520,"deletions":0,"binary":false,"changes":520,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import java.util.List;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+\n+\/**\n+ * Mixed results between different generators with configurable weights.\n+ *\/\n+class MixedGenerator<G extends Generator<T>, T> extends BoundGenerator<T> {\n+    private final TreeMap<Integer, G> generators = new TreeMap<>();\n+    private final int totalWeight;\n+\n+    \/**\n+     * Creates a new {@link MixedGenerator}, which samples from a list of generators at random,\n+     * according to specified weights.\n+     *\/\n+    MixedGenerator(Generators g, List<G> generators, List<Integer> weights) {\n+        super(g);\n+        if (weights.size() != generators.size()) {\n+            throw new IllegalArgumentException(\"weights and generators must have the same size.\");\n+        }\n+        int acc = 0;\n+        for (int i = 0; i < generators.size(); i++) {\n+            acc += weights.get(i);\n+            this.generators.put(acc, generators.get(i));\n+        }\n+        this.totalWeight = acc;\n+    }\n+\n+    \/**\n+     * Creates a new mixed generator by mapping each generator of the old generator to a new value or removing it.\n+     * @param other The generator to copy from.\n+     * @param generatorMapper A function that is called for each subgenerator in the old generator. Either return a\n+     *                        generator that takes the role of the old generator (might be the same) or null to remove\n+     *                        the generator completely. In this case, the weights of the other generators stay the same.\n+     *\/\n+    MixedGenerator(MixedGenerator<G, T> other, Function<G, G> generatorMapper) {\n+        super(other.g);\n+        int acc = 0;\n+        int prevKey = 0;\n+        for (var entry : other.generators.entrySet()) {\n+            var gen = generatorMapper.apply(entry.getValue());\n+            if (gen != null) {\n+                \/\/ entry.getKey() is the sum of all generator weights up to this one.\n+                \/\/ We compute this generator's weight by taking the difference to the previous key\n+                int weight = entry.getKey() - prevKey;\n+                acc += weight;\n+                this.generators.put(acc, gen);\n+            }\n+            prevKey = entry.getKey();\n+        }\n+        if (this.generators.isEmpty()) {\n+            throw new EmptyGeneratorException();\n+        }\n+        this.totalWeight = acc;\n+    }\n+\n+    @Override\n+    public T next() {\n+        int r = g.random.nextInt(0, totalWeight);\n+        return generators.higherEntry(r).getValue().next();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/MixedGenerator.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+class RandomElementGenerator<T> extends BoundGenerator<T> {\n+    private final ArrayList<T> elements;\n+    private final Generator<Integer> generator;\n+\n+    RandomElementGenerator(Generators g, Collection<T> elements) {\n+        super(g);\n+        this.elements = new ArrayList<>(elements);\n+        if (this.elements.isEmpty()) throw new EmptyGeneratorException();\n+        this.generator = g.uniformInts(0, elements.size() - 1);\n+    }\n+\n+    @Override\n+    public final T next() {\n+        return elements.get(generator.next());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RandomElementGenerator.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Defines the underlying randomness source used by the generators. This is essentially a subset of\n+ * {@link java.util.random.RandomGenerator} and the present methods have the same contract.\n+ * This interface greatly benefits testing, as it is much easier to implement than\n+ * {@link java.util.random.RandomGenerator}  and thus makes creating test doubles more convenient.\n+ *\/\n+public interface RandomnessSource {\n+    \/** Samples the next long value uniformly at random. *\/\n+    long nextLong();\n+    \/** Samples the next long value in the half-open interval [lo, hi) uniformly at random. *\/\n+    long nextLong(long lo, long hi);\n+    \/** Samples the next int value uniformly at random. *\/\n+    int nextInt();\n+    \/** Samples the next int value in the half-open interval [lo, hi) uniformly at random. *\/\n+    int nextInt(int lo, int hi);\n+    \/** Samples the next double value in the half-open interval [lo, hi) uniformly at random. *\/\n+    double nextDouble(double lo, double hi);\n+    \/** Samples the next float value in the half-open interval [lo, hi) uniformly at random. *\/\n+    float nextFloat(float lo, float hi);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RandomnessSource.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import java.util.random.RandomGenerator;\n+\n+\/**\n+ * An adapter for using a {@link RandomGenerator} as a {@link RandomnessSource}.\n+ * See RandomnessSource for more information.\n+ *\/\n+public class RandomnessSourceAdapter implements RandomnessSource {\n+    private final RandomGenerator rand;\n+\n+    RandomnessSourceAdapter(RandomGenerator rand) {\n+        this.rand = rand;\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+        return rand.nextLong();\n+    }\n+\n+    @Override\n+    public long nextLong(long lo, long hi) {\n+        return rand.nextLong(lo, hi);\n+    }\n+\n+    @Override\n+    public int nextInt() {\n+        return rand.nextInt();\n+    }\n+\n+    @Override\n+    public int nextInt(int lo, int hi) {\n+        return rand.nextInt(lo, hi);\n+    }\n+\n+    @Override\n+    public double nextDouble(double lo, double hi) {\n+        return rand.nextDouble(lo, hi);\n+    }\n+\n+    @Override\n+    public float nextFloat(float lo, float hi) {\n+        return rand.nextFloat(lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RandomnessSourceAdapter.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * A restrictable generator allows the creation of a new generator by restricting the range of its output values.\n+ * The exact semantics of this restriction depend on the concrete implementation, but it usually means taking the\n+ * intersection of the old range and the newly requested range of values.\n+ *\/\n+public interface RestrictableGenerator<T> extends Generator<T> {\n+    \/**\n+     * Returns a new generator where the range of this generator has been restricted to the range of newLo and newHi.\n+     * Whether newHi is inclusive or exclusive depends on the concrete implementation.\n+     * @throws EmptyGeneratorException if this restriction would result in an empty generator.\n+     *\/\n+    RestrictableGenerator<T> restricted(T newLo, T newHi);\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RestrictableGenerator.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+package compiler.lib.generators;\n+\n+import java.util.List;\n+\n+final class RestrictableMixedGenerator<T extends Comparable<T>> extends MixedGenerator<RestrictableGenerator<T>, T> implements RestrictableGenerator<T> {\n+    RestrictableMixedGenerator(Generators g, List<RestrictableGenerator<T>> generators, List<Integer> weights) {\n+        super(g, generators, weights);\n+    }\n+\n+    RestrictableMixedGenerator(RestrictableMixedGenerator<T> other, T newLo, T newHi) {\n+        super(other, (generator) -> {\n+            try {\n+                return generator.restricted(newLo, newHi);\n+            } catch (EmptyGeneratorException e) {\n+                System.out.println(\"kicking out \" + generator);\n+                return null;\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public RestrictableGenerator<T> restricted(T newLo, T newHi) {\n+        return new RestrictableMixedGenerator<>(this, newLo, newHi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RestrictableMixedGenerator.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+import java.util.NavigableSet;\n+\n+\/**\n+ * Selects values from a pre-defined list.\n+ *\/\n+final class RestrictableRandomElementGenerator<T extends Comparable<T>> extends RandomElementGenerator<T> implements RestrictableGenerator<T> {\n+    \/*\n+     * Pre-generated values we can choose from. Maintained for restriction.\n+     *\/\n+    private final NavigableSet<T> values;\n+\n+    public RestrictableRandomElementGenerator(Generators g, NavigableSet<T> values) {\n+        super(g, values);\n+        if (values.isEmpty()) throw new EmptyGeneratorException();\n+        this.values = values;\n+    }\n+\n+    @Override\n+    public RestrictableGenerator<T> restricted(T newLo, T newHi) {\n+        return new RestrictableRandomElementGenerator<>(g, values.subSet(newLo, true, newHi, true));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RestrictableRandomElementGenerator.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+class RestrictableSingleValueGenerator<T extends Comparable<T>> implements RestrictableGenerator<T> {\n+    private final T value;\n+\n+    RestrictableSingleValueGenerator(T value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public RestrictableGenerator<T> restricted(T newLo, T newHi) {\n+        if (newLo.compareTo(value) <= 0 && value.compareTo(newHi) <= 0) {\n+            return this;\n+        }\n+        throw new EmptyGeneratorException();\n+    }\n+\n+    @Override\n+    public T next() {\n+        return value;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RestrictableSingleValueGenerator.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * A generator which always returns the same value.\n+ *\/\n+class SingleValueGenerator<T> implements Generator<T> {\n+    private final T value;\n+\n+    SingleValueGenerator(T value) {\n+        this.value = value;\n+    }\n+\n+    @Override\n+    public T next() {\n+        return this.value;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/SingleValueGenerator.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides a uniform double distribution random generator, in the provided range [lo, hi).\n+ *\/\n+final class UniformDoubleGenerator extends UniformIntersectionRestrictableGenerator<Double> {\n+    \/**\n+     * Creates a new {@link UniformFloatGenerator}.\n+     *\n+     * @param lo Lower bound of the range (inclusive).\n+     * @param hi Higher bound of the range (exclusive).\n+     *\/\n+    public UniformDoubleGenerator(Generators g, double lo, double hi) {\n+        super(g, lo, hi);\n+    }\n+\n+    @Override\n+    public Double next() {\n+        return g.random.nextDouble(lo(), hi());\n+    }\n+\n+    @Override\n+    protected RestrictableGenerator<Double> doRestrictionFromIntersection(Double lo, Double hi) {\n+        return new UniformDoubleGenerator(g, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformDoubleGenerator.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides a uniform float distribution random generator, in the provided range [lo, hi).\n+ *\/\n+final class UniformFloatGenerator extends UniformIntersectionRestrictableGenerator<Float> {\n+    \/**\n+     * Creates a new {@link UniformFloatGenerator}.\n+     *\n+     * @param lo Lower bound of the range (inclusive).\n+     * @param hi Higher bound of the range (exclusive).\n+     *\/\n+    public UniformFloatGenerator(Generators g, float lo, float hi) {\n+        super(g, lo, hi);\n+    }\n+\n+    @Override\n+    public Float next() {\n+        return g.random.nextFloat(lo(), hi());\n+    }\n+\n+    @Override\n+    protected RestrictableGenerator<Float> doRestrictionFromIntersection(Float lo, Float hi) {\n+        return new UniformFloatGenerator(g, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformFloatGenerator.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides a uniform int distribution random generator.\n+ *\/\n+final class UniformIntGenerator extends UniformIntersectionRestrictableGenerator<Integer> {\n+    public UniformIntGenerator(Generators g, int lo, int hi) {\n+        super(g, lo, hi);\n+    }\n+\n+    @Override\n+    public Integer next() {\n+        if (hi() == Integer.MAX_VALUE) {\n+            if (lo() == Integer.MIN_VALUE) {\n+                return g.random.nextInt();\n+            }\n+            return g.random.nextInt(lo() - 1, hi()) + 1;\n+        }\n+        return g.random.nextInt(lo(), hi() + 1);\n+    }\n+\n+    @Override\n+    protected RestrictableGenerator<Integer> doRestrictionFromIntersection(Integer lo, Integer hi) {\n+        return new UniformIntGenerator(g, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformIntGenerator.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * A generators whose outputs is restricted by taking the intersection of the previous interval and the new interval.\n+ *\/\n+abstract class UniformIntersectionRestrictableGenerator<T extends Comparable<T>> extends BoundGenerator<T> implements RestrictableGenerator<T> {\n+    private final T lo;\n+    private final T hi;\n+\n+    public UniformIntersectionRestrictableGenerator(Generators g, T lo, T hi) {\n+        super(g);\n+        if (lo.compareTo(hi) > 0) throw new EmptyGeneratorException();\n+        this.lo = lo;\n+        this.hi = hi;\n+    }\n+\n+    \/**\n+     * Creates a new generator by further restricting the range of values. The range of values will be the\n+     * intersection of the previous values and the values in the provided range.\n+     * The probability of each element occurring in the new generator stay the same relative to each other.\n+     *\/\n+    @Override\n+    public RestrictableGenerator<T> restricted(T newLo \/*as*\/, T newHi \/*ae*\/) {\n+        if (lo().compareTo(newHi) > 0 || newLo.compareTo(hi()) > 0) throw new EmptyGeneratorException();\n+        return doRestrictionFromIntersection(max(newLo, lo()), min(newHi, hi()));\n+    }\n+\n+    private T max(T a, T b) {\n+        return a.compareTo(b) >= 0 ? a : b;\n+    }\n+\n+    private T min(T a, T b) {\n+        return a.compareTo(b) < 0 ? a : b;\n+    }\n+\n+    \/**\n+     * Your subclass can just override this method which will receive the computed intersection between the old and\n+     * new interval. It is guaranteed that the interval is non-empty.\n+     *\/\n+    protected abstract RestrictableGenerator<T> doRestrictionFromIntersection(T lo, T hi);\n+\n+    T hi() { return hi; }\n+    T lo() { return lo; }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformIntersectionRestrictableGenerator.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.generators;\n+\n+\/**\n+ * Provides a uniform long distribution random generator.\n+ *\/\n+final class UniformLongGenerator extends UniformIntersectionRestrictableGenerator<Long> {\n+    public UniformLongGenerator(Generators g, Long lo, Long hi) {\n+        super(g, lo, hi);\n+    }\n+\n+    @Override\n+    public Long next() {\n+        if (hi() == Long.MAX_VALUE) {\n+            if (lo() == Long.MIN_VALUE) {\n+                return g.random.nextLong();\n+            }\n+            return g.random.nextLong(lo() - 1, hi()) + 1;\n+        }\n+        return g.random.nextLong(lo(), hi() + 1);\n+    }\n+\n+    @Override\n+    protected RestrictableGenerator<Long> doRestrictionFromIntersection(Long lo, Long hi) {\n+        return new UniformLongGenerator(g, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformLongGenerator.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package testlibrary_tests.generators.tests;\n+\n+import compiler.lib.generators.RandomnessSource;\n+\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+\n+\/**\n+ * This class is a mock for RandomnessSource. For each method defined in {@link RandomnessSource}, it maintains\n+ * a queue. For the methods {@link #nextInt()} and {@link #nextLong()} the queue simply contains ints and longs,\n+ * respectively, and they are dequeue and returned when the methods are called. For the bounded methods, each queue\n+ * element is a value associated with the bounds that are expected for the call. If the actual bounds do not match\n+ * the arguments provided, a RuntimeException is raised. This allows verifying that the correct bounds are passed to\n+ * the randomness source.\n+ * Furthermore, if a method is called and its queue is empty, an exception is raised.\n+ * To ensure all expected methods have been called in a test, you should call {@link #checkEmpty()} in-between tests\n+ * to ensure that queues are empty, that is, all expected methods have been called.\n+ *\/\n+class MockRandomnessSource implements RandomnessSource {\n+    private record Bounded<T>(T lo, T hi, T value) {}\n+\n+    private final Queue<Long> unboundedLongQueue = new ArrayDeque<>();\n+    private final Queue<Integer> unboundedIntegerQueue = new ArrayDeque<>();\n+    private final Queue<Bounded<Long>> boundedLongQueue = new ArrayDeque<>();\n+    private final Queue<Bounded<Integer>> boundedIntegerQueue = new ArrayDeque<>();\n+    private final Queue<Bounded<Double>> boundedDoubleQueue = new ArrayDeque<>();\n+    private final Queue<Bounded<Float>> boundedFloatQueue = new ArrayDeque<>();\n+\n+    private <T> T dequeueBounded(Queue<Bounded<T>> queue, T lo, T hi) {\n+        Bounded<T> bounded = queue.remove();\n+        if (!bounded.lo.equals(lo) || !bounded.hi.equals(hi)) {\n+            throw new RuntimeException(\"Expected bounds \" + bounded.lo + \" and \" + bounded.hi + \" but found \" + lo + \" and \" + hi);\n+        }\n+        return bounded.value;\n+    }\n+\n+    private void checkQueueEmpty(Queue<?> queue, String name) {\n+        if (!queue.isEmpty()) throw new RuntimeException(\"Expected empty queue for \" + name + \" but found \" + queue);\n+    }\n+\n+    public MockRandomnessSource enqueueLong(long value) {\n+        unboundedLongQueue.add(value);\n+        return this;\n+    }\n+\n+    public MockRandomnessSource enqueueInteger(int value) {\n+        unboundedIntegerQueue.add(value);\n+        return this;\n+    }\n+\n+    public MockRandomnessSource enqueueLong(long lo, long hi, long value) {\n+        boundedLongQueue.add(new Bounded<>(lo, hi, value));\n+        return this;\n+    }\n+\n+    public MockRandomnessSource enqueueInteger(int lo, int hi, int value) {\n+        boundedIntegerQueue.add(new Bounded<>(lo, hi, value));\n+        return this;\n+    }\n+\n+    public MockRandomnessSource enqueueDouble(double lo, double hi, double value) {\n+        boundedDoubleQueue.add(new Bounded<>(lo, hi, value));\n+        return this;\n+    }\n+\n+    public MockRandomnessSource enqueueFloat(float lo, float hi, float value) {\n+        boundedFloatQueue.add(new Bounded<>(lo, hi, value));\n+        return this;\n+    }\n+\n+    public MockRandomnessSource checkEmpty() {\n+        checkQueueEmpty(unboundedLongQueue, \"unbounded longs\");\n+        checkQueueEmpty(unboundedIntegerQueue, \"unbounded integers\");\n+        checkQueueEmpty(boundedLongQueue, \"bounded longs\");\n+        checkQueueEmpty(boundedIntegerQueue, \"bounded integers\");\n+        checkQueueEmpty(boundedDoubleQueue, \"bounded doubles\");\n+        checkQueueEmpty(boundedFloatQueue, \"bounded floats\");\n+        return this;\n+    }\n+\n+    @Override\n+    public long nextLong() {\n+        return unboundedLongQueue.remove();\n+    }\n+\n+    @Override\n+    public long nextLong(long lo, long hi) {\n+        return dequeueBounded(boundedLongQueue, lo, hi);\n+    }\n+\n+    @Override\n+    public int nextInt() {\n+        return unboundedIntegerQueue.remove();\n+    }\n+\n+    @Override\n+    public int nextInt(int lo, int hi) {\n+        return dequeueBounded(boundedIntegerQueue, lo, hi);\n+    }\n+\n+    @Override\n+    public double nextDouble(double lo, double hi) {\n+        return dequeueBounded(boundedDoubleQueue, lo, hi);\n+    }\n+\n+    @Override\n+    public float nextFloat(float lo, float hi) {\n+        return dequeueBounded(boundedFloatQueue, lo, hi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/MockRandomnessSource.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,504 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test functionality of the Generators library.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @build MockRandomness\n+ * @run driver testlibrary_tests.generators.tests.TestGenerators\n+ *\/\n+\n+package testlibrary_tests.generators.tests;\n+\n+import compiler.lib.generators.EmptyGeneratorException;\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import jdk.test.lib.Asserts;\n+\n+import java.util.*;\n+\n+import static compiler.lib.generators.Generators.G;\n+\n+\n+public class TestGenerators {\n+    \/\/ As it's hard to write tests with real randomness, we mock the randomness source so we can control which \"random\"\n+    \/\/ values are fed to the generators. Thus, a lot of the tests below are white-box tests, that have knowledge about\n+    \/\/ the internals of when randomness is consumed. There are also black-box tests which refer to Generators.G.\n+    \/\/ Please also see MockRandomness to learn more about this class.\n+    static MockRandomnessSource mockSource = new MockRandomnessSource();\n+    static Generators mockGS = new Generators(mockSource);\n+\n+    public static void main(String[] args) {\n+        testEmptyGenerators();\n+        testUniformInts();\n+        testUniformLongs();\n+        testAnyBits();\n+        testUniformFloat();\n+        testUniformDouble();\n+        testSingle();\n+        testMixed();\n+        testRandomElement();\n+        specialInt();\n+        specialLong();\n+        testSpecialFloat();\n+        testSpecialDouble();\n+        testFill();\n+    }\n+\n+    static void testMixed() {\n+        mockSource\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 7)  \/\/ MixedGenerator chooses a generator: single\n+                \/\/ single was chosen but does not consume randomness\n+                .enqueueInteger(0, 10, 5)  \/\/ MixedGenerator chooses a generator: uniform ints\n+                .enqueueInteger(0, 31, 4)  \/\/ uniform ints samples\n+                .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: uniform ints\n+                .enqueueInteger(0, 31, 18); \/\/ uniform ints samples\n+        var g0 = mockGS.mixed(mockGS.uniformInts(0, 30), mockGS.single(-1), 7, 3);\n+        Asserts.assertEQ(g0.next(), -1);\n+        Asserts.assertEQ(g0.next(), 4);\n+        Asserts.assertEQ(g0.next(), 18);\n+\n+        mockSource\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: the first uniform ints\n+                .enqueueInteger(0, 31, 24) \/\/ uniform ints (1) samples\n+                .enqueueInteger(0, 10, 2) \/\/ MixedGenerator chooses a generator: single\n+                \/\/ single does not use randomness\n+                .enqueueInteger(0, 10, 7) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+                .enqueueInteger(-10, 0, -2) \/\/ uniform ints (2) samples\n+                .enqueueInteger(0, 10, 9) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+                .enqueueInteger(-10, 0, -4) \/\/ uniform ints (2) samples\n+                .enqueueInteger(0, 10, 1) \/\/ MixedGenerator chooses a generator: the first uniform ints\n+                .enqueueInteger(0, 31, 29); \/\/ uniform ints (1) samples\n+\n+        var g1 = mockGS.mixed(\n+                List.of(2, 5, 3),\n+                mockGS.uniformInts(0, 30), mockGS.single(-1), mockGS.uniformInts(-10, -1)\n+        );\n+        Asserts.assertEQ(g1.next(), 24);\n+        Asserts.assertEQ(g1.next(), -1);\n+        Asserts.assertEQ(g1.next(), -2);\n+        Asserts.assertEQ(g1.next(), -4);\n+        Asserts.assertEQ(g1.next(), 29);\n+\n+        mockSource\n+            .checkEmpty()\n+            .enqueueInteger(0, 10, 7)  \/\/ MixedGenerator chooses a generator: single\n+            \/\/ single was chosen but does not consume randomness\n+            .enqueueInteger(0, 10, 5)  \/\/ MixedGenerator chooses a generator: uniform ints\n+            .enqueueInteger(0, 21, 18);  \/\/ uniform ints samples\n+        var g0r0 = g0.restricted(-1, 20);\n+        Asserts.assertEQ(g0r0.next(), -1);\n+        Asserts.assertEQ(g0r0.next(), 18);\n+\n+        mockSource\n+            .checkEmpty()\n+            .enqueueInteger(0, 7, 6)  \/\/ MixedGenerator chooses a generator (weight for single will have been removed): uniform ints\n+            .enqueueInteger(4, 21, 9);  \/\/ MixedGenerator chooses a generator: uniform ints\n+        var g0r1 = g0.restricted(4, 20);\n+        Asserts.assertEQ(g0r1.next(), 9);\n+\n+        mockSource\n+            .checkEmpty()\n+            .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: the first uniform ints\n+            .enqueueInteger(0, 21, 2) \/\/ uniform ints (1) samples\n+            .enqueueInteger(0, 10, 2) \/\/ MixedGenerator chooses a generator: single\n+            \/\/ single does not use randomness\n+            .enqueueInteger(0, 10, 7) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+            .enqueueInteger(-1, 0, -1);\n+        var g1r0 = g1.restricted(-1, 20);\n+        Asserts.assertEQ(g1r0.next(), 2);\n+        Asserts.assertEQ(g1r0.next(), -1);\n+        Asserts.assertEQ(g1r0.next(), -1);\n+\n+        mockSource\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: the first uniform ints\n+                .enqueueInteger(0, 21, 2) \/\/ uniform ints (1) samples\n+                .enqueueInteger(0, 10, 2) \/\/ MixedGenerator chooses a generator: single\n+                \/\/ single does not use randomness\n+                .enqueueInteger(0, 10, 7) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+                .enqueueInteger(-1, 0, -1);\n+        var g1r1 = g1.restricted(-1, 20);\n+        Asserts.assertEQ(g1r1.next(), 2);\n+        Asserts.assertEQ(g1r1.next(), -1);\n+        Asserts.assertEQ(g1r1.next(), -1);\n+    }\n+\n+    static void testSpecialFloat() {\n+        mockSource\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 3)\n+                .enqueueDouble(0, 1, 3.4d)\n+                .enqueueInteger(0, 10, 6)\n+                .enqueueInteger(0, 9, 1);\n+        var g = mockGS.mixedWithSpecialDoubles(mockGS.uniformDoubles(), 5, 5);\n+        Asserts.assertEQ(g.next(), 3.4d);\n+        Asserts.assertEQ(g.next(), -1d);\n+    }\n+\n+    static void testSpecialDouble() {\n+        mockSource\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 3)\n+                .enqueueFloat(0, 1, 3.4f)\n+                .enqueueInteger(0, 10, 6)\n+                .enqueueInteger(0, 9, 1);\n+        var g = mockGS.mixedWithSpecialFloats(mockGS.uniformFloats(), 5, 5);\n+        Asserts.assertEQ(g.next(), 3.4f);\n+        Asserts.assertEQ(g.next(), -1f);\n+    }\n+\n+    static void testUniformFloat() {\n+        mockSource.checkEmpty().enqueueFloat(-1, 10, 3.14159f);\n+        Asserts.assertEQ(mockGS.uniformFloats(-1, 10).next(), 3.14159f);\n+        mockSource.checkEmpty().enqueueFloat(0, 1, 3.14159f);\n+        Asserts.assertEQ(mockGS.uniformFloats(0, 1).next(), 3.14159f);\n+\n+        float lo = 0.13f, hi = 13.532f;\n+        var gb = G.uniformFloats(lo, hi);\n+        for (int i = 0; i < 10_000; i++) {\n+            float x = gb.next();\n+            Asserts.assertGreaterThanOrEqual(x, lo);\n+            Asserts.assertLessThan(x, hi);\n+        }\n+    }\n+\n+    static void testUniformDouble() {\n+        mockSource.checkEmpty().enqueueDouble(-1, 10, 3.14159d);\n+        Asserts.assertEQ(mockGS.uniformDoubles(-1, 10).next(), 3.14159d);\n+        mockSource.checkEmpty().enqueueDouble(0, 1, 3.14159d);\n+        Asserts.assertEQ(mockGS.uniformDoubles(0, 1).next(), 3.14159d);\n+\n+        double lo = 0.13, hi = 13.532;\n+        var gb = G.uniformDoubles(lo, hi);\n+        for (int i = 0; i < 10_000; i++) {\n+            double x = gb.next();\n+            Asserts.assertGreaterThanOrEqual(x, lo);\n+            Asserts.assertLessThan(x, hi);\n+        }\n+    }\n+\n+    static void testRandomElement() {\n+        mockSource.checkEmpty().enqueueInteger(0, 3, 1).enqueueInteger(0, 3, 0);\n+        var g = mockGS.randomElement(List.of(\"a\", \"b\", \"c\"));\n+        Asserts.assertEQ(g.next(), \"b\");\n+        Asserts.assertEQ(g.next(), \"a\");\n+\n+        mockSource.checkEmpty().enqueueInteger(0, 8, 1).enqueueInteger(0, 8, 2);\n+        \/\/ The list below is intentionally not sorted and is equivalent to: 1, 4, 4, 8, 9, 10, 13, 18, 20\n+        \/\/ It contains 8 distinct values. Note that orderedRandomElement removes duplicates. Therefor the internal\n+        \/\/ value list is: 1, 4, 8, 9, 10, 13, 18, 20\n+        var g1 = mockGS.orderedRandomElement(List.of(10, 4, 1, 8, 9, 4, 20, 18, 13));\n+        Asserts.assertEQ(g1.next(), 4);\n+        Asserts.assertEQ(g1.next(), 8);\n+\n+        mockSource.checkEmpty().enqueueInteger(0, 3, 1).enqueueInteger(0, 3, 2);\n+        \/\/ Ordered lists can also be restricted. Our new values are 9, 10, 13.\n+        var gr = g1.restricted(9, 13);\n+        Asserts.assertEQ(gr.next(), 10);\n+        Asserts.assertEQ(gr.next(), 13);\n+\n+        mockSource.checkEmpty().enqueueInteger(0, 2, 1);\n+        var gs = mockGS.orderedRandomElement(List.of(\"Bob\", \"Alice\", \"Carol\")).restricted(\"Al\", \"Bz\");\n+        Asserts.assertEQ(gs.next(), \"Bob\");\n+    }\n+\n+    static void specialInt() {\n+        mockSource.checkEmpty().enqueueInteger(0, 63, 1).enqueueInteger(0, 63, 32);\n+        var si = mockGS.specialInts(0);\n+        Asserts.assertEQ(si.next(), -(1 << 30));\n+        Asserts.assertEQ(si.next(), 1);\n+\n+        mockSource.checkEmpty().enqueueInteger(0, 182, 1);\n+        var si1 = mockGS.specialInts(1);\n+        Asserts.assertEQ(si1.next(), -(1 << 31) + 1);\n+    }\n+\n+    static void specialLong() {\n+        mockSource.checkEmpty().enqueueInteger(0, 127, 1).enqueueInteger(0, 127, 64);\n+        var si = mockGS.specialLongs(0);\n+        Asserts.assertEQ(si.next(), -(1L << 62));\n+        Asserts.assertEQ(si.next(), 1L);\n+\n+        mockSource.checkEmpty().enqueueInteger(0, 374, 1);\n+        var si1 = mockGS.specialLongs(1);\n+        Asserts.assertEQ(si1.next(), -(1L << 63) + 1);\n+    }\n+\n+    static void testSingle() {\n+        mockSource.checkEmpty();\n+        var g = mockGS.single(30);\n+        Asserts.assertEQ(g.next(), 30);\n+        Asserts.assertEQ(g.next(), 30);\n+        Asserts.assertEQ(g.restricted(10, 50).next(), 30);\n+        var gs = mockGS.single(\"hello\");\n+        Asserts.assertEQ(gs.next(), \"hello\");\n+        Asserts.assertEQ(gs.next(), \"hello\");\n+        Asserts.assertEQ(gs.restricted(\"a\", \"q\").next(), \"hello\");\n+        var theObject = new Object();\n+        var go = mockGS.single(theObject);\n+        Asserts.assertEQ(go.next(), theObject);\n+        Asserts.assertEQ(go.next(), theObject);\n+    }\n+\n+    static void testUniformInts() {\n+        mockSource.checkEmpty().enqueueInteger(0, 11, 1).enqueueInteger(0, 11, 4);\n+        var g0 = mockGS.uniformInts(0, 10);\n+        Asserts.assertEQ(g0.next(), 1);\n+        Asserts.assertEQ(g0.next(), 4);\n+\n+        mockSource.checkEmpty().enqueueInteger(0, 1, 0).enqueueInteger(0, 1, 0);\n+        var g1 = mockGS.uniformInts(0, 0);\n+        Asserts.assertEQ(g1.next(), 0);\n+        Asserts.assertEQ(g1.next(), 0);\n+\n+        mockSource.checkEmpty().enqueueInteger(-1, Integer.MAX_VALUE, 10);\n+        Asserts.assertEQ(mockGS.uniformInts(0, Integer.MAX_VALUE).next(), 11);\n+\n+        mockSource.checkEmpty().enqueueInteger(Integer.MIN_VALUE, 13, -33);\n+        Asserts.assertEQ(mockGS.uniformInts(Integer.MIN_VALUE, 12).next(), -33);\n+\n+        mockSource.checkEmpty().enqueueInteger(11);\n+        Asserts.assertEQ(mockGS.uniformInts(Integer.MIN_VALUE, Integer.MAX_VALUE).next(), 11);\n+\n+        mockSource.checkEmpty().enqueueInteger(10, 29, 17);\n+        Asserts.assertEQ(mockGS.uniformInts(Integer.MIN_VALUE, Integer.MAX_VALUE).restricted(10, 28).next(), 17);\n+\n+        mockSource.checkEmpty().enqueueInteger(19, 29, 17);\n+        Asserts.assertEQ(mockGS.uniformInts(Integer.MIN_VALUE, Integer.MAX_VALUE).restricted(10, 28).restricted(19, 33).next(), 17);\n+\n+        \/\/ inside interval positive\n+        mockSource.checkEmpty().enqueueInteger(12, 19, 17);\n+        Asserts.assertEQ(mockGS.uniformInts(10, 20).restricted(12, 18).next(), 17);\n+\n+        \/\/ inside interval negative\n+        mockSource.checkEmpty().enqueueInteger(-18, -11, -17);\n+        Asserts.assertEQ(mockGS.uniformInts(-20, -10).restricted(-18, -12).next(), -17);\n+\n+        \/\/ left interval positive\n+        mockSource.checkEmpty().enqueueInteger(10, 13, 11);\n+        Asserts.assertEQ(mockGS.uniformInts(10, 20).restricted(5, 12).next(), 11);\n+\n+        \/\/ left interval negative\n+        mockSource.checkEmpty().enqueueInteger(-12, -9, -11);\n+        Asserts.assertEQ(mockGS.uniformInts(-20, -10).restricted(-12, -5).next(), -11);\n+\n+        \/\/ right interval positive\n+        mockSource.checkEmpty().enqueueInteger(17, 21, 19);\n+        Asserts.assertEQ(mockGS.uniformInts(10, 20).restricted(17, 22).next(), 19);\n+\n+        \/\/ right interval negative\n+        mockSource.checkEmpty().enqueueInteger(-20, -16, -19);\n+        Asserts.assertEQ(mockGS.uniformInts(-20, -10).restricted(-22, -17).next(), -19);\n+\n+        mockSource.checkEmpty().enqueueInteger(144);\n+        Asserts.assertEQ(mockGS.uniformInts().next(), 144);\n+\n+        mockSource.checkEmpty();\n+\n+        int lo = -345555, hi = 11123;\n+        var gb = G.uniformInts(lo, hi);\n+        for (int i = 0; i < 10_000; i++) {\n+            int x = gb.next();\n+            Asserts.assertGreaterThanOrEqual(x, lo);\n+            Asserts.assertLessThanOrEqual(x, hi);\n+        }\n+    }\n+\n+    static void testUniformLongs() {\n+        mockSource.checkEmpty().enqueueLong(0, 11, 1).enqueueLong(0, 11, 4);\n+        var g0 = mockGS.uniformLongs(0, 10);\n+        Asserts.assertEQ(g0.next(), 1L);\n+        Asserts.assertEQ(g0.next(), 4L);\n+\n+        mockSource.checkEmpty().enqueueLong(0, 1, 0).enqueueLong(0, 1, 0);\n+        var g1 = mockGS.uniformLongs(0, 0);\n+        Asserts.assertEQ(g1.next(), 0L);\n+        Asserts.assertEQ(g1.next(), 0L);\n+\n+        mockSource.checkEmpty().enqueueLong(-1, Long.MAX_VALUE, 10);\n+        Asserts.assertEQ(mockGS.uniformLongs(0, Long.MAX_VALUE).next(), 11L);\n+\n+        mockSource.checkEmpty().enqueueLong(Long.MIN_VALUE, 13, -33);\n+        Asserts.assertEQ(mockGS.uniformLongs(Long.MIN_VALUE, 12).next(), -33L);\n+\n+        mockSource.checkEmpty().enqueueLong(11);\n+        Asserts.assertEQ(mockGS.uniformLongs(Long.MIN_VALUE, Long.MAX_VALUE).next(), 11L);\n+\n+        mockSource.checkEmpty().enqueueLong(10, 29, 17);\n+        Asserts.assertEQ(mockGS.uniformLongs(Long.MIN_VALUE, Long.MAX_VALUE).restricted(10L, 28L).next(), 17L);\n+\n+        mockSource.checkEmpty().enqueueLong(19, 29, 17);\n+        Asserts.assertEQ(mockGS.uniformLongs(Long.MIN_VALUE, Long.MAX_VALUE).restricted(10L, 28L).restricted(19L, 33L).next(), 17L);\n+\n+        mockSource.checkEmpty().enqueueLong(144);\n+        Asserts.assertEQ(mockGS.uniformLongs().next(), 144L);\n+\n+        mockSource.checkEmpty();\n+\n+        long lo = -344223244511L, hi = 29;\n+        var gb = G.uniformLongs(lo, hi);\n+        for (int i = 0; i < 10_000; i++) {\n+            long x = gb.next();\n+            Asserts.assertGreaterThanOrEqual(x, lo);\n+            Asserts.assertLessThanOrEqual(x, hi);\n+        }\n+    }\n+\n+    static void testAnyBits() {\n+        mockSource.checkEmpty().enqueueInteger(Float.floatToIntBits(3.14159f));\n+        Asserts.assertEQ(mockGS.anyBitsFloats().next(), 3.14159f);\n+\n+        mockSource.checkEmpty().enqueueLong(Double.doubleToLongBits(3.14159d));\n+        Asserts.assertEQ(mockGS.anyBitsDouble().next(), 3.14159d);\n+    }\n+\n+    static void testEmptyGenerators() {\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformInts(1, 0));\n+        Asserts.assertNotNull(G.uniformInts(0, 0));\n+        Asserts.assertNotNull(G.uniformInts(0, 1));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformInts(0, 1).restricted(2, 5));\n+        Asserts.assertNotNull(G.uniformInts(0, 1).restricted(0, 1));\n+        Asserts.assertNotNull(G.uniformInts(0, 1).restricted(1, 5));\n+        Asserts.assertNotNull(G.uniformInts(0, 10).restricted(1, 2));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformLongs(1, 0));\n+        Asserts.assertNotNull(G.uniformLongs(0, 0));\n+        Asserts.assertNotNull(G.uniformLongs(0, 1));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformLongs(0, 1).restricted(2L, 5L));\n+        Asserts.assertNotNull(G.uniformLongs(0, 1).restricted(0L, 1L));\n+        Asserts.assertNotNull(G.uniformLongs(0, 1).restricted(1L, 5L));\n+        Asserts.assertNotNull(G.uniformLongs(0, 10).restricted(1L, 2L));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformDoubles(1, 0));\n+        Asserts.assertNotNull(G.uniformDoubles(0, 1));\n+        Asserts.assertNotNull(G.uniformDoubles(0, 0));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformDoubles(0, 1).restricted(1.1d, 2.4d));\n+        Asserts.assertNotNull(G.uniformDoubles(0, 1).restricted(0.9d, 2.4d));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformFloats(1, 0));\n+        Asserts.assertNotNull(G.uniformFloats(0, 1));\n+        Asserts.assertNotNull(G.uniformFloats(0, 0));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.uniformFloats(0, 1).restricted(1.1f, 2.4f));\n+        Asserts.assertNotNull(G.uniformFloats(0, 1).restricted(0.9f, 2.4f));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.randomElement(List.of()));\n+        Asserts.assertNotNull(G.randomElement(List.of(\"a\", \"b\", \"c\")));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.orderedRandomElement(new ArrayList<Integer>()));\n+        Asserts.assertNotNull(G.orderedRandomElement(List.of(48, 29, 17)));\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.orderedRandomElement(List.of(48, 29, 17)).restricted(-12, 10));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.single(10).restricted(0, 1));\n+        Asserts.assertNotNull(G.single(10).restricted(9, 10));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(30, 34));\n+        Asserts.assertNotNull(G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(5, 18));\n+        Asserts.assertNotNull(G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(5, 7));\n+        Asserts.assertNotNull(G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(16, 18));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(80, 83));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(10, 35));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(5, 8));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(17, 19));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(31, 38));\n+    }\n+\n+    static void testFill() {\n+        \/\/ All we need to test really is that fill calls the generators sequentially and correctly write the values\n+        \/\/ into the arrays. Since fill with arrays uses memory segments internally, these are also tested.\n+\n+        Generator<Double> doubleGen = new Generator<>() {\n+            private double i = 1;\n+\n+            @Override\n+            public Double next() {\n+                i \/= 2;\n+                return i;\n+            }\n+        };\n+\n+        double[] doubles = new double[5];\n+        mockGS.fill(doubleGen, doubles);\n+        Asserts.assertTrue(Arrays.equals(doubles, (new double[] {0.5, 0.25, 0.125, 0.0625, 0.03125})));\n+\n+        Generator<Float> floatGen = new Generator<>() {\n+            private float i = 1;\n+\n+            @Override\n+            public Float next() {\n+                i \/= 2;\n+                return i;\n+            }\n+        };\n+\n+        float[] floats = new float[5];\n+        mockGS.fill(floatGen, floats);\n+        Asserts.assertTrue(Arrays.equals(floats, (new float[] {0.5f, 0.25f, 0.125f, 0.0625f, 0.03125f})));\n+\n+        Generator<Long> longGen = new Generator<>() {\n+            private long i = 1;\n+\n+            @Override\n+            public Long next() {\n+                return i++;\n+            }\n+        };\n+\n+        long[] longs = new long[5];\n+        mockGS.fill(longGen, longs);\n+        Asserts.assertTrue(Arrays.equals(longs, (new long[] {1, 2, 3, 4, 5})));\n+\n+        Generator<Integer> intGen = new Generator<>() {\n+            private int i = 1;\n+\n+            @Override\n+            public Integer next() {\n+                return i++;\n+            }\n+        };\n+\n+        int[] ints = new int[5];\n+        mockGS.fill(intGen, ints);\n+        Asserts.assertTrue(Arrays.equals(ints, (new int[] {1, 2, 3, 4, 5})));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/TestGenerators.java","additions":504,"deletions":0,"binary":false,"changes":504,"status":"added"}]}