{"files":[{"patch":"@@ -218,0 +218,1 @@\n+     * An overload for restrictable generators exists.\n@@ -220,1 +221,32 @@\n-        return new MixedGenerator<>(this, a, b, weightA, weightB);\n+        return new MixedGenerator<>(this, List.of(a, b), List.of(weightA, weightB));\n+    }\n+\n+    \/**\n+     * Returns a new generator that samples its next element randomly from one of the provided generators with\n+     * assignable weights.\n+     * An overload for restrictable generators exists.\n+     *\/\n+    @SafeVarargs\n+    public final <T> Generator<T> mixed(List<Integer> weights, Generator<T>... generators) {\n+        return new MixedGenerator<>(this, Arrays.asList(generators), weights);\n+    }\n+\n+    \/**\n+     * Returns a new restrictable generator that samples its next element from either generator A or B, with assignable weights.\n+     * Restricting this generator restricts each subgenerator. Generators which become empty by the restriction are\n+     * removed from the new mixed generator. Weights stay their original value if a generator is removed. If the mixed\n+     * generator would become empty by applying a restriction {@link EmptyGeneratorException} is thrown.\n+     *\/\n+    public <T extends Comparable<T>> RestrictableGenerator<T> mixed(RestrictableGenerator<T> a, RestrictableGenerator<T> b, int weightA, int weightB) {\n+        return new RestrictableMixedGenerator<>(this, List.of(a, b), List.of(weightA, weightB));\n+    }\n+\n+    \/**\n+     * Returns a new restrictable generator that samples its next element randomly from one of the provided restrictable\n+     * generators with assignable weights.\n+     * See {@link #mixed(RestrictableGenerator, RestrictableGenerator, int, int)} for details about restricting this\n+     * generator.\n+     *\/\n+    @SafeVarargs\n+    public final <T extends Comparable<T>> RestrictableGenerator<T> mixed(List<Integer> weights, RestrictableGenerator<T>... generators) {\n+        return new RestrictableMixedGenerator<>(this, Arrays.asList(generators), weights);\n@@ -228,1 +260,1 @@\n-    public Generator<Integer> ints() {\n+    public RestrictableGenerator<Integer> ints() {\n@@ -257,1 +289,1 @@\n-    public Generator<Integer> mixedWithSpecialInts(int weightA, int weightB, int rangeSpecial) {\n+    public RestrictableGenerator<Integer> mixedWithSpecialInts(int weightA, int weightB, int rangeSpecial) {\n@@ -266,1 +298,1 @@\n-    public Generator<Long> longs() {\n+    public RestrictableGenerator<Long> longs() {\n@@ -283,1 +315,1 @@\n-    public Generator<Long> specialLongs(int range) {\n+    public RestrictableGenerator<Long> specialLongs(int range) {\n@@ -295,1 +327,1 @@\n-    public Generator<Long> mixedWithSpecialLongs(int weightA, int weightB, int rangeSpecial) {\n+    public RestrictableGenerator<Long> mixedWithSpecialLongs(int weightA, int weightB, int rangeSpecial) {\n@@ -361,0 +393,8 @@\n+    \/**\n+     * Returns a restrictable mixed generator that mixes the provided background generator and SPECIAL_DOUBLES with the provided\n+     * weights.\n+     *\/\n+    public RestrictableGenerator<Double> mixedWithSpecialDoubles(RestrictableGenerator<Double> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_DOUBLES, weightNormal, weightSpecial);\n+    }\n+\n@@ -385,0 +425,8 @@\n+    \/**\n+     * Returns a restrictable mixed generator that mixes the provided background generator and SPECIAL_FLOATS with the provided\n+     * weights.\n+     *\/\n+    public RestrictableGenerator<Float> mixedWithSpecialFloats(RestrictableGenerator<Float> background, int weightNormal, int weightSpecial) {\n+        return mixed(background, SPECIAL_FLOATS, weightNormal, weightSpecial);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generators.java","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+import java.util.List;\n+import java.util.TreeMap;\n+import java.util.function.Function;\n+\n@@ -27,1 +31,1 @@\n- * Mixed results between two different generators with configurable weights.\n+ * Mixed results between different generators with configurable weights.\n@@ -29,5 +33,3 @@\n-class MixedGenerator<T> extends BoundGenerator<T> {\n-    private final Generator<T> a;\n-    private final Generator<T> b;\n-    private final int weightA;\n-    private final int weightB;\n+class MixedGenerator<G extends Generator<T>, T> extends BoundGenerator<T> {\n+    private final TreeMap<Integer, G> generators = new TreeMap<>();\n+    private final int totalWeight;\n@@ -36,1 +38,1 @@\n-     * Creates a new {@link MixedGenerator}, which samples from two generators A and B,\n+     * Creates a new {@link MixedGenerator}, which samples from a list of generators at random,\n@@ -38,3 +40,0 @@\n-     *\n-     * @param weightA Weight for the distribution for a.\n-     * @param weightB Weight for the distribution for b.\n@@ -42,1 +41,1 @@\n-    MixedGenerator(Generators g, Generator<T> a, Generator<T> b, int weightA, int weightB) {\n+    MixedGenerator(Generators g, List<G> generators, List<Integer> weights) {\n@@ -44,4 +43,37 @@\n-        this.a = a;\n-        this.b = b;\n-        this.weightA = weightA;\n-        this.weightB = weightB;\n+        if (weights.size() != generators.size()) {\n+            throw new IllegalArgumentException(\"weights and generators must have the same size.\");\n+        }\n+        int acc = 0;\n+        for (int i = 0; i < generators.size(); i++) {\n+            acc += weights.get(i);\n+            this.generators.put(acc, generators.get(i));\n+        }\n+        this.totalWeight = acc;\n+    }\n+\n+    \/**\n+     * Creates a new mixed generator by mapping each generator of the old generator to a new value or removing it.\n+     * @param other The generator to copy from.\n+     * @param generatorMapper A function that is called for each subgenerator in the old generator. Either return a\n+     *                        generator that takes the role of the old generator (might be the same) or null to remove\n+     *                        the generator completely. In this case, the weights of the other generators stay the same.\n+     *\/\n+    MixedGenerator(MixedGenerator<G, T> other, Function<G, G> generatorMapper) {\n+        super(other.g);\n+        int acc = 0;\n+        int prevKey = 0;\n+        for (var entry : other.generators.entrySet()) {\n+            var gen = generatorMapper.apply(entry.getValue());\n+            if (gen != null) {\n+                \/\/ entry.getKey() is the sum of all generator weights up to this one.\n+                \/\/ We compute this generator's weight by taking the difference to the previous key\n+                int weight = entry.getKey() - prevKey;\n+                acc += weight;\n+                this.generators.put(acc, gen);\n+            }\n+            prevKey = entry.getKey();\n+        }\n+        if (this.generators.isEmpty()) {\n+            throw new EmptyGeneratorException();\n+        }\n+        this.totalWeight = acc;\n@@ -52,6 +84,2 @@\n-        int r = g.random.nextInt(0, weightA + weightB);\n-        if (r < weightA) {\n-            return a.next();\n-        } else {\n-            return b.next();\n-        }\n+        int r = g.random.nextInt(0, totalWeight);\n+        return generators.higherEntry(r).getValue().next();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/MixedGenerator.java","additions":49,"deletions":21,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+package compiler.lib.generators;\n+\n+import java.util.List;\n+\n+final class RestrictableMixedGenerator<T extends Comparable<T>> extends MixedGenerator<RestrictableGenerator<T>, T> implements RestrictableGenerator<T> {\n+    RestrictableMixedGenerator(Generators g, List<RestrictableGenerator<T>> generators, List<Integer> weights) {\n+        super(g, generators, weights);\n+    }\n+\n+    RestrictableMixedGenerator(RestrictableMixedGenerator<T> other, T newLo, T newHi) {\n+        super(other, (generator) -> {\n+            try {\n+                return generator.restricted(newLo, newHi);\n+            } catch (EmptyGeneratorException e) {\n+                System.out.println(\"kicking out \" + generator);\n+                return null;\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public RestrictableGenerator<T> restricted(T newLo, T newHi) {\n+        return new RestrictableMixedGenerator<>(this, newLo, newHi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/RestrictableMixedGenerator.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -46,11 +46,3 @@\n-    public RestrictableGenerator<T> restricted(T newLo, T newHi) {\n-        if (newLo.compareTo(newHi) > 0) throw new EmptyGeneratorException();\n-        if (newHi.compareTo(lo()) <= 0) {  \/\/ new interval is to the left\n-            if (newHi.compareTo(lo()) < 0) throw new EmptyGeneratorException();\n-            return doRestrictionFromIntersection(newLo, hi());\n-        } else if (hi().compareTo(newLo) <= 0) {  \/\/ new interval is to the right\n-            if (hi().compareTo(newLo) < 0) throw new EmptyGeneratorException();\n-            return doRestrictionFromIntersection(lo(), newHi);\n-        } else {  \/\/ old and new interval intersect\n-            return doRestrictionFromIntersection(max(newLo, lo()), min(newHi, hi()));\n-        }\n+    public RestrictableGenerator<T> restricted(T newLo \/*as*\/, T newHi \/*ae*\/) {\n+        if (lo().compareTo(newHi) > 0 || newLo.compareTo(hi()) > 0) throw new EmptyGeneratorException();\n+        return doRestrictionFromIntersection(max(newLo, lo()), min(newHi, hi()));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/UniformIntersectionRestrictableGenerator.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+    \/\/ As it's hard to write tests with real randomness, we mock the randomness source so we can control which \"random\"\n+    \/\/ values are fed to the generators. Thus, a lot of the tests below are white-box tests, that have knowledge about\n+    \/\/ the internals of when randomness is consumed. There are also black-box tests which refer to Generators.G.\n+    \/\/ Please also see MockRandomness to learn more about this class.\n@@ -69,9 +73,76 @@\n-                .enqueueInteger(0, 10, 7)\n-                .enqueueInteger(0, 10, 5)\n-                .enqueueInteger(0, 31, 4)\n-                .enqueueInteger(0, 10, 1)\n-                .enqueueInteger(0, 31, 18);\n-        var g = mockGS.mixed(mockGS.uniformInts(0, 30), mockGS.single(-1), 7, 3);\n-        Asserts.assertEQ(g.next(), -1);\n-        Asserts.assertEQ(g.next(), 4);\n-        Asserts.assertEQ(g.next(), 18);\n+                .enqueueInteger(0, 10, 7)  \/\/ MixedGenerator chooses a generator: single\n+                \/\/ single was chosen but does not consume randomness\n+                .enqueueInteger(0, 10, 5)  \/\/ MixedGenerator chooses a generator: uniform ints\n+                .enqueueInteger(0, 31, 4)  \/\/ uniform ints samples\n+                .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: uniform ints\n+                .enqueueInteger(0, 31, 18); \/\/ uniform ints samples\n+        var g0 = mockGS.mixed(mockGS.uniformInts(0, 30), mockGS.single(-1), 7, 3);\n+        Asserts.assertEQ(g0.next(), -1);\n+        Asserts.assertEQ(g0.next(), 4);\n+        Asserts.assertEQ(g0.next(), 18);\n+\n+        mockRandomness\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: the first uniform ints\n+                .enqueueInteger(0, 31, 24) \/\/ uniform ints (1) samples\n+                .enqueueInteger(0, 10, 2) \/\/ MixedGenerator chooses a generator: single\n+                \/\/ single does not use randomness\n+                .enqueueInteger(0, 10, 7) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+                .enqueueInteger(-10, 0, -2) \/\/ uniform ints (2) samples\n+                .enqueueInteger(0, 10, 9) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+                .enqueueInteger(-10, 0, -4) \/\/ uniform ints (2) samples\n+                .enqueueInteger(0, 10, 1) \/\/ MixedGenerator chooses a generator: the first uniform ints\n+                .enqueueInteger(0, 31, 29); \/\/ uniform ints (1) samples\n+\n+        var g1 = mockGS.mixed(\n+                List.of(2, 5, 3),\n+                mockGS.uniformInts(0, 30), mockGS.single(-1), mockGS.uniformInts(-10, -1)\n+        );\n+        Asserts.assertEQ(g1.next(), 24);\n+        Asserts.assertEQ(g1.next(), -1);\n+        Asserts.assertEQ(g1.next(), -2);\n+        Asserts.assertEQ(g1.next(), -4);\n+        Asserts.assertEQ(g1.next(), 29);\n+\n+        mockRandomness\n+            .checkEmpty()\n+            .enqueueInteger(0, 10, 7)  \/\/ MixedGenerator chooses a generator: single\n+            \/\/ single was chosen but does not consume randomness\n+            .enqueueInteger(0, 10, 5)  \/\/ MixedGenerator chooses a generator: uniform ints\n+            .enqueueInteger(0, 21, 18);  \/\/ uniform ints samples\n+        var g0r0 = g0.restricted(-1, 20);\n+        Asserts.assertEQ(g0r0.next(), -1);\n+        Asserts.assertEQ(g0r0.next(), 18);\n+\n+        mockRandomness\n+            .checkEmpty()\n+            .enqueueInteger(0, 7, 6)  \/\/ MixedGenerator chooses a generator (weight for single will have been removed): uniform ints\n+            .enqueueInteger(4, 21, 9);  \/\/ MixedGenerator chooses a generator: uniform ints\n+        var g0r1 = g0.restricted(4, 20);\n+        Asserts.assertEQ(g0r1.next(), 9);\n+\n+        mockRandomness\n+            .checkEmpty()\n+            .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: the first uniform ints\n+            .enqueueInteger(0, 21, 2) \/\/ uniform ints (1) samples\n+            .enqueueInteger(0, 10, 2) \/\/ MixedGenerator chooses a generator: single\n+            \/\/ single does not use randomness\n+            .enqueueInteger(0, 10, 7) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+            .enqueueInteger(-1, 0, -1);\n+        var g1r0 = g1.restricted(-1, 20);\n+        Asserts.assertEQ(g1r0.next(), 2);\n+        Asserts.assertEQ(g1r0.next(), -1);\n+        Asserts.assertEQ(g1r0.next(), -1);\n+\n+        mockRandomness\n+                .checkEmpty()\n+                .enqueueInteger(0, 10, 1)  \/\/ MixedGenerator chooses a generator: the first uniform ints\n+                .enqueueInteger(0, 21, 2) \/\/ uniform ints (1) samples\n+                .enqueueInteger(0, 10, 2) \/\/ MixedGenerator chooses a generator: single\n+                \/\/ single does not use randomness\n+                .enqueueInteger(0, 10, 7) \/\/ MixedGenerator chooses a generator: the second uniform ints\n+                .enqueueInteger(-1, 0, -1);\n+        var g1r1 = g1.restricted(-1, 20);\n+        Asserts.assertEQ(g1r1.next(), 2);\n+        Asserts.assertEQ(g1r1.next(), -1);\n+        Asserts.assertEQ(g1r1.next(), -1);\n@@ -223,0 +294,24 @@\n+        \/\/ inside interval positive\n+        mockRandomness.checkEmpty().enqueueInteger(12, 19, 17);\n+        Asserts.assertEQ(mockGS.uniformInts(10, 20).restricted(12, 18).next(), 17);\n+\n+        \/\/ inside interval negative\n+        mockRandomness.checkEmpty().enqueueInteger(-18, -11, -17);\n+        Asserts.assertEQ(mockGS.uniformInts(-20, -10).restricted(-18, -12).next(), -17);\n+\n+        \/\/ left interval positive\n+        mockRandomness.checkEmpty().enqueueInteger(10, 13, 11);\n+        Asserts.assertEQ(mockGS.uniformInts(10, 20).restricted(5, 12).next(), 11);\n+\n+        \/\/ left interval negative\n+        mockRandomness.checkEmpty().enqueueInteger(-12, -9, -11);\n+        Asserts.assertEQ(mockGS.uniformInts(-20, -10).restricted(-12, -5).next(), -11);\n+\n+        \/\/ right interval positive\n+        mockRandomness.checkEmpty().enqueueInteger(17, 21, 19);\n+        Asserts.assertEQ(mockGS.uniformInts(10, 20).restricted(17, 22).next(), 19);\n+\n+        \/\/ right interval negative\n+        mockRandomness.checkEmpty().enqueueInteger(-20, -16, -19);\n+        Asserts.assertEQ(mockGS.uniformInts(-20, -10).restricted(-22, -17).next(), -19);\n+\n@@ -323,0 +418,26 @@\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(30, 34));\n+        Asserts.assertNotNull(G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(5, 18));\n+        Asserts.assertNotNull(G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(5, 7));\n+        Asserts.assertNotNull(G.mixed(G.uniformInts(0, 10), G.uniformInts(15, 20), 5, 5).restricted(16, 18));\n+\n+        Asserts.assertThrows(EmptyGeneratorException.class, () -> G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(80, 83));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(10, 35));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(5, 8));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(17, 19));\n+        Asserts.assertNotNull(G.mixed(\n+                List.of(3, 4, 6),\n+                G.uniformInts(0, 10), G.uniformInts(15, 20), G.uniformInts(30, 40)\n+        ).restricted(31, 38));\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/generators\/tests\/TestGenerators.java","additions":130,"deletions":9,"binary":false,"changes":139,"status":"modified"}]}