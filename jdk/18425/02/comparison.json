{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -457,3 +457,12 @@\n-            if (encrypt) {\n-                token.p11.C_EncryptInit(session.id(), mechWithParams,\n-                    p11KeyID);\n+\n+            if (type == Transformation.AES_GCM) {\n+                CK_VERSION cryptokiVersion = token.p11.C_GetInfo().cryptokiVersion;\n+                boolean useNormativeMechFirst = cryptokiVersion.major > 2 ||\n+                    (cryptokiVersion.major == 2  && cryptokiVersion.minor >= 40);\n+                if (encrypt) {\n+                    token.p11.C_GCMEncryptInitWithRetry(session.id(), mechWithParams,\n+                        p11KeyID, useNormativeMechFirst);\n+                } else {\n+                    token.p11.C_GCMDecryptInitWithRetry(session.id(), mechWithParams,\n+                        p11KeyID, useNormativeMechFirst);\n+                }\n@@ -461,2 +470,7 @@\n-                token.p11.C_DecryptInit(session.id(), mechWithParams,\n-                    p11KeyID);\n+                if (encrypt) {\n+                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                        p11KeyID);\n+                } else {\n+                    token.p11.C_DecryptInit(session.id(), mechWithParams,\n+                        p11KeyID);\n+                }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -796,0 +796,18 @@\n+    \/**\n+     * C_GCMEncryptInitWithRetry initializes a GCM encryption operation and retry\n+     * with alternative param structure for max compatibility.\n+     * (Encryption and decryption)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param pMechanism the encryption mechanism\n+     *         (PKCS#11 param: CK_MECHANISM_PTR pMechanism)\n+     * @param hKey the handle of the encryption key\n+     *         (PKCS#11 param: CK_OBJECT_HANDLE hKey)\n+     * @param useNormativeVerFirst whether to use normative version of GCM parameter first\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_GCMEncryptInitWithRetry(long hSession, CK_MECHANISM pMechanism,\n+            long hKey, boolean useNormativeVerFirst) throws PKCS11Exception;\n@@ -890,0 +908,18 @@\n+    \/**\n+     * C_GCMDecryptInitWithRetry initializes a GCM decryption operation\n+     * with alternative param structure for max compatibility.\n+     * (Encryption and decryption)\n+     *\n+     * @param hSession the session's handle\n+     *         (PKCS#11 param: CK_SESSION_HANDLE hSession)\n+     * @param pMechanism the decryption mechanism\n+     *         (PKCS#11 param: CK_MECHANISM_PTR pMechanism)\n+     * @param hKey the handle of the decryption key\n+     *         (PKCS#11 param: CK_OBJECT_HANDLE hKey)\n+     * @param useNormativeVerFirst whether to use normative version of GCM parameter first\n+     * @exception PKCS11Exception If function returns other value than CKR_OK.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public native void C_GCMDecryptInitWithRetry(long hSession, CK_MECHANISM pMechanism,\n+            long hKey, boolean useNormativeVerFirst) throws PKCS11Exception;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1017,2 +1017,3 @@\n- * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS_NO_IVBITS pointer\n- * Note: Need to try NSS definition first to avoid SIGSEGV.\n+ * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS pointer\n+ * Note: Early NSS versions crash w\/ CK_GCM_PARAMS and need to use\n+ * CK_GCM_PARAMS_NO_IVBITS to avoid SIGSEGV.\n@@ -1023,1 +1024,1 @@\n- * @return pointer to the new CK_GCM_PARAMS_NO_IVBITS structure\n+ * @return pointer to the new CK_GCM_PARAMS structure\n@@ -1025,1 +1026,1 @@\n-CK_GCM_PARAMS_NO_IVBITS_PTR\n+CK_GCM_PARAMS_PTR\n@@ -1028,1 +1029,1 @@\n-    CK_GCM_PARAMS_NO_IVBITS_PTR ckParamPtr;\n+    CK_GCM_PARAMS_PTR ckParamPtr;\n@@ -1056,2 +1057,2 @@\n-    \/\/ allocate memory for CK_GCM_PARAMS_NO_IVBITS pointer\n-    ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n+    \/\/ allocate memory for CK_GCM_PARAMS pointer\n+    ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS));\n@@ -1068,0 +1069,2 @@\n+    \/\/ adjust since the value is in bits\n+    ckParamPtr->ulIvBits = ckParamPtr->ulIvLen << 3;\n@@ -1077,1 +1080,1 @@\n-        *pLength = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n+        *pLength = sizeof(CK_GCM_PARAMS);\n@@ -1079,1 +1082,1 @@\n-    TRACE1(\"Created inner GCM_PARAMS PTR w\/o ulIvBits %p\\n\", ckParamPtr);\n+    TRACE1(\"Created inner GCM_PARAMS PTR %p\\n\", ckParamPtr);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-    CK_MECHANISM_PTR ckpTemp;\n@@ -93,10 +92,50 @@\n-    if (ckpMechanism->mechanism == CKM_AES_GCM) {\n-        if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n-            \/\/ retry with CKM_GCM_PARAMS structure in pkcs11t.h\n-            TRACE0(\"DEBUG C_EncryptInit: retry with CK_GCM_PARAMS\\n\");\n-            ckpTemp = updateGCMParams(env, ckpMechanism);\n-            if (ckpTemp != NULL) { \/\/ only re-call if conversion succeeds\n-                ckpMechanism = ckpTemp;\n-                rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism,\n-                        ckKeyHandle);\n-            }\n+    TRACE1(\"DEBUG C_EncryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    freeCKMechanismPtr(ckpMechanism);\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+\n+    TRACE0(\"FINISHED\\n\");\n+}\n+\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_GCMEncryptInitWithRetry\n+ * Signature: (JLsun\/security\/pkcs11\/wrapper\/CK_MECHANISM;JZ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism\n+ * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey\n+ * @param   jboolean useNormVerFirst    CK_BBOOL retry (only retry if the first\n+ *                                      init uses the non-normative version)\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_security_pkcs11_wrapper_PKCS11_C_1GCMEncryptInitWithRetry\n+(JNIEnv *env, jobject obj, jlong jSessionHandle,\n+ jobject jMechanism, jlong jKeyHandle, jboolean useNormVerFirst)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_MECHANISM_PTR ckpMechanism = NULL;\n+    CK_OBJECT_HANDLE ckKeyHandle;\n+    CK_BBOOL retry = FALSE;\n+    CK_RV rv = 1;\n+\n+    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n+    if (ckpFunctions == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckKeyHandle = jLongToCKULong(jKeyHandle);\n+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);\n+\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    \/\/ if !useNormVerFirst, then update 'ckpMechanism' in place w\/\n+    \/\/ non-normative GCM params.\n+    retry = (!useNormVerFirst && updateGCMParams(env, ckpMechanism) != NULL);\n+\n+    rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);\n+\n+    if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n+        \/\/ retry and update 'ckpMechanism' in place w\/ normative GCM params.\n+        if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n+            TRACE0(\"DEBUG retry C_EncryptInit\\n\");\n+            rv = (*ckpFunctions->C_EncryptInit)(ckSessionHandle,\n+                ckpMechanism, ckKeyHandle);\n@@ -106,1 +145,1 @@\n-    TRACE1(\"DEBUG C_EncryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    TRACE1(\"DEBUG C_GCMEncryptInitWithRetry: freed pMech = %p\\n\", ckpMechanism);\n@@ -315,1 +354,0 @@\n-    CK_MECHANISM_PTR ckpTemp;\n@@ -333,10 +371,51 @@\n-    if (ckpMechanism->mechanism == CKM_AES_GCM) {\n-        if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n-            \/\/ retry with CKM_GCM_PARAMS structure in pkcs11t.h\n-            TRACE0(\"DEBUG C_DecryptInit: retry with CK_GCM_PARAMS\\n\");\n-            ckpTemp = updateGCMParams(env, ckpMechanism);\n-            if (ckpTemp != NULL) { \/\/ only re-call if conversion succeeds\n-                ckpMechanism = ckpTemp;\n-                rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n-                        ckKeyHandle);\n-            }\n+    TRACE1(\"DEBUG C_DecryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    freeCKMechanismPtr(ckpMechanism);\n+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }\n+\n+    TRACE0(\"FINISHED\\n\");\n+}\n+\n+\/*\n+ * Class:     sun_security_pkcs11_wrapper_PKCS11\n+ * Method:    C_GCMDecryptInitWithRetry\n+ * Signature: (JLsun\/security\/pkcs11\/wrapper\/CK_MECHANISM;JZ)V\n+ * Parametermapping:                    *PKCS11*\n+ * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession\n+ * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism\n+ * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey\n+ * @param   jboolean useNormVerFirst    CK_BBOOL retry (only retry if the first\n+ *                                      init uses the non-normative version)\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_security_pkcs11_wrapper_PKCS11_C_1GCMDecryptInitWithRetry\n+(JNIEnv *env, jobject obj, jlong jSessionHandle,\n+ jobject jMechanism, jlong jKeyHandle, jboolean useNormVerFirst)\n+{\n+    CK_SESSION_HANDLE ckSessionHandle;\n+    CK_MECHANISM_PTR ckpMechanism = NULL;\n+    CK_OBJECT_HANDLE ckKeyHandle;\n+    CK_BBOOL retry = FALSE;\n+    CK_RV rv = 1;\n+\n+    CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);\n+    if (ckpFunctions == NULL) { return; }\n+\n+    ckSessionHandle = jLongToCKULong(jSessionHandle);\n+    ckKeyHandle = jLongToCKULong(jKeyHandle);\n+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);\n+\n+    if ((*env)->ExceptionCheck(env)) { return; }\n+\n+    \/\/ if !useNormVerFirst, then update 'ckpMechanism' in place w\/\n+    \/\/ non-normative GCM params.\n+    retry = (!useNormVerFirst && updateGCMParams(env, ckpMechanism) != NULL);\n+\n+    rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n+        ckKeyHandle);\n+\n+    if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {\n+        \/\/ retry and update 'ckpMechanism' in place w\/ normative GCM params.\n+        if (retry && updateGCMParams(env, ckpMechanism) != NULL) {\n+            TRACE0(\"DEBUG retry C_DecryptInit with normative CK_GCM_PARAMS\\n\");\n+            rv = (*ckpFunctions->C_DecryptInit)(ckSessionHandle, ckpMechanism,\n+                ckKeyHandle);\n@@ -346,1 +425,1 @@\n-    TRACE1(\"DEBUG C_DecryptInit: freed pMech = %p\\n\", ckpMechanism);\n+    TRACE1(\"DEBUG C_GCMDecryptInitWithRetry: freed pMech = %p\\n\", ckpMechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_crypt.c","additions":104,"deletions":25,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,5 +330,1 @@\n-                     if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n-                         TRACE0(\"[ GCM_PARAMS w\/o ulIvBits ]\\n\");\n-                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pIv);\n-                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pAAD);\n-                     } else if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS)) {\n+                     if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS)) {\n@@ -338,0 +334,4 @@\n+                     } else if (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n+                         TRACE0(\"[ GCM_PARAMS w\/o ulIvBits ]\\n\");\n+                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pIv);\n+                         free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)->pAAD);\n@@ -454,3 +454,3 @@\n-\/* This function replaces the CK_GCM_PARAMS_NO_IVBITS structure associated\n- * with the specified CK_MECHANISM structure with CK_GCM_PARAMS\n- * structure.\n+\/* This function updates the specified CK_MECHANISM structure\n+ * and its GCM parameter structure switching between CK_GCM_PARAMS and\n+ * CK_GCM_PARAMS_NO_IVBITS.\n@@ -459,1 +459,1 @@\n- * the to-be-converted CK_GCM_PARAMS_NO_IVBITS structure.\n+ * the to-be-converted CK_GCM_PARAMS \/ CK_GCM_PARAMS_NO_IVBITS structure.\n@@ -461,1 +461,1 @@\n- * converted CK_GCM_PARAMS structure or NULL if no conversion took place.\n+ * converted structure or NULL if no conversion is done.\n@@ -464,9 +464,35 @@\n-    CK_GCM_PARAMS* pGcmParams2 = NULL;\n-    CK_GCM_PARAMS_NO_IVBITS* pParams = NULL;\n-    if ((mechPtr->mechanism == CKM_AES_GCM) &&\n-            (mechPtr->pParameter != NULL_PTR) &&\n-            (mechPtr->ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS))) {\n-        pGcmParams2 = calloc(1, sizeof(CK_GCM_PARAMS));\n-        if (pGcmParams2 == NULL) {\n-            p11ThrowOutOfMemoryError(env, 0);\n-            return NULL;\n+    CK_GCM_PARAMS_PTR pParams;\n+    CK_GCM_PARAMS_NO_IVBITS_PTR pParamsNoIvBits;\n+    CK_ULONG paramLen;\n+\n+    if (mechPtr != NULL) {\n+        paramLen = mechPtr->ulParameterLen;\n+        if (paramLen == sizeof(CK_GCM_PARAMS)) {\n+            \/\/ CK_GCM_PARAMS => CK_GCM_PARAMS_NO_IVBITS\n+            pParams = (CK_GCM_PARAMS*) mechPtr->pParameter;\n+            pParamsNoIvBits = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));\n+            pParamsNoIvBits->pIv = pParams->pIv;\n+            pParamsNoIvBits->ulIvLen = pParams->ulIvLen;\n+            pParamsNoIvBits->pAAD = pParams->pAAD;\n+            pParamsNoIvBits->ulAADLen = pParams->ulAADLen;\n+            pParamsNoIvBits->ulTagBits = pParams->ulTagBits;\n+            mechPtr->pParameter = pParamsNoIvBits;\n+            mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS_NO_IVBITS);\n+            free(pParams);\n+            TRACE0(\"DEBUG update CK_GCM_PARAMS to CK_GCM_PARAMS_NO_IVBITS\\n\");\n+            return mechPtr;\n+        } else if (paramLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {\n+            \/\/ CK_GCM_PARAMS_NO_IVBITS => CK_GCM_PARAMS\n+            pParamsNoIvBits = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr->pParameter;\n+            pParams = calloc(1, sizeof(CK_GCM_PARAMS));\n+            pParams->pIv = pParamsNoIvBits->pIv;\n+            pParams->ulIvLen = pParamsNoIvBits->ulIvLen;\n+            pParams->ulIvBits = pParamsNoIvBits->ulIvLen << 3;\n+            pParams->pAAD = pParamsNoIvBits->pAAD;\n+            pParams->ulAADLen = pParamsNoIvBits->ulAADLen;\n+            pParams->ulTagBits = pParamsNoIvBits->ulTagBits;\n+            mechPtr->pParameter = pParams;\n+            mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n+            free(pParamsNoIvBits);\n+            TRACE0(\"DEBUG update CK_GCM_PARAMS_NO_IVBITS to CK_GCM_PARAMS\\n\");\n+            return mechPtr;\n@@ -474,16 +500,0 @@\n-        pParams = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr->pParameter;\n-        pGcmParams2->pIv = pParams->pIv;\n-        pGcmParams2->ulIvLen = pParams->ulIvLen;\n-        pGcmParams2->ulIvBits = (pGcmParams2->ulIvLen << 3);\n-        pGcmParams2->pAAD = pParams->pAAD;\n-        pGcmParams2->ulAADLen = pParams->ulAADLen;\n-        pGcmParams2->ulTagBits = pParams->ulTagBits;\n-        TRACE1(\"DEBUG updateGCMParams: pMech %p\\n\", mechPtr);\n-        TRACE2(\"\\t=> GCM param w\/o ulIvBits %p => GCM param %p\\n\", pParams,\n-                pGcmParams2);\n-        free(pParams);\n-        mechPtr->pParameter = pGcmParams2;\n-        mechPtr->ulParameterLen = sizeof(CK_GCM_PARAMS);\n-        return mechPtr;\n-    } else {\n-        TRACE0(\"DEBUG updateGCMParams: no conversion done\\n\");\n@@ -491,0 +501,1 @@\n+    TRACE0(\"DEBUG updateGCMParams: no conversion done\\n\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":47,"deletions":36,"binary":false,"changes":83,"status":"modified"}]}