{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.LongFunction;\n@@ -33,1 +34,0 @@\n-import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -51,1 +51,2 @@\n-     * @param features bits specifying CPU features\n+     * @param bitMaskSupplier supplier to get the bit mask for the corresponding VM constant\n+     * @param featuresSupplier supplier to get the bits specifying CPU features\n@@ -57,1 +58,1 @@\n-    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeaturesViaConstantMasks(\n+    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n@@ -60,1 +61,2 @@\n-            long features,\n+            LongFunction<Long> bitMaskSupplier,\n+            LongFunction<Long> featuresSupplier,\n@@ -65,43 +67,1 @@\n-            long bitMask = e.getValue();\n-            String key = e.getKey();\n-            if (key.startsWith(\"VM_Version::CPU_\")) {\n-                String name = key.substring(\"VM_Version::CPU_\".length());\n-                try {\n-                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n-                    if ((features & bitMask) != 0) {\n-                        outFeatures.add(feature);\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    missing.add(name);\n-                }\n-            }\n-        }\n-        if (!missing.isEmpty()) {\n-            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n-        }\n-        return outFeatures;\n-    }\n-\n-    \/**\n-     * Converts a bit mask of CPU features to enum constants.\n-     *\n-     * @param <CPUFeatureType> CPU feature enum type\n-     * @param enumType the class of {@code CPUFeatureType}\n-     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n-     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n-     * @param features bits specifying CPU features\n-     * @param renaming maps from VM feature names to enum constant names where the two differ\n-     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n-     *             enum value\n-     * @return the set of converted values\n-     *\/\n-    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n-                    Class<CPUFeatureType> enumType,\n-                    Map<String, Long> constants,\n-                    long features,\n-                    Map<String, String> renaming) {\n-        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n-        List<String> missing = new ArrayList<>();\n-        for (Entry<String, Long> e : constants.entrySet()) {\n-            long bitIndex = e.getValue();\n-            long bitMask = 1L << bitIndex;\n+            long bitMask = bitMaskSupplier.apply(e.getValue());\n@@ -113,1 +73,1 @@\n-                    if ((features & bitMask) != 0) {\n+                    if ((featuresSupplier.apply(e.getValue()) & bitMask) != 0) {\n@@ -127,53 +87,0 @@\n-    \/**\n-     * Converts CPU features bit map into enum constants.\n-     *\n-     * @param <CPUFeatureType> CPU feature enum type\n-     * @param enumType the class of {@code CPUFeatureType}\n-     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n-     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n-     * @param featuresBitMapAddress pointer to {@code VM_Features::_features_bitmap} field of {@code VM_Version::_features}\n-     * @param featuresBitMapSize size of feature bit map in bytes\n-     * @param renaming maps from VM feature names to enum constant names where the two differ\n-     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n-     *             enum value\n-     * @return the set of converted values\n-     *\/\n-    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n-                    Class<CPUFeatureType> enumType,\n-                    Map<String, Long> constants,\n-                    long featuresBitMapAddress,\n-                    long featuresBitMapSize,\n-                    Map<String, String> renaming) {\n-        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n-        List<String> missing = new ArrayList<>();\n-\n-        for (Entry<String, Long> e : constants.entrySet()) {\n-            String key = e.getKey();\n-            long bitIndex = e.getValue();\n-            if (key.startsWith(\"VM_Version::CPU_\")) {\n-                String name = key.substring(\"VM_Version::CPU_\".length());\n-                try {\n-                    final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n-                    final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n-\n-                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n-\n-                    long featureIndex = bitIndex >>> featuresElementShiftCount;\n-                    long featureBitMask = 1L << (bitIndex & featuresElementMask);\n-                    assert featureIndex < featuresBitMapSize;\n-\n-                    long featuresElement = UNSAFE.getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n-\n-                    if ((featuresElement & featureBitMask) != 0) {\n-                        outFeatures.add(feature);\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    missing.add(name);\n-                }\n-            }\n-        }\n-        if (!missing.isEmpty()) {\n-            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n-        }\n-        return outFeatures;\n-    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":8,"deletions":101,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -25,6 +25,0 @@\n-import static java.util.Collections.emptyMap;\n-import static jdk.vm.ci.common.InitTimer.timer;\n-\n-import java.util.EnumSet;\n-import java.util.Map;\n-\n@@ -47,0 +41,6 @@\n+import java.util.EnumSet;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+import static jdk.vm.ci.common.InitTimer.timer;\n+\n@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> 1L << idx, idx -> config.vmVersionFeatures, emptyMap());\n@@ -127,1 +127,1 @@\n-                    StackIntrospection stackIntrospection) {\n+                                         StackIntrospection stackIntrospection) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import jdk.internal.misc.Unsafe;\n@@ -53,5 +55,9 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class,\n-                                                                                  constants,\n-                                                                                  featuresBitMapAddress,\n-                                                                                  config.vmFeaturesFeaturesSize,\n-                                                                                  renaming);\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n+            return 1L << (idx & featuresElementMask);\n+        }, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            long featureIndex = idx >>> featuresElementShiftCount;\n+            return Unsafe.getUnsafe().getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n+        }, renaming);\n@@ -131,1 +137,1 @@\n-                    StackIntrospection stackIntrospection) {\n+                                         StackIntrospection stackIntrospection) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeaturesViaConstantMasks(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, mask -> mask, _ -> config.vmVersionFeatures, emptyMap());\n@@ -123,1 +123,1 @@\n-                    StackIntrospection stackIntrospection) {\n+                                         StackIntrospection stackIntrospection) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}