{"files":[{"patch":"@@ -48,1 +48,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n@@ -70,26 +69,7 @@\n-    byte[][] compiledClasses;\n-    Class[] loadedClasses;\n-    String[] classNames;\n-\n-    int index = 0;\n-    Map<Class, Object[]> instancesOfClassMap = new HashMap<>();\n-\n-    Map<Class, Map<Object, MethodHandle>> prebindMethods = new ConcurrentHashMap<>();\n-\n-    static final String methodNames[] = {\n-            \"get\"\n-    };\n-\n-    static String B(int count) {\n-        return \"public class B\" + count + \" {\"\n-            + \" \"\n-            + \"    int instA\" +  \" = 0;\"\n-            + \" \"\n-            + \"    int getA() {\"\n-            + \"        return instA;\"\n-            + \"    }\"\n-            + \" \"\n-            + \"    public Integer get( Integer depth) throws Throwable {\"\n-            + \"        return  getA();\"\n-            + \"    }\"\n-            + \"}\";\n+    @Benchmark\n+    public Integer executeOne() throws Throwable {\n+        Class c = chooseClass();\n+        Object r = chooseInstance(c);\n+        MethodHandle m = prebindMethods.get(c).get(r);\n+        assert m != null;\n+        return callTheMethod(m, r);\n@@ -98,0 +78,2 @@\n+    private Map<Class, Object[]> instancesOfClassMap = new HashMap<>();\n+    private Map<Class, Map<Object, MethodHandle>> prebindMethods = new ConcurrentHashMap<>();\n@@ -99,1 +81,1 @@\n-    class BenchLoader extends ClassLoader {\n+    private Class[] loadedClasses;\n@@ -101,3 +83,1 @@\n-        BenchLoader() {\n-            super();\n-        }\n+    private class BenchLoader extends ClassLoader {\n@@ -105,2 +85,10 @@\n-        BenchLoader(ClassLoader parent) {\n-            super(parent);\n+        private static String classString(String name) {\n+            return \"public class \" + name + \" {\"\n+                    + \"    int instA = 0;\"\n+                    + \"    int getA() {\"\n+                    + \"        return instA;\"\n+                    + \"    }\"\n+                    + \"    public Integer get(Integer depth) throws Throwable {\"\n+                    + \"        return getA();\"\n+                    + \"    }\"\n+                    + \"}\";\n@@ -109,10 +97,3 @@\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            if (name.equals(classNames[index])) {\n-                assert compiledClasses[index] != null;\n-                return defineClass(name, compiledClasses[index],\n-                        0,\n-                        (compiledClasses[index]).length);\n-            } else {\n-                return super.findClass(name);\n-            }\n+        private Class<?> generateClass(String name) {\n+            byte[] classBytes = InMemoryJavaCompiler.compile(name, classString(name));\n+            return defineClass(name, classBytes, 0, classBytes.length);\n@@ -122,3 +103,0 @@\n-    MethodHandleStress.BenchLoader loader1 = new MethodHandleStress.BenchLoader();\n-    static  MethodType generatedGetType = MethodType.methodType(Integer.class, Integer.class);\n-\n@@ -127,0 +105,2 @@\n+        MethodHandleStress.BenchLoader loader = new MethodHandleStress.BenchLoader();\n+\n@@ -129,1 +109,0 @@\n-        compiledClasses = new byte[classes][];\n@@ -131,1 +110,0 @@\n-        classNames = new String[classes];\n@@ -134,0 +112,1 @@\n+        MethodType generatedGetType = MethodType.methodType(Integer.class, Integer.class);\n@@ -136,7 +115,2 @@\n-            classNames[i] = \"B\" + i;\n-            compiledClasses[i] = InMemoryJavaCompiler.compile(classNames[i], B(i));\n-        }\n-\n-        for (index = 0; index < compiledClasses.length; index++) {\n-            Class<?> c = loader1.findClass(classNames[index]);\n-            loadedClasses[index] = c;\n+            Class<?> c = loader.generateClass(\"B\" + i);\n+            loadedClasses[i] = c;\n@@ -154,1 +128,1 @@\n-                MethodHandle mh = publicLookup.findVirtual(c, methodNames[0], generatedGetType);\n+                MethodHandle mh = publicLookup.findVirtual(c, \"get\", generatedGetType);\n@@ -157,1 +131,0 @@\n-\n@@ -164,15 +137,7 @@\n-        IntStream.range(0, compiledClasses.length).forEach(n -> {\n-                    IntStream.range(0, methodNames.length).forEach(m -> {\n-                        try {\n-                            IntStream.range(0, 5000).parallel().forEach(x -> {\n-                                try {\n-                                    executeOne();\n-                                } catch (Throwable e) {\n-                                }\n-                            });\n-                        } catch (Throwable e) {\n-                            System.out.println(\"Exception = \" + e);\n-                            e.printStackTrace();\n-                            System.exit(-1);\n-                        }\n-                    });\n+        for (int n = 0; n < classes; n++) {\n+            try {\n+                IntStream.range(0, 5000).parallel().forEach(x -> {\n+                    try {\n+                        executeOne();\n+                    } catch (Throwable e) {\n+                    }\n@@ -180,0 +145,6 @@\n+            } catch (Throwable e) {\n+                System.out.println(\"Exception = \" + e);\n+                e.printStackTrace();\n+                System.exit(-1);\n+            }\n+        }\n@@ -198,1 +169,1 @@\n-    static final Integer recurse = new Integer(1);\n+    static final Integer recurse = 1;\n@@ -201,2 +172,2 @@\n-    Integer callTheMethod(MethodHandle m, Object r) throws Throwable {\n-        return (Integer) m.invokeExact( recurse );\n+    int callTheMethod(MethodHandle m, Object r) throws Throwable {\n+        return (Integer) m.invokeExact(recurse);\n@@ -204,20 +175,0 @@\n-\n-    int executeOne() throws Throwable {\n-        Class c = chooseClass();\n-        Object r = chooseInstance(c);\n-        MethodHandle m = prebindMethods.get(c).get(r);\n-        assert m != null;\n-        return callTheMethod(m, r);\n-    }\n-\n-    @Benchmark\n-    public void work(Blackhole bh) throws Exception {\n-        \/\/ Call a method of a random instance of a random class\n-        try {\n-            bh.consume(executeOne());\n-        } catch (Throwable e) {\n-            System.out.println(\"Exception = \" + e);\n-            e.printStackTrace();\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/runtime\/MethodHandleStress.java","additions":46,"deletions":95,"binary":false,"changes":141,"status":"modified"}]}