{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,0 +436,14 @@\n+    \/**\n+     * Returns whether any of the stages in the (entire) pipeline is short-circuiting\n+     * or not.\n+     * @return {@code true} if any stage in this pipeline is short-circuiting,\n+     *         {@code false} if not.\n+     *\/\n+    protected final boolean isShortCircuitingPipeline() {\n+        for (var u = sourceStage.nextStage; u != null; u = u.nextStage) {\n+            if (StreamOpFlag.SHORT_CIRCUIT.isKnown(u.combinedFlags))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.function.IntConsumer;\n@@ -266,3 +267,8 @@\n-                return new Sink.ChainedDouble<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                final DoubleConsumer fastPath =\n+                        isShortCircuitingPipeline()\n+                                ? null\n+                                : (sink instanceof DoubleConsumer dc)\n+                                ? dc\n+                                : sink::accept;\n+                final class FlatMap implements Sink.OfDouble, DoublePredicate {\n+                    boolean cancel;\n@@ -270,2 +276,2 @@\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    DoubleConsumer downstreamAsDouble = downstream::accept;\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -274,7 +280,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(double t) {\n-                        try (DoubleStream result = mapper.apply(t)) {\n+                    public void accept(double e) {\n+                        try (DoubleStream result = mapper.apply(e)) {\n@@ -282,7 +283,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsDouble);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -295,6 +293,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -302,1 +295,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(double output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/DoublePipeline.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.util.Comparator;\n-import java.util.Iterator;\n-import java.util.Optional;\n@@ -38,1 +35,0 @@\n-import java.util.function.BiFunction;\n@@ -43,1 +39,0 @@\n-import java.util.function.Predicate;\n@@ -45,3 +40,0 @@\n-import java.util.function.ToDoubleFunction;\n-import java.util.function.ToIntFunction;\n-import java.util.function.ToLongFunction;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,11 +300,11 @@\n-                return new Sink.ChainedInt<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    IntConsumer downstreamAsInt = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                final IntConsumer fastPath =\n+                        isShortCircuitingPipeline()\n+                                ? null\n+                                : (sink instanceof IntConsumer ic)\n+                                ? ic\n+                                : sink::accept;\n+                final class FlatMap implements Sink.OfInt, IntPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -313,2 +313,2 @@\n-                    public void accept(int t) {\n-                        try (IntStream result = mapper.apply(t)) {\n+                    public void accept(int e) {\n+                        try (IntStream result = mapper.apply(e)) {\n@@ -316,7 +316,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsInt);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -329,6 +326,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -336,1 +328,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(int output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/IntPipeline.java","additions":31,"deletions":28,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.IntConsumer;\n@@ -282,11 +283,11 @@\n-                return new Sink.ChainedLong<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    LongConsumer downstreamAsLong = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                final LongConsumer fastPath =\n+                        isShortCircuitingPipeline()\n+                                ? null\n+                                : (sink instanceof LongConsumer lc)\n+                                ? lc\n+                                : sink::accept;\n+                final class FlatMap implements Sink.OfLong, LongPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -295,2 +296,2 @@\n-                    public void accept(long t) {\n-                        try (LongStream result = mapper.apply(t)) {\n+                    public void accept(long e) {\n+                        try (LongStream result = mapper.apply(e)) {\n@@ -298,7 +299,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsLong);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -311,6 +309,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -318,1 +311,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(long output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/LongPipeline.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.function.DoublePredicate;\n@@ -42,0 +43,1 @@\n+import java.util.function.IntPredicate;\n@@ -43,0 +45,1 @@\n+import java.util.function.LongPredicate;\n@@ -277,3 +280,3 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                boolean shorts = isShortCircuitingPipeline();\n+                final class FlatMap implements Sink<P_OUT>, Predicate<R> {\n+                    boolean cancel;\n@@ -281,4 +284,2 @@\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -287,2 +288,2 @@\n-                    public void accept(P_OUT u) {\n-                        try (Stream<? extends R> result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (Stream<? extends R> result = mapper.apply(e)) {\n@@ -290,7 +291,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstream);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstream));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink);\n@@ -303,6 +301,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -310,1 +303,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(R output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -322,6 +326,11 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    IntConsumer downstreamAsInt = downstream::accept;\n+                IntConsumer fastPath =\n+                    isShortCircuitingPipeline()\n+                        ? null\n+                        : (sink instanceof IntConsumer ic)\n+                            ? ic\n+                            : sink::accept;\n+                final class FlatMap implements Sink<P_OUT>, IntPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -330,7 +339,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(P_OUT u) {\n-                        try (IntStream result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (IntStream result = mapper.apply(e)) {\n@@ -338,7 +342,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsInt);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -351,2 +352,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -354,1 +354,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(int output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -366,6 +377,11 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    DoubleConsumer downstreamAsDouble = downstream::accept;\n+                DoubleConsumer fastPath =\n+                    isShortCircuitingPipeline()\n+                        ? null\n+                        : (sink instanceof DoubleConsumer dc)\n+                            ? dc\n+                            : sink::accept;\n+                final class FlatMap implements Sink<P_OUT>, DoublePredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -374,7 +390,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(P_OUT u) {\n-                        try (DoubleStream result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (DoubleStream result = mapper.apply(e)) {\n@@ -382,7 +393,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsDouble);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -395,2 +403,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -398,1 +405,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(double output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -411,11 +429,11 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    LongConsumer downstreamAsLong = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                LongConsumer fastPath =\n+                    isShortCircuitingPipeline()\n+                        ? null\n+                        : (sink instanceof LongConsumer lc)\n+                            ? lc\n+                            : sink::accept;\n+                final class FlatMap implements Sink<P_OUT>, LongPredicate {\n+                    boolean cancel;\n+\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -424,2 +442,2 @@\n-                    public void accept(P_OUT u) {\n-                        try (LongStream result = mapper.apply(u)) {\n+                    public void accept(P_OUT e) {\n+                        try (LongStream result = mapper.apply(e)) {\n@@ -427,7 +445,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsLong);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));\n-                                }\n+                                if (fastPath == null)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(fastPath);\n@@ -440,2 +455,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -443,1 +457,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(long output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReferencePipeline.java","additions":118,"deletions":93,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8044047 8076458 8075939\n+ * @bug 8044047 8076458 8075939 8196106\n@@ -276,0 +276,27 @@\n+\n+    @Test\n+    public void testTerminationOfNestedInfiniteStreams() {\n+        var refExpected = Stream.generate(() -> \"\").limit(5).toList();\n+        var refResult = Stream.generate(() -> \"\")\n+              .flatMap(c -> Stream.generate(() -> c).flatMap(x -> Stream.generate(() -> x)))\n+              .limit(5).toList();\n+        assertEquals(refResult, refExpected);\n+\n+        var intExpected = IntStream.generate(() -> 1).limit(5).sum();\n+        var intResult = IntStream.generate(() -> 1)\n+                .flatMap(c -> IntStream.generate(() -> c).flatMap(x -> IntStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(intResult, intExpected);\n+\n+        var longExpected = LongStream.generate(() -> 1L).limit(5).sum();\n+        var longResult = LongStream.generate(() -> 1L)\n+                .flatMap(c -> LongStream.generate(() -> c).flatMap(x -> LongStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(longResult, longExpected);\n+\n+        var doubleExpected = DoubleStream.generate(() -> 0d).limit(5).sum();\n+        var doubleResult = DoubleStream.generate(() -> 0d)\n+                .flatMap(c -> DoubleStream.generate(() -> c).flatMap(x -> DoubleStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(doubleResult, doubleExpected);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FlatMapOpTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops;\n+\n+public class DoubleAccumulator {\n+\n+    double acc;\n+\n+    public DoubleAccumulator() {\n+        acc = 0;\n+    }\n+\n+    public void add(double v) {\n+        acc += v;\n+    }\n+\n+    public void merge(DoubleAccumulator other) {\n+        acc += other.acc;\n+    }\n+\n+    public double get() {\n+        return acc;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/DoubleAccumulator.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.DoubleAccumulator;\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.LongFunction;\n+import java.util.function.DoubleFunction;\n+import java.util.stream.Stream;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.IntStream;\n+import java.util.Arrays;\n+\n+\/**\n+ * Benchmark for flatMap() operation.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class FlatMap {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    private int size;\n+\n+    private Function<Long, Stream<Long>> funArrayStream;\n+    private Function<Long, Stream<Long>> funIterateStream;\n+    private LongFunction<LongStream> funLongStream;\n+    private LongFunction<LongStream> funIterateLongStream;\n+    private IntFunction<IntStream> funIntStream;\n+    private IntFunction<IntStream> funIterateIntStream;\n+    private DoubleFunction<DoubleStream> funDoubleStream;\n+    private DoubleFunction<DoubleStream> funIterateDoubleStream;\n+\n+    private Long[] cachedRefArray;\n+    private int[] cachedIntArray;\n+    private long[] cachedLongArray;\n+    private double[] cachedDoubleArray;\n+\n+    @Setup\n+    public void setup() {\n+        final int cachedSize = size;\n+        cachedRefArray = new Long[cachedSize];\n+        cachedIntArray = new int[cachedSize];\n+        cachedLongArray = new long[cachedSize];\n+        cachedDoubleArray = new double[cachedSize];\n+        for(int i = 0;i < cachedRefArray.length;++i) {\n+            cachedRefArray[i]    = Long.valueOf(i);\n+            cachedIntArray[i]    = i;\n+            cachedLongArray[i]   = i;\n+            cachedDoubleArray[i] = i;\n+        }\n+\n+        funArrayStream = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Arrays.stream(cachedRefArray);\n+        } };\n+        funIterateStream = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Stream.iterate(0L, i -> i + 1).limit(cachedSize); } };\n+        funLongStream = new LongFunction<LongStream>() { @Override public LongStream apply(long l) {\n+            return Arrays.stream(cachedLongArray); } };\n+        funIterateLongStream = new LongFunction<LongStream>() { @Override public LongStream apply(long l) {\n+            return LongStream.iterate(0L, i -> i + 1).limit(cachedSize); } };\n+        funIntStream = new IntFunction<IntStream>() { @Override public IntStream apply(int i) {\n+            return Arrays.stream(cachedIntArray); } };\n+        funIterateIntStream = new IntFunction<IntStream>() { @Override public IntStream apply(int i) {\n+            return IntStream.iterate(0, ii -> ii + 1).limit(cachedSize); } };\n+        funDoubleStream = new DoubleFunction<DoubleStream>() { @Override public DoubleStream apply(double d) {\n+            return Arrays.stream(cachedDoubleArray); } };\n+        funIterateDoubleStream = new DoubleFunction<DoubleStream>() { @Override public DoubleStream apply(double d) {\n+            return DoubleStream.iterate(0d, i -> i + 1d).limit(cachedSize); } };\n+    }\n+\n+    @Benchmark\n+    public long seq_array_ref() {\n+        return funArrayStream.apply(0L)\n+                .flatMap(funArrayStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array_ref() {\n+        return funArrayStream.apply(0L)\n+                .parallel()\n+                .flatMap(funArrayStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_array_long() {\n+        return funLongStream.apply(0L)\n+                .flatMap(funLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array_long() {\n+        return funLongStream.apply(0L)\n+                .parallel()\n+                .flatMap(funLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_array_int() {\n+        return funIntStream.apply(0)\n+                .flatMap(funIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array_int() {\n+        return funIntStream.apply(0)\n+                .parallel()\n+                .flatMap(funIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double seq_array_double() {\n+        return funDoubleStream.apply(0d)\n+                .flatMap(funDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double par_array_double() {\n+        return funDoubleStream.apply(0d)\n+                .parallel()\n+                .flatMap(funDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_iterate_ref() {\n+        return funIterateStream.apply(0L)\n+                .flatMap(funIterateStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate_ref() {\n+        return funIterateStream.apply(0L)\n+                .parallel()\n+                .flatMap(funIterateStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+\n+    @Benchmark\n+    public long seq_iterate_long() {\n+        return funIterateLongStream.apply(0L)\n+                .flatMap(funIterateLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate_long() {\n+        return funIterateLongStream.apply(0L)\n+                .parallel()\n+                .flatMap(funIterateLongStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_iterate_int() {\n+        return funIterateIntStream.apply(0)\n+                .flatMap(funIterateIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate_int() {\n+        return funIterateIntStream.apply(0)\n+                .parallel()\n+                .flatMap(funIterateIntStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double seq_iterate_double() {\n+        return funIterateDoubleStream.apply(0d)\n+                .flatMap(funIterateDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public double par_iterate_double() {\n+        return funIterateDoubleStream.apply(0d)\n+                .parallel()\n+                .flatMap(funIterateDoubleStream)\n+                .collect(DoubleAccumulator::new, DoubleAccumulator::add, DoubleAccumulator::merge).get();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FlatMap.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}