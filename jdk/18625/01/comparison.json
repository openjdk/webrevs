{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,0 +436,15 @@\n+    \/**\n+     * Returns whether any of the stages in the (entire) pipeline is short-circuiting\n+     * or not.\n+     * @return {@code true} if any stage in this pipeline is stateful,\n+     *         {@code false} if not.\n+     *\/\n+    protected final boolean isShortCircuitingPipeline() {\n+        var result = false;\n+        for (var u = sourceStage.nextStage;\n+             u != null && !(result = StreamOpFlag.SHORT_CIRCUIT.isKnown(u.combinedFlags));\n+             u = u.nextStage) {\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,3 +266,3 @@\n-                return new Sink.ChainedDouble<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                class FlatMap implements Sink.OfDouble, DoublePredicate {\n+                    boolean cancel;\n+                    private final boolean shorts = isShortCircuitingPipeline();\n@@ -270,2 +270,2 @@\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    DoubleConsumer downstreamAsDouble = downstream::accept;\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -274,7 +274,2 @@\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n-\n-                    @Override\n-                    public void accept(double t) {\n-                        try (DoubleStream result = mapper.apply(t)) {\n+                    public void accept(double input) {\n+                        try (DoubleStream result = mapper.apply(input)) {\n@@ -282,7 +277,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsDouble);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -295,6 +287,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -302,1 +289,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(double output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/DoublePipeline.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.util.Comparator;\n-import java.util.Iterator;\n-import java.util.Optional;\n@@ -38,1 +35,0 @@\n-import java.util.function.BiFunction;\n@@ -43,1 +39,0 @@\n-import java.util.function.Predicate;\n@@ -45,3 +40,0 @@\n-import java.util.function.ToDoubleFunction;\n-import java.util.function.ToIntFunction;\n-import java.util.function.ToLongFunction;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,6 +300,3 @@\n-                return new Sink.ChainedInt<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    IntConsumer downstreamAsInt = downstream::accept;\n+                class FlatMap implements Sink.OfInt, IntPredicate {\n+                    boolean cancel;\n+                    private final boolean shorts = isShortCircuitingPipeline();\n@@ -307,4 +304,2 @@\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -313,2 +308,2 @@\n-                    public void accept(int t) {\n-                        try (IntStream result = mapper.apply(t)) {\n+                    public void accept(int input) {\n+                        try (IntStream result = mapper.apply(input)) {\n@@ -316,7 +311,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsInt);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -329,6 +321,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -336,1 +323,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(int output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/IntPipeline.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,6 +282,3 @@\n-                return new Sink.ChainedLong<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n-\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    LongConsumer downstreamAsLong = downstream::accept;\n+                final var shorts = isShortCircuitingPipeline();\n+                class FlatMap implements Sink.OfLong, LongPredicate {\n+                    boolean cancel;\n@@ -289,4 +286,2 @@\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -295,2 +290,2 @@\n-                    public void accept(long t) {\n-                        try (LongStream result = mapper.apply(t)) {\n+                    public void accept(long input) {\n+                        try (LongStream result = mapper.apply(input)) {\n@@ -298,7 +293,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsLong);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -311,6 +303,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -318,1 +305,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(long output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/LongPipeline.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.function.DoublePredicate;\n@@ -42,0 +43,1 @@\n+import java.util.function.IntPredicate;\n@@ -43,0 +45,1 @@\n+import java.util.function.LongPredicate;\n@@ -277,3 +280,3 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                class FlatMap implements Sink<P_OUT>, Predicate<R> {\n+                    boolean cancel;\n+                    private final boolean shorts = isShortCircuitingPipeline();\n@@ -281,4 +284,2 @@\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -290,7 +291,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstream);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstream));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -303,6 +301,1 @@\n-                        \/\/ If this method is called then an operation within the stream\n-                        \/\/ pipeline is short-circuiting (see AbstractPipeline.copyInto).\n-                        \/\/ Note that we cannot differentiate between an upstream or\n-                        \/\/ downstream operation\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -310,1 +303,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(R output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -322,3 +326,3 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                class FlatMap implements Sink<P_OUT>, IntPredicate {\n+                    boolean cancel;\n+                    private final boolean shorts = isShortCircuitingPipeline();\n@@ -326,7 +330,2 @@\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    IntConsumer downstreamAsInt = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -338,7 +337,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsInt);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsInt));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -351,2 +347,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -354,1 +349,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(int output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -366,3 +372,3 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                class FlatMap implements Sink<P_OUT>, DoublePredicate {\n+                    private final boolean shorts = isShortCircuitingPipeline();\n+                    boolean cancel;\n@@ -370,7 +376,2 @@\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    DoubleConsumer downstreamAsDouble = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -382,7 +383,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsDouble);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsDouble));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -395,2 +393,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -398,1 +395,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(double output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n@@ -411,3 +419,3 @@\n-                return new Sink.ChainedReference<>(sink) {\n-                    \/\/ true if cancellationRequested() has been called\n-                    boolean cancellationRequestedCalled;\n+                class FlatMap implements Sink<P_OUT>, LongPredicate {\n+                    private final boolean shorts = isShortCircuitingPipeline();\n+                    boolean cancel;\n@@ -415,7 +423,2 @@\n-                    \/\/ cache the consumer to avoid creation on every accepted element\n-                    LongConsumer downstreamAsLong = downstream::accept;\n-\n-                    @Override\n-                    public void begin(long size) {\n-                        downstream.begin(-1);\n-                    }\n+                    @Override public void begin(long size) { sink.begin(-1); }\n+                    @Override public void end() { sink.end(); }\n@@ -427,7 +430,4 @@\n-                                if (!cancellationRequestedCalled) {\n-                                    result.sequential().forEach(downstreamAsLong);\n-                                } else {\n-                                    var s = result.sequential().spliterator();\n-                                    do {\n-                                    } while (!downstream.cancellationRequested() && s.tryAdvance(downstreamAsLong));\n-                                }\n+                                if (shorts)\n+                                    result.sequential().allMatch(this);\n+                                else\n+                                    result.sequential().forEach(sink::accept);\n@@ -440,2 +440,1 @@\n-                        cancellationRequestedCalled = true;\n-                        return downstream.cancellationRequested();\n+                        return cancel || (cancel |= sink.cancellationRequested());\n@@ -443,1 +442,12 @@\n-                };\n+\n+                    @Override\n+                    public boolean test(long output) {\n+                        if (!cancel) {\n+                            sink.accept(output);\n+                            return !(cancel |= sink.cancellationRequested());\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return new FlatMap();\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReferencePipeline.java","additions":92,"deletions":82,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8044047 8076458 8075939\n+ * @bug 8044047 8076458 8075939 8196106\n@@ -276,0 +276,27 @@\n+\n+    @Test\n+    public void testTerminationOfNestedInfiniteStreams() {\n+        var refExpected = Stream.generate(() -> \"\").limit(5).toList();\n+        var refResult = Stream.generate(() -> \"\")\n+              .flatMap(c -> Stream.generate(() -> c).flatMap(x -> Stream.generate(() -> x)))\n+              .limit(5).toList();\n+        assertEquals(refResult, refExpected);\n+\n+        var intExpected = IntStream.generate(() -> 1).limit(5).sum();\n+        var intResult = IntStream.generate(() -> 1)\n+                .flatMap(c -> IntStream.generate(() -> c).flatMap(x -> IntStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(intResult, intExpected);\n+\n+        var longExpected = LongStream.generate(() -> 1L).limit(5).sum();\n+        var longResult = LongStream.generate(() -> 1L)\n+                .flatMap(c -> LongStream.generate(() -> c).flatMap(x -> LongStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(longResult, longExpected);\n+\n+        var doubleExpected = DoubleStream.generate(() -> 0d).limit(5).sum();\n+        var doubleResult = DoubleStream.generate(() -> 0d)\n+                .flatMap(c -> DoubleStream.generate(() -> c).flatMap(x -> DoubleStream.generate(() -> x)))\n+                .limit(5).sum();\n+        assertEquals(doubleResult, doubleExpected);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/FlatMapOpTest.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.bench.java.util.stream.ops.LongAccumulator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import java.util.Arrays;\n+\n+\/**\n+ * Benchmark for flatMap() operation.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class FlatMap {\n+\n+    \/**\n+     * Implementation notes:\n+     *   - parallel version requires thread-safe sink, we use the same for sequential version for better comparison\n+     *   - operations are explicit inner classes to untangle unwanted lambda effects\n+     *   - the result of applying consecutive operations is the same, in order to have the same number of elements in sink\n+     *\/\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    private int size;\n+\n+    private Function<Long, Stream<Long>> funArrayStream;\n+    private Function<Long, Stream<Long>> funIterateStream;\n+\n+    private Long[] cachedInputArray;\n+\n+    @Setup\n+    public void setup() {\n+        final int cachedSize = size;\n+        cachedInputArray = new Long[cachedSize];\n+        for(int i = 0;i < cachedInputArray.length;++i)\n+            cachedInputArray[i] = Long.valueOf(i);\n+\n+        funArrayStream = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Arrays.stream(cachedInputArray);\n+        } };\n+        funIterateStream = new Function<Long, Stream<Long>>() { @Override public Stream<Long> apply(Long l) {\n+            return Stream.iterate(0L, i -> i + 1).limit(cachedSize);\n+        } };\n+    }\n+\n+    @Benchmark\n+    public long seq_array() {\n+        return funArrayStream.apply(0L)\n+                .flatMap(funArrayStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_array() {\n+        return funArrayStream.apply(0L)\n+                .parallel()\n+                .flatMap(funArrayStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long seq_iterate() {\n+        return funIterateStream.apply(0L)\n+                .flatMap(funIterateStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+    @Benchmark\n+    public long par_iterate() {\n+        return funIterateStream.apply(0L)\n+                .parallel()\n+                .flatMap(funIterateStream)\n+                .collect(LongAccumulator::new, LongAccumulator::add, LongAccumulator::merge).get();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FlatMap.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}