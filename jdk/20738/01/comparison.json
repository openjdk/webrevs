{"files":[{"patch":"@@ -642,26 +642,28 @@\n-        if (value instanceof Integer iVal)\n-            return switch (iVal) {\n-                case -1 -> iconst_m1();\n-                case  0 -> iconst_0();\n-                case  1 -> iconst_1();\n-                case  2 -> iconst_2();\n-                case  3 -> iconst_3();\n-                case  4 -> iconst_4();\n-                case  5 -> iconst_5();\n-                default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n-                         : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n-                         : ldc(constantPool().intEntry(iVal));\n-            };\n-        if (value instanceof Long lVal)\n-            return lVal == 0l ? lconst_0()\n-                 : lVal == 1l ? lconst_1()\n-                 : ldc(constantPool().longEntry(lVal));\n-        if (value instanceof Float fVal)\n-            return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n-                 : fVal == 1.0f ? fconst_1()\n-                 : fVal == 2.0f ? fconst_2()\n-                 : ldc(constantPool().floatEntry(fVal));\n-        if (value instanceof Double dVal)\n-            return Double.doubleToRawLongBits(dVal) == 0l ? dconst_0()\n-                 : dVal == 1.0d ? dconst_1()\n-                 : ldc(constantPool().doubleEntry(dVal));\n+        if (value instanceof Number) {\n+            if (value instanceof Integer iVal)\n+                return switch (iVal) {\n+                    case -1 -> iconst_m1();\n+                    case 0 -> iconst_0();\n+                    case 1 -> iconst_1();\n+                    case 2 -> iconst_2();\n+                    case 3 -> iconst_3();\n+                    case 4 -> iconst_4();\n+                    case 5 -> iconst_5();\n+                    default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n+                            : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n+                            : ldc(constantPool().intEntry(iVal));\n+                };\n+            if (value instanceof Long lVal)\n+                return lVal == 0L ? lconst_0()\n+                        : lVal == 1L ? lconst_1()\n+                        : ldc(constantPool().longEntry(lVal));\n+            if (value instanceof Float fVal)\n+                return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n+                        : fVal == 1.0f ? fconst_1()\n+                        : fVal == 2.0f ? fconst_2()\n+                        : ldc(constantPool().floatEntry(fVal));\n+            if (value instanceof Double dVal)\n+                return Double.doubleToRawLongBits(dVal) == 0L ? dconst_0()\n+                        : dVal == 1.0d ? dconst_1()\n+                        : ldc(constantPool().doubleEntry(dVal));\n+        }\n@@ -2125,4 +2127,1 @@\n-        return with(ConstantInstruction.ofLoad(\n-                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n-                : entry.index() > 0xff ? Opcode.LDC_W\n-                : Opcode.LDC, entry));\n+        return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":29,"deletions":30,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1320,5 +1320,0 @@\n-        @Override\n-        public void writeTo(DirectCodeBuilder writer) {\n-            super.writeTo(writer);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -311,0 +311,6 @@\n+    public static Opcode ldcOpcode(LoadableConstantEntry entry) {\n+        return entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n+                : entry.index() > 0xff ? Opcode.LDC_W\n+                : Opcode.LDC;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,9 +27,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n@@ -46,1 +37,0 @@\n-import java.lang.classfile.instruction.SwitchCase;\n@@ -58,0 +48,1 @@\n+import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -62,0 +53,10 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n@@ -63,8 +64,1 @@\n-import static java.lang.classfile.Opcode.GOTO;\n-import static java.lang.classfile.Opcode.GOTO_W;\n-import static java.lang.classfile.Opcode.IINC;\n-import static java.lang.classfile.Opcode.IINC_W;\n-import static java.lang.classfile.Opcode.JSR;\n-import static java.lang.classfile.Opcode.JSR_W;\n-import static java.lang.classfile.Opcode.LDC2_W;\n-import static java.lang.classfile.Opcode.LDC_W;\n+import static java.lang.classfile.Opcode.*;\n@@ -780,0 +774,700 @@\n+\n+    \/\/ Fast overrides to avoid intermediate instructions\n+    \/\/ These are helpful for direct class building\n+\n+    @Override\n+    public CodeBuilder return_(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.returnOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder storeLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.storeOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder loadLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.loadOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invoke(Opcode opcode, MemberRefEntry ref) {\n+        if (opcode == Opcode.INVOKEINTERFACE) {\n+            int slots = Util.parameterSlots(Util.methodTypeSymbol(ref.nameAndType())) + 1;\n+            writeInvokeInterface(opcode, (InterfaceMethodRefEntry) ref, slots);\n+        } else {\n+            writeInvokeNormal(opcode, ref);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fieldAccess(Opcode opcode, FieldRefEntry ref) {\n+        writeFieldAccess(opcode, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayLoad(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayLoadOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayStore(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayStoreOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder branch(Opcode op, Label target) {\n+        writeBranch(op, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n+        BytecodeHelpers.validateValue(opcode, value);\n+        \/\/ avoid non-local enum switch for bootstrap\n+        if (opcode == BIPUSH || opcode == SIPUSH) {\n+            writeArgumentConstant(opcode, ((Number) value).intValue());\n+        } else if (opcode == LDC || opcode == LDC_W || opcode == LDC2_W) {\n+            writeLoadConstant(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n+        } else {\n+            \/\/ intrinsics\n+            writeBytecode(opcode);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder nop() {\n+        writeBytecode(NOP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aconst_null() {\n+        writeBytecode(Opcode.ACONST_NULL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder anewarray(ClassEntry entry) {\n+        writeNewReferenceArray(entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arraylength() {\n+        writeBytecode(ARRAYLENGTH);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder athrow() {\n+        writeBytecode(ATHROW);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder bipush(int b) {\n+        BytecodeHelpers.validateBIPUSH(b);\n+        writeArgumentConstant(BIPUSH, b);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder checkcast(ClassEntry type) {\n+        writeTypeCheck(CHECKCAST, type);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2f() {\n+        writeBytecode(D2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2i() {\n+        writeBytecode(D2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2l() {\n+        writeBytecode(D2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dadd() {\n+        writeBytecode(DADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpg() {\n+        writeBytecode(DCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpl() {\n+        writeBytecode(DCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_0() {\n+        writeBytecode(DCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_1() {\n+        writeBytecode(DCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ddiv() {\n+        writeBytecode(DDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dmul() {\n+        writeBytecode(DMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dneg() {\n+        writeBytecode(DNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder drem() {\n+        writeBytecode(DREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dsub() {\n+        writeBytecode(DSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup() {\n+        writeBytecode(DUP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2() {\n+        writeBytecode(DUP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x1() {\n+        writeBytecode(DUP2_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x2() {\n+        writeBytecode(DUP2_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x1() {\n+        writeBytecode(DUP_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x2() {\n+        writeBytecode(DUP_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2d() {\n+        writeBytecode(F2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2i() {\n+        writeBytecode(F2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2l() {\n+        writeBytecode(F2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fadd() {\n+        writeBytecode(FADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpg() {\n+        writeBytecode(FCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpl() {\n+        writeBytecode(FCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_0() {\n+        writeBytecode(FCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_1() {\n+        writeBytecode(FCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_2() {\n+        writeBytecode(FCONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fdiv() {\n+        writeBytecode(FDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fmul() {\n+        writeBytecode(FMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fneg() {\n+        writeBytecode(FNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder frem() {\n+        writeBytecode(FREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fsub() {\n+        writeBytecode(FSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2b() {\n+        writeBytecode(I2B);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2c() {\n+        writeBytecode(I2C);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2d() {\n+        writeBytecode(I2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2f() {\n+        writeBytecode(I2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2l() {\n+        writeBytecode(I2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2s() {\n+        writeBytecode(I2S);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iadd() {\n+        writeBytecode(IADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iand() {\n+        writeBytecode(IAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_0() {\n+        writeBytecode(ICONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_1() {\n+        writeBytecode(ICONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_2() {\n+        writeBytecode(ICONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_3() {\n+        writeBytecode(ICONST_3);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_4() {\n+        writeBytecode(ICONST_4);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_5() {\n+        writeBytecode(ICONST_5);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_m1() {\n+        writeBytecode(ICONST_M1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder idiv() {\n+        writeBytecode(IDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iinc(int slot, int val) {\n+        writeIncrement(slot, val);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder imul() {\n+        writeBytecode(IMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ineg() {\n+        writeBytecode(INEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder instanceOf(ClassEntry target) {\n+        writeTypeCheck(INSTANCEOF, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokedynamic(InvokeDynamicEntry ref) {\n+        writeInvokeDynamic(ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokeinterface(InterfaceMethodRefEntry ref) {\n+        writeInvokeInterface(INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokevirtual(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKEVIRTUAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ior() {\n+        writeBytecode(IOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder irem() {\n+        writeBytecode(IREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishl() {\n+        writeBytecode(ISHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishr() {\n+        writeBytecode(ISHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder isub() {\n+        writeBytecode(ISUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iushr() {\n+        writeBytecode(IUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ixor() {\n+        writeBytecode(IXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lookupswitch(Label defaultTarget, List<SwitchCase> cases) {\n+        writeLookupSwitch(defaultTarget, cases);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2d() {\n+        writeBytecode(L2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2f() {\n+        writeBytecode(L2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2i() {\n+        writeBytecode(L2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ladd() {\n+        writeBytecode(LADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder land() {\n+        writeBytecode(LAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lcmp() {\n+        writeBytecode(LCMP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_0() {\n+        writeBytecode(LCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_1() {\n+        writeBytecode(LCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldc(LoadableConstantEntry entry) {\n+        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldiv() {\n+        writeBytecode(LDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lmul() {\n+        writeBytecode(LMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lneg() {\n+        writeBytecode(LNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lor() {\n+        writeBytecode(LOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lrem() {\n+        writeBytecode(LREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshl() {\n+        writeBytecode(LSHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshr() {\n+        writeBytecode(LSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lsub() {\n+        writeBytecode(LSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lushr() {\n+        writeBytecode(LUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lxor() {\n+        writeBytecode(LXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorenter() {\n+        writeBytecode(MONITORENTER);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorexit() {\n+        writeBytecode(MONITOREXIT);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder multianewarray(ClassEntry array, int dims) {\n+        writeNewMultidimensionalArray(dims, array);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder new_(ClassEntry clazz) {\n+        writeNewObject(clazz);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder newarray(TypeKind typeKind) {\n+        int atype = typeKind.newarrayCode(); \/\/ implicit null check\n+        if (atype < 0)\n+            throw new IllegalArgumentException(\"Illegal component type: \" + typeKind.typeName());\n+        writeNewPrimitiveArray(atype);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop() {\n+        writeBytecode(POP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop2() {\n+        writeBytecode(POP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder sipush(int s) {\n+        BytecodeHelpers.validateSIPUSH(s);\n+        writeArgumentConstant(SIPUSH, s);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder swap() {\n+        writeBytecode(SWAP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder tableswitch(int low, int high, Label defaultTarget, List<SwitchCase> cases) {\n+        writeTableSwitch(low, high, defaultTarget, cases);\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":712,"deletions":18,"binary":false,"changes":730,"status":"modified"}]}