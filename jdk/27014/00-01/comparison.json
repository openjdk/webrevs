{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485 8333456 8335668 8366400\n+ * @bug 8327640 8331485 8333456 8335668\n@@ -165,8 +165,0 @@\n-    @Test \/\/ Non-localized, only run once\n-    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n-    public void invalidPositionParseTest() {\n-        \/\/ -1 index should fail properly. Ensure SIOOBE not thrown during\n-        \/\/ affix matching when position may be less than 0\n-        assertNull(assertDoesNotThrow(() -> new DecimalFormat().parse(\"1\", new ParsePosition(-1))));\n-    }\n-\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,6 +24,0 @@\n-\/**\n- * @test\n- * @bug 4109023 4153060 4153061\n- * @summary test ParsePosition and FieldPosition\n- * @run junit PositionTest\n- *\/\n@@ -42,2 +36,6 @@\n-import java.text.*;\n-import java.io.*;\n+\/*\n+ * @test\n+ * @bug 4109023 4153060 4153061 8366400\n+ * @summary test ParsePosition and FieldPosition\n+ * @run junit PositionTest\n+ *\/\n@@ -47,0 +45,8 @@\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -51,0 +57,44 @@\n+    \/\/ Parsing text which contains un-parseable data, but the index\n+    \/\/ begins at the valid portion. Ensure PP is properly updated.\n+    @Test\n+    public void modifiedPositionTest() {\n+        var df = new DecimalFormat(\"YY#\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        var pp = new ParsePosition(9);\n+        assertEquals(123L, assertDoesNotThrow(() -> df.parse(\"FOOBARBAZYY123\", pp)));\n+        assertEquals(-1, pp.getErrorIndex());\n+        assertEquals(14, pp.getIndex());\n+    }\n+\n+    \/\/ Clearly invalid index value that could not work under any scenarios\n+    \/\/ Specifically, ensuring no SIOOBE during affix matching\n+    @Test\n+    public void invalidPositionParseTest() {\n+        var df = new DecimalFormat();\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"1\", new ParsePosition(-1))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"1\", new ParsePosition(Integer.MAX_VALUE))));\n+    }\n+\n+    \/\/ When prefix matching, position + affix length is greater than parsed String length\n+    \/\/ Ensure we do not index out of bounds of the length of the parsed String\n+    @Test\n+    public void prefixMatchingTest() {\n+        var df = new DecimalFormat(\"ZZZ#;YYY#\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        \/\/ 0 + 3 > 2 = (pos + prefix > text)\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"Z1\", new ParsePosition(0))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"Y1\", new ParsePosition(0))));\n+    }\n+\n+    \/\/ When suffix matching, position + affix length is greater than parsed String length\n+    \/\/ Ensure we do not index out of bounds of the length of the parsed String\n+    @Test\n+    public void suffixMatchingTest() {\n+        var df = new DecimalFormat(\"#ZZ;#YY\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        \/\/ Matches prefix properly first. Then 3 + 2 > 4 = (pos + suffix > text)\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"123Z\", new ParsePosition(0))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"123Y\", new ParsePosition(0))));\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/PositionTest.java","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"}]}