{"files":[{"patch":"@@ -150,0 +150,3 @@\n+#ifdef ASSERT\n+  Atomic::store(&_evacuation_state, _oom_not_evacuating);\n+#endif\n@@ -238,0 +241,3 @@\n+#ifdef ASSERT\n+  Atomic::store(&_evacuation_state, _evacuating);\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,0 +184,8 @@\n+#ifdef ASSERT\n+public:\n+  enum ShenandoahEvacuationState {\n+    _evacuating,\n+    _oom_not_evacuating\n+  };\n+  volatile ShenandoahEvacuationState _evacuation_state;\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,12 +61,21 @@\n- if (level == 0) {\n-   \/\/ Entering top level scope, register this thread.\n-   register_thread(thr);\n- } else if (!ShenandoahThreadLocalData::is_oom_during_evac(thr)) {\n-   ShenandoahEvacOOMCounter* counter = counter_for_thread(thr);\n-   jint threads_in_evac = counter->load_acquire();\n-   \/\/ If OOM is in progress, handle it.\n-   if ((threads_in_evac & ShenandoahEvacOOMCounter::OOM_MARKER_MASK) != 0) {\n-     counter->decrement();\n-     wait_for_no_evac_threads();\n-   }\n- }\n+  if (level == 0) {\n+    \/\/ Entering top level scope, register this thread.\n+    register_thread(thr);\n+  } else if (!ShenandoahThreadLocalData::is_oom_during_evac(thr)) {\n+    ShenandoahEvacOOMCounter* counter = counter_for_thread(thr);\n+    jint threads_in_evac = counter->load_acquire();\n+    \/\/ If OOM is in progress, handle it.\n+    if ((threads_in_evac & ShenandoahEvacOOMCounter::OOM_MARKER_MASK) != 0) {\n+      counter->decrement();\n+      wait_for_no_evac_threads();\n+    }\n+  }\n+#ifdef ASSERT\n+  ShenandoahEvacuationState state = Atomic::load(&_evacuation_state);\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(thr)) {\n+    \/\/ This thread is not authorized to allocate\n+    assert(state == _oom_not_evacuating, \"Thread no longer evacuating implies no threads are evacuating\");\n+  } else {\n+    assert(state == _evacuating, \"Thread evacuating implies all threads are evacuating\");\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -294,0 +294,5 @@\n+#ifdef ASSERT\n+    ShenandoahEvacOOMHandler::ShenandoahEvacuationState state = Atomic::load(&(_oom_evac_handler._evacuation_state));\n+    assert(state == ShenandoahEvacOOMHandler::_oom_not_evacuating,\n+           \"all threads must be not evacuating if any thread is not evacuating\");\n+#endif\n@@ -296,0 +301,5 @@\n+#ifdef ASSERT\n+  ShenandoahEvacOOMHandler::ShenandoahEvacuationState state = Atomic::load(&(_oom_evac_handler._evacuation_state));\n+  assert(state == ShenandoahEvacOOMHandler::_evacuating,\n+         \"all threads must be evacuating if any thread is evacuating\");\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}