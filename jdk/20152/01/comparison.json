{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,6 +812,5 @@\n-     * @implSpec The default implementation checks that {@code bound} is a\n-     * positive {@code int}. Then invokes {@code nextInt()}, limiting the result\n-     * to be greater than or equal zero and less than {@code bound}. If {@code bound}\n-     * is a power of two then limiting is a simple masking operation. Otherwise,\n-     * the result is re-calculated by invoking {@code nextInt()} until the\n-     * result is greater than or equal zero and less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code bound} is positive.\n+     * It then invokes {@link #nextInt()} one or more times to ensure a uniform\n+     * distribution in the range 0 (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextInt()} to be uniform.\n@@ -838,7 +837,6 @@\n-     * @implSpec The default implementation checks that {@code origin} and\n-     * {@code bound} are positive {@code ints}. Then invokes {@code nextInt()},\n-     * limiting the result to be greater that or equal {@code origin} and less\n-     * than {@code bound}. If {@code bound} is a power of two then limiting is a\n-     * simple masking operation. Otherwise, the result is re-calculated  by\n-     * invoking {@code nextInt()} until the result is greater than or equal\n-     * {@code origin} and less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code origin}\n+     * is less than {@code bound}.\n+     * It then invokes {@link #nextInt()} one or more times to ensure a uniform\n+     * distribution in the range {@code origin} (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextInt()} to be uniform.\n@@ -871,7 +869,5 @@\n-     * @implSpec The default implementation checks that {@code bound} is a\n-     * positive  {@code long}. Then invokes {@code nextLong()}, limiting the\n-     * result to be greater than or equal zero and less than {@code bound}. If\n-     * {@code bound} is a power of two then limiting is a simple masking\n-     * operation. Otherwise, the result is re-calculated by invoking\n-     * {@code nextLong()} until the result is greater than or equal zero and\n-     * less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code bound} is positive.\n+     * It then invokes {@link #nextLong()} one or more times to ensure a uniform\n+     * distribution in the range 0 (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextLong()} to be uniform.\n@@ -898,7 +894,6 @@\n-     * @implSpec The default implementation checks that {@code origin} and\n-     * {@code bound} are positive {@code longs}. Then invokes {@code nextLong()},\n-     * limiting the result to be greater than or equal {@code origin} and less\n-     * than {@code bound}. If {@code bound} is a power of two then limiting is a\n-     * simple masking operation. Otherwise, the result is re-calculated by\n-     * invoking {@code nextLong()} until the result is greater than or equal\n-     * {@code origin} and less than {@code bound}.\n+     * @implSpec The default implementation checks that {@code origin}\n+     * is less than {@code bound}.\n+     * It then invokes {@link #nextLong()} one or more times to ensure a uniform\n+     * distribution in the range {@code origin} (inclusive)\n+     * to {@code bound} (exclusive).\n+     * It assumes the distribution of {@link #nextLong()} to be uniform.\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"}]}