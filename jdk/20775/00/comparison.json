{"files":[{"patch":"@@ -69,0 +69,6 @@\n+\/\/ example operand group\n+operand x_reg()\n+%{\n+  group(y_reg, z_reg)\n+%}\n+\n@@ -274,0 +280,5 @@\n+\t10. Group: group(reg_x, reg_z)\n+\t\tGroups a series of other existing regs in this group reg. In\n+\t\tan instruct, a group operand can be used as input operand, as\n+\t\ta TEMP in effect list, in ins_encode as parameters. Underlying,\n+\t\ta group operand will be ungrouped automatically as separate operands.\n","filename":"src\/hotspot\/share\/adlc\/Doc\/Syntax.doc","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  else get_oplist(instr->_parameters, instr->_localNames);\n+  else get_oplist(instr->_parameters, instr->_localNames, &instr->_parameters_grouped);\n@@ -481,0 +481,3 @@\n+    else if (!strcmp(ident, \"group\"))    {\n+      oper_group_parse(oper);\n+    }\n@@ -505,0 +508,22 @@\n+void ADLParser::oper_group_parse(OperandForm* current) {\n+  skipws();\n+  next_char();                            \/\/ Skip past open paren or comma\n+\n+  char common;\n+  do {\n+    skipws();\n+    char* ident = get_ident();\n+    const Form* oper = _globalNames[ident];\n+    if (oper == nullptr) {\n+      parse_err(SYNERR, \"missing definition of operand: %s\\n\", ident);\n+    }\n+    assert(oper->is_operand() != nullptr, \"sanity\");\n+    current->append_ungrouped_operand(oper->is_operand());\n+    common = _curchar;\n+    skipws();\n+    next_char();\n+  } while (common == ',');\n+\n+  skipws();\n+}\n+\n@@ -2898,0 +2923,6 @@\n+  inst._parameters_grouped.reset();\n+  while ((param = inst._parameters_grouped.iter()) != nullptr) {\n+    OpClassForm* opForm = inst._localNames[param]->is_opclass();\n+    assert(opForm != nullptr, \"sanity\");\n+    encoding->add_parameter_grouped(opForm->_ident, param);\n+  }\n@@ -2905,1 +2936,2 @@\n-  NameAndList* params  = encrule->add_encode(ec_name);\n+  NameAndList* params = encrule->add_encode(ec_name);\n+  NameAndList* params_grouped = encrule->add_encode_grouped(ec_name);\n@@ -2910,0 +2942,4 @@\n+  inst._parameters_grouped.reset();\n+  while ((param = inst._parameters_grouped.iter()) != nullptr) {\n+    params_grouped->add_entry(param);\n+  }\n@@ -4409,0 +4445,7 @@\n+  {\n+    OperandForm *oper = opcForm ? opcForm->is_operand() : nullptr;\n+    if (oper != nullptr && oper->get_ungrouped_operands_num() > 0) {\n+      parse_err(SYNERR, \"grouping operand (%s) is not supported in match rule\\n\", token);\n+    }\n+  }\n+\n@@ -4896,1 +4939,1 @@\n-void ADLParser::get_oplist(NameList &parameters, FormDict &operands) {\n+void ADLParser::get_oplist(NameList &parameters, FormDict &operands, NameList* parameters_grouped) {\n@@ -4911,6 +4954,0 @@\n-    else {\n-      const Form  *form = _globalNames[ident];\n-      if( form == nullptr ) {\n-        parse_err(SYNERR, \"undefined operand type %s\\n\", ident);\n-        return;\n-      }\n@@ -4918,8 +4955,4 @@\n-      \/\/ Check for valid operand type\n-      OpClassForm *opc  = form->is_opclass();\n-      OperandForm *oper = form->is_operand();\n-      if((oper == nullptr) && (opc == nullptr)) {\n-        parse_err(SYNERR, \"identifier %s not operand type\\n\", ident);\n-        return;\n-      }\n-      opclass = opc;\n+    const Form  *form = _globalNames[ident];\n+    if( form == nullptr ) {\n+      parse_err(SYNERR, \"undefined operand type %s\\n\", ident);\n+      return;\n@@ -4927,0 +4960,10 @@\n+\n+    \/\/ Check for valid operand type\n+    OpClassForm *opc  = form->is_opclass();\n+    OperandForm *oper = form->is_operand();\n+    if((oper == nullptr) && (opc == nullptr)) {\n+      parse_err(SYNERR, \"identifier %s not operand type\\n\", ident);\n+      return;\n+    }\n+    opclass = opc;\n+\n@@ -4939,2 +4982,26 @@\n-    operands.Insert(ident, opclass);\n-    parameters.addName(ident);\n+\n+    if (oper != nullptr && oper->get_ungrouped_operands_num() > 0) {\n+      for (int i = 0; i < (int)oper->get_ungrouped_operands_num(); i++) {\n+        const char* ungrouped = OperandForm::get_ungrouped_oper_name(ident, i);\n+        if( _globalNames[ungrouped] != nullptr ) {\n+          parse_err(SYNERR, \"Reuse of global name %s as operand.\\n\", ungrouped);\n+          return;\n+        }\n+        if( operands[ungrouped] != nullptr ) {\n+          parse_err(SYNERR, \"Reuse of local name %s as operand.\\n\", ungrouped);\n+          return;\n+        }\n+        operands.Insert(ungrouped, oper->get_ungrouped_operand(i));\n+        parameters.addName(ungrouped);\n+      }\n+      if (operands[ident] != nullptr) {\n+        parse_err(SYNERR, \"Reuse of local name %s as operand.\\n\", ident);\n+      }\n+      operands.Insert(ident, opclass);\n+      if (parameters_grouped != nullptr) {\n+        parameters_grouped->addName(ident);\n+      }\n+    } else {\n+      operands.Insert(ident, opclass);\n+      parameters.addName(ident);\n+    }\n@@ -5014,0 +5081,9 @@\n+      \/\/ Add the pairs of ungrouped operands to the effects table\n+      for (int i = 0; i < (int)opForm->get_ungrouped_operands_num(); i++) {\n+        if (!eForm->isa(Component::TEMP)) {\n+          parse_err(SYNERR, \"grouping operand %s must be in TEMP effect\\n\", ident);\n+        }\n+        const char* ungrouped = OperandForm::get_ungrouped_oper_name(ident, i);\n+        effects.Insert(ungrouped, eForm);\n+      }\n+\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":95,"deletions":19,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  void oper_group_parse(OperandForm* current);\n@@ -240,1 +241,1 @@\n-  void  get_oplist(NameList &parameters, FormDict &operands);\/\/ Parse type-operand pairs\n+  void  get_oplist(NameList &parameters, FormDict &operands, NameList* parameters_grouped = nullptr);\/\/ Parse type-operand pairs\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  int buildMachNode(FILE *fp_cpp, InstructForm *inst, ComponentList& components, const char *indent, int start_index = 0);\n","filename":"src\/hotspot\/share\/adlc\/archDesc.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -841,0 +841,4 @@\n+uint InstructForm::num_opnds_grouped() {\n+  return _components_grouped.num_operands();\n+}\n+\n@@ -941,0 +945,1 @@\n+  \/\/ Match rule does not support grouping operands\n@@ -942,0 +947,7 @@\n+  bool has_temp = build_components(_parameters, _components);\n+  if (_parameters_grouped.count() > 0) {\n+    bool has_temp_grouped = build_components(_parameters_grouped, _components_grouped);\n+    \/\/ only support `group` for TEMP operand.\n+    \/\/ if one operand is ungrouped, has_temp must be true also.\n+    assert(has_temp_grouped && has_temp, \"sanity\");\n+  }\n@@ -943,0 +955,8 @@\n+  \/\/ Resolving the interactions between expand rules and TEMPs would\n+  \/\/ be complex so simply disallow it.\n+  if (_matrule == nullptr && has_temp) {\n+    globalAD->syntax_err(_linenum, \"%s: TEMPs without match rule isn't supported\\n\", _ident);\n+  }\n+}\n+\n+bool InstructForm::build_components(NameList& parameters, ComponentList& components) {\n@@ -947,1 +967,1 @@\n-  for (_parameters.reset(); (name = _parameters.iter()) != nullptr;) {\n+  for (parameters.reset(); (name = parameters.iter()) != nullptr;) {\n@@ -975,1 +995,1 @@\n-    const Component *component  = _components.search(name);\n+    const Component *component  = components.search(name);\n@@ -978,2 +998,2 @@\n-        _components.insert(name, opForm->_ident, e->_use_def, false);\n-        component = _components.search(name);\n+        components.insert(name, opForm->_ident, e->_use_def, false);\n+        component = components.search(name);\n@@ -995,1 +1015,1 @@\n-        _components.insert(name, opForm->_ident, Component::INVALID, false);\n+        components.insert(name, opForm->_ident, Component::INVALID, false);\n@@ -1012,1 +1032,1 @@\n-        _components.insert(name, opForm->_ident, e->_use_def, false);\n+        components.insert(name, opForm->_ident, e->_use_def, false);\n@@ -1018,1 +1038,1 @@\n-      int  pos  = _components.operand_position(name);\n+      int  pos  = components.operand_position(name);\n@@ -1024,7 +1044,1 @@\n-  \/\/ Resolving the interactions between expand rules and TEMPs would\n-  \/\/ be complex so simply disallow it.\n-  if (_matrule == nullptr && has_temp) {\n-    globalAD->syntax_err(_linenum, \"%s: TEMPs without match rule isn't supported\\n\", _ident);\n-  }\n-\n-  return;\n+  return has_temp;\n@@ -1042,0 +1056,5 @@\n+int   InstructForm::operand_position_format_grouped(const char *name) {\n+  \/\/ Every grouping operand should be unique in an intruct level.\n+  return _components_grouped.operand_position_format(name, this);\n+}\n+\n@@ -1466,0 +1485,13 @@\n+\n+    _parameters_grouped.reset();\n+    const char  * tmp = nullptr;\n+    if (_parameters_grouped.count() > 0) {\n+      fprintf(fp,\"  \/\/ Below are grouping operands\\n\");\n+    }\n+    while ((tmp = _parameters_grouped.iter()) != nullptr) {\n+      assert( *receiver == 0, \"sanity\");\n+      fprintf(fp,\"  unsigned %sidx%d = %sidx%d + opnd_array(%d)->num_edges();\",\n+                prefix, idx, prefix, idx-1, idx-1 );\n+      fprintf(fp,\" \\t\/\/ %s\\n\", tmp);\n+      idx++;\n+    }\n@@ -1661,0 +1693,5 @@\n+void EncClass::add_parameter_grouped(const char *parameter_type, const char *parameter_name) {\n+  _parameter_type_grouped.addName( parameter_type );\n+  _parameter_name_grouped.addName( parameter_name );\n+}\n+\n@@ -1680,0 +1717,8 @@\n+  return rep_var_index(rep_var, _parameter_name);\n+}\n+\n+int EncClass::rep_var_index_grouped(const char *rep_var) {\n+  return rep_var_index(rep_var, _parameter_name_grouped);\n+}\n+\n+int EncClass::rep_var_index(const char *rep_var, NameList& parameter) {\n@@ -1683,2 +1728,2 @@\n-  _parameter_name.reset();\n-  while ( (name = _parameter_name.iter()) != nullptr ) {\n+  parameter.reset();\n+  while ( (name = parameter.iter()) != nullptr ) {\n@@ -1826,0 +1871,10 @@\n+NameAndList *InsEncode::add_encode_grouped(char *encoding) {\n+  assert( encoding != nullptr, \"Must provide name for encoding\");\n+\n+  \/\/ add_parameter(NameList::_signal);\n+  NameAndList *encode = new NameAndList(encoding);\n+  _encoding_grouped.addName((char*)encode);\n+\n+  return encode;\n+}\n+\n@@ -1829,0 +1884,1 @@\n+  _encoding_grouped.reset();\n@@ -1837,1 +1893,7 @@\n-  NameAndList *params = (NameAndList*)_encoding.current();\n+  return rep_var_name(inst, param_no, _encoding);\n+}\n+const char *InsEncode::rep_var_name_grouped(InstructForm &inst, uint param_no) {\n+  return rep_var_name(inst, param_no, _encoding_grouped);\n+}\n+const char *InsEncode::rep_var_name(InstructForm &inst, uint param_no, NameList& encoding) {\n+  NameAndList *params = (NameAndList*)encoding.current();\n@@ -2147,1 +2209,1 @@\n-  : OpClassForm(id), _ideal_only(false),\n+  : OpClassForm(id), _ideal_only(false), _ungrouped_operands_num(0),\n@@ -2160,1 +2222,1 @@\n-  : OpClassForm(id), _ideal_only(ideal_only),\n+  : OpClassForm(id), _ideal_only(ideal_only), _ungrouped_operands_num(0),\n@@ -2567,0 +2629,25 @@\n+void OperandForm::append_ungrouped_operand(OperandForm *oper) {\n+  assert(oper != nullptr, \"sanity\");\n+  assert(_ungrouped_operands_num < UNGROUPED_OPER_LIMIT, \"sanity\");\n+  _ungrouped_operands[(int)_ungrouped_operands_num++] = oper;\n+}\n+\n+OperandForm* OperandForm::get_ungrouped_operand(int idx) {\n+  assert(idx >= 0 && idx < (int)_ungrouped_operands_num, \"sanity\");\n+  return _ungrouped_operands[idx];\n+}\n+\n+uint OperandForm::get_ungrouped_operands_num() {\n+  assert(_ungrouped_operands_num <= UNGROUPED_OPER_LIMIT, \"sanity\");\n+  return _ungrouped_operands_num;\n+}\n+\n+const char *OperandForm::get_ungrouped_oper_name(const char *name, int idx) {\n+  assert(idx >= 0 && idx < UNGROUPED_OPER_LIMIT, \"sanity\");\n+\n+  const char *suffix = \"_ungrouped_\";\n+  const size_t len = strlen(name) + strlen(suffix) + 2;\n+  char *buf = (char *)AdlAllocateHeap(len);\n+  snprintf_checked(buf, len, \"%s%s%d\", name, suffix, idx);\n+  return buf;\n+}\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":106,"deletions":19,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+  NameList       _parameters_grouped;\n@@ -119,0 +120,1 @@\n+  ComponentList  _components_grouped;\n@@ -210,0 +212,1 @@\n+  virtual uint        num_opnds_grouped();\n@@ -233,0 +236,1 @@\n+  virtual int         operand_position_format_grouped(const char *name);\n@@ -314,0 +318,3 @@\n+\n+private:\n+  bool build_components(NameList& params, ComponentList& components);\n@@ -346,0 +353,2 @@\n+  NameList       _parameter_type_grouped;\n+  NameList       _parameter_name_grouped;\n@@ -366,0 +375,1 @@\n+  void add_parameter_grouped(const char *parameter_type, const char *parameter_name);\n@@ -370,0 +380,1 @@\n+  int         rep_var_index_grouped(const char *rep_var);\n@@ -383,0 +394,3 @@\n+\n+private:\n+  static int rep_var_index(const char *rep_var, NameList& parameter);\n@@ -441,0 +455,1 @@\n+  NameList    _encoding_grouped;\n@@ -454,0 +469,1 @@\n+  NameAndList  *add_encode_grouped(char *encode_method_name);\n@@ -470,0 +486,1 @@\n+  const char   *rep_var_name_grouped(InstructForm &inst, uint param_no);\n@@ -475,0 +492,3 @@\n+\n+private:\n+  const char *rep_var_name(InstructForm &inst, uint param_no, NameList& encoding);\n@@ -598,0 +618,3 @@\n+public:\n+  static constexpr uint UNGROUPED_OPER_LIMIT = 8;\n+\n@@ -600,0 +623,2 @@\n+  OperandForm  *_ungrouped_operands[UNGROUPED_OPER_LIMIT];\n+  uint         _ungrouped_operands_num;\n@@ -704,0 +729,4 @@\n+  void                append_ungrouped_operand(OperandForm *oper);\n+  OperandForm*        get_ungrouped_operand(int idx);\n+  uint                get_ungrouped_operands_num();\n+  static const char  *get_ungrouped_oper_name(const char *name, int idx);\n","filename":"src\/hotspot\/share\/adlc\/formssel.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1755,0 +1755,2 @@\n+    \/\/ NOTE: only plain operands or ungrouped operands are added here,\n+    \/\/       grouping operands are not added here.\n@@ -1921,0 +1923,2 @@\n+  int           _ungrouped_operands[OperandForm::UNGROUPED_OPER_LIMIT];\n+  uint          _ungrouped_operands_num;\n@@ -1959,0 +1963,1 @@\n+    _ungrouped_operands_num  = 0;\n@@ -2002,1 +2007,2 @@\n-        if ( param_no == -1 ) {\n+        int   param_no_grouped = _encoding.rep_var_index_grouped(rep_var);\n+        if ( param_no == -1 && param_no_grouped == -1 ) {\n@@ -2004,1 +2010,1 @@\n-                          \"Replacement variable %s not found in enc_class %s.\\n\",\n+                          \"1 Replacement variable %s not found in enc_class %s.\\n\",\n@@ -2007,0 +2013,1 @@\n+        assert(param_no == -1 || param_no_grouped == -1, \"sanity\");\n@@ -2010,2 +2017,4 @@\n-        const char *inst_rep_var = _ins_encode.rep_var_name(_inst, param_no);\n-        if (inst_rep_var == nullptr) {\n+        const char *inst_rep_var_ungrouped = param_no != -1 ? _ins_encode.rep_var_name(_inst, param_no) : nullptr;\n+        const char *inst_rep_var_grouped = param_no_grouped != -1 ?\n+                   _ins_encode.rep_var_name_grouped(_inst, param_no_grouped) : nullptr;\n+        if (inst_rep_var_ungrouped == nullptr && inst_rep_var_grouped == nullptr) {\n@@ -2019,0 +2028,1 @@\n+        const char *inst_rep_var = inst_rep_var_ungrouped != nullptr ? inst_rep_var_ungrouped : inst_rep_var_grouped;\n@@ -2025,0 +2035,2 @@\n+        int idx_grouped  = (opc != nullptr) ? _inst.operand_position_format_grouped(inst_rep_var) : -1;\n+        assert(idx == -1 || idx_grouped == -1, \"sanity\");\n@@ -2026,1 +2038,1 @@\n-        if ( idx != -1 ) {\n+        if ( idx != -1 || idx_grouped != -1) {\n@@ -2031,0 +2043,14 @@\n+          if (idx != -1) {\n+            _ungrouped_operands_num = 0;\n+          } else {\n+            OperandForm *operand = opc->is_operand();\n+            assert(operand != nullptr, \"sanity\");\n+            assert(operand->get_ungrouped_operands_num() > 0, \"sanity\");\n+            for (int i = 0; i < (int)operand->get_ungrouped_operands_num(); i++) {\n+              const char* ungrouped = OperandForm::get_ungrouped_oper_name(inst_rep_var, i);\n+              int ungrouped_idx  = _inst.operand_position_format(ungrouped);\n+              assert(ungrouped_idx >= 0 && (uint)ungrouped_idx < _inst.num_unique_opnds(), \"sanity\");\n+              _ungrouped_operands[i] = ungrouped_idx;\n+            }\n+            _ungrouped_operands_num = operand->get_ungrouped_operands_num();\n+          }\n@@ -2361,0 +2387,6 @@\n+\n+#if defined(RISCV64)\n+    if (strcmp(rep_var,\"$VectorRegister\") == 0)   return \"as_VectorRegister\";\n+    if (strcmp(rep_var,\"$VectorRegisterGroup\") == 0)   return \"as_VectorRegisterGroup\";\n+#endif\n+\n@@ -2373,1 +2405,1 @@\n-      assert( _operand_idx != -1,\n+      assert( (_operand_idx != -1) != (_ungrouped_operands_num > 0),\n@@ -2388,1 +2420,12 @@\n-          if( _operand_idx != 0 ) fprintf(_fp,\",idx%d\", _operand_idx);\n+          if (_ungrouped_operands_num == 0) {\n+            assert(_operand_idx != -1, \"sanity\");\n+            if( _operand_idx != 0 ) fprintf(_fp,\",idx%d\", _operand_idx);\n+          } else {\n+            assert(_operand_idx == -1, \"sanity\");\n+            assert(_ungrouped_operands_num > 0 && _ungrouped_operands_num <= OperandForm::UNGROUPED_OPER_LIMIT, \"sanity\");\n+            fprintf(_fp, \",%d\", _ungrouped_operands_num);\n+            for (int i = 0; i < (int)_ungrouped_operands_num; i++) {\n+              assert(_ungrouped_operands[i] >= 0, \"sanity\");\n+              fprintf(_fp,\",idx%d\", _ungrouped_operands[i]);\n+            }\n+          }\n@@ -2479,1 +2522,2 @@\n-      if ( param_no == -1 ) {\n+      int   param_no_grouped  = _encoding.rep_var_index_grouped(rep_var);\n+      if ( param_no == -1 && param_no_grouped == -1 ) {\n@@ -2481,1 +2525,1 @@\n-                        \"Replacement variable %s not found in enc_class %s.\\n\",\n+                        \"2 Replacement variable %s not found in enc_class %s.\\n\",\n@@ -2484,0 +2528,2 @@\n+      assert(param_no == -1 || param_no_grouped == -1, \"sanity\");\n+\n@@ -2485,1 +2531,11 @@\n-      const char *inst_rep_var = _ins_encode.rep_var_name(_inst, param_no);\n+      const char *inst_rep_var_ungrouped = param_no != -1 ? _ins_encode.rep_var_name(_inst, param_no) : nullptr;\n+      const char *inst_rep_var_grouped = param_no_grouped != -1 ?\n+                 _ins_encode.rep_var_name_grouped(_inst, param_no_grouped) : nullptr;\n+      if (inst_rep_var_ungrouped == nullptr && inst_rep_var_grouped == nullptr) {\n+        _AD.syntax_err( _ins_encode._linenum,\n+                        \"Parameter %s not passed to enc_class %s from instruct %s.\\n\",\n+                        rep_var, _encoding._name, _inst._ident);\n+        assert(false, \"inst_rep_var == null, cannot continue.\");\n+      }\n+\n+      const char *inst_rep_var = inst_rep_var_ungrouped != nullptr ? inst_rep_var_ungrouped : inst_rep_var_grouped;\n@@ -2494,2 +2550,5 @@\n-      if( idx != -1 ) {\n-        if (_inst.is_noninput_operand(idx)) {\n+      int idx_grouped  = (opc != nullptr) ? _inst.operand_position_format_grouped(inst_rep_var) : -1;\n+      assert(idx == -1 || idx_grouped == -1, \"sanity\");\n+\n+      if ( idx != -1 || idx_grouped != -1) {\n+        if ((idx != -1 && _inst.is_noninput_operand(idx))) {\n@@ -2501,1 +2560,13 @@\n-          fprintf(_fp,\"opnd_array(%d)\",idx);\n+          if (idx != -1) {\n+            fprintf(_fp,\"opnd_array(%d)\",idx);\n+          } else {\n+            OperandForm *operand = opc->is_operand();\n+            assert(operand != nullptr, \"sanity\");\n+            assert(operand->get_ungrouped_operands_num() > 0, \"sanity\");\n+            \/\/ Pass `- 1` below, because in _inst.operand_position_format_grouped above\n+            \/\/ returned `idx_grouped` will start from 1 rather 0 for non-DEF operand,\n+            \/\/ and for grouping operand, only TEMP is supported.\n+            assert(idx_grouped >= 1, \"sanity\");\n+            fprintf(_fp,\"opnd_array(%d\",idx_grouped + _inst.num_unique_opnds() - 1);\n+            fprintf(_fp,\")\");\n+          }\n@@ -3905,0 +3976,26 @@\n+int ArchDesc::buildMachNode(FILE *fp_cpp, InstructForm *inst, ComponentList& comp_list, const char *indent, int start_index) {\n+  bool           dont_care = false;\n+  Component     *comp      = nullptr;\n+  comp_list.reset();\n+  if ( comp_list.match_iter() != nullptr )    dont_care = true;\n+\n+  \/\/ Insert operands that are not in match-rule.\n+  \/\/ Only insert a DEF if the do_care flag is set\n+  comp_list.reset();\n+  int         index = -1;\n+  while ( (comp = comp_list.post_match_iter()) ) {\n+    \/\/ Check if we don't care about DEFs or KILLs that are not USEs\n+    if ( dont_care && (! comp->isa(Component::USE)) ) {\n+      continue;\n+    }\n+    dont_care = true;\n+    \/\/ For each operand not in the match rule, call MachOperGenerator\n+    \/\/ with the enum for the opcode that needs to be built.\n+    ComponentList clist = comp_list;\n+    index  = clist.operand_position(comp->_name, comp->_usedef, inst);\n+    const char *opcode = machOperEnum(comp->_type);\n+    fprintf(fp_cpp, \"%s node->set_opnd_array(%d, \", indent, start_index + index);\n+    fprintf(fp_cpp, \"MachOperGenerator(%s));\\n\", opcode);\n+  }\n+  return start_index + index;\n+}\n@@ -3919,23 +4016,9 @@\n-    bool           dont_care = false;\n-    ComponentList &comp_list = inst->_components;\n-    Component     *comp      = nullptr;\n-    comp_list.reset();\n-    if ( comp_list.match_iter() != nullptr )    dont_care = true;\n-\n-    \/\/ Insert operands that are not in match-rule.\n-    \/\/ Only insert a DEF if the do_care flag is set\n-    comp_list.reset();\n-    while ( (comp = comp_list.post_match_iter()) ) {\n-      \/\/ Check if we don't care about DEFs or KILLs that are not USEs\n-      if ( dont_care && (! comp->isa(Component::USE)) ) {\n-        continue;\n-      }\n-      dont_care = true;\n-      \/\/ For each operand not in the match rule, call MachOperGenerator\n-      \/\/ with the enum for the opcode that needs to be built.\n-      ComponentList clist = inst->_components;\n-      int         index  = clist.operand_position(comp->_name, comp->_usedef, inst);\n-      const char *opcode = machOperEnum(comp->_type);\n-      fprintf(fp_cpp, \"%s node->set_opnd_array(%d, \", indent, index);\n-      fprintf(fp_cpp, \"MachOperGenerator(%s));\\n\", opcode);\n-      }\n+    int index = buildMachNode(fp_cpp, inst, inst->_components, indent);\n+    if (inst->_components_grouped.count() > 0) {\n+      fprintf(fp_cpp,\"%s \/\/ Below are grouping operands\\n\", indent);\n+      assert(index + 1 == inst->num_unique_opnds(), \"sanity\");\n+      \/\/ Not pass `index + 1` as the start_index below, because in buildMachNode(..., start_idx)\n+      \/\/ returned `idx_grouped` will start from 1 rather 0 for non-DEF operand,\n+      \/\/ and for grouping operand, only TEMP is supported.\n+      buildMachNode(fp_cpp, inst, inst->_components_grouped, indent, index);\n+    }\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":119,"deletions":36,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -1539,1 +1539,2 @@\n-    fprintf(fp,\"  MachOper *_opnd_array[%d];\\n\", instr->num_opnds() );\n+    fprintf(fp,\"  MachOper *_opnd_array[%d];\\n\", instr->num_opnds() + instr->num_opnds_grouped() );\n+    fprintf(fp,\"  uint16_t _num_opnds_grouped;\\n\" );\n@@ -1558,1 +1559,1 @@\n-    fprintf(fp,\"    assert(operand_index < _num_opnds, \\\"invalid _opnd_array index\\\");\\n\");\n+    fprintf(fp,\"    assert(operand_index < (uint)(_num_opnds + _num_opnds_grouped), \\\"invalid _opnd_array index\\\");\\n\");\n@@ -1562,1 +1563,1 @@\n-    fprintf(fp,\"    assert(operand_index < _num_opnds, \\\"invalid _opnd_array index\\\");\\n\");\n+    fprintf(fp,\"    assert(operand_index < (uint)(_num_opnds + _num_opnds_grouped), \\\"invalid _opnd_array index\\\");\\n\");\n@@ -1742,0 +1743,1 @@\n+    fprintf(fp,\" _num_opnds_grouped = %d; \", instr->num_opnds_grouped());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}