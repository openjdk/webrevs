{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import java.util.ArrayList;\n@@ -45,0 +46,1 @@\n+import java.util.Objects;\n@@ -241,0 +243,1 @@\n+        Objects.requireNonNull(newPattern, \"newPattern must not be null\");\n@@ -252,10 +255,7 @@\n-        StringBuilder[] segments = new StringBuilder[2];\n-        for (int i = 0; i < segments.length; ++i) {\n-            segments[i] = new StringBuilder();\n-        }\n-        double[] newChoiceLimits = new double[30];\n-        String[] newChoiceFormats = new String[30];\n-        int count = 0;\n-        int part = 0; \/\/ 0 denotes limit, 1 denotes format\n-        double startValue = 0;\n-        double oldStartValue = Double.NaN;\n+        \/\/ Set up components\n+        ArrayList<Double> limits = new ArrayList<>();\n+        ArrayList<String> formats = new ArrayList<>();\n+        Segment seg = Segment.LIMIT;\n+        Segment.LIMIT.patternBldr.setLength(0);\n+        Segment.FORMAT.patternBldr.setLength(0);\n+        double limit = 0;\n@@ -263,0 +263,2 @@\n+\n+        \/\/ Parse the string, swapping between the LIMIT and FORMAT enum mode values\n@@ -265,18 +267,53 @@\n-            if (ch=='\\'') {\n-                \/\/ Check for \"''\" indicating a literal quote\n-                if ((i+1)<newPattern.length() && newPattern.charAt(i+1)==ch) {\n-                    segments[part].append(ch);\n-                    ++i;\n-                } else {\n-                    inQuote = !inQuote;\n-                }\n-            } else if (inQuote) {\n-                segments[part].append(ch);\n-            } else if (part == 0 && (ch == '<' || ch == '#' || ch == '\\u2264')) {\n-                \/\/ Only consider relational symbols if parsing the limit segment (part == 0).\n-                \/\/ Don't treat a relational symbol as syntactically significant\n-                \/\/ when parsing Format segment (part == 1)\n-                if (segments[0].length() == 0) {\n-                    throw new IllegalArgumentException(\"Each interval must\"\n-                            + \" contain a number before a format\");\n-                }\n+            switch (ch) {\n+                case '\\'':\n+                    \/\/ Check for \"''\" indicating a literal quote\n+                    if ((i + 1) < newPattern.length() && newPattern.charAt(i + 1) == ch) {\n+                        seg.patternBldr.append(ch);\n+                        ++i;\n+                    } else {\n+                        inQuote = !inQuote;\n+                    }\n+                    break;\n+                case '<', '#', '\\u2264':\n+                    if (inQuote || seg == Segment.FORMAT) {\n+                        \/\/ Don't interpret relational symbols if parsing the format\n+                        seg.patternBldr.append(ch);\n+                    } else {\n+                        \/\/ Build the numerical value of the limit\n+                        \/\/ and switch to parsing format\n+                        if (Segment.LIMIT.patternBldr.isEmpty()) {\n+                            throw new IllegalArgumentException(\"Each interval must\" +\n+                                    \" contain a number before a format\");\n+                        }\n+                        limit = stringToNum(Segment.LIMIT.patternBldr.toString());\n+                        if (ch == '<' && Double.isFinite(limit)) {\n+                            limit = nextDouble(limit);\n+                        }\n+                        if (!limits.isEmpty() && limit <= limits.getLast()) {\n+                            throw new IllegalArgumentException(\"Incorrect order \" +\n+                                    \"of intervals, must be in ascending order\");\n+                        }\n+                        Segment.LIMIT.patternBldr.setLength(0);\n+                        seg = Segment.FORMAT;\n+                    }\n+                    break;\n+                case '|':\n+                    if (inQuote) {\n+                        seg.patternBldr.append(ch);\n+                    } else {\n+                        if (seg != Segment.FORMAT) {\n+                            \/\/ Discard incorrect portion and finish building cFmt\n+                            break;\n+                        }\n+                        \/\/ Insert an entry into the format and limit arrays\n+                        \/\/ and switch to parsing limit\n+                        limits.add(limit);\n+                        formats.add(Segment.FORMAT.patternBldr.toString());\n+                        Segment.FORMAT.patternBldr.setLength(0);\n+                        seg = Segment.LIMIT;\n+                    }\n+                    break;\n+                default:\n+                    seg.patternBldr.append(ch);\n+            }\n+        }\n@@ -284,8 +321,8 @@\n-                String tempBuffer = segments[0].toString();\n-                if (tempBuffer.equals(\"\\u221E\")) {\n-                    startValue = Double.POSITIVE_INFINITY;\n-                } else if (tempBuffer.equals(\"-\\u221E\")) {\n-                    startValue = Double.NEGATIVE_INFINITY;\n-                } else {\n-                    startValue = Double.parseDouble(tempBuffer);\n-                }\n+        \/\/ clean up last one (SubPattern without trailing '|')\n+        if (seg == Segment.FORMAT) {\n+            limits.add(limit);\n+            formats.add(Segment.FORMAT.patternBldr.toString());\n+        }\n+        choiceLimits = limits.stream().mapToDouble(d -> d).toArray();\n+        choiceFormats = formats.toArray(new String[0]);\n+    }\n@@ -293,24 +330,9 @@\n-                if (ch == '<' && startValue != Double.POSITIVE_INFINITY &&\n-                        startValue != Double.NEGATIVE_INFINITY) {\n-                    startValue = nextDouble(startValue);\n-                }\n-                if (startValue <= oldStartValue) {\n-                    throw new IllegalArgumentException(\"Incorrect order of\"\n-                            + \" intervals, must be in ascending order\");\n-                }\n-                segments[0].setLength(0);\n-                part = 1;\n-            } else if (ch == '|') {\n-                if (count == newChoiceLimits.length) {\n-                    newChoiceLimits = doubleArraySize(newChoiceLimits);\n-                    newChoiceFormats = doubleArraySize(newChoiceFormats);\n-                }\n-                newChoiceLimits[count] = startValue;\n-                newChoiceFormats[count] = segments[1].toString();\n-                ++count;\n-                oldStartValue = startValue;\n-                segments[1].setLength(0);\n-                part = 0;\n-            } else {\n-                segments[part].append(ch);\n-            }\n+    \/\/ Used to explicitly define the segment mode while applying a pattern\n+    private enum Segment {\n+        LIMIT(new StringBuilder()),\n+        FORMAT(new StringBuilder());\n+\n+        private final StringBuilder patternBldr;\n+\n+        Segment(StringBuilder patternBldr) {\n+            this.patternBldr = patternBldr;\n@@ -318,9 +340,15 @@\n-        \/\/ clean up last one\n-        if (part == 1) {\n-            if (count == newChoiceLimits.length) {\n-                newChoiceLimits = doubleArraySize(newChoiceLimits);\n-                newChoiceFormats = doubleArraySize(newChoiceFormats);\n-            }\n-            newChoiceLimits[count] = startValue;\n-            newChoiceFormats[count] = segments[1].toString();\n-            ++count;\n+    }\n+\n+    \/**\n+     * Converts a string value to its double representation; this is used\n+     * to create the limit segment while applying a pattern.\n+     * Handles \"\\u221E\", as specified by the pattern syntax.\n+     *\/\n+    private static double stringToNum(String str) {\n+        double num;\n+        if (str.equals(\"\\u221E\")) {\n+            num = Double.POSITIVE_INFINITY;\n+        } else if (str.equals(\"-\\u221E\")) {\n+            num = Double.NEGATIVE_INFINITY;\n+        } else {\n+            num = Double.parseDouble(str);\n@@ -328,4 +356,1 @@\n-        choiceLimits = new double[count];\n-        System.arraycopy(newChoiceLimits, 0, choiceLimits, 0, count);\n-        choiceFormats = new String[count];\n-        System.arraycopy(newChoiceFormats, 0, choiceFormats, 0, count);\n+        return num;\n@@ -405,0 +430,1 @@\n+        Objects.requireNonNull(newPattern, \"newPattern must not be null\");\n@@ -577,0 +603,18 @@\n+    \/**\n+     * Finds the least double greater than {@code d} (if {@code positive} is\n+     * {@code true}), or the greatest double less than {@code d} (if\n+     * {@code positive} is {@code false}).\n+     * If {@code NaN}, returns same value.\n+     *\n+     * @implNote This is equivalent to calling\n+     * {@code positive ? Math.nextUp(d) : Math.nextDown(d)}\n+     *\n+     * @param d        the reference value\n+     * @param positive {@code true} if the least double is desired;\n+     *                 {@code false} otherwise\n+     * @return the least or greater double value\n+     *\/\n+    public static double nextDouble (double d, boolean positive) {\n+        return positive ? Math.nextUp(d) : Math.nextDown(d);\n+    }\n+\n@@ -596,2 +640,1 @@\n-    public Object clone()\n-    {\n+    public Object clone() {\n@@ -688,33 +731,0 @@\n-\n-    \/**\n-     * Finds the least double greater than {@code d} (if {@code positive} is\n-     * {@code true}), or the greatest double less than {@code d} (if\n-     * {@code positive} is {@code false}).\n-     * If {@code NaN}, returns same value.\n-     *\n-     * @implNote This is equivalent to calling\n-     * {@code positive ? Math.nextUp(d) : Math.nextDown(d)}\n-     *\n-     * @param d        the reference value\n-     * @param positive {@code true} if the least double is desired;\n-     *                 {@code false} otherwise\n-     * @return the least or greater double value\n-     *\/\n-    public static double nextDouble (double d, boolean positive) {\n-        return positive ? Math.nextUp(d) : Math.nextDown(d);\n-    }\n-\n-    private static double[] doubleArraySize(double[] array) {\n-        int oldSize = array.length;\n-        double[] newArray = new double[oldSize * 2];\n-        System.arraycopy(array, 0, newArray, 0, oldSize);\n-        return newArray;\n-    }\n-\n-    private String[] doubleArraySize(String[] array) {\n-        int oldSize = array.length;\n-        String[] newArray = new String[oldSize * 2];\n-        System.arraycopy(array, 0, newArray, 0, oldSize);\n-        return newArray;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":118,"deletions":108,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6285888 6801704\n+ * @bug 6285888 6801704 8325898\n@@ -34,2 +34,0 @@\n-import java.text.ChoiceFormat;\n-\n@@ -41,1 +39,2 @@\n-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import java.text.ChoiceFormat;\n+\n@@ -100,0 +99,1 @@\n+                arguments(\"#\", ERR1), \/\/ Only relation\n@@ -130,0 +130,2 @@\n+                \/\/ Incomplete SubPattern (limit only) at end of Pattern\n+                arguments(\"1#bar|2\", \"1#bar\"),\n@@ -132,0 +134,6 @@\n+                \/\/ Incomplete SubPattern with trailing | at the end of the Pattern\n+                \/\/ Prior to 6801704, it created the broken \"0#foo|1#bar|1#\"\n+                \/\/ which caused formatting 1 to return an empty string\n+                arguments(\"0#foo|1#bar|baz|\", \"0#foo|1#bar\"),\n+                \/\/ Same as previous, with additional incomplete subPatterns\n+                arguments(\"0#foo|1#bar|baz|quux\", \"0#foo|1#bar\"),\n@@ -134,1 +142,2 @@\n-                \/\/ when attempting to format with them ---\n+                \/\/ when attempting to format with them as the incomplete patterns\n+                \/\/ are discarded, initializing the cFmt with empty limits and formats ---\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/PatternsTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"}]}