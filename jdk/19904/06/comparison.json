{"files":[{"patch":"@@ -73,1 +73,0 @@\n-        MISSING_ENCL(Category.RESOLUTION),                             \/\/ not overloaded   non-target\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Kinds.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import com.sun.tools.javac.comp.Resolve.InvalidSymbolError;\n+import com.sun.tools.javac.comp.Resolve.RefBeforeCtorCalledError;\n@@ -2591,2 +2593,1 @@\n-                        rs.resolveImplicitThis(tree.meth.pos(),\n-                                               localEnv, site, true);\n+                        checkNewInnerClass(tree.meth.pos(), localEnv, site, true);\n@@ -2799,3 +2800,1 @@\n-        } else if (!clazztype.tsym.isInterface() &&\n-                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n-                   clazztype.getEnclosingType().hasTag(CLASS)) {\n+        } else {\n@@ -2803,1 +2802,1 @@\n-            rs.resolveImplicitThis(tree.pos(), env, clazztype);\n+            checkNewInnerClass(tree.pos(), env, clazztype, false);\n@@ -3068,0 +3067,18 @@\n+        void checkNewInnerClass(DiagnosticPosition pos, Env<AttrContext> env, Type type, boolean isSuper) {\n+            boolean isLocal = type.tsym.owner.kind == MTH;\n+            if ((type.tsym.flags() & (INTERFACE | ENUM | RECORD)) != 0 ||\n+                    (!isLocal && !type.tsym.isInner()) ||\n+                    (isSuper && env.enclClass.sym.isAnonymous())) {\n+                \/\/ nothing to check\n+                return;\n+            }\n+            Symbol res = isLocal ?\n+                    rs.findLocalClassOwner(env, type.tsym) :\n+                    rs.findSelfContaining(pos, env, type.getEnclosingType().tsym, names._this, isSuper);\n+            if (res.exists()) {\n+                rs.accessBase(res, pos, env.enclClass.sym.type, names._this, true);\n+            } else {\n+                log.error(pos, Errors.EnclClassRequired(type.tsym));\n+            }\n+        }\n+\n@@ -3676,1 +3693,0 @@\n-                    case MISSING_ENCL:\n@@ -3727,5 +3743,1 @@\n-                Type enclosingType = exprType.getEnclosingType();\n-                if (enclosingType != null && enclosingType.hasTag(CLASS)) {\n-                    \/\/ Check for the existence of an appropriate outer instance\n-                    rs.resolveImplicitThis(that.pos(), env, exprType);\n-                }\n+                checkNewInnerClass(that.pos(), env, exprType, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3734,1 +3734,1 @@\n-            Symbol sym = needsInference ?\n+            return needsInference ?\n@@ -3738,1 +3738,0 @@\n-            return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;\n@@ -3783,0 +3782,59 @@\n+    \/**\n+     * Find a \"valid\" reference to an enclosing 'A.this' such that A is a subclass of the provided class symbol.\n+     * A reference to an enclosing 'A.this' is \"valid\" if (a) we're not in the early-construction context for A\n+     * and (b) if the current class is not an inner class of A.\n+     *\/\n+    Symbol findSelfContaining(DiagnosticPosition pos,\n+                    Env<AttrContext> env,\n+                    TypeSymbol c,\n+                    Name name,\n+                    boolean isSuper) {\n+        Assert.check(name == names._this);\n+        Env<AttrContext> env1 = isSuper ? env.outer : env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (isStatic(env1)) staticOnly = true;\n+            if (env1.enclClass.sym.isSubClass(c, types)) {\n+                Symbol sym = env1.info.scope.findFirst(name);\n+                if (sym != null) {\n+                    if (staticOnly) {\n+                        \/\/ current class is not an inner class, stop search\n+                        return new StaticError(sym);\n+                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n+                        \/\/ early construction context, stop search\n+                        return new RefBeforeCtorCalledError(sym);\n+                    } else {\n+                        \/\/ found it\n+                        return sym;\n+                    }\n+                }\n+            }\n+            if ((env1.enclClass.sym.flags() & STATIC) != 0) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return varNotFound;\n+    }\n+\n+    \/**\n+     * Resolve the (method) owner of a local class. This can fail if the local class\n+     * is referenced from a static context nested inside the local class. Effectively,\n+     * this lookup succeeds if we can access a local variable declared inside the owner\n+     * method from the provided env.\n+     *\/\n+    Symbol findLocalClassOwner(Env<AttrContext> env, TypeSymbol c) {\n+        Symbol owner = c.owner;\n+        Assert.check(owner.kind == MTH);\n+        Env<AttrContext> env1 = env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (env1.info.scope.owner == owner) {\n+                return (staticOnly) ?\n+                    new StaticError(owner) :\n+                    owner;\n+            }\n+            if (isStatic(env1)) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return methodNotFound;\n+    }\n+\n@@ -3807,1 +3865,1 @@\n-                                  name, true);\n+                            name, true);\n@@ -3814,2 +3872,2 @@\n-            name == names._super && !isStatic(env) &&\n-            types.isDirectSuperInterface(c, env.enclClass.sym)) {\n+                name == names._super && !isStatic(env) &&\n+                types.isDirectSuperInterface(c, env.enclClass.sym)) {\n@@ -3830,2 +3888,2 @@\n-                              Errors.IllegalDefaultSuperCall(c,\n-                                                             Fragments.RedundantSupertype(c, i)));\n+                            Errors.IllegalDefaultSuperCall(c,\n+                                    Fragments.RedundantSupertype(c, i)));\n@@ -3938,70 +3996,0 @@\n-    \/**\n-     * Resolve `c.this' for an enclosing class c that contains the\n-     * named member.\n-     * @param pos           The position to use for error reporting.\n-     * @param env           The environment current at the expression.\n-     * @param member        The member that must be contained in the result.\n-     *\/\n-    Symbol resolveSelfContaining(DiagnosticPosition pos,\n-                                 Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);\n-        if (sym == null) {\n-            log.error(pos, Errors.EnclClassRequired(member));\n-            return syms.errSymbol;\n-        } else {\n-            return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);\n-        }\n-    }\n-\n-    boolean enclosingInstanceMissing(Env<AttrContext> env, Type type) {\n-        if (type.hasTag(CLASS) && type.getEnclosingType().hasTag(CLASS)) {\n-            Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);\n-            return encl == null || encl.kind.isResolutionError();\n-        }\n-        return false;\n-    }\n-\n-    private Symbol resolveSelfContainingInternal(Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Name name = names._this;\n-        Env<AttrContext> env1 = isSuperCall ? env.outer : env;\n-        boolean staticOnly = false;\n-        if (env1 != null) {\n-            while (env1 != null && env1.outer != null) {\n-                if (isStatic(env1)) staticOnly = true;\n-                if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {\n-                    Symbol sym = env1.info.scope.findFirst(name);\n-                    if (sym != null) {\n-                        if (staticOnly) sym = new StaticError(sym);\n-                        return sym;\n-                    }\n-                }\n-                if ((env1.enclClass.sym.flags() & STATIC) != 0)\n-                    staticOnly = true;\n-                env1 = env1.outer;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Resolve an appropriate implicit this instance for t's container.\n-     * JLS 8.8.5.1 and 15.9.2\n-     *\/\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n-        return resolveImplicitThis(pos, env, t, false);\n-    }\n-\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n-        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)\n-                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)\n-                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;\n-        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n-        }\n-        return thisType;\n-    }\n-\n@@ -4890,17 +4878,0 @@\n-    \/**\n-     * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,\n-     * but pointing to a class for which an enclosing instance is not available.\n-     *\/\n-    class BadConstructorReferenceError extends InvalidSymbolError {\n-\n-        public BadConstructorReferenceError(Symbol sym) {\n-            super(MISSING_ENCL, sym, \"BadConstructorReferenceError\");\n-        }\n-\n-        @Override\n-        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {\n-           return diags.create(dkind, log.currentSource(), pos,\n-                \"cant.access.inner.cls.constr\", site.tsym.name, argtypes, site.getEnclosingType());\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":65,"deletions":94,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -1098,5 +1098,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr=\\\n-    cannot access constructor {0}({1})\\n\\\n-    an enclosing instance of type {2} is not in scope\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8322882\n+ * @summary Disallow attempts to access a free variable proxy field from a static method\n+ * @compile\/fail\/ref=LocalFreeVarStaticInstantiate.out -XDrawDiagnostics LocalFreeVarStaticInstantiate.java\n+ *\/\n+\n+class LocalFreeVarStaticInstantiate {\n+\n+    static void foo(Object there) {\n+        class Local {\n+            {\n+                there.hashCode();\n+            }\n+            static {\n+                new Local();    \/\/ can't get there from here\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/LocalFreeVarStaticInstantiate.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+LocalFreeVarStaticInstantiate.java:16:17: compiler.err.non-static.cant.be.ref: kindname.method, foo(java.lang.Object)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/LocalFreeVarStaticInstantiate.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -10,1 +10,1 @@\n- * @compile\/fail\/ref=QualifiedAccess_2.out -XDrawDiagnostics QualifiedAccess_2.java\n+ * @compile\/fail\/ref=QualifiedAccess_2.out -XDdev -XDrawDiagnostics QualifiedAccess_2.java\n","filename":"test\/langtools\/tools\/javac\/QualifiedAccess\/QualifiedAccess_2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334248\n+ * @summary Invalid error for early construction local class constructor method reference\n+ * @compile\/fail\/ref=EarlyIndirectOuterCapture.out -XDrawDiagnostics EarlyIndirectOuterCapture.java\n+ *\/\n+\n+public class EarlyIndirectOuterCapture {\n+\n+    EarlyIndirectOuterCapture() {\n+        this(null);\n+    }\n+\n+    EarlyIndirectOuterCapture(InnerSuperclass inner) { }\n+\n+    class InnerSuperclass { }\n+\n+    static class InnerOuter extends EarlyIndirectOuterCapture {     \/\/ accessible\n+        class InnerInnerOuter extends EarlyIndirectOuterCapture {   \/\/ not accessible\n+            InnerInnerOuter() {\n+                super(\/* which enclosing instance here ? *\/new InnerSuperclass() { });\n+            }\n+\n+            InnerInnerOuter(boolean b) {\n+                super(InnerOuter.this.new InnerSuperclass() { }); \/\/ ok, explicit\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+EarlyIndirectOuterCapture.java:21:60: compiler.err.cant.ref.before.ctor.called: this\n+1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyIndirectOuterCapture.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8334248\n+ * @summary Allow early construction local class constructor method references\n+ * @enablePreview\n+ *\/\n+\n+import java.util.function.Supplier;\n+\n+public class EarlyLocalCtorRef {\n+\n+    public EarlyLocalCtorRef() {\n+        class InnerLocal { }\n+        this(InnerLocal::new);\n+    }\n+\n+    public EarlyLocalCtorRef(Supplier<Object> s) {\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalCtorRef();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalCtorRef.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-public class EarlyLocalTest1 {\n+public class EarlyLocalTest2 {\n@@ -34,1 +34,1 @@\n-            Runnable r = () -> new InnerLocal();\n+            Runnable r = () -> new InnerLocal() { };\n@@ -41,1 +41,1 @@\n-        new EarlyLocalTest1().new Test();\n+        new EarlyLocalTest2().new Test();\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest2.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest1.java","status":"copied"},{"patch":"@@ -29,1 +29,1 @@\n-public class EarlyLocalTest1 {\n+public class EarlyLocalTest3 {\n@@ -34,1 +34,1 @@\n-            Runnable r = () -> new InnerLocal();\n+            Runnable r = InnerLocal::new;\n@@ -41,1 +41,1 @@\n-        new EarlyLocalTest1().new Test();\n+        new EarlyLocalTest3().new Test();\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest3.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest1.java","status":"copied"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8333313\n+ * @summary Verify references to local classes declared in early construction contexts\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class EarlyLocalTest8 {\n+\n+    class Test extends AtomicReference<Runnable> {\n+        Test(int x) {\n+            super(\n+                switch (x) {\n+                    case 0 -> null;\n+                    default -> {\n+                        class InnerLocal { }\n+                        yield () -> new InnerLocal() { { System.out.println(EarlyLocalTest8.this); } };\n+                    }\n+                });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyLocalTest8().new Test(42);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyLocalTest8.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.cant.access.inner.cls.constr\n-\/\/ key: compiler.err.invalid.mref\n-\n-class CantAccessInnerClsConstructor {\n-\n-    interface SAM {\n-        Outer m();\n-    }\n-\n-    class Outer { }\n-\n-    static void test() {\n-        SAM s = Outer::new;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantAccessInnerClsConstr.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,4 +1,4 @@\n-MethodReference23.java:52:19: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, MethodReference23, MethodReference23)\n-MethodReference23.java:53:16: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, MethodReference23, MethodReference23)\n-MethodReference23.java:57:19: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, , MethodReference23)\n-MethodReference23.java:58:16: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner1, , MethodReference23)\n+MethodReference23.java:52:19: compiler.err.non-static.cant.be.ref: kindname.variable, this\n+MethodReference23.java:53:16: compiler.err.non-static.cant.be.ref: kindname.variable, this\n+MethodReference23.java:57:19: compiler.err.non-static.cant.be.ref: kindname.variable, this\n+MethodReference23.java:58:16: compiler.err.non-static.cant.be.ref: kindname.variable, this\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference23.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-MethodReference37.java:34:40: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner, MethodReference37.Outer, MethodReference37.Outer)\n-MethodReference37.java:38:41: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: Inner, MethodReference37.Outer, MethodReference37.Outer)\n+MethodReference37.java:34:40: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbol: kindname.constructor, Inner, compiler.misc.no.args, MethodReference37.Outer, kindname.class, MethodReference37.Outer.Inner, (compiler.misc.arg.length.mismatch)))\n+MethodReference37.java:38:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbol: kindname.constructor, Inner, compiler.misc.no.args, MethodReference37.Outer, kindname.class, MethodReference37.Outer.Inner, (compiler.misc.arg.length.mismatch)))\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReference37.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-1 error\n\\ No newline at end of file\n+1 error\n","filename":"test\/langtools\/tools\/javac\/lambda\/MethodReferenceNoThisTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-MethodRefToInnerWithoutOuter.java:22:31: compiler.err.invalid.mref: kindname.constructor, (compiler.misc.cant.access.inner.cls.constr: TestString, java.lang.String, MethodRefToInnerBase)\n+MethodRefToInnerWithoutOuter.java:22:31: compiler.err.non-static.cant.be.ref: kindname.variable, this\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/MethodRefToInnerWithoutOuter.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}