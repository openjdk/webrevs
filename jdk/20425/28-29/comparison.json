{"files":[{"patch":"@@ -183,1 +183,2 @@\n-  });}\n+  });\n+}\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,592 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Tests here test the VM-global NMT facility.\n+\/\/  The tests must *not* modify global state! E.g. switch NMT on or off. Instead, they\n+\/\/  should work passively with whatever setting the gtestlauncher had been started with\n+\/\/  - if NMT is enabled, test NMT, otherwise do whatever minimal tests make sense if NMT\n+\/\/  is off.\n+\/\/\n+\/\/ The gtestLauncher then are called with various levels of -XX:NativeMemoryTracking during\n+\/\/  jtreg-controlled gtests (see test\/hotspot\/jtreg\/gtest\/NMTGtests.java)\n+\n+#include \"memory\/memoryReserver.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <stdio.h>\n+\n+\/\/ #define LOG(...) printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout);\n+#define LOG(...)\n+\n+namespace {\n+  struct R {\n+    address _addr;\n+    size_t  _size;\n+  };\n+}\n+\n+#define check(rmr, regions) check_inner((rmr), (regions), ARRAY_SIZE(regions), __FILE__, __LINE__)\n+\n+#define check_empty(rmr)                              \\\n+  do {                                                \\\n+    check_inner((rmr), nullptr, 0, __FILE__, __LINE__);  \\\n+  } while (false)\n+\n+static void diagnostic_print(const ReservedMemoryRegion& rmr) {\n+  LOG(\"In reserved region \" PTR_FORMAT \", size %X:\", p2i(rmr.base()), rmr.size());\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+    LOG(\"   committed region: \" PTR_FORMAT \", size %X\", p2i(region.base()), region.size());\n+    return true;\n+  });\n+  \/\/ CommittedRegionIterator iter = rmr->iterate_committed_regions();\n+  \/\/ LOG(\"In reserved region \" PTR_FORMAT \", size \" SIZE_FORMAT_HEX \":\", p2i(rmr.base()), rmr.size());\n+  \/\/ for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n+  \/\/   LOG(\"   committed region: \" PTR_FORMAT \", size \" SIZE_FORMAT_HEX, p2i(region->base()), region->size());\n+  \/\/ }\n+}\n+\n+static void check_inner(const ReservedMemoryRegion& rmr, R* regions, size_t regions_size, const char* file, int line) {\n+  size_t i = 0;\n+  size_t size = 0;\n+\n+  \/\/ Helpful log\n+  diagnostic_print(rmr);\n+\n+#define WHERE \" from \" << file << \":\" << line\n+\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+    EXPECT_LT(i, regions_size) << WHERE;\n+    EXPECT_EQ(region.base(), regions[i]._addr) << WHERE;\n+    EXPECT_EQ(region.size(), regions[i]._size) << WHERE;\n+    size += region.size();\n+    i++;\n+    return true;\n+  });\n+\n+\n+  \/\/ for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n+  \/\/   EXPECT_LT(i, regions_size) << WHERE;\n+  \/\/   EXPECT_EQ(region->base(), regions[i]._addr) << WHERE;\n+  \/\/   EXPECT_EQ(region->size(), regions[i]._size) << WHERE;\n+  \/\/   size += region->size();\n+  \/\/   i++;\n+  \/\/ }\n+\n+  EXPECT_EQ(i, regions_size) << WHERE;\n+  EXPECT_EQ(size, rmr.committed_size()) << WHERE;\n+}\n+\n+class VirtualMemoryTrackerTest {\n+public:\n+  static void test_add_committed_region_adjacent() {\n+\n+    size_t size  = 0x01000000;\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+\n+    address addr = (address)rs.base();\n+\n+    address frame1 = (address)0x1234;\n+    address frame2 = (address)0x1235;\n+\n+    NativeCallStack stack(&frame1, 1);\n+    NativeCallStack stack2(&frame2, 1);\n+\n+    \/\/ Fetch the added RMR for the space\n+    ReservedMemoryRegion rmr = VirtualMemoryTracker::Instance::tree()->find_reserved_region(addr);\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n+\n+    \/\/ Commit Size Granularity\n+    const size_t cs = 0x1000;\n+\n+    \/\/ Commit adjacent regions with same stack\n+\n+    { \/\/ Commit one region\n+      rtree->commit_region(addr + cs, cs, stack);\n+      R r[] = { {addr + cs, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit adjacent - lower address\n+      rtree->commit_region(addr, cs, stack);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit adjacent - higher address\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n+      R r[] = { {addr, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ Cleanup\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n+\n+\n+    \/\/ Commit adjacent regions with different stacks\n+\n+    { \/\/ Commit one region\n+      rtree->commit_region(addr + cs, cs, stack);\n+      R r[] = { {addr + cs, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit adjacent - lower address\n+      rtree->commit_region(addr, cs, stack2);\n+      R r[] = { {addr,      cs},\n+                {addr + cs, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit adjacent - higher address\n+      rtree->commit_region(addr + 2 * cs, cs, stack2);\n+      R r[] = { {addr,          cs},\n+                {addr +     cs, cs},\n+                {addr + 2 * cs, cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ Cleanup\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n+  }\n+\n+  static void test_add_committed_region_adjacent_overlapping() {\n+\n+    size_t size  = 0x01000000;\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+\n+    address addr = (address)rs.base();\n+\n+    address frame1 = (address)0x1234;\n+    address frame2 = (address)0x1235;\n+\n+    NativeCallStack stack(&frame1, 1);\n+    NativeCallStack stack2(&frame2, 1);\n+\n+    \/\/ Add the reserved memory\n+    VirtualMemoryTracker::Instance::add_reserved_region(addr, size, stack, mtTest);\n+\n+    \/\/ Fetch the added RMR for the space\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n+\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n+\n+    \/\/ Commit Size Granularity\n+    const size_t cs = 0x1000;\n+\n+    \/\/ Commit adjacent and overlapping regions with same stack\n+\n+    { \/\/ Commit two non-adjacent regions\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr + 3 * cs, 2 * cs, stack);\n+      R r[] = { {addr,          2 * cs},\n+                {addr + 3 * cs, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit adjacent and overlapping\n+      rtree->commit_region(addr + 2 * cs, 2 * cs, stack);\n+      R r[] = { {addr, 5 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ revert to two non-adjacent regions\n+    rtree->uncommit_region(addr + 2 * cs, cs);\n+    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n+\n+    { \/\/ Commit overlapping and adjacent\n+      rtree->commit_region(addr + cs, 2 * cs, stack);\n+      R r[] = { {addr, 5 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ Cleanup\n+    rtree->uncommit_region(addr, 5 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n+\n+\n+    \/\/ Commit adjacent and overlapping regions with different stacks\n+\n+    { \/\/ Commit two non-adjacent regions\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr + 3 * cs, 2 * cs, stack);\n+      R r[] = { {addr,          2 * cs},\n+                {addr + 3 * cs, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit adjacent and overlapping\n+      rtree->commit_region(addr + 2 * cs, 2 * cs, stack2);\n+      R r[] = { {addr,          2 * cs},\n+                {addr + 2 * cs, 2 * cs},\n+                {addr + 4 * cs,     cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ revert to two non-adjacent regions\n+    rtree->commit_region(addr, 5 * cs, stack);\n+    rtree->uncommit_region(addr + 2 * cs, cs);\n+    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n+\n+    { \/\/ Commit overlapping and adjacent\n+      rtree->commit_region(addr + cs, 2 * cs, stack2);\n+      R r[] = { {addr,              cs},\n+                {addr +     cs, 2 * cs},\n+                {addr + 3 * cs, 2 * cs} };\n+      check(rmr, r);\n+    }\n+  }\n+\n+  static void test_add_committed_region_overlapping() {\n+\n+    size_t size  = 0x01000000;\n+\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+\n+    address addr = (address)rs.base();\n+\n+    address frame1 = (address)0x1234;\n+    address frame2 = (address)0x1235;\n+\n+    NativeCallStack stack(&frame1, 1);\n+    NativeCallStack stack2(&frame2, 1);\n+\n+    \/\/ Fetch the added RMR for the space\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n+\n+\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n+\n+    \/\/ Commit Size Granularity\n+    const size_t cs = 0x1000;\n+\n+    \/\/ With same stack\n+\n+    { \/\/ Commit one region\n+      rtree->commit_region(addr, cs, stack);\n+      R r[] = { {addr, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit the same region\n+      rtree->commit_region(addr, cs, stack);\n+      R r[] = { {addr, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit a succeeding region\n+      rtree->commit_region(addr + cs, cs, stack);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit  over two regions\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    {\/\/ Commit first part of a region\n+      rtree->commit_region(addr, cs, stack);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit second part of a region\n+      rtree->commit_region(addr + cs, cs, stack);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit a third part\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n+      R r[] = { {addr, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit in the middle of a region\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n+      R r[] = { {addr, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ Cleanup\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n+\n+    \/\/ With preceding region\n+\n+    rtree->commit_region(addr,              cs, stack);\n+    rtree->commit_region(addr + 2 * cs, 3 * cs, stack);\n+\n+    rtree->commit_region(addr + 2 * cs,     cs, stack);\n+    {\n+      R r[] = { {addr,              cs},\n+                {addr + 2 * cs, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    rtree->commit_region(addr + 3 * cs,     cs, stack);\n+    {\n+      R r[] = { {addr,              cs},\n+                {addr + 2 * cs, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    rtree->commit_region(addr + 4 * cs,     cs, stack);\n+    {\n+      R r[] = { {addr,              cs},\n+                {addr + 2 * cs, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    \/\/ Cleanup\n+    rtree->uncommit_region(addr, 5 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n+\n+    \/\/ With different stacks\n+\n+    { \/\/ Commit one region\n+      rtree->commit_region(addr, cs, stack);\n+      R r[] = { {addr, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit the same region\n+      rtree->commit_region(addr, cs, stack2);\n+      R r[] = { {addr, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit a succeeding region\n+      rtree->commit_region(addr + cs, cs, stack);\n+      R r[] = { {addr,      cs},\n+                {addr + cs, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit  over two regions\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    {\/\/ Commit first part of a region\n+      rtree->commit_region(addr, cs, stack2);\n+      R r[] = { {addr,      cs},\n+                {addr + cs, cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit second part of a region\n+      rtree->commit_region(addr + cs, cs, stack2);\n+      R r[] = { {addr, 2 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit a third part\n+      rtree->commit_region(addr + 2 * cs, cs, stack2);\n+      R r[] = { {addr, 3 * cs} };\n+      check(rmr, r);\n+    }\n+\n+    { \/\/ Commit in the middle of a region\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n+      R r[] = { {addr,          cs},\n+                {addr +     cs, cs},\n+                {addr + 2 * cs, cs} };\n+      check(rmr, r);\n+    }\n+  }\n+\n+  static void test_add_committed_region() {\n+    test_add_committed_region_adjacent();\n+    test_add_committed_region_adjacent_overlapping();\n+    test_add_committed_region_overlapping();\n+  }\n+\n+  template <size_t S>\n+  static void fix(R r[S]) {\n+\n+  }\n+\n+  static void test_remove_uncommitted_region() {\n+\n+    size_t size  = 0x01000000;\n+    ReservedSpace rs = MemoryReserver::reserve(size, mtTest);\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+\n+    address addr = (address)rs.base();\n+\n+    address frame1 = (address)0x1234;\n+    address frame2 = (address)0x1235;\n+\n+    NativeCallStack stack(&frame1, 1);\n+    NativeCallStack stack2(&frame2, 1);\n+\n+    \/\/ Fetch the added RMR for the space\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n+\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n+\n+    \/\/ Commit Size Granularity\n+    const size_t cs = 0x1000;\n+\n+    { \/\/ Commit regions\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      R r[] = { {addr, 3 * cs} };\n+      check(rmr, r);\n+\n+      \/\/ Remove only existing\n+      rtree->uncommit_region(addr, 3 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    {\n+      rtree->commit_region(addr + 0 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 4 * cs, cs, stack);\n+\n+      { \/\/ Remove first\n+        rtree->uncommit_region(addr, cs);\n+        R r[] = { {addr + 2 * cs, cs},\n+                  {addr + 4 * cs, cs} };\n+        check(rmr, r);\n+      }\n+\n+      \/\/ add back\n+      rtree->commit_region(addr,          cs, stack);\n+\n+      { \/\/ Remove middle\n+        rtree->uncommit_region(addr + 2 * cs, cs);\n+        R r[] = { {addr + 0 * cs, cs},\n+                  {addr + 4 * cs, cs} };\n+        check(rmr, r);\n+      }\n+\n+      \/\/ add back\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n+\n+      { \/\/ Remove end\n+        rtree->uncommit_region(addr + 4 * cs, cs);\n+        R r[] = { {addr + 0 * cs, cs},\n+                  {addr + 2 * cs, cs} };\n+        check(rmr, r);\n+      }\n+\n+      rtree->uncommit_region(addr, 5 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    { \/\/ Remove larger region\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n+      rtree->uncommit_region(addr, 3 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    { \/\/ Remove smaller region - in the middle\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 1 * cs, cs);\n+      R r[] = { { addr + 0 * cs, cs},\n+                { addr + 2 * cs, cs} };\n+      check(rmr, r);\n+\n+      rtree->uncommit_region(addr, 3 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    { \/\/ Remove smaller region - at the beginning\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 0 * cs, cs);\n+      R r[] = { { addr + 1 * cs, 2 * cs} };\n+      check(rmr, r);\n+\n+      rtree->uncommit_region(addr, 3 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    { \/\/ Remove smaller region - at the end\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 2 * cs, cs);\n+      R r[] = { { addr, 2 * cs} };\n+      check(rmr, r);\n+\n+      rtree->uncommit_region(addr, 3 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    { \/\/ Remove smaller, overlapping region - at the beginning\n+      rtree->commit_region(addr + 1 * cs, 4 * cs, stack);\n+      rtree->uncommit_region(addr, 2 * cs);\n+      R r[] = { { addr + 2 * cs, 3 * cs} };\n+      check(rmr, r);\n+\n+      rtree->uncommit_region(addr + 1 * cs, 4 * cs);\n+      check_empty(rmr);\n+    }\n+\n+    { \/\/ Remove smaller, overlapping region - at the end\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 2 * cs, 2 * cs);\n+      R r[] = { { addr, 2 * cs} };\n+      check(rmr, r);\n+\n+      rtree->uncommit_region(addr, 3 * cs);\n+      check_empty(rmr);\n+    }\n+  }\n+};\n+\n+TEST_VM(NMT_VirtualMemoryTracker, add_committed_region) {\n+  if (MemTracker::tracking_level() >= NMT_detail) {\n+    VirtualMemoryTrackerTest::test_add_committed_region();\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+  }\n+}\n+\n+TEST_VM(NMT_VirtualMemoryTracker, remove_uncommitted_region) {\n+  if (MemTracker::tracking_level() >= NMT_detail) {\n+    VirtualMemoryTrackerTest::test_remove_uncommitted_region();\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":592,"deletions":0,"binary":false,"changes":592,"status":"added"}]}