{"files":[{"patch":"@@ -86,2 +86,0 @@\n-  MemTracker::record_virtual_memory_tag((address)heap_rs.base(), heap_rs.size(), mtGC);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,32 @@\n+\/\/ The nodes for the regions may look like this:\n+\/\/ small letters are existing nodes, capital A and B are the region we are going to find the summary.\n+\/\/ ...--------a-----A----b---c---d----e---B---f---....\n+\/\/ calling visit_range_in_order for [A,B) is not enough to find regions between a---...---f\n+VMATree::SummaryDiff RegionsTree::region_summary(address addr, size_t size) {\n+  NodeHelper prev;\n+  SummaryDiff summary;\n+  VMATree::position A = (VMATree::position)addr;\n+  VMATree::position B = (VMATree::position)A + size;\n+  VMATree::VMATreap::Range ab = tree().find_enclosing_range(A);\n+  VMATree::VMATreap::Range ef = tree().find_enclosing_range(B);\n+  VMATree::position a = ab.start == nullptr ? A : ab.start->key();\n+  VMATree::position f = ef.end == nullptr ? B : ef.end->key();\n+\n+\n+  visit_range_in_order(a, f, [&](Node* node) {\n+    NodeHelper curr(node);\n+    if (prev.is_valid()) {\n+      SingleDiff& single = summary.tag[NMTUtil::tag_to_index(prev.out_tag())];\n+      size_t dist = curr.distance_from(prev);\n+      if (prev.is_reserved_begin())\n+        single.reserve += dist;\n+      if (prev.is_committed_begin()) {\n+        single.reserve += dist;\n+        single.commit += dist;\n+      }\n+    }\n+    prev = curr;\n+    return true;\n+  });\n+  return summary;\n+}\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  SummaryDiff region_summary(address addr, size_t size);\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,27 @@\n+  \/\/ Check overlap\n+  VMATree::SummaryDiff summary = tree()->region_summary(base_addr, size);\n+  VMATree::SingleDiff total{0, 0};\n+  for (int tag = 0; tag < mt_number_of_tags; tag++) {\n+    total.reserve += summary.tag[tag].reserve;\n+    total.commit += summary.tag[tag].commit;\n+  }\n+  bool overlap_accepted = total.reserve == 0;\n+  if (total.reserve != 0) {\n+    \/\/ Overlap with stack region\n+    if (summary.tag[NMTUtil::tag_to_index(mtThreadStack)].reserve != 0) {\n+      guarantee(!CheckJNICalls, \"Attached JNI thread exited without being detached\");\n+      overlap_accepted = true;\n+    }\n+    if (summary.tag[NMTUtil::tag_to_index(mtClassShared)].reserve != 0 ||\n+        summary.tag[NMTUtil::tag_to_index(mtJavaHeap)].reserve != 0 ||\n+        summary.tag[NMTUtil::tag_to_index(mtNone)].reserve != 0\n+        ) {\n+      overlap_accepted = true;\n+    }\n+    if (!overlap_accepted) {\n+      tree()->print_on(tty);\n+      summary.print_on(tty);\n+    }\n+  }\n+  assert(overlap_accepted, \"overlap regions, total reserved area= \" SIZE_FORMAT \", new region: base= \" INTPTR_FORMAT \", end=\" INTPTR_FORMAT,\n+         total.reserve, p2i(base_addr), p2i(base_addr + size));\n@@ -148,0 +175,9 @@\n+    VMATree::SummaryDiff summary = tree()->region_summary(addr, size);\n+    VMATree::SingleDiff total{0, 0};\n+    for (int tag = 0; tag < mt_number_of_tags; tag++) {\n+      total.reserve += summary.tag[tag].reserve;\n+      total.commit += summary.tag[tag].commit;\n+    }\n+    \/\/assert(!stack.is_empty() || (size_t)total.reserve >= size, \"committing non-reserved region\");\n+    \/\/assert(stack.is_empty() || (size_t)total.commit ==  0, \"committing already committed region\");\n+\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+\/\/ Memory regions can be reserved\/committed\/uncommitted\/released by calling MemTracker API which in turn call the corresponding functions in VMT.\n+\/\/ VMT uses RegionsTree to hold and manage the memory regions. Each region has two nodes that each one has address of the region (start\/end) and\n+\/\/ state (reserved\/released\/committed) and MemTag of the regions before and after it.\n@@ -38,29 +41,9 @@\n-\/\/ VMT design:\n-\/\/ - It has a AllStatic member Instance that is used statically\n-\/\/ - It is also possible to create new instances of VMT to use it in a certain workflow, e.g. for tests.\n-\/\/ - The memory addresses of regions are held and managed in a tree (RegionsTree -> VMATree).\n-\/\/ - RegionsTree has methods for visiting reserved-regions and also visiting committed regions of a memory section.\n-\/\/   These methods use the VMATree methods of `visit_in_order` and `visit_range_in_order` to fulfil the task.\n-\/\/ - The memory operations of Reserve\/Commit\/Uncommit\/Release (RCUR) are tracked by updating the underlying tree.\n-\/\/   The RCUR request is done by the RegionsTree class and all the changes of reserved\/committed of the affected\n-\/\/   regions are returned back via a SummaryDiff structure. This structure contains for each memory tag the amounts\n-\/\/   of changes in reserved and committed of each memory tag that to be added or subtracted. These amounts are directly\n-\/\/   applied to the VirtualMemorySummary of NMT.\n-\/\/ - Memory tag of a memory region can be changed by calling `set_reserved_region_tag` method which in turn calls the\n-\/\/   set_tag of VMATree and applies the changes.\n-\/\/ - In the current implementation, all the RCUR operations are allowed with no restriction and in any order, as\n-\/\/   long as the following predicates are true:\n-\/\/     - committed size of a memory tag is <= its reserved size\n-\/\/     - uncommitted size of a memory tag is <= its committed size\n-\/\/     - released size of a memory tag is <= its reserved size\n-\/\/ - In future expansion of VMT:\n-\/\/   - if it is desired to restrict the RCUR operations, the RegionsTree\/VMATree classes\n-\/\/     need to provide corresponding API to:\n-\/\/       - distinguish RCUR ops based on whether a memory tag and\/or call-stack are provided or not.\n-\/\/       - check validity of the requested RCUR with the existing state of the memory regions in the tree.\n-\/\/   - potential restrictions can be listed as:\n-\/\/     - reserving an already committed region\n-\/\/     - committing (when tag+stack are provided) an already committed region\n-\/\/     - committing (when tag+stack are not provided) an already released region\n-\n-\n+\/\/ The memory operations of Reserve\/Commit\/Uncommit\/Release (RCUR) are tracked by updating\/inserting\/deleting the nodes in the tree. When an operation\n+\/\/ changes nodes in the tree, the summary of the changes is returned back in a SummaryDiff struct. This struct shows that how much reserve\/commit amount\n+\/\/ of any specific MemTag is changed. The summary of every operation is accumulated in VirtualMemorySummary class.\n+\/\/\n+\/\/ Not all operations are valid in VMT. The following predicates are checked before the operation is applied to the tree nad\/or VirtualMemorySummary:\n+\/\/   - committed size of a MemTag should be <= of its reserved size\n+\/\/   - uncommitted size of a MemTag should be <= of its committed size\n+\/\/   - released size of a MemTag should be <= of its reserved size\n+\/\/   - reserving an already reserved\/committed region is not valid\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":12,"deletions":29,"binary":false,"changes":41,"status":"modified"}]}