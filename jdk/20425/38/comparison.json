{"files":[{"patch":"@@ -163,1 +163,1 @@\n-  if (!VirtualMemoryTracker::walk_virtual_memory(&virtual_memory_walker)) {\n+  if (!VirtualMemoryTracker::Instance::walk_virtual_memory(&virtual_memory_walker)) {\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-    return VirtualMemoryTracker::walk_virtual_memory(this);\n+    return VirtualMemoryTracker::Instance::walk_virtual_memory(this);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"logging\/log.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -435,7 +438,14 @@\n-    CommittedRegionIterator itr = reserved_rgn->iterate_committed_regions();\n-    const CommittedMemoryRegion* committed_rgn = itr.next();\n-    if (committed_rgn->size() == reserved_rgn->size() && committed_rgn->call_stack()->equals(*stack)) {\n-      \/\/ One region spanning the entire reserved region, with the same stack trace.\n-      \/\/ Don't print this regions because the \"reserved and committed\" line above\n-      \/\/ already indicates that the region is committed.\n-      assert(itr.next() == nullptr, \"Unexpectedly more than one regions\");\n+    bool reserved_and_committed = false;\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*reserved_rgn,\n+                                                                  [&](CommittedMemoryRegion& committed_rgn) {\n+      if (committed_rgn.equals(*reserved_rgn)) {\n+        \/\/ One region spanning the entire reserved region, with the same stack trace.\n+        \/\/ Don't print this regions because the \"reserved and committed\" line above\n+        \/\/ already indicates that the region is committed.\n+        reserved_and_committed = true;\n+        return false;\n+      }\n+      return true;\n+    });\n+\n+    if (reserved_and_committed) {\n@@ -446,3 +456,1 @@\n-  CommittedRegionIterator itr = reserved_rgn->iterate_committed_regions();\n-  const CommittedMemoryRegion* committed_rgn;\n-  while ((committed_rgn = itr.next()) != nullptr) {\n+  auto print_committed_rgn = [&](const CommittedMemoryRegion& crgn) {\n@@ -450,2 +458,2 @@\n-    if (amount_in_current_scale(committed_rgn->size()) == 0) continue;\n-    stack = committed_rgn->call_stack();\n+    if (amount_in_current_scale(crgn.size()) == 0) return;\n+    stack = crgn.call_stack();\n@@ -454,1 +462,1 @@\n-      print_virtual_memory_region(\"committed\", committed_rgn->base(), committed_rgn->size());\n+      print_virtual_memory_region(\"committed\", crgn.base(), crgn.size());\n@@ -459,1 +467,1 @@\n-        INDENT_BY(4, stack->print_on(out);)\n+        INDENT_BY(4, _stackprinter.print_stack(stack);)\n@@ -462,1 +470,7 @@\n-  }\n+  };\n+\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*reserved_rgn,\n+                                                                  [&](CommittedMemoryRegion& crgn) {\n+    print_committed_rgn(crgn);\n+    return true;\n+  });\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        !VirtualMemoryTracker::initialize(level)) {\n+        !VirtualMemoryTracker::Instance::initialize(level)) {\n@@ -127,1 +127,1 @@\n-       VirtualMemoryTracker::print_containing_region(p, out));\n+       VirtualMemoryTracker::Instance::print_containing_region(p, out));\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, mem_tag);\n+      VirtualMemoryTracker::Instance::add_reserved_region((address)addr, size, stack, mem_tag);\n@@ -143,1 +143,1 @@\n-      VirtualMemoryTracker::remove_released_region((address)addr, size);\n+      VirtualMemoryTracker::Instance::remove_released_region((address)addr, size);\n@@ -151,1 +151,1 @@\n-      VirtualMemoryTracker::remove_uncommitted_region((address)addr, size);\n+      VirtualMemoryTracker::Instance::remove_uncommitted_region((address)addr, size);\n@@ -161,2 +161,2 @@\n-      VirtualMemoryTracker::add_reserved_region((address)addr, size, stack, mem_tag);\n-      VirtualMemoryTracker::add_committed_region((address)addr, size, stack);\n+      VirtualMemoryTracker::Instance::add_reserved_region((address)addr, size, stack, mem_tag);\n+      VirtualMemoryTracker::Instance::add_committed_region((address)addr, size, stack);\n@@ -172,1 +172,1 @@\n-      VirtualMemoryTracker::add_committed_region((address)addr, size, stack);\n+      VirtualMemoryTracker::Instance::add_committed_region((address)addr, size, stack);\n@@ -220,1 +220,1 @@\n-      VirtualMemoryTracker::split_reserved_region((address)addr, size, split, mem_tag, split_tag);\n+      VirtualMemoryTracker::Instance::split_reserved_region((address)addr, size, split, mem_tag, split_tag);\n@@ -233,1 +233,1 @@\n-      VirtualMemoryTracker::set_reserved_region_type((address)addr, size, mem_tag);\n+      VirtualMemoryTracker::Instance::set_reserved_region_tag((address)addr, size, mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-      return;\n+      return true;\n@@ -99,0 +99,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  friend class VMTWithVMATreeTest;\n@@ -215,1 +216,1 @@\n-        return;\n+        return true;\n@@ -221,0 +222,1 @@\n+      return true;\n@@ -385,1 +387,3 @@\n-      f(head);\n+      if (!f(head)) {\n+        return;\n+      }\n@@ -412,1 +416,3 @@\n-        f(head);\n+        if (!f(head)) {\n+          return;\n+        }\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -51,1 +50,1 @@\n-  VirtualMemoryTracker::snapshot_thread_stacks();\n+  VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"nmt\/regionsTree.hpp\"\n+\n+VMATree::SummaryDiff RegionsTree::commit_region(address addr, size_t size, const NativeCallStack& stack) {\n+  return commit_mapping((VMATree::position)addr, size, make_region_data(stack, mtNone), \/*use tag inplace*\/ true);\n+}\n+\n+VMATree::SummaryDiff RegionsTree::uncommit_region(address addr, size_t size) {\n+  return uncommit_mapping((VMATree::position)addr, size, make_region_data(NativeCallStack::empty_stack(), mtNone));\n+}\n+\n+#ifdef ASSERT\n+void RegionsTree::NodeHelper::print_on(outputStream* st) {\n+  auto st_str = [&](VMATree::StateType s){\n+    return s == VMATree::StateType::Released ? \"Rl\" :\n+           s == VMATree::StateType::Reserved ? \"Rv\" : \"Cm\";\n+  };\n+  st->print_cr(\"pos: \" INTPTR_FORMAT \" \"\n+                \"%s, %s <|> %s, %s\",\n+                p2i((address)position()),\n+                st_str(in_state()),\n+                NMTUtil::tag_to_name(in_tag()),\n+                st_str(out_state()),\n+                NMTUtil::tag_to_name(out_tag())\n+                );\n+}\n+\n+void RegionsTree::print_on(outputStream* st) {\n+  visit_in_order([&](Node* node) {\n+    NodeHelper curr(node);\n+    curr.print_on(st);\n+    return true;\n+  });\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef NMT_REGIONSTREE_HPP\n+#define NMT_REGIONSTREE_HPP\n+\n+#include \"logging\/log.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+\n+\n+class ReservedMemoryRegion;\n+class CommittedMemoryRegion;\n+\/\/ RegionsTree extends VMATree to add some more specific API and also defines a helper\n+\/\/ for processing the tree nodes in a shorter and more meaningful way.\n+class RegionsTree : public VMATree {\n+  NativeCallStackStorage _ncs_storage;\n+  bool _with_storage;\n+\n+ public:\n+  RegionsTree(bool with_storage) : VMATree() , _ncs_storage(with_storage), _with_storage(with_storage) { }\n+\n+  ReservedMemoryRegion find_reserved_region(address addr);\n+\n+  SummaryDiff commit_region(address addr, size_t size, const NativeCallStack& stack);\n+  SummaryDiff uncommit_region(address addr, size_t size);\n+\n+  using Node = VMATree::TreapNode;\n+\n+  class NodeHelper {\n+      Node* _node;\n+      public:\n+      NodeHelper() : _node(nullptr) { }\n+      NodeHelper(Node* node) : _node(node) { }\n+      inline bool is_valid() const { return _node != nullptr; }\n+      inline void clear_node() { _node = nullptr; }\n+      inline VMATree::position position() const { return _node->key(); }\n+      inline bool is_committed_begin() const { return ((uint8_t)out_state() & (uint8_t)VMATree::StateType::Committed) >= 2; }\n+      inline bool is_released_begin() const { return out_state() == VMATree::StateType::Released; }\n+      inline bool is_reserved_begin() const { return ((uint8_t)out_state() & (uint8_t)VMATree::StateType::Reserved) == 1; }\n+      inline VMATree::StateType in_state() const { return _node->val().in.type(); }\n+      inline VMATree::StateType out_state() const { return _node->val().out.type(); }\n+      inline size_t distance_from(const NodeHelper& other) const {\n+        assert (position() > other.position(), \"negative distance\");\n+        return position() - other.position();\n+      }\n+      inline NativeCallStackStorage::StackIndex out_stack_index() const { return _node->val().out.stack(); }\n+      inline MemTag in_tag() const { return _node->val().in.mem_tag(); }\n+      inline MemTag out_tag() const { return _node->val().out.mem_tag(); }\n+      inline void set_in_tag(MemTag tag) { _node->val().in.set_tag(tag); }\n+      inline void set_out_tag(MemTag tag) { _node->val().out.set_tag(tag); }\n+      DEBUG_ONLY(void print_on(outputStream* st);)\n+    };\n+\n+  DEBUG_ONLY(void print_on(outputStream* st);)\n+\n+  template<typename F>\n+  void visit_committed_regions(const ReservedMemoryRegion& rgn, F func);\n+\n+  template<typename F>\n+  void visit_reserved_regions(F func);\n+\n+  inline RegionData make_region_data(const NativeCallStack& ncs, MemTag tag) {\n+    return RegionData(_ncs_storage.push(ncs), tag);\n+  }\n+\n+  inline const NativeCallStack stack(NodeHelper& node) {\n+    if (!_with_storage) {\n+      return NativeCallStack::empty_stack();\n+    }\n+    NativeCallStackStorage::StackIndex si = node.out_stack_index();\n+    return _ncs_storage.get(si);\n+  }\n+};\n+\n+#endif \/\/ NMT_REGIONSTREE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_NMT_REGIONSTREE_INLINE_HPP\n+#define SHARE_NMT_REGIONSTREE_INLINE_HPP\n+\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+\n+template<typename F>\n+void RegionsTree::visit_committed_regions(const ReservedMemoryRegion& rgn, F func) {\n+  position start = (position)rgn.base();\n+  size_t end = reinterpret_cast<size_t>(rgn.end()) + 1;\n+  size_t comm_size = 0;\n+\n+  NodeHelper prev;\n+  visit_range_in_order(start, end, [&](Node* node) {\n+    NodeHelper curr(node);\n+    if (prev.is_valid() && prev.is_committed_begin()) {\n+      CommittedMemoryRegion cmr((address)prev.position(), curr.distance_from(prev), stack(prev));\n+      if (!func(cmr)) {\n+        return false;\n+      }\n+    }\n+    prev = curr;\n+    return true;\n+  });\n+}\n+\n+template<typename F>\n+void RegionsTree::visit_reserved_regions(F func) {\n+  NodeHelper begin_node, prev;\n+  size_t rgn_size = 0;\n+\n+  visit_in_order([&](Node* node) {\n+    NodeHelper curr(node);\n+    if (prev.is_valid()) {\n+      rgn_size += curr.distance_from(prev);\n+    } else {\n+      begin_node = curr;\n+      rgn_size = 0;\n+    }\n+    prev = curr;\n+    if (curr.is_released_begin() || begin_node.out_tag() != curr.out_tag()) {\n+      auto st = stack(begin_node);\n+      if (rgn_size == 0) {\n+        prev.clear_node();\n+        return true;\n+      }\n+      ReservedMemoryRegion rmr((address)begin_node.position(), rgn_size, st, begin_node.out_tag());\n+      if (!func(rmr)) {\n+        return false;\n+      }\n+      rgn_size = 0;\n+      if (!curr.is_released_begin()) {\n+        begin_node = curr;\n+      } else {\n+        begin_node.clear_node();\n+        prev.clear_node();\n+      }\n+    }\n+\n+    return true;\n+  });\n+}\n+\n+#endif \/\/SHARE_NMT_REGIONSTREE_INLINE_HPP\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -55,1 +54,1 @@\n-  VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);\n+  VirtualMemoryTracker::Instance::add_reserved_region((address)base, size, stack, mtThreadStack);\n@@ -65,1 +64,1 @@\n-  VirtualMemoryTracker::remove_released_region((address)base, size);\n+  MemTracker::record_virtual_memory_release((address)base, size);\n","filename":"src\/hotspot\/share\/nmt\/threadStackTracker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -25,2 +26,0 @@\n-#include \"memory\/metaspaceStats.hpp\"\n-#include \"memory\/metaspaceUtils.hpp\"\n@@ -28,2 +27,0 @@\n-#include \"nmt\/nativeCallStackPrinter.hpp\"\n-#include \"nmt\/threadStackTracker.hpp\"\n@@ -31,0 +28,2 @@\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -34,0 +33,1 @@\n+VirtualMemoryTracker* VirtualMemoryTracker::Instance::_tracker = nullptr;\n@@ -50,1 +50,1 @@\n-  VirtualMemoryTracker::snapshot_thread_stacks();\n+  VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n@@ -54,31 +54,6 @@\n-SortedLinkedList<ReservedMemoryRegion, compare_reserved_region_base>* VirtualMemoryTracker::_reserved_regions;\n-\n-int compare_committed_region(const CommittedMemoryRegion& r1, const CommittedMemoryRegion& r2) {\n-  return r1.compare(r2);\n-}\n-\n-int compare_reserved_region_base(const ReservedMemoryRegion& r1, const ReservedMemoryRegion& r2) {\n-  return r1.compare(r2);\n-}\n-\n-static bool is_mergeable_with(CommittedMemoryRegion* rgn, address addr, size_t size, const NativeCallStack& stack) {\n-  return rgn->adjacent_to(addr, size) && rgn->call_stack()->equals(stack);\n-}\n-\n-static bool is_same_as(CommittedMemoryRegion* rgn, address addr, size_t size, const NativeCallStack& stack) {\n-  \/\/ It would have made sense to use rgn->equals(...), but equals returns true for overlapping regions.\n-  return rgn->same_region(addr, size) && rgn->call_stack()->equals(stack);\n-}\n-\n-static LinkedListNode<CommittedMemoryRegion>* find_preceding_node_from(LinkedListNode<CommittedMemoryRegion>* from, address addr) {\n-  LinkedListNode<CommittedMemoryRegion>* preceding = nullptr;\n-\n-  for (LinkedListNode<CommittedMemoryRegion>* node = from; node != nullptr; node = node->next()) {\n-    CommittedMemoryRegion* rgn = node->data();\n-\n-    \/\/ We searched past the region start.\n-    if (rgn->end() > addr) {\n-      break;\n-    }\n-\n-    preceding = node;\n+bool VirtualMemoryTracker::Instance::initialize(NMT_TrackingLevel level) {\n+  assert(_tracker == nullptr, \"only call once\");\n+  if (level >= NMT_summary) {\n+    void* tracker = os::malloc(sizeof(VirtualMemoryTracker), mtNMT);\n+    if (tracker == nullptr) return false;\n+    _tracker = new (tracker) VirtualMemoryTracker(level == NMT_detail);\n@@ -86,2 +61,1 @@\n-\n-  return preceding;\n+  return true;\n@@ -90,3 +64,0 @@\n-static bool try_merge_with(LinkedListNode<CommittedMemoryRegion>* node, address addr, size_t size, const NativeCallStack& stack) {\n-  if (node != nullptr) {\n-    CommittedMemoryRegion* rgn = node->data();\n@@ -94,7 +65,4 @@\n-    if (is_mergeable_with(rgn, addr, size, stack)) {\n-      rgn->expand_region(addr, size);\n-      return true;\n-    }\n-  }\n-\n-  return false;\n+void VirtualMemoryTracker::Instance::add_reserved_region(address base_addr, size_t size,\n+  const NativeCallStack& stack, MemTag mem_tag) {\n+    assert(_tracker != nullptr, \"Sanity check\");\n+    _tracker->add_reserved_region(base_addr, size, stack, mem_tag);\n@@ -103,7 +71,4 @@\n-static bool try_merge_with(LinkedListNode<CommittedMemoryRegion>* node, LinkedListNode<CommittedMemoryRegion>* other) {\n-  if (other == nullptr) {\n-    return false;\n-  }\n-\n-  CommittedMemoryRegion* rgn = other->data();\n-  return try_merge_with(node, rgn->base(), rgn->size(), *rgn->call_stack());\n+void VirtualMemoryTracker::add_reserved_region(address base_addr, size_t size,\n+  const NativeCallStack& stack, MemTag mem_tag) {\n+  VMATree::SummaryDiff diff = tree()->reserve_mapping((size_t)base_addr, size, tree()->make_region_data(stack, mem_tag));\n+  apply_summary_diff(diff);\n@@ -112,51 +77,3 @@\n-bool ReservedMemoryRegion::add_committed_region(address addr, size_t size, const NativeCallStack& stack) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(contain_region(addr, size), \"Not contain this region\");\n-\n-  \/\/ Find the region that fully precedes the [addr, addr + size) region.\n-  LinkedListNode<CommittedMemoryRegion>* prev = find_preceding_node_from(_committed_regions.head(), addr);\n-  LinkedListNode<CommittedMemoryRegion>* next = (prev != nullptr ? prev->next() : _committed_regions.head());\n-\n-  if (next != nullptr) {\n-    \/\/ Ignore request if region already exists.\n-    if (is_same_as(next->data(), addr, size, stack)) {\n-      return true;\n-    }\n-\n-    \/\/ The new region is after prev, and either overlaps with the\n-    \/\/ next region (and maybe more regions), or overlaps with no region.\n-    if (next->data()->overlap_region(addr, size)) {\n-      \/\/ Remove _all_ overlapping regions, and parts of regions,\n-      \/\/ in preparation for the addition of this new region.\n-      remove_uncommitted_region(addr, size);\n-\n-      \/\/ The remove could have split a region into two and created a\n-      \/\/ new prev region. Need to reset the prev and next pointers.\n-      prev = find_preceding_node_from((prev != nullptr ? prev : _committed_regions.head()), addr);\n-      next = (prev != nullptr ? prev->next() : _committed_regions.head());\n-    }\n-  }\n-\n-  \/\/ At this point the previous overlapping regions have been\n-  \/\/ cleared, and the full region is guaranteed to be inserted.\n-  VirtualMemorySummary::record_committed_memory(size, mem_tag());\n-\n-  \/\/ Try to merge with prev and possibly next.\n-  if (try_merge_with(prev, addr, size, stack)) {\n-    if (try_merge_with(prev, next)) {\n-      \/\/ prev was expanded to contain the new region\n-      \/\/ and next, need to remove next from the list\n-      _committed_regions.remove_after(prev);\n-    }\n-\n-    return true;\n-  }\n-\n-  \/\/ Didn't merge with prev, try with next.\n-  if (try_merge_with(next, addr, size, stack)) {\n-    return true;\n-  }\n-\n-  \/\/ Couldn't merge with any regions - create a new region.\n-  return add_committed_region(CommittedMemoryRegion(addr, size, stack));\n+void VirtualMemoryTracker::Instance::set_reserved_region_tag(address addr, size_t size, MemTag mem_tag) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->set_reserved_region_tag(addr, size, mem_tag);\n@@ -165,31 +82,3 @@\n-bool ReservedMemoryRegion::remove_uncommitted_region(LinkedListNode<CommittedMemoryRegion>* node,\n-  address addr, size_t size) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-\n-  CommittedMemoryRegion* rgn = node->data();\n-  assert(rgn->contain_region(addr, size), \"Has to be contained\");\n-  assert(!rgn->same_region(addr, size), \"Can not be the same region\");\n-\n-  if (rgn->base() == addr ||\n-      rgn->end() == addr + size) {\n-    rgn->exclude_region(addr, size);\n-    return true;\n-  } else {\n-    \/\/ split this region\n-    address top =rgn->end();\n-    \/\/ use this region for lower part\n-    size_t exclude_size = rgn->end() - addr;\n-    rgn->exclude_region(addr, exclude_size);\n-\n-    \/\/ higher part\n-    address high_base = addr + size;\n-    size_t  high_size = top - high_base;\n-\n-    CommittedMemoryRegion high_rgn(high_base, high_size, *rgn->call_stack());\n-    LinkedListNode<CommittedMemoryRegion>* high_node = _committed_regions.add(high_rgn);\n-    assert(high_node == nullptr || node->next() == high_node, \"Should be right after\");\n-    return (high_node != nullptr);\n-  }\n-\n-  return false;\n+void VirtualMemoryTracker::set_reserved_region_tag(address addr, size_t size, MemTag mem_tag) {\n+    VMATree::SummaryDiff diff = tree()->set_tag((VMATree::position) addr, size, mem_tag);\n+    apply_summary_diff(diff);\n@@ -198,30 +87,4 @@\n-bool ReservedMemoryRegion::remove_uncommitted_region(address addr, size_t sz) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(sz > 0, \"Invalid size\");\n-\n-  CommittedMemoryRegion del_rgn(addr, sz, *call_stack());\n-  address end = addr + sz;\n-\n-  LinkedListNode<CommittedMemoryRegion>* head = _committed_regions.head();\n-  LinkedListNode<CommittedMemoryRegion>* prev = nullptr;\n-  CommittedMemoryRegion* crgn;\n-\n-  while (head != nullptr) {\n-    crgn = head->data();\n-\n-    if (crgn->same_region(addr, sz)) {\n-      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), mem_tag());\n-      _committed_regions.remove_after(prev);\n-      return true;\n-    }\n-\n-    \/\/ del_rgn contains crgn\n-    if (del_rgn.contain_region(crgn->base(), crgn->size())) {\n-      VirtualMemorySummary::record_uncommitted_memory(crgn->size(), mem_tag());\n-      head = head->next();\n-      _committed_regions.remove_after(prev);\n-      continue;  \/\/ don't update head or prev\n-    }\n-\n-    \/\/ Found addr in the current crgn. There are 2 subcases:\n-    if (crgn->contain_address(addr)) {\n+void VirtualMemoryTracker::Instance::apply_summary_diff(VMATree::SummaryDiff diff) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->apply_summary_diff(diff);\n+}\n@@ -229,4 +92,24 @@\n-      \/\/ (1) Found addr+size in current crgn as well. (del_rgn is contained in crgn)\n-      if (crgn->contain_address(end - 1)) {\n-        VirtualMemorySummary::record_uncommitted_memory(sz, mem_tag());\n-        return remove_uncommitted_region(head, addr, sz); \/\/ done!\n+void VirtualMemoryTracker::apply_summary_diff(VMATree::SummaryDiff diff) {\n+  VMATree::SingleDiff::delta reserve_delta, commit_delta;\n+  size_t reserved, committed;\n+  MemTag tag = mtNone;\n+  auto print_err = [&](const char* str) {\n+    return;\n+    \/\/ Will be commented out after 8350567. The error outputs corrupt the jdk-image.\n+    \/\/ log_error(nmt)(\"summary mismatch, at %s, for %s,\"\n+    \/\/                \" diff-reserved:  %ld\"\n+    \/\/                \" diff-committed: %ld\"\n+    \/\/                \" vms-reserved: %zu\"\n+    \/\/                \" vms-committed: %zu\",\n+    \/\/                str, NMTUtil::tag_to_name(tag), (long)reserve_delta, (long)commit_delta, reserved, committed);\n+  };\n+\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    reserve_delta = diff.tag[i].reserve;\n+    commit_delta = diff.tag[i].commit;\n+    tag = NMTUtil::index_to_tag(i);\n+    reserved = VirtualMemorySummary::as_snapshot()->by_tag(tag)->reserved();\n+    committed = VirtualMemorySummary::as_snapshot()->by_tag(tag)->committed();\n+    if (reserve_delta != 0) {\n+      if (reserve_delta > 0) {\n+        VirtualMemorySummary::record_reserved_memory(reserve_delta, tag);\n@@ -234,4 +117,5 @@\n-        \/\/ (2) Did not find del_rgn's end in crgn.\n-        size_t size = crgn->end() - del_rgn.base();\n-        crgn->exclude_region(addr, size);\n-        VirtualMemorySummary::record_uncommitted_memory(size, mem_tag());\n+        if ((size_t)-reserve_delta <= reserved) {\n+          VirtualMemorySummary::record_released_memory(-reserve_delta, tag);\n+        } else {\n+          print_err(\"release\");\n+        }\n@@ -239,7 +123,0 @@\n-\n-    } else if (crgn->contain_address(end - 1)) {\n-      \/\/ Found del_rgn's end, but not its base addr.\n-      size_t size = del_rgn.end() - crgn->base();\n-      crgn->exclude_region(crgn->base(), size);\n-      VirtualMemorySummary::record_uncommitted_memory(size, mem_tag());\n-      return true;  \/\/ should be done if the list is sorted properly!\n@@ -247,29 +124,16 @@\n-\n-    prev = head;\n-    head = head->next();\n-  }\n-\n-  return true;\n-}\n-\n-void ReservedMemoryRegion::move_committed_regions(address addr, ReservedMemoryRegion& rgn) {\n-  assert(addr != nullptr, \"Invalid address\");\n-\n-  \/\/ split committed regions\n-  LinkedListNode<CommittedMemoryRegion>* head =\n-    _committed_regions.head();\n-  LinkedListNode<CommittedMemoryRegion>* prev = nullptr;\n-\n-  while (head != nullptr) {\n-    if (head->data()->base() >= addr) {\n-      break;\n-    }\n-    prev = head;\n-    head = head->next();\n-  }\n-\n-  if (head != nullptr) {\n-    if (prev != nullptr) {\n-      prev->set_next(head->next());\n-    } else {\n-      _committed_regions.set_head(nullptr);\n+    if (commit_delta != 0) {\n+      if (commit_delta > 0) {\n+        if ((size_t)commit_delta <= ((size_t)reserve_delta + reserved)) {\n+          VirtualMemorySummary::record_committed_memory(commit_delta, tag);\n+        }\n+        else {\n+          print_err(\"commit\");\n+        }\n+      }\n+      else {\n+        if ((size_t)-commit_delta <= committed) {\n+          VirtualMemorySummary::record_uncommitted_memory(-commit_delta, tag);\n+        } else {\n+          print_err(\"uncommit\");\n+        }\n+      }\n@@ -278,2 +142,0 @@\n-\n-  rgn._committed_regions.set_head(head);\n@@ -282,20 +144,4 @@\n-size_t ReservedMemoryRegion::committed_size() const {\n-  size_t committed = 0;\n-  LinkedListNode<CommittedMemoryRegion>* head =\n-    _committed_regions.head();\n-  while (head != nullptr) {\n-    committed += head->data()->size();\n-    head = head->next();\n-  }\n-  return committed;\n-}\n-\n-void ReservedMemoryRegion::set_mem_tag(MemTag new_mem_tag) {\n-  assert((mem_tag() == mtNone || mem_tag() == new_mem_tag),\n-         \"Overwrite memory tag for region [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), %u->%u.\",\n-         p2i(base()), p2i(end()), (unsigned)mem_tag(), (unsigned)new_mem_tag);\n-  if (mem_tag() != new_mem_tag) {\n-    VirtualMemorySummary::move_reserved_memory(mem_tag(), new_mem_tag, size());\n-    VirtualMemorySummary::move_committed_memory(mem_tag(), new_mem_tag, committed_size());\n-    _mem_tag = new_mem_tag;\n-  }\n+void VirtualMemoryTracker::Instance::add_committed_region(address addr, size_t size,\n+  const NativeCallStack& stack) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->add_committed_region(addr, size, stack);\n@@ -304,18 +150,4 @@\n-address ReservedMemoryRegion::thread_stack_uncommitted_bottom() const {\n-  assert(mem_tag() == mtThreadStack, \"Only for thread stack\");\n-  LinkedListNode<CommittedMemoryRegion>* head = _committed_regions.head();\n-  address bottom = base();\n-  address top = base() + size();\n-  while (head != nullptr) {\n-    address committed_top = head->data()->base() + head->data()->size();\n-    if (committed_top < top) {\n-      \/\/ committed stack guard pages, skip them\n-      bottom = head->data()->base() + head->data()->size();\n-      head = head->next();\n-    } else {\n-      assert(top == committed_top, \"Sanity\");\n-      break;\n-    }\n-  }\n-\n-  return bottom;\n+void VirtualMemoryTracker::add_committed_region(address addr, size_t size,\n+  const NativeCallStack& stack) {\n+    VMATree::SummaryDiff diff = tree()->commit_region(addr, size, stack);\n+    apply_summary_diff(diff);\n@@ -324,8 +156,3 @@\n-bool VirtualMemoryTracker::initialize(NMT_TrackingLevel level) {\n-  assert(_reserved_regions == nullptr, \"only call once\");\n-  if (level >= NMT_summary) {\n-    _reserved_regions = new (std::nothrow, mtNMT)\n-      SortedLinkedList<ReservedMemoryRegion, compare_reserved_region_base>();\n-    return (_reserved_regions != nullptr);\n-  }\n-  return true;\n+void VirtualMemoryTracker::Instance::remove_uncommitted_region(address addr, size_t size) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->remove_uncommitted_region(addr, size);\n@@ -334,5 +161,1 @@\n-bool VirtualMemoryTracker::add_reserved_region(address base_addr, size_t size,\n-    const NativeCallStack& stack, MemTag mem_tag) {\n-  assert(base_addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n+void VirtualMemoryTracker::remove_uncommitted_region(address addr, size_t size) {\n@@ -340,74 +163,2 @@\n-\n-  ReservedMemoryRegion  rgn(base_addr, size, stack, mem_tag);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-\n-  log_debug(nmt)(\"Add reserved region \\'%s\\' (\" INTPTR_FORMAT \", %zu)\",\n-                rgn.mem_tag_name(), p2i(rgn.base()), rgn.size());\n-  if (reserved_rgn == nullptr) {\n-    VirtualMemorySummary::record_reserved_memory(size, mem_tag);\n-    return _reserved_regions->add(rgn) != nullptr;\n-  } else {\n-    \/\/ Deal with recursive reservation\n-    \/\/ os::reserve_memory() -> pd_reserve_memory() -> os::reserve_memory()\n-    \/\/ See JDK-8198226.\n-    if (reserved_rgn->same_region(base_addr, size) &&\n-        (reserved_rgn->mem_tag() == mem_tag || reserved_rgn->mem_tag() == mtNone)) {\n-      reserved_rgn->set_call_stack(stack);\n-      reserved_rgn->set_mem_tag(mem_tag);\n-      return true;\n-    } else {\n-      assert(reserved_rgn->overlap_region(base_addr, size), \"Must be\");\n-\n-      \/\/ Overlapped reservation.\n-      \/\/ It can happen when the regions are thread stacks, as JNI\n-      \/\/ thread does not detach from VM before exits, and leads to\n-      \/\/ leak JavaThread object\n-      if (reserved_rgn->mem_tag() == mtThreadStack) {\n-        guarantee(!CheckJNICalls, \"Attached JNI thread exited without being detached\");\n-        \/\/ Overwrite with new region\n-\n-        \/\/ Release old region\n-        VirtualMemorySummary::record_uncommitted_memory(reserved_rgn->committed_size(), reserved_rgn->mem_tag());\n-        VirtualMemorySummary::record_released_memory(reserved_rgn->size(), reserved_rgn->mem_tag());\n-\n-        \/\/ Add new region\n-        VirtualMemorySummary::record_reserved_memory(rgn.size(), mem_tag);\n-\n-        *reserved_rgn = rgn;\n-        return true;\n-      }\n-\n-      \/\/ CDS mapping region.\n-      \/\/ CDS reserves the whole region for mapping CDS archive, then maps each section into the region.\n-      \/\/ NMT reports CDS as a whole.\n-      if (reserved_rgn->mem_tag() == mtClassShared) {\n-        log_debug(nmt)(\"CDS reserved region \\'%s\\' as a whole (\" INTPTR_FORMAT \", %zu)\",\n-                      reserved_rgn->mem_tag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n-        assert(reserved_rgn->contain_region(base_addr, size), \"Reserved CDS region should contain this mapping region\");\n-        return true;\n-      }\n-\n-      \/\/ Mapped CDS string region.\n-      \/\/ The string region(s) is part of the java heap.\n-      if (reserved_rgn->mem_tag() == mtJavaHeap) {\n-        log_debug(nmt)(\"CDS reserved region \\'%s\\' as a whole (\" INTPTR_FORMAT \", %zu)\",\n-                      reserved_rgn->mem_tag_name(), p2i(reserved_rgn->base()), reserved_rgn->size());\n-        assert(reserved_rgn->contain_region(base_addr, size), \"Reserved heap region should contain this mapping region\");\n-        return true;\n-      }\n-\n-      \/\/ Print some more details. Don't use UL here to avoid circularities.\n-      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\\n\"\n-                    \"       new region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\",\n-                    p2i(reserved_rgn->base()), p2i(reserved_rgn->end()), (unsigned)reserved_rgn->mem_tag(),\n-                    p2i(base_addr), p2i(base_addr + size), (unsigned)mem_tag);\n-      if (MemTracker::tracking_level() == NMT_detail) {\n-        tty->print_cr(\"Existing region allocated from:\");\n-        reserved_rgn->call_stack()->print_on(tty);\n-        tty->print_cr(\"New region allocated from:\");\n-        stack.print_on(tty);\n-      }\n-      ShouldNotReachHere();\n-      return false;\n-    }\n-  }\n+  VMATree::SummaryDiff diff = tree()->uncommit_region(addr, size);\n+  apply_summary_diff(diff);\n@@ -416,15 +167,3 @@\n-void VirtualMemoryTracker::set_reserved_region_type(address addr, size_t size, MemTag mem_tag) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion   rgn(addr, 1);\n-  ReservedMemoryRegion*  reserved_rgn = _reserved_regions->find(rgn);\n-  if (reserved_rgn != nullptr) {\n-    assert(reserved_rgn->contain_address(addr), \"Containment\");\n-    if (reserved_rgn->mem_tag() != mem_tag) {\n-      assert(reserved_rgn->mem_tag() == mtNone, \"Overwrite memory tag (should be mtNone, is: \\\"%s\\\")\",\n-             NMTUtil::tag_to_name(reserved_rgn->mem_tag()));\n-      reserved_rgn->set_mem_tag(mem_tag);\n-    }\n-  }\n+void VirtualMemoryTracker::Instance::remove_released_region(address addr, size_t size) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->remove_released_region(addr, size);\n@@ -433,20 +172,3 @@\n-bool VirtualMemoryTracker::add_committed_region(address addr, size_t size,\n-  const NativeCallStack& stack) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-\n-  if (reserved_rgn == nullptr) {\n-    log_debug(nmt)(\"Add committed region \\'%s\\', No reserved region found for  (\" INTPTR_FORMAT \", %zu)\",\n-                  rgn.mem_tag_name(),  p2i(rgn.base()), rgn.size());\n-  }\n-  assert(reserved_rgn != nullptr, \"Add committed region, No reserved region found\");\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  bool result = reserved_rgn->add_committed_region(addr, size, stack);\n-  log_debug(nmt)(\"Add committed region \\'%s\\'(\" INTPTR_FORMAT \", %zu) %s\",\n-                reserved_rgn->mem_tag_name(),  p2i(rgn.base()), rgn.size(), (result ? \"Succeeded\" : \"Failed\"));\n-  return result;\n+void VirtualMemoryTracker::remove_released_region(address addr, size_t size) {\n+  VMATree::SummaryDiff diff = tree()->release_mapping((VMATree::position)addr, size);\n+  apply_summary_diff(diff);\n@@ -455,15 +177,3 @@\n-bool VirtualMemoryTracker::remove_uncommitted_region(address addr, size_t size) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-  assert(reserved_rgn != nullptr, \"No reserved region (\" INTPTR_FORMAT \", %zu)\", p2i(addr), size);\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  const char* type_name = reserved_rgn->mem_tag_name();  \/\/ after remove, info is not complete\n-  bool result = reserved_rgn->remove_uncommitted_region(addr, size);\n-  log_debug(nmt)(\"Removed uncommitted region \\'%s\\' (\" INTPTR_FORMAT \", %zu) %s\",\n-                 type_name,  p2i(addr), size, (result ? \" Succeeded\" : \"Failed\"));\n-  return result;\n+void VirtualMemoryTracker::Instance::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  _tracker->split_reserved_region(addr, size, split, mem_tag, split_mem_tag);\n@@ -472,19 +182,3 @@\n-bool VirtualMemoryTracker::remove_released_region(ReservedMemoryRegion* rgn) {\n-  assert(rgn != nullptr, \"Sanity check\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  \/\/ uncommit regions within the released region\n-  ReservedMemoryRegion backup(*rgn);\n-  bool result = rgn->remove_uncommitted_region(rgn->base(), rgn->size());\n-  log_debug(nmt)(\"Remove uncommitted region \\'%s\\' (\" INTPTR_FORMAT \", %zu) %s\",\n-                backup.mem_tag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n-  if (!result) {\n-    return false;\n-  }\n-\n-  VirtualMemorySummary::record_released_memory(rgn->size(), rgn->mem_tag());\n-  result =  _reserved_regions->remove(*rgn);\n-  log_debug(nmt)(\"Removed region \\'%s\\' (\" INTPTR_FORMAT \", %zu) from _reserved_regions %s\" ,\n-                backup.mem_tag_name(), p2i(backup.base()), backup.size(), (result ? \"Succeeded\" : \"Failed\"));\n-  return result;\n+void VirtualMemoryTracker::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag) {\n+  add_reserved_region(addr, split, NativeCallStack::empty_stack(), mem_tag);\n+  add_reserved_region(addr + split, size - split, NativeCallStack::empty_stack(), split_mem_tag);\n@@ -493,17 +187,4 @@\n-bool VirtualMemoryTracker::remove_released_region(address addr, size_t size) {\n-  assert(addr != nullptr, \"Invalid address\");\n-  assert(size > 0, \"Invalid size\");\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::assert_locked();\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-\n-  if (reserved_rgn == nullptr) {\n-    log_debug(nmt)(\"No reserved region found for (\" INTPTR_FORMAT \", %zu)!\",\n-                  p2i(rgn.base()), rgn.size());\n-  }\n-  assert(reserved_rgn != nullptr, \"No reserved region\");\n-  if (reserved_rgn->same_region(addr, size)) {\n-    return remove_released_region(reserved_rgn);\n-  }\n+bool VirtualMemoryTracker::Instance::print_containing_region(const void* p, outputStream* st) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  return _tracker->print_containing_region(p, st);\n+}\n@@ -511,2 +192,3 @@\n-  \/\/ uncommit regions within the released region\n-  if (!reserved_rgn->remove_uncommitted_region(addr, size)) {\n+bool VirtualMemoryTracker::print_containing_region(const void* p, outputStream* st) {\n+  ReservedMemoryRegion rmr = tree()->find_reserved_region((address)p);\n+  if (!rmr.contain_address((address)p)) {\n@@ -515,21 +197,4 @@\n-\n-  if (reserved_rgn->mem_tag() == mtClassShared) {\n-    if (reserved_rgn->contain_region(addr, size)) {\n-      \/\/ This is an unmapped CDS region, which is part of the reserved shared\n-      \/\/ memory region.\n-      \/\/ See special handling in VirtualMemoryTracker::add_reserved_region also.\n-      return true;\n-    }\n-\n-    if (size > reserved_rgn->size()) {\n-      \/\/ This is from release the whole region spanning from archive space to class space,\n-      \/\/ so we release them altogether.\n-      ReservedMemoryRegion class_rgn(addr + reserved_rgn->size(),\n-                                     (size - reserved_rgn->size()));\n-      ReservedMemoryRegion* cls_rgn = _reserved_regions->find(class_rgn);\n-      assert(cls_rgn != nullptr, \"Class space region  not recorded?\");\n-      assert(cls_rgn->mem_tag() == mtClass, \"Must be class mem tag\");\n-      remove_released_region(reserved_rgn);\n-      remove_released_region(cls_rgn);\n-      return true;\n-    }\n+  st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n+               p2i(p), p2i(rmr.base()), p2i(rmr.end()), NMTUtil::tag_to_enum_name(rmr.mem_tag()));\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    rmr.call_stack()->print_on(st);\n@@ -537,0 +202,3 @@\n+  st->cr();\n+  return true;\n+}\n@@ -538,1 +206,4 @@\n-  VirtualMemorySummary::record_released_memory(size, reserved_rgn->mem_tag());\n+bool VirtualMemoryTracker::Instance::walk_virtual_memory(VirtualMemoryWalker* walker) {\n+  assert(_tracker != nullptr, \"Sanity check\");\n+  return _tracker->walk_virtual_memory(walker);\n+}\n@@ -540,15 +211,4 @@\n-  assert(reserved_rgn->contain_region(addr, size), \"Not completely contained\");\n-  if (reserved_rgn->base() == addr ||\n-      reserved_rgn->end() == addr + size) {\n-      reserved_rgn->exclude_region(addr, size);\n-    return true;\n-  } else {\n-    address top = reserved_rgn->end();\n-    address high_base = addr + size;\n-    ReservedMemoryRegion high_rgn(high_base, top - high_base,\n-      *reserved_rgn->call_stack(), reserved_rgn->mem_tag());\n-\n-    \/\/ use original region for lower region\n-    reserved_rgn->exclude_region(addr, top - addr);\n-    LinkedListNode<ReservedMemoryRegion>* new_rgn = _reserved_regions->add(high_rgn);\n-    if (new_rgn == nullptr) {\n+bool VirtualMemoryTracker::walk_virtual_memory(VirtualMemoryWalker* walker) {\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n+  tree()->visit_reserved_regions([&](ReservedMemoryRegion& rgn) {\n+    if (!walker->do_allocation_site(&rgn)) {\n@@ -556,3 +216,0 @@\n-    } else {\n-      reserved_rgn->move_committed_regions(addr, *new_rgn->data());\n-      return true;\n@@ -560,1 +217,3 @@\n-  }\n+    return true;\n+  });\n+  return true;\n@@ -563,13 +222,9 @@\n-\/\/ Given an existing memory mapping registered with NMT, split the mapping in\n-\/\/  two. The newly created two mappings will be registered under the call\n-\/\/  stack and the memory tags of the original section.\n-bool VirtualMemoryTracker::split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_tag) {\n-\n-  ReservedMemoryRegion  rgn(addr, size);\n-  ReservedMemoryRegion* reserved_rgn = _reserved_regions->find(rgn);\n-  assert(reserved_rgn->same_region(addr, size), \"Must be identical region\");\n-  assert(reserved_rgn != nullptr, \"No reserved region\");\n-  assert(reserved_rgn->committed_size() == 0, \"Splitting committed region?\");\n-\n-  NativeCallStack original_stack = *reserved_rgn->call_stack();\n-  MemTag original_tag = reserved_rgn->mem_tag();\n+size_t ReservedMemoryRegion::committed_size() const {\n+  size_t committed = 0;\n+  size_t result = 0;\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*this, [&](CommittedMemoryRegion& crgn) {\n+    result += crgn.size();\n+    return true;\n+  });\n+  return result;\n+}\n@@ -577,7 +232,14 @@\n-  const char* name = reserved_rgn->mem_tag_name();\n-  remove_released_region(reserved_rgn);\n-  log_debug(nmt)(\"Split region \\'%s\\' (\" INTPTR_FORMAT \", %zu)  with size %zu\",\n-                name, p2i(rgn.base()), rgn.size(), split);\n-  \/\/ Now, create two new regions.\n-  add_reserved_region(addr, split, original_stack, mem_tag);\n-  add_reserved_region(addr + split, size - split, original_stack, split_tag);\n+address ReservedMemoryRegion::thread_stack_uncommitted_bottom() const {\n+  address bottom = base();\n+  address top = base() + size();\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(*this, [&](CommittedMemoryRegion& crgn) {\n+    address committed_top = crgn.base() + crgn.size();\n+    if (committed_top < top) {\n+      \/\/ committed stack guard pages, skip them\n+      bottom = crgn.base() + crgn.size();\n+    } else {\n+      assert(top == committed_top, \"Sanity, top=\" INTPTR_FORMAT \" , com-top=\" INTPTR_FORMAT, p2i(top), p2i(committed_top));\n+      return false;;\n+    }\n+    return true;\n+  });\n@@ -585,1 +247,1 @@\n-  return true;\n+  return bottom;\n@@ -588,1 +250,0 @@\n-\n@@ -640,1 +301,0 @@\n-      ReservedMemoryRegion* region = const_cast<ReservedMemoryRegion*>(rgn);\n@@ -652,1 +312,1 @@\n-        region->add_committed_region(committed_start, committed_size, ncs);\n+        VirtualMemoryTracker::Instance::add_committed_region(committed_start, committed_size, ncs);\n@@ -665,1 +325,1 @@\n-void VirtualMemoryTracker::snapshot_thread_stacks() {\n+void VirtualMemoryTracker::Instance::snapshot_thread_stacks() {\n@@ -670,9 +330,5 @@\n-bool VirtualMemoryTracker::walk_virtual_memory(VirtualMemoryWalker* walker) {\n-  assert(_reserved_regions != nullptr, \"Sanity check\");\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n-  \/\/ Check that the _reserved_regions haven't been deleted.\n-  if (_reserved_regions != nullptr) {\n-    LinkedListNode<ReservedMemoryRegion>* head = _reserved_regions->head();\n-    while (head != nullptr) {\n-      const ReservedMemoryRegion* rgn = head->peek();\n-      if (!walker->do_allocation_site(rgn)) {\n+ReservedMemoryRegion RegionsTree::find_reserved_region(address addr) {\n+    ReservedMemoryRegion rmr;\n+    auto contain_region = [&](ReservedMemoryRegion& region_in_tree) {\n+      if (region_in_tree.contain_address(addr)) {\n+        rmr = region_in_tree;\n@@ -681,4 +337,4 @@\n-      head = head->next();\n-    }\n-   }\n-  return true;\n+      return true;\n+    };\n+    visit_reserved_regions(contain_region);\n+    return rmr;\n@@ -687,30 +343,3 @@\n-class PrintRegionWalker : public VirtualMemoryWalker {\n-private:\n-  const address               _p;\n-  outputStream*               _st;\n-  NativeCallStackPrinter      _stackprinter;\n-public:\n-  PrintRegionWalker(const void* p, outputStream* st) :\n-    _p((address)p), _st(st), _stackprinter(st) { }\n-\n-  bool do_allocation_site(const ReservedMemoryRegion* rgn) {\n-    if (rgn->contain_address(_p)) {\n-      _st->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"], tag %s\",\n-        p2i(_p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), NMTUtil::tag_to_enum_name(rgn->mem_tag()));\n-      if (MemTracker::tracking_level() == NMT_detail) {\n-        _stackprinter.print_stack(rgn->call_stack());\n-        _st->cr();\n-      }\n-      return false;\n-    }\n-    return true;\n-  }\n-};\n-\n-\/\/ If p is contained within a known memory region, print information about it to the\n-\/\/ given stream and return true; false otherwise.\n-bool VirtualMemoryTracker::print_containing_region(const void* p, outputStream* st) {\n-  PrintRegionWalker walker(p, st);\n-  return !walk_virtual_memory(&walker);\n-\n-}\n+bool CommittedMemoryRegion::equals(const ReservedMemoryRegion& rmr) const {\n+  return size() == rmr.size() && call_stack()->equals(*(rmr.call_stack()));\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":164,"deletions":535,"binary":false,"changes":699,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/metaspace.hpp\" \/\/ For MetadataType\n-#include \"memory\/metaspaceStats.hpp\"\n@@ -32,1 +29,2 @@\n-#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+#include \"nmt\/regionsTree.hpp\"\n@@ -34,1 +32,0 @@\n-#include \"utilities\/linkedlist.hpp\"\n@@ -38,0 +35,16 @@\n+\/\/ VirtualMemoryTracker (VMT) is an internal class of the MemTracker.\n+\/\/ All the Hotspot code use only the MemTracker interface to register the memory operations in NMT.\n+\/\/ Memory regions can be reserved\/committed\/uncommitted\/released by calling MemTracker API which in turn call the corresponding functions in VMT.\n+\/\/ VMT uses RegionsTree to hold and manage the memory regions. Each region has two nodes that each one has address of the region (start\/end) and\n+\/\/ state (reserved\/released\/committed) and MemTag of the regions before and after it.\n+\/\/\n+\/\/ The memory operations of Reserve\/Commit\/Uncommit\/Release are tracked by updating\/inserting\/deleting the nodes in the tree. When an operation\n+\/\/ changes nodes in the tree, the summary of the changes is returned back in a SummaryDiff struct. This struct shows that how much reserve\/commit amount\n+\/\/ of any specific MemTag is changed. The summary of every operation is accumulated in VirtualMemorySummary class.\n+\/\/\n+\/\/ Not all operations are valid in VMT. The following predicates are checked before the operation is applied to the tree and\/or VirtualMemorySummary:\n+\/\/   - committed size of a MemTag should be <= of its reserved size\n+\/\/   - uncommitted size of a MemTag should be <= of its committed size\n+\/\/   - released size of a MemTag should be <= of its reserved size\n+\n+\n@@ -279,2 +292,5 @@\n-  CommittedMemoryRegion(address addr, size_t size, const NativeCallStack& stack) :\n-    VirtualMemoryRegion(addr, size), _stack(stack) { }\n+  CommittedMemoryRegion()\n+    : VirtualMemoryRegion((address)1, 1), _stack(NativeCallStack::empty_stack()) { }\n+\n+  CommittedMemoryRegion(address addr, size_t size, const NativeCallStack& stack)\n+    : VirtualMemoryRegion(addr, size), _stack(stack) { }\n@@ -284,0 +300,1 @@\n+  bool equals(const ReservedMemoryRegion& other) const;\n@@ -286,4 +303,0 @@\n-\n-typedef LinkedListIterator<CommittedMemoryRegion> CommittedRegionIterator;\n-\n-int compare_committed_region(const CommittedMemoryRegion&, const CommittedMemoryRegion&);\n@@ -292,3 +305,0 @@\n-  SortedLinkedList<CommittedMemoryRegion, compare_committed_region>\n-    _committed_regions;\n-\n@@ -296,1 +306,1 @@\n-  MemTag           _mem_tag;\n+  MemTag         _mem_tag;\n@@ -299,0 +309,5 @@\n+  bool is_valid() { return base() != (address)1 && size() != 1;}\n+\n+  ReservedMemoryRegion()\n+    : VirtualMemoryRegion((address)1, 1), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n+\n@@ -300,2 +315,2 @@\n-    MemTag mem_tag = mtNone) :\n-    VirtualMemoryRegion(base, size), _stack(stack), _mem_tag(mem_tag) { }\n+    MemTag mem_tag = mtNone)\n+    : VirtualMemoryRegion(base, size), _stack(stack), _mem_tag(mem_tag) { }\n@@ -304,2 +319,2 @@\n-  ReservedMemoryRegion(address base, size_t size) :\n-    VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n+  ReservedMemoryRegion(address base, size_t size)\n+    : VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _mem_tag(mtNone) { }\n@@ -308,2 +323,2 @@\n-  ReservedMemoryRegion(const ReservedMemoryRegion& rr) :\n-    VirtualMemoryRegion(rr.base(), rr.size()) {\n+  ReservedMemoryRegion(const ReservedMemoryRegion& rr)\n+    : VirtualMemoryRegion(rr.base(), rr.size()) {\n@@ -316,1 +331,0 @@\n-  void  set_mem_tag(MemTag mem_tag);\n@@ -322,4 +336,1 @@\n-  bool    add_committed_region(address addr, size_t size, const NativeCallStack& stack);\n-  bool    remove_uncommitted_region(address addr, size_t size);\n-\n-  size_t  committed_size() const;\n+  size_t committed_size() const;\n@@ -327,7 +338,0 @@\n-  \/\/ move committed regions that higher than specified address to\n-  \/\/ the new region\n-  void    move_committed_regions(address addr, ReservedMemoryRegion& rgn);\n-\n-  CommittedRegionIterator iterate_committed_regions() const {\n-    return CommittedRegionIterator(_committed_regions.head());\n-  }\n@@ -339,1 +343,1 @@\n-    _stack   = *other.call_stack();\n+    _stack = *other.call_stack();\n@@ -341,8 +345,0 @@\n-    _committed_regions.clear();\n-\n-    CommittedRegionIterator itr = other.iterate_committed_regions();\n-    const CommittedMemoryRegion* rgn = itr.next();\n-    while (rgn != nullptr) {\n-      _committed_regions.add(*rgn);\n-      rgn = itr.next();\n-    }\n@@ -353,13 +349,1 @@\n-  const char* mem_tag_name() const { return NMTUtil::tag_to_name(_mem_tag); }\n-\n- private:\n-  \/\/ The committed region contains the uncommitted region, subtract the uncommitted\n-  \/\/ region from this committed region\n-  bool remove_uncommitted_region(LinkedListNode<CommittedMemoryRegion>* node,\n-    address addr, size_t sz);\n-\n-  bool add_committed_region(const CommittedMemoryRegion& rgn) {\n-    assert(rgn.base() != nullptr, \"Invalid base address\");\n-    assert(size() > 0, \"Invalid size\");\n-    return _committed_regions.add(rgn) != nullptr;\n-  }\n+  const char* tag_name() const { return NMTUtil::tag_to_name(_mem_tag); }\n@@ -368,2 +352,0 @@\n-int compare_reserved_region_base(const ReservedMemoryRegion& r1, const ReservedMemoryRegion& r2);\n-\n@@ -375,4 +357,0 @@\n-\/\/ Main class called from MemTracker to track virtual memory allocations, commits and releases.\n-class VirtualMemoryTracker : AllStatic {\n-  friend class VirtualMemoryTrackerTest;\n-  friend class CommittedVirtualMemoryTest;\n@@ -380,2 +358,2 @@\n- public:\n-  static bool initialize(NMT_TrackingLevel level);\n+class VirtualMemoryTracker {\n+  RegionsTree _tree;\n@@ -383,1 +361,2 @@\n-  static bool add_reserved_region (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+ public:\n+  VirtualMemoryTracker(bool is_detailed_mode) : _tree(is_detailed_mode) { }\n@@ -385,5 +364,5 @@\n-  static bool add_committed_region      (address base_addr, size_t size, const NativeCallStack& stack);\n-  static bool remove_uncommitted_region (address base_addr, size_t size);\n-  static bool remove_released_region    (address base_addr, size_t size);\n-  static bool remove_released_region    (ReservedMemoryRegion* rgn);\n-  static void set_reserved_region_type  (address addr, size_t size, MemTag mem_tag);\n+  void add_reserved_region       (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  void add_committed_region      (address base_addr, size_t size, const NativeCallStack& stack);\n+  void remove_uncommitted_region (address base_addr, size_t size);\n+  void remove_released_region    (address base_addr, size_t size);\n+  void set_reserved_region_tag   (address addr, size_t size, MemTag mem_tag);\n@@ -393,2 +372,2 @@\n-  \/\/  stack and the memory tag of the original section.\n-  static bool split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_type);\n+  \/\/  stack and the memory tags of the original section.\n+  void split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag);\n@@ -397,1 +376,1 @@\n-  static bool walk_virtual_memory(VirtualMemoryWalker* walker);\n+  bool walk_virtual_memory(VirtualMemoryWalker* walker);\n@@ -401,1 +380,1 @@\n-  static bool print_containing_region(const void* p, outputStream* st);\n+  bool print_containing_region(const void* p, outputStream* st);\n@@ -404,4 +383,27 @@\n-  static void snapshot_thread_stacks();\n-\n- private:\n-  static SortedLinkedList<ReservedMemoryRegion, compare_reserved_region_base>* _reserved_regions;\n+  void snapshot_thread_stacks();\n+  void apply_summary_diff(VMATree::SummaryDiff diff);\n+  RegionsTree* tree() { return &_tree; }\n+\n+  class Instance : public AllStatic {\n+    friend class VirtualMemoryTrackerTest;\n+    friend class CommittedVirtualMemoryTest;\n+\n+    static VirtualMemoryTracker* _tracker;\n+\n+   public:\n+    using RegionData = VMATree::RegionData;\n+    static bool initialize(NMT_TrackingLevel level);\n+\n+    static void add_reserved_region       (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+    static void add_committed_region      (address base_addr, size_t size, const NativeCallStack& stack);\n+    static void remove_uncommitted_region (address base_addr, size_t size);\n+    static void remove_released_region    (address base_addr, size_t size);\n+    static void set_reserved_region_tag   (address addr, size_t size, MemTag mem_tag);\n+    static void split_reserved_region(address addr, size_t size, size_t split, MemTag mem_tag, MemTag split_mem_tag);\n+    static bool walk_virtual_memory(VirtualMemoryWalker* walker);\n+    static bool print_containing_region(const void* p, outputStream* st);\n+    static void snapshot_thread_stacks();\n+    static void apply_summary_diff(VMATree::SummaryDiff diff);\n+\n+    static RegionsTree* tree() { return _tracker->tree(); }\n+  };\n@@ -410,2 +412,1 @@\n-#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n-\n+#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":80,"deletions":79,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-const char* VMATree::statetype_strings[3] = {\n-  \"reserved\", \"committed\", \"released\",\n+const char* VMATree::statetype_strings[4] = {\n+  \"released\",\"reserved\", \"only-committed\", \"committed\",\n@@ -151,0 +151,1 @@\n+    return true;\n@@ -164,1 +165,0 @@\n-\n@@ -213,1 +213,0 @@\n-    rescom.commit += B - A;\n@@ -215,0 +214,1 @@\n+    rescom.commit += B - A;\n@@ -224,0 +224,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -43,0 +44,1 @@\n+  friend class VMTWithVMATreeTest;\n@@ -58,1 +60,3 @@\n-  enum class StateType : uint8_t { Reserved, Committed, Released, LAST };\n+  \/\/ Bit fields view: bit 0 for Reserved, bit 1 for Committed.\n+  \/\/ Setting a region as Committed preserves the Reserved state.\n+  enum class StateType : uint8_t { Reserved = 1, Committed = 3, Released = 0, st_number_of_states = 4 };\n@@ -61,1 +65,1 @@\n-  static const char* statetype_strings[static_cast<uint8_t>(StateType::LAST)];\n+  static const char* statetype_strings[static_cast<uint8_t>(StateType::st_number_of_states)];\n@@ -67,1 +71,1 @@\n-    assert(type != StateType::LAST, \"must be\");\n+    assert(type < StateType::st_number_of_states, \"must be\");\n@@ -195,1 +199,0 @@\n-\n@@ -218,6 +221,2 @@\n-  SummaryDiff release_mapping(position from, size size) {\n-    return register_mapping(from, from + size, StateType::Released, VMATree::empty_regiondata);\n-  }\n-\n-  VMATreap& tree() {\n-    return _tree;\n+  SummaryDiff release_mapping(position from, position sz) {\n+    return register_mapping(from, from + sz, StateType::Released, VMATree::empty_regiondata);\n@@ -235,1 +234,5 @@\n-\n+  template<typename F>\n+  void visit_range_in_order(const position& from, const position& to, F f) {\n+    _tree.visit_range_in_order(from, to, f);\n+  }\n+  VMATreap& tree() { return _tree; }\n@@ -237,1 +240,0 @@\n-\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  friend class VMTWithVMATreeTest;\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"unittest.hpp\"\n-\n-\/\/ Tests the assignment operator of ReservedMemoryRegion\n-TEST_VM(NMT, ReservedRegionCopy) {\n-  address dummy1 = (address)0x10000000;\n-  NativeCallStack stack1(&dummy1, 1);\n-  ReservedMemoryRegion region1(dummy1, os::vm_page_size(), stack1, mtThreadStack);\n-  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region1.mem_tag());\n-  region1.add_committed_region(dummy1, os::vm_page_size(), stack1);\n-  address dummy2 = (address)0x20000000;\n-  NativeCallStack stack2(&dummy2, 1);\n-  ReservedMemoryRegion region2(dummy2, os::vm_page_size(), stack2, mtCode);\n-  VirtualMemorySummary::record_reserved_memory(os::vm_page_size(), region2.mem_tag());\n-  region2.add_committed_region(dummy2, os::vm_page_size(), stack2);\n-\n-  region2 = region1;\n-\n-  CommittedRegionIterator itr = region2.iterate_committed_regions();\n-  const CommittedMemoryRegion* rgn = itr.next();\n-  ASSERT_EQ(rgn->base(), dummy1); \/\/ Now we should see dummy1\n-  ASSERT_EQ(region2.mem_tag(), mtThreadStack); \/\/ Should be correct memory tag\n-  ASSERT_EQ(region2.call_stack()->get_frame(0), dummy1); \/\/ Check the stack\n-  rgn = itr.next();\n-  ASSERT_EQ(rgn, (const CommittedMemoryRegion*)nullptr); \/\/ and nothing else\n-}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_reserved_region.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n@@ -29,1 +30,0 @@\n-\n@@ -75,0 +75,1 @@\n+      return true;\n@@ -164,0 +165,1 @@\n+      return true;\n@@ -171,0 +173,1 @@\n+      return true;\n@@ -177,0 +180,1 @@\n+      return true;\n@@ -187,0 +191,1 @@\n+      return true;\n@@ -193,0 +198,1 @@\n+      return true;\n@@ -200,0 +206,1 @@\n+      return true;\n@@ -211,0 +218,1 @@\n+      return true;\n@@ -220,0 +228,1 @@\n+      return true;\n@@ -229,0 +238,1 @@\n+      return true;\n@@ -244,0 +254,1 @@\n+      return true;\n@@ -253,0 +264,1 @@\n+      return true;\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/nmtNativeCallStackStorage.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"nmt\/vmatree.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"unittest.hpp\"\n+\n+class NMTRegionsTreeTest : public testing::Test {\n+ public:\n+  RegionsTree rt;\n+  NMTRegionsTreeTest() : rt(true) { }\n+};\n+\n+TEST_VM_F(NMTRegionsTreeTest, ReserveCommitTwice) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  VMATree::RegionData rd2 = rt.make_region_data(ncs, mtGC);\n+  VMATree::SummaryDiff diff;\n+  diff = rt.reserve_mapping(0, 100, rd);\n+  EXPECT_EQ(100, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  diff = rt.commit_region(0, 50, ncs);\n+  diff = rt.reserve_mapping(0, 100, rd);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  diff = rt.reserve_mapping(0, 100, rd2);\n+  EXPECT_EQ(-100, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(100, diff.tag[NMTUtil::tag_to_index(mtGC)].reserve);\n+  diff = rt.commit_region(0, 50, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtGC)].reserve);\n+  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtGC)].commit);\n+  diff = rt.commit_region(0, 50, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, CommitUncommitRegion) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(0, 100, rd);\n+  VMATree::SummaryDiff diff = rt.commit_region(0, 50, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  diff = rt.commit_region((address)60, 10, ncs);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(10, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  diff = rt.uncommit_region(0, 50);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, FindReservedRegion) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(1000, 50, rd);\n+  rt.reserve_mapping(1200, 50, rd);\n+  rt.reserve_mapping(1300, 50, rd);\n+  rt.reserve_mapping(1400, 50, rd);\n+  ReservedMemoryRegion rmr;\n+  rmr = rt.find_reserved_region((address)1205);\n+  EXPECT_EQ(rmr.base(), (address)1200);\n+  rmr = rt.find_reserved_region((address)1305);\n+  EXPECT_EQ(rmr.base(), (address)1300);\n+  rmr = rt.find_reserved_region((address)1405);\n+  EXPECT_EQ(rmr.base(), (address)1400);\n+  rmr = rt.find_reserved_region((address)1005);\n+  EXPECT_EQ(rmr.base(), (address)1000);\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, VisitReservedRegions) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(1000, 50, rd);\n+  rt.reserve_mapping(1200, 50, rd);\n+  rt.reserve_mapping(1300, 50, rd);\n+  rt.reserve_mapping(1400, 50, rd);\n+\n+  rt.visit_reserved_regions([&](const ReservedMemoryRegion& rgn) {\n+    EXPECT_EQ(((size_t)rgn.base()) % 100, 0UL);\n+    EXPECT_EQ(rgn.size(), 50UL);\n+    return true;\n+  });\n+}\n+\n+TEST_VM_F(NMTRegionsTreeTest, VisitCommittedRegions) {\n+  NativeCallStack ncs;\n+  VMATree::RegionData rd = rt.make_region_data(ncs, mtTest);\n+  rt.reserve_mapping(1000, 50, rd);\n+  rt.reserve_mapping(1200, 50, rd);\n+  rt.reserve_mapping(1300, 50, rd);\n+  rt.reserve_mapping(1400, 50, rd);\n+\n+  rt.commit_region((address)1010, 5UL, ncs);\n+  rt.commit_region((address)1020, 5UL, ncs);\n+  rt.commit_region((address)1030, 5UL, ncs);\n+  rt.commit_region((address)1040, 5UL, ncs);\n+  ReservedMemoryRegion rmr((address)1000, 50);\n+  size_t count = 0;\n+  rt.visit_committed_regions(rmr, [&](CommittedMemoryRegion& crgn) {\n+    count++;\n+    EXPECT_EQ((((size_t)crgn.base()) % 100) \/ 10, count);\n+    EXPECT_EQ(crgn.size(), 5UL);\n+    return true;\n+  });\n+  EXPECT_EQ(count, 4UL);\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/nmt\/test_regions_tree.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -81,0 +82,1 @@\n+      return true;\n@@ -137,0 +139,1 @@\n+      return true;\n@@ -162,0 +165,1 @@\n+      return true;\n@@ -196,0 +200,1 @@\n+    return true;\n@@ -234,0 +239,1 @@\n+      return true;\n@@ -273,0 +279,1 @@\n+      return true;\n@@ -540,0 +547,12 @@\n+TEST_VM_F(NMTVMATreeTest, SummaryAccountingReserveAsUncommit) {\n+  Tree tree;\n+  Tree::RegionData rd(NCS::StackIndex(), mtTest);\n+  VMATree::SummaryDiff diff1 = tree.reserve_mapping(1200, 100, rd);\n+  VMATree::SummaryDiff diff2 = tree.commit_mapping(1210, 50, rd);\n+  EXPECT_EQ(100, diff1.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+  EXPECT_EQ(50, diff2.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  VMATree::SummaryDiff diff3 = tree.reserve_mapping(1220, 20, rd);\n+  EXPECT_EQ(-20, diff3.tag[NMTUtil::tag_to_index(mtTest)].commit);\n+  EXPECT_EQ(0, diff3.tag[NMTUtil::tag_to_index(mtTest)].reserve);\n+}\n+\n@@ -728,0 +747,30 @@\n+TEST_VM_F(NMTVMATreeTest, SetMemTypeOfRegions) {\n+  Tree tree;\n+  Tree::RegionData rd(NCS::StackIndex(), mtNone);\n+  int count = 0;\n+  auto dump_and_count_nodes = [&](TNode* n){\n+    tty->print_cr(\"%zu,in.type: %d, in.tag: %s, out.type: %d, out.tag: %s\" ,\n+    (size_t)n->key(), (int)n->val().in.type(), NMTUtil::tag_to_name(n->val().out.mem_tag()),\n+    (int)n->val().out.type(), NMTUtil::tag_to_name(n->val().in.mem_tag()));\n+    count++;\n+    return true;\n+  };\n+  tree.reserve_mapping(1200, 100, rd); \/\/ nodes in tree: 1200, 1300\n+  tree.commit_mapping(1210, 50, rd);   \/\/ nodes in tree: 1200, 1210, 1260, 1300\n+  tree.reserve_mapping(1100, 100, rd); \/\/ nodes in tree: 1100, 1210, 1260, 1300\n+\n+\n+  VMATree::SummaryDiff diff = tree.set_tag(1200, 100, mtClassShared);\n+  EXPECT_EQ(100, diff.tag[NMTUtil::tag_to_index(mtClassShared)].reserve);\n+  EXPECT_EQ(50, diff.tag[NMTUtil::tag_to_index(mtClassShared)].commit);\n+  EXPECT_EQ(-100, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+  EXPECT_EQ(-50, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+\n+  diff = tree.set_tag(1100, 100, mtGC);\n+  EXPECT_EQ(100, diff.tag[NMTUtil::tag_to_index(mtGC)].reserve);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtGC)].commit);\n+  EXPECT_EQ(-100, diff.tag[NMTUtil::tag_to_index(mtNone)].reserve);\n+  EXPECT_EQ(0, diff.tag[NMTUtil::tag_to_index(mtNone)].commit);\n+}\n+\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n+#include \"nmt\/regionsTree.hpp\"\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -40,1 +41,1 @@\n-    VirtualMemoryTracker::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n+    VirtualMemoryTracker::Instance::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n@@ -43,1 +44,1 @@\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n+    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n@@ -45,2 +46,3 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(stack_end, stack_size));\n-    ASSERT_TRUE(rmr != nullptr);\n+    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region(stack_end);\n+    ASSERT_TRUE(rmr_found.is_valid());\n+    ASSERT_EQ(rmr_found.base(), stack_end);\n@@ -48,4 +50,0 @@\n-    ASSERT_EQ(rmr->base(), stack_end);\n-    ASSERT_EQ(rmr->size(), stack_size);\n-\n-    CommittedRegionIterator iter = rmr->iterate_committed_regions();\n@@ -59,4 +57,3 @@\n-\n-    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n-      if (region->base() + region->size() == stack_top) {\n-        ASSERT_TRUE(region->size() <= stack_size);\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr) {\n+      if (cmr.base() + cmr.size() == stack_top) {\n+        EXPECT_TRUE(cmr.size() <= stack_size);\n@@ -65,2 +62,1 @@\n-\n-      if(i_addr < stack_top && i_addr >= region->base()) {\n+      if(i_addr < stack_top && i_addr >= cmr.base()) {\n@@ -69,1 +65,0 @@\n-\n@@ -71,1 +66,3 @@\n-    }\n+      return true;\n+    });\n+\n@@ -75,1 +72,0 @@\n-    ASSERT_TRUE(found_stack_top);\n@@ -77,0 +73,1 @@\n+    ASSERT_TRUE(found_stack_top);\n@@ -105,1 +102,1 @@\n-    VirtualMemoryTracker::add_reserved_region((address)base, size, stack, mtThreadStack);\n+    VirtualMemoryTracker::Instance::add_reserved_region((address)base, size, stack, mtThreadStack);\n@@ -108,1 +105,5 @@\n-    VirtualMemoryTracker::snapshot_thread_stacks();\n+    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n+\n+    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    ASSERT_TRUE(rmr_found.is_valid());\n+    ASSERT_EQ(rmr_found.base(), (address)base);\n@@ -110,2 +111,0 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion((address)base, size));\n-    ASSERT_TRUE(rmr != nullptr);\n@@ -114,6 +113,3 @@\n-    CommittedRegionIterator iter = rmr->iterate_committed_regions();\n-    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n-      if (region->size() == size) {\n-        \/\/ platforms that do not support precise tracking.\n-        ASSERT_TRUE(iter.next() == nullptr);\n-        break;\n+    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr){\n+      if (cmr.size() == size) {\n+        return false;\n@@ -122,1 +118,1 @@\n-        check_covered_pages(region->base(), region->size(), (address)base, touch_pages, page_num);\n+        check_covered_pages(cmr.base(), cmr.size(), (address)base, touch_pages, page_num);\n@@ -124,1 +120,2 @@\n-    }\n+      return true;\n+    });\n@@ -135,4 +132,3 @@\n-    VirtualMemoryTracker::remove_released_region((address)base, size);\n-\n-    rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion((address)base, size));\n-    ASSERT_TRUE(rmr == nullptr);\n+    VirtualMemoryTracker::Instance::remove_released_region((address)base, size);\n+    rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    ASSERT_TRUE(!rmr_found.is_valid());\n@@ -236,2 +232,1 @@\n-TEST_VM(CommittedVirtualMemoryTracker, test_committed_virtualmemory_region) {\n-\n+TEST_VM(NMTCommittedVirtualMemoryTracker, test_committed_virtualmemory_region) {\n@@ -254,1 +249,1 @@\n-TEST_VM(CommittedVirtualMemory, test_committed_in_range){\n+TEST_VM(NMTCommittedVirtualMemory, test_committed_in_range){\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"nmt\/regionsTree.inline.hpp\"\n@@ -59,6 +60,6 @@\n-static void diagnostic_print(ReservedMemoryRegion* rmr) {\n-  CommittedRegionIterator iter = rmr->iterate_committed_regions();\n-  LOG(\"In reserved region \" PTR_FORMAT \", size 0x%zx:\", p2i(rmr->base()), rmr->size());\n-  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n-    LOG(\"   committed region: \" PTR_FORMAT \", size 0x%zx\", p2i(region->base()), region->size());\n-  }\n+static void diagnostic_print(const ReservedMemoryRegion& rmr) {\n+  LOG(\"In reserved region \" PTR_FORMAT \", size %X:\", p2i(rmr.base()), rmr.size());\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+    LOG(\"   committed region: \" PTR_FORMAT \", size %X\", p2i(region.base()), region.size());\n+    return true;\n+  });\n@@ -67,2 +68,1 @@\n-static void check_inner(ReservedMemoryRegion* rmr, R* regions, size_t regions_size, const char* file, int line) {\n-  CommittedRegionIterator iter = rmr->iterate_committed_regions();\n+static void check_inner(const ReservedMemoryRegion& rmr, R* regions, size_t regions_size, const char* file, int line) {\n@@ -77,1 +77,1 @@\n-  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n+  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n@@ -79,3 +79,3 @@\n-    EXPECT_EQ(region->base(), regions[i]._addr) << WHERE;\n-    EXPECT_EQ(region->size(), regions[i]._size) << WHERE;\n-    size += region->size();\n+    EXPECT_EQ(region.base(), regions[i]._addr) << WHERE;\n+    EXPECT_EQ(region.size(), regions[i]._size) << WHERE;\n+    size += region.size();\n@@ -83,1 +83,2 @@\n-  }\n+    return true;\n+  });\n@@ -86,1 +87,1 @@\n-  EXPECT_EQ(size, rmr->committed_size()) << WHERE;\n+  EXPECT_EQ(size, rmr.committed_size()) << WHERE;\n@@ -106,1 +107,2 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    ReservedMemoryRegion rmr = VirtualMemoryTracker::Instance::tree()->find_reserved_region(addr);\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n@@ -108,2 +110,2 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -117,1 +119,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -123,1 +125,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -129,1 +131,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n@@ -135,2 +137,2 @@\n-    rmr->remove_uncommitted_region(addr, 3 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -142,1 +144,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -148,1 +150,1 @@\n-      rmr->add_committed_region(addr, cs, stack2);\n+      rtree->commit_region(addr, cs, stack2);\n@@ -155,1 +157,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack2);\n+      rtree->commit_region(addr + 2 * cs, cs, stack2);\n@@ -163,2 +165,2 @@\n-    rmr->remove_uncommitted_region(addr, 3 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -182,1 +184,1 @@\n-    VirtualMemoryTracker::add_reserved_region(addr, size, stack, mtTest);\n+    VirtualMemoryTracker::Instance::add_reserved_region(addr, size, stack, mtTest);\n@@ -185,1 +187,2 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n@@ -187,2 +190,2 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -196,2 +199,2 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n-      rmr->add_committed_region(addr + 3 * cs, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr + 3 * cs, 2 * cs, stack);\n@@ -204,1 +207,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, 2 * cs, stack);\n+      rtree->commit_region(addr + 2 * cs, 2 * cs, stack);\n@@ -210,2 +213,2 @@\n-    rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n-    ASSERT_EQ(rmr->committed_size(), 4 * cs);\n+    rtree->uncommit_region(addr + 2 * cs, cs);\n+    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n@@ -214,1 +217,1 @@\n-      rmr->add_committed_region(addr + cs, 2 * cs, stack);\n+      rtree->commit_region(addr + cs, 2 * cs, stack);\n@@ -220,2 +223,2 @@\n-    rmr->remove_uncommitted_region(addr, 5 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 5 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -227,2 +230,2 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n-      rmr->add_committed_region(addr + 3 * cs, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr + 3 * cs, 2 * cs, stack);\n@@ -235,1 +238,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, 2 * cs, stack2);\n+      rtree->commit_region(addr + 2 * cs, 2 * cs, stack2);\n@@ -243,3 +246,3 @@\n-    rmr->add_committed_region(addr, 5 * cs, stack);\n-    rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n-    ASSERT_EQ(rmr->committed_size(), 4 * cs);\n+    rtree->commit_region(addr, 5 * cs, stack);\n+    rtree->uncommit_region(addr + 2 * cs, cs);\n+    ASSERT_EQ(rmr.committed_size(), 4 * cs);\n@@ -248,1 +251,1 @@\n-      rmr->add_committed_region(addr + cs, 2 * cs, stack2);\n+      rtree->commit_region(addr + cs, 2 * cs, stack2);\n@@ -272,1 +275,2 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n@@ -274,2 +278,3 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -283,1 +288,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -289,1 +294,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -295,1 +300,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -301,1 +306,1 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n@@ -307,1 +312,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -313,1 +318,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -319,1 +324,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n@@ -325,1 +330,1 @@\n-      rmr->add_committed_region(addr + 1 * cs, cs, stack);\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n@@ -331,2 +336,2 @@\n-    rmr->remove_uncommitted_region(addr, 3 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 3 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -336,2 +341,2 @@\n-    rmr->add_committed_region(addr,              cs, stack);\n-    rmr->add_committed_region(addr + 2 * cs, 3 * cs, stack);\n+    rtree->commit_region(addr,              cs, stack);\n+    rtree->commit_region(addr + 2 * cs, 3 * cs, stack);\n@@ -339,1 +344,1 @@\n-    rmr->add_committed_region(addr + 2 * cs,     cs, stack);\n+    rtree->commit_region(addr + 2 * cs,     cs, stack);\n@@ -346,1 +351,1 @@\n-    rmr->add_committed_region(addr + 3 * cs,     cs, stack);\n+    rtree->commit_region(addr + 3 * cs,     cs, stack);\n@@ -353,1 +358,1 @@\n-    rmr->add_committed_region(addr + 4 * cs,     cs, stack);\n+    rtree->commit_region(addr + 4 * cs,     cs, stack);\n@@ -361,2 +366,2 @@\n-    rmr->remove_uncommitted_region(addr, 5 * cs);\n-    ASSERT_EQ(rmr->committed_size(), 0u);\n+    rtree->uncommit_region(addr, 5 * cs);\n+    ASSERT_EQ(rmr.committed_size(), 0u);\n@@ -367,1 +372,1 @@\n-      rmr->add_committed_region(addr, cs, stack);\n+      rtree->commit_region(addr, cs, stack);\n@@ -373,1 +378,1 @@\n-      rmr->add_committed_region(addr, cs, stack2);\n+      rtree->commit_region(addr, cs, stack2);\n@@ -379,1 +384,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack);\n+      rtree->commit_region(addr + cs, cs, stack);\n@@ -386,1 +391,1 @@\n-      rmr->add_committed_region(addr, 2 * cs, stack);\n+      rtree->commit_region(addr, 2 * cs, stack);\n@@ -392,1 +397,1 @@\n-      rmr->add_committed_region(addr, cs, stack2);\n+      rtree->commit_region(addr, cs, stack2);\n@@ -399,1 +404,1 @@\n-      rmr->add_committed_region(addr + cs, cs, stack2);\n+      rtree->commit_region(addr + cs, cs, stack2);\n@@ -405,1 +410,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack2);\n+      rtree->commit_region(addr + 2 * cs, cs, stack2);\n@@ -411,1 +416,1 @@\n-      rmr->add_committed_region(addr + 1 * cs, cs, stack);\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n@@ -445,1 +450,2 @@\n-    ReservedMemoryRegion* rmr = VirtualMemoryTracker::_reserved_regions->find(ReservedMemoryRegion(addr, size));\n+    RegionsTree* rtree = VirtualMemoryTracker::Instance::tree();\n+    ReservedMemoryRegion rmr = rtree->find_reserved_region(addr);\n@@ -447,2 +453,2 @@\n-    ASSERT_EQ(rmr->size(), size);\n-    ASSERT_EQ(rmr->base(), addr);\n+    ASSERT_EQ(rmr.size(), size);\n+    ASSERT_EQ(rmr.base(), addr);\n@@ -454,1 +460,1 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n+      rtree->commit_region(addr, 3 * cs, stack);\n@@ -459,1 +465,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -464,3 +470,3 @@\n-      rmr->add_committed_region(addr + 0 * cs, cs, stack);\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n-      rmr->add_committed_region(addr + 4 * cs, cs, stack);\n+      rtree->commit_region(addr + 0 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 4 * cs, cs, stack);\n@@ -469,1 +475,1 @@\n-        rmr->remove_uncommitted_region(addr, cs);\n+        rtree->uncommit_region(addr, cs);\n@@ -476,1 +482,1 @@\n-      rmr->add_committed_region(addr,          cs, stack);\n+      rtree->commit_region(addr,          cs, stack);\n@@ -479,1 +485,1 @@\n-        rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n+        rtree->uncommit_region(addr + 2 * cs, cs);\n@@ -486,1 +492,1 @@\n-      rmr->add_committed_region(addr + 2 * cs, cs, stack);\n+      rtree->commit_region(addr + 2 * cs, cs, stack);\n@@ -489,1 +495,1 @@\n-        rmr->remove_uncommitted_region(addr + 4 * cs, cs);\n+        rtree->uncommit_region(addr + 4 * cs, cs);\n@@ -495,1 +501,1 @@\n-      rmr->remove_uncommitted_region(addr, 5 * cs);\n+      rtree->uncommit_region(addr, 5 * cs);\n@@ -500,2 +506,2 @@\n-      rmr->add_committed_region(addr + 1 * cs, cs, stack);\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->commit_region(addr + 1 * cs, cs, stack);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -506,2 +512,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 1 * cs, cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 1 * cs, cs);\n@@ -512,1 +518,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -517,2 +523,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 0 * cs, cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 0 * cs, cs);\n@@ -522,1 +528,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -527,2 +533,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 2 * cs, cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 2 * cs, cs);\n@@ -532,1 +538,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -537,2 +543,2 @@\n-      rmr->add_committed_region(addr + 1 * cs, 4 * cs, stack);\n-      rmr->remove_uncommitted_region(addr, 2 * cs);\n+      rtree->commit_region(addr + 1 * cs, 4 * cs, stack);\n+      rtree->uncommit_region(addr, 2 * cs);\n@@ -542,1 +548,1 @@\n-      rmr->remove_uncommitted_region(addr + 1 * cs, 4 * cs);\n+      rtree->uncommit_region(addr + 1 * cs, 4 * cs);\n@@ -547,2 +553,2 @@\n-      rmr->add_committed_region(addr, 3 * cs, stack);\n-      rmr->remove_uncommitted_region(addr + 2 * cs, 2 * cs);\n+      rtree->commit_region(addr, 3 * cs, stack);\n+      rtree->uncommit_region(addr + 2 * cs, 2 * cs);\n@@ -552,1 +558,1 @@\n-      rmr->remove_uncommitted_region(addr, 3 * cs);\n+      rtree->uncommit_region(addr, 3 * cs);\n@@ -572,1 +578,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":112,"deletions":106,"binary":false,"changes":218,"status":"modified"}]}