{"files":[{"patch":"@@ -47,34 +47,0 @@\n-\/\/ The nodes for the regions may look like this:\n-\/\/ small letters are existing nodes, capital A and B are the region we are going to find the summary.\n-\/\/ ...--------a-----A----b---c---d----e---B---f---....\n-\/\/ calling visit_range_in_order for [A,B) is not enough to find regions between a---...---f\n-VMATree::SummaryDiff RegionsTree::region_summary(address addr, size_t size) {\n-  NodeHelper prev;\n-  SummaryDiff summary;\n-  VMATree::position A = (VMATree::position)addr;\n-  VMATree::position B = (VMATree::position)A + size;\n-  VMATree::VMATreap::Range ab = tree().find_enclosing_range(A);\n-  VMATree::VMATreap::Range ef = tree().find_enclosing_range(B);\n-  VMATree::position a = ab.start == nullptr ? A : ab.start->key();\n-  VMATree::position f = ef.end == nullptr ? B : ef.end->key();\n-\n-\n-  visit_range_in_order(a, f, [&](Node* node) {\n-    NodeHelper curr(node);\n-    if (prev.is_valid()) {\n-      SingleDiff& single = summary.tag[NMTUtil::tag_to_index(prev.out_tag())];\n-      size_t dist = curr.distance_from(prev);\n-      if (prev.is_reserved_begin())\n-        single.reserve += dist;\n-      if (prev.is_committed_begin()) {\n-        single.reserve += dist;\n-        single.commit += dist;\n-      }\n-    }\n-    prev = curr;\n-    return true;\n-  });\n-  return summary;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.cpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  SummaryDiff region_summary(address addr, size_t size);\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,23 +71,0 @@\n-  \/\/ Check overlap\n-  VMATree::SummaryDiff summary = tree()->region_summary(base_addr, size);\n-  VMATree::SingleDiff total{0, 0};\n-  for (int tag = 0; tag < mt_number_of_tags; tag++) {\n-    total.reserve += summary.tag[tag].reserve;\n-    total.commit += summary.tag[tag].commit;\n-  }\n-  bool overlap_accepted = total.reserve == 0;\n-  if (total.reserve != 0) {\n-    \/\/ Overlap with stack region\n-    if (summary.tag[NMTUtil::tag_to_index(mtThreadStack)].reserve != 0) {\n-      guarantee(!CheckJNICalls, \"Attached JNI thread exited without being detached\");\n-      overlap_accepted = true;\n-    }\n-    if (summary.tag[NMTUtil::tag_to_index(mtClassShared)].reserve != 0 ||\n-        summary.tag[NMTUtil::tag_to_index(mtJavaHeap)].reserve != 0 ||\n-        summary.tag[NMTUtil::tag_to_index(mtNone)].reserve != 0\n-        ) {\n-      overlap_accepted = true;\n-    }\n-  }\n-  assert(overlap_accepted, \"overlap regions, total reserved area= \" SIZE_FORMAT \", new region: base= \" INTPTR_FORMAT \", end=\" INTPTR_FORMAT,\n-         (size_t)total.reserve, p2i(base_addr), p2i(base_addr + size));\n@@ -171,9 +148,0 @@\n-    VMATree::SummaryDiff summary = tree()->region_summary(addr, size);\n-    VMATree::SingleDiff total{0, 0};\n-    for (int tag = 0; tag < mt_number_of_tags; tag++) {\n-      total.reserve += summary.tag[tag].reserve;\n-      total.commit += summary.tag[tag].commit;\n-    }\n-    \/\/assert(!stack.is_empty() || (size_t)total.reserve >= size, \"committing non-reserved region\");\n-    \/\/assert(stack.is_empty() || (size_t)total.commit ==  0, \"committing already committed region\");\n-\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/\/   - reserving an already reserved\/committed region is not valid\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}