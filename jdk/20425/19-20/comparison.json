{"files":[{"patch":"@@ -2,1 +2,0 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +104,1 @@\n-                    str, NMTUtil::tag_to_name(tag), (ssize_t)reserve_delta, (ssize_t)commit_delta, reserved, committed);\n+                    str, NMTUtil::tag_to_name(tag), (long)reserve_delta, (long)commit_delta, reserved, committed);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +25,2 @@\n-#ifndef NMT_VIRTUALMEMORYTRACKER_HPP\n-#define NMT_VIRTUALMEMORYTRACKER_HPP\n+#ifndef SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n+#define SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n@@ -107,1 +106,1 @@\n-#endif \/\/ NMT_VIRTUALMEMORYTRACKER_HPP\n\\ No newline at end of file\n+#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-      \/\/assert(state != StateType::Committed && leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n+      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -763,70 +763,0 @@\n-TEST_VM_F(NMTVMATreeTest, SetFlag) {\n-  \/\/ The gc\/cds case with only reserved data\n-  {\n-    VMATree::SummaryDiff diff;\n-    Tree::RegionData rd(NCS::StackIndex(), mtNone);\n-    VMATree tree;\n-    diff = diff.apply(tree.reserve_mapping(0, 500, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = diff.apply(tree.reserve_mapping(500, 100, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = diff.apply(tree.set_tag(0, 500, mtGC));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = diff.apply(tree.set_tag(500, 100, mtClassShared));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-  }\n-\n-  \/\/ Now let's add in some committed data\n-  {\n-    VMATree::SummaryDiff diff;\n-    Tree::RegionData rd(NCS::StackIndex(), mtNone);\n-    VMATree tree;\n-    diff = diff.apply(tree.reserve_mapping(0, 500, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = diff.apply(tree.reserve_mapping(500, 100, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    \/\/ The committed areas\n-\n-    diff = diff.apply(tree.commit_mapping(100, 125, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-    diff = diff.apply(tree.commit_mapping(550, 10, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = diff.apply(tree.commit_mapping(565, 10, rd));\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = tree.set_tag(500, 100, mtClassShared);\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-\n-    diff = tree.set_tag(0, 500, mtGC);\n-    diff.print_self();\n-    tree.print_self();\n-    tty->cr();\n-  }\n-}\n-\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/*\n- * @test\n- * @bug 8341696\n- * @summary Allow C2 to also optimize non-fluid string builder calls.\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.irTests.stringopts.TestFluidAndNonFluid\n- *\/\n-package compiler.c2.irTests.stringopts;\n-\n-import compiler.lib.ir_framework.*;\n-import jdk.test.lib.Asserts;\n-\n-public class TestFluidAndNonFluid {\n-\n-    public static int unknown = 1;\n-\n-    public static void main(String[] args) {\n-        \/\/ Dont inline any StringBuilder methods for this IR test to check if string opts are applied or not.\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=dontinline,java.lang.StringBuilder::*\");\n-    }\n-\n-    @DontInline\n-    public static void opaque(StringBuilder builder) {\n-        builder.append(\"Z\");\n-    }\n-\n-    @Run(test = {\"fluid\", \"nonFluid\", \"nonFinal\", \"nonFluidExtraneousVariable\", \"nonFluidConditional\",\n-        \"nonFluidOpaqueCall\"})\n-    public void runMethod() {\n-        Asserts.assertEQ(\"0ac\", fluidNoParam());\n-        Asserts.assertEQ(\"ac\", nonFluidNoParam());\n-        Asserts.assertEQ(\"ac\", fluid(\"c\"));\n-        Asserts.assertEQ(\"ac\", nonFluid(\"c\"));\n-        Asserts.assertEQ(\"ac\", nonFinal(\"c\"));\n-        Asserts.assertEQ(\"ac\", nonFluidExtraneousVariable(\"c\"));\n-        Asserts.assertEQ(\"ac\", nonFluidConditional(\"c\"));\n-        Asserts.assertEQ(\"aZ\", nonFluidOpaqueCall());\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\", IRNode.INTRINSIC_TRAP})\n-    public static String fluidNoParam() {\n-        return new StringBuilder(\"0\").append(\"a\").append(\"c\").toString();\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\", IRNode.INTRINSIC_TRAP})\n-    public static String nonFluidNoParam() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"a\");\n-        sb.append(\"c\");\n-        return sb.toString();\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n-    public static String fluid(String a) {\n-        return new StringBuilder().append(\"a\").append(a).toString();\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n-    public static String nonFluid(String a) {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"a\");\n-        sb.append(a);\n-        return sb.toString();\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n-    public static String nonFinal(String a) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"a\");\n-        sb.append(a);\n-        return sb.toString();\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ALLOC_OF, \"StringBuilder\", IRNode.CALL_OF_METHOD, \"toString\"})\n-    public static String nonFluidExtraneousVariable(String a) {\n-        final StringBuilder sb = new StringBuilder();\n-        final StringBuilder x = sb;\n-        sb.append(\"a\");\n-        x.append(a);\n-        return sb.toString();\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.ALLOC_OF, \"StringBuilder\", \"1\", IRNode.CALL_OF_METHOD, \"toString\", \"1\"})\n-    @IR(failOn = IRNode.INTRINSIC_TRAP)\n-    static String nonFluidConditional(String a) {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"a\");\n-        if (unknown == 1) {\n-            sb.append(a);\n-        }\n-        return sb.toString();\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.ALLOC_OF, \"StringBuilder\", \"1\", IRNode.CALL_OF_METHOD, \"toString\", \"1\"})\n-    @IR(failOn = IRNode.INTRINSIC_TRAP)\n-    static String nonFluidOpaqueCall() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"a\");\n-        opaque(sb);\n-        return sb.toString();\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/stringopts\/TestFluidAndNonFluid.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -170,1 +170,1 @@\n-          long expected_delta = numThreads * (max_stack_usage_with_pretouch - min_stack_usage_with_pretouch) \/ 2;\n+          long expected_delta = numThreads * (max_stack_usage_with_pretouch - min_stack_usage_with_pretouch);\n@@ -172,11 +172,8 @@\n-          if (pretouch_committed \/ no_pretouch_committed < 10) {\n-            if (pretouch_committed <= (no_pretouch_committed + expected_delta)) {\n-              throw new RuntimeException(\"Expected a higher amount of committed with pretouch stacks\" +\n-                                       \" PreTouch amount: \" + pretouch_committed +\n-                                       \" NoPreTouch amount: \" + no_pretouch_committed +\n-                                       \" Expected Delta calculated as: \" + expected_delta);\n-            }\n-            if (actual_delta < expected_delta) {\n-              throw new RuntimeException(\"Expected a higher delta between stack committed of with and without pretouch.\" +\n-                                       \"Expected: \" + expected_delta + \" Actual: \" + actual_delta);\n-            }\n+          if (pretouch_committed <= (no_pretouch_committed + expected_delta)) {\n+            throw new RuntimeException(\"Expected a higher amount of committed with pretouch stacks\" +\n+                                      \" PreTouch amount: \" + pretouch_committed +\n+                                      \" NoPreTouch amount: \" + (no_pretouch_committed + expected_delta));\n+          }\n+          if (actual_delta < expected_delta) {\n+            throw new RuntimeException(\"Expected a higher delta between stack committed of with and without pretouch.\" +\n+                                      \"Expected: \" + expected_delta + \" Actual: \" + actual_delta);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.vm.compiler;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Scope;\n-import java.util.concurrent.TimeUnit;\n-\n-@Warmup(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n-@Fork(value = 1, jvmArgsAppend = {\"-XX:+UseParallelGC\", \"-Xmx1g\", \"-Xms1g\"})\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-public class FluidSBBench {\n-    static final String PREFIX = \"a\";\n-    String foo = \"aaaaa aaaaa aaaaa aaaaa aaaaa\";\n-\n-    @Benchmark\n-    public String fluid() {\n-        return new StringBuilder().append(PREFIX).append(foo).toString();\n-    }\n-\n-    @Benchmark\n-    public String nonFluid() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(PREFIX);\n-        sb.append(foo);\n-        return sb.toString();\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FluidSBBench.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"}]}