{"files":[{"patch":"@@ -1519,5 +1519,4 @@\n-  CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n-  instance->create_counter(CPUTimeGroups::CPUTimeType::gc_parallel_workers);\n-  instance->create_counter(CPUTimeGroups::CPUTimeType::gc_conc_mark);\n-  instance->create_counter(CPUTimeGroups::CPUTimeType::gc_conc_refine);\n-  instance->create_counter(CPUTimeGroups::CPUTimeType::gc_service);\n+  CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::gc_parallel_workers);\n+  CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::gc_conc_mark);\n+  CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::gc_conc_refine);\n+  CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::gc_service);\n@@ -2432,8 +2431,6 @@\n-  WorkerThreads* worker_threads = workers();\n-  if (worker_threads != nullptr) {\n-    ThreadTotalCPUTimeClosure tttc(CPUTimeGroups::CPUTimeType::gc_parallel_workers);\n-    \/\/ Currently parallel worker threads never terminate (JDK-8081682), so it is\n-    \/\/ safe for VMThread to read their CPU times. However, if JDK-8087340 is\n-    \/\/ resolved so they terminate, we should rethink if it is still safe.\n-    worker_threads->threads_do(&tttc);\n-  }\n+  \n+  ThreadTotalCPUTimeClosure tttc(CPUTimeGroups::CPUTimeType::gc_parallel_workers);\n+  \/\/ Currently parallel worker threads never terminate (JDK-8081682), so it is\n+  \/\/ safe for VMThread to read their CPU times. However, if JDK-8087340 is\n+  \/\/ resolved so they terminate, we should rethink if it is still safe.\n+  workers()->threads_do(&tttc);\n@@ -2441,1 +2438,1 @@\n-  CPUTimeCounters::get_instance()->publish_gc_total_cpu_time();\n+  CPUTimeCounters::publish_gc_total_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  CPUTimeCounters::get_instance()->create_counter(CPUTimeGroups::CPUTimeType::gc_parallel_workers);\n+  CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::gc_parallel_workers);\n@@ -905,1 +905,1 @@\n-  CPUTimeCounters::get_instance()->publish_gc_total_cpu_time();\n+  CPUTimeCounters::publish_gc_total_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  CPUTimeCounters::get_instance()->create_counter(CPUTimeGroups::CPUTimeType::conc_dedup);\n+  CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::conc_dedup);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-      return true;\n@@ -57,1 +56,0 @@\n-      return true;\n@@ -59,1 +57,0 @@\n-      return true;\n@@ -73,1 +70,0 @@\n-  create_counter(SUN_THREADS, CPUTimeGroups::CPUTimeType::gc_total);\n@@ -77,1 +73,2 @@\n-  Atomic::add(&_gc_total_cpu_time_diff, diff);\n+  CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n+  Atomic::add(&(instance->_gc_total_cpu_time_diff), diff);\n@@ -81,0 +78,1 @@\n+  CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n@@ -84,1 +82,1 @@\n-  jlong fetched_value = Atomic::load(&_gc_total_cpu_time_diff);\n+  jlong fetched_value = Atomic::load(&(instance->_gc_total_cpu_time_diff));\n@@ -88,1 +86,1 @@\n-    fetched_value = Atomic::cmpxchg(&_gc_total_cpu_time_diff, old_value, new_value);\n+    fetched_value = Atomic::cmpxchg(&(instance->_gc_total_cpu_time_diff), old_value, new_value);\n@@ -94,1 +92,1 @@\n-  if (UsePerfData) {\n+  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n@@ -96,5 +94,4 @@\n-    if (os::is_thread_cpu_time_supported()) {\n-      _cpu_time_counters[static_cast<int>(name)] =\n-                  PerfDataManager::create_counter(ns, CPUTimeGroups::to_string(name),\n-                                                  PerfData::U_Ticks, CHECK);\n-    }\n+    CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n+    instance->_cpu_time_counters[static_cast<int>(name)] =\n+                PerfDataManager::create_counter(ns, CPUTimeGroups::to_string(name),\n+                                                PerfData::U_Ticks, CHECK);\n@@ -105,1 +102,1 @@\n-  create_counter(SUN_THREADS_CPUTIME, group);\n+  CPUTimeCounters::create_counter(SUN_THREADS_CPUTIME, group);\n@@ -109,1 +106,12 @@\n-  return _cpu_time_counters[static_cast<int>(name)];\n+  return CPUTimeCounters::get_instance()->_cpu_time_counters[static_cast<int>(name)];\n+}\n+\n+void CPUTimeCounters::update_counter(CPUTimeGroups::CPUTimeType name, jlong total) {\n+  CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n+  PerfCounter* counter = instance->get_counter(name);\n+  jlong prev_value = counter->get_value();\n+  jlong net_cpu_time = total - prev_value;\n+  counter->inc(net_cpu_time);\n+  if (CPUTimeGroups::is_gc_counter(name)) {\n+    instance->inc_gc_total_cpu_time(net_cpu_time);\n+  }\n@@ -113,7 +121,1 @@\n-    CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n-    PerfCounter* counter = instance->get_counter(_name);\n-    jlong net_cpu_time = _total - counter->get_value();\n-    counter->inc(net_cpu_time);\n-    if (CPUTimeGroups::is_gc_counter(_name)) {\n-      instance->inc_gc_total_cpu_time(net_cpu_time);\n-    }\n+  CPUTimeCounters::update_counter(_name, _total);\n@@ -123,5 +125,4 @@\n-    \/\/ The default code path (fast_thread_cpu_time()) asserts that\n-    \/\/ pthread_getcpuclockid() and clock_gettime() must return 0. Thus caller\n-    \/\/ must ensure the thread exists and has not terminated.\n-    assert(os::is_thread_cpu_time_supported(), \"os must support cpu time\");\n-    _total += os::thread_cpu_time(thread);\n+  \/\/ The default code path (fast_thread_cpu_time()) asserts that\n+  \/\/ pthread_getcpuclockid() and clock_gettime() must return 0. Thus caller\n+  \/\/ must ensure the thread exists and has not terminated.\n+  _total += os::thread_cpu_time(thread);\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,2 @@\n+  NONCOPYABLE(CPUTimeCounters);\n+\n@@ -68,1 +70,1 @@\n-  void create_counter(CounterNS ns, CPUTimeGroups::CPUTimeType name);\n+  static void create_counter(CounterNS ns, CPUTimeGroups::CPUTimeType name);\n@@ -70,1 +72,0 @@\n-public:\n@@ -75,0 +76,2 @@\n+  \n+  static void inc_gc_total_cpu_time(jlong diff);\n@@ -76,0 +79,1 @@\n+public:\n@@ -79,0 +83,1 @@\n+    create_counter(SUN_THREADS, CPUTimeGroups::CPUTimeType::gc_total);\n@@ -81,3 +86,3 @@\n-  \/\/ Prevent copy of singleton object.\n-  CPUTimeCounters(const CPUTimeCounters& copy) = delete;\n-  void operator=(const CPUTimeCounters& copy) = delete;\n+  static void create_counter(CPUTimeGroups::CPUTimeType name);\n+  static PerfCounter* get_counter(CPUTimeGroups::CPUTimeType name);\n+  static void update_counter(CPUTimeGroups::CPUTimeType name, jlong total);\n@@ -85,6 +90,1 @@\n-  \/\/ Methods to modify and update counter for total CPU time spent doing GC.\n-  void inc_gc_total_cpu_time(jlong diff);\n-  void publish_gc_total_cpu_time();\n-\n-  void create_counter(CPUTimeGroups::CPUTimeType name);\n-  PerfCounter* get_counter(CPUTimeGroups::CPUTimeType name);\n+  static void publish_gc_total_cpu_time();\n@@ -101,2 +101,4 @@\n-  ThreadTotalCPUTimeClosure(CPUTimeGroups::CPUTimeType name) :\n-      _total(0), _name(name) {}\n+  ThreadTotalCPUTimeClosure(CPUTimeGroups::CPUTimeType name)\n+      : _total(0), _name(name) {\n+    assert(os::is_thread_cpu_time_supported(), \"os must support cpu time\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.hpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    CPUTimeCounters::get_instance()->create_counter(CPUTimeGroups::CPUTimeType::vm);\n+    CPUTimeCounters::create_counter(CPUTimeGroups::CPUTimeType::vm);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}