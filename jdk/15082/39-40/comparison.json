{"files":[{"patch":"@@ -1237,1 +1237,0 @@\n-  _cpu_time_counters(new CPUTimeCounters()),\n@@ -1519,4 +1518,6 @@\n-  _cpu_time_counters->create_counter(CPUTimeGroups::gc_parallel_workers);\n-  _cpu_time_counters->create_counter(CPUTimeGroups::gc_conc_mark);\n-  _cpu_time_counters->create_counter(CPUTimeGroups::gc_conc_refine);\n-  _cpu_time_counters->create_counter(CPUTimeGroups::gc_service);\n+  CPUTimeCounters* instance = CPUTimeCounters::get_instance();\n+  assert(instance != nullptr, \"no instance found\");\n+  instance->create_counter(CPUTimeGroups::gc_parallel_workers);\n+  instance->create_counter(CPUTimeGroups::gc_conc_mark);\n+  instance->create_counter(CPUTimeGroups::gc_conc_refine);\n+  instance->create_counter(CPUTimeGroups::gc_service);\n@@ -2433,1 +2434,1 @@\n-    ThreadTotalCPUTimeClosure tttc(cpu_time_counters(), CPUTimeGroups::gc_parallel_workers);\n+    ThreadTotalCPUTimeClosure tttc(CPUTimeCounters::get_instance(), CPUTimeGroups::gc_parallel_workers);\n@@ -2440,1 +2441,1 @@\n-  _cpu_time_counters->publish_total_cpu_time();\n+  CPUTimeCounters::get_instance()->publish_total_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -255,3 +255,0 @@\n-  \/\/ Counters to keep track of CPU time spent by various sources.\n-  CPUTimeCounters* _cpu_time_counters;\n-\n@@ -569,4 +566,0 @@\n-  CPUTimeCounters* cpu_time_counters() {\n-    return _cpu_time_counters;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -2083,12 +2084,0 @@\n-void G1ConcurrentMark::update_concurrent_mark_threads_cpu_time() {\n-  assert(Thread::current() == cm_thread(),\n-         \"Must be called from _cmThread to avoid races\");\n-  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n-    return;\n-  }\n-  CPUTimeCounters* counters = _g1h->cpu_time_counters();\n-  ThreadTotalCPUTimeClosure tttc(counters, CPUTimeGroups::gc_conc_mark);\n-  tttc.do_thread(cm_thread());\n-  threads_do(&tttc);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -452,3 +452,0 @@\n-  \/\/ Update the perf data counter for concurrent mark.\n-  void update_concurrent_mark_threads_cpu_time();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    cm()->update_concurrent_mark_threads_cpu_time();\n+    update_threads_cpu_time();\n@@ -174,1 +174,1 @@\n-  cm()->update_concurrent_mark_threads_cpu_time();\n+  update_threads_cpu_time();\n@@ -234,1 +234,1 @@\n-  cm()->update_concurrent_mark_threads_cpu_time();\n+  update_threads_cpu_time();\n@@ -244,1 +244,1 @@\n-  cm()->update_concurrent_mark_threads_cpu_time();\n+  update_threads_cpu_time();\n@@ -344,0 +344,9 @@\n+\n+void G1ConcurrentMarkThread::update_threads_cpu_time() {\n+  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n+    return;\n+  }\n+  ThreadTotalCPUTimeClosure tttc(CPUTimeCounters::get_instance(), CPUTimeGroups::gc_conc_mark);\n+  tttc.do_thread(this);\n+  _cm->threads_do(&tttc);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+\n+  \/\/ Update the perf data counter for concurrent mark.\n+  void update_threads_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"runtime\/thread.hpp\"\n@@ -156,14 +156,0 @@\n-void G1ConcurrentRefineThreadControl::update_threads_cpu_time() {\n-  \/\/ The primary thread (_threads[0]) updates the counter for all worker\n-  \/\/ threads, because:\n-  \/\/ the primary thread is always woken up first from being blocked on a monitor\n-  \/\/ when there is refinement work to do;\n-  \/\/ the primary thread is started last and stopped first, so it will not risk\n-  \/\/ reading CPU time of a terminated worker thread.\n-  assert_current_thread_is_primary_refinement_thread();\n-  assert(UsePerfData && os::is_thread_cpu_time_supported(), \"Must be enabled\");\n-  CPUTimeCounters* counters = G1CollectedHeap::heap()->cpu_time_counters();\n-  ThreadTotalCPUTimeClosure tttc(counters, CPUTimeGroups::gc_conc_refine);\n-  worker_threads_do(&tttc);\n-}\n-\n@@ -476,4 +462,0 @@\n-\n-void G1ConcurrentRefine::update_concurrent_refine_threads_cpu_time() {\n-  _thread_control.update_threads_cpu_time();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/perfData.hpp\"\n@@ -75,3 +74,0 @@\n-\n-  \/\/ Update the perf data counter for concurrent refine.\n-  void update_threads_cpu_time();\n@@ -225,3 +221,0 @@\n-\n-  \/\/ Update the perf data counter for concurrent refine.\n-  void update_concurrent_refine_threads_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -77,6 +78,1 @@\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - _vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n-    maybe_update_threads_cpu_time();\n+    track_usage();\n@@ -141,1 +137,1 @@\n-  void maybe_update_threads_cpu_time() override;\n+  void track_usage() override;\n@@ -187,1 +183,3 @@\n-void G1PrimaryConcurrentRefineThread::maybe_update_threads_cpu_time() {\n+void G1PrimaryConcurrentRefineThread::track_usage() {\n+  G1ConcurrentRefineThread::track_usage();\n+  \/\/ The primary thread is responsible for updating the CPU time for all workers.\n@@ -189,1 +187,3 @@\n-    cr()->update_concurrent_refine_threads_cpu_time();\n+    CPUTimeCounters* counters = CPUTimeCounters::get_instance();\n+    ThreadTotalCPUTimeClosure tttc(counters, CPUTimeGroups::gc_conc_refine);\n+    cr()->threads_do(&tttc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -74,3 +74,9 @@\n-  \/\/ Attempt to update concurrent refine threads stats.\n-  \/\/ Only overridden in G1PrimaryConcurrentRefineThread.\n-  virtual void maybe_update_threads_cpu_time() {};\n+  \/\/ Update concurrent refine threads stats.\n+  \/\/ If we are in Primary thread, we additionally update CPU time tracking.\n+  virtual void track_usage() {\n+    if (os::supports_vtime()) {\n+      _vtime_accum = (os::elapsedVTime() - _vtime_start);\n+    } else {\n+      _vtime_accum = 0.0;\n+    }\n+  };\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -134,5 +135,1 @@\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n-    CPUTimeCounters* counters = G1CollectedHeap::heap()->cpu_time_counters();\n-    ThreadTotalCPUTimeClosure tttc(counters, CPUTimeGroups::gc_service);\n-    tttc.do_thread(task->_service_thread);\n-  }\n+  update_thread_cpu_time(task);\n@@ -161,0 +158,7 @@\n+void G1ServiceThread::update_thread_cpu_time(G1ServiceTask* task) {\n+  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n+    ThreadTotalCPUTimeClosure tttc(CPUTimeCounters::get_instance(), CPUTimeGroups::gc_service);\n+    tttc.do_thread(task->_service_thread);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -124,0 +124,3 @@\n+  \/\/ Update the perf data counter for service thread.\n+  void update_thread_cpu_time(G1ServiceTask* task);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -131,1 +132,1 @@\n-  _cpu_time_counters->create_counter(CPUTimeGroups::gc_parallel_workers);\n+  CPUTimeCounters::get_instance()->create_counter(CPUTimeGroups::gc_parallel_workers);\n@@ -898,1 +899,1 @@\n-  ThreadTotalCPUTimeClosure tttc(_cpu_time_counters, CPUTimeGroups::gc_parallel_workers);\n+  ThreadTotalCPUTimeClosure tttc(CPUTimeCounters::get_instance(), CPUTimeGroups::gc_parallel_workers);\n@@ -904,1 +905,1 @@\n-  _cpu_time_counters->publish_total_cpu_time();\n+  CPUTimeCounters::get_instance()->publish_total_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -95,1 +94,0 @@\n-  CPUTimeCounters* _cpu_time_counters;\n@@ -124,1 +122,0 @@\n-    _cpu_time_counters(new CPUTimeCounters()),\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+CPUTimeCounters*         CPUTimeCounters::_instance          = nullptr;\n+\n@@ -66,1 +68,1 @@\n-    _cpu_time_counters{nullptr},\n+    _cpu_time_counters(),\n@@ -68,1 +70,0 @@\n-\n@@ -109,0 +110,1 @@\n+    assert(_counter != nullptr, \"ASDF\");\n@@ -112,0 +114,1 @@\n+      assert(_gc_counters != nullptr, \"asdf\");\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,2 +50,6 @@\n-  \/\/ Perf counter to track total CPU time across all threads. Defined here in\n-  \/\/ order to be reused for all collectors.\n+  \/\/ We want CPUTimeCounters to be a singleton instance accessed by the vm thread.\n+  CPUTimeCounters();\n+  static CPUTimeCounters* _instance;\n+\n+  \/\/ An array of PerfCounters which correspond to the various counters we want \n+  \/\/ to track. Indexed by the enum value `CPUTimeType`.\n@@ -59,0 +63,1 @@\n+\n@@ -62,1 +67,12 @@\n-  CPUTimeCounters();\n+  static CPUTimeCounters* get_instance() {\n+    return _instance;\n+  }\n+\n+  static void initialize() {\n+    assert(get_instance() == nullptr, \"we can only allocate one CPUTimeCounters object\");\n+    _instance = new CPUTimeCounters();\n+  }\n+\n+  \/\/ Prevent copy of singleton object.\n+  CPUTimeCounters(const CPUTimeCounters& copy) = delete;\n+  void operator=(const CPUTimeCounters& copy) = delete;\n@@ -85,1 +101,1 @@\n-      _total(0), _counter(counter), _gc_counters(nullptr), _update_gc_counters(false) {}\n+      _total(0), _counter(counter), _gc_counters(CPUTimeCounters::get_instance()), _update_gc_counters(false) {}\n@@ -96,1 +112,1 @@\n-#endif \/\/ SHARE_RUNTIME_CPUTIMECOUNTERS_HPP\n\\ No newline at end of file\n+#endif \/\/ SHARE_RUNTIME_CPUTIMECOUNTERS_HPP\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.hpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -123,0 +124,2 @@\n+  \/\/ Initialize CPUTimeCounters object, which must be done before creation of the heap.\n+  CPUTimeCounters::initialize();  \n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}