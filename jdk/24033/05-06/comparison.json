{"files":[{"patch":"@@ -93,1 +93,2 @@\n-        private final int[] maskBytes = new int[4];\n+        private final ByteBuffer acc = ByteBuffer.allocate(8);\n+        private final byte[] maskBytes = new byte[4];\n@@ -118,1 +119,1 @@\n-            ByteBuffer acc = ByteBuffer.allocate(8).putInt(mask).putInt(mask).flip();\n+            acc.clear().putInt(mask).putInt(mask).flip();\n@@ -137,1 +138,1 @@\n-            if (src.order() == dst.order()) {\n+            if (canVectorMask(src, dst)) {\n@@ -144,0 +145,4 @@\n+        private static boolean canVectorMask(ByteBuffer src, ByteBuffer dst) {\n+            return src.order() == dst.order() && Math.min(src.remaining(), dst.remaining()) >= 8;\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/Frame.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.function.Supplier;\n@@ -44,0 +45,2 @@\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n@@ -50,38 +53,0 @@\n-    private static final ByteBuffer DATA_LE = ByteBuffer\n-            .wrap(new byte[]{\n-                    \/\/ 4-byte words in LE order\n-                    0x00, 0x01, 0x02, 0x03,\n-                    0x04, 0x05, 0x06, 0x07,\n-                    0x08, 0x09, 0x0a, 0x0b,\n-                    0x0c, 0x0d, 0x0e, 0x0f,\n-                    \/\/ 2-byte words in LE order\n-                    0x10, 0x11,\n-                    0x12, 0x13,\n-                    0x14, 0x15,\n-                    0x16, 0x17,\n-                    0x18, 0x19,\n-                    0x1a, 0x1b,\n-                    0x1c, 0x1d,\n-                    0x1e, 0x1f\n-            })\n-            .order(ByteOrder.LITTLE_ENDIAN);\n-\n-    private static final ByteBuffer DATA_BE = ByteBuffer\n-            .wrap(new byte[]{\n-                    \/\/ 4-byte words in BE order\n-                    0x03, 0x02, 0x01, 0x00,\n-                    0x07, 0x06, 0x05, 0x04,\n-                    0x0b, 0x0a, 0x09, 0x08,\n-                    0x0f, 0x0e, 0x0d, 0x0c,\n-                    \/\/ 2-byte words in BE order\n-                    0x11, 0x10,\n-                    0x13, 0x12,\n-                    0x15, 0x14,\n-                    0x17, 0x16,\n-                    0x19, 0x18,\n-                    0x1b, 0x1a,\n-                    0x1d, 0x1c,\n-                    0x1f, 0x1e\n-            })\n-            .order(ByteOrder.BIG_ENDIAN);\n-\n@@ -89,2 +54,24 @@\n-        assertEndiannessAgnosticTransfer(DATA_LE);\n-        assertEndiannessAgnosticTransfer(DATA_BE);\n+        assertEndiannessAgnosticTransfer();\n+        assertSuccessfulMasking();\n+    }\n+\n+    private static void assertEndiannessAgnosticTransfer() throws Exception {\n+        Supplier<ByteBuffer> bufferSupplier = () -> ByteBuffer\n+                .wrap(new byte[]{\n+                        \/\/ 4-byte words\n+                        0x00, 0x01, 0x02, 0x03,\n+                        0x04, 0x05, 0x06, 0x07,\n+                        0x08, 0x09, 0x0a, 0x0b,\n+                        0x0c, 0x0d, 0x0e, 0x0f,\n+                        \/\/ 2-byte words\n+                        0x10, 0x11,\n+                        0x12, 0x13,\n+                        0x14, 0x15,\n+                        0x16, 0x17,\n+                        0x18, 0x19,\n+                        0x1a, 0x1b,\n+                        0x1c, 0x1d,\n+                        0x1e, 0x1f\n+                });\n+        assertEndiannessAgnosticTransfer(bufferSupplier.get().order(LITTLE_ENDIAN));\n+        assertEndiannessAgnosticTransfer(bufferSupplier.get().order(BIG_ENDIAN));\n@@ -119,0 +106,55 @@\n+    private static void assertSuccessfulMasking() {\n+        assertSuccessfulMasking(LITTLE_ENDIAN, LITTLE_ENDIAN);\n+        assertSuccessfulMasking(LITTLE_ENDIAN, BIG_ENDIAN);\n+        assertSuccessfulMasking(BIG_ENDIAN, LITTLE_ENDIAN);\n+        assertSuccessfulMasking(BIG_ENDIAN, BIG_ENDIAN);\n+    }\n+\n+    private static void assertSuccessfulMasking(ByteOrder srcOrder, ByteOrder dstOrder) {\n+\n+        \/\/ Create the masker\n+        Frame.Masker masker = new Frame.Masker().setMask(0x0A0B0C0D);\n+\n+        \/\/ Perform dummy masking to advance `Frame::offset` 1 byte, and effectively make it non-zero.\n+        \/\/ A non-zero `Frame::offset` will trigger `Frame::initVectorMask` invocation.\n+        masker.applyMask(ByteBuffer.wrap(new byte[1]), ByteBuffer.wrap(new byte[1]));\n+\n+        \/\/ Perform the actual masking\n+        ByteBuffer src = ByteBuffer\n+                .wrap(new byte[]{\n+                        \/\/ `initVectorMask` will mask 3 bytes to position the `offset` back to 0.\n+                        \/\/ It is 3 bytes, because of the 1 byte dummy advancement above.\n+                        0x1, 0x2, 0x3,\n+                        \/\/ `applyVectorMask` will make a single 8-byte pass\n+                        0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8,\n+                        \/\/ `applyPlainMask` will mask 1 byte\n+                        0x1\n+                })\n+                .order(srcOrder);\n+        ByteBuffer dst = ByteBuffer.allocate(src.capacity()).order(dstOrder);\n+        masker.applyMask(src, dst);\n+\n+        \/\/ Verify the masking\n+        assertEqualsByteArray(\n+                new byte[]{\n+                        \/\/ 3 bytes for `initVectorMask`.\n+                        \/\/ Remember 0xA is consumed by the initial dummy masking.\n+                        0x1 ^ 0xB,\n+                        0x2 ^ 0xC,\n+                        0x3 ^ 0xD,\n+                        \/\/ 8 bytes for `applyVectorMask`\n+                        0x1 ^ 0xA,\n+                        0x2 ^ 0xB,\n+                        0x3 ^ 0xC,\n+                        0x4 ^ 0xD,\n+                        0x5 ^ 0xA,\n+                        0x6 ^ 0xB,\n+                        0x7 ^ 0xC,\n+                        0x8 ^ 0xD,\n+                        \/\/ 1 byte for `applyPlainMask`\n+                        0x1 ^ 0xA\n+                },\n+                dst.array());\n+\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketEndiannessTest.java","additions":82,"deletions":40,"binary":false,"changes":122,"status":"modified"}]}