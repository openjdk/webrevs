{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.ByteOrder;\n@@ -36,1 +37,1 @@\n-final class Frame {\n+public final class Frame {\n@@ -41,1 +42,1 @@\n-    static final int MAX_CONTROL_FRAME_PAYLOAD_LENGTH = 125;\n+    public static final int MAX_CONTROL_FRAME_PAYLOAD_LENGTH = 125;\n@@ -43,1 +44,1 @@\n-    enum Opcode {\n+    public enum Opcode {\n@@ -90,1 +91,1 @@\n-    static final class Masker {\n+    public static final class Masker {\n@@ -92,2 +93,0 @@\n-        \/\/ Exploiting ByteBuffer's ability to read\/write multi-byte integers\n-        private final ByteBuffer acc = ByteBuffer.allocate(8);\n@@ -96,1 +95,2 @@\n-        private long maskLong;\n+        private long maskLongBe;\n+        private long maskLongLe;\n@@ -105,1 +105,1 @@\n-        static void transferMasking(ByteBuffer src, ByteBuffer dst, int mask) {\n+        static void mask(ByteBuffer src, ByteBuffer dst, int mask) {\n@@ -109,1 +109,1 @@\n-            new Masker().mask(mask).transferMasking(src, dst);\n+            new Masker().reset(mask).mask(src, dst);\n@@ -117,2 +117,2 @@\n-        Masker mask(int value) {\n-            acc.clear().putInt(value).putInt(value).flip();\n+        public Masker reset(int mask) {\n+            ByteBuffer acc = ByteBuffer.allocate(8).putInt(mask).putInt(mask).flip();\n@@ -123,1 +123,2 @@\n-            maskLong = acc.getLong(0);\n+            maskLongBe = acc.getLong(0);\n+            maskLongLe = Long.reverseBytes(maskLongBe);\n@@ -135,5 +136,6 @@\n-        Masker transferMasking(ByteBuffer src, ByteBuffer dst) {\n-            begin(src, dst);\n-            loop(src, dst);\n-            end(src, dst);\n-            return this;\n+        public void mask(ByteBuffer src, ByteBuffer dst) {\n+            if (src.order() == dst.order()) {\n+                initGallopingMasking(src, dst);\n+                doGallopingMasking(src, dst);\n+            }\n+            doPlainMasking(src, dst);\n@@ -142,2 +144,2 @@\n-        \/*\n-         * Applies up to 3 remaining from the previous pass bytes of the mask.\n+        \/**\n+         * Positions the {@link #offset} at 0, which is needed for galloping, by masking necessary amount of bytes.\n@@ -145,2 +147,3 @@\n-        private void begin(ByteBuffer src, ByteBuffer dst) {\n-            if (offset == 0) { \/\/ No partially applied mask from the previous invocation\n+        private void initGallopingMasking(ByteBuffer src, ByteBuffer dst) {\n+            assert src.order() == dst.order() : \"galloping is only allowed on matching byte orders\";\n+            if (offset == 0) {\n@@ -161,1 +164,1 @@\n-         * Gallops one long (mask + mask) at a time.\n+         * Masks one {@code long} at a time.\n@@ -163,1 +166,3 @@\n-        private void loop(ByteBuffer src, ByteBuffer dst) {\n+        private void doGallopingMasking(ByteBuffer src, ByteBuffer dst) {\n+            assert src.order() == dst.order() : \"galloping is only allowed on matching byte orders\";\n+            long maskLong = ByteOrder.LITTLE_ENDIAN == src.order() ? maskLongLe : maskLongBe;\n@@ -167,0 +172,2 @@\n+            assert !(i < srcLongLim && j < dstLongLim) || \/\/ That is, if loop will run at least once\n+                    offset == 0 : \"offset must have been positioned at 0\";\n@@ -183,2 +190,1 @@\n-         * Applies up to 7 remaining from the \"galloping\" phase bytes of the\n-         * mask.\n+         * Masks one {@code byte} at a time.\n@@ -186,2 +192,1 @@\n-        private void end(ByteBuffer src, ByteBuffer dst) {\n-            assert Math.min(src.remaining(), dst.remaining()) < 8;\n+        private void doPlainMasking(ByteBuffer src, ByteBuffer dst) {\n@@ -198,0 +203,1 @@\n+\n@@ -207,1 +213,1 @@\n-    static final class HeaderWriter {\n+    public static final class HeaderWriter {\n@@ -214,1 +220,1 @@\n-        HeaderWriter fin(boolean value) {\n+        public HeaderWriter fin(boolean value) {\n@@ -257,1 +263,1 @@\n-        HeaderWriter opcode(Opcode value) {\n+        public HeaderWriter opcode(Opcode value) {\n@@ -262,1 +268,1 @@\n-        HeaderWriter payloadLen(long value) {\n+        public HeaderWriter payloadLen(long value) {\n@@ -285,1 +291,1 @@\n-        HeaderWriter noMask() {\n+        public HeaderWriter noMask() {\n@@ -298,1 +304,1 @@\n-        void write(ByteBuffer buffer) {\n+        public void write(ByteBuffer buffer) {\n@@ -320,1 +326,1 @@\n-    interface Consumer {\n+    public interface Consumer {\n@@ -361,1 +367,1 @@\n-    static final class Reader {\n+    public static final class Reader {\n@@ -385,1 +391,1 @@\n-        void readFrame(ByteBuffer input, Consumer consumer) {\n+        public void readFrame(ByteBuffer input, Consumer consumer) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/Frame.java","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-        Frame.Masker.transferMasking(src, temp, maskingKey);\n+        Frame.Masker.mask(src, temp, maskingKey);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-        payloadMasker.transferMasking(src, dst);\n+        payloadMasker.mask(src, dst);\n@@ -396,1 +396,1 @@\n-        payloadMasker.mask(mask);\n+        payloadMasker.reset(mask);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageEncoder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/Abort.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n@@ -31,0 +32,1 @@\n+import jdk.internal.net.http.websocket.Frame;\n@@ -189,1 +191,1 @@\n-                        masker.mask(value);\n+                        masker.reset(value);\n@@ -194,1 +196,1 @@\n-                        masker.transferMasking(src, number);\n+                        masker.mask(src, number);\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/AutomaticPong.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/BlowupOutputQueue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/ConnectionHandoverTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import jdk.internal.net.http.websocket.Frame;\n+\n@@ -220,0 +222,84 @@\n+    public List<DecodedFrame> readFrames() throws InterruptedException {\n+        ByteBuffer buffer = read();\n+        Frame.Reader reader = new Frame.Reader();\n+        DecodedFrameCollector consumer = new DecodedFrameCollector();\n+        while (buffer.hasRemaining()) {\n+            reader.readFrame(buffer, consumer);\n+        }\n+        return consumer.frames;\n+    }\n+\n+    private static final class DecodedFrameCollector implements Frame.Consumer {\n+\n+        private final Frame.Masker masker = new Frame.Masker();\n+\n+        private final List<DecodedFrame> frames = new ArrayList<>();\n+\n+        private ByteBuffer data;\n+\n+        private Frame.Opcode opcode;\n+\n+        private boolean last;\n+\n+        @Override\n+        public void fin(boolean value) {\n+            last = value;\n+        }\n+\n+        @Override\n+        public void rsv1(boolean value) {\n+            if (value) {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        @Override\n+        public void rsv2(boolean value) {\n+            if (value) {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        @Override\n+        public void rsv3(boolean value) {\n+            if (value) {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        @Override\n+        public void opcode(Frame.Opcode value) {\n+            opcode = value;\n+        }\n+\n+        @Override\n+        public void mask(boolean value) {\n+            if (!value) { \/\/ Frames from the client MUST be masked\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        @Override\n+        public void payloadLen(long value) {\n+            data = ByteBuffer.allocate((int) value);\n+        }\n+\n+        @Override\n+        public void maskingKey(int value) {\n+            masker.reset(value);\n+        }\n+\n+        @Override\n+        public void payloadData(ByteBuffer data) {\n+            masker.mask(data, this.data);\n+        }\n+\n+        @Override\n+        public void endFrame() {\n+            frames.add(new DecodedFrame(opcode, this.data.flip(), last));\n+        }\n+\n+    }\n+\n+    public record DecodedFrame(Frame.Opcode opcode, ByteBuffer data, boolean last) {}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/DummyWebSocketServer.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1,497 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.ByteBuffer;\n-\n-\/* Copied from jdk.internal.net.http.websocket.Frame *\/\n-final class Frame {\n-\n-    final Opcode opcode;\n-    final ByteBuffer data;\n-    final boolean last;\n-\n-    public Frame(Opcode opcode, ByteBuffer data, boolean last) {\n-        this.opcode = opcode;\n-        \/* copy *\/\n-        this.data = ByteBuffer.allocate(data.remaining()).put(data.slice()).flip();\n-        this.last = last;\n-    }\n-\n-    static final int MAX_HEADER_SIZE_BYTES = 2 + 8 + 4;\n-    static final int MAX_CONTROL_FRAME_PAYLOAD_SIZE = 125;\n-\n-    enum Opcode {\n-\n-        CONTINUATION   (0x0),\n-        TEXT           (0x1),\n-        BINARY         (0x2),\n-        NON_CONTROL_0x3(0x3),\n-        NON_CONTROL_0x4(0x4),\n-        NON_CONTROL_0x5(0x5),\n-        NON_CONTROL_0x6(0x6),\n-        NON_CONTROL_0x7(0x7),\n-        CLOSE          (0x8),\n-        PING           (0x9),\n-        PONG           (0xA),\n-        CONTROL_0xB    (0xB),\n-        CONTROL_0xC    (0xC),\n-        CONTROL_0xD    (0xD),\n-        CONTROL_0xE    (0xE),\n-        CONTROL_0xF    (0xF);\n-\n-        private static final Opcode[] opcodes;\n-\n-        static {\n-            Opcode[] values = values();\n-            opcodes = new Opcode[values.length];\n-            for (Opcode c : values) {\n-                opcodes[c.code] = c;\n-            }\n-        }\n-\n-        private final byte code;\n-\n-        Opcode(int code) {\n-            this.code = (byte) code;\n-        }\n-\n-        boolean isControl() {\n-            return (code & 0x8) != 0;\n-        }\n-\n-        static Opcode ofCode(int code) {\n-            return opcodes[code & 0xF];\n-        }\n-    }\n-\n-    \/*\n-     * A utility for masking frame payload data.\n-     *\/\n-    static final class Masker {\n-\n-        \/\/ Exploiting ByteBuffer's ability to read\/write multi-byte integers\n-        private final ByteBuffer acc = ByteBuffer.allocate(8);\n-        private final int[] maskBytes = new int[4];\n-        private int offset;\n-        private long maskLong;\n-\n-        \/*\n-         * Reads all remaining bytes from the given input buffer, masks them\n-         * with the supplied mask and writes the resulting bytes to the given\n-         * output buffer.\n-         *\n-         * The source and the destination buffers may be the same instance.\n-         *\/\n-        static void transferMasking(ByteBuffer src, ByteBuffer dst, int mask) {\n-            if (src.remaining() > dst.remaining()) {\n-                throw new IllegalArgumentException();\n-            }\n-            new Masker().mask(mask).transferMasking(src, dst);\n-        }\n-\n-        \/*\n-         * Clears this instance's state and sets the mask.\n-         *\n-         * The behaviour is as if the mask was set on a newly created instance.\n-         *\/\n-        Masker mask(int value) {\n-            acc.clear().putInt(value).putInt(value).flip();\n-            for (int i = 0; i < maskBytes.length; i++) {\n-                maskBytes[i] = acc.get(i);\n-            }\n-            offset = 0;\n-            maskLong = acc.getLong(0);\n-            return this;\n-        }\n-\n-        \/*\n-         * Reads as many remaining bytes as possible from the given input\n-         * buffer, masks them with the previously set mask and writes the\n-         * resulting bytes to the given output buffer.\n-         *\n-         * The source and the destination buffers may be the same instance. If\n-         * the mask hasn't been previously set it is assumed to be 0.\n-         *\/\n-        Masker transferMasking(ByteBuffer src, ByteBuffer dst) {\n-            begin(src, dst);\n-            loop(src, dst);\n-            end(src, dst);\n-            return this;\n-        }\n-\n-        \/*\n-         * Applies up to 3 remaining from the previous pass bytes of the mask.\n-         *\/\n-        private void begin(ByteBuffer src, ByteBuffer dst) {\n-            if (offset == 0) { \/\/ No partially applied mask from the previous invocation\n-                return;\n-            }\n-            int i = src.position(), j = dst.position();\n-            final int srcLim = src.limit(), dstLim = dst.limit();\n-            for (; offset < 4 && i < srcLim && j < dstLim; i++, j++, offset++)\n-            {\n-                dst.put(j, (byte) (src.get(i) ^ maskBytes[offset]));\n-            }\n-            offset &= 3; \/\/ Will become 0 if the mask has been fully applied\n-            src.position(i);\n-            dst.position(j);\n-        }\n-\n-        \/*\n-         * Gallops one long (mask + mask) at a time.\n-         *\/\n-        private void loop(ByteBuffer src, ByteBuffer dst) {\n-            int i = src.position();\n-            int j = dst.position();\n-            final int srcLongLim = src.limit() - 7, dstLongLim = dst.limit() - 7;\n-            for (; i < srcLongLim && j < dstLongLim; i += 8, j += 8) {\n-                dst.putLong(j, src.getLong(i) ^ maskLong);\n-            }\n-            if (i > src.limit()) {\n-                src.position(i - 8);\n-            } else {\n-                src.position(i);\n-            }\n-            if (j > dst.limit()) {\n-                dst.position(j - 8);\n-            } else {\n-                dst.position(j);\n-            }\n-        }\n-\n-        \/*\n-         * Applies up to 7 remaining from the \"galloping\" phase bytes of the\n-         * mask.\n-         *\/\n-        private void end(ByteBuffer src, ByteBuffer dst) {\n-            assert Math.min(src.remaining(), dst.remaining()) < 8;\n-            final int srcLim = src.limit(), dstLim = dst.limit();\n-            int i = src.position(), j = dst.position();\n-            for (; i < srcLim && j < dstLim;\n-                 i++, j++, offset = (offset + 1) & 3) \/\/ offset cycles through 0..3\n-            {\n-                dst.put(j, (byte) (src.get(i) ^ maskBytes[offset]));\n-            }\n-            src.position(i);\n-            dst.position(j);\n-        }\n-    }\n-\n-    \/*\n-     * A builder-style writer of frame headers.\n-     *\n-     * The writer does not enforce any protocol-level rules, it simply writes a\n-     * header structure to the given buffer. The order of calls to intermediate\n-     * methods is NOT significant.\n-     *\/\n-    static final class HeaderWriter {\n-\n-        private char firstChar;\n-        private long payloadLen;\n-        private int maskingKey;\n-        private boolean mask;\n-\n-        HeaderWriter fin(boolean value) {\n-            if (value) {\n-                firstChar |=  0b10000000_00000000;\n-            } else {\n-                firstChar &= ~0b10000000_00000000;\n-            }\n-            return this;\n-        }\n-\n-        HeaderWriter rsv1(boolean value) {\n-            if (value) {\n-                firstChar |=  0b01000000_00000000;\n-            } else {\n-                firstChar &= ~0b01000000_00000000;\n-            }\n-            return this;\n-        }\n-\n-        HeaderWriter rsv2(boolean value) {\n-            if (value) {\n-                firstChar |=  0b00100000_00000000;\n-            } else {\n-                firstChar &= ~0b00100000_00000000;\n-            }\n-            return this;\n-        }\n-\n-        HeaderWriter rsv3(boolean value) {\n-            if (value) {\n-                firstChar |=  0b00010000_00000000;\n-            } else {\n-                firstChar &= ~0b00010000_00000000;\n-            }\n-            return this;\n-        }\n-\n-        HeaderWriter opcode(Opcode value) {\n-            firstChar = (char) ((firstChar & 0xF0FF) | (value.code << 8));\n-            return this;\n-        }\n-\n-        HeaderWriter payloadLen(long value) {\n-            if (value < 0) {\n-                throw new IllegalArgumentException(\"Negative: \" + value);\n-            }\n-            payloadLen = value;\n-            firstChar &= 0b11111111_10000000; \/\/ Clear previous payload length leftovers\n-            if (payloadLen < 126) {\n-                firstChar |= payloadLen;\n-            } else if (payloadLen < 65536) {\n-                firstChar |= 126;\n-            } else {\n-                firstChar |= 127;\n-            }\n-            return this;\n-        }\n-\n-        HeaderWriter mask(int value) {\n-            firstChar |= 0b00000000_10000000;\n-            maskingKey = value;\n-            mask = true;\n-            return this;\n-        }\n-\n-        HeaderWriter noMask() {\n-            firstChar &= ~0b00000000_10000000;\n-            mask = false;\n-            return this;\n-        }\n-\n-        \/*\n-         * Writes the header to the given buffer.\n-         *\n-         * The buffer must have at least MAX_HEADER_SIZE_BYTES remaining. The\n-         * buffer's position is incremented by the number of bytes written.\n-         *\/\n-        void write(ByteBuffer buffer) {\n-            buffer.putChar(firstChar);\n-            if (payloadLen >= 126) {\n-                if (payloadLen < 65536) {\n-                    buffer.putChar((char) payloadLen);\n-                } else {\n-                    buffer.putLong(payloadLen);\n-                }\n-            }\n-            if (mask) {\n-                buffer.putInt(maskingKey);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * A consumer of frame parts.\n-     *\n-     * Frame.Reader invokes the consumer's methods in the following order:\n-     *\n-     *     fin rsv1 rsv2 rsv3 opcode mask payloadLength maskingKey? payloadData+ endFrame\n-     *\/\n-    interface Consumer {\n-\n-        void fin(boolean value);\n-\n-        void rsv1(boolean value);\n-\n-        void rsv2(boolean value);\n-\n-        void rsv3(boolean value);\n-\n-        void opcode(Opcode value);\n-\n-        void mask(boolean value);\n-\n-        void payloadLen(long value);\n-\n-        void maskingKey(int value);\n-\n-        \/*\n-         * Called by the Frame.Reader when a part of the (or a complete) payload\n-         * is ready to be consumed.\n-         *\n-         * The sum of numbers of bytes consumed in each invocation of this\n-         * method corresponding to the given frame WILL be equal to\n-         * 'payloadLen', reported to `void payloadLen(long value)` before that.\n-         *\n-         * In particular, if `payloadLen` is 0, then there WILL be a single\n-         * invocation to this method.\n-         *\n-         * No unmasking is done.\n-         *\/\n-        void payloadData(ByteBuffer data);\n-\n-        void endFrame();\n-    }\n-\n-    \/*\n-     * A Reader of frames.\n-     *\n-     * No protocol-level rules are checked.\n-     *\/\n-    static final class Reader {\n-\n-        private static final int AWAITING_FIRST_BYTE  =  1;\n-        private static final int AWAITING_SECOND_BYTE =  2;\n-        private static final int READING_16_LENGTH    =  4;\n-        private static final int READING_64_LENGTH    =  8;\n-        private static final int READING_MASK         = 16;\n-        private static final int READING_PAYLOAD      = 32;\n-\n-        \/\/ Exploiting ByteBuffer's ability to read multi-byte integers\n-        private final ByteBuffer accumulator = ByteBuffer.allocate(8);\n-        private int state = AWAITING_FIRST_BYTE;\n-        private boolean mask;\n-        private long remainingPayloadLength;\n-\n-        \/*\n-         * Reads at most one frame from the given buffer invoking the consumer's\n-         * methods corresponding to the frame parts found.\n-         *\n-         * As much of the frame's payload, if any, is read. The buffer's\n-         * position is updated to reflect the number of bytes read.\n-         *\n-         * Throws FailWebSocketException if detects the frame is malformed.\n-         *\/\n-        void readFrame(ByteBuffer input, Consumer consumer) {\n-            loop:\n-            while (true) {\n-                byte b;\n-                switch (state) {\n-                    case AWAITING_FIRST_BYTE:\n-                        if (!input.hasRemaining()) {\n-                            break loop;\n-                        }\n-                        b = input.get();\n-                        consumer.fin( (b & 0b10000000) != 0);\n-                        consumer.rsv1((b & 0b01000000) != 0);\n-                        consumer.rsv2((b & 0b00100000) != 0);\n-                        consumer.rsv3((b & 0b00010000) != 0);\n-                        consumer.opcode(Opcode.ofCode(b));\n-                        state = AWAITING_SECOND_BYTE;\n-                        continue loop;\n-                    case AWAITING_SECOND_BYTE:\n-                        if (!input.hasRemaining()) {\n-                            break loop;\n-                        }\n-                        b = input.get();\n-                        consumer.mask(mask = (b & 0b10000000) != 0);\n-                        byte p1 = (byte) (b & 0b01111111);\n-                        if (p1 < 126) {\n-                            assert p1 >= 0 : p1;\n-                            consumer.payloadLen(remainingPayloadLength = p1);\n-                            state = mask ? READING_MASK : READING_PAYLOAD;\n-                        } else if (p1 < 127) {\n-                            state = READING_16_LENGTH;\n-                        } else {\n-                            state = READING_64_LENGTH;\n-                        }\n-                        continue loop;\n-                    case READING_16_LENGTH:\n-                        if (!input.hasRemaining()) {\n-                            break loop;\n-                        }\n-                        b = input.get();\n-                        if (accumulator.put(b).position() < 2) {\n-                            continue loop;\n-                        }\n-                        remainingPayloadLength = accumulator.flip().getChar();\n-                        if (remainingPayloadLength < 126) {\n-                            throw notMinimalEncoding(remainingPayloadLength);\n-                        }\n-                        consumer.payloadLen(remainingPayloadLength);\n-                        accumulator.clear();\n-                        state = mask ? READING_MASK : READING_PAYLOAD;\n-                        continue loop;\n-                    case READING_64_LENGTH:\n-                        if (!input.hasRemaining()) {\n-                            break loop;\n-                        }\n-                        b = input.get();\n-                        if (accumulator.put(b).position() < 8) {\n-                            continue loop;\n-                        }\n-                        remainingPayloadLength = accumulator.flip().getLong();\n-                        if (remainingPayloadLength < 0) {\n-                            throw negativePayload(remainingPayloadLength);\n-                        } else if (remainingPayloadLength < 65536) {\n-                            throw notMinimalEncoding(remainingPayloadLength);\n-                        }\n-                        consumer.payloadLen(remainingPayloadLength);\n-                        accumulator.clear();\n-                        state = mask ? READING_MASK : READING_PAYLOAD;\n-                        continue loop;\n-                    case READING_MASK:\n-                        if (!input.hasRemaining()) {\n-                            break loop;\n-                        }\n-                        b = input.get();\n-                        if (accumulator.put(b).position() != 4) {\n-                            continue loop;\n-                        }\n-                        consumer.maskingKey(accumulator.flip().getInt());\n-                        accumulator.clear();\n-                        state = READING_PAYLOAD;\n-                        continue loop;\n-                    case READING_PAYLOAD:\n-                        \/\/ This state does not require any bytes to be available\n-                        \/\/ in the input buffer in order to proceed\n-                        int deliverable = (int) Math.min(remainingPayloadLength,\n-                                                         input.remaining());\n-                        int oldLimit = input.limit();\n-                        input.limit(input.position() + deliverable);\n-                        if (deliverable != 0 || remainingPayloadLength == 0) {\n-                            consumer.payloadData(input);\n-                        }\n-                        int consumed = deliverable - input.remaining();\n-                        if (consumed < 0) {\n-                            \/\/ Consumer cannot consume more than there was available\n-                            throw new InternalError();\n-                        }\n-                        input.limit(oldLimit);\n-                        remainingPayloadLength -= consumed;\n-                        if (remainingPayloadLength == 0) {\n-                            consumer.endFrame();\n-                            state = AWAITING_FIRST_BYTE;\n-                        }\n-                        break loop;\n-                    default:\n-                        throw new InternalError(String.valueOf(state));\n-                }\n-            }\n-        }\n-\n-        private static IllegalArgumentException negativePayload(long payloadLength)\n-        {\n-            return new IllegalArgumentException(\"Negative payload length: \"\n-                                                        + payloadLength);\n-        }\n-\n-        private static IllegalArgumentException notMinimalEncoding(long payloadLength)\n-        {\n-            return new IllegalArgumentException(\"Not minimally-encoded payload length:\"\n-                                                      + payloadLength);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/Frame.java","additions":0,"deletions":497,"binary":false,"changes":497,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingBinaryPingClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingBinaryPongClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingPingBinaryClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingPingTextClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingPongBinaryClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingPongTextClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingTextPingClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/PendingTextPongClose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/SendTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n+ * @build DummyWebSocketServer\n+ *        Support\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketBuilderTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351339\n+ * @summary Verify the intact transmission of the binary payload regardless of its endianness\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n+ * @library \/test\/lib\n+ * @build DummyWebSocketServer\n+ *        jdk.test.lib.Asserts\n+ * @run main WebSocketEndiannessTest\n+ *\/\n+\n+import jdk.internal.net.http.websocket.Frame;\n+\n+import java.net.http.HttpClient;\n+import java.net.http.WebSocket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertEqualsByteArray;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+public class WebSocketEndiannessTest {\n+\n+    private static final ByteBuffer DATA_LE = ByteBuffer\n+            .wrap(new byte[]{\n+                    \/\/ 4-byte words in LE order\n+                    0x00, 0x01, 0x02, 0x03,\n+                    0x04, 0x05, 0x06, 0x07,\n+                    0x08, 0x09, 0x0a, 0x0b,\n+                    0x0c, 0x0d, 0x0e, 0x0f,\n+                    \/\/ 2-byte words in LE order\n+                    0x10, 0x11,\n+                    0x12, 0x13,\n+                    0x14, 0x15,\n+                    0x16, 0x17,\n+                    0x18, 0x19,\n+                    0x1a, 0x1b,\n+                    0x1c, 0x1d,\n+                    0x1e, 0x1f\n+            })\n+            .order(ByteOrder.LITTLE_ENDIAN);\n+\n+    private static final ByteBuffer DATA_BE = ByteBuffer\n+            .wrap(new byte[]{\n+                    \/\/ 4-byte words in BE order\n+                    0x03, 0x02, 0x01, 0x00,\n+                    0x07, 0x06, 0x05, 0x04,\n+                    0x0b, 0x0a, 0x09, 0x08,\n+                    0x0f, 0x0e, 0x0d, 0x0c,\n+                    \/\/ 2-byte words in BE order\n+                    0x11, 0x10,\n+                    0x13, 0x12,\n+                    0x15, 0x14,\n+                    0x17, 0x16,\n+                    0x19, 0x18,\n+                    0x1b, 0x1a,\n+                    0x1d, 0x1c,\n+                    0x1f, 0x1e\n+            })\n+            .order(ByteOrder.BIG_ENDIAN);\n+\n+    public static void main(String[] args) throws Exception {\n+        assertEndiannessAgnosticTransfer(DATA_LE);\n+        assertEndiannessAgnosticTransfer(DATA_BE);\n+    }\n+\n+    private static void assertEndiannessAgnosticTransfer(ByteBuffer data) throws Exception {\n+        List<DummyWebSocketServer.DecodedFrame> frames = sendDataAndReadFrames(data);\n+        assertEquals(frames.size(), 1);\n+        DummyWebSocketServer.DecodedFrame frame = frames.getFirst();\n+        assertEquals(frame.opcode(), Frame.Opcode.BINARY);\n+        assertTrue(frame.last());\n+        assertEqualsByteArray(data.array(), frame.data().array());\n+    }\n+\n+    private static List<DummyWebSocketServer.DecodedFrame> sendDataAndReadFrames(ByteBuffer data) throws Exception {\n+        try (var server = new DummyWebSocketServer();\n+             var client = HttpClient.newBuilder().proxy(NO_PROXY).build()) {\n+            server.open();\n+            WebSocket webSocket = client\n+                    .newWebSocketBuilder()\n+                    .buildAsync(server.getURI(), new WebSocket.Listener() {})\n+                    .join();\n+            try {\n+                webSocket.sendBinary(data, true).join();\n+            } finally {\n+                webSocket.abort();\n+            }\n+            return server.readFrames();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketEndiannessTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- *\n- *\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n@@ -36,0 +35,1 @@\n+import jdk.internal.net.http.websocket.Frame;\n@@ -43,1 +43,0 @@\n-import java.util.ArrayList;\n@@ -80,2 +79,1 @@\n-            ByteBuffer data = server.read();\n-            List<Frame> frames = readFrames(data);\n+            List<DummyWebSocketServer.DecodedFrame> frames = server.readFrames();\n@@ -83,4 +81,4 @@\n-            Frame f = frames.get(0);\n-            assertTrue(f.last);\n-            assertEquals(f.opcode, Frame.Opcode.BINARY);\n-            assertEquals(f.data, expected);\n+            DummyWebSocketServer.DecodedFrame f = frames.get(0);\n+            assertTrue(f.last());\n+            assertEquals(f.opcode(), Frame.Opcode.BINARY);\n+            assertEquals(f.data(), expected);\n@@ -90,75 +88,0 @@\n-    private static List<Frame> readFrames(ByteBuffer src) {\n-        List<Frame> frames = new ArrayList<>();\n-        Frame.Consumer consumer = new Frame.Consumer() {\n-\n-            ByteBuffer data;\n-            Frame.Opcode opcode;\n-            Frame.Masker masker = new Frame.Masker();\n-            boolean last;\n-\n-            @Override\n-            public void fin(boolean value) {\n-                last = value;\n-            }\n-\n-            @Override\n-            public void rsv1(boolean value) {\n-                if (value) {\n-                    throw new AssertionError();\n-                }\n-            }\n-\n-            @Override\n-            public void rsv2(boolean value) {\n-                if (value) {\n-                    throw new AssertionError();\n-                }\n-            }\n-\n-            @Override\n-            public void rsv3(boolean value) {\n-                if (value) {\n-                    throw new AssertionError();\n-                }\n-            }\n-\n-            @Override\n-            public void opcode(Frame.Opcode value) {\n-                opcode = value;\n-            }\n-\n-            @Override\n-            public void mask(boolean value) {\n-                if (!value) { \/\/ Frames from the client MUST be masked\n-                    throw new AssertionError();\n-                }\n-            }\n-\n-            @Override\n-            public void payloadLen(long value) {\n-                data = ByteBuffer.allocate((int) value);\n-            }\n-\n-            @Override\n-            public void maskingKey(int value) {\n-                masker.mask(value);\n-            }\n-\n-            @Override\n-            public void payloadData(ByteBuffer data) {\n-                masker.transferMasking(data, this.data);\n-            }\n-\n-            @Override\n-            public void endFrame() {\n-                frames.add(new Frame(opcode, this.data.flip(), last));\n-            }\n-        };\n-\n-        Frame.Reader r = new Frame.Reader();\n-        while (src.hasRemaining()) {\n-            r.readFrame(src, consumer);\n-        }\n-        return frames;\n-    }\n-\n@@ -175,2 +98,1 @@\n-            ByteBuffer data = server.read();\n-            List<Frame> frames = readFrames(data);\n+            List<DummyWebSocketServer.DecodedFrame> frames = server.readFrames();\n@@ -178,2 +100,2 @@\n-            Frame f = frames.get(0);\n-            assertEquals(f.opcode, Frame.Opcode.PING);\n+            DummyWebSocketServer.DecodedFrame f = frames.get(0);\n+            assertEquals(f.opcode(), Frame.Opcode.PING);\n@@ -181,1 +103,1 @@\n-            actual.put(f.data);\n+            actual.put(f.data());\n@@ -197,2 +119,1 @@\n-            ByteBuffer data = server.read();\n-            List<Frame> frames = readFrames(data);\n+            List<DummyWebSocketServer.DecodedFrame> frames = server.readFrames();\n@@ -200,2 +121,2 @@\n-            Frame f = frames.get(0);\n-            assertEquals(f.opcode, Frame.Opcode.PONG);\n+            DummyWebSocketServer.DecodedFrame f = frames.get(0);\n+            assertEquals(f.opcode(), Frame.Opcode.PONG);\n@@ -203,1 +124,1 @@\n-            actual.put(f.data);\n+            actual.put(f.data());\n@@ -219,2 +140,1 @@\n-            ByteBuffer data = server.read();\n-            List<Frame> frames = readFrames(data);\n+            List<DummyWebSocketServer.DecodedFrame> frames = server.readFrames();\n@@ -222,4 +142,4 @@\n-            Frame f = frames.get(0);\n-            assertEquals(f.opcode, Frame.Opcode.CLOSE);\n-            ByteBuffer actual = ByteBuffer.allocate(Frame.MAX_CONTROL_FRAME_PAYLOAD_SIZE);\n-            actual.put(f.data);\n+            DummyWebSocketServer.DecodedFrame f = frames.get(0);\n+            assertEquals(f.opcode(), Frame.Opcode.CLOSE);\n+            ByteBuffer actual = ByteBuffer.allocate(Frame.MAX_CONTROL_FRAME_PAYLOAD_LENGTH);\n+            actual.put(f.data());\n@@ -242,3 +162,1 @@\n-            ByteBuffer data = server.read();\n-            List<Frame> frames = readFrames(data);\n-\n+            List<DummyWebSocketServer.DecodedFrame> frames = server.readFrames();\n@@ -247,1 +165,1 @@\n-            frames.stream().forEachOrdered(f -> actual.put(f.data));\n+            frames.stream().forEachOrdered(f -> actual.put(f.data()));\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketExtendedTest.java","additions":23,"deletions":105,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import static jdk.internal.net.http.websocket.Frame.Masker.transferMasking;\n+import static jdk.internal.net.http.websocket.Frame.Masker.mask;\n@@ -49,1 +49,1 @@\n-                            () -> transferMasking(src, dst, m));\n+                            () -> mask(src, dst, m));\n@@ -70,1 +70,1 @@\n-                    masker.mask(mask);\n+                    masker.reset(mask);\n@@ -74,1 +74,1 @@\n-                                () -> masker.transferMasking(s, dst));\n+                                () -> masker.mask(s, dst));\n@@ -82,1 +82,1 @@\n-        masker.mask(m);\n+        masker.reset(m);\n@@ -86,1 +86,1 @@\n-                () -> masker.transferMasking(src, dst));\n+                () -> masker.mask(src, dst));\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MaskerTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @modules java.net.http\/jdk.internal.net.http.websocket\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/security\/WSSanityTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}