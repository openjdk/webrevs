{"files":[{"patch":"@@ -51,1 +51,0 @@\n-    public enum CTSVariant {CS1, CS2, CS3}\n@@ -171,1 +170,1 @@\n-    private CTSVariant ctsVariant = CTSVariant.CS1;\n+    private Token.CTSVariant ctsVariant = null;\n@@ -330,1 +329,1 @@\n-    CTSVariant getCTSVariant() {\n+    Token.CTSVariant getCTSVariant() {\n@@ -485,8 +484,2 @@\n-            case \"cipherTextStealingVariant\" -> {\n-                try {\n-                    ctsVariant = CTSVariant.valueOf(parseStringEntry(st.sval));\n-                } catch (IllegalArgumentException ignored) {\n-                    throw excToken(\"cipherTextStealingVariant must be one of \" +\n-                            Arrays.toString(CTSVariant.values()) + \" :\");\n-                }\n-            }\n+            case \"cipherTextStealingVariant\"->\n+                ctsVariant = parseEnumEntry(Token.CTSVariant.class, st.sval);\n@@ -648,0 +641,11 @@\n+    private <E extends Enum<E>> E parseEnumEntry(Class<E> enumClass,\n+            String keyword) throws IOException {\n+        String value = parseStringEntry(keyword);\n+        try {\n+            return Enum.valueOf(enumClass, value);\n+        } catch (IllegalArgumentException ignored) {\n+            throw excToken(keyword + \" must be one of \" +\n+                    Arrays.toString(enumClass.getEnumConstants()) + \", read:\");\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1159,2 +1159,3 @@\n-        Config.CTSVariant tokenVariant = token.config.getCTSVariant();\n-        if (tokenVariant == Config.CTSVariant.CS3) {\n+        assert token.ctsVariant != null : \"CTS algorithms should not be \" +\n+                \"registered if the CTS variant of the token is unknown\";\n+        if (token.ctsVariant == Token.CTSVariant.CS3) {\n@@ -1165,1 +1166,1 @@\n-        if (tokenVariant == Config.CTSVariant.CS2 && pad != 0) {\n+        if (token.ctsVariant == Token.CTSVariant.CS2 && pad != 0) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1302,1 +1302,7 @@\n-\n+            if (longMech == CKM_AES_CTS && token.ctsVariant == null) {\n+                if (showInfo) {\n+                    System.out.println(\"DISABLED due to an unspecified \" +\n+                            \"cipherTextStealingVariant in configuration\");\n+                }\n+                continue;\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+    public enum CTSVariant {CS1, CS2, CS3}\n@@ -68,0 +69,3 @@\n+    @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n+    final CTSVariant ctsVariant;\n+\n@@ -149,0 +153,1 @@\n+        ctsVariant = getCTSVariant();\n@@ -415,0 +420,13 @@\n+    private CTSVariant getCTSVariant() {\n+        CTSVariant ctsVariant = config.getCTSVariant();\n+        if (ctsVariant != null) {\n+            return ctsVariant;\n+        }\n+        \/\/ 'cipherTextStealingVariant' needs an explicit value for the\n+        \/\/ CKM_AES_CTS mechanism to be enabled. In the case of NSS we know\n+        \/\/ that this value is 'CS1', so we can set it for the user. See:\n+        \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=373108#c7\n+        \/\/ https:\/\/github.com\/nss-dev\/nss\/blob\/NSS_3_99_RTM\/lib\/freebl\/cts.c#L65\n+        return P11Util.isNSS(this) ? CTSVariant.CS1 : null;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}