{"files":[{"patch":"@@ -167,0 +167,5 @@\n+    \/\/ CTS mode variant used by the token, as described in Addendum to NIST\n+    \/\/ Special Publication 800-38A, \"Recommendation for Block Cipher Modes\n+    \/\/ of Operation: Three Variants of Ciphertext Stealing for CBC Mode\".\n+    private Token.CTSVariant ctsVariant = null;\n+\n@@ -324,0 +329,4 @@\n+    Token.CTSVariant getCTSVariant() {\n+        return ctsVariant;\n+    }\n+\n@@ -475,0 +484,2 @@\n+            case \"cipherTextStealingVariant\"->\n+                ctsVariant = parseEnumEntry(Token.CTSVariant.class, st.sval);\n@@ -630,0 +641,11 @@\n+    private <E extends Enum<E>> E parseEnumEntry(Class<E> enumClass,\n+            String keyword) throws IOException {\n+        String value = parseStringEntry(keyword);\n+        try {\n+            return Enum.valueOf(enumClass, value);\n+        } catch (IllegalArgumentException ignored) {\n+            throw excToken(keyword + \" must be one of \" +\n+                    Arrays.toString(enumClass.getEnumConstants()) + \", read:\");\n+        }\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Config.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * This class is designed to support ECB, CBC, CTR with NoPadding\n+ * This class is designed to support ECB, CBC, CTR, CTS with NoPadding\n@@ -63,11 +63,3 @@\n-    \/\/ mode constant for ECB mode\n-    private static final int MODE_ECB = 3;\n-    \/\/ mode constant for CBC mode\n-    private static final int MODE_CBC = 4;\n-    \/\/ mode constant for CTR mode\n-    private static final int MODE_CTR = 5;\n-\n-    \/\/ padding constant for NoPadding\n-    private static final int PAD_NONE = 5;\n-    \/\/ padding constant for PKCS5Padding\n-    private static final int PAD_PKCS5 = 6;\n+    \/\/ mode and padding constants\n+    private enum Mode {ECB \/* or stream ciphers *\/, CBC, CTR, CTS}\n+    private enum Pad {NONE, PKCS5}\n@@ -149,2 +141,2 @@\n-    \/\/ mode, one of MODE_* above (MODE_ECB for stream ciphers)\n-    private int blockMode;\n+    \/\/ mode, Mode.ECB for stream ciphers\n+    private final Mode blockMode;\n@@ -155,2 +147,2 @@\n-    \/\/ padding type, on of PAD_* above (PAD_NONE for stream ciphers)\n-    private int paddingType;\n+    \/\/ padding type, Pad.NONE for stream ciphers\n+    private Pad paddingType;\n@@ -166,1 +158,1 @@\n-    \/\/ original IV, if in MODE_CBC or MODE_CTR\n+    \/\/ original IV, if in Mode.CBC, Mode.CTR or Mode.CTS\n@@ -211,2 +203,1 @@\n-        this.blockMode =\n-            (algoParts.length > 1 ? parseMode(algoParts[1]) : MODE_ECB);\n+        blockMode = algoParts.length > 1 ? parseMode(algoParts[1]) : Mode.ECB;\n@@ -230,1 +221,1 @@\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n+    private Mode parseMode(String mode) throws NoSuchAlgorithmException {\n@@ -232,12 +223,11 @@\n-        return switch (mode) {\n-            case \"ECB\" -> MODE_ECB;\n-            case \"CBC\" -> {\n-                if (blockSize == 0) {\n-                    throw new NoSuchAlgorithmException\n-                            (\"CBC mode not supported with stream ciphers\");\n-                }\n-                yield MODE_CBC;\n-            }\n-            case \"CTR\" -> MODE_CTR;\n-            default -> throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-        };\n+        Mode result;\n+        try {\n+            result = Mode.valueOf(mode);\n+        } catch (IllegalArgumentException ignored) {\n+            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        }\n+        if (blockSize == 0 && result != Mode.ECB) {\n+            throw new NoSuchAlgorithmException(\n+                    result + \" mode not supported with stream ciphers\");\n+        }\n+        return result;\n@@ -253,1 +243,10 @@\n-            paddingType = PAD_NONE;\n+            paddingType = Pad.NONE;\n+            if (blockMode == Mode.CTS) {\n+                \/\/ Buffer at least two blocks (where the last one may be\n+                \/\/ partial). When using NSS, buffer one more block to avoid\n+                \/\/ NSS Bug 1823875: \"AES CTS decryption does not update\n+                \/\/ its own context's IV on full blocks input\"\n+                \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1823875#c2\n+                int bufferedBlocks = P11Util.isNSS(token) ? 3 : 2;\n+                padBuffer = new byte[bufferedBlocks * blockSize];\n+            }\n@@ -255,3 +254,3 @@\n-            if (this.blockMode == MODE_CTR) {\n-                throw new NoSuchPaddingException\n-                    (\"PKCS#5 padding not supported with CTR mode\");\n+            if (blockMode == Mode.CTR || blockMode == Mode.CTS) {\n+                throw new NoSuchPaddingException(\"PKCS#5 padding not \" +\n+                        \"supported with \" + blockMode + \" mode\");\n@@ -259,1 +258,1 @@\n-            paddingType = PAD_PKCS5;\n+            paddingType = Pad.PKCS5;\n@@ -374,1 +373,1 @@\n-        if (blockMode == MODE_ECB) { \/\/ ECB or stream cipher\n+        if (blockMode == Mode.ECB) { \/\/ ECB or stream cipher\n@@ -384,1 +383,1 @@\n-        } else { \/\/ MODE_CBC or MODE_CTR\n+        } else { \/\/ Mode.CBC, Mode.CTR or Mode.CTS\n@@ -387,5 +386,3 @@\n-                    String exMsg =\n-                        (blockMode == MODE_CBC ?\n-                         \"IV must be specified for decryption in CBC mode\" :\n-                         \"IV must be specified for decryption in CTR mode\");\n-                    throw new InvalidAlgorithmParameterException(exMsg);\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"IV must be specified for decryption in \" +\n+                            blockMode + \" mode\");\n@@ -436,0 +433,3 @@\n+            if (padBuffer != null) {\n+                Arrays.fill(padBuffer, (byte) 0);\n+            }\n@@ -490,1 +490,1 @@\n-            CK_MECHANISM mechParams = (blockMode == MODE_CTR ?\n+            CK_MECHANISM mechParams = (blockMode == Mode.CTR ?\n@@ -515,1 +515,3 @@\n-        if (blockSize != 0 && blockMode != MODE_CTR) {\n+        if (blockMode == Mode.CTS) {\n+            result -= getCTSMustBeBuffered(result);\n+        } else if (blockSize != 0 && blockMode != Mode.CTR) {\n@@ -529,1 +531,1 @@\n-        if (blockSize != 0 && encrypt && paddingType != PAD_NONE) {\n+        if (blockSize != 0 && encrypt && paddingType != Pad.NONE) {\n@@ -607,1 +609,50 @@\n-            if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+            if (blockMode == Mode.CTS) {\n+                \/\/ decide how to split the total data (totalInLen) between\n+                \/\/ the token (dataForP11Update) and padBuffer\n+                \/\/ (newPadBufferLen)\n+                int totalInLen = padBufferLen + inLen;\n+                newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                int dataForP11Update = totalInLen - newPadBufferLen;\n+                if (dataForP11Update > 0 && padBufferLen > 0) {\n+                    \/\/ there is data for the token and part of it is in\n+                    \/\/ padBuffer\n+                    int flushFromPadBuffer;\n+                    int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                    if (dataForP11Update >= padBufferLen + fillLen) {\n+                        \/\/ flush the whole padBuffer\n+                        if (fillLen > 0) {\n+                            \/\/ complete the last padBuffer block from the\n+                            \/\/ input\n+                            bufferInputBytes(in, inOfs, fillLen);\n+                            inOfs += fillLen;\n+                            inLen -= fillLen;\n+                        }\n+                        flushFromPadBuffer = padBufferLen;\n+                    } else {\n+                        \/\/ There is not enough input data available to\n+                        \/\/ complete the padBuffer to a multiple of block\n+                        \/\/ size. Flush part of the padBuffer (up to a\n+                        \/\/ multiple of blockSize) now. Shift the remaining\n+                        \/\/ padBuffer data and buffer more up to completing\n+                        \/\/ newPadBufferLen later.\n+                        flushFromPadBuffer = dataForP11Update;\n+                    }\n+                    if (encrypt) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    } else {\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, flushFromPadBuffer,\n+                                0, out, outOfs, outLen);\n+                    }\n+                    padBufferLen -= flushFromPadBuffer;\n+                    if (padBufferLen > 0) {\n+                        \/\/ shift remaining data to the padBuffer start\n+                        System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                padBuffer, 0, padBufferLen);\n+                    }\n+                }\n+                newPadBufferLen -= padBufferLen;\n+                inLen -= newPadBufferLen;\n+            } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -652,1 +703,2 @@\n-            if (paddingObj != null && newPadBufferLen > 0) {\n+            if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                    newPadBufferLen > 0) {\n@@ -718,1 +770,50 @@\n-                if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n+                if (blockMode == Mode.CTS) {\n+                    \/\/ decide how to split the total data (totalInLen) between\n+                    \/\/ the token (dataForP11Update) and padBuffer\n+                    \/\/ (newPadBufferLen)\n+                    int totalInLen = padBufferLen + inLen;\n+                    newPadBufferLen = getCTSMustBeBuffered(totalInLen);\n+                    int dataForP11Update = totalInLen - newPadBufferLen;\n+                    if (dataForP11Update > 0 && padBufferLen > 0) {\n+                        \/\/ there is data for the token and part of it is in\n+                        \/\/ padBuffer\n+                        int flushFromPadBuffer;\n+                        int fillLen = getBytesToCompleteBlock(padBufferLen);\n+                        if (dataForP11Update >= padBufferLen + fillLen) {\n+                            \/\/ flush the whole padBuffer\n+                            if (fillLen > 0) {\n+                                \/\/ complete the last padBuffer block from the\n+                                \/\/ input\n+                                bufferInputBytes(inBuffer, fillLen);\n+                                inOfs += fillLen;\n+                                inLen -= fillLen;\n+                            }\n+                            flushFromPadBuffer = padBufferLen;\n+                        } else {\n+                            \/\/ There is not enough input data available to\n+                            \/\/ complete the padBuffer to a multiple of block\n+                            \/\/ size. Flush part of the padBuffer (up to a\n+                            \/\/ multiple of blockSize) now. Shift the remaining\n+                            \/\/ padBuffer data and buffer more up to completing\n+                            \/\/ newPadBufferLen later.\n+                            flushFromPadBuffer = dataForP11Update;\n+                        }\n+                        if (encrypt) {\n+                            k = token.p11.C_EncryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        } else {\n+                            k = token.p11.C_DecryptUpdate(session.id(),\n+                                    0, padBuffer, 0, flushFromPadBuffer,\n+                                    outAddr, outArray, outOfs, outLen);\n+                        }\n+                        padBufferLen -= flushFromPadBuffer;\n+                        if (padBufferLen > 0) {\n+                            \/\/ shift remaining data to the padBuffer start\n+                            System.arraycopy(padBuffer, flushFromPadBuffer,\n+                                    padBuffer, 0, padBufferLen);\n+                        }\n+                    }\n+                    newPadBufferLen -= padBufferLen;\n+                    inLen -= newPadBufferLen;\n+                } else if (paddingObj != null && (!encrypt || reqBlockUpdates)) {\n@@ -771,1 +872,2 @@\n-                if (paddingObj != null && newPadBufferLen > 0) {\n+                if ((blockMode == Mode.CTS || paddingObj != null) &&\n+                        newPadBufferLen > 0) {\n@@ -815,1 +917,5 @@\n-                if (paddingObj != null) {\n+                if (blockMode == Mode.CTS) {\n+                    k = token.p11.C_EncryptUpdate(session.id(),\n+                            0, padBuffer, 0, padBufferLen,\n+                            0, out, outOfs, outLen);\n+                } else if (paddingObj != null) {\n@@ -842,0 +948,3 @@\n+                if (blockMode == Mode.CTS) {\n+                    convertCTSVariant(null, out, outOfs + k);\n+                }\n@@ -847,0 +956,8 @@\n+                if (blockMode == Mode.CTS) {\n+                    convertCTSVariant(null, padBuffer, padBufferLen);\n+                    k = token.p11.C_DecryptUpdate(session.id(),\n+                            0, padBuffer, 0, padBufferLen,\n+                            0, out, outOfs, outLen);\n+                    outOfs += k;\n+                    outLen -= k;\n+                }\n@@ -867,1 +984,1 @@\n-                    k = token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n+                    k += token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,\n@@ -913,1 +1030,5 @@\n-                    if (paddingObj != null) {\n+                    if (blockMode == Mode.CTS) {\n+                        k = token.p11.C_EncryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                    } else if (paddingObj != null) {\n@@ -940,0 +1061,3 @@\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(outBuffer, outArray, outOfs + k);\n+                    }\n@@ -945,1 +1069,8 @@\n-\n+                    if (blockMode == Mode.CTS) {\n+                        convertCTSVariant(null, padBuffer, padBufferLen);\n+                        k = token.p11.C_DecryptUpdate(session.id(),\n+                                0, padBuffer, 0, padBufferLen,\n+                                outAddr, outArray, outOfs, outLen);\n+                        outOfs += k;\n+                        outLen -= k;\n+                    }\n@@ -968,1 +1099,1 @@\n-                        k = token.p11.C_DecryptFinal(session.id(),\n+                        k += token.p11.C_DecryptFinal(session.id(),\n@@ -991,0 +1122,72 @@\n+    private int getBytesToCompleteBlock(int availableBytes) {\n+        int partBlock = availableBytes & (blockSize - 1);\n+        return partBlock == 0 ? 0 : blockSize - partBlock;\n+    }\n+\n+    private int getCTSMustBeBuffered(int availableBytes) {\n+        return Math.min(availableBytes,\n+                padBuffer.length - getBytesToCompleteBlock(availableBytes));\n+    }\n+\n+    \/**\n+     * The ciphertext ordering for the three variants can be depicted as\n+     * follows, where 'p' is the penultimate block (which may be partial\n+     * or full), and 'f' the full final block:\n+     *\n+     *                    'p' is a partial block   'p' is a full block\n+     *                   ------------------------ ---------------------\n+     *   CS1 (NIST)     |     .... pp ffff       |    .... pppp ffff\n+     *   CS2 (Schneier) |     .... ffff pp       |    .... pppp ffff\n+     *   CS3 (Kerberos) |     .... ffff pp       |    .... ffff pppp\n+     *\n+     * After encryption, we get the ciphertext from the token formatted as\n+     * specified in the SunPKCS11 'cipherTextStealingVariant' configuration\n+     * property. Conversely, before decryption, the ciphertext has to be passed\n+     * to the token according to the previous formatting. This method converts\n+     * the ciphertext between the format used by the token and the one used by\n+     * SunJCE's \"AES\/CTS\/NoPadding\" implementation (CS3 as described by RFC\n+     * 2040, section 8).\n+     *\/\n+    private void convertCTSVariant(ByteBuffer ciphertextBuf,\n+            byte[] ciphertextArr, int ciphertextEnd) {\n+        if (padBufferLen == blockSize) {\n+            \/\/ No reordering needed for a single block\n+            return;\n+        }\n+        assert token.ctsVariant != null : \"CTS algorithms should not be \" +\n+                \"registered if the CTS variant of the token is unknown\";\n+        if (token.ctsVariant == Token.CTSVariant.CS3) {\n+            \/\/ Already CS3\n+            return;\n+        }\n+        int pad = padBufferLen % blockSize;\n+        if (token.ctsVariant == Token.CTSVariant.CS2 && pad != 0) {\n+            \/\/ CS2 and 'p' is a partial block, equal to CS3\n+            return;\n+        }\n+        if (ciphertextArr != null) {\n+            ciphertextBuf = ByteBuffer.wrap(ciphertextArr);\n+        }\n+        if (ciphertextBuf != null) {\n+            pad = pad == 0 ? blockSize : pad;\n+            if (encrypt) {\n+                \/\/ .... pp[pp] ffff -> .... ffff pp[pp]\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, pad, blockSize);\n+            } else {\n+                \/\/ .... ffff pp[pp] -> .... pp[pp] ffff\n+                swapLastTwoBlocks(ciphertextBuf, ciphertextEnd, blockSize, pad);\n+            }\n+        }\n+    }\n+\n+    private static void swapLastTwoBlocks(ByteBuffer ciphertextBuf,\n+            int ciphertextEnd, int prevBlockLen, int lastBlockLen) {\n+        \/\/ .... prevBlock lastBlock -> .... lastBlock prevBlock\n+        int prevBlockStart = ciphertextEnd - prevBlockLen - lastBlockLen;\n+        byte[] prevBlockBackup = new byte[prevBlockLen];\n+        ciphertextBuf.get(prevBlockStart, prevBlockBackup);\n+        ciphertextBuf.put(prevBlockStart, ciphertextBuf,\n+                ciphertextEnd - lastBlockLen, lastBlockLen);\n+        ciphertextBuf.put(ciphertextEnd - prevBlockLen, prevBlockBackup);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":260,"deletions":57,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -863,0 +863,9 @@\n+        d(CIP, \"AES\/CTS\/NoPadding\",             P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_128\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_192\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+        d(CIP, \"AES_256\/CTS\/NoPadding\",         P11Cipher,\n+                m(CKM_AES_CTS));\n+\n@@ -1293,1 +1302,7 @@\n-\n+            if (longMech == CKM_AES_CTS && token.ctsVariant == null) {\n+                if (showInfo) {\n+                    System.out.println(\"DISABLED due to an unspecified \" +\n+                            \"cipherTextStealingVariant in configuration\");\n+                }\n+                continue;\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+    public enum CTSVariant {CS1, CS2, CS3}\n@@ -68,0 +69,2 @@\n+    final transient CTSVariant ctsVariant;\n+\n@@ -149,0 +152,1 @@\n+        ctsVariant = getCTSVariant();\n@@ -415,0 +419,13 @@\n+    private CTSVariant getCTSVariant() {\n+        CTSVariant ctsVariant = config.getCTSVariant();\n+        if (ctsVariant != null) {\n+            return ctsVariant;\n+        }\n+        \/\/ 'cipherTextStealingVariant' needs an explicit value for the\n+        \/\/ CKM_AES_CTS mechanism to be enabled. In the case of NSS we know\n+        \/\/ that this value is 'CS1', so we can set it for the user. See:\n+        \/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=373108#c7\n+        \/\/ https:\/\/github.com\/nss-dev\/nss\/blob\/NSS_3_99_RTM\/lib\/freebl\/cts.c#L65\n+        return P11Util.isNSS(this) ? CTSVariant.CS1 : null;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @bug 8330842\n+ * @summary test AES CTS multipart operations with SunPKCS11\n+ * @library \/test\/lib ..\n+ * @run main\/othervm\/timeout=120 TestCipherTextStealingMultipart\n+ *\/\n+\n+public class TestCipherTextStealingMultipart extends PKCS11Test {\n+    private static final String LF = System.lineSeparator();\n+    private static final String ALGORITHM = \"AES\/CTS\/NoPadding\";\n+    private static final int BLOCK_SIZE = 16;\n+    private static final Key KEY =\n+            new SecretKeySpec(\"AbCdEfGhIjKlMnOp\".getBytes(), \"AES\");\n+    private static final IvParameterSpec IV =\n+            new IvParameterSpec(\"1234567890aBcDeF\".getBytes());\n+\n+    private static final StringBuilder chunksDesc = new StringBuilder();\n+    private static Provider sunPKCS11;\n+    private static Cipher sunJCECipher;\n+\n+    private static byte[][] generateChunks(int totalLength, int[] chunkSizes) {\n+        chunksDesc.setLength(0);\n+        chunksDesc.append(\"Testing with \").append(totalLength)\n+                .append(\" bytes distributed in \").append(chunkSizes.length)\n+                .append(\" multipart updates:\").append(LF);\n+        int byteIdx = 0;\n+        byte[][] plaintextChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            for (int i = 0; i < chunk.length; i++) {\n+                chunk[i] = (byte) ('A' + byteIdx++ \/ BLOCK_SIZE);\n+            }\n+            chunksDesc.append(\"  \").append(repr(chunk)).append(LF);\n+            plaintextChunks[chunkIdx] = chunk;\n+        }\n+        return plaintextChunks;\n+    }\n+\n+    private static byte[] computeExpected(byte[] jointPlaintext)\n+            throws Exception {\n+        byte[] ciphertext = sunJCECipher.doFinal(jointPlaintext);\n+        if (ciphertext.length != jointPlaintext.length) {\n+            throw new Exception(\"In CTS mode, ciphertext and plaintext should\" +\n+                    \" have the same length. However, SunJCE's CTS cipher \" +\n+                    \"returned a ciphertext of \" + ciphertext.length + \" bytes\" +\n+                    \" and plaintext has \" + jointPlaintext.length + \" bytes.\");\n+        }\n+        return ciphertext;\n+    }\n+\n+    private enum CheckType {CIPHERTEXT, PLAINTEXT}\n+\n+    private enum OutputType {BYTE_ARRAY, DIRECT_BYTE_BUFFER}\n+\n+    private static void check(CheckType checkType, OutputType outputType,\n+            byte[] expected, ByteBuffer actualBuf) throws Exception {\n+        byte[] actual;\n+        if (actualBuf.hasArray()) {\n+            actual = actualBuf.array();\n+        } else {\n+            actual = new byte[actualBuf.position()];\n+            actualBuf.position(0).get(actual);\n+        }\n+        if (!Arrays.equals(actual, expected)) {\n+            throw new Exception(\"After \" + switch (checkType) {\n+                case CIPHERTEXT -> \"encrypting\";\n+                case PLAINTEXT -> \"decrypting\";\n+            } + \" into a \" + switch (outputType) {\n+                case BYTE_ARRAY -> \"byte[]\";\n+                case DIRECT_BYTE_BUFFER -> \"direct ByteBuffer\";\n+            } + \", \" + checkType.name().toLowerCase() + \"s don't match:\" + LF +\n+                    \"  Expected: \" + repr(expected) + LF +\n+                    \"    Actual: \" + repr(actual));\n+        }\n+    }\n+\n+    private static void doMultipart(int... chunkSizes) throws Exception {\n+        int totalLength = IntStream.of(chunkSizes).sum();\n+        byte[][] plaintextChunks = generateChunks(totalLength, chunkSizes);\n+\n+        ByteBuffer jointPlaintextBuf = ByteBuffer.allocate(totalLength);\n+        for (byte[] plaintextChunk : plaintextChunks) {\n+            jointPlaintextBuf.put(plaintextChunk);\n+        }\n+        byte[] jointPlaintext = jointPlaintextBuf.array();\n+        byte[] expectedCiphertext = computeExpected(jointPlaintext);\n+\n+        \/\/ Check that the output array offset does not affect the penultimate\n+        \/\/ block length calculation.\n+        int outOfs = 1;\n+\n+        Cipher cipher = Cipher.getInstance(ALGORITHM, sunPKCS11);\n+\n+        \/\/ Encryption test, with byte[]\n+        cipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n+        ByteBuffer actualCiphertextBuf = ByteBuffer.allocate(totalLength);\n+        for (byte[] plaintextChunk : plaintextChunks) {\n+            actualCiphertextBuf.put(cipher.update(plaintextChunk));\n+        }\n+\n+        byte [] outArray = new byte[cipher.getOutputSize(0) + outOfs];\n+        cipher.doFinal(outArray, outOfs);\n+        actualCiphertextBuf.put(outArray, outOfs, outArray.length - outOfs);\n+\n+        check(CheckType.CIPHERTEXT, OutputType.BYTE_ARRAY,\n+                expectedCiphertext, actualCiphertextBuf);\n+\n+        \/\/ Encryption test, with direct output buffer\n+        cipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n+        ByteBuffer actualCiphertextDir = ByteBuffer.allocateDirect(totalLength);\n+        for (byte[] plaintextChunk : plaintextChunks) {\n+            cipher.update(ByteBuffer.wrap(plaintextChunk), actualCiphertextDir);\n+        }\n+\n+        ByteBuffer outBuffer = ByteBuffer.allocateDirect(\n+                cipher.getOutputSize(0) + outOfs);\n+        outBuffer.position(outOfs);\n+        cipher.doFinal(ByteBuffer.allocate(0), outBuffer);\n+        outBuffer.position(outOfs);\n+        actualCiphertextDir.put(outBuffer);\n+\n+        check(CheckType.CIPHERTEXT, OutputType.DIRECT_BYTE_BUFFER,\n+                expectedCiphertext, actualCiphertextDir);\n+\n+        \/\/ Decryption test, with byte[]\n+        cipher.init(Cipher.DECRYPT_MODE, KEY, IV);\n+        ByteBuffer actualPlaintextBuf = ByteBuffer.allocate(totalLength);\n+        actualCiphertextBuf.position(0);\n+        for (byte[] plaintextChunk : plaintextChunks) {\n+            \/\/ Use the same chunk sizes as the plaintext\n+            byte[] ciphertextChunk = new byte[plaintextChunk.length];\n+            actualCiphertextBuf.get(ciphertextChunk);\n+            actualPlaintextBuf.put(cipher.update(ciphertextChunk));\n+        }\n+        actualPlaintextBuf.put(cipher.doFinal());\n+\n+        check(CheckType.PLAINTEXT, OutputType.BYTE_ARRAY,\n+                jointPlaintext, actualPlaintextBuf);\n+\n+        \/\/ Decryption test, with direct output buffer\n+        cipher.init(Cipher.DECRYPT_MODE, KEY, IV);\n+        ByteBuffer actualPlaintextDir = ByteBuffer.allocateDirect(totalLength);\n+        actualCiphertextBuf.position(0);\n+        for (byte[] plaintextChunk : plaintextChunks) {\n+            \/\/ Use the same chunk sizes as the plaintext\n+            byte[] ciphertextChunk = new byte[plaintextChunk.length];\n+            actualCiphertextBuf.get(ciphertextChunk);\n+            cipher.update(ByteBuffer.wrap(ciphertextChunk), actualPlaintextDir);\n+        }\n+        cipher.doFinal(ByteBuffer.allocate(0), actualPlaintextDir);\n+\n+        check(CheckType.PLAINTEXT, OutputType.DIRECT_BYTE_BUFFER,\n+                jointPlaintext, actualPlaintextDir);\n+    }\n+\n+    private static String repr(byte[] data) {\n+        if (data == null) {\n+            return \"<null>\";\n+        }\n+        if (data.length == 0) {\n+            return \"<empty []>\";\n+        }\n+        String lenRepr = \" (\" + data.length + \" bytes)\";\n+        for (byte b : data) {\n+            if (b < 32 || b > 126) {\n+                return HexFormat.ofDelimiter(\":\").formatHex(data) + lenRepr;\n+            }\n+        }\n+        return new String(data, StandardCharsets.US_ASCII) + lenRepr;\n+    }\n+\n+    private static void initialize() throws Exception {\n+        sunJCECipher = Cipher.getInstance(ALGORITHM, \"SunJCE\");\n+        sunJCECipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        initialize();\n+        main(new TestCipherTextStealingMultipart(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        sunPKCS11 = p;\n+        try {\n+            \/\/ Test relevant combinations for 2, 3, and 4 update operations\n+            int aesBSize = 16;\n+            int[] points = new int[]{1, aesBSize - 1, aesBSize, aesBSize + 1};\n+            for (int size1 : points) {\n+                for (int size2 : points) {\n+                    if (size1 + size2 >= aesBSize) {\n+                        doMultipart(size1, size2);\n+                    }\n+                    for (int size3 : points) {\n+                        if (size1 + size2 + size3 >= aesBSize) {\n+                            doMultipart(size1, size2, size3);\n+                        }\n+                        for (int size4 : points) {\n+                            if (size1 + size2 + size3 + size4 >= aesBSize) {\n+                                doMultipart(size1, size2, size3, size4);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            doMultipart(17, 17, 17, 17, 17);\n+            doMultipart(4, 2, 7, 1, 6, 12);\n+            doMultipart(2, 15, 21, 26, 31, 26, 5, 30);\n+            doMultipart(7, 12, 26, 8, 15, 2, 17, 16, 21, 2, 32, 29);\n+            doMultipart(6, 7, 6, 1, 5, 16, 14, 1, 10, 16, 17, 8, 1, 13, 12);\n+            doMultipart(16, 125, 19, 32, 32, 16, 17,\n+                    31, 19, 13, 16, 16, 32, 16, 16);\n+            doMultipart(5, 30, 11, 9, 6, 14, 20, 6,\n+                    5, 18, 31, 33, 15, 29, 7, 9);\n+            doMultipart(105, 8, 21, 27, 30, 101, 15, 20,\n+                    23, 33, 26, 6, 8, 2, 13, 17);\n+        } catch (Exception e) {\n+            System.out.print(chunksDesc);\n+            throw e;\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898461 6604496\n+ * @bug 4898461 6604496 8330842\n@@ -83,1 +83,2 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -86,1 +87,1 @@\n-    private static StringBuffer debugBuf = new StringBuffer();\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -131,4 +132,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-                debugBuf = new StringBuffer();\n-            }\n+            System.out.println(debugBuf);\n@@ -174,2 +172,1 @@\n-        perfOut(\"stream InBuf + stream OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"stream InBuf + stream OutBuf\", endTime - startTime);\n@@ -187,2 +184,1 @@\n-        perfOut(\"non-direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -200,2 +196,1 @@\n-        perfOut(\"direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -218,2 +213,1 @@\n-        perfOut(\"direct InBuf + non-direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"direct InBuf + non-direct OutBuf\", endTime - startTime);\n@@ -234,2 +228,1 @@\n-        perfOut(\"non-direct InBuf + direct OutBuf: \" +\n-                (endTime - startTime));\n+        perfOut(\"non-direct InBuf + direct OutBuf\", endTime - startTime);\n@@ -241,1 +234,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n@@ -244,4 +237,2 @@\n-    private static void perfOut(String msg) {\n-        if (debugBuf != null) {\n-            debugBuf.append(\"PERF>\" + msg);\n-        }\n+    private static void perfOut(String msg, long elapsed) {\n+        debugOut(\"PERF> \" + msg + \", elapsed: \" + elapsed + \" ns\\n\");\n@@ -251,3 +242,1 @@\n-        if (debugBuf != null) {\n-            debugBuf.append(msg);\n-        }\n+        debugBuf.append(msg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4898484 6604496 8001284\n+ * @bug 4898484 6604496 8001284 8330842\n@@ -71,1 +71,3 @@\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65)\n+        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -74,1 +76,1 @@\n-    private static StringBuffer debugBuf;\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -114,3 +116,1 @@\n-            if (debugBuf != null) {\n-                System.out.println(debugBuf.toString());\n-            }\n+            System.out.println(debugBuf);\n@@ -125,1 +125,0 @@\n-        debugBuf = new StringBuffer();\n@@ -217,1 +216,1 @@\n-        debugBuf = null;\n+        debugBuf.setLength(0);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}