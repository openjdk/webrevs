{"files":[{"patch":"@@ -87,0 +87,19 @@\n+    private static byte[] join(byte[][] inputChunks, int totalLength) {\n+        ByteBuffer outputBuf = ByteBuffer.allocate(totalLength);\n+        for (byte[] inputChunk : inputChunks) {\n+            outputBuf.put(inputChunk);\n+        }\n+        return outputBuf.array();\n+    }\n+\n+    private static byte[][] split(byte[] input, int[] chunkSizes) {\n+        ByteBuffer inputBuf = ByteBuffer.wrap(input);\n+        byte[][] outputChunks = new byte[chunkSizes.length][];\n+        for (int chunkIdx = 0; chunkIdx < chunkSizes.length; chunkIdx++) {\n+            byte[] chunk = new byte[chunkSizes[chunkIdx]];\n+            inputBuf.get(chunk);\n+            outputChunks[chunkIdx] = chunk;\n+        }\n+        return outputChunks;\n+    }\n+\n@@ -113,0 +132,37 @@\n+    private static ByteBuffer encryptOrDecryptMultipart(int operation,\n+            OutputType outputType, byte[][] inputChunks, int totalLength)\n+            throws Exception {\n+        Cipher cipher = Cipher.getInstance(ALGORITHM, sunPKCS11);\n+        cipher.init(operation, KEY, IV);\n+        ByteBuffer output = null;\n+        int outOfs = 1;\n+        switch (outputType) {\n+            case BYTE_ARRAY -> {\n+                output = ByteBuffer.allocate(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    output.put(cipher.update(inputChunk));\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                byte[] tmpOut = new byte[cipher.getOutputSize(0) + outOfs];\n+                cipher.doFinal(tmpOut, outOfs);\n+                output.put(tmpOut, outOfs, tmpOut.length - outOfs);\n+            }\n+            case DIRECT_BYTE_BUFFER -> {\n+                output = ByteBuffer.allocateDirect(totalLength);\n+                for (byte[] inputChunk : inputChunks) {\n+                    cipher.update(ByteBuffer.wrap(inputChunk), output);\n+                }\n+                \/\/ Check that the output array offset does not affect the\n+                \/\/ penultimate block length calculation.\n+                ByteBuffer tmpOut = ByteBuffer.allocateDirect(\n+                        cipher.getOutputSize(0) + outOfs);\n+                tmpOut.position(outOfs);\n+                cipher.doFinal(ByteBuffer.allocate(0), tmpOut);\n+                tmpOut.position(outOfs);\n+                output.put(tmpOut);\n+            }\n+        }\n+        return output;\n+    }\n+\n@@ -116,6 +172,1 @@\n-\n-        ByteBuffer jointPlaintextBuf = ByteBuffer.allocate(totalLength);\n-        for (byte[] plaintextChunk : plaintextChunks) {\n-            jointPlaintextBuf.put(plaintextChunk);\n-        }\n-        byte[] jointPlaintext = jointPlaintextBuf.array();\n+        byte[] jointPlaintext = join(plaintextChunks, totalLength);\n@@ -123,47 +174,11 @@\n-\n-        \/\/ Check that the output array offset does not affect the penultimate\n-        \/\/ block length calculation.\n-        int outOfs = 1;\n-\n-        Cipher cipher = Cipher.getInstance(ALGORITHM, sunPKCS11);\n-\n-        \/\/ Encryption test, with byte[]\n-        cipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n-        ByteBuffer actualCiphertextBuf = ByteBuffer.allocate(totalLength);\n-        for (byte[] plaintextChunk : plaintextChunks) {\n-            actualCiphertextBuf.put(cipher.update(plaintextChunk));\n-        }\n-\n-        byte [] outArray = new byte[cipher.getOutputSize(0) + outOfs];\n-        cipher.doFinal(outArray, outOfs);\n-        actualCiphertextBuf.put(outArray, outOfs, outArray.length - outOfs);\n-\n-        check(CheckType.CIPHERTEXT, OutputType.BYTE_ARRAY,\n-                expectedCiphertext, actualCiphertextBuf);\n-\n-        \/\/ Encryption test, with direct output buffer\n-        cipher.init(Cipher.ENCRYPT_MODE, KEY, IV);\n-        ByteBuffer actualCiphertextDir = ByteBuffer.allocateDirect(totalLength);\n-        for (byte[] plaintextChunk : plaintextChunks) {\n-            cipher.update(ByteBuffer.wrap(plaintextChunk), actualCiphertextDir);\n-        }\n-\n-        ByteBuffer outBuffer = ByteBuffer.allocateDirect(\n-                cipher.getOutputSize(0) + outOfs);\n-        outBuffer.position(outOfs);\n-        cipher.doFinal(ByteBuffer.allocate(0), outBuffer);\n-        outBuffer.position(outOfs);\n-        actualCiphertextDir.put(outBuffer);\n-\n-        check(CheckType.CIPHERTEXT, OutputType.DIRECT_BYTE_BUFFER,\n-                expectedCiphertext, actualCiphertextDir);\n-\n-        \/\/ Decryption test, with byte[]\n-        cipher.init(Cipher.DECRYPT_MODE, KEY, IV);\n-        ByteBuffer actualPlaintextBuf = ByteBuffer.allocate(totalLength);\n-        actualCiphertextBuf.position(0);\n-        for (byte[] plaintextChunk : plaintextChunks) {\n-            \/\/ Use the same chunk sizes as the plaintext\n-            byte[] ciphertextChunk = new byte[plaintextChunk.length];\n-            actualCiphertextBuf.get(ciphertextChunk);\n-            actualPlaintextBuf.put(cipher.update(ciphertextChunk));\n+        byte[][] ciphertextChunks = split(expectedCiphertext, chunkSizes);\n+\n+        for (OutputType outputType : OutputType.values()) {\n+            \/\/ Encryption test\n+            check(CheckType.CIPHERTEXT, outputType, expectedCiphertext,\n+                    encryptOrDecryptMultipart(Cipher.ENCRYPT_MODE, outputType,\n+                            plaintextChunks, totalLength));\n+            \/\/ Decryption test\n+            check(CheckType.PLAINTEXT, outputType, jointPlaintext,\n+                    encryptOrDecryptMultipart(Cipher.DECRYPT_MODE, outputType,\n+                            ciphertextChunks, totalLength));\n@@ -171,28 +186,0 @@\n-\n-        outArray = new byte[cipher.getOutputSize(0) + outOfs];\n-        cipher.doFinal(outArray, outOfs);\n-        actualPlaintextBuf.put(outArray, outOfs, outArray.length - outOfs);\n-\n-        check(CheckType.PLAINTEXT, OutputType.BYTE_ARRAY,\n-                jointPlaintext, actualPlaintextBuf);\n-\n-        \/\/ Decryption test, with direct output buffer\n-        cipher.init(Cipher.DECRYPT_MODE, KEY, IV);\n-        ByteBuffer actualPlaintextDir = ByteBuffer.allocateDirect(totalLength);\n-        actualCiphertextBuf.position(0);\n-        for (byte[] plaintextChunk : plaintextChunks) {\n-            \/\/ Use the same chunk sizes as the plaintext\n-            byte[] ciphertextChunk = new byte[plaintextChunk.length];\n-            actualCiphertextBuf.get(ciphertextChunk);\n-            cipher.update(ByteBuffer.wrap(ciphertextChunk), actualPlaintextDir);\n-        }\n-\n-        outBuffer = ByteBuffer.allocateDirect(\n-                cipher.getOutputSize(0) + outOfs);\n-        outBuffer.position(outOfs);\n-        cipher.doFinal(ByteBuffer.allocate(0), outBuffer);\n-        outBuffer.position(outOfs);\n-        actualPlaintextDir.put(outBuffer);\n-\n-        check(CheckType.PLAINTEXT, OutputType.DIRECT_BYTE_BUFFER,\n-                jointPlaintext, actualPlaintextDir);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherTextStealingMultipart.java","additions":68,"deletions":81,"binary":false,"changes":149,"status":"modified"}]}