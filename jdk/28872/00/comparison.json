{"files":[{"patch":"@@ -213,1 +213,7 @@\n-            assertEquals(expectedCapturedSystemOut(commandWithDiscardedStreams), outputCapture.outLines());\n+            \/\/ If we dump the subprocesses's output, and the command produced both STDOUT and STDERR,\n+            \/\/ then the captured STDOUT may contain interleaved command's STDOUT and STDERR,\n+            \/\/ not in sequential order (STDOUT followed by STDERR).\n+            \/\/ In this case don't check the contents of the captured command's STDOUT.\n+            if (toolProvider || outputCapture.outLines().isEmpty() || (command.stdout().isEmpty() || command.stderr().isEmpty())) {\n+                assertEquals(expectedCapturedSystemOut(commandWithDiscardedStreams), outputCapture.outLines());\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ExecutorTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.io.UncheckedIOException;\n@@ -45,0 +46,2 @@\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n@@ -51,0 +54,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -468,3 +472,31 @@\n-        final var output = combine(\n-                processProcessStream(outputStreamsControl.stdout(), process.getInputStream()),\n-                processProcessStream(outputStreamsControl.stderr(), process.getErrorStream()));\n+        var stdoutGobbler = CompletableFuture.<Optional<List<String>>>supplyAsync(() -> {\n+            try {\n+                return processProcessStream(outputStreamsControl.stdout(), process.getInputStream());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n+\n+        var stderrGobbler = CompletableFuture.<Optional<List<String>>>supplyAsync(() -> {\n+            try {\n+                return processProcessStream(outputStreamsControl.stderr(), process.getErrorStream());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n+\n+        final CommandOutput output;\n+\n+        try {\n+            output = combine(stdoutGobbler.join(), stderrGobbler.join());\n+        } catch (CompletionException ex) {\n+            var cause = ex.getCause();\n+            switch (cause) {\n+                case UncheckedIOException uioex -> {\n+                    throw uioex.getCause();\n+                }\n+                default -> {\n+                    throw ExceptionBox.rethrowUnchecked(cause);\n+                }\n+            }\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"}]}