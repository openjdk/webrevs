{"files":[{"patch":"@@ -1851,0 +1851,3 @@\n+      break;\n+    case AssertionPredicateType::FinalIv:\n+      st->print(\"#Final IV Assertion Predicate  \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1156,1 +1156,2 @@\n-                                                  ConNode* zero, Invariance& invar, Deoptimization::DeoptReason reason) {\n+                                                  ConNode* zero, Invariance& invar,\n+                                                  Deoptimization::DeoptReason deopt_reason) {\n@@ -1168,1 +1169,1 @@\n-    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n+    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, deopt_reason,\n@@ -1209,3 +1210,3 @@\n-    Node* rng = cmp->in(2);\n-    assert(rng->Opcode() == Op_LoadRange || iff->is_RangeCheck() || _igvn.type(rng)->is_int()->_lo >= 0, \"must be\");\n-    assert(invar.is_invariant(rng), \"range must be invariant\");\n+    Node* range = cmp->in(2);\n+    assert(range->Opcode() == Op_LoadRange || iff->is_RangeCheck() || _igvn.type(range)->is_int()->_lo >= 0, \"must be\");\n+    assert(invar.is_invariant(range), \"range must be invariant\");\n@@ -1240,1 +1241,1 @@\n-    rng = invar.clone(rng, ctrl);\n+    range = invar.clone(range, ctrl);\n@@ -1248,1 +1249,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n+    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, range, false, overflow);\n@@ -1251,1 +1252,1 @@\n-    IfProjNode* lower_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : if_opcode);\n+    IfProjNode* lower_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, deopt_reason, overflow ? Op_If : if_opcode);\n@@ -1260,1 +1261,1 @@\n-    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);\n+    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, range, true, overflow);\n@@ -1262,1 +1263,1 @@\n-    IfProjNode* upper_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : if_opcode);\n+    IfProjNode* upper_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, deopt_reason, overflow ? Op_If : if_opcode);\n@@ -1275,2 +1276,2 @@\n-        add_template_assertion_predicate(iff, loop, hoisted_check_proj, parse_predicate_proj, upper_bound_proj, scale,\n-                                         offset, init, limit, stride, rng, overflow, reason);\n+        create_template_assertion_predicate(if_opcode, cl, parse_predicate_proj, upper_bound_proj, scale, offset, range,\n+                                            deopt_reason);\n@@ -1312,47 +1313,9 @@\n-IfTrueNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n-                                                             ParsePredicateSuccessProj* parse_predicate_proj,\n-                                                             IfProjNode* upper_bound_proj, const int scale, Node* offset,\n-                                                             Node* init, Node* limit, const jint stride,\n-                                                             Node* rng, bool& overflow, Deoptimization::DeoptReason reason) {\n-  \/\/ First predicate for the initial value on first loop iteration\n-  Node* opaque_init = new OpaqueLoopInitNode(C, init);\n-  register_new_node(opaque_init, upper_bound_proj);\n-  bool negate = (if_proj->_con != parse_predicate_proj->_con);\n-  BoolNode* bol = rc_predicate(upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n-                               (stride > 0) != (scale > 0), overflow);\n-  Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); \/\/ This will go away once loop opts are over\n-  C->add_template_assertion_predicate_opaq(opaque_bol);\n-  register_new_node(opaque_bol, upper_bound_proj);\n-  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n-                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n-  _igvn.replace_input_of(new_proj->in(0), 1, opaque_bol);\n-  assert(opaque_init->outcnt() > 0, \"should be used\");\n-\n-  \/\/ Second predicate for init + (current stride - initial stride)\n-  \/\/ This is identical to the previous predicate initially but as\n-  \/\/ unrolling proceeds current stride is updated.\n-  Node* init_stride = loop->_head->as_CountedLoop()->stride();\n-  Node* opaque_stride = new OpaqueLoopStrideNode(C, init_stride);\n-  register_new_node(opaque_stride, new_proj);\n-  Node* max_value = new SubINode(opaque_stride, init_stride);\n-  register_new_node(max_value, new_proj);\n-  max_value = new AddINode(opaque_init, max_value);\n-  register_new_node(max_value, new_proj);\n-  \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-  const Type* type_iv = loop->_head->as_CountedLoop()->phi()->bottom_type();\n-  assert(!type_iv->is_int()->is_con(), \"constant indicates one loop iteration for which we bailed out earlier\");\n-  max_value = new CastIINode(new_proj, max_value, type_iv);\n-  register_new_node(max_value, new_proj);\n-\n-  bol = rc_predicate(new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n-                     overflow);\n-  opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  C->add_template_assertion_predicate_opaq(opaque_bol);\n-  register_new_node(opaque_bol, new_proj);\n-  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n-                                         false NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n-  _igvn.replace_input_of(new_proj->in(0), 1, opaque_bol);\n-  assert(max_value->outcnt() > 0, \"should be used\");\n-  assert(assertion_predicate_has_loop_opaque_node(new_proj->in(0)->as_If()), \"unexpected\");\n-\n-  return new_proj;\n+IfTrueNode* PhaseIdealLoop::create_template_assertion_predicate(const int if_opcode, CountedLoopNode* loop_head,\n+                                                                ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                                IfProjNode* new_control, const int scale, Node* offset,\n+                                                                Node* range, Deoptimization::DeoptReason deopt_reason) {\n+\n+  TemplateAssertionPredicateCreator template_assertion_predicate_creator(loop_head, scale, offset, range, this);\n+  return template_assertion_predicate_creator.create_with_uncommon_trap(new_control, parse_predicate_proj, deopt_reason,\n+                                                                        if_opcode);\n+\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":22,"deletions":59,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1464,1 +1464,1 @@\n-                                                                   Node* new_stride, Node* control) {\n+                                                                   Node* new_stride, Node* new_control) {\n@@ -1467,3 +1467,4 @@\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(template_assertion_predicate, new_init,\n-                                                                       new_stride, this);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create(control);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(this);\n+  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(template_assertion_predicate,\n+                                                                                  new_control, new_init, new_stride);\n+\n@@ -1480,1 +1481,1 @@\n-                                                         Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+                                                         Node* control, IdealLoopTree* outer_loop, Node* new_control) {\n@@ -1485,17 +1486,5 @@\n-  Node* proj = predicate->clone();\n-  Node* other_proj = uncommon_proj->clone();\n-  Node* new_iff = iff->clone();\n-  new_iff->set_req(1, new_opaque_node);\n-  proj->set_req(0, new_iff);\n-  other_proj->set_req(0, new_iff);\n-  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n-  register_new_node(frame, C->start());\n-  Node* halt = new HaltNode(other_proj, frame, \"Template Assertion Predicates are always removed before code generation\");\n-  _igvn.add_input_to(C->root(), halt);\n-  new_iff->set_req(0, input_proj);\n-\n-  register_control(new_iff, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, input_proj);\n-  register_control(proj, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, new_iff);\n-  register_control(other_proj, _ltree_root, new_iff);\n-  register_control(halt, _ltree_root, other_proj);\n-  assert(assertion_predicate_has_loop_opaque_node(proj->in(0)->as_If()),\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(this);\n+  IfTrueNode* success_proj =\n+      assertion_predicate_if_creator.create_for_template(new_control, iff->Opcode(), new_opaque_node\n+                                                         NOT_PRODUCT(COMMA iff->assertion_predicate_type()));\n+  assert(assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n@@ -1503,1 +1492,1 @@\n-  return proj;\n+  return success_proj;\n@@ -2735,34 +2724,0 @@\n-\/\/ Same as PhaseIdealLoop::duplicate_predicates() but for range checks\n-\/\/ eliminated by iteration splitting.\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(\n-    IdealLoopTree* loop, Node* ctrl, const int scale_con, Node* offset, Node* limit, jint stride_con, Node* value,\n-    const bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n-  bool overflow = false;\n-  BoolNode* bol = rc_predicate(ctrl, scale_con, offset, value, nullptr, stride_con,\n-                               limit, (stride_con > 0) != (scale_con > 0), overflow);\n-  Node* opaque_assertion_predicate;\n-  if (is_template) {\n-    opaque_assertion_predicate = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  } else {\n-    opaque_assertion_predicate = new OpaqueInitializedAssertionPredicateNode(bol, C);\n-  }\n-  register_new_node(opaque_assertion_predicate, ctrl);\n-  IfNode* new_iff = nullptr;\n-  if (overflow) {\n-    new_iff = new IfNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n-  } else {\n-    new_iff = new RangeCheckNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n-  }\n-  register_control(new_iff, loop->_parent, ctrl);\n-  Node* iffalse = new IfFalseNode(new_iff);\n-  register_control(iffalse, _ltree_root, new_iff);\n-  ProjNode* iftrue = new IfTrueNode(new_iff);\n-  register_control(iftrue, loop->_parent, new_iff);\n-  Node *frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n-  register_new_node(frame, C->start());\n-  Node* halt = new HaltNode(iffalse, frame, \"range check predicate failed which is impossible\");\n-  register_control(halt, _ltree_root, iffalse);\n-  _igvn.add_input_to(C->root(), halt);\n-  return iftrue;\n-}\n-\n@@ -2977,0 +2932,1 @@\n+          InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(this);\n@@ -2980,4 +2936,4 @@\n-            \/\/ Add an Assertion Predicate for that corner case. The final iv is computed from LoopLimit which is the\n-            \/\/ LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip() as\n-            \/\/ well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for the\n-            \/\/ main loop doesn't constant fold after range check elimination but, the array access for the final\n+            \/\/ Add an Initialized Assertion Predicate for that corner case. The final iv is computed from LoopLimit which\n+            \/\/ is the LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip()\n+            \/\/ as well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for\n+            \/\/ the main loop doesn't constant fold after range check elimination but, the array access for the final\n@@ -2986,2 +2942,8 @@\n-            loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                         int_limit, stride_con, final_iv_placeholder, false);\n+            \/\/ Note that we do not need to emit a Template Assertion Predicate to update this predicate. When further\n+            \/\/ splitting this loop, the final IV will still be the same. When unrolling the loop, we will remove a\n+            \/\/ previously added Initialized Assertion Predicate here. But then abs(stride) is greater than 1, and we\n+            \/\/ cannot remove an empty loop with a constant limit when init is not a constant as well. We will use\n+            \/\/ a LoopLimitCheck node that can only be folded if the zero grip guard is also foldable.\n+            loop_entry = initialized_assertion_predicate_creator.create(final_iv_placeholder, loop_entry, stride_con,\n+                                                                        scale_con, int_offset, int_limit NOT_PRODUCT(\n+                                                                        COMMA AssertionPredicateType::FinalIv));\n@@ -2991,5 +2953,0 @@\n-          \/\/ Initialized Assertion Predicate for the value of the initial main-loop.\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, init, false);\n-          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n-\n@@ -2998,3 +2955,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(\n-              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, opaque_init, true\n-              NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+          TemplateAssertionPredicateCreator template_assertion_predicate_creator(cl, scale_con , int_offset, int_limit,\n+                                                                                 this);\n+          loop_entry = template_assertion_predicate_creator.create_with_halt(loop_entry);\n@@ -3003,13 +2960,5 @@\n-          Node* opaque_stride = new OpaqueLoopStrideNode(C, cl->stride());\n-          register_new_node(opaque_stride, loop_entry);\n-          Node* max_value = new SubINode(opaque_stride, cl->stride());\n-          register_new_node(max_value, loop_entry);\n-          max_value = new AddINode(opaque_init, max_value);\n-          register_new_node(max_value, loop_entry);\n-          \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-          max_value = new CastIINode(loop_entry, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n-          register_new_node(max_value, loop_entry);\n-          loop_entry = add_range_check_elimination_assertion_predicate(\n-              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, max_value, true\n-              NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n+          \/\/ Initialized Assertion Predicate for the value of the initial main-loop.\n+          loop_entry = initialized_assertion_predicate_creator.create(init, loop_entry, stride_con, scale_con,\n+                                                                      int_offset, int_limit NOT_PRODUCT(COMMA\n+                                                                      AssertionPredicateType::InitValue));\n+          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -3075,3 +3024,0 @@\n-\n-      C->print_method(PHASE_AFTER_RANGE_CHECK_ELIMINATION, 4, cl);\n-\n@@ -3141,0 +3087,2 @@\n+\n+  C->print_method(PHASE_AFTER_RANGE_CHECK_ELIMINATION, 4, cl);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":35,"deletions":87,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -954,1 +954,1 @@\n-                                           IdealLoopTree* outer_loop, Node* input_proj);\n+                                           IdealLoopTree* outer_loop, Node* new_control);\n@@ -1387,1 +1387,1 @@\n-                                    Invariance& invar, Deoptimization::DeoptReason reason);\n+                                    Invariance& invar, Deoptimization::DeoptReason deopt_reason);\n@@ -1393,4 +1393,4 @@\n-  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n-                                               ParsePredicateSuccessProj* parse_predicate_proj,\n-                                               IfProjNode* upper_bound_proj, int scale, Node* offset, Node* init, Node* limit,\n-                                               jint stride, Node* rng, bool& overflow, Deoptimization::DeoptReason reason);\n+  IfTrueNode* create_template_assertion_predicate(int if_opcode, CountedLoopNode* loop_head,\n+                                                  ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                  IfProjNode* new_control, int scale, Node* offset,\n+                                                  Node* range, Deoptimization::DeoptReason deopt_reason);\n@@ -1398,3 +1398,0 @@\n-  Node* add_range_check_elimination_assertion_predicate(\n-      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n-      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/addnode.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -250,2 +252,2 @@\n-Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_init, Node* new_stride,\n-                                                                            Node* new_ctrl,\n+Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init,\n+                                                                            Node* new_stride,\n@@ -254,1 +256,1 @@\n-  return clone(replace_init_and_stride_strategy, new_ctrl, phase);\n+  return clone(replace_init_and_stride_strategy, new_control, phase);\n@@ -373,6 +375,120 @@\n-InitializedAssertionPredicateCreator::InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init,\n-                                                                           Node* new_stride, PhaseIdealLoop* phase)\n-    : _template_assertion_predicate(template_assertion_predicate),\n-      _new_init(new_init),\n-      _new_stride(new_stride),\n-      _phase(phase) {}\n+\/\/ This class creates the Assertion Predicate expression to be used for a Template or Initialized Assertion Predicate.\n+class AssertionPredicateExpressionCreator : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  const jint _stride;\n+  const int _scale;\n+  Node* const _offset;\n+  Node* const _range;\n+  const bool _upper;\n+\n+ public:\n+  AssertionPredicateExpressionCreator(const int stride, const int scale, Node* offset, Node* range,\n+                                      PhaseIdealLoop* phase)\n+      : _phase(phase),\n+        _stride(stride),\n+        _scale(scale),\n+        _offset(offset),\n+        _range(range),\n+        _upper((_stride > 0) != (_scale > 0)) {} \/\/ Make sure rc_predicate() chooses the \"scale*init + offset\" case.\n+\n+  \/\/ Create the expression for a Template Assertion Predicate with an Opaque4 node.\n+  Opaque4Node* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n+    BoolNode* bool_for_expression =  _phase->rc_predicate(new_control, _scale, _offset, operand, nullptr,\n+                                                          _stride, _range, _upper, does_overflow);\n+    return create_opaque4_node(new_control, bool_for_expression);\n+  }\n+\n+ private:\n+  Opaque4Node* create_opaque4_node(Node* new_control, BoolNode* bool_for_expression) const {\n+    Compile* C = _phase->C;\n+    Opaque4Node* new_expression = new Opaque4Node(C, bool_for_expression, _phase->igvn().intcon(1));\n+    C->add_template_assertion_predicate_opaq(new_expression);\n+    _phase->register_new_node(new_expression, new_control);\n+    return new_expression;\n+  }\n+\n+ public:\n+  \/\/ Create the expression for an Initialized Assertion Predicate with an OpaqueInitializedAssertionPredicate node.\n+  OpaqueInitializedAssertionPredicateNode* create_for_initialized(Node* new_control, Node* operand,\n+                                                                  bool& does_overflow) const {\n+    BoolNode* bool_for_expression = _phase->rc_predicate(new_control, _scale, _offset, operand, nullptr,\n+                                                         _stride, _range, _upper, does_overflow);\n+    return create_opaque_initialized_assertion_predicate_node(new_control, bool_for_expression);\n+  }\n+\n+ private:\n+  OpaqueInitializedAssertionPredicateNode* create_opaque_initialized_assertion_predicate_node(\n+      Node* new_control, BoolNode* bool_for_expression) const {\n+    OpaqueInitializedAssertionPredicateNode* new_expression =\n+        new OpaqueInitializedAssertionPredicateNode(bool_for_expression, _phase->C);\n+    _phase->register_new_node(new_expression, new_control);\n+    return new_expression;\n+  }\n+};\n+\n+\/\/ Creates an If with a success and a fail path with the given assertion_expression. The only difference to\n+\/\/ create_for_initialized() is that we use a template specific Halt message on the fail path.\n+IfTrueNode* AssertionPredicateIfCreator::create_for_template(Node* new_control, const int if_opcode,\n+                                                             Node* assertion_expression NOT_PRODUCT(COMMA\n+                                                             const AssertionPredicateType assertion_predicate_type)) {\n+  const char* halt_message = \"Template Assertion Predicates are always removed before code generation\";\n+  return create(new_control, if_opcode, assertion_expression, halt_message NOT_PRODUCT(COMMA assertion_predicate_type));\n+}\n+\n+\/\/ Creates an If with a success and a fail path with the given assertion_expression. The only difference to\n+\/\/ create_for_template() is that we use a initialized specific Halt message on the fail path.\n+IfTrueNode* AssertionPredicateIfCreator::create_for_initialized(Node* new_control, const int if_opcode,\n+                                                                Node* assertion_expression NOT_PRODUCT(COMMA\n+                                                                const AssertionPredicateType assertion_predicate_type)) {\n+  const char* halt_message = \"Initialized Assertion Predicate cannot fail\";\n+  return create(new_control, if_opcode, assertion_expression, halt_message NOT_PRODUCT(COMMA assertion_predicate_type));\n+}\n+\n+\/\/ Creates the If node for an Assertion Predicate with a success path and a fail path having a Halt node:\n+\/\/\n+\/\/      new_control   assertion_expression\n+\/\/                \\   \/\n+\/\/                 If\n+\/\/               \/    \\\n+\/\/        success     fail path\n+\/\/           proj      with Halt\n+\/\/\n+IfTrueNode* AssertionPredicateIfCreator::create(Node* new_control, const int if_opcode, Node* assertion_expression,\n+                                                const char* halt_message NOT_PRODUCT(COMMA\n+                                                const AssertionPredicateType assertion_predicate_type)) {\n+  assert(assertion_expression->is_Opaque4() || assertion_expression->is_OpaqueInitializedAssertionPredicate(),\n+         \"not a valid assertion expression\");\n+  IdealLoopTree* loop = _phase->get_loop(new_control);\n+  IfNode* if_node = create_if_node(new_control, if_opcode, assertion_expression, loop\n+                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n+  create_fail_path(if_node, loop, halt_message);\n+  return create_success_path(if_node, loop);\n+}\n+\n+IfNode* AssertionPredicateIfCreator::create_if_node(Node* new_control, const int if_opcode, Node* assertion_expression,\n+                                                    IdealLoopTree* loop NOT_PRODUCT(COMMA\n+                                                    const AssertionPredicateType assertion_predicate_type)) {\n+  IfNode* if_node;\n+  if (if_opcode == Op_If) {\n+    if_node = new IfNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN\n+                         NOT_PRODUCT(COMMA assertion_predicate_type));\n+  } else {\n+    assert(if_opcode == Op_RangeCheck, \"must be range check\");\n+    if_node = new RangeCheckNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN\n+                                 NOT_PRODUCT(COMMA assertion_predicate_type));\n+  }\n+  _phase->register_control(if_node, loop, new_control);\n+  return if_node;\n+}\n+\n+IfTrueNode* AssertionPredicateIfCreator::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n+  IfTrueNode* success_proj = new IfTrueNode(if_node);\n+  _phase->register_control(success_proj, loop, if_node);\n+  return success_proj;\n+}\n+\n+void AssertionPredicateIfCreator::create_fail_path(IfNode* if_node, IdealLoopTree* loop, const char* halt_message) {\n+  IfFalseNode* fail_proj = new IfFalseNode(if_node);\n+  _phase->register_control(fail_proj, loop, if_node);\n+  create_halt_node(fail_proj, loop, halt_message);\n+}\n@@ -380,1 +496,103 @@\n-\/\/ Create an Initialized Assertion Predicate at the provided control from the _template_assertion_predicate.\n+void AssertionPredicateIfCreator::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop,\n+                                                   const char* halt_message) {\n+  StartNode* start_node = _phase->C->start();\n+  Node* frame = new ParmNode(start_node, TypeFunc::FramePtr);\n+  _phase->register_new_node(frame, start_node);\n+  Node* halt = new HaltNode(fail_proj, frame, halt_message);\n+  _phase->igvn().add_input_to(_phase->C->root(), halt);\n+  _phase->register_control(halt, loop, fail_proj);\n+}\n+\n+\/\/ Creates an init and last value Template Assertion Predicate connected together from a Parse Predicate with an UCT on\n+\/\/ the failing path. Returns the success projection of the last value Template Assertion Predicate.\n+IfTrueNode* TemplateAssertionPredicateCreator::create_with_uncommon_trap(\n+    Node* new_control, ParsePredicateSuccessProj* parse_predicate_success_proj,\n+    const Deoptimization::DeoptReason deopt_reason, const int if_opcode) {\n+  OpaqueLoopInitNode* opaque_init = create_opaque_init(new_control);\n+  bool does_overflow;\n+  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n+                                                                               does_overflow);\n+  IfTrueNode* template_predicate_success_proj =\n+      create_if_node_with_uncommon_trap(template_assertion_predicate_expression, parse_predicate_success_proj,\n+                                        deopt_reason, if_opcode, does_overflow\n+                                        NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+  template_assertion_predicate_expression = create_for_last_value(template_predicate_success_proj, opaque_init,\n+                                                                  does_overflow);\n+  return create_if_node_with_uncommon_trap(template_assertion_predicate_expression, parse_predicate_success_proj,\n+                                           deopt_reason, if_opcode, does_overflow\n+                                           NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n+}\n+\n+OpaqueLoopInitNode* TemplateAssertionPredicateCreator::create_opaque_init(Node* new_control) {\n+  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->init_trip());\n+  _phase->register_new_node(opaque_init, new_control);\n+  return opaque_init;\n+}\n+\n+Opaque4Node* TemplateAssertionPredicateCreator::create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                                      bool& does_overflow) const {\n+  AssertionPredicateExpressionCreator expression_creator(_loop_head->stride_con(), _scale, _offset, _range, _phase);\n+  return expression_creator.create_for_template(new_control, opaque_init, does_overflow);\n+}\n+\n+IfTrueNode* TemplateAssertionPredicateCreator::create_if_node_with_uncommon_trap(\n+    Opaque4Node* template_assertion_predicate_expression, ParsePredicateSuccessProj* parse_predicate_success_proj,\n+    const Deoptimization::DeoptReason deopt_reason, const int if_opcode, const bool does_overflow\n+    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+  IfTrueNode* success_proj = _phase->create_new_if_for_predicate(parse_predicate_success_proj, nullptr, deopt_reason,\n+                                                                 does_overflow ? Op_If : if_opcode, false\n+                                                                 NOT_PRODUCT(COMMA assertion_predicate_type));\n+  _phase->igvn().replace_input_of(success_proj->in(0), 1, template_assertion_predicate_expression);\n+  return success_proj;\n+}\n+\n+Opaque4Node* TemplateAssertionPredicateCreator::create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                                      bool& does_overflow) const {\n+  Node* last_value = create_last_value(new_control, opaque_init);\n+  AssertionPredicateExpressionCreator expression_creator(_loop_head->stride_con(), _scale, _offset, _range, _phase);\n+  return expression_creator.create_for_template(new_control, last_value, does_overflow);\n+}\n+\n+Node* TemplateAssertionPredicateCreator::create_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init) const {\n+  Node* init_stride = _loop_head->stride();\n+  Node* opaque_stride = new OpaqueLoopStrideNode(_phase->C, init_stride);\n+  _phase->register_new_node(opaque_stride, new_control);\n+  Node* last_value = new SubINode(opaque_stride, init_stride);\n+  _phase->register_new_node(last_value, new_control);\n+  last_value = new AddINode(opaque_init, last_value);\n+  _phase->register_new_node(last_value, new_control);\n+  \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv phi\n+  last_value = new CastIINode(new_control, last_value, _loop_head->phi()->bottom_type());\n+  _phase->register_new_node(last_value, new_control);\n+  return last_value;\n+}\n+\n+IfTrueNode* TemplateAssertionPredicateCreator::create_if_node_with_halt(\n+    Node* new_control, Opaque4Node* template_assertion_predicate_expression, bool does_overflow\n+    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(_phase);\n+  return assertion_predicate_if_creator.create_for_template(new_control, does_overflow ? Op_If : Op_RangeCheck,\n+                                                            template_assertion_predicate_expression\n+                                                            NOT_PRODUCT(COMMA assertion_predicate_type));\n+}\n+\n+\/\/ Creates an init and last value Template Assertion Predicate connected together with a Halt node on the failing path.\n+\/\/ Returns the success projection of the last value Template Assertion Predicate latter.\n+IfTrueNode* TemplateAssertionPredicateCreator::create_with_halt(Node* new_control) {\n+  OpaqueLoopInitNode* opaque_init = create_opaque_init(new_control);\n+  bool does_overflow;\n+  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n+                                                                               does_overflow);\n+  IfTrueNode* template_predicate_success_proj =\n+      create_if_node_with_halt(new_control, template_assertion_predicate_expression, does_overflow\n+                               NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+  template_assertion_predicate_expression = create_for_last_value(template_predicate_success_proj, opaque_init,\n+                                                                  does_overflow);\n+  return create_if_node_with_halt(template_predicate_success_proj, template_assertion_predicate_expression,\n+                                  does_overflow NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n+}\n+\n+InitializedAssertionPredicateCreator::InitializedAssertionPredicateCreator(PhaseIdealLoop* phase)\n+    : _phase(phase) {}\n+\n+\/\/ Create an Initialized Assertion Predicate from the provided template_assertion_predicate at 'new_control'.\n@@ -383,1 +601,1 @@\n-\/\/ - OpaqueLoop*Nodes with _new_init and _new_stride, respectively.\n+\/\/ - OpaqueLoop*Nodes with new_init and _ew_stride, respectively.\n@@ -387,1 +605,1 @@\n-\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/       _new_init    _new_stride\n+\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/        new_init    new_stride\n@@ -393,1 +611,1 @@\n-\/\/             \\                 Opaque4           ======>          control     \\  OpaqueInitializedAssertionPredicate\n+\/\/             \\                 Opaque4           ======>      new_control     \\  OpaqueInitializedAssertionPredicate\n@@ -400,14 +618,3 @@\n-IfTrueNode* InitializedAssertionPredicateCreator::create(Node* control) {\n-  IdealLoopTree* loop = _phase->get_loop(control);\n-  OpaqueInitializedAssertionPredicateNode* assertion_expression = create_assertion_expression(control);\n-  IfNode* if_node = create_if_node(control, assertion_expression, loop);\n-  create_fail_path(if_node, loop);\n-  return create_success_path(if_node, loop);\n-}\n-\n-\/\/ Create a new Assertion Expression to be used as bool input for the Initialized Assertion Predicate IfNode.\n-OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicateCreator::create_assertion_expression(Node* control) {\n-  Opaque4Node* template_opaque = _template_assertion_predicate->in(1)->as_Opaque4();\n-  TemplateAssertionExpression template_assertion_expression(template_opaque);\n-  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(_new_init, _new_stride,\n-                                                                                            control, _phase);\n+IfTrueNode* InitializedAssertionPredicateCreator::create_from_template(IfNode* template_assertion_predicate,\n+                                                                       Node* new_control, Node* new_init,\n+                                                                       Node* new_stride) {\n@@ -415,3 +622,3 @@\n-      new OpaqueInitializedAssertionPredicateNode(tmp_opaque->in(1)->as_Bool(), _phase->C);\n-  _phase->register_new_node(assertion_expression, control);\n-  return assertion_expression;\n+      create_assertion_expression_from_template(template_assertion_predicate, new_control, new_init, new_stride);\n+  return create_control_nodes(new_control, template_assertion_predicate->Opcode(), assertion_expression\n+                              NOT_PRODUCT(COMMA template_assertion_predicate->assertion_predicate_type()));\n@@ -420,10 +627,10 @@\n-IfNode* InitializedAssertionPredicateCreator::create_if_node(Node* control,\n-                                                             OpaqueInitializedAssertionPredicateNode* assertion_expression,\n-                                                             IdealLoopTree* loop) {\n-  const int if_opcode = _template_assertion_predicate->Opcode();\n-  NOT_PRODUCT(const AssertionPredicateType assertion_predicate_type = _template_assertion_predicate->assertion_predicate_type();)\n-  IfNode* if_node = if_opcode == Op_If ?\n-      new IfNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type)) :\n-      new RangeCheckNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type));\n-  _phase->register_control(if_node, loop, control);\n-  return if_node;\n+\/\/ Create a new Initialized Assertion Predicate directly without a template.\n+IfTrueNode* InitializedAssertionPredicateCreator::create(Node* operand, Node* new_control, const jint stride,\n+                                                         const int scale, Node* offset, Node* range NOT_PRODUCT(COMMA\n+                                                         AssertionPredicateType assertion_predicate_type)) {\n+  AssertionPredicateExpressionCreator expression_creator(stride, scale, offset, range, _phase);\n+  bool does_overflow;\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      expression_creator.create_for_initialized(new_control, operand, does_overflow);\n+  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression\n+                              NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -432,4 +639,7 @@\n-IfTrueNode* InitializedAssertionPredicateCreator::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n-  IfTrueNode* success_proj = new IfTrueNode(if_node);\n-  _phase->register_control(success_proj, loop, if_node);\n-  return success_proj;\n+\/\/ Creates the CFG nodes for the Initialized Assertion Predicate.\n+IfTrueNode* InitializedAssertionPredicateCreator::create_control_nodes(\n+    Node* new_control, const int if_opcode, OpaqueInitializedAssertionPredicateNode* assertion_expression\n+    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(_phase);\n+  return assertion_predicate_if_creator.create_for_initialized(new_control, if_opcode, assertion_expression\n+                                                               NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -438,13 +648,15 @@\n-void InitializedAssertionPredicateCreator::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n-  IfFalseNode* fail_proj = new IfFalseNode(if_node);\n-  _phase->register_control(fail_proj, loop, if_node);\n-  create_halt_node(fail_proj, loop);\n-}\n-\n-void InitializedAssertionPredicateCreator::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n-  StartNode* start_node = _phase->C->start();\n-  Node* frame = new ParmNode(start_node, TypeFunc::FramePtr);\n-  _phase->register_new_node(frame, start_node);\n-  Node* halt = new HaltNode(fail_proj, frame, \"Initialized Assertion Predicate cannot fail\");\n-  _phase->igvn().add_input_to(_phase->C->root(), halt);\n-  _phase->register_control(halt, loop, fail_proj);\n+\/\/ Create a new Assertion Expression based from the given template to be used as bool input for the Initialized\n+\/\/ Assertion Predicate IfNode.\n+OpaqueInitializedAssertionPredicateNode*\n+InitializedAssertionPredicateCreator::create_assertion_expression_from_template(IfNode* template_assertion_predicate,\n+                                                                                Node* new_control, Node* new_init,\n+                                                                                Node* new_stride) {\n+  Opaque4Node* template_opaque = template_assertion_predicate->in(1)->as_Opaque4();\n+  TemplateAssertionExpression template_assertion_expression(template_opaque);\n+  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init,\n+                                                                                            new_stride,\n+                                                                                            _phase);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      new OpaqueInitializedAssertionPredicateNode(tmp_opaque->in(1)->as_Bool(), _phase->C);\n+  _phase->register_new_node(assertion_expression, new_control);\n+  return assertion_expression;\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":269,"deletions":57,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -210,1 +210,3 @@\n-  LastValue\n+  LastValue,\n+  \/\/ Used for the Initialized Assertion Predicate emitted during Range Check Elimination for the final IV value.\n+  FinalIv\n@@ -445,2 +447,3 @@\n-  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n+                                                 PhaseIdealLoop* phase);\n@@ -523,1 +526,59 @@\n-\/\/ This class creates a new Initialized Assertion Predicate.\n+\/\/ This class is used to create the actual If node with a success path and a fail path with a Halt node.\n+class AssertionPredicateIfCreator : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  explicit AssertionPredicateIfCreator(PhaseIdealLoop* const phase) : _phase(phase) {}\n+  NONCOPYABLE(AssertionPredicateIfCreator);\n+\n+  IfTrueNode* create_for_initialized(Node* new_control, int if_opcode, Node* assertion_expression\n+                                     NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_for_template(Node* new_control, int if_opcode, Node* assertion_expression\n+                                  NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+ private:\n+  IfTrueNode* create(Node* new_control, int if_opcode, Node* assertion_expression, const char* halt_message\n+                     NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfNode* create_if_node(Node* new_control, int if_opcode, Node* assertion_expression, IdealLoopTree* loop\n+                         NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_success_path(IfNode* if_node, IdealLoopTree* loop);\n+  void create_fail_path(IfNode* if_node, IdealLoopTree* loop, const char* halt_message);\n+  void create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop, const char* halt_message);\n+};\n+\n+\/\/ This class is used to create a Template Assertion Predicate either with an UCT or a Halt Node from scratch.\n+class TemplateAssertionPredicateCreator : public StackObj {\n+  CountedLoopNode* const _loop_head;\n+  const int _scale;\n+  Node* const _offset;\n+  Node* const _range;\n+  PhaseIdealLoop* const _phase;\n+\n+  OpaqueLoopInitNode* create_opaque_init(Node* new_control);\n+  Opaque4Node* create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n+  Opaque4Node* create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n+  Node* create_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init) const;\n+  IfTrueNode* create_if_node_with_uncommon_trap(Opaque4Node* template_assertion_predicate_expression,\n+                                                ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                                Deoptimization::DeoptReason deopt_reason, int if_opcode,\n+                                                bool does_overflow\n+                                                NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_if_node_with_halt(Node* new_control, Opaque4Node* template_assertion_predicate_expression,\n+                                       bool does_overflow\n+                                       NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+\n+ public:\n+  TemplateAssertionPredicateCreator(CountedLoopNode* loop_head, int scale, Node* offset, Node* range,\n+                                    PhaseIdealLoop* phase)\n+      : _loop_head(loop_head),\n+        _scale(scale),\n+        _offset(offset),\n+        _range(range),\n+        _phase(phase) {}\n+  NONCOPYABLE(TemplateAssertionPredicateCreator);\n+\n+  IfTrueNode* create_with_uncommon_trap(Node* new_control, ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                        Deoptimization::DeoptReason deopt_reason, int if_opcode);\n+  IfTrueNode* create_with_halt(Node* new_control);\n+};\n+\n+\/\/ This class creates a new Initialized Assertion Predicate either from a template or from scratch.\n@@ -525,3 +586,0 @@\n-  IfNode* const _template_assertion_predicate;\n-  Node* const _new_init;\n-  Node* const _new_stride;\n@@ -531,2 +589,1 @@\n-  InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                       PhaseIdealLoop* phase);\n+  explicit InitializedAssertionPredicateCreator(PhaseIdealLoop* phase);\n@@ -535,1 +592,4 @@\n-  IfTrueNode* create(Node* control);\n+  IfTrueNode* create_from_template(IfNode* template_assertion_predicate, Node* new_control, Node* new_init,\n+                                   Node* new_stride);\n+  IfTrueNode* create(Node* operand, Node* new_control, jint stride, int scale, Node* offset, Node* range\n+                     NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n@@ -538,5 +598,6 @@\n-  OpaqueInitializedAssertionPredicateNode* create_assertion_expression(Node* control);\n-  IfNode* create_if_node(Node* control, OpaqueInitializedAssertionPredicateNode* assertion_expression, IdealLoopTree* loop);\n-  void create_fail_path(IfNode* if_node, IdealLoopTree* loop);\n-  void create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop);\n-  IfTrueNode* create_success_path(IfNode* if_node, IdealLoopTree* loop);\n+  OpaqueInitializedAssertionPredicateNode* create_assertion_expression_from_template(IfNode* template_assertion_predicate,\n+                                                                                     Node* new_control, Node* new_init,\n+                                                                                     Node* new_stride);\n+  IfTrueNode* create_control_nodes(Node* new_control, int if_opcode,\n+                                   OpaqueInitializedAssertionPredicateNode* assertion_expression\n+                                   NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":76,"deletions":15,"binary":false,"changes":91,"status":"modified"}]}