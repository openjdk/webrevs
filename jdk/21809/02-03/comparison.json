{"files":[{"patch":"@@ -191,0 +191,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -194,0 +200,12 @@\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  \/\/ In compiled code, the stack banging is performed before LR\n+  \/\/ has been saved in the frame.  LR is live, and SP and FP\n+  \/\/ belong to the caller.\n+  intptr_t* fp = os::Linux::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n+  address pc = (address)(uc->uc_mcontext.arm_lr\n+                         - NativeInstruction::instruction_size);\n+  return frame(sp, fp, pc);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}