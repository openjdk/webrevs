{"files":[{"patch":"@@ -84,0 +84,2 @@\n+        @JEP(number=0, title=\"Module Imports\", status=\"Preview\")\n+        MODULE_IMPORTS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -50,0 +52,6 @@\n+    \/**\n+     * {@return true if this is an module import declaration.}\n+     * @since 23\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.MODULE_IMPORTS, reflective=true)\n+    boolean isModule();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ImportTree.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,0 +213,1 @@\n+            case MODULE_IMPORTS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4399,1 +4399,3 @@\n-        for (final JCImport imp : toplevel.getImports()) {\n+        for (final JCImportBase impBase : toplevel.getImports()) {\n+            if (!(impBase instanceof JCImport imp))\n+                continue;\n@@ -4423,2 +4425,3 @@\n-        OUTER: for (JCImport imp : toplevel.getImports()) {\n-            if (!imp.staticImport && TreeInfo.name(imp.qualid) == names.asterisk) {\n+        OUTER: for (JCImportBase impBase : toplevel.getImports()) {\n+            if (impBase instanceof JCImport imp && !imp.staticImport &&\n+                TreeInfo.name(imp.qualid) == names.asterisk) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCModuleImport;\n@@ -413,0 +414,6 @@\n+    @Override\n+    public void visitModuleImport(JCModuleImport tree) {\n+        JCModuleImport that = (JCModuleImport) parameter;\n+        result = scan(tree.module, that.module);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TreeDiffer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import com.sun.tools.javac.code.Directive.ExportsDirective;\n+import com.sun.tools.javac.code.Directive.RequiresDirective;\n@@ -37,1 +39,0 @@\n-import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -43,2 +44,0 @@\n-import com.sun.tools.javac.parser.Parser;\n-import com.sun.tools.javac.parser.ParserFactory;\n@@ -60,1 +59,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -117,2 +115,0 @@\n-    private final ParserFactory parserFactory;\n-    private final Preview preview;\n@@ -146,2 +142,0 @@\n-        parserFactory = ParserFactory.instance(context);\n-        preview = Preview.instance(context);\n@@ -373,3 +367,1 @@\n-                for (JCImport imp : tree.getImports()) {\n-                    doImport(imp);\n-                }\n+                handleImports(tree.getImports());\n@@ -397,0 +389,10 @@\n+        private void handleImports(List<JCImportBase> imports) {\n+            for (JCImportBase imp : imports) {\n+                if (imp instanceof JCModuleImport mimp) {\n+                    doModuleImport(mimp);\n+                } else {\n+                    doImport((JCImport) imp);\n+                }\n+            }\n+        }\n+\n@@ -448,0 +450,51 @@\n+        private void doModuleImport(JCModuleImport tree) {\n+            Name moduleName = TreeInfo.fullName(tree.module);\n+            ModuleSymbol module = syms.getModule(moduleName);\n+\n+            if (module != null) {\n+                if (!env.toplevel.modle.readModules.contains(module)) {\n+                    if (env.toplevel.modle.isUnnamed()) {\n+                        log.error(tree.pos, Errors.ImportModuleDoesNotReadUnnamed(module));\n+                    } else {\n+                        log.error(tree.pos, Errors.ImportModuleDoesNotRead(module,\n+                                                                           env.toplevel.modle));\n+                    }\n+                    \/\/error recovery, make sure the module is completed:\n+                    module.getDirectives();\n+                }\n+\n+                List<ModuleSymbol> todo = List.of(module);\n+                Set<ModuleSymbol> seenModules = new HashSet<>();\n+\n+                while (!todo.isEmpty()) {\n+                    ModuleSymbol currentModule = todo.head;\n+\n+                    todo = todo.tail;\n+\n+                    if (!seenModules.add(currentModule)) {\n+                        continue;\n+                    }\n+\n+                    for (ExportsDirective export : currentModule.exports) {\n+                        if (export.modules != null && !export.modules.contains(env.toplevel.packge.modle)) {\n+                            continue;\n+                        }\n+\n+                        PackageSymbol pkg = export.getPackage();\n+                        JCImport nestedImport = make.at(tree.pos)\n+                                .Import(make.Select(make.QualIdent(pkg), names.asterisk), false);\n+\n+                        doImport(nestedImport);\n+                    }\n+\n+                    for (RequiresDirective requires : currentModule.requires) {\n+                        if (requires.isTransitive()) {\n+                            todo = todo.prepend(requires.module);\n+                        }\n+                    }\n+                }\n+            } else {\n+                log.error(tree.pos, Errors.ImportModuleNotFound(moduleName));\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":65,"deletions":12,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -4134,0 +4134,7 @@\n+        } else if (token.kind == IDENTIFIER && token.name() == names.module &&\n+                   peekToken(TokenKind.IDENTIFIER)) {\n+            checkSourceLevel(Feature.MODULE_IMPORTS);\n+            nextToken();\n+            JCExpression moduleName = qualident(false);\n+            accept(SEMI);\n+            return toP(F.at(pos).ModuleImport(moduleName));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3218,0 +3218,3 @@\n+compiler.misc.feature.module.imports=\\\n+    module imports\n+\n@@ -3528,0 +3531,12 @@\n+# 0: name\n+compiler.err.import.module.not.found=\\\n+    imported module not found: {0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed=\\\n+    unnamed module does not read: {0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read=\\\n+    {1} module does not read: {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+        \/** Module import clauses.\n+         *\/\n+        MODULEIMPORT,\n+\n@@ -588,2 +592,2 @@\n-        public List<JCImport> getImports() {\n-            ListBuffer<JCImport> imports = new ListBuffer<>();\n+        public List<JCImportBase> getImports() {\n+            ListBuffer<JCImportBase> imports = new ListBuffer<>();\n@@ -591,2 +595,2 @@\n-                if (tree.hasTag(IMPORT))\n-                    imports.append((JCImport)tree);\n+                if (tree instanceof JCImportBase imp)\n+                    imports.append(imp);\n@@ -611,1 +615,3 @@\n-                        && !typeDefs.head.hasTag(PACKAGEDEF) && !typeDefs.head.hasTag(IMPORT)) {\n+                        && !typeDefs.head.hasTag(PACKAGEDEF)\n+                        && !typeDefs.head.hasTag(IMPORT)\n+                        && !typeDefs.head.hasTag(MODULEIMPORT)) {\n@@ -664,0 +670,12 @@\n+    public static abstract class JCImportBase extends JCTree implements ImportTree {\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() { return Kind.IMPORT; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n+            return v.visitImport(this, d);\n+        }\n+\n+        public abstract JCTree getQualifiedIdentifier();\n+    }\n+\n@@ -667,1 +685,1 @@\n-    public static class JCImport extends JCTree implements ImportTree {\n+    public static class JCImport extends JCImportBase {\n@@ -682,0 +700,2 @@\n+        public boolean isModule() { return false; }\n+        @DefinedBy(Api.COMPILER_TREE)\n@@ -684,0 +704,25 @@\n+        @Override\n+        public Tag getTag() {\n+            return IMPORT;\n+        }\n+    }\n+\n+    \/**\n+     * A module import clause.\n+     *\/\n+    public static class JCModuleImport extends JCImportBase {\n+        \/** The module name. *\/\n+        public JCExpression module;\n+        protected JCModuleImport(JCExpression module) {\n+            this.module = module;\n+        }\n+        @Override\n+        public void accept(Visitor v) { v.visitModuleImport(this); }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isStatic() { return false; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public boolean isModule() { return true; }\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public JCExpression getQualifiedIdentifier() { return module; }\n+\n@@ -693,1 +738,1 @@\n-            return IMPORT;\n+            return MODULEIMPORT;\n@@ -3483,0 +3528,1 @@\n+        public void visitModuleImport(JCModuleImport that)   { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":53,"deletions":7,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -383,3 +383,2 @@\n-            if (l.head.hasTag(IMPORT)) {\n-                JCImport imp = (JCImport)l.head;\n-                Name name = TreeInfo.name(imp.qualid);\n+            if (l.head instanceof JCImportBase imp) {\n+                Name name = TreeInfo.name(imp.getQualifiedIdentifier());\n@@ -388,1 +387,2 @@\n-                        isUsed(TreeInfo.symbol(imp.qualid), cdef)) {\n+                        imp instanceof JCModuleImport ||\n+                        isUsed(TreeInfo.symbol(imp.getQualifiedIdentifier()), cdef)) {\n@@ -550,0 +550,11 @@\n+    public void visitModuleImport(JCModuleImport tree) {\n+        try {\n+            print(\"import module \");\n+            printExpr(tree.module);\n+            print(';');\n+            println();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -260,3 +260,8 @@\n-        JCImport t = (JCImport) node;\n-        JCFieldAccess qualid = copy(t.qualid, p);\n-        return M.at(t.pos).Import(qualid, t.staticImport);\n+        if (node instanceof JCModuleImport mimp) {\n+            JCExpression module = copy(mimp.module, p);\n+            return M.at(mimp.pos).ModuleImport(module);\n+        } else {\n+            JCImport t = (JCImport) node;\n+            JCFieldAccess qualid = copy(t.qualid, p);\n+            return M.at(t.pos).Import(qualid, t.staticImport);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+                || node instanceof JCModuleImport\n@@ -154,2 +155,8 @@\n-    public JCImport Import(JCFieldAccess qualid, boolean importStatic) {\n-        JCImport tree = new JCImport(qualid, importStatic);\n+    public JCImport Import(JCFieldAccess qualid, boolean staticImport) {\n+        JCImport tree = new JCImport(qualid, staticImport);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCModuleImport ModuleImport(JCExpression moduleName) {\n+        JCModuleImport tree = new JCModuleImport(moduleName);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -341,0 +341,4 @@\n+        boolean hasOption(OptionKind kind) {\n+            return optMap.containsKey(kind);\n+        }\n+\n@@ -473,1 +477,1 @@\n-            if (options.has(argEnablePreview)) {\n+            if (previewEnabled(options)) {\n@@ -493,0 +497,4 @@\n+        boolean previewEnabled(OptionSet options) {\n+            return options.has(argEnablePreview);\n+        }\n+\n@@ -630,1 +638,2 @@\n-                initialStartup = Startup.unpack(packedStartup, new InitMessageHandler());\n+                boolean preview = previewEnabled(options);\n+                initialStartup = Startup.unpack(packedStartup, preview, new InitMessageHandler());\n@@ -2288,1 +2297,2 @@\n-            startup = Startup.defaultStartup(this);\n+            boolean preview = options.hasOption(OptionKind.ENABLE_PREVIEW);\n+            startup = Startup.defaultStartup(preview, this);\n@@ -2305,1 +2315,2 @@\n-            Startup retainedStart = Startup.unpack(retained, this);\n+            boolean preview = options.hasOption(OptionKind.ENABLE_PREVIEW);\n+            Startup retainedStart = Startup.unpack(retained, preview, this);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,1 @@\n+    private static final String PREVIEW_DEFAULT_STARTUP_NAME = \"PREVIEW_DEFAULT\";\n@@ -123,1 +124,4 @@\n-    private static Startup defaultStartup = null;\n+    private static Startup[] defaultStartup = new Startup[] {\n+        null, \/\/standard startup\n+        null  \/\/preview  startup\n+    };\n@@ -169,1 +173,2 @@\n-            if (sue.isBuiltIn && sue.name.equals(DEFAULT_STARTUP_NAME)) {\n+            if (sue.isBuiltIn && (sue.name.equals(DEFAULT_STARTUP_NAME) ||\n+                                  sue.name.equals(PREVIEW_DEFAULT_STARTUP_NAME))) {\n@@ -220,1 +225,1 @@\n-    static Startup unpack(String storedForm, MessageHandler mh) {\n+    static Startup unpack(String storedForm, boolean preview, MessageHandler mh) {\n@@ -258,1 +263,1 @@\n-        return defaultStartup(mh);\n+        return defaultStartup(preview, mh);\n@@ -327,3 +332,5 @@\n-    static Startup defaultStartup(MessageHandler mh) {\n-        if (defaultStartup != null) {\n-            return defaultStartup;\n+    static Startup defaultStartup(boolean preview, MessageHandler mh) {\n+        int idx = preview ? 1 : 0;\n+\n+        if (defaultStartup[idx] != null) {\n+            return defaultStartup[idx];\n@@ -331,0 +338,2 @@\n+        String resourceName = preview ? PREVIEW_DEFAULT_STARTUP_NAME\n+                                      : DEFAULT_STARTUP_NAME;\n@@ -332,3 +341,3 @@\n-            String content = readResource(DEFAULT_STARTUP_NAME);\n-            return defaultStartup = new Startup(\n-                    new StartupEntry(true, DEFAULT_STARTUP_NAME, content));\n+            String content = readResource(resourceName);\n+            return defaultStartup[idx] = new Startup(\n+                    new StartupEntry(true, resourceName, content));\n@@ -336,1 +345,1 @@\n-            mh.errormsg(\"jshell.err.file.not.accessible\", \"jshell\", DEFAULT_STARTUP_NAME, e.getMessage());\n+            mh.errormsg(\"jshell.err.file.not.accessible\", \"jshell\", resourceName, e.getMessage());\n@@ -338,1 +347,1 @@\n-            mh.errormsg(\"jshell.err.file.not.found\", \"jshell\", DEFAULT_STARTUP_NAME);\n+            mh.errormsg(\"jshell.err.file.not.found\", \"jshell\", resourceName);\n@@ -340,1 +349,1 @@\n-            mh.errormsg(\"jshell.err.file.exception\", \"jshell\", DEFAULT_STARTUP_NAME, e);\n+            mh.errormsg(\"jshell.err.file.exception\", \"jshell\", resourceName, e);\n@@ -342,1 +351,1 @@\n-        return defaultStartup = noStartup();\n+        return defaultStartup[idx] = noStartup();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/Startup.java","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+import static jdk.jshell.Snippet.SubKind.MODULE_IMPORT_SUBKIND;\n@@ -99,1 +100,1 @@\n-    private static final Pattern IMPORT_PATTERN = Pattern.compile(\"import\\\\p{javaWhitespace}+(?<static>static\\\\p{javaWhitespace}+)?(?<fullname>[\\\\p{L}\\\\p{N}_\\\\$\\\\.]+\\\\.(?<name>[\\\\p{L}\\\\p{N}_\\\\$]+|\\\\*))\");\n+    private static final Pattern IMPORT_PATTERN = Pattern.compile(\"import\\\\p{javaWhitespace}+(?<module>module\\\\p{javaWhitespace}+)?(?<static>static\\\\p{javaWhitespace}+)?(?<fullname>[\\\\p{L}\\\\p{N}_\\\\$\\\\.]+\\\\.(?<name>[\\\\p{L}\\\\p{N}_\\\\$]+|\\\\*))\");\n@@ -247,0 +248,1 @@\n+        boolean isModule;\n@@ -249,0 +251,1 @@\n+            isModule = mat.group(\"module\") != null;\n@@ -250,1 +253,0 @@\n-            name = mat.group(\"name\");\n@@ -252,0 +254,5 @@\n+            if (isModule) {\n+                name = fullname;\n+            } else {\n+                name = mat.group(\"name\");\n+            }\n@@ -254,0 +261,1 @@\n+            isModule = compileSource.contains(\" module \");\n@@ -262,3 +270,8 @@\n-        SubKind snippetKind = isStar\n-                ? (isStatic ? STATIC_IMPORT_ON_DEMAND_SUBKIND : TYPE_IMPORT_ON_DEMAND_SUBKIND)\n-                : (isStatic ? SINGLE_STATIC_IMPORT_SUBKIND : SINGLE_TYPE_IMPORT_SUBKIND);\n+        SubKind snippetKind;\n+        if (isModule) {\n+            snippetKind = MODULE_IMPORT_SUBKIND;\n+        } else if (isStar) {\n+            snippetKind = isStatic ? STATIC_IMPORT_ON_DEMAND_SUBKIND : TYPE_IMPORT_ON_DEMAND_SUBKIND;\n+        } else {\n+            snippetKind = isStatic ? SINGLE_STATIC_IMPORT_SUBKIND : SINGLE_TYPE_IMPORT_SUBKIND;\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Eval.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -217,0 +218,9 @@\n+        \/**\n+         * Import Module Declaration.\n+         * An import declaration of a module.\n+         * @jls 7.5.5 Import Module Declarations\n+         * @since 23\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.MODULE_IMPORTS, reflective=true)\n+        MODULE_IMPORT_SUBKIND(Kind.IMPORT),\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Snippet.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import module java.base;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/resources\/PREVIEW_DEFAULT.jsh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.lang.reflect.Method;\n@@ -38,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -40,0 +42,1 @@\n+import jdk.jshell.JShell;\n@@ -46,0 +49,1 @@\n+import static jdk.jshell.Snippet.SubKind.MODULE_IMPORT_SUBKIND;\n@@ -171,0 +175,16 @@\n+\n+    public void testImportModule() {\n+        assertImportKeyMatch(\"import module java.base;\", \"java.base\", MODULE_IMPORT_SUBKIND, added(VALID));\n+        assertEval(\"MethodHandle m;\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp(Method m) {\n+        switch (m.getName()) {\n+            case \"testImportModule\" ->\n+                super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+            default ->\n+                super.setUp(bc -> {});\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ImportTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,0 +271,1 @@\n+            case MODULE_IMPORT_SUBKIND:\n","filename":"test\/langtools\/jdk\/jshell\/KullaTesting.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,7 @@\n+    protected void startCheckUserOutput(Consumer<String> checkUserOutput,\n+            String... args) {\n+        runShell(args);\n+        check(userout, checkUserOutput, \"userout\");\n+        check(usererr, null, \"usererr\");\n+    }\n+\n@@ -361,0 +368,11 @@\n+    public void testPreviewEnabled() {\n+        String fn = writeToFile(\"System.out.println(\\\"prefix\\\");\\n\" +\n+                \"System.out.println(MethodHandle.class.getName());\\n\" +\n+                \"System.out.println(\\\"suffix\\\");\\n\" +\n+                \"\/exit\\n\");\n+        startCheckUserOutput(s -> assertEquals(s, \"prefix\\nsuffix\\n\"),\n+                             fn);\n+        startCheckUserOutput(s -> assertEquals(s, \"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n+                             \"--enable-preview\", fn);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/StartOptionTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.function.Consumer;\n@@ -61,0 +62,7 @@\n+    @Override\n+    protected void startCheckUserOutput(Consumer<String> checkUserOutput, String... args) {\n+        runShell(args);\n+        check(cmdout, checkUserOutput, \"userout\");\n+        check(usererr, null, \"usererr\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ToolProviderTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,722 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8328481\n+ * @summary Check behavior of module imports.\n+ * @library \/tools\/lib\n+ * @modules java.logging\n+ *          java.sql\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ImportModule\n+*\/\n+\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskEvent.Kind;\n+import com.sun.source.util.TaskListener;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ImportModule extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ImportModule().runTests();\n+    }\n+\n+    ImportModule() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testImportJavaBase(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                              public static void main(String... args) {\n+                                  List<String> l = new ArrayList<>();\n+                                  System.out.println(l.getClass().getName());\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        {\/\/with --release:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"test.Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+\n+        {\/\/with --source:\n+            new JavacTask(tb)\n+                .options(\"--enable-preview\", \"--source\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+            var out = new JavaTask(tb)\n+                    .classpath(classes.toString())\n+                    .className(\"test.Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            var expectedOut = List.of(\"java.util.ArrayList\");\n+\n+            if (!Objects.equals(expectedOut, out)) {\n+                throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                          \", actual: \" + out);\n+\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySourceLevelCheck(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--release\", \"21\", \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testConflicts(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          public class Test {\n+                              Logger l;\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:5:5: compiler.err.ref.ambiguous: Logger, kindname.interface, java.lang.System.Logger, java.lang.System, kindname.class, java.util.logging.Logger, java.util.logging\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          import java.lang.System.Logger;\n+                          public class Test {\n+                              Logger l;\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          import java.util.logging.Logger;\n+                          public class Test {\n+                              Logger l;\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.logging;\n+                          import java.lang.System.*;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          import module java.sql;\n+                          public class Test {\n+                              Date d;\n+                          }\n+                          \"\"\");\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:5:5: compiler.err.ref.ambiguous: Date, kindname.class, java.sql.Date, java.sql, kindname.class, java.util.Date, java.util\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          import module java.sql;\n+                          import java.util.Date;\n+                          public class Test {\n+                              Date d;\n+                          }\n+                          \"\"\");\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testNoQualifiedExports(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+\n+        Path lib = current.resolve(\"lib\");\n+        Path libSrc = lib.resolve(\"src\");\n+        Path libClasses = lib.resolve(\"classes\");\n+        tb.writeJavaFiles(libSrc,\n+                          \"\"\"\n+                          module lib {\n+                              exports api;\n+                              exports impl to use;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api;\n+                          public class Api {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl;\n+                          public class Impl {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+            .outdir(libClasses)\n+            .files(tb.findJavaFiles(libSrc))\n+            .run()\n+            .writeAll();\n+\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module lib;\n+                          public class Test {\n+                              public static void main(String... args) {\n+                                  Api a;\n+                                  Impl i;\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-p\", libClasses.toString(),\n+                             \"--add-modules\", \"lib\",\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:6:9: compiler.err.cant.resolve.location: kindname.class, Impl, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-p\", libClasses.toString(),\n+                             \"-XDdev\",\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:1: compiler.err.import.module.does.not.read.unnamed: lib\",\n+                \"Test.java:6:9: compiler.err.cant.resolve.location: kindname.class, Impl, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module test.module {\n+                          }\n+                          \"\"\");\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"-p\", libClasses.toString(),\n+                             \"-XDdev\",\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test.java:2:1: compiler.err.import.module.does.not.read: lib, test.module\",\n+                \"Test.java:6:9: compiler.err.cant.resolve.location: kindname.class, Impl, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"2 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testTransitiveDependencies(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path lib = current.resolve(\"lib\");\n+        Path libSrc = lib.resolve(\"src\");\n+        Path libM1 = libSrc.resolve(\"m1\");\n+        tb.writeJavaFiles(libM1,\n+                          \"\"\"\n+                          module m1 {\n+                              requires transitive m2;\n+                              exports api1;\n+                              exports api2 to test;\n+                              exports api3 to m3;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api1;\n+                          public class Api1 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api2;\n+                          public class Api2 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api3;\n+                          public class Api3 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl1;\n+                          public class Impl1 {\n+                          }\n+                          \"\"\");\n+\n+        Path libM2 = libSrc.resolve(\"m2\");\n+        tb.writeJavaFiles(libM2,\n+                          \"\"\"\n+                          module m2 {\n+                              exports api4;\n+                              exports api5 to test;\n+                              exports api6 to m3;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api4;\n+                          public class Api4 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api5;\n+                          public class Api5 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package api6;\n+                          public class Api6 {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package impl2;\n+                          public class Impl2 {\n+                          }\n+                          \"\"\");\n+\n+        Path libClasses = lib.resolve(\"classes\");\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                     \"--module-source-path\", libSrc.toString(),\n+                     \"-XDrawDiagnostics\")\n+            .outdir(libClasses)\n+            .files(tb.findJavaFiles(libSrc))\n+            .run()\n+            .writeAll();\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module test {\n+                              requires m1;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          import module m1;\n+                          public class Test1 {\n+                              Api1 a1;\n+                              Api2 a2;\n+                              Api3 a3;\n+                              Impl1 i1;\n+                              Api4 a4;\n+                              Api5 a5;\n+                              Api6 a6;\n+                              Impl2 i2;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          import module m2;\n+                          public class Test2 {\n+                              Api1 a1;\n+                              Api2 a2;\n+                              Api3 a3;\n+                              Impl1 i1;\n+                              Api4 a4;\n+                              Api5 a5;\n+                              Api6 a6;\n+                              Impl2 i2;\n+                          }\n+                          \"\"\");\n+\n+        Path classes = current.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors;\n+        List<String> expectedErrors;\n+\n+        actualErrors =\n+                new JavacTask(tb)\n+                    .options(\"--enable-preview\", \"--release\", SOURCE_VERSION,\n+                             \"--module-path\", libClasses.toString(),\n+                             \"-XDrawDiagnostics\")\n+                    .outdir(classes)\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        expectedErrors = List.of(\n+                \"Test1.java:6:5: compiler.err.cant.resolve.location: kindname.class, Api3, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test1.java:7:5: compiler.err.cant.resolve.location: kindname.class, Impl1, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test1.java:10:5: compiler.err.cant.resolve.location: kindname.class, Api6, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test1.java:11:5: compiler.err.cant.resolve.location: kindname.class, Impl2, , , (compiler.misc.location: kindname.class, test.Test1, null)\",\n+                \"Test2.java:4:5: compiler.err.cant.resolve.location: kindname.class, Api1, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:5:5: compiler.err.cant.resolve.location: kindname.class, Api2, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:6:5: compiler.err.cant.resolve.location: kindname.class, Api3, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:7:5: compiler.err.cant.resolve.location: kindname.class, Impl1, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:10:5: compiler.err.cant.resolve.location: kindname.class, Api6, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"Test2.java:11:5: compiler.err.cant.resolve.location: kindname.class, Impl2, , , (compiler.misc.location: kindname.class, test.Test2, null)\",\n+                \"- compiler.note.preview.plural: DEFAULT\",\n+                \"- compiler.note.preview.recompile\",\n+                \"10 errors\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testModel(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+        List<String> kinds = new ArrayList<>();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .callback(task -> {\n+                task.addTaskListener(new TaskListener() {\n+                    @Override\n+                    public void finished(TaskEvent e) {\n+                        if (e.getKind() == Kind.ANALYZE) {\n+                            for (Tree t : e.getCompilationUnit().getTypeDecls()) {\n+                                kinds.add(t.getKind().name());\n+                            }\n+                        }\n+                    }\n+                });\n+            })\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        List<String> expectedKinds = List.of(\n+            \"CLASS\"\n+        );\n+\n+        if (!Objects.equals(expectedKinds, kinds)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedKinds +\n+                                      \", actual: \" + kinds);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testModelDisambiguation(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module.*;\n+                          import module.ModuleClass;\n+                          import module.module.*;\n+                          import module.module.ModuleModuleClass;\n+                          public class Test {\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package module;\n+                          public class ModuleClass{\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package module.module;\n+                          public class ModuleModuleClass {\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+        List<String> kinds = new ArrayList<>();\n+\n+        new JavacTask(tb)\n+            .options(\"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":722,"deletions":0,"binary":false,"changes":722,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.module.imports\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: --release ${jdk.version} --enable-preview -Xlint:preview\n+\n+import module java.base;\n+\n+public class ImportModule {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModule.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.import.module.does.not.read\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --release ${jdk.version} --enable-preview\n+module m {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleDoesNotRead\/module-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -24,3 +24,3 @@\n-module net.foo {\n-    requires jdk.jfr;\n-}\n+import module java.compiler;\n+\n+public class Test {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleDoesNotRead\/test\/Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/src\/net.foo\/module-info.java","status":"copied"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.import.module.does.not.read.unnamed\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --release ${jdk.version} --enable-preview --limit-modules java.base\n+\n+import module java.compiler;\n+\n+public class ImportModuleDoesNotReadUnnamed {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleDoesNotReadUnnamed.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.import.module.not.found\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ options: --release ${jdk.version} --enable-preview\n+\n+import module unknown;\n+\n+public class ImportModuleNotFound {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImportModuleNotFound.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -750,0 +750,2 @@\n+        private final static Pattern importModulePattern =\n+                Pattern.compile(\"import\\\\s+module\\\\s+(((?:\\\\w+\\\\.)*)\\\\w+);\");\n@@ -764,9 +766,4 @@\n-            StringBuilder sb = new StringBuilder();\n-            Matcher matcher = commentPattern.matcher(source);\n-            int start = 0;\n-            while (matcher.find()) {\n-                sb.append(source, start, matcher.start());\n-                start = matcher.end();\n-            }\n-            sb.append(source.substring(start));\n-            source = sb.toString();\n+            source = removeMatchingSpans(source, commentPattern);\n+            source = removeMatchingSpans(source, importModulePattern);\n+\n+            Matcher matcher;\n@@ -798,0 +795,14 @@\n+\n+        static String removeMatchingSpans(String source, Pattern toRemove) {\n+            StringBuilder sb = new StringBuilder();\n+            Matcher matcher = toRemove.matcher(source);\n+            int start = 0;\n+\n+            while (matcher.find()) {\n+                sb.append(source, start, matcher.start());\n+                start = matcher.end();\n+            }\n+\n+            sb.append(source.substring(start));\n+            return sb.toString();\n+        }\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"}]}