{"files":[{"patch":"@@ -4309,0 +4309,14 @@\n+void Assembler::vmovmskps(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovmskpd(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1777,0 +1777,2 @@\n+  void vmovmskps(Register dst, XMMRegister src, int vec_enc);\n+  void vmovmskpd(Register dst, XMMRegister src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4063,12 +4063,1 @@\n-void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, KRegister mask,\n-                                              Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n-  if(VM_Version::supports_avx512bw()) {\n-    kmovql(tmp, mask);\n-  } else {\n-    assert(masklen <= 16, \"\");\n-    kmovwl(tmp, mask);\n-  }\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n-  }\n+void C2_MacroAssembler::vector_mask_operation_helper(int opc, Register dst, Register tmp, int masklen) {\n@@ -4080,3 +4069,9 @@\n-      mov64(dst, -1);\n-      bsrq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (VM_Version::supports_lzcnt()) {\n+        lzcntq(tmp, tmp);\n+        movl(dst, 63);\n+        subl(dst, tmp);\n+      } else {\n+        movl(dst, -1);\n+        bsrq(tmp, tmp);\n+        cmov32(Assembler::notZero, dst, tmp);\n+      }\n@@ -4085,3 +4080,28 @@\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (VM_Version::supports_bmi1()) {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          tzcntl(dst, tmp);\n+        } else if (masklen == 32) {\n+          tzcntl(dst, tmp);\n+        } else {\n+          assert(masklen == 64, \"\");\n+          tzcntq(dst, tmp);\n+        }\n+      } else {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          bsfl(dst, tmp);\n+        } else {\n+          assert(masklen == 32 || masklen == 64, \"\");\n+          movl(dst, masklen);\n+          if (masklen == 32)  {\n+            bsfl(tmp, tmp);\n+          } else {\n+            bsfq(tmp, tmp);\n+          }\n+          cmov32(Assembler::notZero, dst, tmp);\n+        }\n+      }\n+      break;\n+    case Op_VectorMaskToLong:\n+      assert(dst == tmp, \"Dst and tmp should be the same for toLong operations\");\n@@ -4093,9 +4113,9 @@\n-void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n-                                              XMMRegister xtmp1, Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n-  assert(VM_Version::supports_avx(), \"\");\n-  vpxor(xtmp, xtmp, xtmp, vec_enc);\n-  vpsubb(xtmp, xtmp, mask, vec_enc);\n-  vpmovmskb(tmp, xtmp, vec_enc);\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, KRegister mask, Register tmp,\n+                                              int masklen, int masksize, int vec_enc) {\n+  assert(VM_Version::supports_popcnt(), \"\");\n+\n+  if(VM_Version::supports_avx512bw()) {\n+    kmovql(tmp, mask);\n+  } else {\n+    assert(masklen <= 16, \"\");\n+    kmovwl(tmp, mask);\n@@ -4103,3 +4123,24 @@\n-  switch(opc) {\n-    case Op_VectorMaskTrueCount:\n-      popcntq(dst, tmp);\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (masksize < 16 && opc != Op_VectorMaskFirstTrue) {\n+    andq(tmp, (1 << masklen) - 1);\n+  }\n+\n+  vector_mask_operation_helper(opc, dst, tmp, masklen);\n+}\n+\n+void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                                              Register tmp, int masklen, BasicType bt, int vec_enc) {\n+  assert(vec_enc == AVX_128bit && VM_Version::supports_avx() ||\n+         vec_enc == AVX_256bit && (VM_Version::supports_avx2() || type2aelembytes(bt) >= 4), \"\");\n+  assert(VM_Version::supports_popcnt(), \"\");\n+\n+  bool need_clip = false;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      \/\/ While masks of other types contain 0, -1; boolean masks contain lane values of 0, 1\n+      vpxor(xtmp, xtmp, xtmp, vec_enc);\n+      vpsubb(xtmp, xtmp, mask, vec_enc);\n+      vpmovmskb(tmp, xtmp, vec_enc);\n+      need_clip = masklen < 16;\n@@ -4107,4 +4148,3 @@\n-    case Op_VectorMaskLastTrue:\n-      mov64(dst, -1);\n-      bsrq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+    case T_BYTE:\n+      vpmovmskb(tmp, mask, vec_enc);\n+      need_clip = masklen < 16;\n@@ -4112,4 +4152,7 @@\n-    case Op_VectorMaskFirstTrue:\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+    case T_SHORT:\n+      vpacksswb(xtmp, mask, mask, vec_enc);\n+      if (masklen >= 16) {\n+        vpermpd(xtmp, xtmp, 8, vec_enc);\n+      }\n+      vpmovmskb(tmp, xtmp, Assembler::AVX_128bit);\n+      need_clip = masklen < 16;\n@@ -4117,1 +4160,11 @@\n-    default: assert(false, \"Unhandled mask operation\");\n+    case T_INT:\n+    case T_FLOAT:\n+      vmovmskps(tmp, mask, vec_enc);\n+      need_clip = masklen < 4;\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmovmskpd(tmp, mask, vec_enc);\n+      need_clip = masklen < 2;\n+      break;\n+    default: assert(false, \"Unhandled type, %s\", type2name(bt));\n@@ -4119,0 +4172,9 @@\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (need_clip && opc != Op_VectorMaskFirstTrue) {\n+    \/\/ need_clip implies masklen < 32\n+    andq(tmp, (1 << masklen) - 1);\n+  }\n+\n+  vector_mask_operation_helper(opc, dst, tmp, masklen);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":101,"deletions":39,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -227,0 +227,2 @@\n+  void vector_mask_operation_helper(int opc, Register dst, Register tmp, int masklen);\n+\n@@ -229,2 +231,2 @@\n-  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp, XMMRegister xtmp1,\n-                             Register tmp, int masklen, int masksize, int vec_enc);\n+  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                             Register tmp, int masklen, BasicType bt, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8650,1 +8650,1 @@\n-    int mask_len = Matcher::vector_length(this, $mask);\n+    int opcode = this->ideal_Opcode();\n@@ -8652,8 +8652,1 @@\n-    if (VM_Version::supports_avx512vlbw()) {\n-      __ kmovql($dst$$Register, $mask$$KRegister);\n-    } else {\n-      assert(mask_len <= 16, \"\");\n-      __ kmovwl($dst$$Register, $mask$$KRegister);\n-    }\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8661,3 +8654,3 @@\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             $dst$$Register, mask_len, mask_size, vlen_enc);\n@@ -8668,3 +8661,2 @@\n-instruct vmask_tolong_avx(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n-  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL &&\n-            n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+instruct vmask_tolong_bool(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL);\n@@ -8672,1 +8664,1 @@\n-  format %{ \"vector_tolong_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  format %{ \"vector_tolong_bool $dst, $mask \\t! using $xtmp as TEMP\" %}\n@@ -8675,0 +8667,2 @@\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n@@ -8676,0 +8670,14 @@\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_tolong_avx(rRegL dst, vec mask, immI size, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskToLong (VectorStoreMask mask size)));\n+  format %{ \"vector_tolong_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP xtmp, KILL cr);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n@@ -8677,0 +8685,1 @@\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8678,9 +8687,2 @@\n-    __ vpxor($xtmp$$XMMRegister, $xtmp$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n-    __ vpsubb($xtmp$$XMMRegister, $xtmp$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n-    __ vpmovmskb($dst$$Register, $xtmp$$XMMRegister, vlen_enc);\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n-    int mask_size = mask_len * type2aelembytes(mbt);\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n@@ -8702,2 +8704,2 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $tmp$$Register,\n-                             mask_len, mask_size, vlen_enc);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             $tmp$$Register, mask_len, mask_size, vlen_enc);\n@@ -8708,1 +8710,1 @@\n-instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_truecount_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8711,2 +8713,18 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_truecount_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8717,1 +8735,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8720,1 +8737,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n@@ -8737,2 +8754,2 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $tmp$$Register, mask_len,\n-                             mask_size, vlen_enc);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             $tmp$$Register, mask_len, mask_size, vlen_enc);\n@@ -8743,1 +8760,1 @@\n-instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_first_or_last_true_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8747,2 +8764,19 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskFirstTrue (VectorStoreMask mask size)));\n+  match(Set dst (VectorMaskLastTrue (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8753,1 +8787,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8756,1 +8789,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":72,"deletions":39,"binary":false,"changes":111,"status":"modified"}]}