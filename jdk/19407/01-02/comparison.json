{"files":[{"patch":"@@ -7238,1 +7238,1 @@\n-  predicate(!VM_Version::is_knights_family() || Matcher::vector_element_basic_type(n) != T_DOUBLE);\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_DOUBLE);\n@@ -7250,1 +7250,1 @@\n-  predicate(VM_Version::is_knights_family() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -353,0 +353,1 @@\n+  Node* normalize_indexes(Node* index_vec, int num_elem, BasicType type_bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -514,0 +514,20 @@\n+Node* LibraryCallKit::normalize_indexes(Node* index_vec, int num_elem, BasicType elem_bt) {\n+  const TypeVect * vt  = TypeVect::make(elem_bt, num_elem);\n+  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n+\n+  Node* mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node* bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+\n+  BoolTest::mask pred = BoolTest::ugt;\n+  ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(pred));\n+  Node* lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n+  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n+  const TypeVect* vmask_type = TypeVect::makemask(type_bt, num_elem);\n+  Node*  mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n+\n+  \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n+  index_vec = gvn().transform(VectorNode::make(Op_AndV, index_vec, bcast_mod, vt));\n+  Node* biased_val = gvn().transform(VectorNode::make(Op_SubVB, index_vec, bcast_lane_cnt, vt));\n+  return gvn().transform(new VectorBlendNode(biased_val, index_vec, mask));\n+}\n+\n@@ -601,10 +621,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ugt));\n-    Node * lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n-    Node * bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-    const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n-    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ugt, bcast_lane_cnt, res, pred_node, vmask_type));\n-\n-    \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n-    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n-    Node * biased_val = gvn().transform(VectorNode::make(Op_SubVB, res, bcast_lane_cnt, vt));\n-    res = gvn().transform(new VectorBlendNode(biased_val, res, mask));\n+     res = normalize_indexes(res, num_elem, elem_bt);\n@@ -2386,0 +2397,4 @@\n+  if (is_vector_shuffle(vbox_klass_to)) {\n+     op = normalize_indexes(op, num_elem_to, elem_bt_to);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8332119\n+* @summary Incorrect IllegalArgumentException for C2 compiled permute kernel\n+* @modules jdk.incubator.vector\n+* @requires vm.compiler2.enabled\n+* @library \/test\/lib \/\n+* @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbatch -XX:-TieredCompilation -XX:CompileOnly=TestTwoVectorPermute::micro compiler.vectorapi.TestTwoVectorPermute\n+* @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbatch -XX:-TieredCompilation compiler.vectorapi.TestTwoVectorPermute\n+*\/\n+package compiler.vectorapi;\n+\n+\n+import jdk.incubator.vector.*;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+public class TestTwoVectorPermute {\n+   public static final VectorSpecies<Float> FSP = FloatVector.SPECIES_256;\n+\n+   public static void validate(float [] res, float [] shuf, float [] src1, float [] src2) {\n+       for (int i = 0; i < res.length; i++) {\n+           float expected = Float.NaN;\n+           \/\/ Exceptional index.\n+           if (shuf[i] < 0 || shuf[i] >= FSP.length()) {\n+               int wrapped_index = ((int)shuf[i] & (FSP.length() - 1));\n+               if (Integer.compareUnsigned((int)shuf[i], FSP.length()) > 0) {\n+                   wrapped_index -= FSP.length();\n+               }\n+               wrapped_index = wrapped_index < 0 ? wrapped_index + FSP.length() : wrapped_index;\n+               expected = src2[wrapped_index];\n+           } else {\n+               expected = src1[(int)shuf[i]];\n+           }\n+           if (res[i] != expected) {\n+              throw new AssertionError(\"Result mismatch at \" + i + \" index, (actual = \" + res[i] + \") != ( expected \" +   expected + \" )\");\n+           }\n+       }\n+   }\n+\n+   public static void micro(float [] res, float [] shuf, float [] src1, float [] src2) {\n+       VectorShuffle<Float> vshuf = FloatVector.fromArray(FSP, shuf, 0).toShuffle();\n+       VectorShuffle<Float> vshuf_wrapped = vshuf.wrapIndexes();\n+       FloatVector.fromArray(FSP, src1, 0)\n+         .rearrange(vshuf_wrapped)\n+         .blend(FloatVector.fromArray(FSP, src2, 0)\n+                           .rearrange(vshuf_wrapped),\n+                           vshuf.laneIsValid().not())\n+         .intoArray(res, 0);\n+   }\n+\n+   public static void main(String [] args) {\n+       float [] res  = new float[FSP.length()];\n+       float [] shuf = new float[FSP.length()];\n+       float [] src1 = new float[FSP.length()];\n+       float [] src2 = new float[FSP.length()];\n+\n+       for (int i = 0; i < FSP.length(); i++) {\n+           shuf[i] = i * 2;\n+       }\n+       for (int i = 0; i < FSP.length(); i++) {\n+           src1[i] = i;\n+           src2[i] = i + FSP.length();\n+       }\n+       for (int i = 0; i < 10000; i++) {\n+           micro(res, shuf, src1, src2);\n+       }\n+       validate(res, shuf, src1, src2);\n+       for (int i = 0; i < FSP.length(); i++) {\n+           shuf[i] = -i * 2;\n+       }\n+       for (int i = 0; i < 10000; i++) {\n+           micro(res, shuf, src1, src2);\n+       }\n+       validate(res, shuf, src1, src2);\n+       System.out.println(\"PASSED\");\n+   }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestTwoVectorPermute.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}