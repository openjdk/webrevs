{"files":[{"patch":"@@ -61,1 +61,7 @@\n-        modificationMap.put(name + signature, new Method(methodId, Modification.valueOf(modification), className + \"::\" + name));\n+        Method method = new Method(\n+            methodId,\n+            Modification.valueOf(modification),\n+            name.equals(\"<init>\"),\n+            className + \"::\" + name\n+        );\n+        modificationMap.put(name + signature, method);\n@@ -74,1 +80,1 @@\n-                if (modifyClassElement(classBuilder, ce)) {\n+                if (modifyClassElement(classModel, classBuilder, ce)) {\n@@ -96,1 +102,1 @@\n-    private boolean modifyClassElement(ClassBuilder classBuilder, ClassElement ce) {\n+    private boolean modifyClassElement(ClassModel classModel, ClassBuilder classBuilder, ClassElement ce) {\n@@ -105,1 +111,1 @@\n-                    return modifyMethod(classBuilder, mm, tm);\n+                    return modifyMethod(classModel, classBuilder, mm, tm);\n@@ -112,2 +118,2 @@\n-    private boolean modifyMethod(ClassBuilder classBuilder, MethodModel m, Method method) {\n-        var code = m.code();\n+    private boolean modifyMethod(ClassModel classModel, ClassBuilder classBuilder, MethodModel methodModel, Method method) {\n+        var code = methodModel.code();\n@@ -121,1 +127,1 @@\n-                () -> MethodTransform.transformingCode(new Transform(method))\n+                () -> MethodTransform.transformingCode(new Transform(classModel, code.get(), method))\n@@ -123,1 +129,1 @@\n-            classBuilder.transformMethod(m, s);\n+            classBuilder.transformMethod(methodModel, s);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Instrumentation.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-record Method(long methodId, Modification modification, String name) {\n+record Method(long methodId, Modification modification, boolean constructor, String name) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Method.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.CodeModel;\n@@ -30,0 +32,1 @@\n+import java.lang.classfile.Label;\n@@ -31,0 +34,1 @@\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -34,0 +38,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -46,0 +52,4 @@\n+    private static class TryBlock {\n+        Label start;\n+        Label end;\n+    }\n@@ -52,0 +62,3 @@\n+    private final List<TryBlock> tryBlocks = new ArrayList<>();\n+    private final boolean simplifiedInstrumentation;\n+    private final ClassModel classModel;\n@@ -55,1 +68,1 @@\n-    Transform(Method method) {\n+    Transform(ClassModel classModel, CodeModel model, Method method) {\n@@ -57,0 +70,60 @@\n+        this.classModel = classModel;\n+        \/\/ The JVMS (not the JLS) allows multiple mutually exclusive super\/this.<init>\n+        \/\/ invocations in a constructor body as long as only one lies on any given\n+        \/\/ execution path. For example, this is valid bytecode:\n+        \/\/\n+        \/\/ Foo(boolean value) {\n+        \/\/   if (value) {\n+        \/\/     staticMethodThatMayThrow();\n+        \/\/     super();\n+        \/\/   } else {\n+        \/\/     try {\n+        \/\/       if (value == 0) {\n+        \/\/         throw new Exception(\"\");\n+        \/\/       }\n+        \/\/     } catch (Throwable t) {\n+        \/\/       throw t;\n+        \/\/     }\n+        \/\/     super();\n+        \/\/   }\n+        \/\/ }\n+        \/\/\n+        \/\/ If such a method is found, instrumentation falls back to instrumenting only\n+        \/\/ RET and ATHROW. This can cause exceptions to be missed or counted twice.\n+        \/\/\n+        \/\/ An effect of this heuristic is that constructors like the one below\n+        \/\/ will also trigger simplified instrumentation.\n+        \/\/\n+        \/\/ class Bar {\n+        \/\/ }\n+        \/\/\n+        \/\/ class Foo extends Bar {\n+        \/\/   Foo() {\n+        \/\/     new Bar();\n+        \/\/   }\n+        \/\/ }\n+        \/\/\n+        \/\/ java.lang.Object::<init> with zero constructor invocations should use simplified instrumentation\n+        this.simplifiedInstrumentation = method.constructor() && constructorInvocations(model.elementList()) != 1;\n+    }\n+\n+    private int constructorInvocations(List<CodeElement> elementList) {\n+        int count = 0;\n+        for (CodeElement e : elementList) {\n+            if (isConstructorInvocation(e)) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private boolean isConstructorInvocation(CodeElement element) {\n+        if (element instanceof InvokeInstruction inv && inv.name().equalsString(\"<init>\")) {\n+            if (classModel.thisClass().equals(inv.owner())) {\n+                return true;\n+            }\n+            if (classModel.superclass().isPresent()) {\n+                return classModel.superclass().get().equals(inv.owner());\n+            }\n+        }\n+        return false;\n@@ -60,1 +133,57 @@\n-    public final void accept(CodeBuilder builder, CodeElement element) {\n+    public void accept(CodeBuilder builder, CodeElement element) {\n+        if (simplifiedInstrumentation) {\n+            acceptSimplifiedInstrumentation(builder, element);\n+            return;\n+        }\n+        if (method.constructor()) {\n+            acceptConstructor(builder, element, isConstructorInvocation(element));\n+        } else {\n+            acceptMethod(builder, element);\n+        }\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder builder) {\n+        endTryBlock(builder);\n+        for (TryBlock block : tryBlocks) {\n+            addCatchHandler(block, builder);\n+        }\n+    }\n+\n+    private void acceptConstructor(CodeBuilder builder, CodeElement element, boolean isConstructorInvocation) {\n+        if (timestampSlot == -1) {\n+            timestampSlot = invokeTimestamp(builder);\n+            builder.lstore(timestampSlot);\n+            if (!isConstructorInvocation) {\n+                beginTryBlock(builder);\n+            }\n+        }\n+        if (isConstructorInvocation) {\n+            endTryBlock(builder);\n+            builder.with(element);\n+            beginTryBlock(builder);\n+            return;\n+        }\n+        if (element instanceof ReturnInstruction) {\n+            addTracing(builder);\n+        }\n+        builder.with(element);\n+    }\n+\n+    private void endTryBlock(CodeBuilder builder) {\n+        if (tryBlocks.isEmpty()) {\n+            return;\n+        }\n+        TryBlock last = tryBlocks.getLast();\n+        if (last.end == null) {\n+            last.end = builder.newBoundLabel();\n+        }\n+    }\n+\n+    private void beginTryBlock(CodeBuilder builder) {\n+        TryBlock block = new TryBlock();\n+        block.start = builder.newBoundLabel();\n+        tryBlocks.add(block);\n+    }\n+\n+    private void acceptSimplifiedInstrumentation(CodeBuilder builder, CodeElement element) {\n@@ -66,11 +195,36 @@\n-            builder.lload(timestampSlot);\n-            builder.ldc(method.methodId());\n-            Modification modification = method.modification();\n-            boolean objectInit = method.name().equals(\"java.lang.Object::<init>\");\n-            String suffix = objectInit ? \"ObjectInit\" : \"\";\n-            if (modification.timing()) {\n-                if (modification.tracing()) {\n-                    invokeTraceTiming(builder, suffix);\n-                } else {\n-                    invokeTiming(builder, suffix);\n-                }\n+            addTracing(builder);\n+        }\n+        builder.with(element);\n+    }\n+\n+    private void acceptMethod(CodeBuilder builder, CodeElement element) {\n+        if (timestampSlot == -1) {\n+            timestampSlot = invokeTimestamp(builder);\n+            builder.lstore(timestampSlot);\n+            beginTryBlock(builder);\n+        }\n+        if (element instanceof ReturnInstruction) {\n+            addTracing(builder);\n+        }\n+        builder.with(element);\n+    }\n+\n+    private void addCatchHandler(TryBlock block, CodeBuilder builder) {\n+        Label catchHandler = builder.newBoundLabel();\n+        int exceptionSlot = builder.allocateLocal(TypeKind.REFERENCE);\n+        builder.astore(exceptionSlot);\n+        addTracing(builder);\n+        builder.aload(exceptionSlot);\n+        builder.athrow();\n+        builder.exceptionCatchAll(block.start, block.end, catchHandler);\n+    }\n+\n+    private void addTracing(CodeBuilder builder) {\n+        builder.lload(timestampSlot);\n+        builder.ldc(method.methodId());\n+        Modification modification = method.modification();\n+        boolean objectInit = method.name().equals(\"java.lang.Object::<init>\");\n+        String suffix = objectInit ? \"ObjectInit\" : \"\";\n+        if (modification.timing()) {\n+            if (modification.tracing()) {\n+                invokeTraceTiming(builder, suffix);\n@@ -78,3 +232,5 @@\n-                if (modification.tracing()) {\n-                    invokeTrace(builder, suffix);\n-                }\n+                invokeTiming(builder, suffix);\n+            }\n+        } else {\n+            if (modification.tracing()) {\n+                invokeTrace(builder, suffix);\n@@ -83,1 +239,0 @@\n-        builder.with(element);\n@@ -86,1 +241,1 @@\n-    public static void invokeTiming(CodeBuilder builder, String suffix) {\n+    private static void invokeTiming(CodeBuilder builder, String suffix) {\n@@ -90,1 +245,1 @@\n-    public static void invokeTrace(CodeBuilder builder, String suffix) {\n+    private static void invokeTrace(CodeBuilder builder, String suffix) {\n@@ -94,1 +249,1 @@\n-    public static void invokeTraceTiming(CodeBuilder builder, String suffix) {\n+    private static void invokeTraceTiming(CodeBuilder builder, String suffix) {\n@@ -98,1 +253,1 @@\n-    public static int invokeTimestamp(CodeBuilder builder) {\n+    private static int invokeTimestamp(CodeBuilder builder) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Transform.java","additions":176,"deletions":21,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that constructors are instrumented correctly.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=debug\n+ *      jdk.jfr.event.tracing.TestConstructors\n+ **\/\n+public class TestConstructors {\n+    static private void methodThatThrows() {\n+        throw new RuntimeException();\n+    }\n+\n+    public static class Cat {\n+        Cat() {\n+            new String();\n+            methodThatThrows();\n+            super();\n+            methodThatThrows();\n+        }\n+    }\n+\n+    public static class Dog {\n+        Dog() {\n+            super();\n+            methodThatThrows();\n+        }\n+    }\n+\n+    public static class Tiger {\n+        Tiger() {\n+            methodThatThrows();\n+            super();\n+        }\n+    }\n+\n+    public static class Zebra {\n+        Zebra(boolean shouldThrow) {\n+            this(shouldThrow ? 1 : 0);\n+        }\n+\n+        Zebra(int shouldThrow) {\n+            if (shouldThrow == 1) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    public static class Snake {\n+        Snake() {\n+            try {\n+                throw new RuntimeException();\n+            } catch (Exception e) {\n+                \/\/ Ignore\n+            }\n+            super();\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.MethodTrace\").with(\"filter\", Dog.class.getName() + \";\" + Cat.class.getName() + \";\" + Tiger.class.getName() + \";\" + Zebra.class.getName() + \";\" + Snake.class.getName());\n+            r.start();\n+            try {\n+                new Cat();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Dog();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Tiger();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Zebra(true);\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Zebra(false);\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Snake();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            var methods = buildMethodMap(events);\n+            if (methods.size() != 5) {\n+                throw new Exception(\"Expected 5 different methods\");\n+            }\n+            assertMethodCount(methods, \"Cat\", 1);\n+            assertMethodCount(methods, \"Dog\", 1);\n+            assertMethodCount(methods, \"Snake\", 1);\n+            assertMethodCount(methods, \"Tiger\", 1);\n+            assertMethodCount(methods, \"Zebra\", 3);\n+        }\n+    }\n+\n+    private static void assertMethodCount(Map<String, Long> methods, String className, int expectedCount) throws Exception {\n+        String name = TestConstructors.class.getName() + \"$\" + className + \"::<init>\";\n+        Long count = methods.get(name);\n+        if (count == null) {\n+            throw new Exception(\"Could not find traced method \" + name);\n+        }\n+        if (count != expectedCount) {\n+            throw new Exception(\"Expected \" + expectedCount + \" trace event for \" + name);\n+        }\n+    }\n+\n+    private static Map<String, Long> buildMethodMap(List<RecordedEvent> events) {\n+        Map<String, Long> map = new TreeMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedMethod m = e.getValue(\"method\");\n+            String name = m.getType().getName() + \"::\" + m.getName();\n+            map.compute(name, (_, value) -> (value == null) ? 1 : value + 1);\n+        }\n+        for (var e : map.entrySet()) {\n+            System.out.println(e.getKey() + \" \" + e.getValue());\n+        }\n+        return map;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestConstructors.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -96,0 +96,2 @@\n+        assertMethod(map, \"deepException\", 1);\n+        assertMethod(map, \"whileTrue\", 1);\n@@ -108,0 +110,2 @@\n+        assertMethod(map, \"deepException\", 1);\n+        assertMethod(map, \"whileTrue\", 1);\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestInstrumentation.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}