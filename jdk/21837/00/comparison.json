{"files":[{"patch":"@@ -875,0 +875,7 @@\n+address ArchiveBuilder::offset_to_buffered_address(u4 offset) const {\n+  address requested_addr = _requested_static_archive_bottom + offset;\n+  address buffered_addr = requested_addr - _buffer_to_requested_delta;\n+  assert(is_in_buffer_space(buffered_addr), \"bad offset\");\n+  return buffered_addr;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-  static const uintx MAX_SHARED_DELTA = 0x7FFFFFFF;\n+  static const uintx MAX_SHARED_DELTA = ArchiveUtils::MAX_SHARED_DELTA;;\n@@ -334,0 +334,3 @@\n+  \/\/ The reverse of buffer_to_offset()\n+  address offset_to_buffered_address(u4 offset) const;\n+\n@@ -346,0 +349,5 @@\n+  template <typename T>\n+  T offset_to_buffered(u4 offset) const {\n+    return (T)offset_to_buffered_address(offset);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cds_globals.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -250,0 +252,1 @@\n+  static const uintx MAX_SHARED_DELTA = 0x7FFFFFFF;\n@@ -251,0 +254,19 @@\n+\n+  \/\/ offset must represent an object of type T in the mapped shared space. Return\n+  \/\/ a direct pointer to this object.\n+  template <typename T> T static from_offset(u4 offset) {\n+    T p = (T)(SharedBaseAddress + offset);\n+    assert(Metaspace::is_in_shared_metaspace(p), \"must be\");\n+    return p;\n+  }\n+\n+  \/\/ p must be an archived object. Get its offset from SharedBaseAddress\n+  template <typename T> static u4 to_offset(T p) {\n+    uintx pn = (uintx)p;\n+    uintx base = (uintx)SharedBaseAddress;\n+    assert(Metaspace::is_in_shared_metaspace(p), \"must be\");\n+    assert(pn > base, \"sanity\"); \/\/ No valid object is stored at 0 offset from SharedBaseAddress\n+    uintx offset = pn - base;\n+    assert(offset <= MAX_SHARED_DELTA, \"range check\");\n+    return static_cast<u4>(offset);\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-Array<Array<char>*>*  LambdaFormInvokers::_static_archive_invokers = nullptr;\n+Array<u4>*  LambdaFormInvokers::_static_archive_invokers = nullptr;\n@@ -219,1 +219,1 @@\n-      _static_archive_invokers = ArchiveBuilder::new_ro_array<Array<char>*>(count);\n+      _static_archive_invokers = ArchiveBuilder::new_ro_array<u4>(count);\n@@ -228,2 +228,1 @@\n-          _static_archive_invokers->at_put(index, line);\n-          ArchivePtrMarker::mark_pointer(_static_archive_invokers->adr_at(index));\n+          _static_archive_invokers->at_put(index, ArchiveBuilder::current()->any_to_offset_u4(line));\n@@ -242,1 +241,7 @@\n-      Array<char>* line = _static_archive_invokers->at(i);\n+      u4 offset = _static_archive_invokers->at(i);\n+      Array<char>* line;\n+      if (ArchiveBuilder::is_active()) {\n+        line = ArchiveBuilder::current()->offset_to_buffered<Array<char>*>(offset);\n+      } else {\n+        line = ArchiveUtils::from_offset<Array<char>*>(offset);\n+      }\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  static Array<Array<char>*>* _static_archive_invokers;\n+  static Array<u4>* _static_archive_invokers;\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,11 +37,0 @@\n-void LambdaProxyClassKey::init_for_archive(LambdaProxyClassKey& dumptime_key) {\n-  ArchiveBuilder* b = ArchiveBuilder::current();\n-\n-  b->write_pointer_in_buffer(&_caller_ik,                dumptime_key._caller_ik);\n-  b->write_pointer_in_buffer(&_instantiated_method_type, dumptime_key._instantiated_method_type);\n-  b->write_pointer_in_buffer(&_invoked_name,             dumptime_key._invoked_name);\n-  b->write_pointer_in_buffer(&_invoked_type,             dumptime_key._invoked_type);\n-  b->write_pointer_in_buffer(&_member_method,            dumptime_key._member_method);\n-  b->write_pointer_in_buffer(&_method_type,              dumptime_key._method_type);\n-}\n-\n@@ -56,0 +45,8 @@\n+unsigned int RunTimeLambdaProxyClassKey::hash() const {\n+  return primitive_hash<u4>(_caller_ik) +\n+         primitive_hash<u4>(_invoked_name) +\n+         primitive_hash<u4>(_invoked_type) +\n+         primitive_hash<u4>(_method_type) +\n+         primitive_hash<u4>(_instantiated_method_type);\n+}\n+\n@@ -68,0 +65,11 @@\n+void RunTimeLambdaProxyClassKey::print_on(outputStream* st) const {\n+  ResourceMark rm;\n+  st->print_cr(\"LambdaProxyClassKey       : \" INTPTR_FORMAT \" hash: %0x08x\", p2i(this), hash());\n+  st->print_cr(\"_caller_ik                : %d\", _caller_ik);\n+  st->print_cr(\"_instantiated_method_type : %d\", _instantiated_method_type);\n+  st->print_cr(\"_invoked_name             : %d\", _invoked_name);\n+  st->print_cr(\"_invoked_type             : %d\", _invoked_type);\n+  st->print_cr(\"_member_method            : %d\", _member_method);\n+  st->print_cr(\"_method_type              : %d\", _method_type);\n+}\n+\n@@ -74,1 +82,1 @@\n-  _key.init_for_archive(key);\n+  _key = RunTimeLambdaProxyClassKey::init_for_dumptime(key);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,6 @@\n-  InstanceKlass* caller_ik() const { return _caller_ik; }\n+  InstanceKlass* caller_ik()         const { return _caller_ik; }\n+  Symbol* invoked_name()             const { return _invoked_name; }\n+  Symbol* invoked_type()             const { return _invoked_type; }\n+  Symbol* method_type()              const { return _method_type; }\n+  Method* member_method()            const { return _member_method; }\n+  Symbol* instantiated_method_type() const { return _instantiated_method_type; }\n@@ -106,1 +111,67 @@\n-  void init_for_archive(LambdaProxyClassKey& dumptime_key);\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const;\n+#endif\n+};\n+\n+class RunTimeLambdaProxyClassKey {\n+  u4 _caller_ik;\n+  u4 _invoked_name;\n+  u4 _invoked_type;\n+  u4 _method_type;\n+  u4 _member_method;\n+  u4 _instantiated_method_type;\n+\n+  RunTimeLambdaProxyClassKey(u4 caller_ik,\n+                             u4 invoked_name,\n+                             u4 invoked_type,\n+                             u4 method_type,\n+                             u4 member_method,\n+                             u4 instantiated_method_type) :\n+    _caller_ik(caller_ik),\n+    _invoked_name(invoked_name),\n+    _invoked_type(invoked_type),\n+    _method_type(method_type),\n+    _member_method(member_method),\n+    _instantiated_method_type(instantiated_method_type) {}\n+\n+public:\n+  static RunTimeLambdaProxyClassKey init_for_dumptime(LambdaProxyClassKey& key) {\n+    assert(ArchiveBuilder::is_active(), \"sanity\");\n+    ArchiveBuilder* b = ArchiveBuilder::current();\n+\n+    u4 caller_ik                = b->any_to_offset_u4(key.caller_ik());\n+    u4 invoked_name             = b->any_to_offset_u4(key.invoked_name());\n+    u4 invoked_type             = b->any_to_offset_u4(key.invoked_type());\n+    u4 method_type              = b->any_to_offset_u4(key.method_type());\n+    u4 member_method            = b->any_to_offset_u4(key.member_method());\n+    u4 instantiated_method_type = b->any_to_offset_u4(key.instantiated_method_type());\n+\n+    return RunTimeLambdaProxyClassKey(caller_ik, invoked_name, invoked_type, method_type,\n+                                      member_method, instantiated_method_type);\n+  }\n+\n+  static RunTimeLambdaProxyClassKey init_for_runtime(InstanceKlass* caller_ik,\n+                                                     Symbol*        invoked_name,\n+                                                     Symbol*        invoked_type,\n+                                                     Symbol*        method_type,\n+                                                     Method*        member_method,\n+                                                     Symbol*        instantiated_method_type) {\n+    \/\/ All parameters must be in shared space, or else you'd get an assert in\n+    \/\/ ArchiveUtils::to_offset().\n+    return RunTimeLambdaProxyClassKey(ArchiveUtils::to_offset(caller_ik),\n+                                      ArchiveUtils::to_offset(invoked_name),\n+                                      ArchiveUtils::to_offset(invoked_type),\n+                                      ArchiveUtils::to_offset(method_type),\n+                                      ArchiveUtils::to_offset(member_method),\n+                                      ArchiveUtils::to_offset(instantiated_method_type));\n+  }\n+\n+  unsigned int hash() const;\n+  bool equals(RunTimeLambdaProxyClassKey const& other) const {\n+    return _caller_ik == other._caller_ik &&\n+           _invoked_name == other._invoked_name &&\n+           _invoked_type == other._invoked_type &&\n+           _method_type == other._method_type &&\n+           _member_method == other._member_method &&\n+           _instantiated_method_type == other._instantiated_method_type;\n+  }\n@@ -136,1 +207,1 @@\n-  LambdaProxyClassKey _key;\n+  RunTimeLambdaProxyClassKey _key;\n@@ -139,1 +210,1 @@\n-  RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n+  RunTimeLambdaProxyClassInfo(RunTimeLambdaProxyClassKey key, InstanceKlass* proxy_klass_head) :\n@@ -146,1 +217,1 @@\n-       const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {\n+       const RunTimeLambdaProxyClassInfo* value, RunTimeLambdaProxyClassKey* key, int len_unused) {\n@@ -154,1 +225,1 @@\n-  LambdaProxyClassKey key() const {\n+  RunTimeLambdaProxyClassKey key() const {\n@@ -176,1 +247,1 @@\n-  LambdaProxyClassKey*,\n+  RunTimeLambdaProxyClassKey*,\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":79,"deletions":8,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-  builder->write_pointer_in_buffer(&_klass, info._klass);\n+  InstanceKlass* k = info._klass;\n+  _klass_offset = builder->any_to_offset_u4(k);\n@@ -35,1 +36,1 @@\n-  if (!SystemDictionaryShared::is_builtin(_klass)) {\n+  if (!SystemDictionaryShared::is_builtin(k)) {\n@@ -64,2 +65,2 @@\n-  if (_klass->is_hidden()) {\n-    builder->write_pointer_in_buffer(nest_host_addr(), info.nest_host());\n+  if (k->is_hidden()) {\n+    _nest_host_offset = builder->any_to_offset_u4(info.nest_host());\n@@ -67,1 +68,1 @@\n-  if (_klass->has_archived_enum_objs()) {\n+  if (k->has_archived_enum_objs()) {\n@@ -77,0 +78,8 @@\n+InstanceKlass* RunTimeClassInfo::klass() const {\n+  if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space((address)this)) {\n+    return ArchiveBuilder::current()->offset_to_buffered<InstanceKlass*>(_klass_offset);\n+  } else {\n+    return ArchiveUtils::from_offset<InstanceKlass*>(_klass_offset);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-    Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}\n-    Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }\n+    Symbol* name() { return ArchiveUtils::from_offset<Symbol*>(_name); }\n+    Symbol* from_name() { return ArchiveUtils::from_offset<Symbol*>(_from_name); }\n@@ -63,3 +63,1 @@\n-    Symbol* constraint_name() {\n-      return (Symbol*)(SharedBaseAddress + _name);\n-    }\n+    Symbol* constraint_name() { return ArchiveUtils::from_offset<Symbol*>(_name); }\n@@ -72,1 +70,3 @@\n-  InstanceKlass* _klass;\n+private:\n+  u4 _klass_offset;\n+  u4 _nest_host_offset;\n@@ -83,1 +83,0 @@\n-private:\n@@ -111,0 +110,3 @@\n+  InstanceKlass* klass() const;\n+  int num_verifier_constraints() const { return _num_verifier_constraints; }\n+  int num_loader_constraints() const { return _num_loader_constraints; }\n@@ -128,1 +130,1 @@\n-    return crc_offset() + crc_size(_klass);\n+    return crc_offset() + crc_size(klass());\n@@ -132,1 +134,1 @@\n-    return nest_host_offset() + nest_host_size(_klass);\n+    return nest_host_offset() + nest_host_size(klass());\n@@ -153,1 +155,1 @@\n-    assert(_klass->has_archived_enum_objs(), \"sanity\");\n+    assert(klass()->has_archived_enum_objs(), \"sanity\");\n@@ -159,1 +161,1 @@\n-    assert(crc_size(_klass) > 0, \"must be\");\n+    assert(crc_size(klass()) > 0, \"must be\");\n@@ -176,4 +178,0 @@\n-  InstanceKlass** nest_host_addr() {\n-    assert(_klass->is_hidden(), \"sanity\");\n-    return (InstanceKlass**)(address(this) + nest_host_offset());\n-  }\n@@ -181,1 +179,5 @@\n-    return *nest_host_addr();\n+    if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space((address)this)) {\n+      return ArchiveBuilder::current()->offset_to_buffered<InstanceKlass*>(_nest_host_offset);\n+    } else {\n+      return ArchiveUtils::from_offset<InstanceKlass*>(_nest_host_offset);\n+    }\n@@ -251,1 +253,1 @@\n-    return (value->_klass->name() == key);\n+    return (value->klass()->name() == key);\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  return acquire_class_for_current_thread(record->_klass, class_loader,\n+  return acquire_class_for_current_thread(record->klass(), class_loader,\n@@ -792,0 +792,10 @@\n+  if (!caller_ik->is_shared()     ||\n+      !invoked_name->is_shared()  ||\n+      !invoked_type->is_shared()  ||\n+      !method_type->is_shared()   ||\n+      !member_method->is_shared() ||\n+      !instantiated_method_type->is_shared()) {\n+    \/\/ These can't be represented as u4 offset, but we wouldn't have archived a lambda proxy in this case anyway.\n+    return nullptr;\n+  }\n+\n@@ -793,2 +803,3 @@\n-  LambdaProxyClassKey key(caller_ik, invoked_name, invoked_type,\n-                          method_type, member_method, instantiated_method_type);\n+  RunTimeLambdaProxyClassKey key =\n+    RunTimeLambdaProxyClassKey::init_for_runtime(caller_ik, invoked_name, invoked_type,\n+                                                 method_type, member_method, instantiated_method_type);\n@@ -902,1 +913,1 @@\n-  int length = record->_num_verifier_constraints;\n+  int length = record->num_verifier_constraints();\n@@ -1018,1 +1029,1 @@\n-    if (info->_num_loader_constraints > 0) {\n+    if (info->num_loader_constraints() > 0) {\n@@ -1020,1 +1031,1 @@\n-      for (int i = 0; i < info->_num_loader_constraints; i++) {\n+      for (int i = 0; i < info->num_loader_constraints(); i++) {\n@@ -1336,2 +1347,2 @@\n-    assert(!record->_klass->is_hidden(), \"hidden class cannot be looked up by name\");\n-    assert(check_alignment(record->_klass), \"Address not aligned\");\n+    assert(!record->klass()->is_hidden(), \"hidden class cannot be looked up by name\");\n+    assert(check_alignment(record->klass()), \"Address not aligned\");\n@@ -1340,1 +1351,1 @@\n-    if (record->_klass->is_generated_shared_class() && JvmtiExport::should_post_class_file_load_hook()) {\n+    if (record->klass()->is_generated_shared_class() && JvmtiExport::should_post_class_file_load_hook()) {\n@@ -1343,1 +1354,1 @@\n-    return record->_klass;\n+    return record->klass();\n@@ -1381,4 +1392,4 @@\n-    _st->print_cr(\"%4d: %s %s\", _index++, record->_klass->external_name(),\n-        class_loader_name_for_shared(record->_klass));\n-    if (record->_klass->array_klasses() != nullptr) {\n-      record->_klass->array_klasses()->cds_print_value_on(_st);\n+    _st->print_cr(\"%4d: %s %s\", _index++, record->klass()->external_name(),\n+        class_loader_name_for_shared(record->klass()));\n+    if (record->klass()->array_klasses() != nullptr) {\n+      record->klass()->array_klasses()->cds_print_value_on(_st);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-    const RunTimeLambdaProxyClassInfo* lookup_lambda_proxy_class(LambdaProxyClassKey* key) {\n+    const RunTimeLambdaProxyClassInfo* lookup_lambda_proxy_class(RunTimeLambdaProxyClassKey* key) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}