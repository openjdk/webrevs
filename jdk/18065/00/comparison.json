{"files":[{"patch":"@@ -176,7 +176,5 @@\n-  idx_t cur_beg = find_obj_beg(range_beg, search_end);\n-  while (cur_beg < range_end) {\n-    const idx_t cur_end = find_obj_end(cur_beg, search_end);\n-    if (cur_end >= range_end) {\n-      \/\/ The obj ends outside the range.\n-      live_closure->set_source(bit_to_addr(cur_beg));\n-      return incomplete;\n+  idx_t cur_beg = range_beg;\n+  while (true) {\n+    cur_beg = find_obj_beg(cur_beg, search_end);\n+    if (cur_beg >= range_end) {\n+      break;\n@@ -185,1 +183,1 @@\n-    const size_t size = obj_size(cur_beg, cur_end);\n+    const size_t size = obj_size(cur_beg);\n@@ -192,2 +190,4 @@\n-    \/\/ Successfully processed the object; look for the next object.\n-    cur_beg = find_obj_beg(cur_end + 1, search_end);\n+    cur_beg += words_to_bits(size);\n+    if (cur_beg >= range_end) {\n+      break;\n+    }\n@@ -196,1 +196,0 @@\n-  live_closure->set_source(bit_to_addr(range_end));\n@@ -213,1 +212,0 @@\n-  const idx_t live_search_end = align_range_end(range_end);\n@@ -219,0 +217,2 @@\n+    \/\/ This must be the beginning of old\/eden\/from\/to-space, so it's must be\n+    \/\/ larger enough for a filler.\n@@ -220,1 +220,1 @@\n-    const idx_t dead_space_end = MIN2(cur_beg - 1, dead_range_end - 1);\n+    const idx_t dead_space_end = cur_beg - 1;\n@@ -226,8 +226,1 @@\n-    const idx_t cur_end = find_obj_end(cur_beg, live_search_end);\n-    if (cur_end >= range_end) {\n-      \/\/ The obj ends outside the range.\n-      live_closure->set_source(bit_to_addr(cur_beg));\n-      return incomplete;\n-    }\n-\n-    const size_t size = obj_size(cur_beg, cur_end);\n+    const size_t size = obj_size(cur_beg);\n@@ -240,0 +233,4 @@\n+    const idx_t dead_space_beg = cur_beg + words_to_bits(size);\n+    if (dead_space_beg >= dead_search_end) {\n+      break;\n+    }\n@@ -241,1 +238,0 @@\n-    const idx_t dead_space_beg = cur_end + 1;\n@@ -245,3 +241,3 @@\n-      const idx_t dead_space_end = MIN2(cur_beg - 1, dead_range_end - 1);\n-      const size_t size = obj_size(dead_space_beg, dead_space_end);\n-      dead_closure->do_addr(bit_to_addr(dead_space_beg), size);\n+      const idx_t dead_space_end = cur_beg - 1;\n+      dead_closure->do_addr(bit_to_addr(dead_space_beg),\n+                            obj_size(dead_space_beg, dead_space_end));\n@@ -251,1 +247,0 @@\n-  live_closure->set_source(bit_to_addr(range_end));\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -84,4 +84,0 @@\n-  \/\/ incomplete         The iteration is not complete.  The last object that\n-  \/\/                    begins in the range does not end in the range;\n-  \/\/                    closure->source() is set to the start of that object.\n-  \/\/\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2600,6 +2600,1 @@\n-    ParMarkBitMap::IterationStatus status;\n-    status = mbm->iterate(&update_closure, &fill_closure, beg_addr, end_addr,\n-                          dense_prefix_end);\n-    if (status == ParMarkBitMap::incomplete) {\n-      update_closure.do_addr(update_closure.source());\n-    }\n+    mbm->iterate(&update_closure, &fill_closure, beg_addr, end_addr, dense_prefix_end);\n@@ -2916,19 +2911,0 @@\n-    if (status == ParMarkBitMap::incomplete) {\n-      \/\/ The last obj that starts in the source region does not end in the\n-      \/\/ region.\n-      assert(closure.source() < end_addr, \"sanity\");\n-      HeapWord* const obj_beg = closure.source();\n-      HeapWord* const range_end = MIN2(obj_beg + closure.words_remaining(),\n-                                       src_space_top);\n-      HeapWord* const obj_end = bitmap->find_obj_end(obj_beg, range_end);\n-      if (obj_end < range_end) {\n-        \/\/ The end was found; the entire object will fit.\n-        status = closure.do_addr(obj_beg, bitmap->obj_size(obj_beg, obj_end));\n-        assert(status != ParMarkBitMap::would_overflow, \"sanity\");\n-      } else {\n-        \/\/ The end was not found; the object will not fit.\n-        assert(range_end < src_space_top, \"obj cannot cross space boundary\");\n-        status = ParMarkBitMap::would_overflow;\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"}]}