{"files":[{"patch":"@@ -1655,0 +1655,179 @@\n+#ifdef DEBUG\n+\/\/ APIs that can be called when debugging the debug agent\n+\n+#define check_jvmti_status(err, msg) \\\n+  if (err != JVMTI_ERROR_NONE) { \\\n+      EXIT_ERROR(err, msg); \\\n+  }\n+\n+char*\n+translateThreadState(jint flags) {\n+    char str[15 * 20];\n+    str[0] = '\\0';\n+\n+    if (flags & JVMTI_THREAD_STATE_ALIVE) {\n+        strcat(str, \" ALIVE\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_TERMINATED) {\n+        strcat(str, \" TERMINATED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_RUNNABLE) {\n+        strcat(str, \" RUNNABLE\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_WAITING) {\n+        strcat(str, \" WAITING\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) {\n+        strcat(str, \" WAITING_INDEFINITELY\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) {\n+        strcat(str, \" WAITING_WITH_TIMEOUT\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_SLEEPING) {\n+        strcat(str, \" SLEEPING\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) {\n+        strcat(str, \" IN_OBJECT_WAIT\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_PARKED) {\n+        strcat(str, \" PARKED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) {\n+        strcat(str, \" BLOCKED_ON_MONITOR_ENTER\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_SUSPENDED) {\n+        strcat(str, \" SUSPENDED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_INTERRUPTED) {\n+        strcat(str, \" INTERRUPTED\");\n+    }\n+    if (flags & JVMTI_THREAD_STATE_IN_NATIVE) {\n+        strcat(str, \" IN_NATIVE\");\n+    }\n+\n+    if (strlen(str) == 0) {\n+        strcpy(str, \"<none>\");\n+    }\n+\n+    char* tstate = (char*)jvmtiAllocate((int)strlen(str) + 1);\n+    strcpy(tstate, str);\n+\n+  return tstate;\n+}\n+\n+char*\n+getThreadName(jthread thread) {\n+    jvmtiThreadInfo thr_info;\n+    jvmtiError err;\n+\n+    memset(&thr_info, 0, sizeof(thr_info));\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+        (gdata->jvmti, thread, &thr_info);\n+    if (err == JVMTI_ERROR_WRONG_PHASE || err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+        return NULL; \/\/ VM or target thread completed its work\n+    }\n+    check_jvmti_status(err, \"getThreadName: error in JVMTI GetThreadInfo call\");\n+\n+    char* tname = thr_info.name;\n+    if (tname == NULL) {\n+        const char* UNNAMED_STR = \"<Unnamed thread>\";\n+        size_t UNNAMED_LEN = strlen(UNNAMED_STR);\n+        tname = (char*)jvmtiAllocate((int)UNNAMED_LEN + 1);\n+        strcpy(tname, UNNAMED_STR);\n+    }\n+    return tname;\n+}\n+\n+char*\n+getMethodName(jmethodID method) {\n+    char*  mname = NULL;\n+    jvmtiError err;\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodName)\n+        (gdata->jvmti, method, &mname, NULL, NULL);\n+    check_jvmti_status(err, \"getMethodName: error in JVMTI GetMethodName call\");\n+\n+    return mname;\n+}\n+\n+static char*\n+get_method_class_name(jmethodID method) {\n+    jclass klass = NULL;\n+    char*  cname = NULL;\n+    char*  result = NULL;\n+    jvmtiError err;\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodDeclaringClass)\n+        (gdata->jvmti, method, &klass);\n+    check_jvmti_status(err, \"get_method_class_name: error in JVMTI GetMethodDeclaringClass\");\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetClassSignature)\n+        (gdata->jvmti, klass, &cname, NULL);\n+    check_jvmti_status(err, \"get_method_class_name: error in JVMTI GetClassSignature\");\n+\n+    size_t len = strlen(cname) - 2; \/\/ get rid of leading 'L' and trailing ';'\n+    result = (char*)jvmtiAllocate((int)len + 1);\n+    strncpy(result, cname + 1, len); \/\/ skip leading 'L'\n+    result[len] = '\\0';\n+    jvmtiDeallocate((void*)cname);\n+    return result;\n+}\n+\n+static void\n+print_method(jmethodID method, jint depth) {\n+    char*  cname = NULL;\n+    char*  mname = NULL;\n+    char*  msign = NULL;\n+    jvmtiError err;\n+\n+    cname = get_method_class_name(method);\n+\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodName)\n+        (gdata->jvmti, method, &mname, &msign, NULL);\n+    check_jvmti_status(err, \"print_method: error in JVMTI GetMethodName\");\n+\n+    tty_message(\"%2d: %s: %s%s\", depth, cname, mname, msign);\n+    jvmtiDeallocate((void*)cname);\n+    jvmtiDeallocate((void*)mname);\n+    jvmtiDeallocate((void*)msign);\n+}\n+\n+#define MAX_FRAME_COUNT_PRINT_STACK_TRACE 200\n+\n+void\n+printStackTrace(jthread thread) {\n+    jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n+    char* tname = getThreadName(thread);\n+    jint count = 0;\n+\n+    jvmtiError err = JVMTI_FUNC_PTR(gdata->jvmti,GetStackTrace)\n+        (gdata->jvmti, thread, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n+    check_jvmti_status(err, \"printStackTrace: error in JVMTI GetStackTrace\");\n+\n+    tty_message(\"JVMTI Stack Trace for thread %s: frame count: %d\", tname, count);\n+    for (int depth = 0; depth < count; depth++) {\n+        print_method(frames[depth].method, depth);\n+    }\n+    jvmtiDeallocate((void*)tname);\n+}\n+\n+void\n+printThreadInfo(jthread thread) {\n+    jvmtiThreadInfo thread_info;\n+    jint thread_state;\n+    jvmtiError err;\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+        (gdata->jvmti, thread, &thread_info);\n+    check_jvmti_status(err, \"Error in GetThreadInfo\");\n+    err = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadState)\n+        (gdata->jvmti, thread, &thread_state);\n+    check_jvmti_status(err, \"Error in GetThreadState\");\n+    const char* state = translateThreadState(thread_state);\n+    tty_message(\"Thread: %p, name: %s, state(%x): %s, attrs: %s %s\",\n+                thread, thread_info.name, thread_state, state,\n+                (isVThread(thread) ? \"virtual\": \"platform\"),\n+                (thread_info.is_daemon ? \"daemon\": \"\"));\n+}\n+\n+#endif \/* DEBUG*\/\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":179,"deletions":0,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -389,0 +389,9 @@\n+#ifdef DEBUG\n+\/\/ APIs that can be called when debugging the debug agent\n+char* translateThreadState(jint flags);\n+char* getThreadName(jthread thread);\n+char* getMethodName(jmethodID method);\n+void printStackTrace(jthread thread);\n+void printThreadInfo(jthread thread);\n+#endif\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}