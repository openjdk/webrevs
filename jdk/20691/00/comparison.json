{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -442,1 +442,2 @@\n-            Loader loader;\n+            Loader loader = null;\n+            final URL[] loaderClassPathURLs;\n@@ -445,6 +446,3 @@\n-                \/\/ If the loader defines a local class path then add the\n-                \/\/ URLs as the next URLs to be opened.\n-                URL[] urls = loader.getClassPath();\n-                if (urls != null) {\n-                    push(urls);\n-                }\n+                \/\/ If the loader defines a local class path then construct\n+                \/\/ and add the URLs as the next URLs to be opened.\n+                loaderClassPathURLs = loader.getClassPath();\n@@ -452,1 +450,8 @@\n-                \/\/ Silently ignore for now...\n+                \/\/ log the error and close the unusable loader (if any)\n+                if (DEBUG) {\n+                    System.err.println(\"Failed to construct a loader or construct its\" +\n+                            \" local classpath for \" + url + \", cause:\" + e);\n+                }\n+                if (loader != null) {\n+                    closeLoaderIgnoreEx(loader);\n+                }\n@@ -455,3 +460,3 @@\n-                \/\/ Always silently ignore. The context, if there is one, that\n-                \/\/ this URLClassPath was given during construction will never\n-                \/\/ have permission to access the URL.\n+                \/\/ log the error and close the unusable loader (if any).\n+                \/\/ The context, if there is one, that this URLClassPath was\n+                \/\/ given during construction will never have permission to access the URL.\n@@ -461,0 +466,3 @@\n+                if (loader != null) {\n+                    closeLoaderIgnoreEx(loader);\n+                }\n@@ -463,0 +471,3 @@\n+            if (loaderClassPathURLs != null) {\n+                push(loaderClassPathURLs);\n+            }\n@@ -470,0 +481,11 @@\n+    \/\/ closes the given loader and ignores any IOException that may occur during close\n+    private static void closeLoaderIgnoreEx(final Loader loader) {\n+        try {\n+            loader.close();\n+        } catch (IOException ioe) {\n+            if (DEBUG) {\n+                System.err.println(\"ignoring exception \" + ioe + \" while closing loader \" + loader);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8338445\n+ * @summary verify that the jdk.internal.loader.URLClassPath closes the JarFile\n+ *          instances that it no longer uses for loading\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ * @comment This test expects MalformedURLException for some specific URLs.\n+ *          We use othervm to prevent interference from other tests which\n+ *          might have installed custom URLStreamHandler(s)\n+ * @run junit\/othervm JarLoaderCloseTest\n+ *\/\n+public class JarLoaderCloseTest {\n+\n+    private static final String RESOURCE_NAME = \"foo-bar.txt\";\n+    private static final String RESOURCE_CONTENT = \"Hello world\";\n+    private static final Path TEST_SCRATCH_DIR = Path.of(\".\");\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        \/\/ create a file which will be added to the jar that gets tested\n+        Files.writeString(TEST_SCRATCH_DIR.resolve(RESOURCE_NAME), RESOURCE_CONTENT);\n+    }\n+\n+    static Stream<Arguments> malformedClassPaths() {\n+        return Stream.of(\n+                Arguments.of(\"C:\\\\foo\\\\bar\\\\hello\/world.jar lib2.jar\"),\n+                Arguments.of(\"C:\/hello\/world\/foo.jar\"),\n+                Arguments.of(\"lib4.jar C:\\\\bar\\\\foo\\\\world\/hello.jar\")\n+        );\n+    }\n+\n+    \/*\n+     * Creates a jar with a manifest which has a Class-Path entry value with malformed URLs.\n+     * Then uses a URLClassLoader backed by the jar file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying jar file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"malformedClassPaths\")\n+    public void testMalformedClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the jar with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the jar file and load a non-existent resource just to\n+        \/\/ exercise the URLClassPath code of loading the jar and parsing the Class-Path entry.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying jar file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(\"non-existent.txt\")) {\n+                assertNull(is, \"unexpectedly found a resource in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+            }\n+        }\n+        \/\/ now delete the jar file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    static Stream<Arguments> missingButParsableClassPaths() {\n+        return Stream.of(\n+                Arguments.of(\"\/home\/me\/hello\/world.jar lib9.jar\"),\n+                Arguments.of(\"lib10.jar\")\n+        );\n+    }\n+\n+    \/*\n+     * Creates a jar with a manifest which has a Class-Path entry value with URLs that are parsable\n+     * but point to files that don't exist on the filesystem.\n+     * Then uses a URLClassLoader backed by the jar file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying jar file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"missingButParsableClassPaths\")\n+    public void testParsableClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the jar with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the jar file and load a resource\n+        \/\/ and verify the resource contents.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying jar file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(RESOURCE_NAME)) {\n+                assertNotNull(is, RESOURCE_NAME + \" not located by classloader in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+                final String content = new String(is.readAllBytes(), US_ASCII);\n+                assertEquals(RESOURCE_CONTENT, content, \"unexpected content in \" + RESOURCE_NAME);\n+            }\n+        }\n+        \/\/ now delete the jar file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    private static Manifest createManifestWithClassPath(final String classPathValue) {\n+        final Manifest manifest = new Manifest();\n+        final Attributes mainAttributes = manifest.getMainAttributes();\n+        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+        mainAttributes.putValue(\"Class-Path\", classPathValue);\n+        return manifest;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/JarLoaderCloseTest.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}