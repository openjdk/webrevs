{"files":[{"patch":"@@ -135,1 +135,1 @@\n-const Klass* JfrClassTransformer::find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n+const InstanceKlass* JfrClassTransformer::find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n@@ -142,1 +142,1 @@\n-const Klass* JfrClassTransformer::klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n+const InstanceKlass* JfrClassTransformer::klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n@@ -152,0 +152,1 @@\n+    assert(existing_klass->is_instance_klass(), \"invariant\");\n@@ -154,1 +155,1 @@\n-      return existing_klass;\n+      return InstanceKlass::cast(existing_klass);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  static const Klass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state);\n+  static const InstanceKlass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state);\n@@ -44,1 +44,1 @@\n-  static const Klass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread);\n+  static const InstanceKlass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrTraceTagging.hpp\"\n@@ -91,3 +92,2 @@\n-void Jfr::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n-  assert(JfrMethodTracer::in_use(), \"invariant\");\n-  JfrMethodTracer::on_klass_redefinition(ik, thread);\n+void Jfr::on_klass_redefinition(const InstanceKlass* ik, const InstanceKlass* scratch_klass) {\n+  JfrTraceTagging::on_klass_redefinition(ik, scratch_klass);\n@@ -96,1 +96,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n+  static void on_klass_redefinition(const InstanceKlass* ik, const InstanceKlass* scratch_klass);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1064,7 +1064,5 @@\n-      while (ik != nullptr) {\n-        const int len = ik->methods()->length();\n-        for (int i = 0; i < len; ++i) {\n-          MethodPtr method = ik->methods()->at(i);\n-          if (_method_flag_predicate(method)) {\n-            _method_cb(method);\n-          }\n+      const int len = ik->methods()->length();\n+      for (int i = 0; i < len; ++i) {\n+        MethodPtr method = ik->methods()->at(i);\n+        if (_method_flag_predicate(method)) {\n+          _method_cb(method);\n@@ -1072,3 +1070,0 @@\n-        \/\/ There can be multiple versions of the same method running\n-        \/\/ due to redefinition. Need to inspect the complete set of methods.\n-        ik = ik->previous_versions();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class InstanceKlass;\n@@ -89,1 +90,0 @@\n-  static traceid load_previous_epoch(const Klass* klass);\n@@ -149,4 +149,2 @@\n-  static bool has_timing_bit(const Klass* k);\n-  static void set_timing_bit(const Klass* k);\n-  static void clear_timing_bit(const Klass* k);\n-\n+  static bool has_timing_bit(const InstanceKlass* scratch_klass);\n+  static void set_timing_bit(const InstanceKlass* scratch_klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/instanceKlass.hpp\"\n@@ -84,4 +85,0 @@\n-inline traceid JfrTraceId::load_previous_epoch(const Klass* klass) {\n-  return JfrTraceIdLoadBarrier::load_previous_epoch(klass);\n-}\n-\n@@ -201,0 +198,1 @@\n+  assert(!method->is_old(), \"invariant\");\n@@ -208,0 +206,1 @@\n+  assert(!method->is_old(), \"invariant\");\n@@ -213,3 +212,3 @@\n-inline bool JfrTraceId::has_timing_bit(const Klass* k) {\n-  assert(k != nullptr, \"invariant\");\n-  return HAS_TIMING_BIT(k);\n+inline bool JfrTraceId::has_timing_bit(const InstanceKlass* scratch_klass) {\n+  assert(scratch_klass != nullptr, \"invariant\");\n+  return HAS_TIMING_BIT(scratch_klass);\n@@ -218,14 +217,5 @@\n-inline void JfrTraceId::set_timing_bit(const Klass* k) {\n-  assert(k != nullptr, \"invariant\");\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  assert(!has_timing_bit(k), \"invariant\");\n-  SET_TIMING_BIT(k);\n-  assert(has_timing_bit(k), \"invariant\");\n-}\n-\n-inline void JfrTraceId::clear_timing_bit(const Klass* k) {\n-  assert(k != nullptr, \"invarriant\");\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  assert(JfrTraceId::has_timing_bit(k), \"invariant\");\n-  CLEAR_TIMING_BIT(k);\n-  assert(!JfrTraceId::has_timing_bit(k), \"invariant\");\n+inline void JfrTraceId::set_timing_bit(const InstanceKlass* scratch_klass) {\n+  assert(scratch_klass != nullptr, \"invariant\");\n+  assert(!has_timing_bit(scratch_klass), \"invariant\");\n+  SET_TIMING_BIT(scratch_klass);\n+  assert(has_timing_bit(scratch_klass), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  return ptr->trace_meta_addr();\n+  return ptr->trace_flags_meta_addr();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdBits.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,16 @@\n+inline const Method* latest_version(const Klass* klass, const Method* method) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n+  assert(klass == method->method_holder(), \"invariant\");\n+  assert(method->is_old(), \"invariant\");\n+  const InstanceKlass* const ik = InstanceKlass::cast(klass);\n+  assert(ik->has_been_redefined(), \"invariant\");\n+  const Method* const latest_version = ik->method_with_orig_idnum(method->orig_method_idnum());\n+  assert(latest_version != nullptr, \"invariant\");\n+  assert(latest_version != method, \"invariant\");\n+  assert(!latest_version->is_old(), \"invariant\");\n+  assert(latest_version->orig_method_idnum() == method->orig_method_idnum(), \"invariant\");\n+  assert(latest_version->name() == method->name() && latest_version->signature() == method->signature(), \"invariant\");\n+  return latest_version;\n+}\n+\n@@ -96,0 +112,3 @@\n+   if (method->is_old()) {\n+     method = latest_version(klass, method);\n+   }\n@@ -114,0 +133,3 @@\n+  if (method->is_old()) {\n+    method = latest_version(klass, method);\n+  }\n@@ -126,0 +148,1 @@\n+  const traceid id = set_used_and_get(cld);\n@@ -130,1 +153,1 @@\n-  return set_used_and_get(cld);\n+  return id;\n@@ -161,0 +184,1 @@\n+  assert(!method->is_old(), \"invariant\");\n@@ -178,0 +202,1 @@\n+  assert(!method->is_old(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-  total_elements = flush_storage(_storage, _chunkwriter);\n+  total_elements += flush_storage(_storage, _chunkwriter);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -189,0 +190,1 @@\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,3 +393,4 @@\n-\/\/ First, we consolidate all stack trace blobs into a single TYPE_STACKTRACE checkpoint\n-\/\/ and serialize it to the chunk. Then, all events are serialized, and unique type set blobs\n-\/\/ written into the JfrCheckpoint system to be serialized to the chunk upon return.\n+\/\/ First, all events are serialized, and unique type set blobs are written into the\n+\/\/ JfrCheckpoint system to be serialized to the chunk upon return.\n+\/\/ Then, we consolidate all stack trace blobs into a single TYPE_STACKTRACE checkpoint\n+\/\/ and serialize it directly to the chunk.\n@@ -398,0 +399,1 @@\n+    write_events(cw, thread, on_error);\n@@ -401,1 +403,0 @@\n-    write_events(cw, thread, on_error);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-#define KLASS_HAS_STICKY_BIT(ptr) (((ptr)->trace_id() & STICKY_BIT) != 0)\n-#define ON_KLASS_REDEFINITION(k, t) if (KLASS_HAS_STICKY_BIT(k)) Jfr::on_klass_redefinition(k, t)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassExtension.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  uint8_t* trace_meta_addr() const {               \\\n+  uint8_t* trace_flags_meta_addr() const {         \\\n@@ -101,2 +101,4 @@\n-  void copy_trace_flags(uint16_t rhs_flags) const { \\\n-    _trace_flags.set_flags(_trace_flags.flags() | rhs_flags); \\\n+  void copy_trace_flags(const Method* rhm) const { \\\n+    assert(rhm != nullptr, \"invariant\");           \\\n+    set_trace_flags(rhm->trace_flags());           \\\n+    assert(trace_flags()==rhm->trace_flags(), \"\"); \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  const InstanceKlass* _instance_klass;\n+  const InstanceKlass* _ik;\n@@ -43,2 +43,2 @@\n-  JfrInstrumentedClass(traceid trace_id = 0, const InstanceKlass* instance_klass = nullptr, bool unloaded = false) :\n-    _trace_id(trace_id), _instance_klass(instance_klass), _unloaded(unloaded) {\n+  JfrInstrumentedClass(traceid trace_id = 0, const InstanceKlass* ik = nullptr, bool unloaded = false) :\n+    _trace_id(trace_id), _ik(ik), _unloaded(unloaded) {\n@@ -48,1 +48,1 @@\n-    return _instance_klass;\n+    return _ik;\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+    assert(method->name() == _methods->at(i).name(), \"invariant\");\n+    assert(method->signature() == _methods->at(i).signature(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodProcessor.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,3 +131,3 @@\n-static void handle_no_bytecode_result(const Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  if (JfrTraceId::has_sticky_bit(klass)) {\n+static void handle_no_bytecode_result(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  if (JfrTraceId::has_sticky_bit(ik)) {\n@@ -135,1 +135,1 @@\n-    JfrTraceTagging::clear_sticky_bit(InstanceKlass::cast(klass));\n+    JfrTraceTagging::clear_sticky(ik);\n@@ -146,2 +146,2 @@\n-  const Klass* const existing_klass = JfrClassTransformer::find_existing_klass(ik, THREAD);\n-  const bool is_retransform = existing_klass != nullptr;\n+  const InstanceKlass* const existing_ik = JfrClassTransformer::find_existing_klass(ik, THREAD);\n+  const bool is_retransform = existing_ik != nullptr;\n@@ -150,1 +150,1 @@\n-  JfrMethodProcessor mp(is_retransform ? InstanceKlass::cast(existing_klass) : ik, THREAD);\n+  JfrMethodProcessor mp(is_retransform ? existing_ik : ik, THREAD);\n@@ -162,1 +162,1 @@\n-    handle_no_bytecode_result(is_retransform ? InstanceKlass::cast(existing_klass) : ik);\n+    handle_no_bytecode_result(is_retransform ? existing_ik : ik);\n@@ -176,1 +176,0 @@\n-    const InstanceKlass* const existing_ik = InstanceKlass::cast(existing_klass);\n@@ -182,1 +181,1 @@\n-    JfrTraceTagging::install_sticky_bit_for_retransform_klass(existing_ik, mp.methods(), mp.has_timing());\n+    JfrTraceTagging::tag_sticky_for_retransform_klass(existing_ik, ik, mp.methods(), mp.has_timing());\n@@ -206,2 +205,1 @@\n-void JfrMethodTracer::add_timing_entry(const InstanceKlass* ik, traceid klass_id) {\n-  assert(ik != nullptr, \"invariant\");\n+void JfrMethodTracer::add_timing_entry(traceid klass_id) {\n@@ -209,4 +207,1 @@\n-  if (JfrTraceId::has_timing_bit(ik)) {\n-    JfrTraceId::clear_timing_bit(ik);\n-    _timing_entries->append(klass_id);\n-  }\n+  _timing_entries->append(klass_id);\n@@ -216,5 +211,4 @@\n-\/\/ jvmtiRedefineClassses::redefine_single_class() has finished so we are still at a safepoint.\n-\/\/ If the original klass is not already in the list, add it and also dynamically tag all\n-\/\/ artifacts that have the sticky bit set. If the klass has an associated TimedClass,\n-\/\/ also add the klass to the list of _timing_entries for publication.\n-void JfrMethodTracer::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n+\/\/ jvmtiRedefineClassses::redefine_single_class() is about to finish so we are still at a safepoint.\n+\/\/ If the original klass is not already in the list, add it. If the klass has an associated TimedClass,\n+\/\/ add also the klass_id to the list of _timing_entries for publication.\n+void JfrMethodTracer::on_klass_redefinition(const InstanceKlass* ik, bool has_timing) {\n@@ -227,1 +221,0 @@\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -238,2 +231,3 @@\n-    add_timing_entry(ik, klass_id);\n-    JfrTraceTagging::set_dynamic_tag_for_sticky_bit(ik);\n+    if (has_timing) {\n+      add_timing_entry(klass_id);\n+    }\n@@ -261,2 +255,1 @@\n-  JfrTraceTagging::set_dynamic_tag(ik, methods);\n-  JfrTraceTagging::set_sticky_bit(ik, methods);\n+  JfrTraceTagging::tag_sticky(ik, methods);\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.cpp","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  static void add_timing_entry(const InstanceKlass* ik, traceid klass_id);\n+  static void add_timing_entry(traceid klass_id);\n@@ -64,1 +64,1 @@\n-  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n+  static void on_klass_redefinition(const InstanceKlass* ik, bool has_timing);\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -41,40 +43,0 @@\n-void JfrTraceTagging::tag_dynamic(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(methods != nullptr, \"invariant\");\n-\n-  for (int i = 0; i < methods->length(); ++i) {\n-    const Method* const method = methods->at(i).method();\n-    assert(method != nullptr, \"invariant\");\n-    if (!method->is_old()) {\n-      tag_dynamic(method);\n-      continue;\n-    }\n-    \/\/ A redefinition \/ retransformation interleaved.\n-    \/\/ Find and tag the latest version of the method.\n-    tag_dynamic(ik->method_with_orig_idnum(method->orig_method_idnum()));\n-  }\n-}\n-\n-void JfrTraceTagging::set_dynamic_tag(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(!ik->is_scratch_class(), \"invariant\");\n-\n-  tag_dynamic(ik, methods);\n-  tag_dynamic(ik);\n-}\n-\n-void JfrTraceTagging::set_dynamic_tag_for_sticky_bit(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(!ik->is_scratch_class(), \"invariant\");\n-  assert(JfrTraceId::has_sticky_bit(ik), \"invariant\");\n-\n-  const int length = ik->methods()->length();\n-  for (int i = 0; i < length; ++i) {\n-    const Method* const m = ik->methods()->at(i);\n-    if (JfrTraceId::has_sticky_bit(m)) {\n-      tag_dynamic(m);\n-    }\n-  }\n-  tag_dynamic(ik);\n-}\n-\n@@ -85,0 +47,5 @@\n+void JfrTraceTagging::tag_sticky_enqueue(const InstanceKlass* ik) {\n+  tag_sticky(ik);\n+  JfrTraceIdLoadBarrier::enqueue(ik);\n+}\n+\n@@ -89,2 +56,1 @@\n-void JfrTraceTagging::tag_sticky(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n-  assert(ik != nullptr, \"invariant\");\n+void JfrTraceTagging::tag_sticky(const GrowableArray<JfrTracedMethod>* methods) {\n@@ -92,1 +58,1 @@\n-\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -96,26 +62,1 @@\n-    if (!method->is_old()) {\n-      tag_sticky(method);\n-      continue;\n-    }\n-    \/\/ A redefinition \/ retransformation interleaved.\n-    \/\/ Find and tag the latest version of the method.\n-    tag_sticky(ik->method_with_orig_idnum(method->orig_method_idnum()));\n-  }\n-}\n-\n-void JfrTraceTagging::tag_timing(const InstanceKlass* ik) {\n-  JfrTraceId::set_timing_bit(ik);\n-}\n-\n-void JfrTraceTagging::install_sticky_bit_for_retransform_klass(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods, bool timing) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(!ik->is_scratch_class(), \"invariant\");\n-\n-  MutexLocker lock(ClassLoaderDataGraph_lock);\n-  if (JfrTraceId::has_sticky_bit(ik)) {\n-    clear_sticky_bit(ik);\n-  }\n-  tag_sticky(ik, methods);\n-  tag_sticky(ik);\n-  if (timing) {\n-    tag_timing(ik);\n+    tag_sticky(method);\n@@ -125,1 +66,1 @@\n-void JfrTraceTagging::set_sticky_bit(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+void JfrTraceTagging::tag_sticky(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n@@ -128,0 +69,1 @@\n+  assert(methods != nullptr, \"invariant\");\n@@ -129,3 +71,2 @@\n-\n-  tag_sticky(ik, methods);\n-  tag_sticky(ik);\n+  tag_sticky(methods);\n+  tag_sticky_enqueue(ik);\n@@ -134,1 +75,1 @@\n-void JfrTraceTagging::clear_sticky_bit(const InstanceKlass* ik, bool dynamic_tag \/* true *\/) {\n+void JfrTraceTagging::clear_sticky(const InstanceKlass* ik, bool dynamic_tag \/* true *\/) {\n@@ -156,2 +97,72 @@\n-  if (JfrTraceId::has_timing_bit(ik)) {\n-    JfrTraceId::clear_timing_bit(ik);\n+}\n+\n+void JfrTraceTagging::tag_sticky_for_retransform_klass(const InstanceKlass* existing_klass, const InstanceKlass* scratch_klass, const GrowableArray<JfrTracedMethod>* methods, bool timing) {\n+  assert(existing_klass != nullptr, \"invariant\");\n+  assert(scratch_klass != nullptr, \"invariant\");\n+  \/\/ The scratch class has not yet received its official status.\n+  \/\/ assert(scratch_klass->is_scratch_class(), \"invariant\");\n+  if (timing) {\n+    \/\/ Can be done outside lock because it is a scratch klass.\n+    \/\/ Visibility guaranteed by upcoming safepoint.\n+    JfrTraceId::set_timing_bit(scratch_klass);\n+  }\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  if (JfrTraceId::has_sticky_bit(existing_klass)) {\n+    clear_sticky(existing_klass);\n+  }\n+  tag_sticky(methods);\n+  tag_sticky(existing_klass);\n+}\n+\n+void JfrTraceTagging::on_klass_redefinition(const InstanceKlass* ik, const InstanceKlass* scratch_klass) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->has_been_redefined(), \"invariant\");\n+  assert(scratch_klass != nullptr, \"invariant\");\n+  assert(scratch_klass->is_scratch_class(), \"invariant\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+  const bool klass_has_sticky_bit = JfrTraceId::has_sticky_bit(ik);\n+  if (klass_has_sticky_bit) {\n+    JfrTraceIdLoadBarrier::enqueue(ik);\n+  }\n+\n+  const Array<Method*>* new_methods = ik->methods();\n+  assert(new_methods != nullptr, \"invariant\");\n+  const Array<Method*>* old_methods = scratch_klass->methods();\n+  assert(old_methods != nullptr, \"invariant\");\n+\n+  const int new_methods_len = new_methods->length(); \/\/ Can be shorter, equal to, or longer than old methods length.\n+  const int len = MIN2(new_methods_len, old_methods->length());\n+\n+  for (int i = 0; i < len; ++i) {\n+    const Method* const nm = new_methods->at(i);\n+    assert(nm != nullptr, \"invariant\");\n+    const Method* const om = scratch_klass->method_with_orig_idnum(nm->orig_method_idnum());\n+    assert(om != nullptr, \"invariant\");\n+    assert(nm != om, \"invariant\");\n+    assert(om->is_old(), \"invariant\");\n+    assert(nm->orig_method_idnum() == om->orig_method_idnum(), \"invariant\");\n+    assert(nm->name() == om->name() && nm->signature() == om->signature(), \"invariant\");\n+\n+    if (nm->trace_flags() == om->trace_flags()) {\n+      continue;\n+    }\n+\n+    const bool is_blessed = IS_METHOD_BLESSED(nm);\n+\n+    \/\/ Copy the old method trace flags under a safepoint.\n+    nm->copy_trace_flags(om);\n+\n+    assert(nm->trace_flags() == om->trace_flags(), \"invariant\");\n+\n+    if (is_blessed) {\n+      BLESS_METHOD(nm);\n+      assert(IS_METHOD_BLESSED(nm), \"invariant\");\n+    }\n+  }\n+\n+  \/\/ A retransformed\/redefined klass carrying the sticky bit\n+  \/\/ needs additional processing by the JfrMethodTracer subsystem.\n+  if (klass_has_sticky_bit) {\n+    assert(JfrMethodTracer::in_use(), \"invariant\");\n+    JfrMethodTracer::on_klass_redefinition(ik, JfrTraceId::has_timing_bit(scratch_klass));\n@@ -159,1 +170,0 @@\n-  assert(!JfrTraceId::has_timing_bit(ik), \"invariant\");\n@@ -161,0 +171,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTraceTagging.cpp","additions":88,"deletions":77,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  static void tag_dynamic(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n@@ -46,2 +45,2 @@\n-  static void tag_sticky(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n-  static void tag_timing(const InstanceKlass* ik);\n+  static void tag_sticky(const GrowableArray<JfrTracedMethod>* methods);\n+  static void tag_sticky_enqueue(const InstanceKlass* ik);\n@@ -49,5 +48,4 @@\n-  static void set_dynamic_tag(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n-  static void set_dynamic_tag_for_sticky_bit(const InstanceKlass* ik);\n-  static void install_sticky_bit_for_retransform_klass(const InstanceKlass* existing_klass, const GrowableArray<JfrTracedMethod>* methods, bool timing);\n-  static void set_sticky_bit(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n-  static void clear_sticky_bit(const InstanceKlass* ik, bool dynamic_tag = true);\n+  static void clear_sticky(const InstanceKlass* ik, bool dynamic_tag = true);\n+  static void tag_sticky(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void tag_sticky_for_retransform_klass(const InstanceKlass* existing_klass, const InstanceKlass* scratch_klass, const GrowableArray<JfrTracedMethod>* methods, bool timing);\n+  static void on_klass_redefinition(const InstanceKlass* ik, const InstanceKlass* scratch_klass);\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTraceTagging.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -1178,1 +1181,0 @@\n-      JFR_ONLY(k_new_method->copy_trace_flags(k_old_method->trace_flags());)\n@@ -4409,1 +4411,1 @@\n-  JFR_ONLY(ON_KLASS_REDEFINITION(the_class, current);)\n+  JFR_ONLY(Jfr::on_klass_redefinition(the_class, scratch_class);)\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-    JFR_ONLY(Jfr::check_and_process_sample_request(thread);)\n@@ -164,0 +163,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(thread);)\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                \/\/ assert false : msg;\n+                assert false : msg;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}