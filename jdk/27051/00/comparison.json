{"files":[{"patch":"@@ -113,0 +113,1 @@\n+                                             size_t page_size,\n@@ -118,1 +119,1 @@\n-    return ReservedSpace(base, size, alignment, os::vm_page_size(), exec, false \/* special *\/);\n+    return ReservedSpace(base, size, alignment, page_size, exec, false \/* special *\/);\n@@ -191,1 +192,1 @@\n-  return reserve_memory(requested_address, size, alignment, executable, mem_tag);\n+  return reserve_memory(requested_address, size, alignment, page_size, executable, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+                                      size_t page_size,\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @summary Run tests with G1\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.G1\n+ * @run driver TestTransparentHugePagesHeap G1\n+*\/\n+\/*\n+ * @test id=Parallel\n+ * @summary Run tests with Parallel\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Parallel\n+ * @run driver TestTransparentHugePagesHeap Parallel\n+*\/\n+\/*\n+ * @test id=Serial\n+ * @summary Run tests with Serial\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Serial\n+ * @run driver TestTransparentHugePagesHeap Serial\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.os.linux.HugePageConfiguration;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+import jtreg.SkippedException;\n+\n+\/\/ We verify that the heap can be backed by THP by looking at the\n+\/\/ THPeligible field for the heap section in \/proc\/self\/smaps. This\n+\/\/ field indicates if a mapping can use THP.\n+\/\/ THP mode 'always': this field is 1 whenever huge pages can be used\n+\/\/ THP mode 'madvise': this field is 1 if the mapping has been madvised\n+\/\/ as MADV_HUGEPAGE. In the JVM that should happen when the flag\n+\/\/ -XX:+UseTransparentHugePages is specified.\n+\/\/\n+\/\/ Note: we don't verify if the heap is backed by huge pages because we\n+\/\/ can't know if the underlying system have any available.\n+public class TestTransparentHugePagesHeap {\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ To be able to detect large page use (esp. THP) somewhat reliably, we\n+        \/\/  need at least kernel 3.8 to get the \"VmFlags\" tag in smaps.\n+        \/\/ (Note: its still good we started the VM at least since this serves as a nice\n+        \/\/  test for all manners of large page options).\n+        if (Platform.getOsVersionMajor() < 3 ||\n+            (Platform.getOsVersionMajor() == 3 && Platform.getOsVersionMinor() < 8)) {\n+            throw new SkippedException(\"Kernel older than 3.8 - skipping this test.\");\n+        }\n+\n+        final HugePageConfiguration hugePageConfiguration = HugePageConfiguration.readFromOS();\n+        if (!hugePageConfiguration.supportsTHP()) {\n+            throw new SkippedException(\"THP is turned off\");\n+        }\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\"-XX:+Use\" + args[0] + \"GC\", \"-Xmx128m\", \"-Xms128m\", \"-Xlog:pagesize:thp-%p.log\", \"-XX:+UseTransparentHugePages\", VerifyTHPEnabledForHeap.class.getName());\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    class VerifyTHPEnabledForHeap {\n+\n+        public static void main(String args[]) throws Exception {\n+            String heapAddress = readHeapAddressInLog();\n+            Path smaps = makeSmapsCopy();\n+\n+            final Pattern heapSection = Pattern.compile(\"^\" + heapAddress + \".*\");\n+            final Pattern thpEligible = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n+\n+            Scanner smapsFile = new Scanner(smaps);\n+            while (smapsFile.hasNextLine()) {\n+                Matcher heapMatcher = heapSection.matcher(smapsFile.nextLine());\n+\n+                if (heapMatcher.matches()) {\n+                    \/\/ Found the first heap section, verify that it is THP eligible\n+                    while (smapsFile.hasNextLine()) {\n+                        Matcher m = thpEligible.matcher(smapsFile.nextLine());\n+                        if (m.matches()) {\n+                            if (Integer.parseInt(m.group(1)) == 1) {\n+                                \/\/ THPeligible is 1, heap can be backed by huge pages\n+                                return;\n+                            }\n+\n+                            throw new RuntimeException(\"First heap section at 0x\" + heapAddress + \" is not THPeligible\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ Failed to verify THP for heap\n+            throw new RuntimeException(\"Could not find heap section in smaps file\");\n+        }\n+\n+        private static String readHeapAddressInLog() throws Exception {\n+            final Pattern heapAddress = Pattern.compile(\".* Heap: .*base=(0x[0-9A-Fa-f]*).*\");\n+\n+            Scanner logFile = new Scanner(Paths.get(\"thp-\" + ProcessHandle.current().pid() + \".log\"));\n+            while (logFile.hasNextLine()) {\n+                Matcher m = heapAddress.matcher(logFile.nextLine());\n+                if (m.matches()) {\n+                    return Long.toHexString(Long.decode(m.group(1)));\n+                }\n+            }\n+            throw new RuntimeException(\"Failed to parse heap address, failing test\");\n+        }\n+\n+        private static Path makeSmapsCopy() throws Exception {\n+            Path src = Paths.get(\"\/proc\/self\/smaps\");\n+            Path dest = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \".txt\");\n+            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);\n+            return dest;\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"}]}