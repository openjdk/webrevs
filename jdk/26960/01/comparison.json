{"files":[{"patch":"@@ -85,8 +85,4 @@\n-  u4 elementIndex;\n-  do {\n-    elementIndex = Atomic::load_acquire(&_head);\n-    if (elementIndex >= _capacity) {\n-      return false;\n-    }\n-  } while (Atomic::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n-  _data[elementIndex] = request;\n+  if (_head >= _capacity) {\n+    return false;\n+  }\n+  _data[_head++] = request;\n@@ -104,1 +100,1 @@\n-  return Atomic::load_acquire(&_head);\n+  return _head;\n@@ -108,1 +104,1 @@\n-  Atomic::release_store(&_head, size);\n+  _head = size;\n@@ -112,1 +108,1 @@\n-  return Atomic::load_acquire(&_capacity);\n+  return _capacity;\n@@ -116,1 +112,1 @@\n-  if (capacity == Atomic::load(&_capacity)) {\n+  if (capacity == _capacity) {\n@@ -129,1 +125,1 @@\n-  Atomic::release_store(&_capacity, capacity);\n+  _capacity = capacity;\n@@ -133,1 +129,1 @@\n-  return Atomic::load_acquire(&_head) == 0;\n+  return _head == 0;\n@@ -137,1 +133,1 @@\n-  return Atomic::load(&_lost_samples);\n+  return _lost_samples;\n@@ -146,1 +142,1 @@\n-  Atomic::inc(&_lost_samples_due_to_queue_full);\n+  _lost_samples_due_to_queue_full++;\n@@ -154,1 +150,3 @@\n-  return Atomic::xchg(&_lost_samples_due_to_queue_full, (u4)0);\n+  u4 lost = _lost_samples_due_to_queue_full;\n+  _lost_samples_due_to_queue_full = 0;\n+  return lost;\n@@ -162,1 +160,1 @@\n-  Atomic::release_store(&_head, (u4)0);\n+  _head = 0;\n@@ -170,3 +168,2 @@\n-  u4 capacity = Atomic::load(&_capacity);\n-  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n-    float ratio = (float)lost_samples_due_to_queue_full \/ (float)capacity;\n+  if (_capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n+    float ratio = (float)lost_samples_due_to_queue_full \/ (float)_capacity;\n@@ -184,1 +181,1 @@\n-      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, capacity * factor);\n+      u4 new_capacity = MIN2(CPU_TIME_QUEUE_MAX_CAPACITY, _capacity * factor);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -46,0 +46,7 @@\n+\/\/ The lock in question is the tri-state CPU time JFR lock in JfrThreadLocal\n+\/\/ This allows us to skip most of the atomic accesses and memory barriers,\n+\/\/ holding a lock acts as a memory barrier\n+\/\/ Only the _lost_samples property is atomic, as it can be accessed even after\n+\/\/ acquiring the lock failed.\n+\/\/ Important to note is that the queue is also only accessed under lock in signal\n+\/\/ handlers.\n@@ -48,4 +55,0 @@\n-  \/\/ the default queue capacity, scaled if the sampling period is smaller than 10ms\n-  \/\/ when the thread is started\n-  static const u4 CPU_TIME_QUEUE_CAPACITY = 500;\n-\n@@ -53,1 +56,1 @@\n-  volatile u4 _capacity;\n+  u4 _capacity;\n@@ -55,1 +58,1 @@\n-  volatile u4 _head;\n+  u4 _head;\n@@ -57,0 +60,1 @@\n+  \/\/ the only property accessible without a lock\n@@ -58,1 +62,2 @@\n-  volatile u4 _lost_samples_due_to_queue_full;\n+\n+  u4 _lost_samples_due_to_queue_full;\n@@ -85,0 +90,1 @@\n+  \/\/ the only method callable without holding a lock\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}