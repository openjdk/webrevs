{"files":[{"patch":"@@ -774,4 +774,0 @@\n-  NameSigHash*  _next;             \/\/ Next entry in hash table\n-};\n-\n-static const int HASH_ROW_SIZE = 256;\n@@ -779,7 +775,1 @@\n-static unsigned int hash(const Symbol* name, const Symbol* sig) {\n-  unsigned int raw_hash = 0;\n-  raw_hash += ((unsigned int)(uintptr_t)name) >> (LogHeapWordSize + 2);\n-  raw_hash += ((unsigned int)(uintptr_t)sig) >> LogHeapWordSize;\n-\n-  return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;\n-}\n+  static const int HASH_ROW_SIZE = 256;\n@@ -787,0 +777,3 @@\n+  NameSigHash(Symbol* name, Symbol* sig) :\n+    _name(name),\n+    _sig(sig) {}\n@@ -788,19 +781,2 @@\n-static void initialize_hashtable(NameSigHash** table) {\n-  memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);\n-}\n-\/\/ Return false if the name\/sig combination is found in table.\n-\/\/ Return true if no duplicate is found. And name\/sig is added as a new entry in table.\n-\/\/ The old format checker uses heap sort to find duplicates.\n-\/\/ NOTE: caller should guarantee that GC doesn't happen during the life cycle\n-\/\/ of table since we don't expect Symbol*'s to move.\n-static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {\n-  assert(name != nullptr, \"name in constant pool is null\");\n-\n-  \/\/ First lookup for duplicates\n-  int index = hash(name, sig);\n-  NameSigHash* entry = table[index];\n-  while (entry != nullptr) {\n-    if (entry->_name == name && entry->_sig == sig) {\n-      return false;\n-    }\n-    entry = entry->_next;\n+  static unsigned int hash(NameSigHash const& namesig) {\n+    return namesig._name->identity_hash() ^ namesig._sig->identity_hash();\n@@ -809,8 +785,5 @@\n-  \/\/ No duplicate is found, allocate a new entry and fill it.\n-  entry = new NameSigHash();\n-  entry->_name = name;\n-  entry->_sig = sig;\n-\n-  \/\/ Insert into hash table\n-  entry->_next = table[index];\n-  table[index] = entry;\n+  static bool equals(NameSigHash const& e0, NameSigHash const& e1) {\n+    return (e0._name == e1._name) &&\n+          (e0._sig  == e1._sig);\n+  }\n+};\n@@ -818,2 +791,4 @@\n-  return true;\n-}\n+using NameSigHashtable = ResourceHashtable<NameSigHash, int,\n+                                           NameSigHash::HASH_ROW_SIZE,\n+                                           AnyObj::RESOURCE_AREA, mtInternal,\n+                                           &NameSigHash::hash, &NameSigHash::equals>;\n@@ -885,16 +860,9 @@\n-    NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                                                 NameSigHash*,\n-                                                                 HASH_ROW_SIZE);\n-    initialize_hashtable(interface_names);\n-    bool dup = false;\n-    const Symbol* name = nullptr;\n-    {\n-      debug_only(NoSafepointVerifier nsv;)\n-      for (index = 0; index < itfs_len; index++) {\n-        const InstanceKlass* const k = _local_interfaces->at(index);\n-        name = k->name();\n-        \/\/ If no duplicates, add (name, nullptr) in hashtable interface_names.\n-        if (!put_after_lookup(name, nullptr, interface_names)) {\n-          dup = true;\n-          break;\n-        }\n+    \/\/ Set containing interface names\n+    ResourceHashtable<Symbol*, int>* interface_names = new ResourceHashtable<Symbol*, int>();\n+    for (index = 0; index < itfs_len; index++) {\n+      const InstanceKlass* const k = _local_interfaces->at(index);\n+      Symbol* interface_name = k->name();\n+      \/\/ If no duplicates, add (name, nullptr) in hashtable interface_names.\n+      if (!interface_names->put(interface_name, 0)) {\n+        classfile_parse_error(\"Duplicate interface name \\\"%s\\\" in class file %s\",\n+                               interface_name->as_C_string(), THREAD);\n@@ -903,4 +871,0 @@\n-    if (dup) {\n-      classfile_parse_error(\"Duplicate interface name \\\"%s\\\" in class file %s\",\n-                             name->as_C_string(), THREAD);\n-    }\n@@ -1624,16 +1588,9 @@\n-    NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(\n-      THREAD, NameSigHash*, HASH_ROW_SIZE);\n-    initialize_hashtable(names_and_sigs);\n-    bool dup = false;\n-    const Symbol* name = nullptr;\n-    const Symbol* sig = nullptr;\n-    {\n-      debug_only(NoSafepointVerifier nsv;)\n-      for (int i = 0; i < _temp_field_info->length(); i++) {\n-        name = _temp_field_info->adr_at(i)->name(_cp);\n-        sig = _temp_field_info->adr_at(i)->signature(_cp);\n-        \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n-        if (!put_after_lookup(name, sig, names_and_sigs)) {\n-          dup = true;\n-          break;\n-        }\n+    \/\/ Set containing name-signature pairs\n+    NameSigHashtable* names_and_sigs = new NameSigHashtable();\n+    for (int i = 0; i < _temp_field_info->length(); i++) {\n+      NameSigHash name_and_sig(_temp_field_info->adr_at(i)->name(_cp),\n+                               _temp_field_info->adr_at(i)->signature(_cp));\n+      \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n+      if(!names_and_sigs->put(name_and_sig, 0)) {\n+        classfile_parse_error(\"Duplicate field name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n+                               name_and_sig._name->as_C_string(), name_and_sig._sig->as_klass_external_name(), THREAD);\n@@ -1642,4 +1599,0 @@\n-    if (dup) {\n-      classfile_parse_error(\"Duplicate field name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n-                             name->as_C_string(), sig->as_klass_external_name(), THREAD);\n-    }\n@@ -2874,17 +2827,9 @@\n-      NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(\n-        THREAD, NameSigHash*, HASH_ROW_SIZE);\n-      initialize_hashtable(names_and_sigs);\n-      bool dup = false;\n-      const Symbol* name = nullptr;\n-      const Symbol* sig = nullptr;\n-      {\n-        debug_only(NoSafepointVerifier nsv;)\n-        for (int i = 0; i < length; i++) {\n-          const Method* const m = _methods->at(i);\n-          name = m->name();\n-          sig = m->signature();\n-          \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n-          if (!put_after_lookup(name, sig, names_and_sigs)) {\n-            dup = true;\n-            break;\n-          }\n+      \/\/ Set containing name-signature pairs\n+      NameSigHashtable* names_and_sigs = new NameSigHashtable();\n+      for (int i = 0; i < length; i++) {\n+        const Method* const m = _methods->at(i);\n+        NameSigHash name_and_sig(m->name(), m->signature());\n+        \/\/ If no duplicates, add name\/signature in hashtable names_and_sigs.\n+        if(!names_and_sigs->put(name_and_sig, 0)) {\n+          classfile_parse_error(\"Duplicate method name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n+                                 name_and_sig._name->as_C_string(), name_and_sig._sig->as_klass_external_name(), THREAD);\n@@ -2893,4 +2838,0 @@\n-      if (dup) {\n-        classfile_parse_error(\"Duplicate method name \\\"%s\\\" with signature \\\"%s\\\" in class file %s\",\n-                               name->as_C_string(), sig->as_klass_external_name(), THREAD);\n-      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":42,"deletions":101,"binary":false,"changes":143,"status":"modified"}]}