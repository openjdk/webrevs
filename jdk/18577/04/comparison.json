{"files":[{"patch":"@@ -534,1 +534,1 @@\n-    VPointer align_to_ref_p(mem_ref, _vloop);\n+    const VPointer& align_to_ref_p = vpointer(mem_ref);\n@@ -540,1 +540,1 @@\n-        VPointer p2(s, _vloop);\n+        const VPointer& p2 = vpointer(s);\n@@ -596,1 +596,1 @@\n-    VPointer p1(s1, _vloop);\n+    const VPointer& p1 = vpointer(s1);\n@@ -600,1 +600,1 @@\n-        VPointer p2(s2, _vloop);\n+        const VPointer& p2 = vpointer(s2);\n@@ -621,1 +621,1 @@\n-      VPointer p(s, _vloop);\n+      const VPointer& p = vpointer(s);\n@@ -644,1 +644,1 @@\n-        VPointer p(s, _vloop);\n+        const VPointer& p = vpointer(s);\n@@ -717,1 +717,1 @@\n-  VPointer align_to_ref_p(mem_ref, _vloop);\n+  const VPointer& align_to_ref_p = vpointer(mem_ref);\n@@ -878,2 +878,2 @@\n-  VPointer p1(s1->as_Mem(), _vloop);\n-  VPointer p2(s2->as_Mem(), _vloop);\n+  const VPointer& p1 = vpointer(s1->as_Mem());\n+  const VPointer& p2 = vpointer(s2->as_Mem());\n@@ -1640,1 +1640,1 @@\n-  VPointer mem_ref_p(mem_ref, _vloop);\n+  const VPointer& mem_ref_p = vpointer(mem_ref);\n@@ -3313,1 +3313,1 @@\n-  VPointer p(s, _vloop);\n+  const VPointer& p = vpointer(s);\n@@ -3416,1 +3416,1 @@\n-  VPointer align_to_ref_p(align_to_ref, _vloop);\n+  const VPointer& align_to_ref_p = vpointer(align_to_ref);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-  \/\/ VLoop Accessors\n+  \/\/ VLoop accessors\n@@ -437,1 +437,1 @@\n-  \/\/ VLoopReductions Accessors\n+  \/\/ VLoopReductions accessors\n@@ -446,1 +446,1 @@\n-  \/\/ VLoopMemorySlices Accessors\n+  \/\/ VLoopMemorySlices accessors\n@@ -451,1 +451,1 @@\n-  \/\/ VLoopBody Accessors\n+  \/\/ VLoopBody accessors\n@@ -460,1 +460,1 @@\n-  \/\/ VLoopTypes Accessors\n+  \/\/ VLoopTypes accessors\n@@ -485,1 +485,1 @@\n-  \/\/ VLoopDependencyGraph Accessors\n+  \/\/ VLoopDependencyGraph accessors\n@@ -498,0 +498,5 @@\n+  \/\/ VLoopVPointer accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  flags(POINTER_ANALYSIS,     \"Trace VPointer\") \\\n+  flags(POINTER_ANALYSIS,     \"Trace VPointer (verbose)\") \\\n@@ -38,0 +38,1 @@\n+  flags(POINTERS,             \"Trace VLoopPointers\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,13 @@\n+#ifndef PRODUCT\n+static void print_con_or_idx(const Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(   0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%4d)\", val);\n+  } else {\n+    tty->print(\"[%4d]\", n->_idx);\n+  }\n+}\n+#endif\n+\n@@ -164,0 +177,2 @@\n+  _vpointers.compute_and_cache();\n+\n@@ -169,0 +184,43 @@\n+void VLoopVPointers::compute_and_cache() {\n+  \/\/ Count\n+  _vpointers_length = 0;\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    _vpointers_length++;\n+  });\n+\n+  \/\/ Allocate\n+  uint bytes = _vpointers_length * sizeof(VPointer);\n+  _vpointers = (VPointer*)_arena->Amalloc(bytes);\n+\n+  \/\/ Compute and Cache\n+  int pointers_idx = 0;\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    \/\/ Placement new: construct directly into the array.\n+    ::new (&_vpointers[pointers_idx]) VPointer(mem, _vloop);\n+    _bb_idx_to_vpointer.at_put(bb_idx, pointers_idx);\n+    pointers_idx++;\n+  });\n+\n+  NOT_PRODUCT( if (_vloop.is_trace_vpointers()) { print(); } )\n+}\n+\n+const VPointer& VLoopVPointers::vpointer(const MemNode* mem) const {\n+  assert(mem != nullptr && _vloop.in_bb(mem), \"only mem in loop\");\n+  int bb_idx = _body.bb_idx(mem);\n+  int pointers_idx = _bb_idx_to_vpointer.at(bb_idx);\n+  assert(0 <= pointers_idx && pointers_idx < _vpointers_length, \"valid range\");\n+  return _vpointers[pointers_idx];\n+}\n+\n+#ifndef PRODUCT\n+void VLoopVPointers::print() const {\n+  tty->print_cr(\"\\nVLoopVPointers::print:\");\n+\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    const VPointer& p = vpointer(mem);\n+    tty->print(\"  \");\n+    p.print();\n+  });\n+}\n+#endif\n+\n@@ -196,1 +254,1 @@\n-      VPointer p1(n1, _vloop);\n+      const VPointer& p1 = _vpointers.vpointer(n1);\n@@ -204,1 +262,1 @@\n-        VPointer p2(n2, _vloop);\n+        const VPointer& p2 = _vpointers.vpointer(n2);\n@@ -707,2 +765,0 @@\n-\/\/ Function for printing the fields of a VPointer\n-void VPointer::print() {\n@@ -710,9 +766,15 @@\n-  tty->print(\"base: [%d]  adr: [%d]  scale: %d  offset: %d\",\n-             _base != nullptr ? _base->_idx : 0,\n-             _adr  != nullptr ? _adr->_idx  : 0,\n-             _scale, _offset);\n-  if (_invar != nullptr) {\n-    tty->print(\"  invar: [%d]\", _invar->_idx);\n-  }\n-  tty->cr();\n-#endif\n+\/\/ Function for printing the fields of a VPointer\n+void VPointer::print() const {\n+  tty->print(\"VPointer[mem: %4d %10s, \", _mem->_idx, _mem->Name());\n+  tty->print(\"base: %4d, \", _base != nullptr ? _base->_idx : 0);\n+  tty->print(\"adr: %4d, \", _adr != nullptr ? _adr->_idx : 0);\n+\n+  tty->print(\" base\");\n+  print_con_or_idx(_base);\n+\n+  tty->print(\" + offset(%4d)\", _offset);\n+\n+  tty->print(\" + invar\");\n+  print_con_or_idx(_invar);\n+\n+  tty->print_cr(\" + scale(%4d) * iv]\", _scale);\n@@ -720,0 +782,1 @@\n+#endif\n@@ -1486,11 +1549,0 @@\n-static void print_con_or_idx(const Node* n) {\n-  if (n == nullptr) {\n-    tty->print(\"(0)\");\n-  } else if (n->is_ConI()) {\n-    jint val = n->as_ConI()->get_int();\n-    tty->print(\"(%d)\", val);\n-  } else {\n-    tty->print(\"[%d]\", n->_idx);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":76,"deletions":24,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class VPointer;\n+\n@@ -157,0 +159,4 @@\n+  bool is_trace_vpointers() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::POINTERS);\n+  }\n+\n@@ -359,0 +365,10 @@\n+  template<typename Callback>\n+  void for_each_mem(Callback callback) const {\n+    for (int i = 0; i < _body.length(); i++) {\n+      MemNode* mem = _body.at(i)->isa_Mem();\n+      if (mem != nullptr && _vloop.in_bb(mem)) {\n+        callback(mem, i);\n+      }\n+    }\n+  }\n+\n@@ -448,0 +464,34 @@\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ We compute and cache the VPointer for every load and store.\n+class VLoopVPointers : public StackObj {\n+private:\n+  Arena*                   _arena;\n+  const VLoop&             _vloop;\n+  const VLoopBody&         _body;\n+\n+  \/\/ Array of cached pointers\n+  VPointer* _vpointers;\n+  int _vpointers_length;\n+\n+  \/\/ Map bb_idx -> index in _vpointers. -1 if not mapped.\n+  GrowableArray<int> _bb_idx_to_vpointer;\n+\n+public:\n+  VLoopVPointers(Arena* arena,\n+                 const VLoop& vloop,\n+                 const VLoopBody& body) :\n+    _arena(arena),\n+    _vloop(vloop),\n+    _body(body),\n+    _vpointers(nullptr),\n+    _bb_idx_to_vpointer(arena,\n+                        vloop.estimated_body_length(),\n+                        vloop.estimated_body_length(),\n+                        -1) {}\n+  NONCOPYABLE(VLoopVPointers);\n+\n+  void compute_and_cache();\n+  const VPointer& vpointer(const MemNode* mem) const;\n+  NOT_PRODUCT( void print() const; )\n+};\n+\n@@ -464,0 +514,1 @@\n+  const VLoopVPointers&    _vpointers;\n@@ -475,1 +526,2 @@\n-                       const VLoopMemorySlices& memory_slices) :\n+                       const VLoopMemorySlices& memory_slices,\n+                       const VLoopVPointers& pointers) :\n@@ -480,0 +532,1 @@\n+    _vpointers(pointers),\n@@ -573,0 +626,1 @@\n+  VLoopVPointers       _vpointers;\n@@ -584,1 +638,2 @@\n-    _dependency_graph(&_arena, vloop, _body, _memory_slices)\n+    _vpointers       (&_arena, vloop, _body),\n+    _dependency_graph(&_arena, vloop, _body, _memory_slices, _vpointers)\n@@ -598,0 +653,1 @@\n+  const VLoopVPointers& vpointers()              const { return _vpointers; }\n@@ -681,1 +737,1 @@\n-  bool invar_equals(VPointer& q) {\n+  bool invar_equals(const VPointer& q) const {\n@@ -689,1 +745,1 @@\n-  int cmp(VPointer& q) {\n+  int cmp(const VPointer& q) const {\n@@ -701,1 +757,1 @@\n-  bool overlap_possible_with_any_in(Node_List* p) {\n+  bool overlap_possible_with_any_in(const Node_List* p) const {\n@@ -715,3 +771,3 @@\n-  bool not_equal(VPointer& q)     { return not_equal(cmp(q)); }\n-  bool equal(VPointer& q)         { return equal(cmp(q)); }\n-  bool comparable(VPointer& q)    { return comparable(cmp(q)); }\n+  bool not_equal(const VPointer& q)  const { return not_equal(cmp(q)); }\n+  bool equal(const VPointer& q)      const { return equal(cmp(q)); }\n+  bool comparable(const VPointer& q) const { return comparable(cmp(q)); }\n@@ -722,1 +778,1 @@\n-  void print();\n+  NOT_PRODUCT( void print() const; )\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":65,"deletions":9,"binary":false,"changes":74,"status":"modified"}]}