{"files":[{"patch":"@@ -63,74 +63,0 @@\n-    static final class Concat1 extends StringConcatBase {\n-        Concat1(String[] constants) {\n-            super(constants);\n-        }\n-\n-        @ForceInline\n-        String concat0(String value) {\n-            int length = stringSize(this.length, value);\n-            byte coder = (byte) (this.coder | value.coder());\n-            byte[] buf = newArray(length << coder);\n-            String prefix = constants[0];\n-            prefix.getBytes(buf, 0, coder);\n-            value.getBytes(buf, prefix.length(), coder);\n-            constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n-            return new String(buf, coder);\n-        }\n-\n-        @ForceInline\n-        String concat(boolean value) {\n-            int length = stringSize(this.length, value);\n-            String suffix = constants[1];\n-            length -= suffix.length();\n-            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n-            prepend(length, coder, buf, value, constants[0]);\n-            return new String(buf, coder);\n-        }\n-\n-        @ForceInline\n-        String concat(char value) {\n-            int length = stringSize(this.length, value);\n-            byte coder = (byte) (this.coder | stringCoder(value));\n-            String suffix = constants[1];\n-            length -= suffix.length();\n-            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n-            prepend(length, coder, buf, value, constants[0]);\n-            return new String(buf, coder);\n-        }\n-\n-        @ForceInline\n-        String concat(int value) {\n-            int length = stringSize(this.length, value);\n-            String suffix = constants[1];\n-            length -= suffix.length();\n-            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n-            prepend(length, coder, buf, value, constants[0]);\n-            return new String(buf, coder);\n-        }\n-\n-        @ForceInline\n-        String concat(long value) {\n-            int length = stringSize(this.length, value);\n-            String suffix = constants[1];\n-            length -= suffix.length();\n-            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n-            prepend(length, coder, buf, value, constants[0]);\n-            return new String(buf, coder);\n-        }\n-\n-        @ForceInline\n-        String concat(Object value) {\n-            return concat0(stringOf(value));\n-        }\n-\n-        @ForceInline\n-        String concat(float value) {\n-            return concat0(Float.toString(value));\n-        }\n-\n-        @ForceInline\n-        String concat(double value) {\n-            return concat0(Double.toString(value));\n-        }\n-    }\n-\n@@ -408,1 +334,1 @@\n-    static String simpleConcat(Object first, Object second) {\n+    static String concat(Object first, Object second) {\n@@ -798,2 +724,0 @@\n-        if (prefix == null) prefix = \"null\";\n-        if (suffix == null) suffix = \"null\";\n@@ -802,0 +726,90 @@\n+\n+    @ForceInline\n+    static String concat(String prefix, float value, String suffix) {\n+        return concat0(prefix, stringOf(value), suffix);\n+    }\n+\n+    @ForceInline\n+    static String concat(String prefix, double value, String suffix) {\n+        return concat0(prefix, stringOf(value), suffix);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation between 3 argument. Added for startup\n+     * performance, but also demonstrates the code that would be emitted by\n+     * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}\n+     * for 3 arguments.\n+     *\n+     * @param prefix         prefix argument\n+     * @param value        value argument\n+     * @param suffix        suffix argument\n+     * @return String       resulting string\n+     *\/\n+    @ForceInline\n+    static String concat(String prefix, int value, String suffix) {\n+        byte coder = (byte) (prefix.coder() | suffix.coder());\n+        int length = prefix.length() + DecimalDigits.stringSize(value);\n+        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+        prepend(length, coder, buf, value, prefix);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation between 3 argument. Added for startup\n+     * performance, but also demonstrates the code that would be emitted by\n+     * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}\n+     * for 3 arguments.\n+     *\n+     * @param prefix         prefix argument\n+     * @param value        value argument\n+     * @param suffix        suffix argument\n+     * @return String       resulting string\n+     *\/\n+    @ForceInline\n+    static String concat(String prefix, long value, String suffix) {\n+        byte coder = (byte) (prefix.coder() | suffix.coder());\n+        int length = prefix.length() + DecimalDigits.stringSize(value);\n+        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+        prepend(length, coder, buf, value, prefix);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation between 3 argument. Added for startup\n+     * performance, but also demonstrates the code that would be emitted by\n+     * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}\n+     * for 3 arguments.\n+     *\n+     * @param prefix         prefix argument\n+     * @param value        value argument\n+     * @param suffix        suffix argument\n+     * @return String       resulting string\n+     *\/\n+    @ForceInline\n+    static String concat(String prefix, char value, String suffix) {\n+        byte coder = (byte) (prefix.coder() | suffix.coder() | stringCoder(value));\n+        int length = prefix.length() + 1;\n+        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+        prepend(length, coder, buf, value, prefix);\n+        return new String(buf, coder);\n+    }\n+\n+    \/**\n+     * Perform a simple concatenation between 3 argument. Added for startup\n+     * performance, but also demonstrates the code that would be emitted by\n+     * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}\n+     * for 3 arguments.\n+     *\n+     * @param prefix         prefix argument\n+     * @param value        value argument\n+     * @param suffix        suffix argument\n+     * @return String       resulting string\n+     *\/\n+    @ForceInline\n+    static String concat(String prefix, boolean value, String suffix) {\n+        byte coder = (byte) (prefix.coder() | suffix.coder());\n+        int length = stringSize(prefix.length(), value);\n+        byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+        prepend(length, coder, buf, value, prefix);\n+        return new String(buf, coder);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":91,"deletions":77,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2641,4 +2641,0 @@\n-            public Object stringConcat1(String[] constants) {\n-                return new StringConcatHelper.Concat1(constants);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -494,0 +494,4 @@\n+\n+        String prefix = constants[0];\n+        MethodHandle mh;\n+        var paramType0 = mt.parameterType(0);\n@@ -495,1 +499,0 @@\n-            String prefix = constants[0];\n@@ -499,2 +502,4 @@\n-                    return unaryConcat(mt.parameterType(0));\n-                } else if (!mt.hasPrimitives()) {\n+                    return unaryConcat(paramType0);\n+                }\n+\n+                if (!mt.hasPrimitives()) {\n@@ -502,7 +507,13 @@\n-                } \/\/ else fall-through\n-            } else if (suffix.isEmpty() && !mt.hasPrimitives()) {\n-                \/\/ Non-primitive argument\n-                return MethodHandles.insertArguments(simpleConcat(), 0, prefix);\n-            } \/\/ fall-through if there's both a prefix and suffix\n-        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix.isEmpty()\n-                && constants[0].isEmpty() && constants[1].isEmpty()) {\n+                }\n+            } else if (suffix.isEmpty()) {\n+                if (!mt.hasPrimitives()) {\n+                    \/\/ Non-primitive argument\n+                    return MethodHandles.insertArguments(simpleConcat(), 0, prefix);\n+                }\n+            }\n+\n+            mh = simpleConcat3(paramType0);\n+            mh = MethodHandles.insertArguments(mh, 2, suffix);\n+            return MethodHandles.insertArguments(mh, 0, prefix);\n+        } else if (paramCount == 2 && constants[1].isEmpty()) {\n+            var paramType1 = mt.parameterType(1);\n@@ -510,1 +521,15 @@\n-            return simpleConcat();\n+            if (!mt.hasPrimitives() && suffix.isEmpty() && prefix.isEmpty()) {\n+                return simpleConcat();\n+            }\n+\n+            if (suffix.isEmpty() && !paramType1.isPrimitive() && paramType1 == String.class) {\n+                \/\/ \"prefix\" + i + s\n+                mh = simpleConcat3(paramType0);\n+                return MethodHandles.insertArguments(mh, 0, prefix);\n+            }\n+\n+            if (prefix.isEmpty() && !paramType0.isPrimitive() && paramType0 == String.class) {\n+                \/\/ s + i + \"suffix\"\n+                mh = simpleConcat3(paramType1);\n+                return MethodHandles.insertArguments(mh, 2, suffix);\n+            }\n@@ -516,0 +541,20 @@\n+    static MethodHandle simpleConcat3(Class<?> paramType) {\n+        MethodHandle mh;\n+        if (paramType == byte.class || paramType == short.class || paramType == int.class) {\n+            mh = simpleConcat3int();\n+        } else if (paramType == long.class) {\n+            mh = simpleConcat3long();\n+        } else if (paramType == char.class) {\n+            mh = simpleConcat3char();\n+        } else if (paramType == boolean.class) {\n+            mh = simpleConcat3boolean();\n+        } else if (paramType == float.class) {\n+            mh = simpleConcat3float();\n+        } else if (paramType == double.class) {\n+            mh = simpleConcat3double();\n+        } else {\n+            mh = simpleConcat3();\n+        }\n+        return mh;\n+    }\n+\n@@ -899,1 +944,1 @@\n-            MethodHandle simpleConcat = JLA.stringConcatHelper(\"simpleConcat\",\n+            MethodHandle simpleConcat = JLA.stringConcatHelper(\"concat\",\n@@ -906,0 +951,77 @@\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_INT;\n+    private static MethodHandle simpleConcat3int() {\n+        MethodHandle mh = SIMPLE_CONCAT3_INT;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, int.class, String.class));\n+            SIMPLE_CONCAT3_INT = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_LONG;\n+    private static MethodHandle simpleConcat3long() {\n+        MethodHandle mh = SIMPLE_CONCAT3_LONG;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, long.class, String.class));\n+            SIMPLE_CONCAT3_LONG = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_BOOLEAN;\n+    private static MethodHandle simpleConcat3boolean() {\n+        MethodHandle mh = SIMPLE_CONCAT3_BOOLEAN;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, boolean.class, String.class));\n+            SIMPLE_CONCAT3_BOOLEAN = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_CHAR;\n+    private static MethodHandle simpleConcat3char() {\n+        MethodHandle mh = SIMPLE_CONCAT3_CHAR;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, char.class, String.class));\n+            SIMPLE_CONCAT3_CHAR = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_FLOAT;\n+    private static MethodHandle simpleConcat3float() {\n+        MethodHandle mh = SIMPLE_CONCAT3_FLOAT;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, float.class, String.class));\n+            SIMPLE_CONCAT3_FLOAT = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3_DOUBLE;\n+    private static MethodHandle simpleConcat3double() {\n+        MethodHandle mh = SIMPLE_CONCAT3_DOUBLE;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, double.class, String.class));\n+            SIMPLE_CONCAT3_DOUBLE = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n+    private @Stable static MethodHandle SIMPLE_CONCAT3;\n+    private static MethodHandle simpleConcat3() {\n+        MethodHandle mh = SIMPLE_CONCAT3;\n+        if (mh == null) {\n+            var simpleConcat = JLA.stringConcatHelper(\"concat\",\n+                    methodType(String.class, String.class, Object.class, String.class));\n+            SIMPLE_CONCAT3 = mh = simpleConcat.rebind();\n+        }\n+        return mh;\n+    }\n+\n@@ -1248,8 +1370,1 @@\n-            final MethodType concatArgs = erasedArgs(args);\n-\n-            \/\/ 1 argument use built-in method\n-            if (args.parameterCount() == 1) {\n-                Object concat1 = JLA.stringConcat1(constants);\n-                var handle = lookup.findVirtual(concat1.getClass(), METHOD_NAME, concatArgs);\n-                return handle.bindTo(concat1);\n-            }\n+            var concatArgs = erasedArgs(args);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":135,"deletions":20,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -460,2 +460,0 @@\n-    Object stringConcat1(String[] constants);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}