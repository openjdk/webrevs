{"files":[{"patch":"@@ -113,0 +113,3 @@\n+  typedef TESTSIZE (*cmpxchg_narrow_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result,\n+                                          int64_t scratch0, int64_t scratch1, int64_t scratch2);\n+\n@@ -115,0 +118,1 @@\n+  cmpxchg_narrow_func _narrow;\n@@ -122,1 +126,9 @@\n-    {\n+    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+        address entry = _masm.pc();\n+       _masm.cmpxchg_narrow_value(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n+                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n+                        \/*result*\/ c_rarg3, boolean_result, c_rarg4, c_rarg5, c_rarg6); \/* Uses also t0-t1, caller saved *\/\n+      _masm.mv(c_rarg0, c_rarg3);\n+      _masm.ret();\n+      _narrow = ((cmpxchg_narrow_func)entry);\n+    } else {\n@@ -154,0 +166,1 @@\n+      _func = ((cmpxchg_func)entry);\n@@ -156,1 +169,0 @@\n-    _func = ((cmpxchg_func)entry);\n@@ -164,1 +176,5 @@\n-    return _func(addr, expected, new_value, \/* dummy result *\/ 67);\n+    if (ASMSIZE == Assembler::int8 || ASMSIZE == Assembler::int16) {\n+      return _narrow(addr, expected, new_value, \/* dummy result *\/ 67, -1, -1, -1);\n+    } else {\n+      return _func(addr, expected, new_value, \/* dummy result *\/ 67);\n+    }\n@@ -274,107 +290,0 @@\n-template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n-static void run_concurrent_cmpxchg_tests() {\n-  volatile TESTSIZE data = 0;\n-  int num_threads = 4;\n-  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false); \/\/ variant 0, not bool ret\n-  auto incThread = [&](Thread* _current, int _id) {\n-    for (int i = 0; i < 10000; i++) {\n-      TESTSIZE oldvalue = _id + num_threads * i;\n-      TESTSIZE newvalue = oldvalue + 1;\n-      TESTSIZE ret;\n-      do {\n-        ret = cmpxchg.cmpxchg((intptr_t)&data, oldvalue, newvalue);\n-      } while (ret != oldvalue);\n-    }\n-  };\n-  TestThreadGroup<decltype(incThread)> ttg(incThread, num_threads);\n-  ttg.doit();\n-  ttg.join();\n-  ASSERT_EQ(data, (TESTSIZE)(num_threads*10000));\n-}\n-\n-template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n-static void run_concurrent_alt_cmpxchg_tests() {\n-  volatile TESTSIZE data = 0;\n-  int num_threads = 4;\n-  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false); \/\/ variant 0, not bool ret\n-  auto incThread = [&](Thread* _current, int _id) {\n-    for (int i = 0; i < 10000; i++) {\n-      TESTSIZE oldvalue;\n-      TESTSIZE ret = 0;\n-      do {\n-        oldvalue = ret;\n-        TESTSIZE newvalue = oldvalue + 1;\n-        ret = cmpxchg.cmpxchg((intptr_t)&data, oldvalue, newvalue);\n-      } while (ret != oldvalue);\n-    }\n-  };\n-  TestThreadGroup<decltype(incThread)> ttg(incThread, num_threads);\n-  ttg.doit();\n-  ttg.join();\n-  ASSERT_EQ(data, (TESTSIZE)(num_threads*10000));\n-}\n-\n-TEST_VM(RiscV, cmpxchg_int64_concurrent_lr_sc) {\n-  bool zacas = UseZacas;\n-  UseZacas = false;\n-  run_concurrent_cmpxchg_tests<int64_t, Assembler::int64>();\n-  run_concurrent_alt_cmpxchg_tests<int64_t, Assembler::int64>();\n-  UseZacas = zacas;\n-}\n-\n-TEST_VM(RiscV, cmpxchg_int64_concurrent_maybe_zacas) {\n-  if (UseZacas) {\n-    run_concurrent_cmpxchg_tests<int64_t, Assembler::int64>();\n-    run_concurrent_alt_cmpxchg_tests<int64_t, Assembler::int64>();\n-  }\n-}\n-\n-TEST_VM(RiscV, cmpxchg_int32_concurrent_lr_sc) {\n-  bool zacas = UseZacas;\n-  UseZacas = false;\n-  run_concurrent_cmpxchg_tests<int32_t, Assembler::int32>();\n-  run_concurrent_alt_cmpxchg_tests<int32_t, Assembler::int32>();\n-  UseZacas = zacas;\n-}\n-\n-TEST_VM(RiscV, cmpxchg_int32_concurrent_maybe_zacas) {\n-  if (UseZacas) {\n-    run_concurrent_cmpxchg_tests<int32_t, Assembler::int32>();\n-    run_concurrent_alt_cmpxchg_tests<int32_t, Assembler::int32>();\n-  }\n-}\n-\n-template <typename TESTSIZE, Assembler::operand_size ASMSIZE>\n-class NarrowCmpxchgTester {\n-  typedef TESTSIZE (*cmpxchg_func)(intptr_t addr, TESTSIZE expected, TESTSIZE new_value, TESTSIZE result,\n-                                   int64_t scratch0, int64_t scratch1, int64_t scratch2);\n-\n-  BufferBlob*  _bb;\n-  cmpxchg_func _func;\n-\n- public:\n-  NarrowCmpxchgTester(bool boolean_result) {\n-    _bb = BufferBlob::create(\"riscvTest\", 128);\n-    CodeBuffer code(_bb);\n-    MacroAssembler _masm(&code);\n-    address entry = _masm.pc();\n-    {\n-       _masm.cmpxchg_narrow_value(\/*addr*\/ c_rarg0, \/*expected*\/ c_rarg1, \/*new_value*\/c_rarg2,\n-                        ASMSIZE, Assembler::relaxed, Assembler::relaxed,\n-                        \/*result*\/ c_rarg3, boolean_result, c_rarg4, c_rarg5, c_rarg6); \/* Uses also t0-t1, caller saved *\/\n-      _masm.mv(c_rarg0, c_rarg3);\n-      _masm.ret();\n-    }\n-    _masm.flush(); \/\/ icache invalidate\n-    _func = ((cmpxchg_func)entry);\n-  }\n-\n-  ~NarrowCmpxchgTester() {\n-    BufferBlob::free(_bb);\n-  }\n-\n-  TESTSIZE narrow_cmpxchg(intptr_t addr, TESTSIZE expected, TESTSIZE new_value) {\n-    return _func(addr, expected, new_value, \/* dummy result *\/ 67, -1, -1, -1);\n-  }\n-};\n-\n@@ -383,2 +292,2 @@\n-  NarrowCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(false);\n-  NarrowCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg_bool(true);\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false);\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg_bool(0, true);\n@@ -392,1 +301,1 @@\n-    ret = cmpxchg.narrow_cmpxchg((intptr_t)&data[i], 121, 42);\n+    ret = cmpxchg.cmpxchg((intptr_t)&data[i], 121, 42);\n@@ -397,1 +306,1 @@\n-    ret = cmpxchg.narrow_cmpxchg((intptr_t)&data[i], 120, 42);\n+    ret = cmpxchg.cmpxchg((intptr_t)&data[i], 120, 42);\n@@ -402,1 +311,1 @@\n-    ret = cmpxchg_bool.narrow_cmpxchg((intptr_t)&data[i], 121, 42);\n+    ret = cmpxchg_bool.cmpxchg((intptr_t)&data[i], 121, 42);\n@@ -407,1 +316,1 @@\n-    ret = cmpxchg_bool.narrow_cmpxchg((intptr_t)&data[i], 120, 42);\n+    ret = cmpxchg_bool.cmpxchg((intptr_t)&data[i], 120, 42);\n@@ -420,0 +329,6 @@\n+TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+  if (UseZacas) {\n+    run_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+  }\n+}\n+\n@@ -427,1 +342,1 @@\n-TEST_VM(RiscV, cmpxchg_int16_maybe_zacas) {\n+TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n@@ -429,1 +344,1 @@\n-    run_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -433,3 +348,18 @@\n-TEST_VM(RiscV, cmpxchg_int8_maybe_zacas) {\n-  if (UseZacas) {\n-    run_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n+template <typename TESTSIZE>\n+TESTSIZE next_count(TESTSIZE now, TESTSIZE add) {\n+  if ((std::numeric_limits<TESTSIZE>::max() - add) >= now) {\n+    return now + add;\n+  }\n+  TESTSIZE diff = std::numeric_limits<TESTSIZE>::max() - now;\n+  add -= diff;\n+  return std::numeric_limits<TESTSIZE>::min() + add;\n+}\n+\n+constexpr int64_t PAR_IT_END       = 10000;\n+constexpr int64_t NUMBER_THREADS   = 4;\n+constexpr int64_t TOTAL_ITERATIONS = NUMBER_THREADS * PAR_IT_END;\n+\n+template <typename TESTSIZE>\n+constexpr TESTSIZE result_count() {\n+  if (std::numeric_limits<TESTSIZE>::max() > (std::numeric_limits<TESTSIZE>::min() + TOTAL_ITERATIONS)) {\n+    return std::numeric_limits<TESTSIZE>::min() + TOTAL_ITERATIONS;\n@@ -437,0 +367,9 @@\n+  int64_t range = std::numeric_limits<TESTSIZE>::max();\n+  range -= std::numeric_limits<TESTSIZE>::min();\n+  int64_t rest = TOTAL_ITERATIONS % range;\n+  return std::numeric_limits<TESTSIZE>::min() + rest;\n+}\n+\n+template<>\n+constexpr int64_t result_count<int64_t>() {\n+    return std::numeric_limits<int64_t>::min() + TOTAL_ITERATIONS;\n@@ -440,8 +379,8 @@\n-static void run_concurrent_narrow_cmpxchg_tests() {\n-  volatile TESTSIZE data = 0;\n-  int num_threads = 4;\n-  NarrowCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(false); \/\/ not bool ret\n-  auto incThread = [&](Thread* _current, int _id) {\n-    for (int i = 0; i < 10000; i++) {\n-      TESTSIZE oldvalue = _id + num_threads * i;\n-      TESTSIZE newvalue = oldvalue + 1;\n+static void run_concurrent_cmpxchg_tests() {\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false); \/\/ variant 0, not bool ret\n+  auto incThread = [&](Thread* _current, int _id) {   \/\/ _id starts from 0..(CTHREAD-1)\n+    TESTSIZE my_oldvalue = std::numeric_limits<TESTSIZE>::min() + _id;\n+    for (int64_t i = 0; i < PAR_IT_END ; i++) {\n+      TESTSIZE newvalue = next_count<TESTSIZE>(my_oldvalue,  1);\n@@ -450,2 +389,3 @@\n-        ret = cmpxchg.narrow_cmpxchg((intptr_t)&data, oldvalue, newvalue);\n-      } while (ret != oldvalue);\n+        ret = cmpxchg.cmpxchg((intptr_t)&data, my_oldvalue, newvalue);\n+      } while (ret != my_oldvalue);\n+      my_oldvalue = next_count<TESTSIZE>(my_oldvalue, num_threads);\n@@ -457,1 +397,1 @@\n-  ASSERT_EQ(data, (TESTSIZE)(num_threads*10000));\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n@@ -461,6 +401,6 @@\n-static void run_concurrent_alt_narrow_cmpxchg_tests() {\n-  volatile TESTSIZE data = 0;\n-  int num_threads = 4;\n-  NarrowCmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(false); \/\/ not bool ret\n-  auto incThread = [&](Thread* _current, int _id) {\n-    for (int i = 0; i < 10000; i++) {\n+static void run_concurrent_alt_cmpxchg_tests() {\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n+  CmpxchgTester<TESTSIZE, ASMSIZE> cmpxchg(0, false); \/\/ variant 0, not bool ret\n+  auto incThread = [&](Thread* _current, int _id) {   \/\/ _id starts from 0..(CTHREAD-1)\n+    for (int i = 0; i < PAR_IT_END; i++) {\n@@ -471,2 +411,2 @@\n-        TESTSIZE newvalue = oldvalue + 1;\n-        ret = cmpxchg.narrow_cmpxchg((intptr_t)&data, oldvalue, newvalue);\n+        TESTSIZE newvalue = next_count<TESTSIZE>(oldvalue, 1);\n+        ret = cmpxchg.cmpxchg((intptr_t)&data, oldvalue, newvalue);\n@@ -479,1 +419,31 @@\n-  ASSERT_EQ(data, (TESTSIZE)(num_threads*10000));\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int64_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<int64_t, Assembler::int64>();\n+  run_concurrent_alt_cmpxchg_tests<int64_t, Assembler::int64>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int64_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_cmpxchg_tests<int64_t, Assembler::int64>();\n+    run_concurrent_alt_cmpxchg_tests<int64_t, Assembler::int64>();\n+  }\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int32_concurrent_lr_sc) {\n+  bool zacas = UseZacas;\n+  UseZacas = false;\n+  run_concurrent_cmpxchg_tests<int32_t, Assembler::int32>();\n+  run_concurrent_alt_cmpxchg_tests<int32_t, Assembler::int32>();\n+  UseZacas = zacas;\n+}\n+\n+TEST_VM(RiscV, cmpxchg_int32_concurrent_maybe_zacas) {\n+  if (UseZacas) {\n+    run_concurrent_cmpxchg_tests<int32_t, Assembler::int32>();\n+    run_concurrent_alt_cmpxchg_tests<int32_t, Assembler::int32>();\n+  }\n@@ -485,2 +455,2 @@\n-  run_concurrent_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n-  run_concurrent_alt_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+  run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+  run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n@@ -492,2 +462,2 @@\n-    run_concurrent_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n-    run_concurrent_alt_narrow_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_cmpxchg_tests<int16_t, Assembler::int16>();\n+    run_concurrent_alt_cmpxchg_tests<int16_t, Assembler::int16>();\n@@ -500,2 +470,2 @@\n-  run_concurrent_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n-  run_concurrent_alt_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n+  run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+  run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -507,2 +477,2 @@\n-    run_concurrent_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n-    run_concurrent_alt_narrow_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_cmpxchg_tests<int8_t, Assembler::int8>();\n+    run_concurrent_alt_cmpxchg_tests<int8_t, Assembler::int8>();\n@@ -628,2 +598,2 @@\n-  volatile TESTSIZE data = 0;\n-  int num_threads = 4;\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n@@ -631,4 +601,4 @@\n-  auto incThread = [&](Thread* _current, int _id) {\n-    for (int i = 0; i < 10000; i++) {\n-      TESTSIZE oldvalue = _id + num_threads * i;\n-      TESTSIZE newvalue = oldvalue + 1;\n+  auto incThread = [&](Thread* _current, int _id) { \/\/ _id starts from 0..(CTHREAD-1)\n+    TESTSIZE my_oldvalue = std::numeric_limits<TESTSIZE>::min() + _id;\n+    for (int64_t i = 0; i < PAR_IT_END; i++) {\n+      TESTSIZE newvalue = next_count<TESTSIZE>(my_oldvalue, 1);\n@@ -637,1 +607,1 @@\n-        ret = cmpxchg.weak_cmpxchg((intptr_t)&data, oldvalue, newvalue);\n+        ret = cmpxchg.weak_cmpxchg((intptr_t)&data, my_oldvalue, newvalue);\n@@ -639,0 +609,1 @@\n+      my_oldvalue = next_count<TESTSIZE>(my_oldvalue, num_threads);\n@@ -644,1 +615,1 @@\n-  ASSERT_EQ(data, (TESTSIZE)(num_threads*10000));\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n@@ -649,2 +620,2 @@\n-  volatile TESTSIZE data = 0;\n-  int num_threads = 4;\n+  volatile TESTSIZE data = std::numeric_limits<TESTSIZE>::min();\n+  int num_threads = NUMBER_THREADS;\n@@ -652,2 +623,2 @@\n-  auto incThread = [&](Thread* _current, int _id) {\n-    for (int i = 0; i < 10000; i++) {\n+  auto incThread = [&](Thread* _current, int _id) { \/\/ _id starts from 0..(CTHREAD-1)\n+    for (int i = 0; i < PAR_IT_END; i++) {\n@@ -658,1 +629,1 @@\n-        TESTSIZE newvalue = oldvalue + 1;\n+        TESTSIZE newvalue = next_count<TESTSIZE>(oldvalue, 1);\n@@ -666,1 +637,1 @@\n-  ASSERT_EQ(data, (TESTSIZE)(num_threads*10000));\n+  ASSERT_EQ(data, result_count<TESTSIZE>());\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":134,"deletions":163,"binary":false,"changes":297,"status":"modified"}]}