{"files":[{"patch":"@@ -1920,0 +1920,1 @@\n+  assert(!UseRVV, \"sanity\");\n@@ -1994,0 +1995,98 @@\n+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(MaxVectorSize >= 16, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, t0, t1);\n+\n+  \/\/ The MaxVectorSize should have been set by detecting RVV max vector register\n+  \/\/ size when check UseRVV (i.e. MaxVectorSize == VM_Version::_initial_vector_length).\n+  const int num_8bit_elems_in_vec_reg = MaxVectorSize;\n+  \/\/ Let's use T_INT as all hashCode calculations eventually deal with ints.\n+  const int ints_in_vec_reg = num_8bit_elems_in_vec_reg\/sizeof(jint);\n+  const int lmul = 1;\n+\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+  const int MAX_VEC_MASK = ~(ints_in_vec_reg*lmul - 1);\n+\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n+  const Register pow31_highest  = tmp1;\n+  const Register ary_end = tmp2;\n+  const Register consumed = tmp3;\n+\n+  const VectorRegister v_coeffs =  v4;\n+  const VectorRegister v_src    =  v8;\n+  const VectorRegister v_sum    = v12;\n+  const VectorRegister v_powmax = v16;\n+  const VectorRegister v_result = v20;\n+  const VectorRegister v_tmp    = v24;\n+  const VectorRegister v_zred   = v28;\n+\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+  Label VEC_LOOP, DONE, SCALAR_TAIL, SCALAR_TAIL_LOOP;\n+\n+  \/\/ NB: at this point (a) 'result' already has some value,\n+  \/\/ (b) 'cnt' is not 0 or 1, see java code for details.\n+\n+  andi(t1, cnt, MAX_VEC_MASK);\n+  beqz(t1, SCALAR_TAIL);\n+\n+  vsetvli(t0, x0, Assembler::e64, Assembler::m8);\n+  vmv_v_x(v0, x0);\n+  vmv_v_x(v8, x0);\n+  vmv_v_x(v16, x0);\n+  vmv_v_x(v24, x0);\n+\n+  la(t1, ExternalAddress(adr_pows31));\n+  lw(pow31_highest, Address(t1, -1 * sizeof(jint)));\n+  vsetvli(x0, x0, Assembler::e32, Assembler::m4);\n+  vle32_v(v_coeffs, t1); \/\/ 31^^(MaxVectorSize-1)...31^^0\n+  vmv_v_x(v_powmax, pow31_highest);\n+  vmv_s_x(v_result, result);\n+\n+  vsetvli(consumed, cnt, Assembler::e32, Assembler::m1);\n+\n+  bind(VEC_LOOP);\n+  vmul_vv(v_result, v_result, v_powmax);\n+  vmul_vv(v_sum, v_sum, v_powmax);\n+  arrays_hashcode_vec_elload(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vadd_vv(v_sum, v_sum, v_src);\n+  shadd(ary, consumed, ary, t0, elsize_shift);\n+  subw(cnt, cnt, consumed);\n+  andi(t1, cnt, MAX_VEC_MASK);\n+  bne(t1, x0, VEC_LOOP);\n+\n+  vredsum_vs(v_sum, v_sum, v_zred);\n+  vadd_vv(v_result, v_result, v_sum);\n+  vmv_x_s(result, v_result);\n+  beqz(cnt, DONE);\n+\n+  bind(SCALAR_TAIL);\n+  shadd(ary_end, cnt, ary, t0, elsize_shift);\n+\n+  bind(SCALAR_TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);           \/\/ optimize 31 * result\n+  subw(result, t1, result);      \/\/ with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, ary_end, SCALAR_TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode_v\");\n+}\n+\n@@ -2016,0 +2115,30 @@\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_vec_elload(VectorRegister varr,\n+                                                   VectorRegister vtmp,\n+                                                   Register array,\n+                                                   BasicType eltype) {\n+  assert((T_INT == eltype) || (varr != vtmp), \"should be\");\n+  switch (eltype) {\n+  case T_BOOLEAN:\n+    vle8_v(vtmp, array);\n+    vzext_vf4(varr, vtmp);\n+    break;\n+  case T_BYTE:\n+    vle8_v(vtmp, array);\n+    vsext_vf4(varr, vtmp);\n+    break;\n+  case T_CHAR:\n+    vle16_v(vtmp, array);\n+    vzext_vf2(varr, vtmp);\n+    break;\n+  case T_SHORT:\n+    vle16_v(vtmp, array);\n+    vsext_vf2(varr, vtmp);\n+    break;\n+  case T_INT:\n+    vle32_v(varr, array);\n+    break;\n+  default:\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -100,2 +100,4 @@\n-\n-  \/\/ helper function for arrays_hashcode\n+  void arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                         Register tmp1, Register tmp2, Register tmp3,\n+                         BasicType eltype);\n+  \/\/ helper functions for arrays_hashcode\n@@ -104,0 +106,1 @@\n+  void arrays_hashcode_vec_elload(VectorRegister varr, VectorRegister vtmp, Register array, BasicType eltype);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -945,0 +945,85 @@\n+\/\/ class for vector register v12\n+reg_class v12_reg(\n+    V12, V12_H, V12_J, V12_K\n+);\n+\n+\/\/ class for vector register v13\n+reg_class v13_reg(\n+    V13, V13_H, V13_J, V13_K\n+);\n+\n+\/\/ class for vector register v14\n+reg_class v14_reg(\n+    V14, V14_H, V14_J, V14_K\n+);\n+\n+\/\/ class for vector register v15\n+reg_class v15_reg(\n+    V15, V15_H, V15_J, V15_K\n+);\n+\n+\/\/ class for vector register v16\n+reg_class v16_reg(\n+    V16, V16_H, V16_J, V16_K\n+);\n+\n+\/\/ class for vector register v17\n+reg_class v17_reg(\n+    V17, V17_H, V17_J, V17_K\n+);\n+\n+\/\/ class for vector register v18\n+reg_class v18_reg(\n+    V18, V18_H, V18_J, V18_K\n+);\n+\n+\/\/ class for vector register v19\n+reg_class v19_reg(\n+    V19, V19_H, V19_J, V19_K\n+);\n+\n+\/\/ class for vector register v20\n+reg_class v20_reg(\n+    V20, V20_H, V20_J, V20_K\n+);\n+\n+\/\/ class for vector register v21\n+reg_class v21_reg(\n+    V21, V21_H, V21_J, V21_K\n+);\n+\n+\/\/ class for vector register v22\n+reg_class v22_reg(\n+    V22, V22_H, V22_J, V22_K\n+);\n+\n+\/\/ class for vector register v23\n+reg_class v23_reg(\n+    V23, V23_H, V23_J, V23_K\n+);\n+\n+\/\/ class for vector register v24\n+reg_class v24_reg(\n+    V24, V24_H, V24_J, V24_K\n+);\n+\n+\/\/ class for vector register v25\n+reg_class v25_reg(\n+    V25, V25_H, V25_J, V25_K\n+);\n+\n+\/\/ class for vector register v26\n+reg_class v26_reg(\n+    V26, V26_H, V26_J, V26_K\n+);\n+\n+\/\/ class for vector register v27\n+reg_class v27_reg(\n+    V27, V27_H, V27_J, V27_K\n+);\n+\n+\/\/ class for vector register v28\n+reg_class v28_reg(\n+    V28, V28_H, V28_J, V28_K\n+);\n+\n@@ -3508,0 +3593,170 @@\n+operand vReg_V12()\n+%{\n+  constraint(ALLOC_IN_RC(v12_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V13()\n+%{\n+  constraint(ALLOC_IN_RC(v13_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V14()\n+%{\n+  constraint(ALLOC_IN_RC(v14_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V15()\n+%{\n+  constraint(ALLOC_IN_RC(v15_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V16()\n+%{\n+  constraint(ALLOC_IN_RC(v16_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V17()\n+%{\n+  constraint(ALLOC_IN_RC(v17_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V18()\n+%{\n+  constraint(ALLOC_IN_RC(v18_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V19()\n+%{\n+  constraint(ALLOC_IN_RC(v19_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V20()\n+%{\n+  constraint(ALLOC_IN_RC(v20_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V21()\n+%{\n+  constraint(ALLOC_IN_RC(v21_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V22()\n+%{\n+  constraint(ALLOC_IN_RC(v22_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V23()\n+%{\n+  constraint(ALLOC_IN_RC(v23_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V24()\n+%{\n+  constraint(ALLOC_IN_RC(v24_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V25()\n+%{\n+  constraint(ALLOC_IN_RC(v25_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V26()\n+%{\n+  constraint(ALLOC_IN_RC(v26_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V27()\n+%{\n+  constraint(ALLOC_IN_RC(v27_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V28()\n+%{\n+  constraint(ALLOC_IN_RC(v28_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -10749,0 +11004,1 @@\n+  predicate(!UseRVV);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":256,"deletions":0,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -3956,0 +3956,29 @@\n+\/\/ fast ArraysSupport.vectorizedHashCode\n+instruct varrays_hashcode(iRegP_R11 ary, iRegI_R12 cnt, iRegI_R10 result, immI basic_type,\n+                          vReg_V4   v4, vReg_V5   v5, vReg_V6   v6, vReg_V7   v7,\n+                          vReg_V8   v8, vReg_V9   v9, vReg_V10 v10, vReg_V11 v11,\n+                          vReg_V12 v12, vReg_V13 v13, vReg_V14 v14, vReg_V15 v15,\n+                          vReg_V16 v16, vReg_V17 v17, vReg_V18 v18, vReg_V19 v19,\n+                          vReg_V20 v20, vReg_V21 v21, vReg_V22 v22, vReg_V23 v23,\n+                          vReg_V24 v24, vReg_V25 v25, vReg_V26 v26, vReg_V27 v27,\n+                          vReg_V28 v28,\n+                          iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3,\n+                          rFlagsReg cr)\n+%{\n+  predicate(UseRVV);\n+  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n+  effect(USE_KILL ary, USE_KILL cnt, USE basic_type,\n+         TEMP  v4, TEMP  v5, TEMP  v6, TEMP  v7, TEMP  v8, TEMP  v9, TEMP v10, TEMP v11,\n+         TEMP v12, TEMP v13, TEMP v14, TEMP v15, TEMP v16, TEMP v17, TEMP v18, TEMP v19,\n+         TEMP v20, TEMP v21, TEMP v22, TEMP v23, TEMP v24, TEMP v25, TEMP v26, TEMP v27,\n+         TEMP v28, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode_v($ary$$Register, $cnt$$Register, $result$$Register,\n+                         $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                         (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+  do_stub(compiler, arrays_hashcode_powers_of_31)                       \\\n+  do_arch_entry(riscv, compiler, arrays_hashcode_powers_of_31,          \\\n+                arrays_hashcode_powers_of_31, arrays_hashcode_powers_of_31) \\\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6461,0 +6461,18 @@\n+  address generate_arrays_hashcode_powers_of_31() {\n+    const int num_8bit_elems_in_vec_reg = MaxVectorSize;\n+    const int ints_in_vec_reg = num_8bit_elems_in_vec_reg\/sizeof(jint);\n+    const int lmul = 1;\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"arrays_hashcode_powers_of_31\");\n+    address start = __ pc();\n+    for (int i = ints_in_vec_reg*lmul; i >= 0; i--) {\n+        jint power_of_31 = 1;\n+        for (int j = i; j > 0; j--) {\n+          power_of_31 = java_multiply(power_of_31, 31);\n+        }\n+        __ emit_int32(power_of_31);\n+    }\n+\n+    return start;\n+  }\n+\n@@ -6653,0 +6671,4 @@\n+    if (UseVectorizedHashCodeIntrinsic && UseRVV) {\n+      StubRoutines::riscv::_arrays_hashcode_powers_of_31 = generate_arrays_hashcode_powers_of_31();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}