{"files":[{"patch":"@@ -1920,0 +1920,1 @@\n+  assert(!UseRVV, \"sanity\");\n@@ -1992,0 +1993,87 @@\n+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, t0, t1);\n+\n+  \/\/ The MaxVectorSize should have been set by detecting RVV max vector register\n+  \/\/ size when check UseRVV (i.e. MaxVectorSize == VM_Version::_initial_vector_length).\n+  \/\/ Let's use T_INT as all hashCode calculations eventually deal with ints.\n+  const int ints_in_vec_reg = MaxVectorSize \/ sizeof(jint);\n+  const int lmul = 2;\n+\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+  const int MAX_VEC_MASK = ~(ints_in_vec_reg * lmul - 1);\n+\n+  switch (eltype) {\n+    case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+    case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+    case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+    case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+    case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  const Register pow31_highest = tmp1;\n+  const Register ary_end       = tmp2;\n+  const Register consumed      = tmp3;\n+\n+  const VectorRegister v_sum    = v2;\n+  const VectorRegister v_src    = v4;\n+  const VectorRegister v_coeffs = v6;\n+  const VectorRegister v_tmp    = v8;\n+\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+  Label VEC_LOOP, DONE, SCALAR_TAIL, SCALAR_TAIL_LOOP;\n+\n+  \/\/ NB: at this point (a) 'result' already has some value,\n+  \/\/ (b) 'cnt' is not 0 or 1, see java code for details.\n+\n+  andi(t0, cnt, MAX_VEC_MASK);\n+  beqz(t0, SCALAR_TAIL);\n+\n+  vsetvli(t1, x0, Assembler::e32, Assembler::m2);\n+  vmv_v_x(v_sum, x0);\n+\n+  la(t1, ExternalAddress(adr_pows31));\n+  lw(pow31_highest, Address(t1, -1 * sizeof(jint)));\n+  vle32_v(v_coeffs, t1); \/\/ 31^^(MaxVectorSize-1)...31^^0\n+\n+  vsetvli(consumed, cnt, Assembler::e32, Assembler::m2);\n+\n+  bind(VEC_LOOP);\n+  arrays_hashcode_elload_v(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vmadd_vx(v_sum, pow31_highest, v_src);\n+  shadd(ary, consumed, ary, t0, elsize_shift);\n+  mulw(result, result, pow31_highest);\n+  subw(cnt, cnt, consumed);\n+  andi(t1, cnt, MAX_VEC_MASK);\n+  bnez(t1, VEC_LOOP);\n+\n+  vmv_s_x(v_tmp, x0);\n+  vredsum_vs(v_sum, v_sum, v_tmp);\n+  vmv_x_s(t0, v_sum);\n+  addw(result, result, t0);\n+  beqz(cnt, DONE);\n+\n+  bind(SCALAR_TAIL);\n+  shadd(ary_end, cnt, ary, t0, elsize_shift);\n+\n+  bind(SCALAR_TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);           \/\/ optimize 31 * result\n+  subw(result, t1, result);      \/\/ with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, ary_end, SCALAR_TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode_v\");\n+}\n+\n@@ -1994,8 +2082,8 @@\n-  case T_BOOLEAN: return sizeof(jboolean);\n-  case T_BYTE:    return sizeof(jbyte);\n-  case T_SHORT:   return sizeof(jshort);\n-  case T_CHAR:    return sizeof(jchar);\n-  case T_INT:     return sizeof(jint);\n-  default:\n-    ShouldNotReachHere();\n-    return -1;\n+    case T_BOOLEAN: return sizeof(jboolean);\n+    case T_BYTE:    return sizeof(jbyte);\n+    case T_SHORT:   return sizeof(jshort);\n+    case T_CHAR:    return sizeof(jchar);\n+    case T_INT:     return sizeof(jint);\n+    default:\n+      ShouldNotReachHere();\n+      return -1;\n@@ -2007,8 +2095,38 @@\n-  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n-  case T_BOOLEAN: lbu(dst, src);   break;\n-  case T_BYTE:     lb(dst, src);   break;\n-  case T_SHORT:    lh(dst, src);   break;\n-  case T_CHAR:    lhu(dst, src);   break;\n-  case T_INT:      lw(dst, src);   break;\n-  default:\n-    ShouldNotReachHere();\n+    \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+    case T_BOOLEAN: lbu(dst, src);   break;\n+    case T_BYTE:     lb(dst, src);   break;\n+    case T_SHORT:    lh(dst, src);   break;\n+    case T_CHAR:    lhu(dst, src);   break;\n+    case T_INT:      lw(dst, src);   break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload_v(VectorRegister vdst,\n+                                                 VectorRegister vtmp,\n+                                                 Register src,\n+                                                 BasicType eltype) {\n+  assert_different_registers(vdst, vtmp);\n+  switch (eltype) {\n+    case T_BOOLEAN:\n+      vle8_v(vtmp, src);\n+      vzext_vf4(vdst, vtmp);\n+      break;\n+    case T_BYTE:\n+      vle8_v(vtmp, src);\n+      vsext_vf4(vdst, vtmp);\n+      break;\n+    case T_CHAR:\n+      vle16_v(vtmp, src);\n+      vzext_vf2(vdst, vtmp);\n+      break;\n+    case T_SHORT:\n+      vle16_v(vtmp, src);\n+      vsext_vf2(vdst, vtmp);\n+      break;\n+    case T_INT:\n+      vle32_v(vdst, src);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":134,"deletions":16,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-\n-  \/\/ helper function for arrays_hashcode\n@@ -105,0 +103,6 @@\n+  void arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                         Register tmp1, Register tmp2, Register tmp3,\n+                         BasicType eltype);\n+  void arrays_hashcode_elload_v(VectorRegister vdst, VectorRegister vtmp,\n+                                Register src, BasicType eltype);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -10972,0 +10972,1 @@\n+  predicate(!UseRVV);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4082,0 +4082,22 @@\n+\/\/ fast ArraysSupport.vectorizedHashCode\n+instruct varrays_hashcode(iRegP_R11 ary, iRegI_R12 cnt, iRegI_R10 result, immI basic_type,\n+                          vReg_V2 v2, vReg_V3 v3, vReg_V4 v4, vReg_V5 v5,\n+                          vReg_V6 v6, vReg_V7 v7, vReg_V8 v8, vReg_V9 v9,\n+                          iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3,\n+                          rFlagsReg cr)\n+%{\n+  predicate(UseRVV);\n+  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n+  effect(USE_KILL ary, USE_KILL cnt, USE basic_type,\n+         TEMP v2, TEMP v3, TEMP v4, TEMP v5, TEMP v6, TEMP v7, TEMP v8, TEMP v9,\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result\\t#varrays_hashcode\" %}\n+  ins_encode %{\n+    __ arrays_hashcode_v($ary$$Register, $cnt$$Register, $result$$Register,\n+                         $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                         (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  do_stub(compiler, arrays_hashcode_powers_of_31)                       \\\n+  do_arch_entry(riscv, compiler, arrays_hashcode_powers_of_31,          \\\n+                arrays_hashcode_powers_of_31, arrays_hashcode_powers_of_31) \\\n","filename":"src\/hotspot\/cpu\/riscv\/stubDeclarations_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6584,0 +6584,18 @@\n+  address generate_arrays_hashcode_powers_of_31() {\n+    assert(UseRVV, \"sanity\");\n+    const int ints_in_vec_reg = MaxVectorSize \/ sizeof(jint);\n+    const int lmul = 2;\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"arrays_hashcode_powers_of_31\");\n+    address start = __ pc();\n+    for (int i = ints_in_vec_reg * lmul; i >= 0; i--) {\n+        jint power_of_31 = 1;\n+        for (int j = i; j > 0; j--) {\n+          power_of_31 = java_multiply(power_of_31, 31);\n+        }\n+        __ emit_int32(power_of_31);\n+    }\n+\n+    return start;\n+  }\n+\n@@ -6778,0 +6796,4 @@\n+    if (UseVectorizedHashCodeIntrinsic && UseRVV) {\n+      StubRoutines::riscv::_arrays_hashcode_powers_of_31 = generate_arrays_hashcode_powers_of_31();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}