{"files":[{"patch":"@@ -1468,0 +1468,1 @@\n+  assert(!UseRVV, \"sanity\");\n@@ -1542,0 +1543,131 @@\n+void C2_MacroAssembler::arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3,\n+                                          Register tmp4, Register tmp5, Register tmp6,\n+                                          BasicType eltype)\n+{\n+  assert(UseRVV, \"sanity\");\n+  assert(StubRoutines::riscv::arrays_hashcode_powers_of_31() != nullptr, \"sanity\");\n+  assert_different_registers(ary, cnt, result, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, t0, t1);\n+\n+  const int num_8b_elems_in_vec = MaxVectorSize;\n+  const int elsize_bytes = arrays_hashcode_elsize(eltype);\n+  const int elsize_shift = exact_log2(elsize_bytes);\n+  const int vec_step_bytes = num_8b_elems_in_vec << elsize_shift;\n+  const address adr_pows31 = StubRoutines::riscv::arrays_hashcode_powers_of_31()\n+                           + sizeof(jint);\n+\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode_v(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode_v(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode_v(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode_v(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode_v(int) {\");           break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n+  const int scalar_stride = 4;\n+  const Register pow31_4 = tmp1;\n+  const Register pow31_3 = tmp2;\n+  const Register pow31_2 = tmp3;\n+  const Register chunks  = tmp4;\n+  const Register chunks_end = chunks;\n+\n+  const Register pows31  = tmp1;\n+  const VectorRegister v_coeffs =  v4;\n+  const VectorRegister v_src    =  v8;\n+  const VectorRegister v_sum    = v12;\n+  const VectorRegister v_powmax = v16;\n+  const VectorRegister v_result = v20;\n+  const VectorRegister v_tmp    = v24;\n+  const VectorRegister v_zred   = v28;\n+\n+  Label DONE, TAIL, TAIL_LOOP, WIDE_TAIL, WIDE_LOOP, VEC_LOOP;\n+\n+  \/\/ result has a value initially\n+\n+  beqz(cnt, DONE);\n+\n+  andi(chunks, cnt, ~(num_8b_elems_in_vec-1));\n+  beqz(chunks, WIDE_TAIL);\n+\n+  subw(cnt, cnt, chunks);\n+  slli(chunks_end, chunks, elsize_shift);\n+  add(chunks_end, ary, chunks_end);\n+\n+  \/\/ load pre-calculated powers of 31:\n+  \/\/   31^^MaxVectorSize             ==> scalar register\n+  \/\/   31^^(MaxVectorSize-1)...31^^0 ==> vector registers\n+  la(pows31, ExternalAddress(adr_pows31));\n+  mv(t1, num_8b_elems_in_vec);\n+  vsetvli(t0, t1, Assembler::e32, Assembler::m4);\n+  vle32_v(v_coeffs, pows31);\n+  lw(pows31, Address(pows31, -1 * sizeof(jint)));\n+  \/\/ clear vector registers used in intermediate calculations\n+  vmv_v_i(v_sum, 0);\n+  vmv_v_i(v_powmax, 0);\n+  vmv_v_i(v_result, 0);\n+  vmv_s_x(v_zred, x0);\n+  \/\/ set initial values\n+  vmv_s_x(v_powmax, pows31);\n+  vmv_s_x(v_result, result);\n+\n+  bind(VEC_LOOP);\n+  vmul_vv(v_result, v_result, v_powmax);\n+  arrays_hashcode_vec_elload(v_src, v_tmp, ary, eltype);\n+  vmul_vv(v_src, v_src, v_coeffs);\n+  vredsum_vs(v_sum, v_src, v_zred);\n+  vadd_vv(v_result, v_result, v_sum);\n+  addi(ary, ary, vec_step_bytes);\n+  bne(ary, chunks_end, VEC_LOOP);\n+  \/\/ finally remember calculated result value in scalar register\n+  vmv_x_s(result, v_result);\n+  beqz(cnt, DONE);\n+\n+  bind(WIDE_TAIL);\n+  andi(chunks, cnt, ~(scalar_stride-1));\n+  beqz(chunks, TAIL);\n+\n+  mv(pow31_4, 923521);           \/\/ [31^^4]\n+  mv(pow31_3,  29791);           \/\/ [31^^3]\n+  mv(pow31_2,    961);           \/\/ [31^^2]\n+\n+  slli(chunks_end, chunks, elsize_shift);\n+  add(chunks_end, ary, chunks_end);\n+  andi(cnt, cnt, scalar_stride-1);      \/\/ don't forget about tail!\n+\n+  bind(WIDE_LOOP);\n+  mulw(result, result, pow31_4); \/\/ 31^^4 * h\n+  arrays_hashcode_elload(t0,   Address(ary, 0 * elsize_bytes), eltype);\n+  arrays_hashcode_elload(t1,   Address(ary, 1 * elsize_bytes), eltype);\n+  arrays_hashcode_elload(tmp5, Address(ary, 2 * elsize_bytes), eltype);\n+  arrays_hashcode_elload(tmp6, Address(ary, 3 * elsize_bytes), eltype);\n+  mulw(t0, t0, pow31_3);         \/\/ 31^^3 * ary[i+0]\n+  addw(result, result, t0);\n+  mulw(t1, t1, pow31_2);         \/\/ 31^^2 * ary[i+1]\n+  addw(result, result, t1);\n+  slli(t0, tmp5, 5);             \/\/ optimize 31^^1 * ary[i+2]\n+  subw(tmp5, t0, tmp5);          \/\/ with ary[i+2]<<5 - ary[i+2]\n+  addw(result, result, tmp5);\n+  addw(result, result, tmp6);    \/\/ 31^^4 * h + 31^^3 * ary[i+0] + 31^^2 * ary[i+1]\n+                                 \/\/           + 31^^1 * ary[i+2] + 31^^0 * ary[i+3]\n+  addi(ary, ary, elsize_bytes * scalar_stride);\n+  bne(ary, chunks_end, WIDE_LOOP);\n+  beqz(cnt, DONE);\n+\n+  bind(TAIL);\n+  slli(chunks_end, cnt, elsize_shift);\n+  add(chunks_end, ary, chunks_end);\n+\n+  bind(TAIL_LOOP);\n+  arrays_hashcode_elload(t0, Address(ary), eltype);\n+  slli(t1, result, 5);           \/\/ optimize 31 * result\n+  subw(result, t1, result);      \/\/ with result<<5 - result\n+  addw(result, result, t0);\n+  addi(ary, ary, elsize_bytes);\n+  bne(ary, chunks_end, TAIL_LOOP);\n+\n+  bind(DONE);\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode_v\");\n+}\n+\n@@ -1568,0 +1700,30 @@\n+void C2_MacroAssembler::arrays_hashcode_vec_elload(VectorRegister varr,\n+                                                   VectorRegister vtmp,\n+                                                   Register array,\n+                                                   BasicType eltype) {\n+  assert((T_INT == eltype) || (varr != vtmp), \"should be\");\n+  switch (eltype) {\n+  case T_BOOLEAN:\n+    vle8_v(vtmp, array);\n+    vzext_vf4(varr, vtmp);\n+    break;\n+  case T_BYTE:\n+    vle8_v(vtmp, array);\n+    vsext_vf4(varr, vtmp);\n+    break;\n+  case T_CHAR:\n+    vle16_v(vtmp, array);\n+    vzext_vf2(varr, vtmp);\n+    break;\n+  case T_SHORT:\n+    vle16_v(vtmp, array);\n+    vsext_vf2(varr, vtmp);\n+    break;\n+  case T_INT:\n+    vle32_v(varr, array);\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -90,1 +90,6 @@\n-  \/\/ helper function for arrays_hashcode\n+  void arrays_hashcode_v(Register ary, Register cnt, Register result,\n+                         Register tmp1, Register tmp2,\n+                         Register tmp3, Register tmp4,\n+                         Register tmp5, Register tmp6,\n+                         BasicType eltype);\n+  \/\/ helper functions for arrays_hashcode\n@@ -93,0 +98,1 @@\n+  void arrays_hashcode_vec_elload(VectorRegister varr, VectorRegister vtmp, Register array, BasicType eltype);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -957,0 +957,65 @@\n+\/\/ class for vector register v16\n+reg_class v16_reg(\n+    V16, V16_H, V16_J, V16_K\n+);\n+\n+\/\/ class for vector register v17\n+reg_class v17_reg(\n+    V17, V17_H, V17_J, V17_K\n+);\n+\n+\/\/ class for vector register v18\n+reg_class v18_reg(\n+    V18, V18_H, V18_J, V18_K\n+);\n+\n+\/\/ class for vector register v19\n+reg_class v19_reg(\n+    V19, V19_H, V19_J, V19_K\n+);\n+\n+\/\/ class for vector register v20\n+reg_class v20_reg(\n+    V20, V20_H, V20_J, V20_K\n+);\n+\n+\/\/ class for vector register v21\n+reg_class v21_reg(\n+    V21, V21_H, V21_J, V21_K\n+);\n+\n+\/\/ class for vector register v22\n+reg_class v22_reg(\n+    V22, V22_H, V22_J, V22_K\n+);\n+\n+\/\/ class for vector register v23\n+reg_class v23_reg(\n+    V23, V23_H, V23_J, V23_K\n+);\n+\n+\/\/ class for vector register v24\n+reg_class v24_reg(\n+    V24, V24_H, V24_J, V24_K\n+);\n+\n+\/\/ class for vector register v25\n+reg_class v25_reg(\n+    V25, V25_H, V25_J, V25_K\n+);\n+\n+\/\/ class for vector register v26\n+reg_class v26_reg(\n+    V26, V26_H, V26_J, V26_K\n+);\n+\n+\/\/ class for vector register v27\n+reg_class v27_reg(\n+    V27, V27_H, V27_J, V27_K\n+);\n+\n+\/\/ class for vector register v28\n+reg_class v28_reg(\n+    V28, V28_H, V28_J, V28_K\n+);\n+\n@@ -3576,0 +3641,130 @@\n+operand vReg_V16()\n+%{\n+  constraint(ALLOC_IN_RC(v16_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V17()\n+%{\n+  constraint(ALLOC_IN_RC(v17_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V18()\n+%{\n+  constraint(ALLOC_IN_RC(v18_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V19()\n+%{\n+  constraint(ALLOC_IN_RC(v19_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V20()\n+%{\n+  constraint(ALLOC_IN_RC(v20_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V21()\n+%{\n+  constraint(ALLOC_IN_RC(v21_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V22()\n+%{\n+  constraint(ALLOC_IN_RC(v22_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V23()\n+%{\n+  constraint(ALLOC_IN_RC(v23_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V24()\n+%{\n+  constraint(ALLOC_IN_RC(v24_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V25()\n+%{\n+  constraint(ALLOC_IN_RC(v25_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V26()\n+%{\n+  constraint(ALLOC_IN_RC(v26_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V27()\n+%{\n+  constraint(ALLOC_IN_RC(v27_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V28()\n+%{\n+  constraint(ALLOC_IN_RC(v28_reg));\n+  match(VecA);\n+  match(vReg);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -10409,0 +10604,1 @@\n+  predicate(!UseRVV);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2669,0 +2669,31 @@\n+\/\/ fast ArraysSupport.vectorizedHashCode\n+instruct varrays_hashcode(iRegP_R11 ary, iRegI_R12 cnt, iRegI_R10 result, immI basic_type,\n+                          vReg_V4   v4, vReg_V5   v5, vReg_V6   v6, vReg_V7   v7,\n+                          vReg_V8   v8, vReg_V9   v9, vReg_V10 v10, vReg_V11 v11,\n+                          vReg_V12 v12, vReg_V13 v13, vReg_V14 v14, vReg_V15 v15,\n+                          vReg_V16 v16, vReg_V17 v17, vReg_V18 v18, vReg_V19 v19,\n+                          vReg_V20 v20, vReg_V21 v21, vReg_V22 v22, vReg_V23 v23,\n+                          vReg_V24 v24, vReg_V25 v25, vReg_V26 v26, vReg_V27 v27,\n+                          vReg_V28 v28,\n+                          iRegLNoSp tmp1, iRegLNoSp tmp2, iRegLNoSp tmp3,\n+                          iRegLNoSp tmp4, iRegLNoSp tmp5, iRegLNoSp tmp6, rFlagsReg cr)\n+%{\n+  predicate(UseRVV && (MaxVectorSize >= 16));\n+  match(Set result (VectorizedHashCode (Binary ary cnt) (Binary result basic_type)));\n+  effect(USE_KILL ary, USE_KILL cnt, USE basic_type,\n+         TEMP  v4, TEMP  v5, TEMP  v6, TEMP  v7, TEMP  v8, TEMP  v9, TEMP v10, TEMP v11,\n+         TEMP v12, TEMP v13, TEMP v14, TEMP v15, TEMP v16, TEMP v17, TEMP v18, TEMP v19,\n+         TEMP v20, TEMP v21, TEMP v22, TEMP v23, TEMP v24, TEMP v25, TEMP v26, TEMP v27,\n+         TEMP v28, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, TEMP tmp6,\n+         KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary,$cnt,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode_v($ary$$Register, $cnt$$Register, $result$$Register,\n+                         $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                         $tmp4$$Register, $tmp5$$Register, $tmp6$$Register,\n+                         (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -5018,0 +5018,16 @@\n+  address generate_arrays_hashcode_powers_of_31() {\n+    const int num_8b_elems_in_vec = MaxVectorSize;\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"arrays_hashcode_powers_of_31\");\n+    address start = __ pc();\n+    for (int i = num_8b_elems_in_vec; i >= 0; i--) {\n+        jint power_of_31 = 1;\n+        for (int j = i; j > 0; j--) {\n+          power_of_31 = java_multiply(power_of_31, 31);\n+        }\n+        __ emit_int32(power_of_31);\n+    }\n+\n+    return start;\n+  }\n+\n@@ -5249,0 +5265,4 @@\n+\n+    if (UseVectorizedHashCodeIntrinsic && UseRVV && (MaxVectorSize >= 16)) {\n+      StubRoutines::riscv::_arrays_hashcode_powers_of_31 = generate_arrays_hashcode_powers_of_31();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+address StubRoutines::riscv::_arrays_hashcode_powers_of_31 = nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  static address _arrays_hashcode_powers_of_31;\n@@ -149,0 +150,4 @@\n+  static address arrays_hashcode_powers_of_31() {\n+    return _arrays_hashcode_powers_of_31;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}