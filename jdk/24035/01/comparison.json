{"files":[{"patch":"@@ -772,1 +772,1 @@\n- public:\n+ protected:\n@@ -803,0 +803,2 @@\n+ public:\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,1 +186,0 @@\n-\n@@ -3605,0 +3604,8 @@\n+  if (UseZtso && ((order_constraint & StoreLoad) != StoreLoad)) {\n+    \/\/ TSO allows for stores to be reordered after loads. When the compiler\n+    \/\/ generates a fence to disallow that, we are required to generate the\n+    \/\/ fence for correctness.\n+    BLOCK_COMMENT(\"elided tso membar\");\n+    return;\n+  }\n+\n@@ -3613,8 +3620,1 @@\n-  } else {\n-    code()->set_last_insn(pc());\n-\n-    uint32_t predecessor = 0;\n-    uint32_t successor = 0;\n-\n-    membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n-    fence(predecessor, successor);\n+    return;\n@@ -3622,0 +3622,6 @@\n+\n+  code()->set_last_insn(pc());\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+  membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n+  fence(predecessor, successor);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -426,5 +426,5 @@\n-    StoreStore = 0b0101,               \/\/ (pred = ow   + succ =   ow)\n-    LoadStore  = 0b1001,               \/\/ (pred = ir   + succ =   ow)\n-    StoreLoad  = 0b0110,               \/\/ (pred = ow   + succ =   ir)\n-    LoadLoad   = 0b1010,               \/\/ (pred = ir   + succ =   ir)\n-    AnyAny     = LoadStore | StoreLoad \/\/ (pred = iorw + succ = iorw)\n+    StoreStore = 0b0101,               \/\/ (pred = w   + succ = w)\n+    LoadStore  = 0b1001,               \/\/ (pred = r   + succ = w)\n+    StoreLoad  = 0b0110,               \/\/ (pred = w   + succ = r)\n+    LoadLoad   = 0b1010,               \/\/ (pred = r   + succ = r)\n+    AnyAny     = LoadStore | StoreLoad \/\/ (pred = rw  + succ = rw)\n@@ -435,0 +435,2 @@\n+ private:\n+\n@@ -446,1 +448,1 @@\n-      successor |= successor << 2;\n+      successor   |= successor << 2;\n@@ -454,15 +456,1 @@\n-  void fence(uint32_t predecessor, uint32_t successor) {\n-    if (UseZtso) {\n-      if ((pred_succ_to_membar_mask(predecessor, successor) & StoreLoad) == StoreLoad) {\n-        \/\/ TSO allows for stores to be reordered after loads. When the compiler\n-        \/\/ generates a fence to disallow that, we are required to generate the\n-        \/\/ fence for correctness.\n-        Assembler::fence(predecessor, successor);\n-      } else {\n-        \/\/ TSO guarantees other fences already.\n-      }\n-    } else {\n-      \/\/ always generate fence for RVWMO\n-      Assembler::fence(predecessor, successor);\n-    }\n-  }\n+ public:\n@@ -473,0 +461,2 @@\n+    \/\/ Zihintpause\n+    \/\/ PAUSE is encoded as a FENCE instruction with pred=W, succ=0, fm=0, rd=x0, and rs1=x0.\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -4454,0 +4454,6 @@\n+\/\/ The real do-nothing guy\n+pipe_class real_empty()\n+%{\n+    instruction_count(0);\n+%}\n+\n@@ -7880,1 +7886,4 @@\n-instruct load_fence() %{\n+\/\/ ZTSO\n+\n+instruct no_membar_rvtso() %{\n+  predicate(UseZtso);\n@@ -7882,1 +7891,9 @@\n-  ins_cost(ALU_COST);\n+  match(StoreFence);\n+  match(StoreStoreFence);\n+  match(MemBarAcquire);\n+  match(MemBarRelease);\n+  match(MemBarStoreStore);\n+  match(MemBarAcquireLock);\n+  match(MemBarReleaseLock);\n+\n+  ins_cost(0);\n@@ -7884,1 +7901,1 @@\n-  format %{ \"#@load_fence\" %}\n+  size(0);\n@@ -7886,0 +7903,1 @@\n+  format %{ \"no_membar_rvtso elided\/tso (empty encoding)\" %}\n@@ -7887,1 +7905,1 @@\n-    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+    __ block_comment(\"no_membar_rvtso\");\n@@ -7889,1 +7907,1 @@\n-  ins_pipe(pipe_serial);\n+  ins_pipe(real_empty);\n@@ -7892,3 +7910,4 @@\n-instruct membar_acquire() %{\n-  match(MemBarAcquire);\n-  ins_cost(ALU_COST);\n+instruct membar_volatile_rvtso() %{\n+  predicate(UseZtso);\n+  match(MemBarVolatile);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -7896,2 +7915,2 @@\n-  format %{ \"#@membar_acquire\\n\\t\"\n-            \"fence ir iorw\" %}\n+  format %{ \"membar_volatile_rvtso\\n\\t\"\n+            \"fence w, r\"%}\n@@ -7900,2 +7919,2 @@\n-    __ block_comment(\"membar_acquire\");\n-    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+    __ block_comment(\"membar_volatile_rvtso\");\n+    __ membar(MacroAssembler::StoreLoad);\n@@ -7904,1 +7923,1 @@\n-  ins_pipe(pipe_serial);\n+  ins_pipe(pipe_slow);\n@@ -7907,2 +7926,3 @@\n-instruct membar_acquire_lock() %{\n-  match(MemBarAcquireLock);\n+instruct unnecessary_membar_volatile_rvtso() %{\n+  predicate(UseZtso && Matcher::post_store_load_barrier(n));\n+  match(MemBarVolatile);\n@@ -7911,2 +7931,3 @@\n-  format %{ \"#@membar_acquire_lock (elided)\" %}\n-\n+  size(0);\n+  \n+  format %{ \"unnecessary_membar_volatile_rvtso (unnecessary so empty encoding)\" %}\n@@ -7914,1 +7935,2 @@\n-    __ block_comment(\"membar_acquire_lock (elided)\");\n+    assert(UseZtso, \"Must be\");\n+    __ block_comment(\"unnecessary_membar_volatile_rvtso\");\n@@ -7916,2 +7938,1 @@\n-\n-  ins_pipe(pipe_serial);\n+  ins_pipe(real_empty);\n@@ -7920,3 +7941,1 @@\n-instruct store_fence() %{\n-  match(StoreFence);\n-  ins_cost(ALU_COST);\n+\/\/ RVWMO\n@@ -7924,1 +7943,8 @@\n-  format %{ \"#@store_fence\" %}\n+instruct membar_rvwmo_aqcuire() %{\n+  predicate(!UseZtso);\n+  match(LoadFence);\n+  match(MemBarAcquire);\n+  ins_cost(VOLATILE_REF_COST);\n+\n+  format %{ \"membar_rvwmo_aqcuire\\n\\t\"\n+            \"fence r, rw\" %}\n@@ -7927,1 +7953,2 @@\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+    __ block_comment(\"membar_rvwmo_aqcuire\");\n+    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n@@ -7932,1 +7959,3 @@\n-instruct membar_release() %{\n+instruct membar_rvwmo_release() %{\n+  predicate(!UseZtso);\n+  match(StoreFence);\n@@ -7934,1 +7963,1 @@\n-  ins_cost(ALU_COST);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -7936,2 +7965,2 @@\n-  format %{ \"#@membar_release\\n\\t\"\n-            \"fence iorw ow\" %}\n+  format %{ \"membar_rvwmo_release\\n\\t\"\n+            \"fence rw, w\" %}\n@@ -7940,1 +7969,1 @@\n-    __ block_comment(\"membar_release\");\n+    __ block_comment(\"membar_rvwmo_release\");\n@@ -7946,1 +7975,2 @@\n-instruct membar_storestore() %{\n+instruct membar_rvwmo_storestore() %{\n+  predicate(!UseZtso);\n@@ -7949,1 +7979,1 @@\n-  ins_cost(ALU_COST);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -7951,1 +7981,2 @@\n-  format %{ \"MEMBAR-store-store\\t#@membar_storestore\" %}\n+  format %{ \"membar_rvwmo_storestore\\n\\t\"\n+            \"fence w, w\" %}\n@@ -7959,3 +7990,4 @@\n-instruct membar_release_lock() %{\n-  match(MemBarReleaseLock);\n-  ins_cost(0);\n+instruct membar_rvwmo_volatile() %{\n+  predicate(!UseZtso);\n+  match(MemBarVolatile);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -7963,1 +7995,2 @@\n-  format %{ \"#@membar_release_lock (elided)\" %}\n+  format %{ \"membar_rvwmo_volatile\\n\\t\"\n+             \"fence w, r\"%}\n@@ -7966,1 +7999,2 @@\n-    __ block_comment(\"membar_release_lock (elided)\");\n+    __ block_comment(\"membar_rvwmo_volatile\");\n+    __ membar(MacroAssembler::StoreLoad);\n@@ -7972,3 +8006,5 @@\n-instruct membar_volatile() %{\n-  match(MemBarVolatile);\n-  ins_cost(ALU_COST);\n+instruct membar_rvwmo_lock() %{\n+  predicate(!UseZtso);\n+  match(MemBarAcquireLock);\n+  match(MemBarReleaseLock);\n+  ins_cost(0);\n@@ -7976,2 +8012,1 @@\n-  format %{ \"#@membar_volatile\\n\\t\"\n-             \"fence iorw iorw\"%}\n+  format %{ \"membar_rvwmo_lock (elided)\" %}\n@@ -7980,2 +8015,1 @@\n-    __ block_comment(\"membar_volatile\");\n-    __ membar(MacroAssembler::StoreLoad);\n+    __ block_comment(\"membar_rvwmo_lock (elided)\");\n@@ -7987,0 +8021,13 @@\n+instruct unnecessary_membar_volatile_rvwmo() %{\n+  predicate(!UseZtso && Matcher::post_store_load_barrier(n));\n+  match(MemBarVolatile);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"unnecessary_membar_volatile_rvwmo (unnecessary so empty encoding)\" %}\n+  ins_encode %{\n+    __ block_comment(\"unnecessary_membar_volatile_rvwmo\");\n+  %}\n+  ins_pipe(real_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":92,"deletions":45,"binary":false,"changes":137,"status":"modified"}]}