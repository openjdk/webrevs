{"files":[{"patch":"@@ -772,1 +772,1 @@\n- public:\n+ protected:\n@@ -803,0 +803,2 @@\n+ public:\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,1 +186,0 @@\n-\n@@ -3605,0 +3604,8 @@\n+  if (UseZtso && ((order_constraint & StoreLoad) != StoreLoad)) {\n+    \/\/ TSO allows for stores to be reordered after loads. When the compiler\n+    \/\/ generates a fence to disallow that, we are required to generate the\n+    \/\/ fence for correctness.\n+    BLOCK_COMMENT(\"elided tso membar\");\n+    return;\n+  }\n+\n@@ -3613,8 +3620,1 @@\n-  } else {\n-    code()->set_last_insn(pc());\n-\n-    uint32_t predecessor = 0;\n-    uint32_t successor = 0;\n-\n-    membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n-    fence(predecessor, successor);\n+    return;\n@@ -3622,0 +3622,6 @@\n+\n+  code()->set_last_insn(pc());\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+  membar_mask_to_pred_succ(order_constraint, predecessor, successor);\n+  fence(predecessor, successor);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -426,5 +426,5 @@\n-    StoreStore = 0b0101,               \/\/ (pred = ow   + succ =   ow)\n-    LoadStore  = 0b1001,               \/\/ (pred = ir   + succ =   ow)\n-    StoreLoad  = 0b0110,               \/\/ (pred = ow   + succ =   ir)\n-    LoadLoad   = 0b1010,               \/\/ (pred = ir   + succ =   ir)\n-    AnyAny     = LoadStore | StoreLoad \/\/ (pred = iorw + succ = iorw)\n+    StoreStore = 0b0101,               \/\/ (pred = w   + succ = w)\n+    LoadStore  = 0b1001,               \/\/ (pred = r   + succ = w)\n+    StoreLoad  = 0b0110,               \/\/ (pred = w   + succ = r)\n+    LoadLoad   = 0b1010,               \/\/ (pred = r   + succ = r)\n+    AnyAny     = LoadStore | StoreLoad \/\/ (pred = rw  + succ = rw)\n@@ -435,0 +435,2 @@\n+ private:\n+\n@@ -446,1 +448,1 @@\n-      successor |= successor << 2;\n+      successor   |= successor << 2;\n@@ -454,15 +456,1 @@\n-  void fence(uint32_t predecessor, uint32_t successor) {\n-    if (UseZtso) {\n-      if ((pred_succ_to_membar_mask(predecessor, successor) & StoreLoad) == StoreLoad) {\n-        \/\/ TSO allows for stores to be reordered after loads. When the compiler\n-        \/\/ generates a fence to disallow that, we are required to generate the\n-        \/\/ fence for correctness.\n-        Assembler::fence(predecessor, successor);\n-      } else {\n-        \/\/ TSO guarantees other fences already.\n-      }\n-    } else {\n-      \/\/ always generate fence for RVWMO\n-      Assembler::fence(predecessor, successor);\n-    }\n-  }\n+ public:\n@@ -473,0 +461,2 @@\n+    \/\/ Zihintpause\n+    \/\/ PAUSE is encoded as a FENCE instruction with pred=W, succ=0, fm=0, rd=x0, and rs1=x0.\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -4458,0 +4458,6 @@\n+\/\/ The real do-nothing guy\n+pipe_class real_empty()\n+%{\n+    instruction_count(0);\n+%}\n+\n@@ -7944,1 +7950,4 @@\n-instruct load_fence() %{\n+\/\/ ZTSO\n+\n+instruct no_membar_rvtso() %{\n+  predicate(UseZtso);\n@@ -7946,1 +7955,9 @@\n-  ins_cost(ALU_COST);\n+  match(StoreFence);\n+  match(StoreStoreFence);\n+  match(MemBarAcquire);\n+  match(MemBarRelease);\n+  match(MemBarStoreStore);\n+  match(MemBarAcquireLock);\n+  match(MemBarReleaseLock);\n+\n+  ins_cost(0);\n@@ -7948,1 +7965,1 @@\n-  format %{ \"#@load_fence\" %}\n+  size(0);\n@@ -7950,0 +7967,1 @@\n+  format %{ \"no_membar_rvtso elided\/tso (empty encoding)\" %}\n@@ -7951,1 +7969,1 @@\n-    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+    __ block_comment(\"no_membar_rvtso\");\n@@ -7953,1 +7971,1 @@\n-  ins_pipe(pipe_serial);\n+  ins_pipe(real_empty);\n@@ -7956,3 +7974,4 @@\n-instruct membar_acquire() %{\n-  match(MemBarAcquire);\n-  ins_cost(ALU_COST);\n+instruct membar_volatile_rvtso() %{\n+  predicate(UseZtso);\n+  match(MemBarVolatile);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -7960,2 +7979,2 @@\n-  format %{ \"#@membar_acquire\\n\\t\"\n-            \"fence ir iorw\" %}\n+  format %{ \"membar_volatile_rvtso\\n\\t\"\n+            \"fence w, r\"%}\n@@ -7964,2 +7983,2 @@\n-    __ block_comment(\"membar_acquire\");\n-    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+    __ block_comment(\"membar_volatile_rvtso\");\n+    __ membar(MacroAssembler::StoreLoad);\n@@ -7968,1 +7987,1 @@\n-  ins_pipe(pipe_serial);\n+  ins_pipe(pipe_slow);\n@@ -7971,2 +7990,3 @@\n-instruct membar_acquire_lock() %{\n-  match(MemBarAcquireLock);\n+instruct unnecessary_membar_volatile_rvtso() %{\n+  predicate(UseZtso && Matcher::post_store_load_barrier(n));\n+  match(MemBarVolatile);\n@@ -7975,2 +7995,3 @@\n-  format %{ \"#@membar_acquire_lock (elided)\" %}\n-\n+  size(0);\n+  \n+  format %{ \"unnecessary_membar_volatile_rvtso (unnecessary so empty encoding)\" %}\n@@ -7978,1 +7999,2 @@\n-    __ block_comment(\"membar_acquire_lock (elided)\");\n+    assert(UseZtso, \"Must be\");\n+    __ block_comment(\"unnecessary_membar_volatile_rvtso\");\n@@ -7980,2 +8002,1 @@\n-\n-  ins_pipe(pipe_serial);\n+  ins_pipe(real_empty);\n@@ -7984,3 +8005,1 @@\n-instruct store_fence() %{\n-  match(StoreFence);\n-  ins_cost(ALU_COST);\n+\/\/ RVWMO\n@@ -7988,1 +8007,8 @@\n-  format %{ \"#@store_fence\" %}\n+instruct membar_rvwmo_aqcuire() %{\n+  predicate(!UseZtso);\n+  match(LoadFence);\n+  match(MemBarAcquire);\n+  ins_cost(VOLATILE_REF_COST);\n+\n+  format %{ \"membar_rvwmo_aqcuire\\n\\t\"\n+            \"fence r, rw\" %}\n@@ -7991,1 +8017,2 @@\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+    __ block_comment(\"membar_rvwmo_aqcuire\");\n+    __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n@@ -7996,1 +8023,3 @@\n-instruct membar_release() %{\n+instruct membar_rvwmo_release() %{\n+  predicate(!UseZtso);\n+  match(StoreFence);\n@@ -7998,1 +8027,1 @@\n-  ins_cost(ALU_COST);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -8000,2 +8029,2 @@\n-  format %{ \"#@membar_release\\n\\t\"\n-            \"fence iorw ow\" %}\n+  format %{ \"membar_rvwmo_release\\n\\t\"\n+            \"fence rw, w\" %}\n@@ -8004,1 +8033,1 @@\n-    __ block_comment(\"membar_release\");\n+    __ block_comment(\"membar_rvwmo_release\");\n@@ -8010,1 +8039,2 @@\n-instruct membar_storestore() %{\n+instruct membar_rvwmo_storestore() %{\n+  predicate(!UseZtso);\n@@ -8013,1 +8043,1 @@\n-  ins_cost(ALU_COST);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -8015,1 +8045,2 @@\n-  format %{ \"MEMBAR-store-store\\t#@membar_storestore\" %}\n+  format %{ \"membar_rvwmo_storestore\\n\\t\"\n+            \"fence w, w\" %}\n@@ -8023,3 +8054,4 @@\n-instruct membar_release_lock() %{\n-  match(MemBarReleaseLock);\n-  ins_cost(0);\n+instruct membar_rvwmo_volatile() %{\n+  predicate(!UseZtso);\n+  match(MemBarVolatile);\n+  ins_cost(VOLATILE_REF_COST);\n@@ -8027,1 +8059,2 @@\n-  format %{ \"#@membar_release_lock (elided)\" %}\n+  format %{ \"membar_rvwmo_volatile\\n\\t\"\n+             \"fence w, r\"%}\n@@ -8030,1 +8063,2 @@\n-    __ block_comment(\"membar_release_lock (elided)\");\n+    __ block_comment(\"membar_rvwmo_volatile\");\n+    __ membar(MacroAssembler::StoreLoad);\n@@ -8036,3 +8070,5 @@\n-instruct membar_volatile() %{\n-  match(MemBarVolatile);\n-  ins_cost(ALU_COST);\n+instruct membar_rvwmo_lock() %{\n+  predicate(!UseZtso);\n+  match(MemBarAcquireLock);\n+  match(MemBarReleaseLock);\n+  ins_cost(0);\n@@ -8040,2 +8076,1 @@\n-  format %{ \"#@membar_volatile\\n\\t\"\n-             \"fence iorw iorw\"%}\n+  format %{ \"membar_rvwmo_lock (elided)\" %}\n@@ -8044,2 +8079,1 @@\n-    __ block_comment(\"membar_volatile\");\n-    __ membar(MacroAssembler::StoreLoad);\n+    __ block_comment(\"membar_rvwmo_lock (elided)\");\n@@ -8051,0 +8085,13 @@\n+instruct unnecessary_membar_volatile_rvwmo() %{\n+  predicate(!UseZtso && Matcher::post_store_load_barrier(n));\n+  match(MemBarVolatile);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"unnecessary_membar_volatile_rvwmo (unnecessary so empty encoding)\" %}\n+  ins_encode %{\n+    __ block_comment(\"unnecessary_membar_volatile_rvwmo\");\n+  %}\n+  ins_pipe(real_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":92,"deletions":45,"binary":false,"changes":137,"status":"modified"}]}