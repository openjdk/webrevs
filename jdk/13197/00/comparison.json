{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n-import java.lang.reflect.*;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -32,2 +31,9 @@\n-import jdk.internal.access.JavaLangReflectAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import jdk.internal.vm.annotation.Stable;\n@@ -35,0 +41,4 @@\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.UndeclaredThrowableException;\n@@ -36,0 +46,4 @@\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -40,0 +54,2 @@\n+\n+import static java.lang.constant.ConstantDescs.*;\n@@ -41,0 +57,1 @@\n+import static jdk.internal.classfile.Classfile.*;\n@@ -165,0 +182,3 @@\n+        if (intfc.isHidden())\n+            throw newIllegalArgumentException(\"a hidden interface\", intfc.getName());\n+        Objects.requireNonNull(target);\n@@ -174,4 +194,7 @@\n-        ClassLoader proxyLoader = intfc.getClassLoader();\n-        if (proxyLoader == null) {\n-            ClassLoader cl = Thread.currentThread().getContextClassLoader(); \/\/ avoid use of BCP\n-            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();\n+\n+        \/\/ We will just define the class as hidden under the interface\n+        var info = IMPLEMENTATION_INFOS.get(intfc);\n+        MethodHandle[] mhs = new MethodHandle[info.types.length + 1];\n+        mhs[0] = target;\n+        for (int i = 1; i < mhs.length; i++) {\n+            mhs[i] = mh.asType(info.types[i - 1]);\n@@ -179,10 +202,6 @@\n-        final Method[] methods = getSingleNameMethods(intfc);\n-        if (methods == null)\n-            throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n-        final MethodHandle[] vaTargets = new MethodHandle[methods.length];\n-        for (int i = 0; i < methods.length; i++) {\n-            Method sm = methods[i];\n-            MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n-            MethodHandle checkTarget = mh.asType(smMT);  \/\/ make throw WMT\n-            checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));\n-            vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());\n+\n+        Object proxy;\n+        try {\n+            proxy = (Object) info.ctor.invokeExact(mhs); \/\/ non-varargs\n+        } catch (Throwable e) {\n+            throw new InternalError(\"Cannot create interface instance\", e);\n@@ -190,20 +209,26 @@\n-        final InvocationHandler ih = new InvocationHandler() {\n-                private Object getArg(String name) {\n-                    if ((Object)name == \"getWrapperInstanceTarget\")  return target;\n-                    if ((Object)name == \"getWrapperInstanceType\")    return intfc;\n-                    throw new AssertionError();\n-                }\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    for (int i = 0; i < methods.length; i++) {\n-                        if (method.equals(methods[i]))\n-                            return vaTargets[i].invokeExact(args);\n-                    }\n-                    if (method.getDeclaringClass() == WrapperInstance.class)\n-                        return getArg(method.getName());\n-                    if (isObjectMethod(method))\n-                        return callObjectMethod(proxy, method, args);\n-                    if (isDefaultMethod(method)) {\n-                        \/\/ no additional access check is performed\n-                        return JLRA.invokeDefault(proxy, method, args, null);\n-                    }\n-                    throw newInternalError(\"bad proxy method: \"+method);\n+\n+        return intfc.cast(proxy);\n+    }\n+\n+    private record LocalMethodInfo(String fieldName, MethodType mt, MethodTypeDesc desc, List<ClassDesc> thrown) {}\n+\n+    private static final ClassValue<ImplementationInfo> IMPLEMENTATION_INFOS = new ClassValue<>() {\n+        @Override\n+        protected ImplementationInfo computeValue(Class<?> intfc) {\n+            final List<Method> methods = getSingleNameMethods(intfc);\n+            if (methods == null)\n+                throw newIllegalArgumentException(\"not a single-method interface\", intfc.getName());\n+\n+            List<LocalMethodInfo> infos = new ArrayList<>(methods.size());\n+            MethodType[] types = new MethodType[methods.size()];\n+            for (int i = 0; i < methods.size(); i++) {\n+                Method sm = methods.get(i);\n+                MethodType mt = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n+                types[i] = mt;\n+                var thrown = sm.getExceptionTypes();\n+                var fieldName = \"m\" + i;\n+                if (thrown.length == 0) {\n+                    infos.add(new LocalMethodInfo(fieldName, mt, desc(mt), DEFAULT_RETHROWNS));\n+                } else {\n+                    infos.add(new LocalMethodInfo(fieldName, mt, desc(mt), Stream.concat(Stream.of(RuntimeException.class, Error.class),\n+                            Arrays.stream(thrown)).map(MethodHandleProxies::desc).distinct().toList()));\n@@ -211,1 +236,1 @@\n-            };\n+            }\n@@ -213,11 +238,74 @@\n-        final Object proxy;\n-        if (System.getSecurityManager() != null) {\n-            \/\/ sun.invoke.WrapperInstance is a restricted interface not accessible\n-            \/\/ by any non-null class loader.\n-            final ClassLoader loader = proxyLoader;\n-            proxy = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    return Proxy.newProxyInstance(\n-                            loader,\n-                            new Class<?>[]{ intfc, WrapperInstance.class },\n-                            ih);\n+            var bytes = spin(desc(intfc), methods.get(0).getName(), infos);\n+            Class<?> resultClass;\n+            MethodHandle ctor, getType, getTarget;\n+\n+            try {\n+                var lookup = new MethodHandles.Lookup(intfc).defineHiddenClass(bytes, true);\n+                resultClass = lookup.lookupClass();\n+                ctor = lookup.findConstructor(resultClass, MT_void_MethodHandleArray)\n+                        .asType(MT_Object_MethodHandleArray);\n+                getTarget = lookup.findVirtual(resultClass, WRAPPER_INSTANCE_TARGET_NAME, MT_MethodHandle)\n+                        .asType(MT_MethodHandle_Object);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n+                throw new InternalError(\"Cannot define class for interface \" + intfc.getName(), e);\n+            }\n+            return new ImplementationInfo(types, resultClass, intfc, ctor, getTarget);\n+        }\n+    };\n+\n+    \/\/ all mh have the proxy type changed to object\n+    private record ImplementationInfo(@Stable MethodType[] types, Class<?> resultClass, Class<?> ifaceClass,\n+                                      MethodHandle ctor, MethodHandle getTarget) {}\n+\n+    private static final ClassDesc CD_RuntimeException = desc(RuntimeException.class);\n+    private static final ClassDesc CD_Error = desc(Error.class);\n+    private static final List<ClassDesc> DEFAULT_RETHROWNS = List.of(CD_RuntimeException, CD_Error);\n+    private static final ClassDesc CD_WrapperInstance = desc(WrapperInstance.class);\n+    private static final String WRAPPER_INSTANCE_TARGET_NAME = \"getWrapperInstanceTarget\";\n+    private static final MethodType MT_MethodHandle = MethodType.methodType(MethodHandle.class);\n+    private static final MethodType MT_MethodHandle_Object = MethodType.methodType(MethodHandle.class, Object.class);\n+    private static final MethodType MT_void_MethodHandleArray = MethodType.methodType(void.class, MethodHandle[].class);\n+    private static final MethodType MT_Object_MethodHandleArray = MethodType.methodType(Object.class, MethodHandle[].class);\n+    private static final MethodTypeDesc MTD_MethodHandle = desc(MT_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_MethodHandleArray = desc(MT_void_MethodHandleArray);\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_int_Object = MethodTypeDesc.of(CD_int, CD_Object);\n+    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+    private static final MethodTypeDesc MTD_String_Object = MethodTypeDesc.of(CD_String, CD_Object);\n+    private static final MethodTypeDesc MTD_boolean_Object = MethodTypeDesc.of(CD_boolean, CD_Object);\n+    private static final ClassDesc CD_System = desc(System.class);\n+    private static final ClassDesc CD_Objects = desc(Objects.class);\n+    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n+    private static final MethodTypeDesc MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable);\n+    private static final String TARGET_FIELD_NAME = \"target\";\n+\n+    \/\/ Spin an implementation class for an interface. A new class should be defined for each handle.\n+    \/\/ constructor parameter: Array[target, mh1, mh2, ...]\n+    private static byte[] spin(ClassDesc ifaceDesc, String name, List<LocalMethodInfo> methods) {\n+        ClassDesc proxyDesc = ifaceDesc.nested(\"$MethodHandleProxy\");\n+        return Classfile.build(proxyDesc, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_FINAL | ACC_SYNTHETIC);\n+            clb.withInterfaceSymbols(ifaceDesc);\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(Annotation.of(CD_WrapperInstance,\n+                    AnnotationElement.of(\"implementedType\", AnnotationValue.ofClass(ifaceDesc)))));\n+            \/\/ <init>\n+            clb.withMethodBody(INIT_NAME, MTD_void_MethodHandleArray, 0, cob -> {\n+                cob.aload(0);\n+                cob.dup();\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                \/\/ target field\n+                cob.dup();\n+                cob.aload(1);\n+                cob.iconst_0();\n+                cob.aaload();\n+                cob.putfield(proxyDesc, TARGET_FIELD_NAME, CD_MethodHandle);\n+\n+                \/\/ implemented methods\n+                int i = 1;\n+                for (var method : methods) {\n+                    cob.dup();\n+                    cob.aload(1);\n+                    cob.constantInstruction(i++);\n+                    cob.aaload();\n+                    cob.putfield(proxyDesc, method.fieldName, CD_MethodHandle);\n@@ -225,0 +313,3 @@\n+\n+                cob.pop();\n+                cob.return_();\n@@ -226,7 +317,0 @@\n-        } else {\n-            proxy = Proxy.newProxyInstance(proxyLoader,\n-                                           new Class<?>[]{ intfc, WrapperInstance.class },\n-                                           ih);\n-        }\n-        return intfc.cast(proxy);\n-    }\n@@ -234,0 +318,52 @@\n+            \/\/ wrapper instance methods\n+            clb.withField(TARGET_FIELD_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+            clb.withMethodBody(WRAPPER_INSTANCE_TARGET_NAME, MTD_MethodHandle, ACC_PRIVATE, cob -> cob\n+                    .aload(0)\n+                    .getfield(proxyDesc, TARGET_FIELD_NAME, CD_MethodHandle)\n+                    .areturn());\n+\n+            \/\/ object methods\n+            clb.withMethodBody(\"toString\", MTD_String, ACC_PUBLIC, cob -> cob\n+                    .aload(0)\n+                    .invokestatic(CD_Objects, \"toIdentityString\", MTD_String_Object)\n+                    .areturn());\n+            clb.withMethodBody(\"hashCode\", MTD_int, ACC_PUBLIC, cob -> cob\n+                    .aload(0)\n+                    .invokestatic(CD_System, \"identityHashCode\", MTD_int_Object)\n+                    .ireturn());\n+            clb.withMethodBody(\"equals\", MTD_boolean_Object, ACC_PUBLIC, cob -> cob\n+                    .aload(0)\n+                    .aload(1)\n+                    .ifThenElse(Opcode.IF_ACMPEQ, CodeBuilder::iconst_1, CodeBuilder::iconst_0)\n+                    .ireturn());\n+\n+            \/\/ actual implementations\n+            for (LocalMethodInfo mi : methods) {\n+                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+                \/\/ we don't need to generate thrown exception attribute\n+                clb.withMethodBody(name, mi.desc, ACC_PUBLIC, cob -> cob\n+                        .trying(bcb -> {\n+                                    bcb.aload(0);\n+                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    int slot = 1;\n+                                    for (var t : mi.desc.parameterList()) {\n+                                        var kind = TypeKind.from(t);\n+                                        bcb.loadInstruction(kind, slot);\n+                                        slot += kind.slotSize();\n+                                    }\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", mi.desc);\n+                                    bcb.returnInstruction(TypeKind.from(mi.desc.returnType()));\n+                                },\n+                                ctb -> ctb\n+                                        .catchingMulti(mi.thrown, CodeBuilder::athrow)\n+                                        .catchingAll(cb -> cb\n+                                                .new_(CD_UndeclaredThrowableException)\n+                                                .dup_x1()\n+                                                .swap()\n+                                                .invokespecial(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable)\n+                                                .athrow()\n+                                        )\n+                        ));\n+            }\n+        });\n+    }\n@@ -244,1 +380,9 @@\n-        return x instanceof WrapperInstance;\n+        var clz = x.getClass();\n+        var anno = clz.getDeclaredAnnotation(WrapperInstance.class);\n+        if (anno == null) return false;\n+\n+        try {\n+            return IMPLEMENTATION_INFOS.get(anno.implementedType()).resultClass == clz;\n+        } catch (Throwable ex) {\n+            return false; \/\/ Not an interface, etc.\n+        }\n@@ -247,1 +391,6 @@\n-    private static WrapperInstance asWrapperInstance(Object x) {\n+    private static ImplementationInfo ensureWrapperInstance(Object x) {\n+        var clz = x.getClass();\n+        var anno = clz.getDeclaredAnnotation(WrapperInstance.class);\n+        if (anno == null) throw newIllegalArgumentException(\"not a wrapper instance: \" + x);;\n+\n+        ImplementationInfo ret;\n@@ -249,3 +398,3 @@\n-            if (x != null)\n-                return (WrapperInstance) x;\n-        } catch (ClassCastException ex) {\n+            ret = IMPLEMENTATION_INFOS.get(anno.implementedType());\n+        } catch (Throwable ex) {\n+            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n@@ -253,1 +402,5 @@\n-        throw newIllegalArgumentException(\"not a wrapper instance\");\n+\n+        if (ret.resultClass != clz)\n+            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n+\n+        return ret;\n@@ -266,1 +419,6 @@\n-        return asWrapperInstance(x).getWrapperInstanceTarget();\n+        var t = ensureWrapperInstance(x);\n+        try {\n+            return (MethodHandle) t.getTarget.invokeExact(x);\n+        } catch (Throwable ex) {\n+            throw new InternalError(\"Cannot invoke wrapperInstanceTarget\", ex);\n+        }\n@@ -278,1 +436,11 @@\n-        return asWrapperInstance(x).getWrapperInstanceType();\n+        return ensureWrapperInstance(x).ifaceClass;\n+    }\n+\n+    private static ClassDesc desc(Class<?> cl) {\n+        return cl.describeConstable().orElseThrow(() -> new InternalError(\"Cannot convert class \"\n+                + cl.getName() + \" to a constant\"));\n+    }\n+\n+    private static MethodTypeDesc desc(MethodType mt) {\n+        return mt.describeConstable().orElseThrow(() -> new InternalError(\"Cannot convert method type \"\n+                + mt + \" to a constant\"));\n@@ -294,11 +462,1 @@\n-    private static Object callObjectMethod(Object self, Method m, Object[] args) {\n-        assert(isObjectMethod(m)) : m;\n-        return switch (m.getName()) {\n-            case \"toString\" -> java.util.Objects.toIdentityString(self);\n-            case \"hashCode\" -> System.identityHashCode(self);\n-            case \"equals\"   -> (self == args[0]);\n-            default -> null;\n-        };\n-    }\n-\n-    private static Method[] getSingleNameMethods(Class<?> intfc) {\n+    private static List<Method> getSingleNameMethods(Class<?> intfc) {\n@@ -318,1 +476,1 @@\n-        return methods.toArray(new Method[methods.size()]);\n+        return methods;\n@@ -320,6 +478,0 @@\n-\n-    private static boolean isDefaultMethod(Method m) {\n-        return !Modifier.isAbstract(m.getModifiers());\n-    }\n-\n-    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":237,"deletions":85,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,4 @@\n-import java.lang.invoke.MethodHandle;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n@@ -38,0 +41,3 @@\n+ * <p>\n+ * Classes annotated with this annotation should define private methods\n+ * getWrapperInstanceTarget ()MethodHandle and getWrapperInstanceType ()Class.\n@@ -39,8 +45,4 @@\n-public interface WrapperInstance {\n-    \/** Produce or recover a target method handle which is behaviorally\n-     *  equivalent to the SAM method of this object.\n-     *\/\n-    public MethodHandle getWrapperInstanceTarget();\n-    \/** Recover the SAM type for which this object was created.\n-     *\/\n-    public Class<?> getWrapperInstanceType();\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface WrapperInstance {\n+    Class<?> implementedType();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.classfile.ClassHierarchyResolver;\n+import jdk.internal.classfile.Classfile;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.ToLongFunction;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandleProxies.*;\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.classfile.Classfile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/* @test\n+ * @bug 6983726\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Basic sanity tests for MethodHandleProxies\n+ * @run junit BasicTest\n+ *\/\n+public class BasicTest {\n+\n+    @Test\n+    public void testUsual() throws Throwable {\n+        AtomicInteger ai = new AtomicInteger(5);\n+        var mh = MethodHandles.lookup().findVirtual(AtomicInteger.class, \"getAndIncrement\", methodType(int.class));\n+        IntSupplier is = asInterfaceInstance(IntSupplier.class, mh.bindTo(ai));\n+        assertEquals(5, is.getAsInt());\n+        assertEquals(6, is.getAsInt());\n+        assertEquals(7, is.getAsInt());\n+    }\n+\n+    @Test\n+    public void testThrowables() throws Throwable {\n+        \/\/ don't wrap\n+        assertThrows(Error.class, throwing(Error.class, new Error())::close);\n+        assertThrows(RuntimeException.class, throwing(RuntimeException.class, new RuntimeException())::close);\n+        assertThrows(IOException.class, throwing(IOException.class, new IOException())::close);\n+        \/\/ wrap\n+        assertThrows(UndeclaredThrowableException.class, throwing(IllegalAccessException.class,\n+                new IllegalAccessException())::close);\n+    }\n+\n+    @Test\n+    public void testWrapperInstance() throws Throwable {\n+        Comparator<Integer> lambda = Integer::compareTo;\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> proxy = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertTrue(isWrapperInstance(proxy));\n+        assertFalse(isWrapperInstance(lambda));\n+        assertSame(mh, wrapperInstanceTarget(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceTarget(lambda));\n+        assertSame(Comparator.class, wrapperInstanceType(proxy));\n+        assertThrows(IllegalArgumentException.class, () -> wrapperInstanceType(lambda));\n+    }\n+\n+    private <T extends Throwable> Closeable throwing(Class<T> clz, T value) {\n+        return asInterfaceInstance(Closeable.class, MethodHandles.throwException(void.class, clz).bindTo(value));\n+    }\n+\n+    private static long mul(int i) {\n+        return (long) i * i;\n+    }\n+\n+    @Test\n+    public void testConversion() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(BasicTest.class, \"mul\", methodType(long.class, int.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Long> func = (Function<Integer, Long>) asInterfaceInstance(Function.class, mh);\n+        assertEquals(32423432L * 32423432L, func.apply(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        ToLongFunction<Integer> func1 = (ToLongFunction<Integer>) asInterfaceInstance(ToLongFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func1.applyAsLong(32423432));\n+        @SuppressWarnings(\"unchecked\")\n+        IntFunction<Long> func2 = (IntFunction<Long>) asInterfaceInstance(IntFunction.class, mh);\n+        assertEquals(32423432L * 32423432L, func2.apply(32423432));\n+    }\n+\n+    @Test\n+    public void testMultiAbstract() throws Throwable {\n+        var baseAndChild = loadBaseAndChild();\n+        var baseClass = baseAndChild.get(0);\n+        var childClass = baseAndChild.get(1);\n+        checkMethods(childClass.getMethods());\n+        checkMethods(childClass.getDeclaredMethods());\n+\n+        var lookup = MethodHandles.lookup();\n+        var baseValueMh = lookup.findVirtual(baseClass, \"value\", genericMethodType(0))\n+                .asType(genericMethodType(1));\n+        var childIntegerValueMh = lookup.findVirtual(childClass, \"value\", methodType(Integer.class))\n+                .asType(methodType(Integer.class, Object.class));\n+        var childIntValueMh = lookup.findVirtual(childClass, \"value\", methodType(int.class))\n+                .asType(methodType(int.class, Object.class));\n+\n+        Object child = asInterfaceInstance(childClass, MethodHandles.constant(Integer.class, 7));\n+\n+        assertEquals(7, (Object) baseValueMh.invokeExact(child));\n+        assertEquals(7, (Integer) childIntegerValueMh.invokeExact(child));\n+        assertEquals(7, (int) childIntValueMh.invokeExact(child));\n+    }\n+\n+    @Test\n+    public void testRejects() {\n+        var mh = MethodHandles.constant(String.class, \"42\");\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(Inaccessible.class, mh));\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(loadHidden(), mh));\n+        assertThrows(WrongMethodTypeException.class, () -> asInterfaceInstance(IntSupplier.class, mh));\n+    }\n+\n+    void checkMethods(Method[] methods) {\n+        assertTrue(methods.length > 1, () -> \"Should have more than 1 declared methods, found only \" + Arrays.toString(methods));\n+        for (Method method : methods) {\n+            assertTrue(method.accessFlags().contains(AccessFlag.ABSTRACT), () -> method + \" is not abstract\");\n+        }\n+    }\n+\n+    private Class<?> loadHidden() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$HiddenItf\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var baseBytes = Classfile.build(baseCd, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        return lookup.defineHiddenClass(baseBytes, true).lookupClass();\n+    }\n+\n+    \/\/ Base: Object value();\n+    \/\/ Child: Integer value(); int value();\n+    private List<Class<?>> loadBaseAndChild() throws IllegalAccessException {\n+        ClassDesc baseCd = ClassDesc.of(\"BasicTest$Base\");\n+        ClassDesc childCd = ClassDesc.of(\"BasicTest$Child\");\n+        var objMtd = MethodTypeDesc.of(CD_Object);\n+        var integerMtd = MethodTypeDesc.of(CD_Integer);\n+        var intMtd = MethodTypeDesc.of(CD_int);\n+        var chi = ClassHierarchyResolver.DEFAULT_CLASS_HIERARCHY_RESOLVER.orElse(\n+                ClassHierarchyResolver.of(List.of(baseCd, childCd), Map.ofEntries(Map.entry(baseCd, CD_Object),\n+                        Map.entry(childCd, CD_Object))));\n+\n+        var baseBytes = Classfile.build(baseCd, List.of(Option.classHierarchyResolver(chi)), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", objMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var lookup = MethodHandles.lookup();\n+        var base = lookup.ensureInitialized(lookup.defineClass(baseBytes));\n+\n+        var childBytes = Classfile.build(childCd, List.of(Option.classHierarchyResolver(chi)), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(baseCd);\n+            clb.withFlags(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n+            clb.withMethod(\"value\", integerMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+            clb.withMethod(\"value\", intMtd, ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n+\n+        var child = lookup.ensureInitialized(lookup.defineClass(childBytes));\n+        return List.of(base, child);\n+    }\n+}\n+\n+interface Inaccessible {\n+    Object value();\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-\/**\n- * @test\n- * @summary test MethodHandleProxies that adds qualified export of sun.invoke\n- * from java.base to a dynamic module\n- * @run testng ProxyForMethodHandle\n- *\/\n-public class ProxyForMethodHandle {\n-    \/**\n-     * MethodHandleProxies will add qualified export of sun.invoke from java.base\n-     * to a dynamic module\n-     *\/\n-    @Test\n-    public static void testRunnableMethodHandle() throws Exception {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodType mt = MethodType.methodType(void.class);\n-        MethodHandle mh = lookup.findStatic(ProxyForMethodHandle.class, \"runForRunnable\", mt);\n-        Runnable proxy = MethodHandleProxies.asInterfaceInstance(Runnable.class, mh);\n-        proxy.run();\n-\n-        Class<?> proxyClass = proxy.getClass();\n-        Module target = proxyClass.getModule();\n-        assertDynamicModule(target, proxyClass.getClassLoader(), proxyClass);\n-    }\n-\n-    static void runForRunnable() {\n-        System.out.println(\"runForRunnable\");\n-    }\n-\n-    public static void assertDynamicModule(Module m, ClassLoader ld, Class<?> proxyClass) {\n-        if (!m.isNamed() || !m.getName().startsWith(\"jdk.proxy\")) {\n-            throw new RuntimeException(m.getName() + \" not dynamic module\");\n-        }\n-\n-        if (ld != m.getClassLoader() || proxyClass.getClassLoader() != ld) {\n-            throw new RuntimeException(\"unexpected class loader\");\n-        }\n-\n-        try {\n-            Constructor<?> cons = proxyClass.getConstructor(InvocationHandler.class);\n-            cons.newInstance(handler);\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n-        } catch (IllegalAccessException e) {\n-            \/\/ expected\n-        } catch (NoSuchMethodException|InstantiationException|InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-    private final static InvocationHandler handler =\n-            (proxy, m, params) -> { throw new RuntimeException(m.toString()); };\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyForMethodHandle.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"}]}