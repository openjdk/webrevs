{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.DynamicConstantDesc;\n@@ -36,1 +37,0 @@\n-import jdk.internal.classfile.Opcode;\n@@ -42,0 +42,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -57,0 +58,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -195,3 +197,3 @@\n-        \/\/ We will just define the class as hidden under the interface\n-        var info = IMPLEMENTATION_INFOS.get(intfc);\n-        MethodHandle[] mhs = new MethodHandle[info.types.length + 1];\n+        \/\/ Interface-specific setup\n+        var info = INTERFACE_INFOS.get(intfc); \/\/ throws IllegalArgumentException\n+        var mhs = new MethodHandle[info.types.length + 1];\n@@ -200,1 +202,1 @@\n-            mhs[i] = mh.asType(info.types[i - 1]);\n+            mhs[i] = mh.asType(info.types[i - 1]); \/\/ throws WrongMethodTypeException\n@@ -203,0 +205,1 @@\n+        \/\/ Define the class under the interface\n@@ -205,1 +208,4 @@\n-            proxy = (Object) info.ctor.invokeExact(mhs); \/\/ non-varargs\n+            \/\/ Intentionally weak + no nestmate\n+            var lookup = info.lookup.defineHiddenClassWithClassData(info.template, List.of(mhs), true);\n+            proxy = lookup.findConstructor(lookup.lookupClass(), methodType(void.class))\n+                    .asType(methodType(Object.class)).invokeExact();\n@@ -213,1 +219,1 @@\n-    private record LocalMethodInfo(String fieldName, MethodType mt, MethodTypeDesc desc, List<ClassDesc> thrown) {}\n+    private record LocalMethodInfo(MethodTypeDesc desc, List<ClassDesc> thrown) {}\n@@ -215,1 +221,7 @@\n-    private static final ClassValue<ImplementationInfo> IMPLEMENTATION_INFOS = new ClassValue<>() {\n+    private record InterfaceInfo(@Stable MethodType[] types, Lookup lookup, @Stable byte[] template) {}\n+\n+    private record WrapperInfo(Class<?> type, MethodHandle target) {\n+        private static final WrapperInfo INVALID = new WrapperInfo(null, null);\n+    }\n+\n+    private static final ClassValue<InterfaceInfo> INTERFACE_INFOS = new ClassValue<>() {\n@@ -217,1 +229,1 @@\n-        protected ImplementationInfo computeValue(Class<?> intfc) {\n+        protected InterfaceInfo computeValue(Class<?> intfc) {\n@@ -226,1 +238,1 @@\n-                MethodType mt = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());\n+                MethodType mt = methodType(sm.getReturnType(), sm.getParameterTypes());\n@@ -229,1 +241,0 @@\n-                var fieldName = \"m\" + i;\n@@ -231,1 +242,1 @@\n-                    infos.add(new LocalMethodInfo(fieldName, mt, desc(mt), DEFAULT_RETHROWNS));\n+                    infos.add(new LocalMethodInfo(desc(mt), DEFAULT_RETHROWNS));\n@@ -233,1 +244,1 @@\n-                    infos.add(new LocalMethodInfo(fieldName, mt, desc(mt), Stream.concat(Stream.of(RuntimeException.class, Error.class),\n+                    infos.add(new LocalMethodInfo(desc(mt), Stream.concat(Stream.of(RuntimeException.class, Error.class),\n@@ -238,3 +249,11 @@\n-            var bytes = spin(desc(intfc), methods.get(0).getName(), infos);\n-            Class<?> resultClass;\n-            MethodHandle ctor, getType, getTarget;\n+            var template = createTemplate(desc(intfc), methods.get(0).getName(), infos);\n+            return new InterfaceInfo(types, new Lookup(intfc), template);\n+        }\n+    };\n+\n+    private static final ClassValue<WrapperInfo> WRAPPER_INFOS = new ClassValue<>() {\n+        @Override\n+        protected WrapperInfo computeValue(Class<?> type) {\n+            var anno = type.getDeclaredAnnotation(WrapperInstance.class);\n+            if (anno == null)\n+                return WrapperInfo.INVALID;\n@@ -242,0 +261,2 @@\n+            var implementedType = anno.implementedType();\n+            InterfaceInfo itfInfo;\n@@ -243,8 +264,4 @@\n-                var lookup = new MethodHandles.Lookup(intfc).defineHiddenClass(bytes, true);\n-                resultClass = lookup.lookupClass();\n-                ctor = lookup.findConstructor(resultClass, MT_void_MethodHandleArray)\n-                        .asType(MT_Object_MethodHandleArray);\n-                getTarget = lookup.findVirtual(resultClass, WRAPPER_INSTANCE_TARGET_NAME, MT_MethodHandle)\n-                        .asType(MT_MethodHandle_Object);\n-            } catch (IllegalAccessException | NoSuchMethodException e) {\n-                throw new InternalError(\"Cannot define class for interface \" + intfc.getName(), e);\n+                itfInfo = INTERFACE_INFOS.get(implementedType);\n+            } catch (IllegalArgumentException ex) {\n+                \/\/ bad interface in WrapperInstance anno, may be attacks\n+                return WrapperInfo.INVALID;\n@@ -252,1 +269,8 @@\n-            return new ImplementationInfo(types, resultClass, intfc, ctor, getTarget);\n+\n+            if ((MethodHandles.classData(type) instanceof List<?> l)\n+                    && l.size() == itfInfo.types.length + 1\n+                    && l.get(0) instanceof MethodHandle mh) {\n+                return new WrapperInfo(implementedType, mh);\n+            }\n+\n+            return WrapperInfo.INVALID;\n@@ -256,4 +280,0 @@\n-    \/\/ all mh have the proxy type changed to object\n-    private record ImplementationInfo(@Stable MethodType[] types, Class<?> resultClass, Class<?> ifaceClass,\n-                                      MethodHandle ctor, MethodHandle getTarget) {}\n-\n@@ -264,14 +284,0 @@\n-    private static final String WRAPPER_INSTANCE_TARGET_NAME = \"getWrapperInstanceTarget\";\n-    private static final MethodType MT_MethodHandle = MethodType.methodType(MethodHandle.class);\n-    private static final MethodType MT_MethodHandle_Object = MethodType.methodType(MethodHandle.class, Object.class);\n-    private static final MethodType MT_void_MethodHandleArray = MethodType.methodType(void.class, MethodHandle[].class);\n-    private static final MethodType MT_Object_MethodHandleArray = MethodType.methodType(Object.class, MethodHandle[].class);\n-    private static final MethodTypeDesc MTD_MethodHandle = desc(MT_MethodHandle);\n-    private static final MethodTypeDesc MTD_void_MethodHandleArray = desc(MT_void_MethodHandleArray);\n-    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n-    private static final MethodTypeDesc MTD_int_Object = MethodTypeDesc.of(CD_int, CD_Object);\n-    private static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n-    private static final MethodTypeDesc MTD_String_Object = MethodTypeDesc.of(CD_String, CD_Object);\n-    private static final MethodTypeDesc MTD_boolean_Object = MethodTypeDesc.of(CD_boolean, CD_Object);\n-    private static final ClassDesc CD_System = desc(System.class);\n-    private static final ClassDesc CD_Objects = desc(Objects.class);\n@@ -280,1 +286,0 @@\n-    private static final String TARGET_FIELD_NAME = \"target\";\n@@ -284,1 +289,1 @@\n-    private static byte[] spin(ClassDesc ifaceDesc, String name, List<LocalMethodInfo> methods) {\n+    private static byte[] createTemplate(ClassDesc ifaceDesc, String name, List<LocalMethodInfo> methods) {\n@@ -293,28 +298,1 @@\n-            clb.withMethodBody(INIT_NAME, MTD_void_MethodHandleArray, 0, cob -> {\n-                cob.aload(0);\n-                cob.dup();\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                \/\/ target field\n-                cob.dup();\n-                cob.aload(1);\n-                cob.iconst_0();\n-                cob.aaload();\n-                cob.putfield(proxyDesc, TARGET_FIELD_NAME, CD_MethodHandle);\n-\n-                \/\/ implemented methods\n-                int i = 1;\n-                for (var method : methods) {\n-                    cob.dup();\n-                    cob.aload(1);\n-                    cob.constantInstruction(i++);\n-                    cob.aaload();\n-                    cob.putfield(proxyDesc, method.fieldName, CD_MethodHandle);\n-                }\n-\n-                cob.pop();\n-                cob.return_();\n-            });\n-\n-            \/\/ wrapper instance methods\n-            clb.withField(TARGET_FIELD_NAME, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n-            clb.withMethodBody(WRAPPER_INSTANCE_TARGET_NAME, MTD_MethodHandle, ACC_PRIVATE, cob -> cob\n+            clb.withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n@@ -322,17 +300,2 @@\n-                    .getfield(proxyDesc, TARGET_FIELD_NAME, CD_MethodHandle)\n-                    .areturn());\n-\n-            \/\/ object methods\n-            clb.withMethodBody(\"toString\", MTD_String, ACC_PUBLIC, cob -> cob\n-                    .aload(0)\n-                    .invokestatic(CD_Objects, \"toIdentityString\", MTD_String_Object)\n-                    .areturn());\n-            clb.withMethodBody(\"hashCode\", MTD_int, ACC_PUBLIC, cob -> cob\n-                    .aload(0)\n-                    .invokestatic(CD_System, \"identityHashCode\", MTD_int_Object)\n-                    .ireturn());\n-            clb.withMethodBody(\"equals\", MTD_boolean_Object, ACC_PUBLIC, cob -> cob\n-                    .aload(0)\n-                    .aload(1)\n-                    .ifThenElse(Opcode.IF_ACMPEQ, CodeBuilder::iconst_1, CodeBuilder::iconst_0)\n-                    .ireturn());\n+                    .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                    .return_());\n@@ -341,0 +304,1 @@\n+            int i = 1;\n@@ -342,1 +306,1 @@\n-                clb.withField(mi.fieldName, CD_MethodHandle, ACC_PRIVATE | ACC_FINAL);\n+                var condy = DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, CD_MethodHandle, i++);\n@@ -346,2 +310,1 @@\n-                                    bcb.aload(0);\n-                                    bcb.getfield(proxyDesc, mi.fieldName, CD_MethodHandle);\n+                                    bcb.constantInstruction(condy);\n@@ -370,0 +333,1 @@\n+\n@@ -380,9 +344,1 @@\n-        var clz = x.getClass();\n-        var anno = clz.getDeclaredAnnotation(WrapperInstance.class);\n-        if (anno == null) return false;\n-\n-        try {\n-            return IMPLEMENTATION_INFOS.get(anno.implementedType()).resultClass == clz;\n-        } catch (Throwable ex) {\n-            return false; \/\/ Not an interface, etc.\n-        }\n+        return WRAPPER_INFOS.get(x.getClass()) != WrapperInfo.INVALID;\n@@ -391,14 +347,4 @@\n-    private static ImplementationInfo ensureWrapperInstance(Object x) {\n-        var clz = x.getClass();\n-        var anno = clz.getDeclaredAnnotation(WrapperInstance.class);\n-        if (anno == null) throw newIllegalArgumentException(\"not a wrapper instance: \" + x);;\n-\n-        ImplementationInfo ret;\n-        try {\n-            ret = IMPLEMENTATION_INFOS.get(anno.implementedType());\n-        } catch (Throwable ex) {\n-            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n-        }\n-\n-        if (ret.resultClass != clz)\n-            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);\n+    private static WrapperInfo ensureWrapperInstance(Object x) {\n+        var ret = WRAPPER_INFOS.get(x.getClass());\n+        if (ret == WrapperInfo.INVALID)\n+            throw newIllegalArgumentException(\"not a wrapper instance: \" + x);;\n@@ -419,6 +365,1 @@\n-        var t = ensureWrapperInstance(x);\n-        try {\n-            return (MethodHandle) t.getTarget.invokeExact(x);\n-        } catch (Throwable ex) {\n-            throw new InternalError(\"Cannot invoke wrapperInstanceTarget\", ex);\n-        }\n+        return ensureWrapperInstance(x).target;\n@@ -436,1 +377,1 @@\n-        return ensureWrapperInstance(x).ifaceClass;\n+        return ensureWrapperInstance(x).type;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":64,"deletions":123,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -35,4 +35,4 @@\n- * Interface implemented by every object which is produced by\n- * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance MethodHandleProxies.asInterfaceInstance}.\n- * The methods of this interface allow a caller to recover the parameters\n- * to {@code asInstance}.\n+ * This annotation is present on by every class produced by\n+ * {@link java.lang.invoke.MethodHandleProxies#asInterfaceInstance\n+ * MethodHandleProxies.asInterfaceInstance}.\n+ * <p>\n@@ -42,2 +42,8 @@\n- * Classes annotated with this annotation should define private methods\n- * getWrapperInstanceTarget ()MethodHandle and getWrapperInstanceType ()Class.\n+ * The {@link #implementedType)} method allows recovering the\n+ * interface that was implemented, after which {@code asInterfaceInstance}\n+ * will perform more validation to enable recovery of method handle and\n+ * SAM objects.\n+ * <p>\n+ * This annotation is only scanned when it's first used; the wrapper\n+ * information is then cached in a {@code ClassValue} to speed up\n+ * wrapper testing and retrieval.\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/WrapperInstance.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -24,0 +24,10 @@\n+\/*\n+ * @test\n+ * @bug 6983726\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ * @summary Basic sanity tests for MethodHandleProxies\n+ * @run junit BasicTest\n+ *\/\n+\n@@ -41,0 +51,1 @@\n+import java.util.Objects;\n@@ -54,8 +65,0 @@\n-\/* @test\n- * @bug 6983726\n- * @modules java.base\/jdk.internal.classfile\n- *          java.base\/jdk.internal.classfile.attribute\n- *          java.base\/jdk.internal.classfile.constantpool\n- * @summary Basic sanity tests for MethodHandleProxies\n- * @run junit BasicTest\n- *\/\n@@ -101,0 +104,21 @@\n+    \/\/ We both check for correctness and that it doesn't throw\n+    @Test\n+    public void testObjectMethods() throws Throwable {\n+        var mh = MethodHandles.publicLookup()\n+                .findVirtual(Integer.class, \"compareTo\", methodType(int.class, Integer.class));\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> p1 = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+        @SuppressWarnings(\"unchecked\")\n+        Comparator<Integer> p2 = (Comparator<Integer>) asInterfaceInstance(Comparator.class, mh);\n+\n+        assertEquals(System.identityHashCode(p1), p1.hashCode());\n+        assertEquals(System.identityHashCode(p2), p2.hashCode());\n+\n+        assertEquals(p1, p1);\n+        assertEquals(p1 == p2, p1.equals(p2));\n+        assertEquals(p2 == p1, p2.equals(p1));\n+\n+        assertEquals(Objects.toIdentityString(p1), p1.toString());\n+        assertEquals(Objects.toIdentityString(p2), p2.toString());\n+    }\n+\n@@ -151,0 +175,2 @@\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(MultiAbstractMethods.class, mh));\n+        assertThrows(IllegalArgumentException.class, () -> asInterfaceInstance(NoAbstractMethods.class, mh));\n@@ -206,0 +232,9 @@\n+\n+    public interface MultiAbstractMethods {\n+        String a();\n+        String b();\n+    }\n+\n+    public interface NoAbstractMethods {\n+        String toString();\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/BasicTest.java","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.lang.invoke.LambdaMetafactory;\n@@ -38,1 +39,1 @@\n-import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -42,0 +43,3 @@\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+\n@@ -58,0 +62,1 @@\n+     *   - lambda* compares lambda performance with asInterfaceInstance performance\n@@ -62,0 +67,3 @@\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MT_Doable = methodType(Doable.class);\n+    private static final MethodType MT_int_int = methodType(int.class, int.class);\n@@ -64,0 +72,1 @@\n+    private Doable precreatedLambda;\n@@ -67,1 +76,1 @@\n-        target = MethodHandles.lookup().findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MethodType.methodType(int.class, int.class));\n+        target = LOOKUP.findStatic(MethodHandleProxiesAsIFInstance.class, \"doWork\", MT_int_int);\n@@ -69,0 +78,7 @@\n+        precreatedLambda = MethodHandleProxiesAsIFInstance::doWork;\n+    }\n+\n+    @Benchmark\n+    public Doable lambdaCreate() throws Throwable {\n+        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+        return doable;              \/\/ make sure allocation happens\n@@ -77,0 +93,7 @@\n+    @Benchmark\n+    public Doable lambdaCreateCall() throws Throwable {\n+        Doable doable = (Doable) LambdaMetafactory.metafactory(LOOKUP, \"doWork\", MT_Doable, MT_int_int, target, MT_int_int).getTarget().invokeExact();\n+        i = doable.doWork(i);       \/\/ make sure computation happens\n+        return null;                \/\/ let allocation be eliminated\n+    }\n+\n@@ -84,0 +107,6 @@\n+    @Benchmark\n+    public Doable lambdaCall() {\n+        i = precreatedLambda.doWork(i); \/\/ make sure computation happens\n+        return precreatedLambda;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandleProxiesAsIFInstance.java","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"}]}