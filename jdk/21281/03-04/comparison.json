{"files":[{"patch":"@@ -42,1 +42,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -48,1 +47,0 @@\n-    private static volatile CountDownLatch countDownLatch;\n@@ -50,0 +48,2 @@\n+    private static volatile int width, height;\n+    private static Robot robot;\n@@ -55,1 +55,0 @@\n-            countDownLatch = new CountDownLatch(1);\n@@ -57,1 +56,3 @@\n-            countDownLatch.await();\n+            \/\/ we should check focus after all events are processed,\n+            \/\/ since focus transfers are asynchronous\n+            robot.waitForIdle();\n@@ -81,2 +82,2 @@\n-    static void runTest() throws Exception {\n-        Robot robot = new Robot();\n+    private static void runTest() throws Exception {\n+        robot = new Robot();\n@@ -85,2 +86,6 @@\n-        EventQueue.invokeAndWait(() -> bp = b.getLocationOnScreen());\n-        robot.mouseMove(bp.x + b.getWidth() \/ 2, bp.y + b.getHeight() \/ 2 );\n+        EventQueue.invokeAndWait(() -> {\n+            bp = b.getLocationOnScreen();\n+            width = b.getWidth();\n+            height = b.getHeight();\n+        });\n+        robot.mouseMove(bp.x + width \/ 2, bp.y + height \/ 2 );\n@@ -95,4 +100,0 @@\n-\n-        \/\/ we should check focus after all events are processed,\n-        \/\/ since focus transfers are asynchronous\n-        EventQueue.invokeLater(() -> countDownLatch.countDown());\n","filename":"test\/jdk\/java\/awt\/Window\/InvalidFocusLostEventTest\/InvalidFocusLostEventTest.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"}]}