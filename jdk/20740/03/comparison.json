{"files":[{"patch":"@@ -82,1 +82,1 @@\n-    lightweight_lock(Roop, Rmark, tmp, slow_case);\n+    lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  compiler_fast_lock_lightweight_object(obj, temp1, temp2);\n+  compiler_fast_lock_lightweight_object(obj, box, temp1, temp2);\n@@ -42,1 +42,1 @@\n-  compiler_fast_unlock_lightweight_object(obj, temp1, temp2);\n+  compiler_fast_unlock_lightweight_object(obj, box, temp1, temp2);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-    lightweight_lock(object, header, tmp, slow_case);\n+    lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6010,1 +6010,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register temp1, Register temp2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register temp1, Register temp2, Label& slow) {\n@@ -6013,1 +6013,1 @@\n-  assert_different_registers(obj, temp1, temp2);\n+  assert_different_registers(basic_lock, obj, temp1, temp2);\n@@ -6025,0 +6025,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    const Address om_cache_addr = Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes())));\n+    z_mvghi(om_cache_addr, 0);\n+  }\n@@ -6148,2 +6153,2 @@\n-void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n-  assert_different_registers(obj, tmp1, tmp2);\n+void MacroAssembler::compiler_fast_lock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, box, tmp1, tmp2);\n@@ -6158,0 +6163,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    z_mvghi(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n+\n@@ -6222,0 +6232,1 @@\n+    const Register tmp1_monitor = tmp1;\n@@ -6223,20 +6234,1 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register tagged_monitor = mark;\n-      const Register zero           = tmp2;\n-\n-      \/\/ Try to CAS m->owner from null to current thread.\n-      \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-      \/\/ Otherwise, register zero is filled with the current owner.\n-      z_lghi(zero, 0);\n-      z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n-      z_bre(locked);\n-\n-      \/\/ Check if recursive.\n-      z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n-      z_brne(slow_path);\n-\n-      \/\/ Recursive\n-      z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-      z_cgr(zero, zero);\n-      \/\/ z_bru(locked);\n-      \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+      assert(tmp1_monitor == mark, \"should be the same here\");\n@@ -6244,3 +6236,28 @@\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      z_ltgr(obj, obj);\n+      NearLabel monitor_found;\n+\n+      \/\/ load cache address\n+      z_la(tmp1, Address(Z_thread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        z_cg(obj, Address(tmp1));\n+        z_bre(monitor_found);\n+        add2reg(tmp1, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      NearLabel loop;\n+      \/\/ Search for obj in cache\n+\n+      bind(loop);\n+\n+      \/\/ check for match.\n+      z_cg(obj, Address(tmp1));\n+      z_bre(monitor_found);\n+\n+      \/\/ search until null encountered, guaranteed _null_sentinel at end.\n+      add2reg(tmp1, in_bytes(OMCache::oop_to_oop_difference()));\n+      z_cghsi(0, tmp1, 0);\n+      z_brne(loop); \/\/ if not EQ to 0, go for another loop\n+\n+      \/\/ we reached to the end, cache miss\n+      z_ltgr(obj, obj); \/\/ set CC to NE\n@@ -6248,0 +6265,4 @@\n+\n+      \/\/ cache hit\n+      bind(monitor_found);\n+      z_lg(tmp1_monitor, Address(tmp1, OMCache::oop_to_monitor_difference()));\n@@ -6249,0 +6270,33 @@\n+    NearLabel monitor_locked;\n+    \/\/ lock the monitor\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register tagged_monitor = mark;\n+    const Register zero           = tmp2;\n+\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+\n+    \/\/ Try to CAS m->owner from null to current thread.\n+    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+    \/\/ Otherwise, register zero is filled with the current owner.\n+    z_lghi(zero, 0);\n+    z_csg(zero, Z_thread, owner_address);\n+    z_bre(monitor_locked);\n+\n+    \/\/ Check if recursive.\n+    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+    z_brne(slow_path);\n+\n+    \/\/ Recursive\n+    z_agsi(recursions_address, 1ll);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock\n+      z_stg(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n+    \/\/ set the CC now\n+    z_cgr(obj, obj);\n@@ -6273,2 +6327,2 @@\n-void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2) {\n-  assert_different_registers(obj, tmp1, tmp2);\n+void MacroAssembler::compiler_fast_unlock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2) {\n+  assert_different_registers(obj, box, tmp1, tmp2);\n@@ -6277,1 +6331,1 @@\n-  NearLabel inflated, inflated_load_monitor;\n+  NearLabel inflated, inflated_load_mark;\n@@ -6297,1 +6351,1 @@\n-    branch_optimized(bcondNotEqual, inflated_load_monitor);\n+    branch_optimized(bcondNotEqual, inflated_load_mark);\n@@ -6318,0 +6372,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -6356,1 +6413,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -6381,0 +6438,2 @@\n+    const Register tmp1_monitor = tmp1;\n+\n@@ -6382,2 +6441,6 @@\n-      \/\/ mark contains the tagged ObjectMonitor*.\n-      const Register monitor = mark;\n+      assert(tmp1_monitor == mark, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      z_lg(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      z_cghi(tmp1_monitor, alignof(ObjectMonitor*));\n@@ -6385,2 +6448,2 @@\n-      NearLabel not_recursive;\n-      const Register recursions = tmp2;\n+      z_brl(slow_path);\n+    }\n@@ -6388,3 +6451,2 @@\n-      \/\/ Check if recursive.\n-      load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-      z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register monitor = mark;\n@@ -6392,4 +6454,5 @@\n-      \/\/ Recursive unlock\n-      z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-      z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n-      z_bru(unlocked);\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -6397,1 +6460,2 @@\n-      bind(not_recursive);\n+    NearLabel not_recursive;\n+    const Register recursions = tmp2;\n@@ -6399,6 +6463,3 @@\n-      NearLabel not_ok;\n-      \/\/ Check if the entry lists are empty.\n-      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-      z_brne(not_ok);\n-      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-      z_brne(not_ok);\n+    \/\/ Check if recursive.\n+    load_and_test_long(recursions, recursions_address);\n+    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -6406,2 +6467,4 @@\n-      z_release();\n-      z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+    \/\/ Recursive unlock\n+    z_agsi(recursions_address, -1ll);\n+    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+    z_bru(unlocked);\n@@ -6409,1 +6472,1 @@\n-      z_bru(unlocked); \/\/ CC = EQ here\n+    bind(not_recursive);\n@@ -6411,1 +6474,6 @@\n-      bind(not_ok);\n+    NearLabel not_ok;\n+    \/\/ Check if the entry lists are empty.\n+    load_and_test_long(tmp2, EntryList_address);\n+    z_brne(not_ok);\n+    load_and_test_long(tmp2, cxq_address);\n+    z_brne(not_ok);\n@@ -6413,11 +6481,12 @@\n-      \/\/ The owner may be anonymous, and we removed the last obj entry in\n-      \/\/ the lock-stack. This loses the information about the owner.\n-      \/\/ Write the thread to the owner field so the runtime knows the owner.\n-      z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n-      z_bru(slow_path); \/\/ CC = NE here\n-    } else {\n-      \/\/ OMCache lookup not supported yet. Take the slowpath.\n-      \/\/ Set flag to NE\n-      z_ltgr(obj, obj);\n-      z_bru(slow_path);\n-    }\n+    z_release();\n+    z_stg(tmp2 \/*=0*\/, owner_address);\n+\n+    z_bru(unlocked); \/\/ CC = EQ here\n+\n+    bind(not_ok);\n+\n+    \/\/ The owner may be anonymous, and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    z_stg(Z_thread, owner_address);\n+    z_bru(slow_path); \/\/ CC = NE here\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":134,"deletions":65,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -755,1 +755,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Label& slow);\n@@ -757,2 +757,2 @@\n-  void compiler_fast_lock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n-  void compiler_fast_unlock_lightweight_object(Register obj, Register tmp1, Register tmp2);\n+  void compiler_fast_lock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2);\n+  void compiler_fast_unlock_lightweight_object(Register obj, Register box, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1716,1 +1716,1 @@\n-      __ compiler_fast_lock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+      __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1920,1 +1920,1 @@\n-      __ compiler_fast_unlock_lightweight_object(r_oop, r_tmp1, r_tmp2);\n+      __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64) || defined(PPC64) || defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}