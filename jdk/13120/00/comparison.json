{"files":[{"patch":"@@ -5377,1 +5377,1 @@\n-  predicate(UseAVX > 0 && !n->is_reduction());\n+  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n@@ -5399,1 +5399,1 @@\n-  predicate(UseAVX > 0 && n->is_reduction());\n+  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n@@ -5413,1 +5413,1 @@\n-  predicate(UseAVX > 0 && !n->is_reduction());\n+  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n@@ -5435,1 +5435,1 @@\n-  predicate(UseAVX > 0 && n->is_reduction());\n+  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n@@ -5449,1 +5449,1 @@\n-  predicate(UseAVX > 0 && !n->is_reduction());\n+  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n@@ -5471,1 +5471,1 @@\n-  predicate(UseAVX > 0 && n->is_reduction());\n+  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n@@ -5485,1 +5485,1 @@\n-  predicate(UseAVX > 0 && !n->is_reduction());\n+  predicate(UseAVX > 0 && !SuperWord::is_reduction(n));\n@@ -5507,1 +5507,1 @@\n-  predicate(UseAVX > 0 && n->is_reduction());\n+  predicate(UseAVX > 0 && SuperWord::is_reduction(n));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,0 +274,1 @@\n+  AD.addInclude(AD._DFA_file, \"opto\/superword.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -465,3 +465,0 @@\n-    if (flags & Node::Flag_is_reduction) {\n-      print_prop(\"is_reduction\", \"true\");\n-    }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1040,4 +1040,0 @@\n-    if (!cl->is_reduction_loop()) {\n-      phase->mark_reductions(this);\n-    }\n-\n@@ -1697,9 +1693,0 @@\n-  if (peel_only) {\n-    \/\/ Nodes in the peeled iteration that were marked as reductions within the\n-    \/\/ original loop might not be reductions within their new outer loop.\n-    for (uint i = 0; i < loop->_body.size(); i++) {\n-      Node* n = old_new[loop->_body[i]->_idx];\n-      n->remove_flag(Node::Flag_is_reduction);\n-    }\n-  }\n-\n@@ -2501,63 +2488,0 @@\n-void PhaseIdealLoop::mark_reductions(IdealLoopTree *loop) {\n-  if (SuperWordReductions == false) return;\n-\n-  CountedLoopNode* loop_head = loop->_head->as_CountedLoop();\n-  if (loop_head->unrolled_count() > 1) {\n-    return;\n-  }\n-\n-  Node* trip_phi = loop_head->phi();\n-  for (DUIterator_Fast imax, i = loop_head->fast_outs(imax); i < imax; i++) {\n-    Node* phi = loop_head->fast_out(i);\n-    if (phi->is_Phi() && phi->outcnt() > 0 && phi != trip_phi) {\n-      \/\/ For definitions which are loop inclusive and not tripcounts.\n-      Node* def_node = phi->in(LoopNode::LoopBackControl);\n-\n-      if (def_node != nullptr) {\n-        Node* n_ctrl = get_ctrl(def_node);\n-        if (n_ctrl != nullptr && loop->is_member(get_loop(n_ctrl))) {\n-          \/\/ Now test it to see if it fits the standard pattern for a reduction operator.\n-          int opc = def_node->Opcode();\n-          if (opc != ReductionNode::opcode(opc, def_node->bottom_type()->basic_type())\n-              || opc == Op_MinD || opc == Op_MinF || opc == Op_MaxD || opc == Op_MaxF) {\n-            if (!def_node->is_reduction()) { \/\/ Not marked yet\n-              \/\/ To be a reduction, the arithmetic node must have the phi as input and provide a def to it\n-              bool ok = false;\n-              for (unsigned j = 1; j < def_node->req(); j++) {\n-                Node* in = def_node->in(j);\n-                if (in == phi) {\n-                  ok = true;\n-                  break;\n-                }\n-              }\n-\n-              \/\/ do nothing if we did not match the initial criteria\n-              if (ok == false) {\n-                continue;\n-              }\n-\n-              \/\/ The result of the reduction must not be used in the loop\n-              for (DUIterator_Fast imax, i = def_node->fast_outs(imax); i < imax && ok; i++) {\n-                Node* u = def_node->fast_out(i);\n-                if (!loop->is_member(get_loop(ctrl_or_self(u)))) {\n-                  continue;\n-                }\n-                if (u == phi) {\n-                  continue;\n-                }\n-                ok = false;\n-              }\n-\n-              \/\/ iff the uses conform\n-              if (ok) {\n-                def_node->add_flag(Node::Flag_is_reduction);\n-                loop_head->mark_has_reductions();\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2252,1 +2252,0 @@\n-  if (is_reduction_loop()) st->print(\" reduction\");\n@@ -3994,1 +3993,0 @@\n-    if (cl->is_reduction_loop()) tty->print(\" reduction\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,17 +64,16 @@\n-         MainHasNoPreLoop    = 1<<2,\n-         HasExactTripCount   = 1<<3,\n-         InnerLoop           = 1<<4,\n-         PartialPeelLoop     = 1<<5,\n-         PartialPeelFailed   = 1<<6,\n-         HasReductions       = 1<<7,\n-         WasSlpAnalyzed      = 1<<8,\n-         PassedSlpAnalysis   = 1<<9,\n-         DoUnrollOnly        = 1<<10,\n-         VectorizedLoop      = 1<<11,\n-         HasAtomicPostLoop   = 1<<12,\n-         IsMultiversioned    = 1<<13,\n-         StripMined          = 1<<14,\n-         SubwordLoop         = 1<<15,\n-         ProfileTripFailed   = 1<<16,\n-         LoopNestInnerLoop = 1 << 17,\n-         LoopNestLongOuterLoop = 1 << 18};\n+         MainHasNoPreLoop      = 1<<2,\n+         HasExactTripCount     = 1<<3,\n+         InnerLoop             = 1<<4,\n+         PartialPeelLoop       = 1<<5,\n+         PartialPeelFailed     = 1<<6,\n+         WasSlpAnalyzed        = 1<<7,\n+         PassedSlpAnalysis     = 1<<8,\n+         DoUnrollOnly          = 1<<9,\n+         VectorizedLoop        = 1<<10,\n+         HasAtomicPostLoop     = 1<<11,\n+         IsMultiversioned      = 1<<12,\n+         StripMined            = 1<<13,\n+         SubwordLoop           = 1<<14,\n+         ProfileTripFailed     = 1<<15,\n+         LoopNestInnerLoop     = 1<<16,\n+         LoopNestLongOuterLoop = 1<<17};\n@@ -108,1 +107,0 @@\n-  void mark_has_reductions() { _loop_flags |= HasReductions; }\n@@ -289,1 +287,0 @@\n-  bool is_reduction_loop() const { return (_loop_flags&HasReductions) == HasReductions; }\n@@ -894,1 +891,1 @@\n-  bool has_ctrl( Node *n ) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n+  bool has_ctrl(const Node* n) const { return ((intptr_t)_nodes[n->_idx]) & 1; }\n@@ -971,1 +968,1 @@\n-  bool has_node( Node* n ) const {\n+  bool has_node(const Node* n) const {\n@@ -1002,1 +999,1 @@\n-  Node *get_ctrl( Node *i ) {\n+  Node* get_ctrl(const Node* i) {\n@@ -1023,1 +1020,1 @@\n-  Node *get_ctrl_no_update_helper(Node *i) const {\n+  Node* get_ctrl_no_update_helper(const Node* i) const {\n@@ -1028,1 +1025,1 @@\n-  Node *get_ctrl_no_update(Node *i) const {\n+  Node* get_ctrl_no_update(const Node* i) const {\n@@ -1313,3 +1310,0 @@\n-  \/\/ Mark vector reduction candidates before loop unrolling\n-  void mark_reductions( IdealLoopTree *loop );\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":21,"deletions":27,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2627,4 +2627,0 @@\n-    if (old->is_reduction()) {\n-      \/\/ Reduction flag is not copied by default. Copy it here when cloning the entire loop body.\n-      nnn->add_flag(Node::Flag_is_reduction);\n-    }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -524,4 +524,0 @@\n-  if (n->is_reduction()) {\n-    \/\/ Do not copy reduction information. This must be explicitly set by the calling code.\n-    n->remove_flag(Node::Flag_is_reduction);\n-  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -581,0 +581,6 @@\n+    \/\/ Flip swapped edges flag.\n+    if (has_swapped_edges()) {\n+      remove_flag(Node::Flag_has_swapped_edges);\n+    } else {\n+      add_flag(Node::Flag_has_swapped_edges);\n+    }\n@@ -787,1 +793,1 @@\n-    Flag_is_reduction                = 1 << 11,\n+    Flag_has_swapped_edges           = 1 << 11,\n@@ -1004,4 +1010,2 @@\n-\n-  \/\/ An arithmetic node which accumulates a data in a loop.\n-  \/\/ It must have the loop's phi as input and provide a def to the phi.\n-  bool is_reduction() const { return (_flags & Flag_is_reduction) != 0; }\n+  \/\/ The node's original edge position is swapped.\n+  bool has_swapped_edges() const { return (_flags & Flag_has_swapped_edges) != 0; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  _loop_reductions(arena()),                                \/\/ reduction nodes in the current loop\n@@ -113,1 +114,5 @@\n-  if (cl->is_rce_post_loop() && cl->is_reduction_loop()) {\n+  if (SuperWordReductions) {\n+    mark_reductions(lpt);\n+  }\n+\n+  if (cl->is_rce_post_loop() && is_marked_reduction_loop()) {\n@@ -180,1 +185,1 @@\n-      if (cl->is_vectorized_loop() && cl->is_main_loop() && !cl->is_reduction_loop()) {\n+      if (cl->is_vectorized_loop() && cl->is_main_loop() && !is_marked_reduction_loop()) {\n@@ -236,1 +241,1 @@\n-      n->is_reduction() ||\n+      is_marked_reduction(n) ||\n@@ -424,0 +429,141 @@\n+bool SuperWord::is_reduction(const Node* n) {\n+  if (!is_reduction_operator(n)) {\n+    return false;\n+  }\n+  \/\/ Test whether there is a reduction cycle via every edge index\n+  \/\/ (typically indices 1 and 2).\n+  for (uint input = 1; input < n->req(); input++) {\n+    if (in_reduction_cycle(n, input)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool SuperWord::is_reduction_operator(const Node* n) {\n+  int opc = n->Opcode();\n+  return (opc != ReductionNode::opcode(opc, n->bottom_type()->basic_type())\n+          || opc == Op_MinD || opc == Op_MinF || opc == Op_MaxD || opc == Op_MaxF);\n+}\n+\n+bool SuperWord::in_reduction_cycle(const Node* n, uint input) {\n+  \/\/ First find input reduction path to phi node.\n+  auto has_my_opcode = [&](const Node* m){ return m->Opcode() == n->Opcode(); };\n+  PathEnd path_to_phi = find_in_path(n, input, LoopMaxUnroll, has_my_opcode,\n+                                     [&](const Node* m) { return m->is_Phi(); });\n+  const Node* phi = path_to_phi.first;\n+  if (phi == nullptr) {\n+    return false;\n+  }\n+  \/\/ If there is an input reduction path from the phi's loop-back to n, then n\n+  \/\/ is part of a reduction cycle.\n+  const Node* first = phi->in(LoopNode::LoopBackControl);\n+  PathEnd path_from_phi = find_in_path(first, input, LoopMaxUnroll, has_my_opcode,\n+                                       [&](const Node* m) { return m == n; });\n+  return path_from_phi.first != nullptr;\n+}\n+\n+Node* SuperWord::original_input(const Node* n, uint i) {\n+  if (n->has_swapped_edges()) {\n+    assert(n->is_Add() || n->is_Mul(), \"n should be commutative\");\n+    if (i == 1) {\n+      return n->in(2);\n+    } else if (i == 2) {\n+      return n->in(1);\n+    }\n+  }\n+  return n->in(i);\n+}\n+\n+void SuperWord::mark_reductions(IdealLoopTree* loop) {\n+\n+  _loop_reductions.clear();\n+  const CountedLoopNode* loop_head = loop->_head->as_CountedLoop();\n+  const Node* trip_phi = loop_head->phi();\n+\n+  \/\/ Iterate through all phi nodes associated to the loop and search for\n+  \/\/ reduction cycles of at most LoopMaxUnroll nodes.\n+  for (DUIterator_Fast imax, i = loop_head->fast_outs(imax); i < imax; i++) {\n+    const Node* phi = loop_head->fast_out(i);\n+    if (!phi->is_Phi()) {\n+      continue;\n+    }\n+    if (phi->outcnt() == 0) {\n+      continue;\n+    }\n+    if (phi == trip_phi) {\n+      continue;\n+    }\n+    \/\/ The phi's loop-back is considered the first node in the reduction cycle.\n+    const Node* first = phi->in(LoopNode::LoopBackControl);\n+    if (first == nullptr) {\n+      continue;\n+    }\n+    \/\/ Test that the node fits the standard pattern for a reduction operator.\n+    if (!is_reduction_operator(first)) {\n+      continue;\n+    }\n+    \/\/ Test that 'first' is the beginning of a reduction cycle ending in 'phi'.\n+    \/\/ To contain the number of searched paths, assume that all nodes in a\n+    \/\/ reduction cycle are connected via the same edge index, modulo swapped\n+    \/\/ inputs. This assumption is realistic because reduction cycles usually\n+    \/\/ consist of nodes cloned by loop unrolling. To further bound the search,\n+    \/\/ constrain the size of reduction cycles to LoopMaxUnroll.\n+    int reduction_input = -1;\n+    int path_nodes = -1;\n+    for (uint input = 1; input < first->req(); input++) {\n+      \/\/ Test whether there is a reduction path of at most LoopMaxUnroll nodes\n+      \/\/ from 'first' to the phi node following edge index 'input'.\n+      PathEnd path =\n+        find_in_path(\n+          first, input, LoopMaxUnroll,\n+          [&](const Node* n) {\n+            Node* ctrl = _phase->get_ctrl(n);\n+            return (n->Opcode() == first->Opcode() && ctrl != nullptr &&\n+                    loop->is_member(_phase->get_loop(ctrl)));\n+          },\n+          [&](const Node* n) { return n == phi; });\n+      if (path.first != nullptr) {\n+        reduction_input = input;\n+        path_nodes = path.second;\n+        break;\n+      }\n+    }\n+    if (reduction_input == -1) {\n+      continue;\n+    }\n+    \/\/ Test that reduction nodes do not have any users in the loop besides their\n+    \/\/ reduction cycle predecessors.\n+    const Node* current = first;\n+    const Node* pred = phi; \/\/ current's predecessor in the reduction cycle.\n+    bool used_in_loop = false;\n+    for (int i = 0; i < path_nodes; i++) {\n+      for (DUIterator_Fast jmax, j = current->fast_outs(jmax); j < jmax; j++) {\n+        Node* u = current->fast_out(j);\n+        if (!loop->is_member(_phase->get_loop(_phase->ctrl_or_self(u)))) {\n+          continue;\n+        }\n+        if (u == pred) {\n+          continue;\n+        }\n+        used_in_loop = true;\n+        break;\n+      }\n+      if (used_in_loop) {\n+        break;\n+      }\n+      pred = current;\n+      current = original_input(current, reduction_input);\n+    }\n+    if (used_in_loop) {\n+      continue;\n+    }\n+    \/\/ Reduction cycle found. Mark all nodes in the found path as reductions.\n+    current = first;\n+    for (int i = 0; i < path_nodes; i++) {\n+      _loop_reductions.set(current->_idx);\n+      current = original_input(current, reduction_input);\n+    }\n+  }\n+}\n+\n@@ -1389,1 +1535,1 @@\n-  if (p->at(0)->is_reduction()) {\n+  if (is_marked_reduction(p->at(0))) {\n@@ -1447,1 +1593,1 @@\n-    if (s1->is_reduction() && s2->is_reduction()) {\n+    if (is_marked_reduction(s1) && is_marked_reduction(s2)) {\n@@ -1664,1 +1810,1 @@\n-  if (s1->is_reduction()) return;\n+  if (is_marked_reduction(s1)) return;\n@@ -1700,1 +1846,1 @@\n-  if (u1->is_reduction() && u2->is_reduction()) {\n+  if (is_marked_reduction(u1) && is_marked_reduction(u2)) {\n@@ -1703,1 +1849,1 @@\n-    if (first->is_Phi() || first->is_reduction()) {\n+    if (first->is_Phi() || is_marked_reduction(first)) {\n@@ -1708,1 +1854,1 @@\n-    if (first->is_Phi() || first->is_reduction()) {\n+    if (first->is_Phi() || is_marked_reduction(first)) {\n@@ -1931,1 +2077,1 @@\n-    if (n->is_reduction()) {\n+    if (is_marked_reduction(n)) {\n@@ -2182,1 +2328,1 @@\n-    if (p0->is_reduction()) {\n+    if (is_marked_reduction(p0)) {\n@@ -2272,1 +2418,1 @@\n-  if (p0->is_reduction()) {\n+  if (is_marked_reduction(p0)) {\n@@ -2276,1 +2422,1 @@\n-      \/\/ Remove reduction flag if no parent pack or if not enough work\n+      \/\/ Unmark reduction if no parent pack or if not enough work\n@@ -2278,1 +2424,1 @@\n-      p0->remove_flag(Node::Flag_is_reduction);\n+      _loop_reductions.remove(p0->_idx);\n@@ -2310,1 +2456,1 @@\n-            if (def->is_reduction() &&\n+            if (is_marked_reduction(def) &&\n@@ -2779,1 +2925,1 @@\n-        bool node_isa_reduction = n->is_reduction();\n+        bool node_isa_reduction = is_marked_reduction(n);\n@@ -3033,1 +3179,1 @@\n-  assert(!cl->is_reduction_loop(), \"no vector reduction in post loop\");\n+  assert(!is_marked_reduction_loop(), \"no vector reduction in post loop\");\n@@ -3311,1 +3457,1 @@\n-    if (def->is_reduction()) continue;\n+    if (is_marked_reduction(def)) continue;\n@@ -3334,1 +3480,1 @@\n-  if (use->is_reduction()) return true;\n+  if (is_marked_reduction(use)) return true;\n@@ -3495,1 +3641,1 @@\n-          if (use->is_reduction()) {\n+          if (is_marked_reduction(use)) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":166,"deletions":20,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -358,0 +359,1 @@\n+  VectorSet      _loop_reductions; \/\/ Reduction nodes in the current loop\n@@ -470,0 +472,55 @@\n+  typedef const Pair<const Node*, int> PathEnd;\n+\n+  \/\/ Search for a path P = (n_1, n_2, ..., n_k) such that:\n+  \/\/ - original_input(n_i, input) = n_i+1 for all 1 <= i < k,\n+  \/\/ - path(n) for all n in P,\n+  \/\/ - k <= max, and\n+  \/\/ - there exists a node e such that original_input(n_k, input) = e and end(e).\n+  \/\/ Return <e, k>, if P is found, or <nullptr, -1> otherwise.\n+  \/\/ Note that original_input(n, i) has the same behavior as n->in(i) except\n+  \/\/ that it commutes the inputs of binary nodes whose edges have been swapped.\n+  template <typename NodePredicate1, typename NodePredicate2>\n+  static PathEnd find_in_path(const Node *n1, uint input, int max,\n+                              NodePredicate1 path, NodePredicate2 end) {\n+    const PathEnd no_path(nullptr, -1);\n+    const Node* current = n1;\n+    int k = 0;\n+    for (int i = 0; i <= max; i++) {\n+      if (current == nullptr) {\n+        return no_path;\n+      }\n+      if (end(current)) {\n+        return PathEnd(current, k);\n+      }\n+      if (!path(current)) {\n+        return no_path;\n+      }\n+      current = original_input(current, input);\n+      k++;\n+    }\n+    return no_path;\n+  }\n+\n+public:\n+  \/\/ Whether n is a reduction operator and part of a reduction cycle.\n+  \/\/ This function can be used for individual queries outside the SLP analysis,\n+  \/\/ e.g. to inform matching in target-specific code. Otherwise, the\n+  \/\/ almost-equivalent but faster SuperWord::mark_reductions() is preferable.\n+  static bool is_reduction(const Node* n);\n+private:\n+  \/\/ Whether n is a standard reduction operator.\n+  static bool is_reduction_operator(const Node* n);\n+  \/\/ Whether n is part of a reduction cycle via the 'input' edge index.\n+  static bool in_reduction_cycle(const Node* n, uint input);\n+  \/\/ Reference to the i'th input node of n, commuting the inputs of binary nodes\n+  \/\/ whose edges have been swapped. Assumes n is a commutative operation.\n+  static Node* original_input(const Node* n, uint i);\n+  \/\/ Find and mark reductions in a loop. Running mark_reductions(loop) is\n+  \/\/ similar to querying is_reduction(n) for every n in loop, but stricter in\n+  \/\/ that it assumes counted loops and requires that reduction nodes are not\n+  \/\/ used within the loop except by their reduction cycle predecessors.\n+  void mark_reductions(IdealLoopTree* loop);\n+  \/\/ Whether n is marked as a reduction node.\n+  bool is_marked_reduction(Node* n) { return _loop_reductions.test(n->_idx); }\n+  \/\/ Whether the current loop has any reduction node.\n+  bool is_marked_reduction_loop() { return !_loop_reductions.is_empty(); }\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +48,1 @@\n-            TestFramework.runWithFlags(\"-XX:UseAVX=2\", \"-XX:LoopMaxUnroll=8\");\n+            TestFramework.runWithFlags(\"-XX:UseAVX=2\", \"-XX:LoopMaxUnroll=8\", \"-XX:-SuperWordReductions\");\n@@ -49,1 +50,1 @@\n-        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=8\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=8\", \"-XX:-SuperWordReductions\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSuperwordFailsUnrolling.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8287087\n+ * @summary Test that floating-point min\/max x64 operations are implemented\n+ *          differently depending on whether they are part of a reduction. These\n+ *          tests complement those in TestFpMinMaxIntrinsics, which focus more\n+ *          on correctness aspects.\n+ * @library \/test\/lib \/\n+ * @requires os.simpleArch == \"x64\"& (vm.opt.UseAVX == \"null\" | vm.opt.UseAVX > 0)\n+ * @run driver compiler.intrinsics.math.TestFpMinMaxReductions\n+ *\/\n+\n+package compiler.intrinsics.math;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestFpMinMaxReductions {\n+\n+    private static float acc;\n+    private static float floatInput1;\n+    private static float floatInput2;\n+    private static float[] floatArray = new float[1000];\n+\n+    private static double doubleInput1;\n+    private static double doubleInput2;\n+    private static double[] doubleArray = new double[1000];\n+\n+    private static int stride = 1;\n+\n+    public static void main(String[] args) throws Exception {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_F_REG, \"1\"},\n+        failOn = {IRNode.MIN_F_REDUCTION_REG})\n+    private static float testFloatMin() {\n+        return Math.min(floatInput1, floatInput2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_F_REG, \"1\"},\n+        failOn = {IRNode.MAX_F_REDUCTION_REG})\n+    private static float testFloatMax() {\n+        return Math.max(floatInput1, floatInput2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_F_REDUCTION_REG, \">= 1\"})\n+    private static float testFloatMinReduction() {\n+        float fmin = Float.POSITIVE_INFINITY;\n+        for (int i = 0; i < floatArray.length; i++) {\n+            fmin = Math.min(fmin, floatArray[i]);\n+        }\n+        return fmin;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_F_REDUCTION_REG, \">= 1\"})\n+    private static float testFloatMinReductionPartiallyUnrolled() {\n+        float fmin = Float.POSITIVE_INFINITY;\n+        for (int i = 0; i < floatArray.length \/ 2; i++) {\n+            fmin = Math.min(fmin, floatArray[2*i]);\n+            fmin = Math.min(fmin, floatArray[2*i + 1]);\n+        }\n+        return fmin;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_F_REDUCTION_REG, \">= 1\"})\n+    private static float testFloatMinReductionNonCounted() {\n+        float fmin = Float.POSITIVE_INFINITY;\n+        for (int i = 0; i < floatArray.length; i += stride) {\n+            fmin = Math.min(fmin, floatArray[i]);\n+        }\n+        return fmin;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_F_REDUCTION_REG, \">= 1\"})\n+    private static float testFloatMinReductionGlobalAccumulator() {\n+        acc = Float.POSITIVE_INFINITY;\n+        for (int i = 0; i < floatArray.length; i++) {\n+            acc = Math.min(acc, floatArray[i]);\n+        }\n+        return acc;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_F_REDUCTION_REG, \">= 1\"})\n+    private static float testFloatMinReductionInOuterLoop() {\n+        float fmin = Float.POSITIVE_INFINITY;\n+        int count = 0;\n+        for (int i = 0; i < floatArray.length; i++) {\n+            fmin = Math.min(fmin, floatArray[i]);\n+            for (int j = 0; j < 10; j += stride) {\n+                count++;\n+            }\n+        }\n+        return fmin + count;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_F_REDUCTION_REG, \">= 1\"})\n+    private static float testFloatMaxReduction() {\n+        float fmax = Float.NEGATIVE_INFINITY;\n+        for (int i = 0; i < floatArray.length; i++) {\n+            fmax = Math.max(fmax, floatArray[i]);\n+        }\n+        return fmax;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_D_REG, \"1\"},\n+        failOn = {IRNode.MIN_D_REDUCTION_REG})\n+    private static double testDoubleMin() {\n+        return Math.min(doubleInput1, doubleInput2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_D_REG, \"1\"},\n+        failOn = {IRNode.MAX_D_REDUCTION_REG})\n+    private static double testDoubleMax() {\n+        return Math.max(doubleInput1, doubleInput2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_D_REDUCTION_REG, \">= 1\"})\n+    private static double testDoubleMinReduction() {\n+        double fmin = Double.POSITIVE_INFINITY;\n+        for (int i = 0; i < doubleArray.length; i++) {\n+            fmin = Math.min(fmin, doubleArray[i]);\n+        }\n+        return fmin;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_D_REDUCTION_REG, \">= 1\"})\n+    private static double testDoubleMaxReduction() {\n+        double fmax = Double.NEGATIVE_INFINITY;\n+        for (int i = 0; i < doubleArray.length; i++) {\n+            fmax = Math.max(fmax, doubleArray[i]);\n+        }\n+        return fmax;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestFpMinMaxReductions.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -652,0 +652,20 @@\n+    public static final String MAX_D_REDUCTION_REG = PREFIX + \"MAX_D_REDUCTION_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MAX_D_REDUCTION_REG, \"maxD_reduction_reg\");\n+    }\n+\n+    public static final String MAX_D_REG = PREFIX + \"MAX_D_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MAX_D_REG, \"maxD_reg\");\n+    }\n+\n+    public static final String MAX_F_REDUCTION_REG = PREFIX + \"MAX_F_REDUCTION_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MAX_F_REDUCTION_REG, \"maxF_reduction_reg\");\n+    }\n+\n+    public static final String MAX_F_REG = PREFIX + \"MAX_F_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MAX_F_REG, \"maxF_reg\");\n+    }\n+\n@@ -677,0 +697,20 @@\n+    public static final String MIN_D_REDUCTION_REG = PREFIX + \"MIN_D_REDUCTION_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MIN_D_REDUCTION_REG, \"minD_reduction_reg\");\n+    }\n+\n+    public static final String MIN_D_REG = PREFIX + \"MIN_D_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MIN_D_REG, \"minD_reg\");\n+    }\n+\n+    public static final String MIN_F_REDUCTION_REG = PREFIX + \"MIN_F_REDUCTION_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MIN_F_REDUCTION_REG, \"minF_reduction_reg\");\n+    }\n+\n+    public static final String MIN_F_REG = PREFIX + \"MIN_F_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MIN_F_REG, \"minF_reg\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8283187 8287087\n+ * @summary Test reduction vectorizations that are enabled by performing SLP\n+ *          reduction analysis on unrolled loops.\n+ * @library \/test\/lib \/\n+ * @requires vm.bits == 64\n+ * @run driver compiler.loopopts.superword.TestGeneralizedReductions\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestGeneralizedReductions {\n+\n+    private static int acc = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"testReductionOnGlobalAccumulator\",\n+                 \"testReductionOnPartiallyUnrolledLoop\",\n+                 \"testReductionOnPartiallyUnrolledLoopWithSwappedInputs\",\n+                 \"testMapReductionOnGlobalAccumulator\"})\n+    void run() {\n+        long[] array = new long[100];\n+        long result;\n+        initArray(array);\n+        result = testReductionOnGlobalAccumulator(array);\n+        if (result != 4950) {\n+            throw new RuntimeException(\"unexpected result\");\n+        }\n+        initArray(array);\n+        result = testReductionOnPartiallyUnrolledLoop(array);\n+        if (result != 4950) {\n+            throw new RuntimeException(\"unexpected result\");\n+        }\n+        initArray(array);\n+        result = testReductionOnPartiallyUnrolledLoopWithSwappedInputs(array);\n+        if (result != 4950) {\n+            throw new RuntimeException(\"unexpected result\");\n+        }\n+        initArray(array);\n+        result = testMapReductionOnGlobalAccumulator(array);\n+        if (result != 316) {\n+            throw new RuntimeException(\"unexpected result\");\n+        }\n+    }\n+\n+    private static void initArray(long[] array) {\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = i;\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n+    private static long testReductionOnGlobalAccumulator(long[] array) {\n+        acc = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            acc += array[i];\n+        }\n+        return acc;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\"})\n+    private static long testReductionOnPartiallyUnrolledLoop(long[] array) {\n+        int sum = 0;\n+        for (int i = 0; i < array.length \/ 2; i++) {\n+            sum += array[2*i];\n+            sum += array[2*i + 1];\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ This test illustrates a limitation of the current reduction analysis: it\n+    \/\/ fails to detect reduction cycles where nodes are connected via different\n+    \/\/ input indices (except if the differences result from C2 edge swapping).\n+    \/\/ If this limitation is overcome in the future, the test case should be\n+    \/\/ turned into a positive one.\n+    @Test\n+    @IR(applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n+        failOn = {IRNode.ADD_REDUCTION_VI})\n+    private static long testReductionOnPartiallyUnrolledLoopWithSwappedInputs(long[] array) {\n+        int sum = 0;\n+        for (int i = 0; i < array.length \/ 2; i++) {\n+            sum = sum + (int)array[2*i];\n+            sum = (int)array[2*i + 1] + sum;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\",\n+                      \"UsePopCountInstruction\", \"true\",\n+                      \"LoopMaxUnroll\", \">= 8\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \">= 1\",\n+                  IRNode.POPCOUNT_VL, \">= 1\"})\n+    private static long testMapReductionOnGlobalAccumulator(long[] array) {\n+        acc = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            acc += Long.bitCount(array[i]);\n+        }\n+        return acc;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestGeneralizedReductions.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,3 @@\n+    private static int stride = 1;\n+    private static float acc;\n+\n@@ -130,0 +133,40 @@\n+\n+    @Benchmark\n+    public float fMinReducePartiallyUnrolled() {\n+        float result = Float.MAX_VALUE;\n+        for (int i = 0; i < COUNT \/ 2; i++) {\n+            result = Math.min(result, floats[2*i]);\n+            result = Math.min(result, floats[2*i + 1]);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public float fMinReduceNonCounted() {\n+        float result = Float.MAX_VALUE;\n+        for (int i = 0; i < COUNT; i += stride)\n+            result = Math.min(result, floats[i]);\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public float fMinReduceGlobalAccumulator() {\n+        acc = Float.MAX_VALUE;\n+        for (int i = 0; i < COUNT; i += stride)\n+            acc = Math.min(acc, floats[i]);\n+        return acc;\n+    }\n+\n+    @Benchmark\n+    public float fMinReduceInOuterLoop() {\n+        float result = Float.MAX_VALUE;\n+        int count = 0;\n+        for (int i = 0; i < COUNT; i++) {\n+            result = Math.min(result, floats[i]);\n+            for (int j = 0; j < 10; j += stride) {\n+                count++;\n+            }\n+        }\n+        return result + count;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FpMinMaxIntrinsics.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-    private int resI;\n@@ -50,1 +49,0 @@\n-    private long resL;\n@@ -56,0 +54,2 @@\n+    private static int globalResI;\n+\n@@ -78,1 +78,2 @@\n-    public void andRedI() {\n+    public void andRedI(Blackhole bh) {\n+        int resI = 0xFFFF;\n@@ -83,0 +84,1 @@\n+        bh.consume(resI);\n@@ -86,1 +88,2 @@\n-    public void orRedI() {\n+    public void orRedI(Blackhole bh) {\n+        int resI = 0x0000;\n@@ -91,0 +94,1 @@\n+        bh.consume(resI);\n@@ -94,1 +98,2 @@\n-    public void xorRedI() {\n+    public void xorRedI(Blackhole bh) {\n+        int resI = 0x0000;\n@@ -99,0 +104,1 @@\n+        bh.consume(resI);\n@@ -102,1 +108,2 @@\n-    public void andRedL() {\n+    public void andRedL(Blackhole bh) {\n+        long resL = 0xFFFFFFFF;\n@@ -107,0 +114,1 @@\n+        bh.consume(resL);\n@@ -110,1 +118,2 @@\n-    public void orRedL() {\n+    public void orRedL(Blackhole bh) {\n+        long resL = 0x00000000;\n@@ -115,0 +124,1 @@\n+        bh.consume(resL);\n@@ -118,1 +128,2 @@\n-    public void xorRedL() {\n+    public void xorRedL(Blackhole bh) {\n+        long resL = 0x00000000;\n@@ -123,0 +134,24 @@\n+        bh.consume(resL);\n+    }\n+\n+    @Benchmark\n+    public void andRedIPartiallyUnrolled(Blackhole bh) {\n+        int resI = 0xFFFF;\n+        for (int i = 0; i < COUNT \/ 2; i++) {\n+            int j = 2*i;\n+            intsD[j] = (intsA[j] * intsB[j]) + (intsA[j] * intsC[j]) + (intsB[j] * intsC[j]);\n+            resI &= intsD[j];\n+            j = 2*i + 1;\n+            intsD[j] = (intsA[j] * intsB[j]) + (intsA[j] * intsC[j]) + (intsB[j] * intsC[j]);\n+            resI &= intsD[j];\n+        }\n+        bh.consume(resI);\n+    }\n+\n+    @Benchmark\n+    public void andRedIOnGlobalAccumulator() {\n+        globalResI = 0xFFFF;\n+        for (int i = 0; i < COUNT; i++) {\n+            intsD[i] = (intsA[i] * intsB[i]) + (intsA[i] * intsC[i]) + (intsB[i] * intsC[i]);\n+            globalResI &= intsD[i];\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorReduction.java","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"}]}