{"files":[{"patch":"@@ -0,0 +1,894 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.PackageTest.PackageHandlers;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+\n+public class PackageTestTest extends JUnitAdapter {\n+\n+    private interface Verifiable {\n+        void verify();\n+    }\n+\n+    private static class CallbackFactory {\n+\n+        CallbackFactory(int tickCount) {\n+            this.tickCount = tickCount;\n+        }\n+\n+        CountingInstaller createInstaller(int exitCode) {\n+            return new CountingInstaller(tickCount, exitCode);\n+        }\n+\n+        CountingConsumer createUninstaller() {\n+            return new CountingConsumer(tickCount, \"uninstall\");\n+        }\n+\n+        CountingUnpacker createUnpacker() {\n+            return new CountingUnpacker(tickCount);\n+        }\n+\n+        CountingConsumer createInitializer() {\n+            return new CountingConsumer(tickCount, \"init\");\n+        }\n+\n+        CountingRunnable createRunOnceInitializer() {\n+            return new CountingRunnable(tickCount, \"once-init\");\n+        }\n+\n+        CountingConsumer createInstallVerifier() {\n+            return new CountingConsumer(tickCount, \"on-install\");\n+        }\n+\n+        CountingConsumer createUninstallVerifier() {\n+            return new CountingConsumer(tickCount, \"on-uninstall\");\n+        }\n+\n+        CountingConsumer createBundleVerifier() {\n+            return new CountingConsumer(tickCount, \"on-bundle\");\n+        }\n+\n+        CountingBundleVerifier createBundleVerifier(int jpackageExitCode) {\n+            return new CountingBundleVerifier(tickCount, jpackageExitCode);\n+        }\n+\n+        private final int tickCount;\n+    }\n+\n+    private final static int ERROR_EXIT_CODE_JPACKAGE = 35;\n+    private final static int ERROR_EXIT_CODE_INSTALL = 27;\n+\n+    private final static CallbackFactory NEVER = new CallbackFactory(0);\n+    private final static CallbackFactory ONCE = new CallbackFactory(1);\n+    private final static CallbackFactory TWICE = new CallbackFactory(2);\n+\n+    enum BundleVerifier {\n+        ONCE_SUCCESS(ONCE),\n+        ONCE_FAIL(ONCE),\n+        NEVER(PackageTestTest.NEVER),\n+        ONCE_SUCCESS_EXIT_CODE(ONCE, 0),\n+        ONCE_FAIL_EXIT_CODE(ONCE, ERROR_EXIT_CODE_JPACKAGE),\n+        NEVER_EXIT_CODE(PackageTestTest.NEVER, 0);\n+\n+        BundleVerifier(CallbackFactory factory) {\n+            specSupplier = () -> new BundleVerifierSpec(Optional.of(factory.createBundleVerifier()), Optional.empty());\n+        }\n+\n+        BundleVerifier(CallbackFactory factory, int jpackageExitCode) {\n+            specSupplier = () -> new BundleVerifierSpec(Optional.empty(),\n+                    Optional.of(factory.createBundleVerifier(jpackageExitCode)));\n+        }\n+\n+        BundleVerifierSpec spec() {\n+            return specSupplier.get();\n+        }\n+\n+        private final Supplier<BundleVerifierSpec> specSupplier;\n+    }\n+\n+    private static class TickCounter implements Verifiable {\n+\n+        TickCounter(int expectedTicks) {\n+            this.expectedTicks = expectedTicks;\n+        }\n+\n+        void tick() {\n+            ticks++;\n+        }\n+\n+        @Override\n+        public void verify() {\n+            switch (expectedTicks) {\n+                case 0 -> {\n+                    TKit.assertEquals(expectedTicks, ticks, String.format(\"%s: never called\", this));\n+                }\n+                case 1 -> {\n+                    TKit.assertEquals(expectedTicks, ticks, String.format(\"%s: called once\", this));\n+                }\n+                case 2 -> {\n+                    TKit.assertEquals(expectedTicks, ticks, String.format(\"%s: called twice\", this));\n+                }\n+                default -> {\n+                    TKit.assertEquals(expectedTicks, ticks, toString());\n+                }\n+            }\n+        }\n+\n+        protected int tickCount() {\n+            return ticks;\n+        }\n+\n+        protected static String getDescription(TickCounter o) {\n+            return \"tk=\" + o.expectedTicks;\n+        }\n+\n+        private int ticks;\n+        protected final int expectedTicks;\n+    }\n+\n+    private static class CountingConsumer extends TickCounter implements ThrowingConsumer<JPackageCommand> {\n+\n+        @Override\n+        public void accept(JPackageCommand cmd) {\n+            tick();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s(%s)\", label, TickCounter.getDescription(this));\n+        }\n+\n+        CountingConsumer(int expectedTicks, String label) {\n+            super(expectedTicks);\n+            this.label = Objects.requireNonNull(label);\n+        }\n+\n+        private final String label;\n+    }\n+\n+    private static class CountingRunnable extends TickCounter implements ThrowingRunnable {\n+\n+        @Override\n+        public void run() {\n+            tick();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s(%s)\", label, TickCounter.getDescription(this));\n+        }\n+\n+        CountingRunnable(int expectedTicks, String label) {\n+            super(expectedTicks);\n+            this.label = Objects.requireNonNull(label);\n+        }\n+\n+        private final String label;\n+    }\n+\n+    private static class CountingBundleVerifier extends TickCounter implements ThrowingBiConsumer<JPackageCommand, Executor.Result> {\n+\n+        @Override\n+        public void accept(JPackageCommand cmd, Executor.Result result) {\n+            tick();\n+            jpackageExitCode = result.exitCode();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            if (expectedTicks > 0) {\n+                TKit.assertEquals(expectedJPackageExitCode, jpackageExitCode, String.format(\"%s: run jpackage\", this));\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"on-bundle-ex(exit=%d, %s)\", expectedJPackageExitCode, TickCounter.getDescription(this));\n+        }\n+\n+        CountingBundleVerifier(int expectedTicks, int expectedJPackageExitCode) {\n+            super(expectedTicks);\n+            this.expectedJPackageExitCode = expectedJPackageExitCode;\n+        }\n+\n+        private int jpackageExitCode;\n+        private final int expectedJPackageExitCode;\n+    }\n+\n+    private final static class CountingInstaller extends TickCounter implements Function<JPackageCommand, Integer> {\n+\n+        @Override\n+        public Integer apply(JPackageCommand cmd) {\n+            tick();\n+            return exitCode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"install(exit=%d, %s)\", exitCode, TickCounter.getDescription(this));\n+        }\n+\n+        CountingInstaller(int expectedTicks, int exitCode) {\n+            super(expectedTicks);\n+            this.exitCode = exitCode;\n+        }\n+\n+        private final int exitCode;\n+    }\n+\n+    private static class CountingUnpacker extends TickCounter implements BiFunction<JPackageCommand, Path, Path> {\n+\n+        @Override\n+        public Path apply(JPackageCommand cmd, Path path) {\n+            tick();\n+            try {\n+                Files.createDirectories(path.resolve(\"mockup-installdir\"));\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            unpackPaths.add(path);\n+            return path;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"unpack(%s)\", TickCounter.getDescription(this));\n+        }\n+\n+        CountingUnpacker(int expectedTicks) {\n+            super(expectedTicks);\n+        }\n+\n+        List<Path> unpackPaths() {\n+            return unpackPaths;\n+        }\n+\n+        private final List<Path> unpackPaths = new ArrayList<>();\n+    }\n+\n+    record BundleVerifierSpec(Optional<CountingConsumer> verifier, Optional<CountingBundleVerifier> verifierWithExitCode) {\n+        BundleVerifierSpec {\n+            if (verifier.isPresent() == verifierWithExitCode.isPresent()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        Verifiable apply(PackageTest test) {\n+            verifier.ifPresent(test::addBundleVerifier);\n+            verifierWithExitCode.ifPresent(test::addBundleVerifier);\n+            return verifier.map(Verifiable.class::cast).orElseGet(verifierWithExitCode::orElseThrow);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return verifier.map(Verifiable.class::cast).orElseGet(verifierWithExitCode::orElseThrow).toString();\n+        }\n+    }\n+\n+    record PackageHandlersSpec(CountingInstaller installer, CountingConsumer uninstaller,\n+            Optional<CountingUnpacker> unpacker, int installExitCode) {\n+\n+        PackageHandlers createPackageHandlers(Consumer<Verifiable> verifiableAccumulator) {\n+            List.of(installer, uninstaller).forEach(verifiableAccumulator::accept);\n+            unpacker.ifPresent(verifiableAccumulator::accept);\n+            return new PackageHandlers(installer, uninstaller::accept, unpacker);\n+        }\n+    }\n+\n+    record TestSpec(PackageType type, PackageHandlersSpec handlersSpec,\n+            List<CountingConsumer> initializers, List<BundleVerifierSpec> bundleVerifierSpecs,\n+            List<CountingConsumer> installVerifiers, List<CountingConsumer> uninstallVerifiers,\n+            int expectedJPackageExitCode, int actualJPackageExitCode, List<Action> actions) {\n+\n+        PackageTest createTest(Consumer<Verifiable> verifiableAccumulator) {\n+            return createTest(handlersSpec.createPackageHandlers(verifiableAccumulator));\n+        }\n+\n+        PackageTest createTest(PackageHandlers handlers) {\n+            return new PackageTest().jpackageFactory(() -> {\n+                return new JPackageCommand() {\n+                    @Override\n+                    public Path outputBundle() {\n+                        return outputDir().resolve(\"mockup-bundle\" + super.packageType().getSuffix());\n+                    }\n+\n+                    @Override\n+                    public PackageType packageType() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    JPackageCommand assertAppLayout() {\n+                        return this;\n+                    }\n+\n+                    @Override\n+                    JPackageCommand createImmutableCopy() {\n+                        return this;\n+                    }\n+\n+                    @Override\n+                    public void verifyIsOfType(PackageType ... types) {\n+                    }\n+\n+                    @Override\n+                    public String getPrintableCommandLine() {\n+                        return \"'mockup jpackage'\";\n+                    }\n+\n+                    @Override\n+                    public Executor.Result execute(int expectedExitCode) {\n+                        final var outputBundle = outputBundle();\n+                        try {\n+                            Files.createDirectories(outputBundle.getParent());\n+                            if (actualJPackageExitCode == 0) {\n+                                Files.createFile(outputBundle);\n+                            }\n+                        } catch (IOException ex) {\n+                            throw new UncheckedIOException(ex);\n+                        }\n+                        return new Executor.Result(actualJPackageExitCode, null,\n+                                this::getPrintableCommandLine).assertExitCodeIs(expectedExitCode);\n+                    }\n+                };\n+            }).setExpectedExitCode(expectedJPackageExitCode)\n+                    .setExpectedInstallExitCode(handlersSpec.installExitCode)\n+                    .isPackageTypeSupported(type -> true)\n+                    .forTypes().packageHandlers(handlers);\n+        }\n+\n+        void configureInitializers(PackageTest test, Consumer<Verifiable> verifiableAccumulator) {\n+            for (final var initializer : initializers) {\n+                verifiableAccumulator.accept(initializer);\n+                test.addInitializer(initializer);\n+            }\n+        }\n+\n+        void configureBundleVerifiers(PackageTest test, Consumer<Verifiable> verifiableAccumulator) {\n+            for (final var verifierSpec : bundleVerifierSpecs) {\n+                verifiableAccumulator.accept(verifierSpec.apply(test));\n+            }\n+        }\n+\n+        void configureInstallVerifiers(PackageTest test, Consumer<Verifiable> verifiableAccumulator) {\n+            for (final var verifier : installVerifiers) {\n+                verifiableAccumulator.accept(verifier);\n+                test.addInstallVerifier(verifier);\n+            }\n+        }\n+\n+        void configureUninstallVerifiers(PackageTest test, Consumer<Verifiable> verifiableAccumulator) {\n+            for (final var verifier : uninstallVerifiers) {\n+                verifiableAccumulator.accept(verifier);\n+                test.addUninstallVerifier(verifier);\n+            }\n+        }\n+\n+        void run(PackageTest test) {\n+            final boolean expectedSuccess = (expectedJPackageExitCode == actualJPackageExitCode);\n+\n+            TKit.assertAssert(expectedSuccess, () -> {\n+                test.run(actions.toArray(Action[]::new));\n+            });\n+        }\n+\n+        List<Verifiable> run() {\n+            return run(Optional.empty());\n+        }\n+\n+        List<Verifiable> run(Consumer<PackageTest> customConfigure) {\n+            return run(Optional.of(customConfigure));\n+        }\n+\n+        private List<Verifiable> run(Optional<Consumer<PackageTest>> customConfigure) {\n+            final List<Verifiable> verifiers = new ArrayList<>();\n+\n+            final var test = createTest(verifiers::add);\n+            test.forTypes(type);\n+            configureInitializers(test, verifiers::add);\n+            configureBundleVerifiers(test, verifiers::add);\n+            configureInstallVerifiers(test, verifiers::add);\n+            configureUninstallVerifiers(test, verifiers::add);\n+            customConfigure.ifPresent(callback -> callback.accept(test));\n+            run(test);\n+            verifiers.forEach(Verifiable::verify);\n+            return verifiers;\n+        }\n+    }\n+\n+    private final static class TestSpecBuilder {\n+\n+        TestSpecBuilder type(PackageType v) {\n+            type = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        TestSpecBuilder install(CallbackFactory v) {\n+            install = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        TestSpecBuilder uninstall(CallbackFactory v) {\n+            uninstall = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        TestSpecBuilder unpack(CallbackFactory v) {\n+            unpack = v;\n+            return this;\n+        }\n+\n+        TestSpecBuilder installExitCode(int v) {\n+            installExitCode = v;\n+            return this;\n+        }\n+\n+        TestSpecBuilder jpackageExitCode(int v) {\n+            return expectedJPackageExitCode(v).actualJPackageExitCode(v);\n+        }\n+\n+        TestSpecBuilder expectedJPackageExitCode(int v) {\n+            expectedJPackageExitCode = v;\n+            return this;\n+        }\n+\n+        TestSpecBuilder actualJPackageExitCode(int v) {\n+            actualJPackageExitCode = v;\n+            return this;\n+        }\n+\n+        TestSpecBuilder addActions(Action... v) {\n+            actions.addAll(List.of(v));\n+            return this;\n+        }\n+\n+        TestSpecBuilder actions(Action... v) {\n+            actions.clear();\n+            return addActions(v);\n+        }\n+\n+        TestSpecBuilder doCreateAndUnpack() {\n+            actions(Action.CREATE_AND_UNPACK);\n+            install(NEVER);\n+            uninstall(NEVER);\n+            if (willHaveBundle()) {\n+                overrideNonNullUnpack(ONCE);\n+            } else {\n+                overrideNonNullUnpack(NEVER);\n+            }\n+            initializers(ONCE);\n+            if (expectedJPackageExitCode != actualJPackageExitCode) {\n+                bundleVerifiers(BundleVerifier.NEVER.spec());\n+            } else if (expectedJPackageExitCode == 0) {\n+                bundleVerifiers(BundleVerifier.ONCE_SUCCESS.spec());\n+                bundleVerifiers(BundleVerifier.ONCE_SUCCESS_EXIT_CODE.spec());\n+            } else {\n+                bundleVerifiers(BundleVerifier.ONCE_FAIL.spec());\n+                if (expectedJPackageExitCode == ERROR_EXIT_CODE_JPACKAGE) {\n+                    bundleVerifiers(BundleVerifier.ONCE_FAIL_EXIT_CODE.spec());\n+                }\n+            }\n+            uninstallVerifiers(NEVER);\n+            if (willVerifyUnpack()) {\n+                installVerifiers(ONCE);\n+            } else {\n+                installVerifiers(NEVER);\n+            }\n+            return this;\n+        }\n+\n+        TestSpecBuilder doCreateUnpackInstallUninstall() {\n+            actions(Action.CREATE, Action.UNPACK, Action.VERIFY_INSTALL, Action.INSTALL,\n+                    Action.VERIFY_INSTALL, Action.UNINSTALL, Action.VERIFY_UNINSTALL);\n+            initializers(ONCE);\n+            uninstallVerifiers(NEVER);\n+            if (willHaveBundle()) {\n+                overrideNonNullUnpack(ONCE);\n+                install(ONCE);\n+                if (installExitCode == 0) {\n+                    uninstall(ONCE);\n+                    uninstallVerifiers(ONCE);\n+                } else {\n+                    uninstall(NEVER);\n+                }\n+            } else {\n+                overrideNonNullUnpack(NEVER);\n+                install(NEVER);\n+                uninstall(NEVER);\n+            }\n+\n+            if (expectedJPackageExitCode != actualJPackageExitCode) {\n+                bundleVerifiers(BundleVerifier.NEVER.spec());\n+                installVerifiers(NEVER);\n+            } else if (expectedJPackageExitCode == 0) {\n+                bundleVerifiers(BundleVerifier.ONCE_SUCCESS.spec());\n+                bundleVerifiers(BundleVerifier.ONCE_SUCCESS_EXIT_CODE.spec());\n+                if (installExitCode == 0) {\n+                    if (willVerifyUnpack()) {\n+                        installVerifiers(TWICE);\n+                    } else {\n+                        installVerifiers(ONCE);\n+                    }\n+                } else {\n+                    if (willVerifyUnpack()) {\n+                        installVerifiers(ONCE);\n+                    } else {\n+                        installVerifiers(NEVER);\n+                    }\n+                }\n+            } else {\n+                bundleVerifiers(BundleVerifier.ONCE_FAIL.spec());\n+                if (expectedJPackageExitCode == ERROR_EXIT_CODE_JPACKAGE) {\n+                    bundleVerifiers(BundleVerifier.ONCE_FAIL_EXIT_CODE.spec());\n+                }\n+                installVerifiers(NEVER);\n+            }\n+            return this;\n+        }\n+\n+        TestSpecBuilder addInitializers(CallbackFactory... v) {\n+            initializers.addAll(List.of(v));\n+            return this;\n+        }\n+\n+        TestSpecBuilder addBundleVerifiers(BundleVerifierSpec... v) {\n+            bundleVerifiers.addAll(List.of(v));\n+            return this;\n+        }\n+\n+        TestSpecBuilder addInstallVerifiers(CallbackFactory... v) {\n+            installVerifiers.addAll(List.of(v));\n+            return this;\n+        }\n+\n+        TestSpecBuilder addUninstallVerifiers(CallbackFactory... v) {\n+            uninstallVerifiers.addAll(List.of(v));\n+            return this;\n+        }\n+\n+        TestSpecBuilder initializers(CallbackFactory... v) {\n+            initializers.clear();\n+            return addInitializers(v);\n+        }\n+\n+        TestSpecBuilder bundleVerifiers(BundleVerifierSpec... v) {\n+            bundleVerifiers.clear();\n+            return addBundleVerifiers(v);\n+        }\n+\n+        TestSpecBuilder installVerifiers(CallbackFactory... v) {\n+            installVerifiers.clear();\n+            return addInstallVerifiers(v);\n+        }\n+\n+        TestSpecBuilder uninstallVerifiers(CallbackFactory... v) {\n+            uninstallVerifiers.clear();\n+            return addUninstallVerifiers(v);\n+        }\n+\n+        TestSpec create() {\n+            final var handlersSpec = new PackageHandlersSpec(\n+                    install.createInstaller(installExitCode), uninstall.createUninstaller(),\n+                    Optional.ofNullable(unpack).map(CallbackFactory::createUnpacker), installExitCode);\n+            return new TestSpec(type, handlersSpec,\n+                    initializers.stream().map(CallbackFactory::createInitializer).toList(),\n+                    bundleVerifiers,\n+                    installVerifiers.stream().map(CallbackFactory::createInstallVerifier).toList(),\n+                    uninstallVerifiers.stream().map(CallbackFactory::createUninstallVerifier).toList(),\n+                    expectedJPackageExitCode,\n+                    actualJPackageExitCode, actions);\n+        }\n+\n+        boolean willVerifyCreate() {\n+            return actions.contains(Action.CREATE) && actualJPackageExitCode == 0 && expectedJPackageExitCode == actualJPackageExitCode;\n+        }\n+\n+        boolean willHaveBundle() {\n+            return !actions.contains(Action.CREATE) || willVerifyCreate();\n+        }\n+\n+        boolean willVerifyUnpack() {\n+            return actions.contains(Action.UNPACK) && willHaveBundle() && unpack != null;\n+        }\n+\n+        boolean willVerifyInstall() {\n+            return (actions.contains(Action.INSTALL) && installExitCode == 0) && willHaveBundle();\n+        }\n+\n+        private void overrideNonNullUnpack(CallbackFactory v) {\n+            if (unpack != null) {\n+                unpack(v);\n+            }\n+        }\n+\n+        private PackageType type = PackageType.LINUX_RPM;\n+        private CallbackFactory install = NEVER;\n+        private CallbackFactory uninstall = NEVER;\n+        private CallbackFactory unpack = NEVER;\n+        private int installExitCode;\n+        private final List<CallbackFactory> initializers = new ArrayList<>();\n+        private final List<BundleVerifierSpec> bundleVerifiers = new ArrayList<>();\n+        private final List<CallbackFactory> installVerifiers = new ArrayList<>();\n+        private final List<CallbackFactory> uninstallVerifiers = new ArrayList<>();\n+        private int expectedJPackageExitCode;\n+        private int actualJPackageExitCode;\n+        private final List<Action> actions = new ArrayList<>();\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    public void test(TestSpec spec) {\n+        spec.run();\n+    }\n+\n+    public static List<Object[]> test() {\n+        List<TestSpec> data = new ArrayList<>();\n+\n+        for (boolean withUnpack : List.of(false, true)) {\n+            for (int actualJPackageExitCode : List.of(0, 1, ERROR_EXIT_CODE_INSTALL)) {\n+                for (int expectedJPackageExitCode : List.of(0, 1, ERROR_EXIT_CODE_INSTALL)) {\n+                    data.add(new TestSpecBuilder()\n+                            .unpack(withUnpack ? ONCE : null)\n+                            .actualJPackageExitCode(actualJPackageExitCode)\n+                            .expectedJPackageExitCode(expectedJPackageExitCode)\n+                            .doCreateAndUnpack().create());\n+                }\n+            }\n+        }\n+\n+        for (boolean withUnpack : List.of(false, true)) {\n+            for (int installExitCode : List.of(0, 1, ERROR_EXIT_CODE_INSTALL)) {\n+                for (int actualJPackageExitCode : List.of(0, 1, ERROR_EXIT_CODE_JPACKAGE)) {\n+                    for (int expectedJPackageExitCode : List.of(0, 1, ERROR_EXIT_CODE_JPACKAGE)) {\n+                        data.add(new TestSpecBuilder()\n+                                .unpack(withUnpack ? ONCE : null)\n+                                .installExitCode(installExitCode)\n+                                .actualJPackageExitCode(actualJPackageExitCode)\n+                                .expectedJPackageExitCode(expectedJPackageExitCode)\n+                                .doCreateUnpackInstallUninstall().create());\n+                    }\n+                }\n+            }\n+        }\n+\n+        data.add(new TestSpecBuilder()\n+                .actions(Action.VERIFY_INSTALL, Action.UNINSTALL, Action.VERIFY_INSTALL, Action.VERIFY_UNINSTALL)\n+                .uninstall(ONCE)\n+                .initializers(ONCE)\n+                .bundleVerifiers(BundleVerifier.NEVER.spec())\n+                .installVerifiers(TWICE)\n+                .uninstallVerifiers(ONCE)\n+                .create());\n+\n+        return data.stream().map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    public void testDisableInstallerUninstaller(TestSpec spec, boolean disableInstaller, boolean disableUninstaller) {\n+        spec.run(test -> {\n+            if (disableInstaller) {\n+                test.disablePackageInstaller();\n+            }\n+            if (disableUninstaller) {\n+                test.disablePackageUninstaller();\n+            }\n+        });\n+    }\n+\n+    public static List<Object[]> testDisableInstallerUninstaller() {\n+        List<Object[]> data = new ArrayList<>();\n+\n+        for (boolean disableInstaller : List.of(true, false)) {\n+            for (boolean disableUninstaller : List.of(true, false)) {\n+                if (disableInstaller || disableUninstaller) {\n+                    final var builder = new TestSpecBuilder().doCreateUnpackInstallUninstall();\n+                    if (disableInstaller) {\n+                        builder.install(NEVER);\n+                    }\n+                    if (disableUninstaller) {\n+                        builder.uninstall(NEVER);\n+                    }\n+                    data.add(new Object[] { builder.create(), disableInstaller, disableUninstaller });\n+                }\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Path> getUnpackPaths(Collection<Verifiable> verifiers) {\n+        return verifiers.stream()\n+                .filter(CountingUnpacker.class::isInstance)\n+                .map(CountingUnpacker.class::cast)\n+                .map(CountingUnpacker::unpackPaths)\n+                .reduce((x , y) -> {\n+                    throw new UnsupportedOperationException();\n+                }).orElseThrow();\n+    }\n+\n+    @Test\n+    public void testUnpackTwice() {\n+        final var testSpec = new TestSpecBuilder()\n+                .actions(Action.CREATE, Action.UNPACK, Action.VERIFY_INSTALL, Action.UNPACK, Action.VERIFY_INSTALL)\n+                .unpack(TWICE)\n+                .initializers(ONCE)\n+                .installVerifiers(TWICE)\n+                .create();\n+\n+        final var unpackPaths = getUnpackPaths(testSpec.run());\n+\n+        TKit.assertEquals(2, unpackPaths.size(), \"Check the bundle was unpacked in different directories\");\n+\n+        unpackPaths.forEach(dir -> {\n+            TKit.assertTrue(dir.startsWith(TKit.workDir()), \"Check unpack directory is inside of the test work directory\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDeleteUnpackDirs() {\n+        final int unpackActionCount = 4;\n+        final var testSpec = new TestSpecBuilder()\n+                .actions(Action.UNPACK, Action.UNPACK, Action.UNPACK, Action.UNPACK)\n+                .unpack(new CallbackFactory(unpackActionCount) {\n+                    @Override\n+                    CountingUnpacker createUnpacker() {\n+                        return new CountingUnpacker(unpackActionCount) {\n+                            @Override\n+                            public Path apply(JPackageCommand cmd, Path path) {\n+                                switch (tickCount()) {\n+                                    case 0 -> {\n+                                    }\n+\n+                                    case 2 -> {\n+                                        path = path.resolve(\"foo\");\n+                                    }\n+\n+                                    case 1, 3 -> {\n+                                        try {\n+                                            path = Files.createTempDirectory(\"jpackage-test\");\n+                                        } catch (IOException ex) {\n+                                            throw new UncheckedIOException(ex);\n+                                        }\n+                                    }\n+\n+                                    default -> {\n+                                        throw new IllegalStateException();\n+                                    }\n+                                }\n+                                return super.apply(cmd, path);\n+                            }\n+                        };\n+                    }\n+                })\n+                .initializers(ONCE)\n+                .create();\n+\n+        final var unpackPaths = getUnpackPaths(testSpec.run());\n+\n+        TKit.assertEquals(unpackActionCount, unpackPaths.size(), \"Check the bundle was unpacked in different directories\");\n+\n+        \/\/ Unpack directories within the test work directory must exist.\n+        TKit.assertDirectoryExists(unpackPaths.get(0));\n+        TKit.assertDirectoryExists(unpackPaths.get(2));\n+\n+        \/\/ Unpack directories outside of the test work directory must be deleted.\n+        TKit.assertPathExists(unpackPaths.get(1), false);\n+        TKit.assertPathExists(unpackPaths.get(3), false);\n+    }\n+\n+    @Test\n+    public void testRunOnceInitializer() {\n+        final var testSpec = new TestSpecBuilder().doCreateAndUnpack().unpack(TWICE).create();\n+\n+        final var initializer = TWICE.createInitializer();\n+        final var runOnceInitializer = ONCE.createRunOnceInitializer();\n+        testSpec.run(test -> {\n+            test.forTypes(PackageType.LINUX_RPM, PackageType.WIN_MSI)\n+                    .addRunOnceInitializer(runOnceInitializer)\n+                    .addInitializer(initializer);\n+        });\n+\n+        initializer.verify();\n+        runOnceInitializer.verify();\n+    }\n+\n+    @Test\n+    @Parameter(\"0\")\n+    @Parameter(\"1\")\n+    public void testPurge(int jpackageExitCode) {\n+\n+        Path[] outputBundle = new Path[1];\n+\n+        final var builder = new TestSpecBuilder();\n+\n+        builder.actions(Action.CREATE).initializers(new CallbackFactory(1) {\n+            @Override\n+            CountingConsumer createInitializer() {\n+                    return new CountingConsumer(1, \"custom-init\") {\n+                        @Override\n+                        public void accept(JPackageCommand cmd) {\n+                            outputBundle[0] = cmd.outputBundle();\n+                            super.accept(cmd);\n+                        }\n+                    };\n+                }\n+            }).create().run();\n+        TKit.assertFileExists(outputBundle[0]);\n+\n+        builder.actions(Action.PURGE).initializers(ONCE).jpackageExitCode(jpackageExitCode).create().run();\n+        TKit.assertPathExists(outputBundle[0], false);\n+    }\n+\n+    @Test\n+    public void testPackageTestOrder() {\n+\n+        Set<PackageType> packageTypes = new LinkedHashSet<>();\n+\n+        final var initializer = new CountingConsumer(PackageType.NATIVE.size(), \"custom-init\") {\n+            @Override\n+            public void accept(JPackageCommand cmd) {\n+                packageTypes.add(new JPackageCommand().setArgumentValue(\n+                        \"--type\", cmd.getArgumentValue(\"--type\")).packageType());\n+                super.accept(cmd);\n+            }\n+        };\n+\n+        new TestSpecBuilder().actions(Action.CREATE).create().run(test -> {\n+            test.forTypes().addInitializer(initializer);\n+        });\n+\n+        initializer.verify();\n+\n+        final var expectedOrder = PackageType.NATIVE.stream()\n+                .sorted().map(PackageType::name).toList();\n+        final var actualOrder = packageTypes.stream().map(PackageType::name).toList();\n+\n+        TKit.assertStringListEquals(expectedOrder, actualOrder, \"Check the order or packaging\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":894,"deletions":0,"binary":false,"changes":894,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -79,0 +80,1 @@\n+        winMsiLogFile = cmd.winMsiLogFile;\n@@ -995,0 +997,16 @@\n+    JPackageCommand winMsiLogFile(Path v) {\n+        this.winMsiLogFile = v;\n+        return this;\n+    }\n+\n+    public Optional<Path> winMsiLogFile() {\n+        return Optional.ofNullable(winMsiLogFile);\n+    }\n+\n+    public Optional<Stream<String>> winMsiLogFileContents() {\n+        return winMsiLogFile().map(ThrowingFunction.toFunction(msiLog -> {\n+            \/\/ MSI log files are UTF16LE-encoded\n+            return Files.lines(msiLog, StandardCharsets.UTF_16LE);\n+        }));\n+    }\n+\n@@ -1171,0 +1189,1 @@\n+    private Path winMsiLogFile;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -198,23 +198,25 @@\n-        PackageHandlers deb = new PackageHandlers();\n-        deb.installHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.LINUX_DEB);\n-            Executor.of(\"sudo\", \"dpkg\", \"-i\")\n-            .addArgument(cmd.outputBundle())\n-            .execute();\n-        };\n-        deb.uninstallHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.LINUX_DEB);\n-            var packageName = getPackageName(cmd);\n-            String script = String.format(\"! dpkg -s %s || sudo dpkg -r %s\",\n-                    packageName, packageName);\n-            Executor.of(\"sh\", \"-c\", script).execute();\n-        };\n-        deb.unpackHandler = (cmd, destinationDir) -> {\n-            cmd.verifyIsOfType(PackageType.LINUX_DEB);\n-            Executor.of(\"dpkg\", \"-x\")\n-            .addArgument(cmd.outputBundle())\n-            .addArgument(destinationDir)\n-            .execute();\n-            return destinationDir;\n-        };\n-        return deb;\n+        return new PackageHandlers(LinuxHelper::installDeb, LinuxHelper::uninstallDeb, LinuxHelper::unpackDeb);\n+    }\n+\n+    private static int installDeb(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.LINUX_DEB);\n+        return Executor.of(\"sudo\", \"dpkg\", \"-i\")\n+                .addArgument(cmd.outputBundle())\n+                .execute().getExitCode();\n+    }\n+\n+    private static void uninstallDeb(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.LINUX_DEB);\n+        var packageName = getPackageName(cmd);\n+        String script = String.format(\"! dpkg -s %s || sudo dpkg -r %s\",\n+                packageName, packageName);\n+        Executor.of(\"sh\", \"-c\", script).execute();\n+    }\n+\n+    private static Path unpackDeb(JPackageCommand cmd, Path destinationDir) {\n+        cmd.verifyIsOfType(PackageType.LINUX_DEB);\n+        Executor.of(\"dpkg\", \"-x\")\n+        .addArgument(cmd.outputBundle())\n+        .addArgument(destinationDir)\n+        .execute(0);\n+        return destinationDir;\n@@ -224,26 +226,27 @@\n-        PackageHandlers rpm = new PackageHandlers();\n-        rpm.installHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.LINUX_RPM);\n-            Executor.of(\"sudo\", \"rpm\", \"-U\")\n-            .addArgument(cmd.outputBundle())\n-            .execute();\n-        };\n-        rpm.uninstallHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.LINUX_RPM);\n-            var packageName = getPackageName(cmd);\n-            String script = String.format(\"! rpm -q %s || sudo rpm -e %s\",\n-                    packageName, packageName);\n-            Executor.of(\"sh\", \"-c\", script).execute();\n-        };\n-        rpm.unpackHandler = (cmd, destinationDir) -> {\n-            cmd.verifyIsOfType(PackageType.LINUX_RPM);\n-            Executor.of(\"sh\", \"-c\", String.format(\n-                    \"rpm2cpio '%s' | cpio -idm --quiet\",\n-                    JPackageCommand.escapeAndJoin(\n-                            cmd.outputBundle().toAbsolutePath().toString())))\n-            .setDirectory(destinationDir)\n-            .execute();\n-            return destinationDir;\n-        };\n-\n-        return rpm;\n+        return new PackageHandlers(LinuxHelper::installRpm, LinuxHelper::uninstallRpm, LinuxHelper::unpackRpm);\n+    }\n+\n+    private static int installRpm(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.LINUX_RPM);\n+        return Executor.of(\"sudo\", \"rpm\", \"-U\")\n+                .addArgument(cmd.outputBundle())\n+                .execute().getExitCode();\n+    }\n+\n+    private static void uninstallRpm(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.LINUX_RPM);\n+        var packageName = getPackageName(cmd);\n+        String script = String.format(\"! rpm -q %s || sudo rpm -e %s\",\n+                packageName, packageName);\n+        Executor.of(\"sh\", \"-c\", script).execute();\n+    }\n+\n+    private static Path unpackRpm(JPackageCommand cmd, Path destinationDir) {\n+        cmd.verifyIsOfType(PackageType.LINUX_RPM);\n+        Executor.of(\"sh\", \"-c\", String.format(\n+                \"rpm2cpio '%s' | cpio -idm --quiet\",\n+                JPackageCommand.escapeAndJoin(\n+                        cmd.outputBundle().toAbsolutePath().toString())))\n+        .setDirectory(destinationDir)\n+        .execute(0);\n+        return destinationDir;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":52,"deletions":49,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import static java.util.stream.Collectors.toSet;\n+\n@@ -32,1 +34,0 @@\n-import java.util.List;\n@@ -34,0 +35,1 @@\n+import java.util.List;\n@@ -38,1 +40,0 @@\n-import static java.util.stream.Collectors.toSet;\n@@ -46,0 +47,2 @@\n+import jdk.jpackage.internal.RetryExecutor;\n+import jdk.jpackage.internal.util.PathUtils;\n@@ -49,3 +52,0 @@\n-import jdk.jpackage.internal.RetryExecutor;\n-import jdk.jpackage.internal.util.PathUtils;\n-import org.xml.sax.SAXException;\n@@ -53,0 +53,1 @@\n+import org.xml.sax.SAXException;\n@@ -152,1 +153,2 @@\n-        PackageHandlers dmg = new PackageHandlers();\n+        return new PackageHandlers(MacHelper::installDmg, MacHelper::uninstallDmg, MacHelper::unpackDmg);\n+    }\n@@ -154,17 +156,10 @@\n-        dmg.installHandler = cmd -> {\n-            withExplodedDmg(cmd, dmgImage -> {\n-                Executor.of(\"sudo\", \"cp\", \"-r\")\n-                .addArgument(dmgImage)\n-                .addArgument(getInstallationDirectory(cmd).getParent())\n-                .execute();\n-            });\n-        };\n-        dmg.unpackHandler = (cmd, destinationDir) -> {\n-            Path unpackDir = destinationDir.resolve(\n-                    TKit.removeRootFromAbsolutePath(\n-                            getInstallationDirectory(cmd)).getParent());\n-            try {\n-                Files.createDirectories(unpackDir);\n-            } catch (IOException ex) {\n-                throw new RuntimeException(ex);\n-            }\n+    private static int installDmg(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.MAC_DMG);\n+        withExplodedDmg(cmd, dmgImage -> {\n+            Executor.of(\"sudo\", \"cp\", \"-r\")\n+                    .addArgument(dmgImage)\n+                    .addArgument(getInstallationDirectory(cmd).getParent())\n+                    .execute(0);\n+        });\n+        return 0;\n+    }\n@@ -172,14 +167,17 @@\n-            withExplodedDmg(cmd, dmgImage -> {\n-                Executor.of(\"cp\", \"-r\")\n-                .addArgument(dmgImage)\n-                .addArgument(unpackDir)\n-                .execute();\n-            });\n-            return destinationDir;\n-        };\n-        dmg.uninstallHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.MAC_DMG);\n-            Executor.of(\"sudo\", \"rm\", \"-rf\")\n-            .addArgument(cmd.appInstallationDirectory())\n-            .execute();\n-        };\n+    private static void uninstallDmg(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.MAC_DMG);\n+        Executor.of(\"sudo\", \"rm\", \"-rf\")\n+        .addArgument(cmd.appInstallationDirectory())\n+        .execute();\n+    }\n+\n+    private static Path unpackDmg(JPackageCommand cmd, Path destinationDir) {\n+        cmd.verifyIsOfType(PackageType.MAC_DMG);\n+        Path unpackDir = destinationDir.resolve(\n+                TKit.removeRootFromAbsolutePath(\n+                        getInstallationDirectory(cmd)).getParent());\n+        try {\n+            Files.createDirectories(unpackDir);\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n@@ -187,1 +185,7 @@\n-        return dmg;\n+        withExplodedDmg(cmd, dmgImage -> {\n+            Executor.of(\"cp\", \"-r\")\n+            .addArgument(dmgImage)\n+            .addArgument(unpackDir)\n+            .execute();\n+        });\n+        return destinationDir;\n@@ -191,1 +195,2 @@\n-        PackageHandlers pkg = new PackageHandlers();\n+        return new PackageHandlers(MacHelper::installPkg, MacHelper::uninstallPkg, MacHelper::unpackPkg);\n+    }\n@@ -193,5 +198,16 @@\n-        pkg.installHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.MAC_PKG);\n-            Executor.of(\"sudo\", \"\/usr\/sbin\/installer\", \"-allowUntrusted\", \"-pkg\")\n-                    .addArgument(cmd.outputBundle())\n-                    .addArguments(\"-target\", \"\/\")\n+    private static int installPkg(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.MAC_PKG);\n+        return Executor.of(\"sudo\", \"\/usr\/sbin\/installer\", \"-allowUntrusted\", \"-pkg\")\n+                .addArgument(cmd.outputBundle())\n+                .addArguments(\"-target\", \"\/\")\n+                .execute().getExitCode();\n+    }\n+\n+    private static void uninstallPkg(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.MAC_PKG);\n+        if (Files.exists(getUninstallCommand(cmd))) {\n+            Executor.of(\"sudo\", \"\/bin\/sh\",\n+                    getUninstallCommand(cmd).toString()).execute();\n+        } else {\n+            Executor.of(\"sudo\", \"rm\", \"-rf\")\n+                    .addArgument(cmd.appInstallationDirectory())\n@@ -199,3 +215,2 @@\n-        };\n-        pkg.unpackHandler = (cmd, destinationDir) -> {\n-            cmd.verifyIsOfType(PackageType.MAC_PKG);\n+        }\n+    }\n@@ -203,1 +218,2 @@\n-            var dataDir = destinationDir.resolve(\"data\");\n+    private static Path unpackPkg(JPackageCommand cmd, Path destinationDir) {\n+        cmd.verifyIsOfType(PackageType.MAC_PKG);\n@@ -205,4 +221,1 @@\n-            Executor.of(\"pkgutil\", \"--expand\")\n-                    .addArgument(cmd.outputBundle())\n-                    .addArgument(dataDir) \/\/ We need non-existing folder\n-                    .execute();\n+        var dataDir = destinationDir.resolve(\"data\");\n@@ -210,32 +223,25 @@\n-            final Path unpackRoot = destinationDir.resolve(\"unpacked\");\n-\n-            \/\/ Unpack all \".pkg\" files from $dataDir folder in $unpackDir folder\n-            try (var dataListing = Files.list(dataDir)) {\n-                dataListing.filter(file -> {\n-                    return \".pkg\".equals(PathUtils.getSuffix(file.getFileName()));\n-                }).forEach(ThrowingConsumer.toConsumer(pkgDir -> {\n-                    \/\/ Installation root of the package is stored in\n-                    \/\/ \/pkg-info@install-location attribute in $pkgDir\/PackageInfo xml file\n-                    var doc = createDocumentBuilder().parse(\n-                            new ByteArrayInputStream(Files.readAllBytes(\n-                                    pkgDir.resolve(\"PackageInfo\"))));\n-                    var xPath = XPathFactory.newInstance().newXPath();\n-\n-                    final String installRoot = (String) xPath.evaluate(\n-                            \"\/pkg-info\/@install-location\", doc,\n-                            XPathConstants.STRING);\n-\n-                    final Path unpackDir = unpackRoot.resolve(\n-                            TKit.removeRootFromAbsolutePath(Path.of(installRoot)));\n-\n-                    Files.createDirectories(unpackDir);\n-\n-                    Executor.of(\"tar\", \"-C\")\n-                            .addArgument(unpackDir)\n-                            .addArgument(\"-xvf\")\n-                            .addArgument(pkgDir.resolve(\"Payload\"))\n-                            .execute();\n-                }));\n-            } catch (IOException ex) {\n-                throw new RuntimeException(ex);\n-            }\n+        Executor.of(\"pkgutil\", \"--expand\")\n+                .addArgument(cmd.outputBundle())\n+                .addArgument(dataDir) \/\/ We need non-existing folder\n+                .execute();\n+\n+        final Path unpackRoot = destinationDir.resolve(\"unpacked\");\n+\n+        \/\/ Unpack all \".pkg\" files from $dataDir folder in $unpackDir folder\n+        try (var dataListing = Files.list(dataDir)) {\n+            dataListing.filter(file -> {\n+                return \".pkg\".equals(PathUtils.getSuffix(file.getFileName()));\n+            }).forEach(ThrowingConsumer.toConsumer(pkgDir -> {\n+                \/\/ Installation root of the package is stored in\n+                \/\/ \/pkg-info@install-location attribute in $pkgDir\/PackageInfo xml file\n+                var doc = createDocumentBuilder().parse(\n+                        new ByteArrayInputStream(Files.readAllBytes(\n+                                pkgDir.resolve(\"PackageInfo\"))));\n+                var xPath = XPathFactory.newInstance().newXPath();\n+\n+                final String installRoot = (String) xPath.evaluate(\n+                        \"\/pkg-info\/@install-location\", doc,\n+                        XPathConstants.STRING);\n+\n+                final Path unpackDir = unpackRoot.resolve(\n+                        TKit.removeRootFromAbsolutePath(Path.of(installRoot)));\n@@ -243,11 +249,6 @@\n-            return unpackRoot;\n-        };\n-        pkg.uninstallHandler = cmd -> {\n-            cmd.verifyIsOfType(PackageType.MAC_PKG);\n-\n-            if (Files.exists(getUninstallCommand(cmd))) {\n-                Executor.of(\"sudo\", \"\/bin\/sh\",\n-                        getUninstallCommand(cmd).toString()).execute();\n-            } else {\n-                Executor.of(\"sudo\", \"rm\", \"-rf\")\n-                        .addArgument(cmd.appInstallationDirectory())\n+                Files.createDirectories(unpackDir);\n+\n+                Executor.of(\"tar\", \"-C\")\n+                        .addArgument(unpackDir)\n+                        .addArgument(\"-xvf\")\n+                        .addArgument(pkgDir.resolve(\"Payload\"))\n@@ -255,2 +256,4 @@\n-            }\n-        };\n+            }));\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n@@ -258,1 +261,1 @@\n-        return pkg;\n+        return unpackRoot;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":101,"deletions":98,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -25,0 +25,9 @@\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.PackageType.LINUX;\n+import static jdk.jpackage.test.PackageType.MAC_PKG;\n+import static jdk.jpackage.test.PackageType.NATIVE;\n+import static jdk.jpackage.test.PackageType.WINDOWS;\n+\n@@ -32,0 +41,1 @@\n+import java.util.Comparator;\n@@ -43,0 +53,1 @@\n+import java.util.function.Function;\n@@ -49,1 +60,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n@@ -51,1 +61,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -53,11 +62,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n-import static jdk.jpackage.test.PackageType.LINUX;\n-import static jdk.jpackage.test.PackageType.LINUX_DEB;\n-import static jdk.jpackage.test.PackageType.LINUX_RPM;\n-import static jdk.jpackage.test.PackageType.MAC_DMG;\n-import static jdk.jpackage.test.PackageType.MAC_PKG;\n-import static jdk.jpackage.test.PackageType.NATIVE;\n-import static jdk.jpackage.test.PackageType.WINDOWS;\n-import static jdk.jpackage.test.PackageType.WIN_EXE;\n-import static jdk.jpackage.test.PackageType.WIN_MSI;\n@@ -76,0 +74,5 @@\n+        isPackageTypeSupported = PackageType::isSupported;\n+        jpackageFactory = JPackageCommand::new;\n+        packageHandlers = new HashMap<>();\n+        disabledInstallers = new HashSet<>();\n+        disabledUninstallers = new HashSet<>();\n@@ -79,0 +82,1 @@\n+        setExpectedInstallExitCode(0);\n@@ -80,1 +84,1 @@\n-        handlers = currentTypes.stream()\n+        handlers = NATIVE.stream()\n@@ -82,1 +86,0 @@\n-        packageHandlers = createDefaultPackageHandlers();\n@@ -96,1 +99,1 @@\n-        if (types == null || types.length == 0) {\n+        if (types.length == 0) {\n@@ -102,1 +105,1 @@\n-                .filter(PackageType::isSupported)\n+                .filter(isPackageTypeSupported)\n@@ -127,0 +130,5 @@\n+    public PackageTest setExpectedInstallExitCode(int v) {\n+        expectedInstallExitCode = v;\n+        return this;\n+    }\n+\n@@ -136,2 +144,2 @@\n-    private PackageTest addInitializer(ThrowingConsumer<JPackageCommand> v,\n-            String id) {\n+    private PackageTest addInitializer(ThrowingConsumer<JPackageCommand> v, String id) {\n+        Objects.requireNonNull(v);\n@@ -145,2 +153,1 @@\n-        currentTypes.forEach(type -> handlers.get(type).addInitializer(\n-                toConsumer(v)));\n+        currentTypes.forEach(type -> handlers.get(type).addInitializer(toConsumer(v)));\n@@ -151,0 +158,1 @@\n+        Objects.requireNonNull(v);\n@@ -172,4 +180,3 @@\n-    public PackageTest addBundleVerifier(\n-            ThrowingBiConsumer<JPackageCommand, Executor.Result> v) {\n-        currentTypes.forEach(type -> handlers.get(type).addBundleVerifier(\n-                toBiConsumer(v)));\n+    public PackageTest addBundleVerifier(ThrowingBiConsumer<JPackageCommand, Executor.Result> v) {\n+        Objects.requireNonNull(v);\n+        currentTypes.forEach(type -> handlers.get(type).addBundleVerifier(toBiConsumer(v)));\n@@ -180,0 +187,1 @@\n+        Objects.requireNonNull(v);\n@@ -185,0 +193,2 @@\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(pred);\n@@ -187,1 +197,1 @@\n-            if (TKit.isLinux()) {\n+            if (isOfType(cmd, LINUX)) {\n@@ -189,1 +199,1 @@\n-            } else if (TKit.isWindows()) {\n+            } else if (isOfType(cmd, WINDOWS)) {\n@@ -226,2 +236,1 @@\n-        currentTypes.forEach(\n-                type -> packageHandlers.get(type).installHandler = cmd -> {});\n+        currentTypes.forEach(disabledInstallers::add);\n@@ -232,2 +241,6 @@\n-        currentTypes.forEach(\n-                type -> packageHandlers.get(type).uninstallHandler = cmd -> {});\n+        currentTypes.forEach(disabledUninstallers::add);\n+        return this;\n+    }\n+\n+    public PackageTest createMsiLog(boolean v) {\n+        createMsiLog = v;\n@@ -239,0 +252,1 @@\n+        Objects.requireNonNull(consumer);\n@@ -257,0 +271,1 @@\n+        Objects.requireNonNull(fa);\n@@ -293,1 +308,1 @@\n-            if (TKit.isWindows()) {\n+            if (isOfType(cmd, WINDOWS)) {\n@@ -310,2 +325,1 @@\n-        Set<PackageType> oldTypes = Set.of(currentTypes.toArray(\n-                PackageType[]::new));\n+        final var oldTypes = Set.of(currentTypes.toArray(PackageType[]::new));\n@@ -377,4 +391,53 @@\n-    static final class PackageHandlers {\n-        Consumer<JPackageCommand> installHandler;\n-        Consumer<JPackageCommand> uninstallHandler;\n-        BiFunction<JPackageCommand, Path, Path> unpackHandler;\n+    PackageTest packageHandlers(PackageHandlers v) {\n+        Objects.requireNonNull(v);\n+        currentTypes.forEach(type -> packageHandlers.put(type, v));\n+        return this;\n+    }\n+\n+    PackageTest isPackageTypeSupported(Predicate<PackageType> v) {\n+        Objects.requireNonNull(v);\n+        isPackageTypeSupported = v;\n+        return this;\n+    }\n+\n+    PackageTest jpackageFactory(Supplier<JPackageCommand> v) {\n+        Objects.requireNonNull(v);\n+        jpackageFactory = v;\n+        return this;\n+    }\n+\n+    record PackageHandlers(Function<JPackageCommand, Integer> installHandler,\n+            Consumer<JPackageCommand> uninstallHandler,\n+            Optional<? extends BiFunction<JPackageCommand, Path, Path>> unpackHandler) {\n+\n+        PackageHandlers(Function<JPackageCommand, Integer> installHandler,\n+                Consumer<JPackageCommand> uninstallHandler,\n+                BiFunction<JPackageCommand, Path, Path> unpackHandler) {\n+            this(installHandler, uninstallHandler, Optional.of(unpackHandler));\n+        }\n+\n+        PackageHandlers {\n+            Objects.requireNonNull(installHandler);\n+            Objects.requireNonNull(uninstallHandler);\n+            Objects.requireNonNull(unpackHandler);\n+        }\n+\n+        PackageHandlers copyWithNopInstaller() {\n+            return new PackageHandlers(cmd -> 0, uninstallHandler, unpackHandler);\n+        }\n+\n+        PackageHandlers copyWithNopUninstaller() {\n+            return new PackageHandlers(installHandler, cmd -> {}, unpackHandler);\n+        }\n+\n+        int install(JPackageCommand cmd) {\n+            return installHandler.apply(cmd);\n+        }\n+\n+        Path unpack(JPackageCommand cmd, Path unpackDir) {\n+            return unpackHandler.orElseThrow().apply(cmd, unpackDir);\n+        }\n+\n+        void uninstall(JPackageCommand cmd) {\n+            uninstallHandler.accept(cmd);\n+        }\n@@ -396,17 +459,7 @@\n-        return NATIVE.stream()\n-                .map(type -> {\n-                    Handler handler = handlers.entrySet().stream()\n-                        .filter(entry -> !entry.getValue().isVoid())\n-                        .filter(entry -> entry.getKey() == type)\n-                        .map(entry -> entry.getValue())\n-                        .findAny().orElse(null);\n-                    Map.Entry<PackageType, Handler> result = null;\n-                    if (handler != null) {\n-                        result = Map.entry(type, handler);\n-                    }\n-                    return result;\n-                })\n-                .filter(Objects::nonNull)\n-                .map(entry -> createPackageTypeHandler(\n-                        entry.getKey(), entry.getValue()))\n-                .collect(Collectors.toList());\n+        return handlers.entrySet().stream()\n+                .filter(entry -> !entry.getValue().isVoid())\n+                .filter(entry -> NATIVE.contains(entry.getKey()))\n+                .sorted(Comparator.comparing(Map.Entry::getKey))\n+                .map(entry -> {\n+                    return  createPackageTypeHandler(entry.getKey(), entry.getValue());\n+                }).toList();\n@@ -415,8 +468,3 @@\n-    private Consumer<Action> createPackageTypeHandler(\n-            PackageType type, Handler handler) {\n-        return toConsumer(new ThrowingConsumer<Action>() {\n-            @Override\n-            public void accept(Action action) throws Throwable {\n-                if (terminated) {\n-                    throw new IllegalStateException();\n-                }\n+    private record PackageTypePipeline(PackageType type, int expectedJPackageExitCode,\n+            int expectedInstallExitCode, PackageHandlers packageHandlers, Handler handler,\n+            JPackageCommand cmd, State state) implements Consumer<Action> {\n@@ -424,10 +472,7 @@\n-                if (action == Action.FINALIZE) {\n-                    if (unpackDir != null) {\n-                        if (Files.isDirectory(unpackDir)\n-                                && !unpackDir.startsWith(TKit.workDir())) {\n-                            TKit.deleteDirectoryRecursive(unpackDir);\n-                        }\n-                        unpackDir = null;\n-                    }\n-                    terminated = true;\n-                }\n+        PackageTypePipeline {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(packageHandlers);\n+            Objects.requireNonNull(handler);\n+            Objects.requireNonNull(cmd);\n+            Objects.requireNonNull(state);\n+        }\n@@ -435,17 +480,6 @@\n-                boolean skip = false;\n-\n-                if (unhandledAction != null) {\n-                    switch (unhandledAction) {\n-                        case CREATE:\n-                            skip = true;\n-                            break;\n-                        case UNPACK:\n-                        case INSTALL:\n-                            skip = (action == Action.VERIFY_INSTALL);\n-                            break;\n-                        case UNINSTALL:\n-                            skip = (action == Action.VERIFY_UNINSTALL);\n-                            break;\n-                        default: \/\/ NOP\n-                    }\n-                }\n+        PackageTypePipeline(PackageType type, int expectedJPackageExitCode,\n+                int expectedInstallExitCode, PackageHandlers packageHandlers,\n+                Handler handler, JPackageCommand cmd) {\n+            this(type, expectedJPackageExitCode, expectedInstallExitCode,\n+                    packageHandlers, handler, cmd, new State());\n+        }\n@@ -453,1 +487,9 @@\n-                if (skip) {\n+        @Override\n+        public void accept(Action action) {\n+            switch(analizeAction(action)) {\n+                case SKIP_NO_PACKAGE_HANDLER -> {\n+                    TKit.trace(String.format(\"No handler of [%s] action for %s command\",\n+                            action, cmd.getPrintableCommandLine()));\n+                    return;\n+                }\n+                case SKIP -> {\n@@ -458,0 +500,3 @@\n+                case PROCESS -> {\n+                }\n+            }\n@@ -459,21 +504,8 @@\n-                final Supplier<JPackageCommand> curCmd = () -> {\n-                    if (Set.of(Action.INITIALIZE, Action.CREATE).contains(action)) {\n-                        return cmd;\n-                    } else {\n-                        return cmd.createImmutableCopy();\n-                    }\n-                };\n-\n-                switch (action) {\n-                    case UNPACK: {\n-                        cmd.setUnpackedPackageLocation(null);\n-                        handleAction(action,\n-                                packageHandlers.get(type).unpackHandler,\n-                                handler -> {\n-                                    unpackDir = TKit.createTempDirectory(\n-                                            String.format(\"unpacked-%s\",\n-                                                    type.getName()));\n-                                    unpackDir = handler.apply(cmd, unpackDir);\n-                                    cmd.setUnpackedPackageLocation(unpackDir);\n-                                });\n-                        break;\n+            switch (action) {\n+                case UNPACK -> {\n+                    cmd.setUnpackedPackageLocation(null);\n+                    final var unpackRootDir = TKit.createTempDirectory(\n+                            String.format(\"unpacked-%s\", type.getName()));\n+                    final Path unpackDir = packageHandlers.unpack(cmd, unpackRootDir);\n+                    if (!unpackDir.startsWith(TKit.workDir())) {\n+                        state.deleteUnpackDirs.add(unpackDir);\n@@ -481,0 +513,2 @@\n+                    cmd.setUnpackedPackageLocation(unpackDir);\n+                }\n@@ -482,9 +516,6 @@\n-                    case INSTALL: {\n-                        cmd.setUnpackedPackageLocation(null);\n-                        handleAction(action,\n-                                packageHandlers.get(type).installHandler,\n-                                handler -> {\n-                                    handler.accept(curCmd.get());\n-                                });\n-                        break;\n-                    }\n+                case INSTALL -> {\n+                    cmd.setUnpackedPackageLocation(null);\n+                    final int installExitCode = packageHandlers.install(cmd);\n+                    TKit.assertEquals(expectedInstallExitCode, installExitCode,\n+                            String.format(\"Check installer exited with %d code\", expectedInstallExitCode));\n+                }\n@@ -492,8 +523,4 @@\n-                    case UNINSTALL: {\n-                        handleAction(action,\n-                                packageHandlers.get(type).uninstallHandler,\n-                                handler -> {\n-                                    handler.accept(curCmd.get());\n-                                });\n-                        break;\n-                    }\n+                case UNINSTALL -> {\n+                    cmd.setUnpackedPackageLocation(null);\n+                    packageHandlers.uninstall(cmd);\n+                }\n@@ -501,12 +528,3 @@\n-                    case CREATE:\n-                        cmd.setUnpackedPackageLocation(null);\n-                        handler.accept(action, curCmd.get());\n-                        handleAction(action,\n-                                (expectedJPackageExitCode == 0) ? Boolean.TRUE : null,\n-                                handler -> {\n-                                });\n-                        return;\n-\n-                    default:\n-                        handler.accept(action, curCmd.get());\n-                        break;\n+                case CREATE -> {\n+                    cmd.setUnpackedPackageLocation(null);\n+                    handler.processAction(action, cmd, expectedJPackageExitCode);\n@@ -515,6 +533,8 @@\n-                Optional.ofNullable(unhandledAction).ifPresent(v -> {\n-                    TKit.trace(String.format(\n-                            \"No handler of [%s] action for %s command\", v,\n-                            cmd.getPrintableCommandLine()));\n-                });\n-            }\n+                case INITIALIZE -> {\n+                    handler.processAction(action, cmd, expectedJPackageExitCode);\n+                }\n+\n+                case FINALIZE -> {\n+                    state.deleteUnpackDirs.forEach(TKit::deleteDirectoryRecursive);\n+                    state.deleteUnpackDirs.clear();\n+                }\n@@ -522,7 +542,2 @@\n-            private <T> void handleAction(Action action, T handler,\n-                    ThrowingConsumer<T> consumer) throws Throwable {\n-                if (handler == null) {\n-                    unhandledAction = action;\n-                } else {\n-                    unhandledAction = null;\n-                    consumer.accept(handler);\n+                default -> {\n+                    handler.processAction(action, cmd.createImmutableCopy(), expectedJPackageExitCode);\n@@ -531,0 +546,14 @@\n+        }\n+\n+        private enum ActionAction {\n+            PROCESS,\n+            SKIP,\n+            SKIP_NO_PACKAGE_HANDLER\n+        }\n+\n+        private ActionAction analizeAction(Action action) {\n+            Objects.requireNonNull(action);\n+\n+            if (jpackageFailed()) {\n+                return ActionAction.SKIP;\n+            }\n@@ -532,8 +561,3 @@\n-            private Path unpackDir;\n-            private Action unhandledAction;\n-            private boolean terminated;\n-            private final JPackageCommand cmd = Functional.identity(() -> {\n-                JPackageCommand result = new JPackageCommand();\n-                result.setDefaultInputOutput().setDefaultAppName();\n-                if (BUNDLE_OUTPUT_DIR != null && !ignoreBundleOutputDir) {\n-                    result.setArgumentValue(\"--dest\", BUNDLE_OUTPUT_DIR.toString());\n+            switch (action) {\n+                case CREATE -> {\n+                    state.packageActions.add(action);\n@@ -541,4 +565,60 @@\n-                type.applyTo(result);\n-                return result;\n-            }).get();\n-        });\n+                case INSTALL -> {\n+                    state.packageActions.add(action);\n+                    state.packageActions.remove(Action.UNPACK);\n+                }\n+                case UNINSTALL -> {\n+                    state.packageActions.add(action);\n+                    if (installFailed()) {\n+                        return ActionAction.SKIP;\n+                    }\n+                }\n+                case UNPACK -> {\n+                    state.packageActions.add(action);\n+                    state.packageActions.remove(Action.INSTALL);\n+                    if (unpackNotSupported()) {\n+                        return ActionAction.SKIP_NO_PACKAGE_HANDLER;\n+                    }\n+                }\n+                case VERIFY_INSTALL -> {\n+                    if (unpackNotSupported()) {\n+                        return ActionAction.SKIP;\n+                    }\n+\n+                    if (installFailed()) {\n+                        return ActionAction.SKIP;\n+                    }\n+                }\n+                case VERIFY_UNINSTALL -> {\n+                    if (installFailed() && processed(Action.UNINSTALL)) {\n+                        return ActionAction.SKIP;\n+                    }\n+                }\n+                default -> {\n+                    \/\/ NOP\n+                }\n+            }\n+\n+            return ActionAction.PROCESS;\n+        }\n+\n+        private boolean processed(Action action) {\n+            Objects.requireNonNull(action);\n+            return state.packageActions.contains(action);\n+        }\n+\n+        private boolean installFailed() {\n+            return processed(Action.INSTALL) && expectedInstallExitCode != 0;\n+        }\n+\n+        private boolean jpackageFailed() {\n+            return processed(Action.CREATE) && expectedJPackageExitCode != 0;\n+        }\n+\n+        private boolean unpackNotSupported() {\n+            return processed(Action.UNPACK) && packageHandlers.unpackHandler().isEmpty();\n+        }\n+\n+        private final static class State {\n+            private final Set<Action> packageActions = new HashSet<>();\n+            private final List<Path> deleteUnpackDirs = new ArrayList<>();\n+        }\n@@ -547,1 +627,15 @@\n-    private class Handler implements BiConsumer<Action, JPackageCommand> {\n+    private Consumer<Action> createPackageTypeHandler(PackageType type, Handler handler) {\n+        final var cmd = jpackageFactory.get();\n+        cmd.setDefaultInputOutput().setDefaultAppName();\n+        if (BUNDLE_OUTPUT_DIR != null && !ignoreBundleOutputDir) {\n+            cmd.setArgumentValue(\"--dest\", BUNDLE_OUTPUT_DIR.toString());\n+        }\n+        type.applyTo(cmd);\n+        return new PackageTypePipeline(type, expectedJPackageExitCode,\n+                expectedInstallExitCode, getPackageHandlers(type), handler.copy(), cmd);\n+    }\n+\n+    private record Handler(List<Consumer<JPackageCommand>> initializers,\n+            List<BiConsumer<JPackageCommand, Executor.Result>> bundleVerifiers,\n+            List<Consumer<JPackageCommand>> installVerifiers,\n+            List<Consumer<JPackageCommand>> uninstallVerifiers) {\n@@ -550,4 +644,6 @@\n-            initializers = new ArrayList<>();\n-            bundleVerifiers = new ArrayList<>();\n-            installVerifiers = new ArrayList<>();\n-            uninstallVerifiers = new ArrayList<>();\n+            this(new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), new ArrayList<>());\n+        }\n+\n+        Handler copy() {\n+            return new Handler(List.copyOf(initializers), List.copyOf(bundleVerifiers),\n+                    List.copyOf(installVerifiers), List.copyOf(uninstallVerifiers));\n@@ -576,2 +672,1 @@\n-        @Override\n-        public void accept(Action action, JPackageCommand cmd) {\n+        public void processAction(Action action, JPackageCommand cmd, int expectedJPackageExitCode) {\n@@ -579,1 +674,1 @@\n-                case INITIALIZE:\n+                case INITIALIZE -> {\n@@ -585,1 +680,1 @@\n-                    break;\n+                }\n@@ -587,1 +682,1 @@\n-                case CREATE:\n+                case CREATE -> {\n@@ -596,2 +691,2 @@\n-                    verifyPackageBundle(cmd, result);\n-                    break;\n+                    verifyPackageBundle(cmd, result, expectedJPackageExitCode);\n+                }\n@@ -599,1 +694,1 @@\n-                case VERIFY_INSTALL:\n+                case VERIFY_INSTALL -> {\n@@ -603,1 +698,1 @@\n-                    break;\n+                }\n@@ -605,1 +700,1 @@\n-                case VERIFY_UNINSTALL:\n+                case VERIFY_UNINSTALL -> {\n@@ -609,1 +704,1 @@\n-                    break;\n+                }\n@@ -611,7 +706,4 @@\n-                case PURGE:\n-                    if (expectedJPackageExitCode == 0) {\n-                        var bundle = cmd.outputBundle();\n-                        if (toSupplier(() -> TKit.deleteIfExists(bundle)).get()) {\n-                            TKit.trace(String.format(\"Deleted [%s] package\",\n-                                    bundle));\n-                        }\n+                case PURGE -> {\n+                    var bundle = cmd.outputBundle();\n+                    if (toSupplier(() -> TKit.deleteIfExists(bundle)).get()) {\n+                        TKit.trace(String.format(\"Deleted [%s] package\", bundle));\n@@ -619,1 +711,1 @@\n-                    break;\n+                }\n@@ -621,1 +713,3 @@\n-                default: \/\/ NOP\n+                default -> {\n+                    \/\/ NOP\n+                }\n@@ -626,1 +720,1 @@\n-                Executor.Result result) {\n+                Executor.Result result, int expectedJPackageExitCode) {\n@@ -628,1 +722,1 @@\n-                if (LINUX.contains(cmd.packageType())) {\n+                if (isOfType(cmd, LINUX)) {\n@@ -650,3 +744,1 @@\n-                if (WINDOWS.contains(cmd.packageType())\n-                        && !cmd.isPackageUnpacked(\n-                                \"Not verifying desktop integration\")) {\n+                if (isOfType(cmd, WINDOWS) && !cmd.isPackageUnpacked(\"Not verifying desktop integration\")) {\n@@ -662,2 +754,1 @@\n-            if (LauncherAsServiceVerifier.SUPPORTED_PACKAGES.contains(\n-                    cmd.packageType())) {\n+            if (isOfType(cmd, LauncherAsServiceVerifier.SUPPORTED_PACKAGES)) {\n@@ -679,1 +770,1 @@\n-            if (WINDOWS.contains(cmd.packageType())) {\n+            if (isOfType(cmd, WINDOWS)) {\n@@ -683,1 +774,1 @@\n-            } else if (withServices && MAC_PKG.equals(cmd.packageType())) {\n+            } else if (withServices && isOfType(cmd, MAC_PKG)) {\n@@ -685,1 +776,1 @@\n-            } else if (LINUX.contains(cmd.packageType())) {\n+            } else if (isOfType(cmd, LINUX)) {\n@@ -735,1 +826,1 @@\n-                if (WINDOWS.contains(cmd.packageType())) {\n+                if (isOfType(cmd, WINDOWS)) {\n@@ -746,1 +837,1 @@\n-            if (TKit.isLinux() && Path.of(\"\/\").equals(appInstallDir)) {\n+            if (isOfType(cmd, LINUX) && Path.of(\"\/\").equals(appInstallDir)) {\n@@ -753,2 +844,1 @@\n-            if (LauncherAsServiceVerifier.SUPPORTED_PACKAGES.contains(\n-                    cmd.packageType())) {\n+            if (isOfType(cmd, LauncherAsServiceVerifier.SUPPORTED_PACKAGES)) {\n@@ -760,5 +850,0 @@\n-\n-        private final List<Consumer<JPackageCommand>> initializers;\n-        private final List<BiConsumer<JPackageCommand, Executor.Result>> bundleVerifiers;\n-        private final List<Consumer<JPackageCommand>> installVerifiers;\n-        private final List<Consumer<JPackageCommand>> uninstallVerifiers;\n@@ -767,5 +852,23 @@\n-    private static Map<PackageType, PackageHandlers> createDefaultPackageHandlers() {\n-        HashMap<PackageType, PackageHandlers> handlers = new HashMap<>();\n-        if (TKit.isLinux()) {\n-            handlers.put(LINUX_DEB, LinuxHelper.createDebPackageHandlers());\n-            handlers.put(LINUX_RPM, LinuxHelper.createRpmPackageHandlers());\n+    private PackageHandlers getDefaultPackageHandlers(PackageType type) {\n+        switch (type) {\n+            case LINUX_DEB -> {\n+                return LinuxHelper.createDebPackageHandlers();\n+            }\n+            case LINUX_RPM -> {\n+                return LinuxHelper.createRpmPackageHandlers();\n+            }\n+            case WIN_MSI -> {\n+                return WindowsHelper.createMsiPackageHandlers(createMsiLog);\n+            }\n+            case WIN_EXE -> {\n+                return WindowsHelper.createExePackageHandlers(createMsiLog);\n+            }\n+            case MAC_DMG -> {\n+                return MacHelper.createDmgPackageHandlers();\n+            }\n+            case MAC_PKG -> {\n+                return MacHelper.createPkgPackageHandlers();\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n@@ -773,0 +876,4 @@\n+    }\n+\n+    private PackageHandlers getPackageHandlers(PackageType type) {\n+        Objects.requireNonNull(type);\n@@ -774,3 +881,14 @@\n-        if (TKit.isWindows()) {\n-            handlers.put(WIN_MSI, WindowsHelper.createMsiPackageHandlers());\n-            handlers.put(WIN_EXE, WindowsHelper.createExePackageHandlers());\n+        var reply = Optional.ofNullable(packageHandlers.get(type)).orElseGet(() -> {\n+            if (TKit.isLinux() && !PackageType.LINUX.contains(type)) {\n+                throw new IllegalArgumentException();\n+            } else if (TKit.isWindows() && !PackageType.WINDOWS.contains(type)) {\n+                throw new IllegalArgumentException();\n+            } else if (TKit.isOSX() && !PackageType.MAC.contains(type)) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                return getDefaultPackageHandlers(type);\n+            }\n+        });\n+\n+        if (disabledInstallers.contains(type)) {\n+            reply = reply.copyWithNopInstaller();\n@@ -779,3 +897,2 @@\n-        if (TKit.isOSX()) {\n-            handlers.put(MAC_DMG,  MacHelper.createDmgPackageHandlers());\n-            handlers.put(MAC_PKG,  MacHelper.createPkgPackageHandlers());\n+        if (disabledUninstallers.contains(type)) {\n+            reply = reply.copyWithNopUninstaller();\n@@ -784,1 +901,9 @@\n-        return handlers;\n+        return reply;\n+    }\n+\n+    private static boolean isOfType(JPackageCommand cmd, PackageType packageTypes) {\n+        return isOfType(cmd, Set.of(packageTypes));\n+    }\n+\n+    private static boolean isOfType(JPackageCommand cmd, Set<PackageType> packageTypes) {\n+        return Optional.ofNullable(cmd.packageType()).map(packageTypes::contains).orElse(false);\n@@ -790,3 +915,8 @@\n-    private Map<PackageType, Handler> handlers;\n-    private Set<String> namedInitializers;\n-    private Map<PackageType, PackageHandlers> packageHandlers;\n+    private int expectedInstallExitCode;\n+    private final Map<PackageType, Handler> handlers;\n+    private final Set<String> namedInitializers;\n+    private final Map<PackageType, PackageHandlers> packageHandlers;\n+    private final Set<PackageType> disabledInstallers;\n+    private final Set<PackageType> disabledUninstallers;\n+    private Predicate<PackageType> isPackageTypeSupported;\n+    private Supplier<JPackageCommand> jpackageFactory;\n@@ -794,0 +924,1 @@\n+    private boolean createMsiLog;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":356,"deletions":225,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n@@ -29,1 +32,0 @@\n-import java.util.HashMap;\n@@ -32,0 +34,1 @@\n+import java.util.NoSuchElementException;\n@@ -35,1 +38,1 @@\n-import java.util.function.BiConsumer;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -40,1 +43,0 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n@@ -42,1 +44,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -70,1 +71,1 @@\n-    private static void runMsiexecWithRetries(Executor misexec) {\n+    private static int runMsiexecWithRetries(Executor misexec, Optional<Path> msiLog) {\n@@ -72,0 +73,2 @@\n+        final boolean isUnpack = misexec.getExecutable().orElseThrow().equals(Path.of(\"cmd\"));\n+        final List<String> origArgs = msiLog.isPresent() ? misexec.getAllArguments() : null;\n@@ -73,0 +76,1 @@\n+            msiLog.ifPresent(v -> misexec.clearArguments().addArguments(origArgs).addArgument(\"\/L*v\").addArgument(v));\n@@ -78,1 +82,1 @@\n-                return;\n+                return result.exitCode();\n@@ -84,1 +88,1 @@\n-            if ((result.exitCode() == 1618) || (result.exitCode() == 1603)) {\n+            if ((result.exitCode() == 1618) || (result.exitCode() == 1603 && isUnpack)) {\n@@ -94,1 +98,1 @@\n-        result.assertExitCodeIsZero();\n+        return result.exitCode();\n@@ -97,7 +101,4 @@\n-    static PackageHandlers createMsiPackageHandlers() {\n-        BiConsumer<JPackageCommand, Boolean> installMsi = (cmd, install) -> {\n-            cmd.verifyIsOfType(PackageType.WIN_MSI);\n-            var msiPath = TransientMsi.create(cmd).path();\n-            runMsiexecWithRetries(Executor.of(\"msiexec\", \"\/qn\", \"\/norestart\",\n-                    install ? \"\/i\" : \"\/x\").addArgument(msiPath));\n-        };\n+    static PackageHandlers createMsiPackageHandlers(boolean createMsiLog) {\n+        return new PackageHandlers(cmd -> installMsi(cmd, createMsiLog),\n+                cmd -> uninstallMsi(cmd, createMsiLog), WindowsHelper::unpackMsi);\n+    }\n@@ -105,53 +106,79 @@\n-        PackageHandlers msi = new PackageHandlers();\n-        msi.installHandler = cmd -> installMsi.accept(cmd, true);\n-        msi.uninstallHandler = cmd -> {\n-            if (Files.exists(cmd.outputBundle())) {\n-                installMsi.accept(cmd, false);\n-            }\n-        };\n-        msi.unpackHandler = (cmd, destinationDir) -> {\n-            cmd.verifyIsOfType(PackageType.WIN_MSI);\n-            final Path unpackBat = destinationDir.resolve(\"unpack.bat\");\n-            final Path unpackDir = destinationDir.resolve(\n-                    TKit.removeRootFromAbsolutePath(\n-                            getInstallationRootDirectory(cmd)));\n-\n-            final Path msiPath = TransientMsi.create(cmd).path();\n-\n-            \/\/ Put msiexec in .bat file because can't pass value of TARGETDIR\n-            \/\/ property containing spaces through ProcessBuilder properly.\n-            \/\/ Set folder permissions to allow msiexec unpack msi bundle.\n-            TKit.createTextFile(unpackBat, List.of(\n-                    String.format(\"icacls \\\"%s\\\" \/inheritance:e \/grant Users:M\",\n-                            destinationDir),\n-                    String.join(\" \", List.of(\n-                    \"msiexec\",\n-                    \"\/a\",\n-                    String.format(\"\\\"%s\\\"\", msiPath),\n-                    \"\/qn\",\n-                    String.format(\"TARGETDIR=\\\"%s\\\"\",\n-                            unpackDir.toAbsolutePath().normalize())))));\n-            runMsiexecWithRetries(Executor.of(\"cmd\", \"\/c\", unpackBat.toString()));\n-\n-            \/\/\n-            \/\/ WiX3 uses \".\" as the value of \"DefaultDir\" field for \"ProgramFiles64Folder\" folder in msi's Directory table\n-            \/\/ WiX4 uses \"PFiles64\" as the value of \"DefaultDir\" field for \"ProgramFiles64Folder\" folder in msi's Directory table\n-            \/\/ msiexec creates \"Program Files\/.\/<App Installation Directory>\" from WiX3 msi which translates to \"Program Files\/<App Installation Directory>\"\n-            \/\/ msiexec creates \"Program Files\/PFiles64\/<App Installation Directory>\" from WiX4 msi\n-            \/\/ So for WiX4 msi we need to transform \"Program Files\/PFiles64\/<App Installation Directory>\" into \"Program Files\/<App Installation Directory>\"\n-            \/\/\n-            \/\/ WiX4 does the same thing for %LocalAppData%.\n-            \/\/\n-            for (var extraPathComponent : List.of(\"PFiles64\", \"LocalApp\")) {\n-                if (Files.isDirectory(unpackDir.resolve(extraPathComponent))) {\n-                    Path installationSubDirectory = getInstallationSubDirectory(cmd);\n-                    Path from = Path.of(extraPathComponent).resolve(installationSubDirectory);\n-                    Path to = installationSubDirectory;\n-                    TKit.trace(String.format(\"Convert [%s] into [%s] in [%s] directory\", from, to,\n-                            unpackDir));\n-                    ThrowingRunnable.toRunnable(() -> {\n-                        Files.createDirectories(unpackDir.resolve(to).getParent());\n-                        Files.move(unpackDir.resolve(from), unpackDir.resolve(to));\n-                        TKit.deleteDirectoryRecursive(unpackDir.resolve(extraPathComponent));\n-                    }).run();\n-                }\n+    private static Optional<Path> configureMsiLogFile(JPackageCommand cmd, boolean createMsiLog) {\n+        final Optional<Path> msiLogFile;\n+        if (createMsiLog) {\n+            msiLogFile = Optional.of(TKit.createTempFile(String.format(\"logs\\\\%s-msi.log\",\n+                    cmd.packageType().getName())));\n+        } else {\n+            msiLogFile = Optional.empty();\n+        }\n+\n+        cmd.winMsiLogFile(msiLogFile.orElse(null));\n+\n+        return msiLogFile;\n+    }\n+\n+    private static int runMsiInstaller(JPackageCommand cmd, boolean createMsiLog, boolean install) {\n+        cmd.verifyIsOfType(PackageType.WIN_MSI);\n+        final var msiPath = TransientMsi.create(cmd).path();\n+        return runMsiexecWithRetries(Executor.of(\"msiexec\", \"\/qn\", \"\/norestart\",\n+                install ? \"\/i\" : \"\/x\").addArgument(msiPath), configureMsiLogFile(cmd, createMsiLog));\n+    }\n+\n+    private static int installMsi(JPackageCommand cmd, boolean createMsiLog) {\n+        return runMsiInstaller(cmd, createMsiLog, true);\n+    }\n+\n+    private static void uninstallMsi(JPackageCommand cmd, boolean createMsiLog) {\n+        if (Files.exists(cmd.outputBundle())) {\n+            runMsiInstaller(cmd, createMsiLog, false);\n+        } else {\n+            configureMsiLogFile(cmd, false);\n+        }\n+    }\n+\n+    private static Path unpackMsi(JPackageCommand cmd, Path destinationDir) {\n+        cmd.verifyIsOfType(PackageType.WIN_MSI);\n+        configureMsiLogFile(cmd, false);\n+        final Path unpackBat = destinationDir.resolve(\"unpack.bat\");\n+        final Path unpackDir = destinationDir.resolve(\n+                TKit.removeRootFromAbsolutePath(\n+                        getInstallationRootDirectory(cmd)));\n+\n+        final Path msiPath = TransientMsi.create(cmd).path();\n+\n+        \/\/ Put msiexec in .bat file because can't pass value of TARGETDIR\n+        \/\/ property containing spaces through ProcessBuilder properly.\n+        \/\/ Set folder permissions to allow msiexec unpack msi bundle.\n+        TKit.createTextFile(unpackBat, List.of(\n+                String.format(\"icacls \\\"%s\\\" \/inheritance:e \/grant Users:M\",\n+                        destinationDir),\n+                String.join(\" \", List.of(\n+                \"msiexec\",\n+                \"\/a\",\n+                String.format(\"\\\"%s\\\"\", msiPath),\n+                \"\/qn\",\n+                String.format(\"TARGETDIR=\\\"%s\\\"\",\n+                        unpackDir.toAbsolutePath().normalize())))));\n+        runMsiexecWithRetries(Executor.of(\"cmd\", \"\/c\", unpackBat.toString()), Optional.empty());\n+\n+        \/\/\n+        \/\/ WiX3 uses \".\" as the value of \"DefaultDir\" field for \"ProgramFiles64Folder\" folder in msi's Directory table\n+        \/\/ WiX4 uses \"PFiles64\" as the value of \"DefaultDir\" field for \"ProgramFiles64Folder\" folder in msi's Directory table\n+        \/\/ msiexec creates \"Program Files\/.\/<App Installation Directory>\" from WiX3 msi which translates to \"Program Files\/<App Installation Directory>\"\n+        \/\/ msiexec creates \"Program Files\/PFiles64\/<App Installation Directory>\" from WiX4 msi\n+        \/\/ So for WiX4 msi we need to transform \"Program Files\/PFiles64\/<App Installation Directory>\" into \"Program Files\/<App Installation Directory>\"\n+        \/\/\n+        \/\/ WiX4 does the same thing for %LocalAppData%.\n+        \/\/\n+        for (var extraPathComponent : List.of(\"PFiles64\", \"LocalApp\")) {\n+            if (Files.isDirectory(unpackDir.resolve(extraPathComponent))) {\n+                Path installationSubDirectory = getInstallationSubDirectory(cmd);\n+                Path from = Path.of(extraPathComponent).resolve(installationSubDirectory);\n+                Path to = installationSubDirectory;\n+                TKit.trace(String.format(\"Convert [%s] into [%s] in [%s] directory\", from, to,\n+                        unpackDir));\n+                ThrowingRunnable.toRunnable(() -> {\n+                    Files.createDirectories(unpackDir.resolve(to).getParent());\n+                    Files.move(unpackDir.resolve(from), unpackDir.resolve(to));\n+                    TKit.deleteDirectoryRecursive(unpackDir.resolve(extraPathComponent));\n+                }).run();\n@@ -159,3 +186,29 @@\n-            return destinationDir;\n-        };\n-        return msi;\n+        }\n+        return destinationDir;\n+    }\n+\n+    static PackageHandlers createExePackageHandlers(boolean createMsiLog) {\n+        return new PackageHandlers(cmd -> installExe(cmd, createMsiLog), WindowsHelper::uninstallExe, Optional.empty());\n+    }\n+\n+    private static int runExeInstaller(JPackageCommand cmd, boolean createMsiLog, boolean install) {\n+        cmd.verifyIsOfType(PackageType.WIN_EXE);\n+        Executor exec = new Executor().setExecutable(cmd.outputBundle());\n+        if (install) {\n+            exec.addArgument(\"\/qn\").addArgument(\"\/norestart\");\n+        } else {\n+            exec.addArgument(\"uninstall\");\n+        }\n+        return runMsiexecWithRetries(exec, configureMsiLogFile(cmd, createMsiLog));\n+    }\n+\n+    private static int installExe(JPackageCommand cmd, boolean createMsiLog) {\n+        return runExeInstaller(cmd, createMsiLog, true);\n+    }\n+\n+    private static void uninstallExe(JPackageCommand cmd) {\n+        if (Files.exists(cmd.outputBundle())) {\n+            runExeInstaller(cmd, false, false);\n+        } else {\n+            configureMsiLogFile(cmd, false);\n+        }\n@@ -207,22 +260,0 @@\n-    static PackageHandlers createExePackageHandlers() {\n-        BiConsumer<JPackageCommand, Boolean> installExe = (cmd, install) -> {\n-            cmd.verifyIsOfType(PackageType.WIN_EXE);\n-            Executor exec = new Executor().setExecutable(cmd.outputBundle());\n-            if (install) {\n-                exec.addArgument(\"\/qn\").addArgument(\"\/norestart\");\n-            } else {\n-                exec.addArgument(\"uninstall\");\n-            }\n-            runMsiexecWithRetries(exec);\n-        };\n-\n-        PackageHandlers exe = new PackageHandlers();\n-        exe.installHandler = cmd -> installExe.accept(cmd, true);\n-        exe.uninstallHandler = cmd -> {\n-            if (Files.exists(cmd.outputBundle())) {\n-                installExe.accept(cmd, false);\n-            }\n-        };\n-        return exe;\n-    }\n-\n@@ -418,2 +449,1 @@\n-            Path dir = Path.of(queryRegistryValueCache(\n-                    SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Desktop\"));\n+            Path dir = SpecialFolder.COMMON_DESKTOP.getPath();\n@@ -424,2 +454,1 @@\n-            Path dir = Path.of(\n-                    queryRegistryValueCache(USER_SHELL_FOLDERS_REGKEY, \"Desktop\"));\n+            Path dir = SpecialFolder.USER_DESKTOP.getPath();\n@@ -448,1 +477,6 @@\n-                TKit.assertDirectoryNotEmpty(shortcutPath.getParent());\n+                final var parentDir = shortcutPath.getParent();\n+                if (Files.isDirectory(parentDir)) {\n+                    TKit.assertDirectoryNotEmpty(parentDir);\n+                } else {\n+                    TKit.assertPathExists(parentDir, false);\n+                }\n@@ -453,2 +487,1 @@\n-            verifyStartMenuShortcut(Path.of(queryRegistryValueCache(\n-                    SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Programs\")), exists);\n+            verifyStartMenuShortcut(SpecialFolder.COMMON_START_MENU_PROGRAMS.getPath(), exists);\n@@ -459,2 +492,1 @@\n-            verifyStartMenuShortcut(Path.of(queryRegistryValueCache(\n-                    USER_SHELL_FOLDERS_REGKEY, \"Programs\")), exists);\n+            verifyStartMenuShortcut(SpecialFolder.USER_START_MENU_PROGRAMS.getPath(), exists);\n@@ -568,7 +600,24 @@\n-    private static String queryRegistryValueCache(String keyPath,\n-            String valueName) {\n-        String key = String.format(\"[%s][%s]\", keyPath, valueName);\n-        String value = REGISTRY_VALUES.get(key);\n-        if (value == null) {\n-            value = queryRegistryValue(keyPath, valueName);\n-            REGISTRY_VALUES.put(key, value);\n+    \/\/ See .NET special folders\n+    private enum SpecialFolderDotNet {\n+        Desktop,\n+        CommonDesktop,\n+\n+        Programs,\n+        CommonPrograms;\n+\n+        Path getPath() {\n+            final var str = Executor.of(\"powershell\", \"-NoLogo\", \"-NoProfile\",\n+                    \"-NonInteractive\", \"-Command\",\n+                    String.format(\"[Environment]::GetFolderPath('%s')\", name())\n+                    ).saveFirstLineOfOutput().execute().getFirstLineOfOutput();\n+\n+            TKit.trace(String.format(\"Value of .NET special folder '%s' is [%s]\", name(), str));\n+\n+            return Path.of(str);\n+        }\n+    }\n+\n+    private record RegValuePath(String keyPath, String valueName) {\n+        RegValuePath {\n+            Objects.requireNonNull(keyPath);\n+            Objects.requireNonNull(valueName);\n@@ -577,1 +626,34 @@\n-        return value;\n+        Optional<String> findValue() {\n+            return Optional.ofNullable(queryRegistryValue(keyPath, valueName));\n+        }\n+    }\n+\n+    private enum SpecialFolder {\n+        COMMON_START_MENU_PROGRAMS(SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Programs\", SpecialFolderDotNet.CommonPrograms),\n+        USER_START_MENU_PROGRAMS(USER_SHELL_FOLDERS_REGKEY, \"Programs\", SpecialFolderDotNet.Programs),\n+\n+        COMMON_DESKTOP(SYSTEM_SHELL_FOLDERS_REGKEY, \"Common Desktop\", SpecialFolderDotNet.CommonDesktop),\n+        USER_DESKTOP(USER_SHELL_FOLDERS_REGKEY, \"Desktop\", SpecialFolderDotNet.Desktop);\n+\n+        SpecialFolder(String keyPath, String valueName) {\n+            reg = new RegValuePath(keyPath, valueName);\n+            alt = Optional.empty();\n+        }\n+\n+        SpecialFolder(String keyPath, String valueName, SpecialFolderDotNet alt) {\n+            reg = new RegValuePath(keyPath, valueName);\n+            this.alt = Optional.of(alt);\n+        }\n+\n+        Path getPath() {\n+            return CACHE.computeIfAbsent(this, k -> reg.findValue().map(Path::of).orElseGet(() -> {\n+                return alt.map(SpecialFolderDotNet::getPath).orElseThrow(() -> {\n+                    return new NoSuchElementException(String.format(\"Failed to find path to %s folder\", name()));\n+                });\n+            }));\n+        }\n+\n+        private final RegValuePath reg;\n+        private final Optional<SpecialFolderDotNet> alt;\n+\n+        private final static Map<SpecialFolder, Path> CACHE = new ConcurrentHashMap<>();\n@@ -620,2 +702,0 @@\n-    private static final Map<String, String> REGISTRY_VALUES = new HashMap<>();\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":192,"deletions":112,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!--\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+-->\n+\n+<Wix xmlns=\"http:\/\/schemas.microsoft.com\/wix\/2006\/wi\">\n+  <Fragment>\n+    <Condition Message=\"Not supported on this version of Windows\">0<\/Condition>\n+    <ComponentGroup Id=\"FragmentOsCondition\"\/>\n+  <\/Fragment>\n+<\/Wix>\n","filename":"test\/jdk\/tools\/jpackage\/resources\/fail-os-condition.wxf","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary jpackage test that installer blocks on Windows of older version\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror WinOSConditionTest.java\n+ * @requires (os.family == \"windows\")\n+ * @requires (jpackage.test.SQETest == null)\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=WinOSConditionTest\n+ *\/\n+public class WinOSConditionTest {\n+\n+    @Test\n+    public static void test() throws IOException {\n+        \/\/ Use custom always failing condition. Installation is expected to fail.\n+        \/\/ This way the test covers:\n+        \/\/  1. If jpackage picks custom OS version condition from the resource directory;\n+        \/\/  2. If the installer created by jpackage uses OS version condition.\n+        new PackageTest().ignoreBundleOutputDir()\n+        .forTypes(PackageType.WINDOWS)\n+        .configureHelloApp()\n+        .addInitializer(JPackageCommand::setFakeRuntime)\n+        .addInitializer(cmd -> {\n+            final var resourceDir = TKit.createTempDirectory(\"resource-dir\");\n+            Files.copy(TKit.TEST_SRC_ROOT.resolve(\"resources\/fail-os-condition.wxf\"), resourceDir.resolve(\"os-condition.wxf\"));\n+            \/\/ Create a per-user installer to let user without admin privileges install it.\n+            cmd.addArguments(\"--win-per-user-install\",\n+                    \"--resource-dir\", resourceDir.toString()).setFakeRuntime();\n+        })\n+        .addUninstallVerifier(cmd -> {\n+            \/\/ MSI error code 1603 is generic.\n+            \/\/ Dig into the last msi log file for log messages specific to failed condition.\n+            try (final var lines = cmd.winMsiLogFileContents().orElseThrow()) {\n+                TKit.assertTextStream(\"Doing action: LaunchConditions\").predicate(String::endsWith)\n+                    .andThen(TKit.assertTextStream(\"Not supported on this version of Windows\").predicate(String::endsWith)).apply(lines);\n+            }\n+        })\n+        .createMsiLog(true)\n+        .setExpectedInstallExitCode(1603)\n+        \/\/ Create, try install the package (installation should fail) and verify it is not installed.\n+        .run(Action.CREATE, Action.INSTALL, Action.VERIFY_UNINSTALL);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinOSConditionTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}