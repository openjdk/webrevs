{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng InterruptibleOrNot\n+ * @run junit InterruptibleOrNot\n@@ -43,4 +43,1 @@\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n+import java.util.Arrays;\n@@ -49,2 +46,4 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.function.Executable;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -52,1 +51,0 @@\n-@Test\n@@ -54,0 +52,2 @@\n+    \/\/ DatagramChannel implementation class\n+    private static String dcImplClassName;\n@@ -55,18 +55,5 @@\n-    public void testInterruptBeforeInterruptibleReceive() throws Exception {\n-        testInterruptBeforeReceive(true);\n-    }\n-\n-    public void testInterruptDuringInterruptibleReceive() throws Exception {\n-        testInterruptDuringReceive(true);\n-    }\n-\n-    public void testInterruptBeforeUninterruptibleReceive() throws Exception {\n-        testInterruptBeforeReceive(false);\n-    }\n-\n-    public void testInterruptDuringUninterruptibleReceive() throws Exception {\n-        testInterruptDuringReceive(false);\n-    }\n-\n-    public void testInterruptBeforeInterruptibleSend() throws Exception {\n-        testInterruptBeforeSend(true);\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            dcImplClassName = dc.getClass().getName();\n+        }\n@@ -75,2 +62,14 @@\n-    public void testInterruptBeforeUninterruptibleSend() throws Exception {\n-        testInterruptBeforeSend(false);\n+    \/**\n+     * Call DatagramChannel.receive with the interrupt status set, the DatagramChannel\n+     * is interruptible.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeInterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            Thread.currentThread().interrupt();\n+            assertThrows(ClosedByInterruptException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt status\n+        }\n@@ -80,1 +79,2 @@\n-     * Test invoking DatagramChannel receive with interrupt status set\n+     * Test interrupting a thread blocked in DatagramChannel.receive, the DatagramChannel\n+     * is interruptible.\n@@ -82,13 +82,8 @@\n-    static void testInterruptBeforeReceive(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timeout = scheduleClose(dc, Duration.ofSeconds(2));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                Thread.currentThread().interrupt();\n-                assertThrows(expectedException(interruptible), () -> dc.receive(buf));\n-            } finally {\n-                timeout.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptDuringInterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            Thread thread = Thread.currentThread();\n+            onReceive(thread::interrupt);\n+            assertThrows(ClosedByInterruptException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -96,1 +91,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -101,1 +96,2 @@\n-     * Test Thread.interrupt when target thread is blocked in DatagramChannel receive\n+     * Call DatagramChannel.receive with the interrupt status set, the DatagramChannel\n+     * is not interruptible.\n@@ -103,14 +99,12 @@\n-    static void testInterruptDuringReceive(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timerTask = scheduleClose(dc, Duration.ofSeconds(5));\n-            Future<?> interruptTask = scheduleInterrupt(Thread.currentThread(), Duration.ofSeconds(1));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                assertThrows(expectedException(interruptible), () -> dc.receive(buf));\n-            } finally {\n-                timerTask.cancel(false);\n-                interruptTask.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptBeforeUninterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(false)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            onReceive(() -> {\n+                \/\/ close the channel after a delay to ensure receive wakes up\n+                Thread.sleep(1000);\n+                dc.close();\n+            });\n+            Thread.currentThread().interrupt();\n+            assertThrows(AsynchronousCloseException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -118,1 +112,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -123,1 +117,2 @@\n-     * Test invoking DatagramChannel send with interrupt status set\n+     * Test interrupting a thread blocked in DatagramChannel.receive, the DatagramChannel\n+     * is not interruptible.\n@@ -125,19 +120,16 @@\n-    static void testInterruptBeforeSend(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timeout = scheduleClose(dc, Duration.ofSeconds(2));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                SocketAddress target = dc.getLocalAddress();\n-                Thread.currentThread().interrupt();\n-                if (interruptible) {\n-                    assertThrows(ClosedByInterruptException.class, () -> dc.send(buf, target));\n-                } else {\n-                    int n = dc.send(buf, target);\n-                    assertTrue(n == 100);\n-                }\n-            } finally {\n-                timeout.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptDuringUninterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+\n+            Thread thread = Thread.currentThread();\n+            onReceive(() -> {\n+                \/\/ interrupt should not cause the receive to wakeup\n+                thread.interrupt();\n+\n+                \/\/ close the channel after a delay to ensure receive wakes up\n+                Thread.sleep(1000);\n+                dc.close();\n+            });\n+            assertThrows(AsynchronousCloseException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -145,1 +137,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -150,1 +142,2 @@\n-     * Creates a DatagramChannel that is interruptible or not.\n+     * Call DatagramChannel.send with the interrupt status set, the DatagramChannel\n+     * is interruptible.\n@@ -152,5 +145,10 @@\n-    static DatagramChannel openDatagramChannel(boolean interruptible) throws IOException {\n-        if (interruptible) {\n-            return DatagramChannel.open();\n-        } else {\n-            return DefaultSelectorProvider.get().openUninterruptibleDatagramChannel();\n+    @Test\n+    public void testInterruptBeforeInterruptibleSend() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            SocketAddress target = dc.getLocalAddress();\n+            Thread.currentThread().interrupt();\n+            assertThrows(ClosedByInterruptException.class, () -> dc.send(buf, target));\n+            assertFalse(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt\n@@ -161,1 +159,2 @@\n-     * Expect ClosedByInterruptException if interruptible.\n+     * Call DatagramChannel.send with the interrupt status set, the DatagramChannel\n+     * is not interruptible.\n@@ -163,5 +162,11 @@\n-    static Class<? extends Exception> expectedException(boolean expectInterrupt) {\n-        if (expectInterrupt) {\n-            return ClosedByInterruptException.class;\n-        } else {\n-            return AsynchronousCloseException.class;\n+    @Test\n+    public void testInterruptBeforeUninterruptibleSend() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(false)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            SocketAddress target = dc.getLocalAddress();\n+            Thread.currentThread().interrupt();\n+            int n = dc.send(buf, target);\n+            assertEquals(100, n);\n+            assertTrue(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -172,1 +177,2 @@\n-     * Schedule the given object to be closed.\n+     * Creates a DatagramChannel that is interruptible or not, and bound to the loopback\n+     * address.\n@@ -174,6 +180,14 @@\n-    static Future<?> scheduleClose(Closeable c, Duration timeout) {\n-        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n-        return STPE.schedule(() -> {\n-            c.close();\n-            return null;\n-        }, nanos, TimeUnit.NANOSECONDS);\n+    static DatagramChannel boundDatagramChannel(boolean interruptible) throws IOException {\n+        DatagramChannel dc;\n+        if (interruptible) {\n+            dc = DatagramChannel.open();\n+        } else {\n+            dc = DefaultSelectorProvider.get().openUninterruptibleDatagramChannel();\n+        }\n+        try {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        } catch (IOException ioe) {\n+            dc.close();\n+            throw ioe;\n+        }\n+        return dc;\n@@ -183,1 +197,1 @@\n-     * Schedule the given thread to be interrupted.\n+     * Runs the given action when the current thread is sampled in DatagramChannel.receive.\n@@ -185,3 +199,17 @@\n-    static Future<?> scheduleInterrupt(Thread t, Duration timeout) {\n-        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n-        return STPE.schedule(t::interrupt, nanos, TimeUnit.NANOSECONDS);\n+    static void onReceive(Executable action) {\n+        Thread target = Thread.currentThread();\n+        Thread.ofPlatform().daemon().start(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.sleep(20);\n+                    StackTraceElement[] stack = target.getStackTrace();\n+                    found = Arrays.stream(stack)\n+                            .anyMatch(e -> dcImplClassName.equals(e.getClassName())\n+                                    && \"receive\".equals(e.getMethodName()));\n+                }\n+                action.execute();\n+            } catch (Throwable ex) {\n+                ex.printStackTrace();\n+            }\n+        });\n@@ -189,2 +217,0 @@\n-\n-    static final ScheduledExecutorService STPE = Executors.newScheduledThreadPool(0);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/InterruptibleOrNot.java","additions":132,"deletions":106,"binary":false,"changes":238,"status":"modified"}]}