{"files":[{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -33,258 +32,1 @@\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n-\/\/ sub-classes). It knows how to filter out objects that are outside of the\n-\/\/ _boundary.\n-\/\/ (Note that because of the imprecise nature of the write barrier, this may\n-\/\/ iterate over oops beyond the region.)\n-\/\/\n-\/\/ Assumptions:\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-\n-class DirtyCardToOopClosure: public MemRegionClosure {\n-protected:\n-  OopIterateClosure* _cl;\n-  TenuredSpace* _sp;\n-  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n-                                \/\/ imprecise write barrier; this is the\n-                                \/\/ lowest location already done (or,\n-                                \/\/ alternatively, the lowest address that\n-                                \/\/ shouldn't be done again.  null means infinity.)\n-  NOT_PRODUCT(HeapWord* _last_bottom;)\n-\n-  \/\/ Get the actual top of the area on which the closure will\n-  \/\/ operate, given where the top is assumed to be (the end of the\n-  \/\/ memory region passed to do_MemRegion) and where the object\n-  \/\/ at the top is assumed to start. For example, an object may\n-  \/\/ start at the top but actually extend past the assumed top,\n-  \/\/ in which case the top becomes the end of the object.\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n-\n-  \/\/ Walk the given memory region from bottom to (actual) top\n-  \/\/ looking for objects and applying the oop closure (_cl) to\n-  \/\/ them. The base implementation of this treats the area as\n-  \/\/ blocks, where a block may or may not be an object. Sub-\n-  \/\/ classes should override this to provide more accurate\n-  \/\/ or possibly more efficient walking.\n-  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n-\n-  \/\/ Walk the given memory region, from bottom to top, applying\n-  \/\/ the given oop closure to (possibly) all objects found. The\n-  \/\/ given oop closure may or may not be the same as the oop\n-  \/\/ closure with which this closure was created, as it may\n-  \/\/ be a filtering closure which makes use of the _boundary.\n-  \/\/ We offer two signatures, so the FilteringClosure static type is\n-  \/\/ apparent.\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               OopIterateClosure* cl);\n-public:\n-  DirtyCardToOopClosure(TenuredSpace* sp, OopIterateClosure* cl) :\n-    _cl(cl), _sp(sp), _min_done(nullptr) {\n-    NOT_PRODUCT(_last_bottom = nullptr);\n-  }\n-\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n-HeapWord* DirtyCardToOopClosure::get_actual_top(HeapWord* top,\n-                                                HeapWord* top_obj) {\n-  if (top_obj != nullptr && top_obj < _sp->top()) {\n-    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-      \/\/ An arrayOop is starting on the dirty card - since we do exact\n-      \/\/ store checks for objArrays we are done.\n-    } else {\n-      \/\/ Otherwise, it is possible that the object starting on the dirty\n-      \/\/ card spans the entire card, and that the store happened on a\n-      \/\/ later card.  Figure out where the object ends.\n-      top = top_obj + cast_to_oop(top_obj)->size();\n-    }\n-  } else {\n-    top = _sp->top();\n-  }\n-  return top;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region(MemRegion mr,\n-                                            HeapWord* bottom,\n-                                            HeapWord* top) {\n-  \/\/ Note that this assumption won't hold if we have a concurrent\n-  \/\/ collector in this space, which may have freed up objects after\n-  \/\/ they were dirtied and before the stop-the-world GC that is\n-  \/\/ examining cards here.\n-  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n-\n-  walk_mem_region_with_cl(mr, bottom, top, _cl);\n-}\n-\n-\/\/ We get called with \"mr\" representing the dirty region\n-\/\/ that we want to process. Because of imprecise marking,\n-\/\/ we may need to extend the incoming \"mr\" to the right,\n-\/\/ and scan more. However, because we may already have\n-\/\/ scanned some of that extended region, we may need to\n-\/\/ trim its right-end back some so we do not scan what\n-\/\/ we (or another worker thread) may already have scanned\n-\/\/ or planning to scan.\n-void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {\n-  HeapWord* bottom = mr.start();\n-  HeapWord* last = mr.last();\n-  HeapWord* top = mr.end();\n-  HeapWord* bottom_obj;\n-  HeapWord* top_obj;\n-\n-  assert(_last_bottom == nullptr || top <= _last_bottom,\n-         \"Not decreasing\");\n-  NOT_PRODUCT(_last_bottom = mr.start());\n-\n-  bottom_obj = _sp->block_start(bottom);\n-  top_obj    = _sp->block_start(last);\n-\n-  assert(bottom_obj <= bottom, \"just checking\");\n-  assert(top_obj    <= top,    \"just checking\");\n-\n-  \/\/ Given what we think is the top of the memory region and\n-  \/\/ the start of the object at the top, get the actual\n-  \/\/ value of the top.\n-  top = get_actual_top(top, top_obj);\n-\n-  \/\/ If the previous call did some part of this region, don't redo.\n-  if (_min_done != nullptr && _min_done < top) {\n-    top = _min_done;\n-  }\n-\n-  \/\/ Top may have been reset, and in fact may be below bottom,\n-  \/\/ e.g. the dirty card region is entirely in a now free object\n-  \/\/ -- something that could happen with a concurrent sweeper.\n-  bottom = MIN2(bottom, top);\n-  MemRegion extended_mr = MemRegion(bottom, top);\n-  assert(bottom <= top &&\n-         (_min_done == nullptr || top <= _min_done),\n-         \"overlap!\");\n-\n-  \/\/ Walk the region if it is not empty; otherwise there is nothing to do.\n-  if (!extended_mr.is_empty()) {\n-    walk_mem_region(extended_mr, bottom_obj, top);\n-  }\n-\n-  _min_done = bottom;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n-                                                    HeapWord* bottom,\n-                                                    HeapWord* top,\n-                                                    OopIterateClosure* cl) {\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n-  if (bottom < top) {\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n-    while (next_obj < top) {\n-      \/* Bottom lies entirely below top, so we can call the *\/\n-      \/* non-memRegion version of oop_iterate below. *\/\n-      cast_to_oop(bottom)->oop_iterate(cl);\n-      bottom = next_obj;\n-      next_obj = bottom + cast_to_oop(bottom)->size();\n-    }\n-    \/* Last object. *\/\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);\n-  }\n-}\n-\n-class ClearNoncleanCardWrapper: public MemRegionClosure {\n-  DirtyCardToOopClosure* _dirty_card_closure;\n-  CardTableRS* _ct;\n-\n-public:\n-\n-  typedef CardTable::CardValue CardValue;\n-private:\n-  \/\/ Clears the given card, return true if the corresponding card should be\n-  \/\/ processed.\n-  inline bool clear_card(CardValue* entry);\n-  \/\/ check alignment of pointer\n-  bool is_word_aligned(CardValue* entry);\n-\n-public:\n-  ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct);\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n-inline bool ClearNoncleanCardWrapper::clear_card(CardValue* entry) {\n-  assert(*entry == CardTableRS::dirty_card_val(), \"Only look at dirty cards.\");\n-  *entry = CardTableRS::clean_card_val();\n-  return true;\n-}\n-\n-ClearNoncleanCardWrapper::ClearNoncleanCardWrapper(\n-  DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct) :\n-    _dirty_card_closure(dirty_card_closure), _ct(ct) {\n-}\n-\n-bool ClearNoncleanCardWrapper::is_word_aligned(CardTable::CardValue* entry) {\n-  return (((intptr_t)entry) & (BytesPerWord-1)) == 0;\n-}\n-\n-\/\/ The regions are visited in *decreasing* address order.\n-\/\/ This order aids with imprecise card marking, where a dirty\n-\/\/ card may cause scanning, and summarization marking, of objects\n-\/\/ that extend onto subsequent cards.\n-void ClearNoncleanCardWrapper::do_MemRegion(MemRegion mr) {\n-  assert(mr.word_size() > 0, \"Error\");\n-  assert(_ct->is_aligned(mr.start()), \"mr.start() should be card aligned\");\n-  \/\/ mr.end() may not necessarily be card aligned.\n-  CardValue* cur_entry = _ct->byte_for(mr.last());\n-  const CardValue* limit = _ct->byte_for(mr.start());\n-  HeapWord* end_of_non_clean = mr.end();\n-  HeapWord* start_of_non_clean = end_of_non_clean;\n-  while (cur_entry >= limit) {\n-    HeapWord* cur_hw = _ct->addr_for(cur_entry);\n-    if ((*cur_entry != CardTableRS::clean_card_val()) && clear_card(cur_entry)) {\n-      \/\/ Continue the dirty range by opening the\n-      \/\/ dirty window one card to the left.\n-      start_of_non_clean = cur_hw;\n-    } else {\n-      \/\/ We hit a \"clean\" card; process any non-empty\n-      \/\/ \"dirty\" range accumulated so far.\n-      if (start_of_non_clean < end_of_non_clean) {\n-        const MemRegion mrd(start_of_non_clean, end_of_non_clean);\n-        _dirty_card_closure->do_MemRegion(mrd);\n-      }\n-\n-      \/\/ fast forward through potential continuous whole-word range of clean cards beginning at a word-boundary\n-      if (is_word_aligned(cur_entry)) {\n-        CardValue* cur_row = cur_entry - BytesPerWord;\n-        while (cur_row >= limit && *((intptr_t*)cur_row) ==  CardTableRS::clean_card_row_val()) {\n-          cur_row -= BytesPerWord;\n-        }\n-        cur_entry = cur_row + BytesPerWord;\n-        cur_hw = _ct->addr_for(cur_entry);\n-      }\n-\n-      \/\/ Reset the dirty window, while continuing to look\n-      \/\/ for the next dirty card that will start a\n-      \/\/ new dirty window.\n-      end_of_non_clean = cur_hw;\n-      start_of_non_clean = cur_hw;\n-    }\n-    \/\/ Note that \"cur_entry\" leads \"start_of_non_clean\" in\n-    \/\/ its leftward excursion after this point\n-    \/\/ in the loop and, when we hit the left end of \"mr\",\n-    \/\/ will point off of the left end of the card-table\n-    \/\/ for \"mr\".\n-    cur_entry--;\n-  }\n-  \/\/ If the first card of \"mr\" was dirty, we will have\n-  \/\/ been left with a dirty window, co-initial with \"mr\",\n-  \/\/ which we now process.\n-  if (start_of_non_clean < end_of_non_clean) {\n-    const MemRegion mrd(start_of_non_clean, end_of_non_clean);\n-    _dirty_card_closure->do_MemRegion(mrd);\n-  }\n-}\n+#include \"utilities\/align.hpp\"\n@@ -297,1 +39,3 @@\n-  non_clean_card_iterate(sp, urasm, cl, this);\n+  if (!urasm.is_empty()) {\n+    non_clean_card_iterate(sp, urasm, cl, this);\n+  }\n@@ -604,0 +348,106 @@\n+\/\/ Implemented word-iteration to skip long consecutive clean cards.\n+CardTable::CardValue* CardTableRS::find_first_dirty_card(CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  using Word = uintptr_t;\n+\n+  static_assert(clean_card_val() == (CardValue)-1, \"inv\");\n+  constexpr Word clean_word = (Word)-1;\n+\n+  CardValue* i_card = start_card;\n+\n+  while (!is_aligned(i_card, sizeof(Word))) {\n+    if (i_card >= end_card) {\n+      return end_card;\n+    }\n+    if (is_dirty(i_card)) {\n+      return i_card;\n+    }\n+    ++i_card;\n+  }\n+\n+  \/\/ Word comparison\n+  while (i_card + sizeof(Word) <= end_card) {\n+    Word* i_word = reinterpret_cast<Word*>(i_card);\n+    if (*i_word != clean_word) {\n+      \/\/ Found a clean card in this word; fall back to per-CardValue comparison.\n+      break;\n+    }\n+    i_card += sizeof(Word);\n+  }\n+\n+  \/\/ Per-CardValue comparison.\n+  for (\/* empty *\/; i_card < end_card; ++i_card) {\n+    if (is_dirty(i_card)) {\n+      return i_card;\n+    }\n+  }\n+\n+  return end_card;\n+}\n+\n+\/\/ Because non-objArray objs can be imprecisely-marked (only obj-start card is\n+\/\/ dirty instead of the part containing old-to-young pointers), if the\n+\/\/ obj-start of a non-objArray is dirty, all cards that obj completely resides\n+\/\/ on are considered as dirty, since that obj will be iterated (scanned for\n+\/\/ old-to-young pointers) as a whole.\n+template<typename Func>\n+CardTable::CardValue* CardTableRS::find_first_clean_card(CardValue* const start_card,\n+                                                         CardValue* const end_card,\n+                                                         CardTableRS* ct,\n+                                                         Func&& object_start) {\n+  for (CardValue* i_card = start_card; i_card < end_card; \/* empty *\/) {\n+    if (is_dirty(i_card)) {\n+      i_card++;\n+      continue;\n+    }\n+\n+    \/\/ A potential candidate.\n+    HeapWord* addr = ct->addr_for(i_card);\n+    HeapWord* obj_start_addr = object_start(addr);\n+\n+    if (obj_start_addr == addr) {\n+      return i_card;\n+    }\n+\n+    \/\/ Final obj in dirty-chunk crosses card-boundary.\n+    oop obj = cast_to_oop(obj_start_addr);\n+    if (obj->is_objArray()) {\n+      \/\/ ObjArrays are always precisely-marked so we are not allowed to jump to\n+      \/\/ the end of the current object.\n+      return i_card;\n+    }\n+\n+    \/\/ Final card occupied by this obj.\n+    CardValue* final_card = ct->byte_for(obj_start_addr + obj->size() - 1);\n+    if (is_clean(final_card)) {\n+      return final_card;\n+    }\n+\n+    \/\/ Continue the search at the end of the current object...\n+    i_card = final_card + 1;\n+  }\n+\n+  return end_card;\n+}\n+\n+void CardTableRS::clear_cards(CardValue* start, CardValue* end) {\n+  size_t num_cards = pointer_delta(end, start, sizeof(CardValue));\n+  memset(start, clean_card_val(), num_cards);\n+}\n+\n+static void prefetch_write(void *p) {\n+  if (PrefetchScanIntervalInBytes >= 0) {\n+    Prefetch::write(p, PrefetchScanIntervalInBytes);\n+  }\n+}\n+\n+static void scan_obj_with_limit(oop obj,\n+                                OopIterateClosure* cl,\n+                                HeapWord* start,\n+                                HeapWord* end) {\n+  if (!obj->is_typeArray()) {\n+    prefetch_write(start);\n+    obj->oop_iterate(cl, MemRegion(start, end));\n+  }\n+}\n+\n@@ -607,6 +457,27 @@\n-                                         CardTableRS* ct)\n-{\n-  if (mr.is_empty()) {\n-    return;\n-  }\n-  \/\/ clear_cl finds contiguous dirty ranges of cards to process and clear.\n+                                         CardTableRS* ct) {\n+  struct {\n+    HeapWord* start_addr;\n+    HeapWord* end_addr;\n+  } cached_obj { nullptr, mr.start() };\n+\n+  auto object_start = [&] (const HeapWord* const addr) {\n+    if (addr < cached_obj.end_addr) {\n+      assert(cached_obj.start_addr != nullptr, \"inv\");\n+      return cached_obj.start_addr;\n+    }\n+    HeapWord* result = sp->block_start_const(addr);\n+\n+    cached_obj.start_addr = result;\n+    cached_obj.end_addr = result + cast_to_oop(result)->size();\n+\n+    return result;\n+  };\n+\n+  CardValue* const start_card = ct->byte_for(mr.start());\n+  CardValue* const end_card = ct->byte_for(mr.last()) + 1;\n+\n+  \/\/ if mr.end() is not card-aligned, that final card should not be cleared\n+  \/\/ because it can be annotated dirty due to old-to-young pointers in\n+  \/\/ newly-promoted objs on that card.\n+  CardValue* const clear_limit_card = is_card_aligned(mr.end()) ? end_card - 1\n+                                                                : end_card - 2;\n@@ -614,2 +485,2 @@\n-  DirtyCardToOopClosure dcto_cl{sp, cl};\n-  ClearNoncleanCardWrapper clear_cl(&dcto_cl, ct);\n+  for (CardValue* i_card = start_card; i_card < end_card; \/* empty *\/) {\n+    CardValue* const dirty_l = find_first_dirty_card(i_card, end_card);\n@@ -617,1 +488,42 @@\n-  clear_cl.do_MemRegion(mr);\n+    if (dirty_l == end_card) {\n+      \/\/ No dirty cards to iterate.\n+      break;\n+    }\n+\n+    HeapWord* const addr_l = ct->addr_for(dirty_l);\n+    HeapWord* obj_addr = object_start(addr_l);\n+\n+    CardValue* const dirty_r = find_first_clean_card(dirty_l + 1,\n+                                                     end_card,\n+                                                     ct,\n+                                                     object_start);\n+    assert(dirty_l < dirty_r, \"inv\");\n+    HeapWord* const addr_r = dirty_r == end_card ? mr.end()\n+                                                 : ct->addr_for(dirty_r);\n+\n+    clear_cards(MIN2(dirty_l, clear_limit_card),\n+                MIN2(dirty_r, clear_limit_card));\n+\n+    while (true) {\n+      assert(obj_addr < addr_r, \"inv\");\n+\n+      oop obj = cast_to_oop(obj_addr);\n+      const bool is_obj_array = obj->is_objArray();\n+      HeapWord* const obj_end_addr = obj_addr + obj->size();\n+\n+      if (is_obj_array) {\n+        \/\/ ObjArrays are always precise-marked.\n+        scan_obj_with_limit(obj, cl, addr_l, addr_r);\n+      } else {\n+        scan_obj_with_limit(obj, cl, addr_l, obj_end_addr);\n+      }\n+\n+      if (obj_end_addr >= addr_r) {\n+        i_card = dirty_r + 1;\n+        break;\n+      }\n+\n+      \/\/ Move to next obj inside this dirty chunk.\n+      obj_addr = obj_end_addr;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":181,"deletions":269,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class DirtyCardToOopClosure;\n@@ -44,1 +43,0 @@\n-  friend class ClearNoncleanCardWrapper;\n@@ -48,0 +46,18 @@\n+  static bool is_dirty(const CardValue* const v) {\n+    return !is_clean(v);\n+  }\n+\n+  static bool is_clean(const CardValue* const v) {\n+    return *v == clean_card_val();\n+  }\n+\n+  static void clear_cards(CardValue* start, CardValue* end);\n+\n+  static CardTable::CardValue* find_first_dirty_card(CardValue* const start_card,\n+                                              CardValue* const end_card);\n+  template<typename Func>\n+  CardTable::CardValue* find_first_clean_card(CardValue* const start_card,\n+                                              CardValue* const end_card,\n+                                              CardTableRS* ct,\n+                                              Func&& object_start);\n+\n@@ -60,4 +76,0 @@\n-  bool is_aligned(HeapWord* addr) {\n-    return is_card_aligned(addr);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -307,6 +307,2 @@\n-  guarantee(_rs->is_aligned(reserved_mr.start()), \"generation must be card aligned\");\n-  if (reserved_mr.end() != SerialHeap::heap()->reserved_region().end()) {\n-    \/\/ Don't check at the very end of the heap as we'll assert that we're probing off\n-    \/\/ the end if we try.\n-    guarantee(_rs->is_aligned(reserved_mr.end()), \"generation must be card aligned\");\n-  }\n+  guarantee(_rs->is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n+  guarantee(_rs->is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,2 +115,1 @@\n-    CardValue* pcard = byte_for(p);\n-    return (addr_for(pcard) == p);\n+    return is_aligned(p, card_size());\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}