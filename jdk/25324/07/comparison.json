{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.Buffer;\n@@ -913,1 +914,1 @@\n-                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ The use of addresses below need not be guarded as\n@@ -919,2 +920,2 @@\n-                long srcaddr = dsrc.address();\n-                long dstaddr = ddst.address();\n+                long srcaddr = NIO_ACCESS.getBufferAddress(src);\n+                long dstaddr = NIO_ACCESS.getBufferAddress(dst);\n@@ -925,1 +926,1 @@\n-                    srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                    srcaddr = NIO_ACCESS.getBufferAddress((Buffer) dsrc.attachment());\n@@ -932,1 +933,1 @@\n-                    dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                    dstaddr = NIO_ACCESS.getBufferAddress((Buffer) ddst.attachment());\n@@ -950,2 +951,2 @@\n-                if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n-                    ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                if (NIO_ACCESS.getBufferAddress(src) - srcaddr + src.position() >=\n+                    NIO_ACCESS.getBufferAddress(dst) - dstaddr + dst.position()) {\n@@ -1605,1 +1606,1 @@\n-                                ((DirectBuffer)dst).address(),\n+                                NIO_ACCESS.getBufferAddress(dst),\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-    private static void releaseScope(ByteBuffer bb) {\n+    static void releaseScope(ByteBuffer bb) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+        if (dst.isDirect()) {\n@@ -172,1 +172,1 @@\n-                long address = ddst.address() + pos;\n+                long address = NIO_ACCESS.getBufferAddress(dst) + pos;\n@@ -228,1 +228,1 @@\n-        if (src instanceof sun.nio.ch.DirectBuffer buf) {\n+        if (src.isDirect()) {\n@@ -231,1 +231,1 @@\n-                long address = buf.address() + pos;\n+                long address = NIO_ACCESS.getBufferAddress(src) + pos;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -447,1 +447,1 @@\n-            if (dst instanceof DirectBuffer) {\n+            if (dst.isDirect()) {\n@@ -449,1 +449,1 @@\n-                address = ((DirectBuffer)dst).address() + pos;\n+                address = IOUtil.bufferAddress(dst) + pos;\n@@ -451,0 +451,1 @@\n+                \/\/ buf can never be backed by a memory segment\n@@ -452,1 +453,1 @@\n-                address = ((DirectBuffer)buf).address();\n+                address = IOUtil.bufferAddress(buf);\n@@ -456,0 +457,1 @@\n+            IOUtil.acquireScope(buf, true);\n@@ -480,0 +482,1 @@\n+                IOUtil.releaseScope(buf);\n@@ -627,1 +630,1 @@\n-            if (src instanceof DirectBuffer) {\n+            if (src.isDirect()) {\n@@ -629,1 +632,1 @@\n-                address = ((DirectBuffer)src).address() + pos;\n+                address = IOUtil.bufferAddress(src) + pos;\n@@ -637,1 +640,1 @@\n-                address = ((DirectBuffer)buf).address();\n+                address = IOUtil.bufferAddress(buf);\n@@ -640,0 +643,1 @@\n+            IOUtil.acquireScope(buf, true);\n@@ -665,0 +669,1 @@\n+                IOUtil.releaseScope(buf);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousFileChannelImpl.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -746,2 +747,2 @@\n-                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n-                            inAddr = dInBuffer.address();\n+                        if (inBuffer instanceof DirectBuffer) {\n+                            inAddr = NIO_ACCESS.getBufferAddress(inBuffer);\n@@ -762,2 +763,2 @@\n-                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                        outAddr = dOutBuffer.address();\n+                    if (outBuffer instanceof DirectBuffer) {\n+                        outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -745,2 +746,2 @@\n-                if (inBuffer instanceof DirectBuffer dInBuffer) {\n-                    inAddr = dInBuffer.address();\n+                if (inBuffer instanceof DirectBuffer) {\n+                    inAddr = NIO_ACCESS.getBufferAddress(inBuffer);\n@@ -756,2 +757,2 @@\n-                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                    outAddr = dOutBuffer.address();\n+                if (outBuffer instanceof DirectBuffer) {\n+                    outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n@@ -1015,2 +1016,2 @@\n-                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                    outAddr = dOutBuffer.address();\n+                if (outBuffer instanceof DirectBuffer) {\n+                    outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-        if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+        if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -292,1 +292,2 @@\n-                token.p11.C_DigestUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+                final long address = NIO_ACCESS.getBufferAddress(byteBuffer);\n+                token.p11.C_DigestUpdate(session.id(), address + ofs, null, 0, len);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -580,2 +581,2 @@\n-                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n-                            inAddr = dInBuffer.address();\n+                        if (inBuffer instanceof DirectBuffer) {\n+                            inAddr = NIO_ACCESS.getBufferAddress(inBuffer);\n@@ -596,2 +597,2 @@\n-                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                        outAddr = dOutBuffer.address();\n+                    if (outBuffer instanceof DirectBuffer) {\n+                        outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+            if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -289,1 +289,2 @@\n-                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+                final long address = NIO_ACCESS.getBufferAddress(byteBuffer);\n+                token.p11.C_SignUpdate(session.id(), address + ofs, null, 0, len);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -617,1 +617,1 @@\n-                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+                if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -625,1 +625,1 @@\n-                    long addr = dByteBuffer.address();\n+                    long addr = NIO_ACCESS.getBufferAddress(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -582,1 +582,1 @@\n-                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+                if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -590,1 +590,1 @@\n-                    long addr = dByteBuffer.address();\n+                    long addr = NIO_ACCESS.getBufferAddress(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -832,1 +833,1 @@\n-            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+            int n = receive0(fd, resultContainer, NIO_ACCESS.getBufferAddress(bb) + pos, rem, peek);\n@@ -1015,1 +1016,1 @@\n-            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+            int written = send0(fd, NIO_ACCESS.getBufferAddress(bb) + pos, rem, addr,\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -564,1 +565,1 @@\n-            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            int n = receive0(fd, resultContainer, NIO_ACCESS.getBufferAddress(bb) + pos, rem);\n@@ -873,1 +874,1 @@\n-            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+            int written = send0(fd, NIO_ACCESS.getBufferAddress(bb) + pos, rem, addr,\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -61,0 +62,1 @@\n+    \/\/ Must be indeterministic\n@@ -566,9 +568,13 @@\n-        boolean useDirect = rand.nextBoolean();\n-        if (useDirect) {\n-            ByteBuffer bb = ByteBuffer.allocateDirect(buf.length);\n-            bb.put(buf);\n-            bb.flip();\n-            return bb;\n-        } else {\n-            return ByteBuffer.wrap(buf);\n-        }\n+        return switch (rand.nextInt(4)) {\n+            case 0 -> ByteBuffer.allocateDirect(buf.length)\n+                    .put(buf)\n+                    .flip();\n+            case 1 -> ByteBuffer.wrap(buf);\n+            case 2 -> Arena.ofAuto().allocate(buf.length).asByteBuffer()\n+                    .put(buf)\n+                    .flip();\n+            case 3 -> Arena.ofShared().allocate(buf.length).asByteBuffer()\n+                    .put(buf)\n+                    .flip();\n+            default -> throw new InternalError(\"Should not reach here\");\n+        };\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousFileChannel\/Basic.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -49,1 +50,2 @@\n-    private static Random rand = new Random();\n+    \/\/ Must be indeterministic\n+    private static final Random rand = new Random();\n@@ -91,2 +93,6 @@\n-        ByteBuffer buf = rand.nextBoolean() ?\n-            ByteBuffer.allocate(100) : ByteBuffer.allocateDirect(100);\n+        final ByteBuffer buf = switch (rand.nextInt(3)) {\n+            case 0 -> ByteBuffer.allocate(100);\n+            case 1 -> ByteBuffer.allocateDirect(100);\n+            case 2 -> Arena.ofAuto().allocate(100).asByteBuffer();\n+            default -> throw new InternalError(\"Should not reach here\");\n+        };\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/UserDefinedFileAttributeView\/Basic.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"}]}