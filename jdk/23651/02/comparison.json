{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.Serial;\n@@ -30,2 +31,11 @@\n-import java.security.*;\n-import java.security.interfaces.ECKey;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n@@ -33,1 +43,0 @@\n-import java.security.interfaces.XECKey;\n@@ -35,1 +44,10 @@\n-import java.security.spec.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPrivateKeySpec;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPrivateKeySpec;\n+import java.security.spec.XECPublicKeySpec;\n@@ -38,1 +56,7 @@\n-import javax.crypto.*;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -42,2 +66,6 @@\n-import sun.security.ssl.HKDF;\n-import sun.security.util.*;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.SliceableSecretKey;\n@@ -80,5 +108,5 @@\n-                byte[] dh = params.DH(skE, pkR);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new KEM.Encapsulated(\n-                        new SecretKeySpec(key, from, to - from, algorithm),\n-                        pkEm, null);\n+                SecretKey key = params.deriveKey(algorithm, from, to, kem_context,\n+                        params.DH(skE, pkR));\n+                return new KEM.Encapsulated(key, pkEm, null);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -101,1 +129,0 @@\n-                byte[] dh = params.DH(skR, pkE);\n@@ -104,2 +131,4 @@\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new SecretKeySpec(key, from, to - from, algorithm);\n+                return params.deriveKey(algorithm, from, to, kem_context,\n+                        params.DH(skR, pkE));\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -127,1 +156,2 @@\n-        static final long serialVersionUID = 0L;\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n@@ -136,1 +166,1 @@\n-        public KeyPair derive(Params params) {\n+        private KeyPair derive(Params params) {\n@@ -156,1 +186,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"HKDF-SHA256\"),\n@@ -159,1 +189,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"HKDF-SHA384\"),\n@@ -162,1 +192,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"HKDF-SHA512\"),\n@@ -165,1 +195,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"HKDF-SHA256\"),\n@@ -168,1 +198,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"HKDF-SHA512\"),\n@@ -240,1 +270,1 @@\n-        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+        private SecretKey DH(PrivateKey skE, PublicKey pkR)\n@@ -245,1 +275,1 @@\n-            return ka.generateSecret();\n+            return ka.generateSecret(\"Generic\");\n@@ -248,6 +278,39 @@\n-        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n-            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n-                    kem_context, Nsecret);\n+        \/\/ The final shared secret derivation of either the encapsulator\n+        \/\/ or the decapsulator. The key slicing is implemented inside.\n+        \/\/ Throws UOE if a slice of the key cannot be found.\n+        private SecretKey deriveKey(String alg, int from, int to,\n+                byte[] kem_context, SecretKey dh)\n+                throws NoSuchAlgorithmException {\n+            if (from == 0 && to == Nsecret) {\n+                return ExtractAndExpand(kem_context, alg, dh);\n+            } else {\n+                \/\/ First get shared secrets in \"Generic\" and then get a slice\n+                \/\/ of it in the requested algorithm.\n+                var fullKey = ExtractAndExpand(kem_context, \"Generic\", dh);\n+                if (\"RAW\".equalsIgnoreCase(fullKey.getFormat())) {\n+                    byte[] km = fullKey.getEncoded();\n+                    if (km == null) {\n+                        \/\/ Should not happen if format is \"RAW\"\n+                        throw new UnsupportedOperationException(\"Key extract failed\");\n+                    } else {\n+                        return new SecretKeySpec(km, from, to - from, alg);\n+                    }\n+                } else if (fullKey instanceof SliceableSecretKey ssk) {\n+                    return ssk.slice(alg, from, to);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Cannot extract key\");\n+                }\n+            }\n+        }\n+\n+        private SecretKey ExtractAndExpand(byte[] kem_context, String alg, SecretKey dh)\n+                throws NoSuchAlgorithmException {\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, EAE_PRK);\n+            builder.addIKM(dh);\n+            try {\n+                return kdf.deriveKey(alg,\n+                        labeledExpand(builder, suiteId, SHARED_SECRET, kem_context, Nsecret));\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw new ProviderException(e);\n+            }\n@@ -280,2 +343,2 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, DKP_PRK).addIKM(ikm);\n@@ -288,1 +351,2 @@\n-                        throw new RuntimeException();\n+                        \/\/ So unlucky and should not happen\n+                        throw new ProviderException(\"DeriveKeyPairError\");\n@@ -290,2 +354,2 @@\n-                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n-                            CANDIDATE, I2OSP(counter, 1), Nsk);\n+                    byte[] bytes = kdf.deriveData(labeledExpand(builder,\n+                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk));\n@@ -302,1 +366,2 @@\n-                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                byte[] sk = kdf.deriveData(labeledExpand(builder,\n+                        suiteId, SK, EMPTY, Nsk));\n@@ -347,3 +412,4 @@\n-    private Params paramsFromKey(Key k) throws InvalidKeyException {\n-        if (k instanceof ECKey eckey) {\n-            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+    private Params paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+        var p = k.getParams();\n+        if (p instanceof ECParameterSpec ecp) {\n+            if (ECUtil.equals(ecp, CurveDB.P_256)) {\n@@ -351,1 +417,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n@@ -353,1 +419,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n@@ -356,2 +422,1 @@\n-        } else if (k instanceof XECKey xkey\n-                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+        } else if (p instanceof NamedParameterSpec ns) {\n@@ -373,2 +438,5 @@\n-    private static byte[] I2OSP(int n, int w) {\n-        assert n < 256;\n+    \/\/ I2OSP(n, w) as defined in RFC 9180 Section 3.\n+    \/\/ In DHKEM and HPKE, number is always <65536\n+    \/\/ and converted to at most 2 bytes.\n+    public static byte[] I2OSP(int n, int w) {\n+        assert n < 65536;\n@@ -383,5 +451,20 @@\n-    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n-            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n-        return kdf.extract(salt,\n-                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n-                    \"HKDF-PRK\");\n+    \/\/ Create a LabeledExtract builder with labels.\n+    \/\/ You can add more IKM and salt into the result.\n+    public static HKDFParameterSpec.Builder labeledExtract(\n+            byte[] suiteId, byte[] label) {\n+        return HKDFParameterSpec.ofExtract()\n+                .addIKM(HPKE_V1).addIKM(suiteId).addIKM(label);\n+    }\n+\n+    \/\/ Create a labeled info from info and labels\n+    private static byte[] labeledInfo(\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return concat(I2OSP(L, 2), HPKE_V1, suiteId, label, info);\n+    }\n+\n+    \/\/ LabeledExpand from a builder\n+    public static HKDFParameterSpec labeledExpand(\n+            HKDFParameterSpec.Builder builder,\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return builder.thenExpand(\n+                labeledInfo(suiteId, label, info, L), L);\n@@ -390,6 +473,5 @@\n-    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n-            SecretKey prk, byte[] label, byte[] info, int L)\n-            throws InvalidKeyException {\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n-                suite_id, label, info);\n-        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+    \/\/ LabeledExpand from a prk\n+    public static HKDFParameterSpec labeledExpand(\n+            SecretKey prk, byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return HKDFParameterSpec.expandOnly(\n+                prk, labeledInfo(suiteId, label, info, L), L);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":139,"deletions":57,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-import sun.security.ec.point.AffinePoint;\n-import sun.security.ec.point.MutablePoint;\n@@ -210,7 +208,0 @@\n-        ECParameterSpec ecParams = getParams();\n-        ECOperations ops = ECOperations.forParameters(ecParams)\n-                .orElseThrow(ProviderException::new);\n-        MutablePoint pub = ops.multiply(ecParams.getGenerator(), getArrayS0());\n-        AffinePoint affPub = pub.asAffine();\n-        ECPoint w = new ECPoint(affPub.getX().asBigInteger(),\n-                affPub.getY().asBigInteger());\n@@ -218,1 +209,1 @@\n-            return new ECPublicKeyImpl(w, ecParams);\n+            return ECUtil.sArrayToPublicKey(getArrayS0(), getParams());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-     * ECKeyFactory.\n+     * ECKeyFactory and ECUtil.\n@@ -63,1 +63,1 @@\n-    ECPublicKeyImpl(ECPoint w, ECParameterSpec params)\n+    public ECPublicKeyImpl(ECPoint w, ECParameterSpec params)\n@@ -145,1 +145,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import sun.security.ec.ECOperations;\n+import sun.security.ec.ECPublicKeyImpl;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.ec.point.MutablePoint;\n@@ -378,0 +382,12 @@\n+    \/\/ Calculate an ECPublicKey from the private sArray component\n+    public static ECPublicKey sArrayToPublicKey(byte[] sArray, ECParameterSpec params)\n+            throws InvalidKeyException {\n+        ECOperations ops = ECOperations.forParameters(params)\n+                .orElseThrow(ProviderException::new);\n+        MutablePoint pub = ops.multiply(params.getGenerator(), sArray);\n+        AffinePoint affPub = pub.asAffine();\n+        ECPoint w = new ECPoint(affPub.getX().asBigInteger(),\n+                affPub.getY().asBigInteger());\n+        return new ECPublicKeyImpl(w, params);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ECUtil.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.util;\n+\n+import javax.crypto.SecretKey;\n+\n+\/**\n+ * An interface for <code>SecretKey<\/code>s that support using its slice as a new\n+ * <code>SecretKey<\/code>\n+ * <p>\n+ * This is mainly used by PKCS #11 implementations that support the\n+ * EXTRACT_KEY_FROM_KEY mechanism even if the key itself is sensitive\n+ * and non-extractable.\n+ *\/\n+public interface SliceableSecretKey {\n+\n+    \/**\n+     * Returns a slice as a new <code>SecretKey<\/code>.\n+     *\n+     * @param alg the new algorithm name\n+     * @param from the byte offset of the new key in the full key\n+     * @param to the to offset (exclusive) of the new key in the full key\n+     * @return the new key\n+     * @throws ArrayIndexOutOfBoundsException for improper <code>from<\/code>\n+     *      and <code>to<\/code> values\n+     * @throws UnsupportedOperationException if slicing is not supported\n+     *\/\n+    SecretKey slice(String alg, int from, int to);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,0 +270,6 @@\n+            PublicKey pk = null;\n+            try {\n+                pk = ECUtil.sArrayToPublicKey(ECUtil.sArray(s, params), params);\n+            } catch (Exception e) {\n+                \/\/ Happens when params is not supported. Ignore it.\n+            }\n@@ -271,1 +277,1 @@\n-                (session, keyID, \"EC\", params.getCurve().getField().getFieldSize(), attributes);\n+                    (session, keyID, \"EC\", params.getCurve().getField().getFieldSize(), attributes, pk);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11ECKeyFactory.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import sun.security.util.InternalPrivateKey;\n@@ -55,0 +56,1 @@\n+import sun.security.util.SliceableSecretKey;\n@@ -402,0 +404,7 @@\n+        return privateKey(session, keyID, algorithm, keyLength, attrs, null);\n+    }\n+\n+    \/\/ Create a PrivateKey with an optional PublicKey. The PublicKey is only\n+    \/\/ added to EC keys at the moment.\n+    static PrivateKey privateKey(Session session, long keyID, String algorithm,\n+            int keyLength, CK_ATTRIBUTE[] attrs, PublicKey pk) {\n@@ -420,1 +429,1 @@\n-                    keyLength, attrs, keySensitive);\n+                    keyLength, attrs, keySensitive, pk);\n@@ -449,1 +458,1 @@\n-    static class P11SecretKey extends P11Key implements SecretKey {\n+    static class P11SecretKey extends P11Key implements SecretKey, SliceableSecretKey {\n@@ -489,0 +498,36 @@\n+\n+        @Override\n+        public P11SecretKey slice(String alg, int from, int to) {\n+            Objects.checkFromToIndex(from, to, length() \/ 8);\n+            try {\n+                CK_MECHANISM mechanism = new CK_MECHANISM(CKM_EXTRACT_KEY_FROM_KEY,\n+                        new CK_KEY_EXTRACT_FROM_KEY(from * 8));\n+\n+                P11SecretKeyFactory.KeyInfo ki = P11SecretKeyFactory.getKeyInfo(alg);\n+                if (ki == null) {\n+                    throw new UnsupportedOperationException(\"A PKCS #11 key \" +\n+                            \"type (CKK_*) was not found for a key of the algorithm '\" +\n+                            alg + \"'.\");\n+                }\n+                CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n+                        new CK_ATTRIBUTE(CKA_VALUE_LEN, to - from),\n+                };\n+\n+                var session = token.getOpSession();\n+                attrs = token.getAttributes(O_GENERATE, CKO_SECRET_KEY,\n+                        ki.keyType, attrs);\n+                long newKeyHandle = token.p11.C_DeriveKey(\n+                        session.id(),\n+                        mechanism,\n+                        getKeyID(),\n+                        attrs\n+                );\n+\n+                return (P11Key.P11SecretKey) P11Key.secretKey(session,\n+                        newKeyHandle, alg, (to - from) * 8, null);\n+            } catch (PKCS11Exception e) {\n+                throw new UnsupportedOperationException(e);\n+            }\n+        }\n@@ -1204,1 +1249,2 @@\n-    static class P11ECPrivateKeyInternal extends P11PrivateKey {\n+    static class P11ECPrivateKeyInternal extends P11PrivateKey\n+            implements ECKey, InternalPrivateKey {\n@@ -1209,0 +1255,1 @@\n+        private final PublicKey pk;\n@@ -1213,1 +1260,1 @@\n-                boolean keySensitive) {\n+                boolean keySensitive, PublicKey pk) {\n@@ -1216,1 +1263,1 @@\n-                        keyLength, attrs);\n+                        keyLength, attrs, pk);\n@@ -1219,1 +1266,1 @@\n-                        keyLength, attrs);\n+                        keyLength, attrs, pk);\n@@ -1224,1 +1271,1 @@\n-                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs, PublicKey pk) {\n@@ -1226,0 +1273,1 @@\n+            this.pk = pk;\n@@ -1248,0 +1296,5 @@\n+\n+        @Override\n+        public PublicKey calculatePublicKey() {\n+            return pk;\n+        }\n@@ -1258,2 +1311,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attrs) {\n-            super(session, keyID, algorithm, keyLength, attrs);\n+                int keyLength, CK_ATTRIBUTE[] attrs, PublicKey pk) {\n+            super(session, keyID, algorithm, keyLength, attrs, pk);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":62,"deletions":9,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,1 +430,1 @@\n-                (session, keyIDs[1], algorithm, keySize, privateKeyTemplate);\n+                (session, keyIDs[1], algorithm, keySize, privateKeyTemplate, publicKey);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyPairGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,1 +316,1 @@\n-                    return loadPkey(session, h.handle);\n+                    return loadPkey(session, h.handle, aliasInfo.cert.getPublicKey());\n@@ -971,1 +971,0 @@\n-                    PrivateKey pkey = loadPkey(session, h.handle);\n@@ -973,0 +972,1 @@\n+                    PrivateKey pkey = loadPkey(session, h.handle, chain[0].getPublicKey());\n@@ -1308,1 +1308,1 @@\n-    private PrivateKey loadPkey(Session session, long oHandle)\n+    private PrivateKey loadPkey(Session session, long oHandle, PublicKey pk)\n@@ -1388,1 +1388,1 @@\n-            return P11Key.privateKey(session, oHandle, \"EC\", keyLength, null);\n+            return P11Key.privateKey(session, oHandle, \"EC\", keyLength, null, pk);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyStore.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -798,0 +798,1 @@\n+                    \/\/ in this case, there is no way to get the associated public key\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,9 @@\n+package sun.security.pkcs11.wrapper;\n+\n+public class CK_KEY_EXTRACT_FROM_KEY {\n+    private final int fromBit;\n+\n+    public CK_KEY_EXTRACT_FROM_KEY(int fromBit) {\n+        this.fromBit = fromBit;\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_KEY_EXTRACT_FROM_KEY.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -138,0 +138,4 @@\n+    public CK_MECHANISM(long mechanism, CK_KEY_EXTRACT_FROM_KEY params) {\n+        init(mechanism, params);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -878,0 +878,34 @@\n+CK_EXTRACT_PARAMS_PTR\n+jKeyExtractKeyFromKeyToExtractKeyFromKeyPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)\n+{\n+    CK_EXTRACT_PARAMS_PTR ckParamPtr = NULL;\n+    jclass jKeyDerivationStringDataClass;\n+    jfieldID fieldID;\n+    jint jpData;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0L;\n+    }\n+\n+    jKeyDerivationStringDataClass = (*env)->FindClass(env, CLASS_KEY_EXTRACT_FROM_KEY);\n+    if (jKeyDerivationStringDataClass == NULL) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jKeyDerivationStringDataClass, \"fromBit\", \"I\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jpData = (*env)->GetIntField(env, jParam, fieldID);\n+    ckParamPtr = calloc(1, sizeof(CK_EXTRACT_PARAMS));\n+    if (ckParamPtr == NULL) {\n+        p11ThrowOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+    *ckParamPtr = jpData;\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_EXTRACT_PARAMS);\n+    }\n+    return ckParamPtr;\n+}\n+\n@@ -1652,0 +1686,4 @@\n+            break;\n+        case CKM_EXTRACT_KEY_FROM_KEY:\n+            ckpParamPtr = jKeyExtractKeyFromKeyToExtractKeyFromKeyPtr(env, jParam,\n+                    ckpLength);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -419,0 +419,1 @@\n+                 case CKM_EXTRACT_KEY_FROM_KEY:\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,1 +223,0 @@\n-\n@@ -303,0 +302,1 @@\n+#define CLASS_KEY_EXTRACT_FROM_KEY \"sun\/security\/pkcs11\/wrapper\/CK_KEY_EXTRACT_FROM_KEY\"\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.test.lib.Utils;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -46,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -69,6 +66,4 @@\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(null, new byte[0], null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(null, new byte[0], null));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null));\n@@ -89,16 +84,11 @@\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"OLALA\"),\n-                NoSuchAlgorithmException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n-                NoSuchProviderException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n-                NoSuchAlgorithmException.class);\n-\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(null),\n-                InvalidKeyException.class);\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(null),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"OLALA\"));\n+        Asserts.assertThrows(NoSuchProviderException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"));\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"));\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newEncapsulator(null));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(null));\n@@ -107,3 +97,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(badECKey()),\n-                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(badECKey())),\n+                DHKEM.class.getName());\n@@ -113,3 +104,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(kpRSA.getPublic()),\n-                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(kpRSA.getPublic())),\n+                KEM.class.getName() + \"$DelayedKEM\");\n@@ -117,3 +109,2 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()));\n@@ -128,9 +119,6 @@\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(-1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(-1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> e2.encapsulate(0, e2.secretSize(), null));\n@@ -165,12 +153,8 @@\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(null));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null));\n@@ -181,3 +165,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(enc2.encapsulation()),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(enc2.encapsulation()));\n@@ -185,3 +168,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(new byte[100]),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(new byte[100]));\n@@ -276,29 +258,3 @@\n-    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n-    record ExChecker(Class<? extends Throwable> ex, String caller)\n-            implements Consumer<Throwable> {\n-        ExChecker {\n-            Objects.requireNonNull(ex);\n-        }\n-        static ExChecker of(Class<? extends Throwable> ex) {\n-            return new ExChecker(ex, null);\n-        }\n-        ExChecker by(String caller) {\n-            return new ExChecker(ex(), caller);\n-        }\n-        ExChecker by(Class<?> caller) {\n-            return new ExChecker(ex(), caller.getName());\n-        }\n-        @Override\n-        public void accept(Throwable t) {\n-            if (t == null) {\n-                throw new AssertionError(\"no exception thrown\");\n-            } else if (!ex.isAssignableFrom(t.getClass())) {\n-                throw new AssertionError(\"exception thrown is \" + t.getClass());\n-            } else if (caller == null) {\n-                return;\n-            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n-                return;\n-            } else {\n-                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n-            }\n-        }\n+    \/\/ Ensures `t` is thrown by `caller`\n+    static <T extends Throwable> void checkThrownBy(T t, String caller) {\n+        Asserts.assertEquals(caller, t.getStackTrace()[0].getClassName());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4938185\n+ * @bug 4938185 8350134\n@@ -36,0 +36,4 @@\n+ * @modules jdk.crypto.cryptoki\n+ *          java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.util\n+ *          java.base\/sun.security.x509\n@@ -65,0 +69,3 @@\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.x509.X500Name;\n@@ -242,0 +249,1 @@\n+                testnum = Basic.calculatePublicKey(testnum);\n@@ -916,0 +924,22 @@\n+    private static int calculatePublicKey(int testnum) throws Exception {\n+        System.out.println(\"check calculatePublicKey in keystore\");\n+        var kag = new CertAndKeyGen(\"EC\", \"SHA256withECDSA\");\n+        kag.generate(-1);\n+\n+        ks.setKeyEntry(\"a2\", kag.getPrivateKey(), null,\n+                new Certificate[] {kag.getSelfCertificate(new X500Name(\"CN=Me\"), 1000)});\n+        var sk = ks.getKey(\"a2\", null);\n+        if (sk instanceof InternalPrivateKey ipk) {\n+            var pk = ipk.calculatePublicKey();\n+            var cert = ks.getCertificate(\"a2\");\n+            if (!cert.getPublicKey().equals(pk)) {\n+                throw new SecurityException(\"Associated public key is not correct\");\n+            }\n+        } else {\n+            throw new SecurityException(\"Not an InternalPrivateKey\");\n+        }\n+        System.out.println(\"test \" + testnum++ + \" passed\");\n+\n+        return testnum;\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/Basic.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ *          java.base\/sun.security.util\n+ * @run main\/othervm TestSlice p11-nss-sensitive.txt\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.util.SliceableSecretKey;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.util.Arrays;\n+\n+public class TestSlice extends PKCS11Test {\n+    public static void main(String[] args) throws Exception {\n+        main(new TestSlice(args[0]), args);\n+    }\n+\n+    public TestSlice(String conf) throws IOException {\n+        copyNssCertKeyToClassesDir();\n+        setCommonSystemProps();\n+        System.setProperty(\"CUSTOM_P11_CONFIG\",\n+                Path.of(System.getProperty(\"test.src\", \".\"), \"..\/nss\/\" + conf).toString());\n+        System.setProperty(\"TOKEN\", \"nss\");\n+        System.setProperty(\"TEST\", \"basic\");\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        var data = new byte[48];\n+        for (var i = 0; i < 48; i++) data[i] = (byte)i;\n+        var sk = new SecretKeySpec(data, \"Generic\");\n+        var hk = SecretKeyFactory.getInstance(\"Generic\", p).translateKey(sk);\n+        if (hk instanceof SliceableSecretKey ssk) {\n+            var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < 16; i++) {\n+                var slice = ssk.slice(\"HmacSHA256\", i, i + 32);\n+                System.out.println(slice);\n+                var enc = slice.getEncoded();\n+                var expected = Arrays.copyOfRange(data, i, i + 32);\n+                if (enc != null) {\n+                    \/\/ If extractable, just compare key material\n+                    Asserts.assertEqualsByteArray(expected, enc);\n+                } else {\n+                    \/\/ Otherwise, see if they are equivalent as Hmac key\n+                    var h1 = Mac.getInstance(\"HmacSHA256\");\n+                    h1.init(new SecretKeySpec(expected, \"HmacSHA256\"));\n+                    h1.update(msg);\n+                    var m1 = h1.doFinal();\n+                    var h2 = Mac.getInstance(\"HmacSHA256\", p);\n+                    h2.init(slice);\n+                    h2.update(msg);\n+                    var m2 = h2.doFinal();\n+                    Asserts.assertEqualsByteArray(m1, m2);\n+                }\n+            }\n+        } else {\n+            throw new Exception(\"This should be a SliceableSecretKey\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestSlice.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350134\n+ * @summary Verify that pkcs11 EC keys has public key associated\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ *          java.base\/sun.security.util\n+ * @run main\/othervm CalculatePublicKey p11-nss.txt\n+ * @run main\/othervm CalculatePublicKey p11-nss-sensitive.txt\n+ *\/\n+\n+import sun.security.util.InternalPrivateKey;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+\n+public class CalculatePublicKey extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new CalculatePublicKey(args[0]), args);\n+    }\n+\n+    public CalculatePublicKey(String conf) throws IOException {\n+        copyNssCertKeyToClassesDir();\n+        setCommonSystemProps();\n+        System.setProperty(\"CUSTOM_P11_CONFIG\",\n+                Path.of(System.getProperty(\"test.src\", \".\"), \"..\/nss\/\" + conf).toString());\n+        System.setProperty(\"TOKEN\", \"nss\");\n+        System.setProperty(\"TEST\", \"basic\");\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        \/\/ Newly generated\n+        var kp = KeyPairGenerator.getInstance(\"EC\", p).generateKeyPair();\n+        check(kp.getPrivate());\n+\n+        \/\/ Translate from another key\n+        var kp2 = KeyPairGenerator.getInstance(\"EC\", \"SunEC\").generateKeyPair();\n+        check((PrivateKey) KeyFactory.getInstance(\"EC\", p).translateKey(kp2.getPrivate()));\n+\n+        \/\/ Generate from PKCS8\n+        check(KeyFactory.getInstance(\"EC\", p).generatePrivate(\n+                new PKCS8EncodedKeySpec(kp2.getPrivate().getEncoded())));\n+\n+        \/\/ Unwrapped: not supported yet.\n+        KeyGenerator kg = KeyGenerator.getInstance(\"AES\", p);\n+        kg.init(256);\n+        var k = kg.generateKey();\n+        var cipher = Cipher.getInstance(\"AES_256\/KW\/PKCS5Padding\", p);\n+        cipher.init(Cipher.WRAP_MODE, k);\n+        var wrapped = cipher.wrap(kp.getPrivate());\n+        cipher.init(Cipher.UNWRAP_MODE, k);\n+\n+        \/\/ check((PrivateKey) cipher.unwrap(wrapped, \"EC\", Cipher.PRIVATE_KEY));\n+    }\n+\n+    static void check(PrivateKey sk) throws Exception {\n+        System.out.println(sk);\n+        if (sk instanceof InternalPrivateKey ipk) {\n+            if (ipk.calculatePublicKey() == null) {\n+                throw new Exception(\"Associated public key is null\");\n+            }\n+        } else {\n+            throw new Exception(\"Not an InternalPrivateKey\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/CalculatePublicKey.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @summary Verify that HPKE works across security providers\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm DHKEM p11-nss.txt\n+ * @run main\/othervm DHKEM p11-nss-sensitive.txt\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.spec.ECGenParameterSpec;\n+\n+public class DHKEM extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new DHKEM(args[0]), args);\n+    }\n+\n+    public DHKEM(String conf) throws IOException {\n+        copyNssCertKeyToClassesDir();\n+        setCommonSystemProps();\n+        System.setProperty(\"CUSTOM_P11_CONFIG\",\n+                Path.of(System.getProperty(\"test.src\", \".\"), \"..\/nss\/\" + conf).toString());\n+        System.setProperty(\"TOKEN\", \"nss\");\n+        System.setProperty(\"TEST\", \"basic\");\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        var ec = Security.getProvider(\"SunEC\");\n+        test(p, p);\n+        test(p, ec);\n+        test(ec, p);\n+    }\n+\n+    static void test(Provider p1, Provider p2) throws Exception {\n+        var g = KeyPairGenerator.getInstance(\"EC\", p2);\n+        g.initialize(new ECGenParameterSpec(\"secp521r1\"));\n+        var kp = g.generateKeyPair();\n+        var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+\n+        prefer(p1);\n+        var kem1 = KEM.getInstance(\"DHKEM\");\n+        var e = kem1.newEncapsulator(kp.getPublic());\n+        var enc = e.encapsulate();\n+        var kdf1 = KDF.getInstance(\"HKDF-SHA256\");\n+        var k1 = kdf1.deriveKey(\"AES\", HKDFParameterSpec.ofExtract().addIKM(enc.key()).thenExpand(null, 32));\n+        var c1 = Cipher.getInstance(\"AES\");\n+        c1.init(Cipher.ENCRYPT_MODE, k1);\n+        var ct = c1.doFinal(msg);\n+\n+        Asserts.assertTrue(e.secretSize() >= 42);\n+        var enc2 = e.encapsulate(5, 37, \"AES\");\n+        c1.init(Cipher.ENCRYPT_MODE, enc2.key());\n+        var ct2 = c1.doFinal(msg);\n+\n+        prefer(p2);\n+        var kem2 = KEM.getInstance(\"DHKEM\");\n+        var d = kem2.newDecapsulator(kp.getPrivate());\n+        var k = d.decapsulate(enc.encapsulation());\n+        var kdf2 = KDF.getInstance(\"HKDF-SHA256\");\n+        var k2 = kdf2.deriveKey(\"AES\", HKDFParameterSpec.ofExtract().addIKM(k).thenExpand(null, 32));\n+        var c2 = Cipher.getInstance(\"AES\");\n+        c2.init(Cipher.DECRYPT_MODE, k2);\n+        var pt = c2.doFinal(ct);\n+\n+        Asserts.assertEqualsByteArray(msg, pt);\n+\n+        var k3 = d.decapsulate(enc2.encapsulation(), 5, 37, \"AES\");\n+        c2.init(Cipher.DECRYPT_MODE, k3);\n+        var pt2 = c2.doFinal(ct2);\n+\n+        Asserts.assertEqualsByteArray(msg, pt2);\n+    }\n+\n+    static void prefer(Provider p) {\n+        Security.removeProvider(p.getName());\n+        Security.insertProviderAt(p, 1);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/DHKEM.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}