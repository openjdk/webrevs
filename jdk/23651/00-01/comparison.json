{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.Serial;\n@@ -30,2 +31,11 @@\n-import java.security.*;\n-import java.security.interfaces.ECKey;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n@@ -33,1 +43,0 @@\n-import java.security.interfaces.XECKey;\n@@ -35,1 +44,10 @@\n-import java.security.spec.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPrivateKeySpec;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPrivateKeySpec;\n+import java.security.spec.XECPublicKeySpec;\n@@ -38,1 +56,7 @@\n-import javax.crypto.*;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n@@ -42,2 +66,6 @@\n-import sun.security.ssl.HKDF;\n-import sun.security.util.*;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.SliceableSecretKey;\n@@ -46,1 +74,0 @@\n-\/\/ without the AuthEncap and AuthDecap functions\n@@ -66,1 +93,2 @@\n-                           PrivateKey skR, PublicKey pkR)\n+                           PrivateKey skS, PublicKey pkS, \/\/ sender keys\n+                           PrivateKey skR, PublicKey pkR) \/\/ receiver keys\n@@ -78,1 +106,0 @@\n-            byte[] kem_context = concat(pkEm, pkRm);\n@@ -80,5 +107,14 @@\n-                byte[] dh = params.DH(skE, pkR);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new KEM.Encapsulated(\n-                        new SecretKeySpec(key, from, to - from, algorithm),\n-                        pkEm, null);\n+                SecretKey key;\n+                if (skS == null) {\n+                    byte[] kem_context = concat(pkEm, pkRm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(pkEm, pkRm, pkSm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skE, pkR), params.DH(skS, pkR));\n+                }\n+                return new KEM.Encapsulated(key, pkEm, null);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -101,1 +137,0 @@\n-                byte[] dh = params.DH(skR, pkE);\n@@ -103,3 +138,12 @@\n-                byte[] kem_context = concat(encapsulation, pkRm);\n-                byte[] key = params.ExtractAndExpand(dh, kem_context);\n-                return new SecretKeySpec(key, from, to - from, algorithm);\n+                if (pkS == null) {\n+                    byte[] kem_context = concat(encapsulation, pkRm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE));\n+                } else {\n+                    byte[] pkSm = params.SerializePublicKey(pkS);\n+                    byte[] kem_context = concat(encapsulation, pkRm, pkSm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.DH(skR, pkE), params.DH(skR, pkS));\n+                }\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -127,1 +171,2 @@\n-        static final long serialVersionUID = 0L;\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n@@ -136,1 +181,1 @@\n-        public KeyPair derive(Params params) {\n+        private KeyPair derive(Params params) {\n@@ -156,1 +201,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"HKDF-SHA256\"),\n@@ -159,1 +204,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"HKDF-SHA384\"),\n@@ -162,1 +207,1 @@\n-                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"HKDF-SHA512\"),\n@@ -165,1 +210,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"HKDF-SHA256\"),\n@@ -168,1 +213,1 @@\n-                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"HKDF-SHA512\"),\n@@ -240,1 +285,1 @@\n-        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+        private SecretKey DH(PrivateKey skE, PublicKey pkR)\n@@ -245,1 +290,1 @@\n-            return ka.generateSecret();\n+            return ka.generateSecret(\"Generic\");\n@@ -248,6 +293,39 @@\n-        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n-            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n-                    kem_context, Nsecret);\n+        \/\/ The final shared secret derivation of either the encapsulator\n+        \/\/ or the decapsulator. The key slicing is implemented inside.\n+        \/\/ Throws UOE if a slice of the key cannot be found.\n+        private SecretKey deriveKey(String alg, int from, int to,\n+                byte[] kem_context, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            if (from == 0 && to == Nsecret) {\n+                return ExtractAndExpand(kem_context, alg, dhs);\n+            } else {\n+                \/\/ First get shared secrets in \"Generic\" and then get a slice\n+                \/\/ of it in the requested algorithm.\n+                var fullKey = ExtractAndExpand(kem_context, \"Generic\", dhs);\n+                if (\"RAW\".equalsIgnoreCase(fullKey.getFormat())) {\n+                    byte[] km = fullKey.getEncoded();\n+                    if (km == null) {\n+                        \/\/ Should not happen if format is \"RAW\"\n+                        throw new UnsupportedOperationException(\"Key extract failed\");\n+                    } else {\n+                        return new SecretKeySpec(km, from, to - from, alg);\n+                    }\n+                } else if (fullKey instanceof SliceableSecretKey ssk) {\n+                    return ssk.slice(alg, from, to);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Cannot extract key\");\n+                }\n+            }\n+        }\n+\n+        private SecretKey ExtractAndExpand(byte[] kem_context, String alg, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, EAE_PRK);\n+            for (var dh : dhs) builder.addIKM(dh);\n+            try {\n+                return kdf.deriveKey(alg,\n+                        labeledExpand(builder, suiteId, SHARED_SECRET, kem_context, Nsecret));\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw new ProviderException(e);\n+            }\n@@ -280,2 +358,2 @@\n-            HKDF kdf = new HKDF(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, DKP_PRK).addIKM(ikm);\n@@ -288,1 +366,2 @@\n-                        throw new RuntimeException();\n+                        \/\/ So unlucky and should not happen\n+                        throw new ProviderException(\"DeriveKeyPairError\");\n@@ -290,2 +369,2 @@\n-                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n-                            CANDIDATE, I2OSP(counter, 1), Nsk);\n+                    byte[] bytes = kdf.deriveData(labeledExpand(builder,\n+                            suiteId, CANDIDATE, I2OSP(counter, 1), Nsk));\n@@ -302,1 +381,2 @@\n-                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                byte[] sk = kdf.deriveData(labeledExpand(builder,\n+                        suiteId, SK, EMPTY, Nsk));\n@@ -331,1 +411,16 @@\n-        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, null, null, pk);\n+    }\n+\n+    \/\/ AuthEncap is not public KEM API\n+    public EncapsulatorSpi engineNewAuthEncapsulator(PublicKey pkR, PrivateKey skS,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pkR == null || skS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pkR);\n+        return new Handler(params, getSecureRandom(secureRandom),\n+                skS, params.getPublicKey(skS), null, pkR);\n@@ -344,1 +439,1 @@\n-        return new Handler(params, null, sk, params.getPublicKey(sk));\n+        return new Handler(params, null, null, null, sk, params.getPublicKey(sk));\n@@ -347,3 +442,18 @@\n-    private Params paramsFromKey(Key k) throws InvalidKeyException {\n-        if (k instanceof ECKey eckey) {\n-            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+    \/\/ AuthDecap is not public KEM API\n+    public DecapsulatorSpi engineNewAuthDecapsulator(\n+            PrivateKey skR, PublicKey pkS, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (skR == null || pkS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(skR);\n+        return new Handler(params, null, null, pkS, skR, params.getPublicKey(skR));\n+    }\n+\n+    private Params paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+        var p = k.getParams();\n+        if (p instanceof ECParameterSpec ecp) {\n+            if (ECUtil.equals(ecp, CurveDB.P_256)) {\n@@ -351,1 +461,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n@@ -353,1 +463,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n@@ -356,2 +466,1 @@\n-        } else if (k instanceof XECKey xkey\n-                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+        } else if (p instanceof NamedParameterSpec ns) {\n@@ -373,2 +482,5 @@\n-    private static byte[] I2OSP(int n, int w) {\n-        assert n < 256;\n+    \/\/ I2OSP(n, w) as defined in RFC 9180 Section 3.\n+    \/\/ In DHKEM and HPKE, number is always <65536\n+    \/\/ and converted to at most 2 bytes.\n+    public static byte[] I2OSP(int n, int w) {\n+        assert n < 65536;\n@@ -383,5 +495,20 @@\n-    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n-            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n-        return kdf.extract(salt,\n-                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n-                    \"HKDF-PRK\");\n+    \/\/ Create a LabeledExtract builder with labels.\n+    \/\/ You can add more IKM and salt into the result.\n+    public static HKDFParameterSpec.Builder labeledExtract(\n+            byte[] suiteId, byte[] label) {\n+        return HKDFParameterSpec.ofExtract()\n+                .addIKM(HPKE_V1).addIKM(suiteId).addIKM(label);\n+    }\n+\n+    \/\/ Create a labeled info from info and labels\n+    private static byte[] labeledInfo(\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return concat(I2OSP(L, 2), HPKE_V1, suiteId, label, info);\n+    }\n+\n+    \/\/ LabeledExpand from a builder\n+    public static HKDFParameterSpec labeledExpand(\n+            HKDFParameterSpec.Builder builder,\n+            byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return builder.thenExpand(\n+                labeledInfo(suiteId, label, info, L), L);\n@@ -390,6 +517,5 @@\n-    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n-            SecretKey prk, byte[] label, byte[] info, int L)\n-            throws InvalidKeyException {\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n-                suite_id, label, info);\n-        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+    \/\/ LabeledExpand from a prk\n+    public static HKDFParameterSpec labeledExpand(\n+            SecretKey prk, byte[] suiteId, byte[] label, byte[] info, int L) {\n+        return HKDFParameterSpec.expandOnly(\n+                prk, labeledInfo(suiteId, label, info, L), L);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":189,"deletions":63,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.util;\n+\n+import javax.crypto.SecretKey;\n+\n+\/**\n+ * An interface for <code>SecretKey<\/code>s that support using its slice as a new\n+ * <code>SecretKey<\/code>\n+ * <p>\n+ * This is mainly used by PKCS #11 implementations that support the\n+ * EXTRACT_KEY_FROM_KEY mechanism even if the key itself is sensitive\n+ * and non-extractable.\n+ *\/\n+public interface SliceableSecretKey {\n+\n+    \/**\n+     * Returns a slice as a new <code>SecretKey<\/code>.\n+     *\n+     * @param alg the new algorithm name\n+     * @param from the byte offset of the new key in the full key\n+     * @param to the to offset (exclusive) of the new key in the full key\n+     * @return the new key\n+     * @throws ArrayIndexOutOfBoundsException for improper <code>from<\/code>\n+     *      and <code>to<\/code> values\n+     * @throws UnsupportedOperationException if slicing is not supported\n+     *\/\n+    SecretKey slice(String alg, int from, int to);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -56,0 +56,1 @@\n+import sun.security.util.SliceableSecretKey;\n@@ -457,1 +458,1 @@\n-    static class P11SecretKey extends P11Key implements SecretKey {\n+    static class P11SecretKey extends P11Key implements SecretKey, SliceableSecretKey {\n@@ -497,0 +498,36 @@\n+\n+        @Override\n+        public P11SecretKey slice(String alg, int from, int to) {\n+            Objects.checkFromToIndex(from, to, length() \/ 8);\n+            try {\n+                CK_MECHANISM mechanism = new CK_MECHANISM(CKM_EXTRACT_KEY_FROM_KEY,\n+                        new CK_KEY_EXTRACT_FROM_KEY(from * 8));\n+\n+                P11SecretKeyFactory.KeyInfo ki = P11SecretKeyFactory.getKeyInfo(alg);\n+                if (ki == null) {\n+                    throw new UnsupportedOperationException(\"A PKCS #11 key \" +\n+                            \"type (CKK_*) was not found for a key of the algorithm '\" +\n+                            alg + \"'.\");\n+                }\n+                CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),\n+                        new CK_ATTRIBUTE(CKA_KEY_TYPE, ki.keyType),\n+                        new CK_ATTRIBUTE(CKA_VALUE_LEN, to - from),\n+                };\n+\n+                var session = token.getOpSession();\n+                attrs = token.getAttributes(O_GENERATE, CKO_SECRET_KEY,\n+                        ki.keyType, attrs);\n+                long newKeyHandle = token.p11.C_DeriveKey(\n+                        session.id(),\n+                        mechanism,\n+                        getKeyID(),\n+                        attrs\n+                );\n+\n+                return (P11Key.P11SecretKey) P11Key.secretKey(session,\n+                        newKeyHandle, alg, (to - from) * 8, null);\n+            } catch (PKCS11Exception e) {\n+                throw new UnsupportedOperationException(e);\n+            }\n+        }\n@@ -1213,1 +1250,1 @@\n-            implements InternalPrivateKey {\n+            implements ECKey, InternalPrivateKey {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,9 @@\n+package sun.security.pkcs11.wrapper;\n+\n+public class CK_KEY_EXTRACT_FROM_KEY {\n+    private final int fromBit;\n+\n+    public CK_KEY_EXTRACT_FROM_KEY(int fromBit) {\n+        this.fromBit = fromBit;\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_KEY_EXTRACT_FROM_KEY.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -138,0 +138,4 @@\n+    public CK_MECHANISM(long mechanism, CK_KEY_EXTRACT_FROM_KEY params) {\n+        init(mechanism, params);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -878,0 +878,34 @@\n+CK_EXTRACT_PARAMS_PTR\n+jKeyExtractKeyFromKeyToExtractKeyFromKeyPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)\n+{\n+    CK_EXTRACT_PARAMS_PTR ckParamPtr = NULL;\n+    jclass jKeyDerivationStringDataClass;\n+    jfieldID fieldID;\n+    jint jpData;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0L;\n+    }\n+\n+    jKeyDerivationStringDataClass = (*env)->FindClass(env, CLASS_KEY_EXTRACT_FROM_KEY);\n+    if (jKeyDerivationStringDataClass == NULL) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jKeyDerivationStringDataClass, \"fromBit\", \"I\");\n+    if (fieldID == NULL) {\n+        return NULL;\n+    }\n+    jpData = (*env)->GetIntField(env, jParam, fieldID);\n+    ckParamPtr = calloc(1, sizeof(CK_EXTRACT_PARAMS));\n+    if (ckParamPtr == NULL) {\n+        p11ThrowOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+    *ckParamPtr = jpData;\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_EXTRACT_PARAMS);\n+    }\n+    return ckParamPtr;\n+}\n+\n@@ -1652,0 +1686,4 @@\n+            break;\n+        case CKM_EXTRACT_KEY_FROM_KEY:\n+            ckpParamPtr = jKeyExtractKeyFromKeyToExtractKeyFromKeyPtr(env, jParam,\n+                    ckpLength);\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -419,0 +419,1 @@\n+                 case CKM_EXTRACT_KEY_FROM_KEY:\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,1 +223,0 @@\n-\n@@ -303,0 +302,1 @@\n+#define CLASS_KEY_EXTRACT_FROM_KEY \"sun\/security\/pkcs11\/wrapper\/CK_KEY_EXTRACT_FROM_KEY\"\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.test.lib.Utils;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -46,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -69,6 +66,4 @@\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(null, new byte[0], null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(null, new byte[0], null));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null));\n@@ -89,16 +84,11 @@\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"OLALA\"),\n-                NoSuchAlgorithmException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n-                NoSuchProviderException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n-                NoSuchAlgorithmException.class);\n-\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(null),\n-                InvalidKeyException.class);\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(null),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"OLALA\"));\n+        Asserts.assertThrows(NoSuchProviderException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"));\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"));\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newEncapsulator(null));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(null));\n@@ -107,3 +97,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(badECKey()),\n-                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(badECKey())),\n+                DHKEM.class.getName());\n@@ -113,3 +104,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(kpRSA.getPublic()),\n-                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(kpRSA.getPublic())),\n+                KEM.class.getName() + \"$DelayedKEM\");\n@@ -117,3 +109,2 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()));\n@@ -128,9 +119,6 @@\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(-1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(-1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> e2.encapsulate(0, e2.secretSize(), null));\n@@ -165,12 +153,8 @@\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(null));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null));\n@@ -181,3 +165,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(enc2.encapsulation()),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(enc2.encapsulation()));\n@@ -185,3 +168,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(new byte[100]),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(new byte[100]));\n@@ -276,29 +258,3 @@\n-    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n-    record ExChecker(Class<? extends Throwable> ex, String caller)\n-            implements Consumer<Throwable> {\n-        ExChecker {\n-            Objects.requireNonNull(ex);\n-        }\n-        static ExChecker of(Class<? extends Throwable> ex) {\n-            return new ExChecker(ex, null);\n-        }\n-        ExChecker by(String caller) {\n-            return new ExChecker(ex(), caller);\n-        }\n-        ExChecker by(Class<?> caller) {\n-            return new ExChecker(ex(), caller.getName());\n-        }\n-        @Override\n-        public void accept(Throwable t) {\n-            if (t == null) {\n-                throw new AssertionError(\"no exception thrown\");\n-            } else if (!ex.isAssignableFrom(t.getClass())) {\n-                throw new AssertionError(\"exception thrown is \" + t.getClass());\n-            } else if (caller == null) {\n-                return;\n-            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n-                return;\n-            } else {\n-                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n-            }\n-        }\n+    \/\/ Ensures `t` is thrown by `caller`\n+    static <T extends Throwable> void checkThrownBy(T t, String caller) {\n+        Asserts.assertEquals(caller, t.getStackTrace()[0].getClassName());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ *          java.base\/sun.security.util\n+ * @run main\/othervm TestSlice p11-nss-sensitive.txt\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.util.SliceableSecretKey;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.util.Arrays;\n+\n+public class TestSlice extends PKCS11Test {\n+    public static void main(String[] args) throws Exception {\n+        main(new TestSlice(args[0]), args);\n+    }\n+\n+    public TestSlice(String conf) throws IOException {\n+        copyNssCertKeyToClassesDir();\n+        setCommonSystemProps();\n+        System.setProperty(\"CUSTOM_P11_CONFIG\",\n+                Path.of(System.getProperty(\"test.src\", \".\"), \"..\/nss\/\" + conf).toString());\n+        System.setProperty(\"TOKEN\", \"nss\");\n+        System.setProperty(\"TEST\", \"basic\");\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        var data = new byte[48];\n+        for (var i = 0; i < 48; i++) data[i] = (byte)i;\n+        var sk = new SecretKeySpec(data, \"Generic\");\n+        var hk = SecretKeyFactory.getInstance(\"Generic\", p).translateKey(sk);\n+        if (hk instanceof SliceableSecretKey ssk) {\n+            var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < 16; i++) {\n+                var slice = ssk.slice(\"HmacSHA256\", i, i + 32);\n+                System.out.println(slice);\n+                var enc = slice.getEncoded();\n+                var expected = Arrays.copyOfRange(data, i, i + 32);\n+                if (enc != null) {\n+                    \/\/ If extractable, just compare key material\n+                    Asserts.assertEqualsByteArray(expected, enc);\n+                } else {\n+                    \/\/ Otherwise, see if they are equivalent as Hmac key\n+                    var h1 = Mac.getInstance(\"HmacSHA256\");\n+                    h1.init(new SecretKeySpec(expected, \"HmacSHA256\"));\n+                    h1.update(msg);\n+                    var m1 = h1.doFinal();\n+                    var h2 = Mac.getInstance(\"HmacSHA256\", p);\n+                    h2.init(slice);\n+                    h2.update(msg);\n+                    var m2 = h2.doFinal();\n+                    Asserts.assertEqualsByteArray(m1, m2);\n+                }\n+            }\n+        } else {\n+            throw new Exception(\"This should be a SliceableSecretKey\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestSlice.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @summary Verify that HPKE works across security providers\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm DHKEM p11-nss.txt\n+ * @run main\/othervm DHKEM p11-nss-sensitive.txt\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.spec.ECGenParameterSpec;\n+\n+public class DHKEM extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new DHKEM(args[0]), args);\n+    }\n+\n+    public DHKEM(String conf) throws IOException {\n+        copyNssCertKeyToClassesDir();\n+        setCommonSystemProps();\n+        System.setProperty(\"CUSTOM_P11_CONFIG\",\n+                Path.of(System.getProperty(\"test.src\", \".\"), \"..\/nss\/\" + conf).toString());\n+        System.setProperty(\"TOKEN\", \"nss\");\n+        System.setProperty(\"TEST\", \"basic\");\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        var ec = Security.getProvider(\"SunEC\");\n+        test(p, p);\n+        test(p, ec);\n+        test(ec, p);\n+    }\n+\n+    static void test(Provider p1, Provider p2) throws Exception {\n+        var g = KeyPairGenerator.getInstance(\"EC\", p2);\n+        g.initialize(new ECGenParameterSpec(\"secp521r1\"));\n+        var kp = g.generateKeyPair();\n+        var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+\n+        prefer(p1);\n+        var kem1 = KEM.getInstance(\"DHKEM\");\n+        var e = kem1.newEncapsulator(kp.getPublic());\n+        var enc = e.encapsulate();\n+        var kdf1 = KDF.getInstance(\"HKDF-SHA256\");\n+        var k1 = kdf1.deriveKey(\"AES\", HKDFParameterSpec.ofExtract().addIKM(enc.key()).thenExpand(null, 32));\n+        var c1 = Cipher.getInstance(\"AES\");\n+        c1.init(Cipher.ENCRYPT_MODE, k1);\n+        var ct = c1.doFinal(msg);\n+\n+        Asserts.assertTrue(e.secretSize() >= 42);\n+        var enc2 = e.encapsulate(5, 37, \"AES\");\n+        c1.init(Cipher.ENCRYPT_MODE, enc2.key());\n+        var ct2 = c1.doFinal(msg);\n+\n+        prefer(p2);\n+        var kem2 = KEM.getInstance(\"DHKEM\");\n+        var d = kem2.newDecapsulator(kp.getPrivate());\n+        var k = d.decapsulate(enc.encapsulation());\n+        var kdf2 = KDF.getInstance(\"HKDF-SHA256\");\n+        var k2 = kdf2.deriveKey(\"AES\", HKDFParameterSpec.ofExtract().addIKM(k).thenExpand(null, 32));\n+        var c2 = Cipher.getInstance(\"AES\");\n+        c2.init(Cipher.DECRYPT_MODE, k2);\n+        var pt = c2.doFinal(ct);\n+\n+        Asserts.assertEqualsByteArray(msg, pt);\n+\n+        var k3 = d.decapsulate(enc2.encapsulation(), 5, 37, \"AES\");\n+        c2.init(Cipher.DECRYPT_MODE, k3);\n+        var pt2 = c2.doFinal(ct2);\n+\n+        Asserts.assertEqualsByteArray(msg, pt2);\n+    }\n+\n+    static void prefer(Provider p) {\n+        Security.removeProvider(p.getName());\n+        Security.insertProviderAt(p, 1);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/DHKEM.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}