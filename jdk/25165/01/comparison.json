{"files":[{"patch":"@@ -223,0 +223,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -231,0 +232,1 @@\n+    _available[partition_id] = FreeSetUnderConstruction;\n@@ -238,0 +240,2 @@\n+  shenandoah_assert_heaplocked();\n+\n@@ -246,0 +250,2 @@\n+  _available[int(ShenandoahFreeSetPartitionId::Mutator)] =\n+    _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] - _used[int(ShenandoahFreeSetPartitionId::Mutator)];\n@@ -255,0 +261,1 @@\n+  _available[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -261,0 +268,2 @@\n+  shenandoah_assert_heaplocked();\n+\n@@ -269,0 +278,2 @@\n+  _available[int(ShenandoahFreeSetPartitionId::OldCollector)] =\n+    _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] - _used[int(ShenandoahFreeSetPartitionId::OldCollector)];\n@@ -272,0 +283,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -273,0 +285,1 @@\n+\n@@ -274,0 +287,1 @@\n+  _available[int(which_partition)] -= bytes;\n@@ -369,0 +383,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -377,0 +392,1 @@\n+  _available[int(which_partition)] += available;\n@@ -401,0 +417,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -439,0 +456,1 @@\n+  _available[int(orig_partition)] -= available;\n@@ -443,0 +461,1 @@\n+  _available[int(new_partition)] += available;\n@@ -1366,1 +1385,0 @@\n-  shenandoah_assert_heaplocked();\n@@ -1371,0 +1389,1 @@\n+  shenandoah_assert_heaplocked();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  size_t _available[UIntNumPartitions];\n@@ -111,0 +112,2 @@\n+  static const size_t FreeSetUnderConstruction = SIZE_MAX;\n+\n@@ -223,1 +226,21 @@\n-    return _capacity[int(which_partition)] - _used[int(which_partition)];\n+    shenandoah_assert_heaplocked();\n+    assert(_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)],\n+           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n+           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n+           partition_membership_name(ssize_t(which_partition)));\n+    return _available[int(which_partition)];\n+  }\n+\n+  \/\/ Acquire heap lock and return available_in, assuming heap lock is not acquired by the caller.\n+  inline size_t available_in_not_locked(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    shenandoah_assert_not_heaplocked();\n+#ifdef ASSERT\n+    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n+    assert((_available[int(which_partition)] == FreeSetUnderConstruction) ||\n+           (_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)]),\n+           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n+           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n+           partition_membership_name(ssize_t(which_partition)));\n+#endif\n+    return _available[int(which_partition)];\n@@ -227,0 +250,1 @@\n+    shenandoah_assert_heaplocked();\n@@ -229,0 +253,1 @@\n+    _available[int(which_partition)] = value - _used[int(which_partition)];\n@@ -232,0 +257,1 @@\n+    shenandoah_assert_heaplocked();\n@@ -234,0 +260,1 @@\n+    _available[int(which_partition)] = _capacity[int(which_partition)] - value;\n@@ -385,0 +412,2 @@\n+  static const size_t FreeSetUnderConstruction = ShenandoahRegionPartitions::FreeSetUnderConstruction;\n+\n@@ -444,2 +473,0 @@\n-  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator); }\n-  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);     }\n@@ -447,4 +474,8 @@\n-  inline size_t available() const {\n-    assert(used() <= capacity(), \"must use less than capacity\");\n-    return capacity() - used();\n-  }\n+  \/\/ All three of the following functions may produce stale data if called without owning the global heap lock.\n+  \/\/ Changes to the values of these variables are performed with a lock.  A change to capacity or used \"atomically\"\n+  \/\/ adjusts available with respect to lock holders.  However, sequential calls to these three functions may produce\n+  \/\/ inconsistent data: available may not equal capacity - used because the intermediate states of any \"atomic\"\n+  \/\/ locked action can be seen by these unlocked functions.\n+  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator);             }\n+  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);                 }\n+  inline size_t available() const { return _partitions.available_in_not_locked(ShenandoahFreeSetPartitionId::Mutator); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+  ShenandoahGenerationalHeap::TransferResult result;\n@@ -255,1 +256,8 @@\n-    phase5_epilog();\n+    result = phase5_epilog();\n+  }\n+  if (heap->mode()->is_generational()) {\n+    LogTarget(Info, gc, ergo) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      result.print_on(\"Full GC\", &ls);\n+    }\n@@ -1123,1 +1131,1 @@\n-void ShenandoahFullGC::phase5_epilog() {\n+ShenandoahGenerationalHeap::TransferResult ShenandoahFullGC::phase5_epilog() {\n@@ -1126,0 +1134,1 @@\n+  ShenandoahGenerationalHeap::TransferResult result;\n@@ -1171,1 +1180,1 @@\n-    ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n+    result = ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n@@ -1174,0 +1183,1 @@\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -84,1 +85,1 @@\n-  void phase5_epilog();\n+  ShenandoahGenerationalHeap::TransferResult phase5_epilog();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,7 +131,2 @@\n-void ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n-  auto result = ShenandoahGenerationalHeap::heap()->balance_generations();\n-  LogTarget(Info, gc, ergo) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    result.print_on(\"Full GC\", &ls);\n-  }\n+ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n+  return ShenandoahGenerationalHeap::heap()->balance_generations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -64,1 +65,1 @@\n-  static void balance_generations_after_rebuilding_free_set();\n+  static ShenandoahGenerationalHeap::TransferResult balance_generations_after_rebuilding_free_set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,4 @@\n-  return ShenandoahHeap::heap()->free_set()->available();\n+  \/\/ The collector reserve may eat into what the mutator is allowed to use. Make sure we are looking\n+  \/\/ at what is available to the mutator when reporting how much memory is available.\n+  size_t available = this->ShenandoahGeneration::available();\n+  return MIN2(available, ShenandoahHeap::heap()->free_set()->available());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -405,1 +405,0 @@\n-  _free_set = new ShenandoahFreeSet(this, _num_regions);\n@@ -409,1 +408,1 @@\n-\n+    _free_set = new ShenandoahFreeSet(this, _num_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  assert(free_actual != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n@@ -89,0 +90,1 @@\n+  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n@@ -114,0 +116,1 @@\n+  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}