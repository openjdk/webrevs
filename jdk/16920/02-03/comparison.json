{"files":[{"patch":"@@ -30,0 +30,3 @@\n+#define __XCOFF32__\n+#define __XCOFF64__\n+\n@@ -196,1 +199,1 @@\n-    void   *handle;\n+    void*   handle;\n@@ -203,1 +206,1 @@\n-static struct handletableentry g_handletable[max_handletable] = {{0,0,0,0}};\n+static struct handletableentry g_handletable[max_handletable] = {{0, 0, 0, 0}};\n@@ -1125,0 +1128,276 @@\n+\/\/ get the library search path burned in to the executable file during linking\n+\/\/ If the libpath cannot be retrieved return an empty path\n+static const char* rtv_linkedin_libpath() {\n+  static char buffer[4096];\n+  static const char* libpath = 0;\n+\n+  if (libpath)\n+    return libpath;\n+\n+  char pgmpath[32+1];\n+  \/\/ retrieve the path to the currently running executable binary\n+  snprintf(pgmpath, 32, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  \/\/ open the currently running executable binary\n+  FILE *f = fopen(pgmpath, \"r\");\n+  \/\/ read the generic XCOFF header and analyze the substructures\n+  \/\/ to find the burned in libpath\n+  fread(buffer, 1, FILHSZ_64 + _AOUTHSZ_EXEC_64, f);\n+\n+  if (((struct filehdr*)buffer)->f_magic == U802TOCMAGIC ) {\n+    \/\/ __XCOFF32__\n+    struct xcoffhdr xcoff;\n+    struct scnhdr scn;\n+    struct ldhdr ldr;\n+    memcpy((char*)&xcoff, buffer, FILHSZ + _AOUTHSZ_EXEC);\n+    int ldroffset = FILHSZ + xcoff.filehdr.f_opthdr + (xcoff.aouthdr.o_snloader -1)*SCNHSZ;\n+    fseek (f, ldroffset, SEEK_SET);\n+    fread(buffer, 1, SCNHSZ, f);\n+    memcpy((char*)&scn, buffer, SCNHSZ);\n+    if (strcmp(scn.s_name, \".loader\")) {\n+      buffer[0] = 0;\n+      libpath = buffer;\n+      fclose(f);\n+      return libpath;\n+    }\n+    fseek (f, scn.s_scnptr, SEEK_SET);\n+    fread(buffer, 1, LDHDRSZ, f);\n+    memcpy((char*)&ldr, buffer, LDHDRSZ);\n+    fseek (f, scn.s_scnptr + ldr.l_impoff, SEEK_SET);\n+    fread(buffer, 1, 4096, f);\n+  }\n+  else if (((struct filehdr*)buffer)->f_magic == U64_TOCMAGIC ) {\n+    \/\/ __XCOFF64__\n+    struct _S_(xcoffhdr) xcoff64;\n+    struct _S_(scnhdr) scn64;\n+    struct _S_(ldhdr) ldr64;\n+    memcpy((char*)&xcoff64, buffer, FILHSZ_64 + _AOUTHSZ_EXEC_64);\n+    int ldroffset = FILHSZ_64 + xcoff64.filehdr.f_opthdr + (xcoff64.aouthdr.o_snloader -1)*SCNHSZ_64;\n+    fseek (f, ldroffset, SEEK_SET);\n+    fread(buffer, 1, SCNHSZ_64, f);\n+    memcpy((char*)&scn64, buffer, SCNHSZ_64);\n+    if (strcmp(scn64.s_name, \".loader\")) {\n+      buffer[0] = 0;\n+      libpath = buffer;\n+      fclose(f);\n+      return libpath;\n+    }\n+    fseek (f, scn64.s_scnptr, SEEK_SET);\n+    fread(buffer, 1, LDHDRSZ_64, f);\n+    memcpy((char*)&ldr64, buffer, LDHDRSZ_64);\n+    fseek (f, scn64.s_scnptr + ldr64.l_impoff, SEEK_SET);\n+    fread(buffer, 1, 4096, f);\n+  }\n+  else\n+    buffer[0] = 0;\n+\n+  fclose(f);\n+  libpath = buffer;\n+\n+  return libpath;\n+\n+}\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+static bool search_file_in_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path == nullptr)\n+    return false;\n+\n+  char* path2 = os::strdup (path);\n+  \/\/ if exist, strip off trailing (shr_64.o) or similar\n+  char* substr;\n+  if (path2[strlen(path2) - 1] == ')' && (substr = strrchr(path2, '('))) {\n+    *substr = 0;\n+  }\n+\n+  bool ret = false;\n+  \/\/ If FilePath contains a slash character, FilePath is used directly,\n+  \/\/ and no directories are searched.\n+  \/\/ But if FilePath does not start with \/ or . we have to prepend it with .\/\n+  if (strchr(path2, '\/')) {\n+    stringStream combined;\n+    if (*path2 == '\/' || *path2 == '.')\n+      combined.print(\"%s\", path2);\n+    else\n+      combined.print(\".\/%s\", path2);\n+    ret = (0 == stat64x(combined.base(), stat));\n+    os::free (path2);\n+    return ret;\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH, try with LD_LIBRARY_PATH\n+    env = getenv(\"LD_LIBRARY_PATH\");\n+  }\n+\n+  stringStream Libpath;\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH or LD_LIBRARY_PATH given -> try only with burned in libpath\n+    Libpath.print(\"%s\", rtv_linkedin_libpath());\n+  } else if (*env == 0) {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given but empty -> try first with burned\n+    \/\/  in libpath and with current working directory second\n+    Libpath.print(\"%s:.\", rtv_linkedin_libpath());\n+  } else {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given with content -> try first with\n+    \/\/ LIBPATH or LD_LIBRARY_PATH and second with burned in libpath.\n+    \/\/ No check against current working directory\n+    Libpath.print(\"%s:%s\", env, rtv_linkedin_libpath());\n+  }\n+\n+  char* libpath = os::strdup (Libpath.base());\n+\n+  char *saveptr, *token;\n+  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n+    stringStream combined;\n+    combined.print(\"%s\/%s\", token, path2);\n+    if ((ret = (0 == stat64x(combined.base(), stat))))\n+      break;\n+  }\n+\n+  os::free (libpath);\n+  os::free (path2);\n+  return ret;\n+}\n+\n+\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+\/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n+\/\/ opened a second time, as it is implemented on other platforms.\n+void* Aix_dlopen(const char* filename, int Flags, char *ebuf, int ebuflen) {\n+  void* result;\n+  struct stat64x libstat;\n+\n+  if (false == search_file_in_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+  #ifdef ASSERT\n+    result = ::dlopen(filename, Flags);\n+    assert(result == nullptr, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+  #endif\n+  }\n+  else {\n+    int i = 0;\n+    pthread_mutex_lock(&g_handletable_mutex);\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if (g_handletable[i].handle &&\n+          g_handletable[i].inode == libstat.st_ino &&\n+          g_handletable[i].devid == libstat.st_dev) {\n+        g_handletable[i].refcount++;\n+        result = g_handletable[i].handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not yet loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ Array is already full. No place for new handle. Cry and give up.\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        if (ebuf != nullptr && ebuflen > 0) {\n+          ::strncpy(ebuf, \"dlopen: too many libraries loaded\", ebuflen - 1);\n+        }\n+        assert(false, \"max_handletable reached\");\n+        return nullptr;\n+      }\n+      \/\/ Library not yet loaded; load it, then store its handle in handle table\n+      result = ::dlopen(filename, Flags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        g_handletable[i].handle = result;\n+        g_handletable[i].inode = libstat.st_ino;\n+        g_handletable[i].devid = libstat.st_dev;\n+        g_handletable[i].refcount = 1;\n+      }\n+      else {\n+        \/\/ error analysis when dlopen fails\n+        const char* error_report = ::dlerror();\n+        if (error_report == nullptr) {\n+          error_report = \"dlerror returned no error description\";\n+        }\n+        if (ebuf != nullptr && ebuflen > 0) {\n+          snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+        }\n+      }\n+    }\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  }\n+  return result;\n+}\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+  int i = 0;\n+  bool res = false;\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  pthread_mutex_lock(&g_handletable_mutex);\n+  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+  for (i = 0; i < g_handletable_used; i++) {\n+    if (g_handletable[i].handle == libhandle) {\n+      \/\/ handle found, decrease refcount\n+      g_handletable[i].refcount--;\n+      if (g_handletable[i].refcount > 0) {\n+        \/\/ if refcount is still >0 then we have to keep library and just return true\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        return true;\n+      }\n+      \/\/ refcount == 0, so we have to ::dlclose() the lib\n+      \/\/ and delete the entry from the array.\n+      break;\n+    }\n+  }\n+\n+  \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n+  \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n+  \/\/ the error handling. In the first case we then also have to delete the entry from the array\n+  \/\/ while in the second case we simply have to nag.\n+  res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  #ifdef ASSERT\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  #endif\n+    assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n+  }\n+\n+  if (i < g_handletable_used) {\n+    if (res) {\n+      \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n+      \/\/ so delete entry from array\n+      g_handletable_used--;\n+      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+      if (i < g_handletable_used) {\n+        g_handletable[i] = g_handletable[g_handletable_used];\n+      }\n+    }\n+  }\n+  else {\n+  #ifdef ASSERT\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  #endif\n+    \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n+    \/\/ therefore nag\n+    assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n+  }\n+\n+  pthread_mutex_unlock(&g_handletable_mutex);\n+\n+  \/\/ Update the dll cache\n+  LoadedLibraries::reload();\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n+\n@@ -1153,1 +1432,1 @@\n-  result = os::Aix::dlopen(filename, dflags);\n+  result = Aix_dlopen(filename, dflags, ebuf, ebuflen);\n@@ -3050,133 +3329,0 @@\n-\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-int os::Aix::stat64x_via_LIBPATH(const char* path, struct stat64x* stat) {\n-  if (path == nullptr)\n-    return -1;\n-\n-  char *path2 = strdup (path);\n-  \/\/ if exist, strip off trailing (shr_64.o) or similar\n-  int idx = strlen(path2) - 1;\n-  if (path2[idx] == ')') {\n-    while (path2[idx] != '(' && idx > 0) idx--;\n-    if (idx > 0)\n-      path2[idx] = 0;\n-  }\n-\n-  int ret = -1;\n-  if (path2[0] == '\/' ||\n-      (path2[0] == '.' && (path2[1] == '\/' ||\n-                          (path2[1] == '.' && path2[2] == '\/')))) {\n-    ret = stat64x(path2, stat);\n-    free (path2);\n-    return ret;\n-  }\n-\n-  const char* env = getenv(\"LIBPATH\");\n-  if (env == nullptr || *env == 0) {\n-    free (path2);\n-    return -1;\n-  }\n-\n-  size_t libpathlen = strlen(env);\n-  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n-  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path2) + 1, mtServiceability);\n-  char *saveptr, *token;\n-  strcpy(libpath, env);\n-  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n-    sprintf(combined, \"%s\/%s\", token, path2);\n-    if (0 == (ret = stat64x(combined, stat)))\n-      break;\n-  }\n-\n-  FREE_C_HEAP_ARRAY(char*, combined);\n-  FREE_C_HEAP_ARRAY(char*, libpath);\n-  free (path2);\n-  return ret;\n-}\n-\n-\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n-\/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n-\/\/ opened a second time, as it is implemented on other platforms.\n-void* os::Aix::dlopen(const char* filename, int Flags) {\n-  void* result;\n-  struct stat64x libstat;\n-\n-  if (os::Aix::stat64x_via_LIBPATH(filename, &libstat)) {\n-    \/\/ file with filename does not exist\n-    result = ::dlopen(filename, Flags);\n-    if (result != nullptr) {\n-      assert(false, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n-    }\n-  }\n-  else {\n-    int i = 0;\n-    pthread_mutex_lock(&g_handletable_mutex);\n-    \/\/ check if library belonging to filename is already loaded.\n-    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n-    for (i = 0; i < g_handletable_used; i++) {\n-      if (g_handletable[i].handle &&\n-          g_handletable[i].inode == libstat.st_ino &&\n-          g_handletable[i].devid == libstat.st_dev) {\n-        g_handletable[i].refcount++;\n-        result = g_handletable[i].handle;\n-        break;\n-      }\n-    }\n-    if (i == g_handletable_used) {\n-      \/\/ library not still loaded. Check if there is space left in array\n-      \/\/ to store new ::dlopen() handle\n-      if (g_handletable_used == max_handletable) {\n-        \/\/ Array is already full. No place for new handle. Cry and give up.\n-        pthread_mutex_unlock(&g_handletable_mutex);\n-        assert(false, \"max_handletable reached\");\n-        return nullptr;\n-      }\n-      \/\/ library not still loaded and still place in array, so load library\n-      \/\/ and if successful, create new entry at end of array\n-      \/\/ to store handle, inode\/devid with refcount=1\n-      result = ::dlopen(filename, Flags);\n-      if (result != nullptr) {\n-        g_handletable_used++;\n-        g_handletable[i].handle = result;\n-        g_handletable[i].inode = libstat.st_ino;\n-        g_handletable[i].devid = libstat.st_dev;\n-        g_handletable[i].refcount = 1;\n-      }\n-    }\n-    pthread_mutex_unlock(&g_handletable_mutex);\n-  }\n-  return result;\n-}\n-\n-int os::Aix::dlclose(void* lib) {\n-  int i = 0, res;\n-  pthread_mutex_lock(&g_handletable_mutex);\n-  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n-  for (i = 0; i < g_handletable_used; i++) {\n-    if (g_handletable[i].handle == lib) {\n-      \/\/ handle found, decrease refcount\n-      g_handletable[i].refcount--;\n-      if (g_handletable[i].refcount > 0) {\n-        \/\/ if refcount is still >0 then we have to keep library and return\n-        pthread_mutex_unlock(&g_handletable_mutex);\n-        return 0;\n-      }\n-      \/\/ refcount == 0, so we have to ::dlclose() the lib\n-      \/\/ and delete the entry from the array.\n-      res = ::dlclose(lib);\n-      g_handletable_used--;\n-      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n-      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n-      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n-      if (i < g_handletable_used) {\n-        g_handletable[i] = g_handletable[g_handletable_used];\n-      }\n-      pthread_mutex_unlock(&g_handletable_mutex);\n-      return res;\n-    }\n-  }\n-  pthread_mutex_unlock(&g_handletable_mutex);\n-  \/\/ if we reach this point, the library was not created by os::dll_load()\n-  \/\/ so nag and perform the plain ::dlclose();\n-  assert(false, \"os::AIX::dlclose() library was not loaded by os::dll_load()\");\n-  return ::dlclose(lib);\n-} \/\/ end: os::AIX::dlclose()\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":282,"deletions":136,"binary":false,"changes":418,"status":"modified"},{"patch":"@@ -178,8 +178,0 @@\n-  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-  static int stat64x_via_LIBPATH(const char* path, struct stat64x* stat);\n-\n-  \/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n-  \/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n-  \/\/ opened a second time, as it is implemented on other platforms.\n-  static void* dlopen(const char* filename, int Flags);\n-  static int dlclose(void* lib);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2558,0 +2558,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -5411,0 +5411,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -735,1 +735,0 @@\n-  int res = AIX_ONLY(os::Aix)::dlclose(lib);\n@@ -737,1 +736,4 @@\n-  if (res == 0) {\n+  char ebuf[1024];\n+  bool res = os::pd_dll_unload(lib, ebuf, sizeof(ebuf));\n+\n+  if (res) {\n@@ -743,5 +745,0 @@\n-    const char* error_report = ::dlerror();\n-    if (error_report == nullptr) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-\n@@ -749,1 +746,1 @@\n-                            l_path, p2i(lib), error_report);\n+                            l_path, p2i(lib), ebuf);\n@@ -751,2 +748,2 @@\n-                  l_path, p2i(lib), error_report);\n-    JFR_ONLY(unload_event.set_error_msg(error_report);)\n+                  l_path, p2i(lib), ebuf);\n+    JFR_ONLY(unload_event.set_error_msg(ebuf);)\n@@ -754,2 +751,0 @@\n-  \/\/ Update the dll cache\n-  AIX_ONLY(LoadedLibraries::reload());\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1066,0 +1066,3 @@\n+  static bool pd_dll_unload(void* libhandle, char* ebuf, int ebuflen);\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}