{"files":[{"patch":"@@ -192,0 +192,14 @@\n+\/\/ variables needed to emulate linux behavior in os::dll_load() if library is loaded twice\n+static pthread_mutex_t g_handletable_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+struct handletableentry{\n+    void   *handle;\n+    ino64_t inode;\n+    dev64_t devid;\n+    uint    refcount;\n+};\n+constexpr int max_handletable = 1024;\n+static int g_handletable_used = 0;\n+static struct handletableentry g_handletable[max_handletable] = {{0,0,0,0}};\n+\n+\n@@ -1121,1 +1135,3 @@\n-    ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    }\n@@ -1137,1 +1153,47 @@\n-  result = ::dlopen(filename, dflags);\n+\n+  struct stat64x libstat;\n+  if (os::Aix::stat64x_via_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+    result = ::dlopen(filename, dflags);\n+    if (result != nullptr) {\n+      assert(false, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+    }\n+  }\n+  else {\n+    int i = 0;\n+    pthread_mutex_lock ( &g_handletable_mutex);\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if (g_handletable[i].handle &&\n+          g_handletable[i].inode == libstat.st_ino &&\n+          g_handletable[i].devid == libstat.st_dev) {\n+        g_handletable[i].refcount++;\n+        result = g_handletable[i].handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not still loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ Array is already full. No place for new handle. Cry and give up.\n+        pthread_mutex_unlock ( &g_handletable_mutex);\n+        assert(false, \"max_handletable reached\");\n+        ::strncpy(ebuf, \"dll_load: max_handletable reached\", ebuflen - 1);\n+        return nullptr;\n+      }\n+      \/\/ library not still loaded and still place in array, so load library\n+      \/\/ and if successful, create new entry at end of array\n+      \/\/ to store handle, inode\/devid with refcount=1\n+      result = ::dlopen(filename, dflags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        g_handletable[i].handle = result;\n+        g_handletable[i].inode = libstat.st_ino;\n+        g_handletable[i].devid = libstat.st_dev;\n+        g_handletable[i].refcount = 1;\n+      }\n+    }\n+    pthread_mutex_unlock ( &g_handletable_mutex);\n+  }\n@@ -1161,0 +1223,36 @@\n+\/\/ specific AIX version for ::dlclose(), which handles the struct g_handletable\n+\/\/ filled by os::dll_load()\n+int os::Aix::dlclose(void* lib) {\n+  int i = 0, res;\n+  pthread_mutex_lock(&g_handletable_mutex);\n+  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+  for (i = 0; i < g_handletable_used; i++) {\n+    if (g_handletable[i].handle == lib) {\n+      \/\/ handle found, decrease refcount\n+      g_handletable[i].refcount--;\n+      if (g_handletable[i].refcount > 0) {\n+        \/\/ if refcount is still >0 then we have to keep library and return\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        return 0;\n+      }\n+      \/\/ refcount == 0, so we have to ::dlclose() the lib\n+      \/\/ and delete the entry from the array.\n+      res = ::dlclose(lib);\n+      g_handletable_used--;\n+      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+      if (i < g_handletable_used) {\n+        g_handletable[i] = g_handletable[g_handletable_used];\n+      }\n+      pthread_mutex_unlock(&g_handletable_mutex);\n+      return res;\n+    }\n+  }\n+  pthread_mutex_unlock(&g_handletable_mutex);\n+  \/\/ if we reach this point, the library was not created by os::dll_load()\n+  \/\/ so nag and perform the plain ::dlclose();\n+  assert(false, \"os::AIX::dlclose() library was not loaded by os::dll_load()\");\n+  return ::dlclose(lib);\n+} \/\/ end: os::AIX::dlclose()\n+\n@@ -3036,4 +3134,19 @@\n-  if (path[0] == '\/' ||\n-      (path[0] == '.' && (path[1] == '\/' ||\n-                          (path[1] == '.' && path[2] == '\/')))) {\n-    return stat64x(path, stat);\n+  if (path == nullptr)\n+    return -1;\n+\n+  char *path2 = strdup (path);\n+  \/\/ if exist, strip off trailing (shr_64.o) or similar\n+  int idx = strlen(path2) - 1;\n+  if (path2[idx] == ')') {\n+    while (path2[idx] != '(' && idx > 0) idx--;\n+    if (idx > 0)\n+      path2[idx] = 0;\n+  }\n+\n+  int ret = -1;\n+  if (path2[0] == '\/' ||\n+      (path2[0] == '.' && (path2[1] == '\/' ||\n+                          (path2[1] == '.' && path2[2] == '\/')))) {\n+    ret = stat64x(path2, stat);\n+    free (path2);\n+    return ret;\n@@ -3043,1 +3156,2 @@\n-  if (env == nullptr || *env == 0)\n+  if (env == nullptr || *env == 0) {\n+    free (path2);\n@@ -3045,0 +3159,1 @@\n+  }\n@@ -3046,1 +3161,0 @@\n-  int ret = -1;\n@@ -3049,1 +3163,1 @@\n-  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) + 1, mtServiceability);\n+  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path2) + 1, mtServiceability);\n@@ -3053,1 +3167,1 @@\n-    sprintf(combined, \"%s\/%s\", token, path);\n+    sprintf(combined, \"%s\/%s\", token, path2);\n@@ -3060,0 +3174,1 @@\n+  free (path2);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":125,"deletions":10,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -180,0 +180,4 @@\n+\n+  \/\/ specific AIX version for ::dlclose(), which handles the struct g_handletable\n+  \/\/ filled by os::dll_load()\n+  static int dlclose(void* lib);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"os_aix.hpp\"\n@@ -734,1 +735,1 @@\n-  int res = ::dlclose(lib);\n+  int res = AIX_ONLY(os::Aix)::dlclose(lib);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,4 +78,0 @@\n-#ifdef AIX\n-  _inode(0),\n-  _device(0),\n-#endif\n@@ -126,18 +122,0 @@\n-#ifdef AIX\n-void JvmtiAgent::set_inode(ino64_t inode) {\n-  _inode = inode;\n-}\n-\n-void JvmtiAgent::set_device(dev64_t device) {\n-  _device = device;\n-}\n-\n-ino64_t JvmtiAgent::inode() const {\n-  return _inode;\n-}\n-\n-dev64_t JvmtiAgent::device() const {\n-  return _device;\n-}\n-#endif\n-\n@@ -298,14 +276,0 @@\n-#ifdef AIX\n-\/\/ save the inode and device of the library's file as a signature. This signature can be used\n-\/\/ in the same way as the library handle as a signature on other platforms.\n-static void save_library_signature(JvmtiAgent* agent, const char* name) {\n-  struct stat64x libstat;\n-  if (0 == os::Aix::stat64x_via_LIBPATH(name, &libstat)) {\n-    agent->set_inode(libstat.st_ino);\n-    agent->set_device(libstat.st_dev);\n-  } else {\n-    assert(false, \"stat64x failed\");\n-  }\n-}\n-#endif\n-\n@@ -321,1 +285,0 @@\n-  AIX_ONLY(if (library != nullptr) save_library_signature(agent, agent->name());)\n@@ -334,1 +297,0 @@\n-    AIX_ONLY(if (library != nullptr) save_library_signature(agent, &buffer[0]);)\n@@ -340,1 +302,0 @@\n-      AIX_ONLY(save_library_signature(agent, &buffer[0]);)\n@@ -558,3 +519,0 @@\n-  #ifdef AIX\n-    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(agent->device(), agent->inode());\n-  #else\n@@ -562,1 +520,0 @@\n-  #endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -46,4 +46,0 @@\n-#ifdef AIX\n-  ino64_t _inode;\n-  dev64_t _device;\n-#endif\n@@ -87,6 +83,0 @@\n-#ifdef AIX\n-  void set_inode(ino64_t inode);\n-  void set_device(dev64_t device);\n-  unsigned long inode() const;\n-  unsigned long device() const;\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,13 +246,0 @@\n-#ifdef AIX\n-bool JvmtiAgentList::is_dynamic_lib_loaded(dev64_t device, ino64_t inode) {\n-  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n-  while (it.has_next()) {\n-    JvmtiAgent* const agent = it.next();\n-    if (!agent->is_static_lib() && device != 0 && inode != 0 &&\n-        agent->device() == device && agent->inode() == inode) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,3 +81,0 @@\n-#ifdef AIX\n-  static bool is_dynamic_lib_loaded(dev64_t device, ino64_t inode);\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}