{"files":[{"patch":"@@ -1153,47 +1153,1 @@\n-\n-  struct stat64x libstat;\n-  if (os::Aix::stat64x_via_LIBPATH(filename, &libstat)) {\n-    \/\/ file with filename does not exist\n-    result = ::dlopen(filename, dflags);\n-    if (result != nullptr) {\n-      assert(false, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n-    }\n-  }\n-  else {\n-    int i = 0;\n-    pthread_mutex_lock ( &g_handletable_mutex);\n-    \/\/ check if library belonging to filename is already loaded.\n-    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n-    for (i = 0; i < g_handletable_used; i++) {\n-      if (g_handletable[i].handle &&\n-          g_handletable[i].inode == libstat.st_ino &&\n-          g_handletable[i].devid == libstat.st_dev) {\n-        g_handletable[i].refcount++;\n-        result = g_handletable[i].handle;\n-        break;\n-      }\n-    }\n-    if (i == g_handletable_used) {\n-      \/\/ library not still loaded. Check if there is space left in array\n-      \/\/ to store new ::dlopen() handle\n-      if (g_handletable_used == max_handletable) {\n-        \/\/ Array is already full. No place for new handle. Cry and give up.\n-        pthread_mutex_unlock ( &g_handletable_mutex);\n-        assert(false, \"max_handletable reached\");\n-        ::strncpy(ebuf, \"dll_load: max_handletable reached\", ebuflen - 1);\n-        return nullptr;\n-      }\n-      \/\/ library not still loaded and still place in array, so load library\n-      \/\/ and if successful, create new entry at end of array\n-      \/\/ to store handle, inode\/devid with refcount=1\n-      result = ::dlopen(filename, dflags);\n-      if (result != nullptr) {\n-        g_handletable_used++;\n-        g_handletable[i].handle = result;\n-        g_handletable[i].inode = libstat.st_ino;\n-        g_handletable[i].devid = libstat.st_dev;\n-        g_handletable[i].refcount = 1;\n-      }\n-    }\n-    pthread_mutex_unlock ( &g_handletable_mutex);\n-  }\n+  result = os::Aix::dlopen(filename, dflags);\n@@ -1223,36 +1177,0 @@\n-\/\/ specific AIX version for ::dlclose(), which handles the struct g_handletable\n-\/\/ filled by os::dll_load()\n-int os::Aix::dlclose(void* lib) {\n-  int i = 0, res;\n-  pthread_mutex_lock(&g_handletable_mutex);\n-  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n-  for (i = 0; i < g_handletable_used; i++) {\n-    if (g_handletable[i].handle == lib) {\n-      \/\/ handle found, decrease refcount\n-      g_handletable[i].refcount--;\n-      if (g_handletable[i].refcount > 0) {\n-        \/\/ if refcount is still >0 then we have to keep library and return\n-        pthread_mutex_unlock(&g_handletable_mutex);\n-        return 0;\n-      }\n-      \/\/ refcount == 0, so we have to ::dlclose() the lib\n-      \/\/ and delete the entry from the array.\n-      res = ::dlclose(lib);\n-      g_handletable_used--;\n-      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n-      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n-      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n-      if (i < g_handletable_used) {\n-        g_handletable[i] = g_handletable[g_handletable_used];\n-      }\n-      pthread_mutex_unlock(&g_handletable_mutex);\n-      return res;\n-    }\n-  }\n-  pthread_mutex_unlock(&g_handletable_mutex);\n-  \/\/ if we reach this point, the library was not created by os::dll_load()\n-  \/\/ so nag and perform the plain ::dlclose();\n-  assert(false, \"os::AIX::dlclose() library was not loaded by os::dll_load()\");\n-  return ::dlclose(lib);\n-} \/\/ end: os::AIX::dlclose()\n-\n@@ -3177,0 +3095,88 @@\n+\n+\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+\/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n+\/\/ opened a second time, as it is implemented on other platforms.\n+void* os::Aix::dlopen(const char* filename, int Flags) {\n+  void* result;\n+  struct stat64x libstat;\n+\n+  if (os::Aix::stat64x_via_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+    result = ::dlopen(filename, Flags);\n+    if (result != nullptr) {\n+      assert(false, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+    }\n+  }\n+  else {\n+    int i = 0;\n+    pthread_mutex_lock(&g_handletable_mutex);\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if (g_handletable[i].handle &&\n+          g_handletable[i].inode == libstat.st_ino &&\n+          g_handletable[i].devid == libstat.st_dev) {\n+        g_handletable[i].refcount++;\n+        result = g_handletable[i].handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not still loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ Array is already full. No place for new handle. Cry and give up.\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        assert(false, \"max_handletable reached\");\n+        return nullptr;\n+      }\n+      \/\/ library not still loaded and still place in array, so load library\n+      \/\/ and if successful, create new entry at end of array\n+      \/\/ to store handle, inode\/devid with refcount=1\n+      result = ::dlopen(filename, Flags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        g_handletable[i].handle = result;\n+        g_handletable[i].inode = libstat.st_ino;\n+        g_handletable[i].devid = libstat.st_dev;\n+        g_handletable[i].refcount = 1;\n+      }\n+    }\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  }\n+  return result;\n+}\n+\n+int os::Aix::dlclose(void* lib) {\n+  int i = 0, res;\n+  pthread_mutex_lock(&g_handletable_mutex);\n+  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+  for (i = 0; i < g_handletable_used; i++) {\n+    if (g_handletable[i].handle == lib) {\n+      \/\/ handle found, decrease refcount\n+      g_handletable[i].refcount--;\n+      if (g_handletable[i].refcount > 0) {\n+        \/\/ if refcount is still >0 then we have to keep library and return\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        return 0;\n+      }\n+      \/\/ refcount == 0, so we have to ::dlclose() the lib\n+      \/\/ and delete the entry from the array.\n+      res = ::dlclose(lib);\n+      g_handletable_used--;\n+      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+      if (i < g_handletable_used) {\n+        g_handletable[i] = g_handletable[g_handletable_used];\n+      }\n+      pthread_mutex_unlock(&g_handletable_mutex);\n+      return res;\n+    }\n+  }\n+  pthread_mutex_unlock(&g_handletable_mutex);\n+  \/\/ if we reach this point, the library was not created by os::dll_load()\n+  \/\/ so nag and perform the plain ::dlclose();\n+  assert(false, \"os::AIX::dlclose() library was not loaded by os::dll_load()\");\n+  return ::dlclose(lib);\n+} \/\/ end: os::AIX::dlclose()\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":89,"deletions":83,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -181,2 +181,4 @@\n-  \/\/ specific AIX version for ::dlclose(), which handles the struct g_handletable\n-  \/\/ filled by os::dll_load()\n+  \/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+  \/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n+  \/\/ opened a second time, as it is implemented on other platforms.\n+  static void* dlopen(const char* filename, int Flags);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}