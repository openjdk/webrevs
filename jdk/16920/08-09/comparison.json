{"files":[{"patch":"@@ -914,1 +914,1 @@\n-constexpr int max_handletable = 1024;\n+static int max_handletable = 0;\n@@ -916,1 +916,3 @@\n-static struct handletableentry g_handletable[max_handletable] = {{0, 0, 0, 0}};\n+\/\/ We start with an empty array. At first use we will dynamically allocate memory for 128 entries.\n+\/\/ If this table is full we dynamically reallocate a memory reagion of double size, and so on.\n+static struct handletableentry* p_handletable = nullptr;\n@@ -1032,1 +1034,1 @@\n-\/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n+\/\/ This way we mimic dl handle equality for a library\n@@ -1045,0 +1047,2 @@\n+    *error_report = \"Could not load module .\\nSystem error: No such file or directory\";\n+    return nullptr;\n@@ -1052,5 +1056,5 @@\n-      if (g_handletable[i].handle &&\n-          g_handletable[i].inode == libstat.st_ino &&\n-          g_handletable[i].devid == libstat.st_dev) {\n-        g_handletable[i].refcount++;\n-        result = g_handletable[i].handle;\n+      if ((p_handletable + i)->handle &&\n+          (p_handletable + i)->inode == libstat.st_ino &&\n+          (p_handletable + i)->devid == libstat.st_dev) {\n+        (p_handletable + i)->refcount++;\n+        result = (p_handletable + i)->handle;\n@@ -1064,4 +1068,22 @@\n-        \/\/ Array is already full. No place for new handle. Cry and give up.\n-        *error_report = \"dlopen: too many libraries loaded\";\n-        assert(false, \"max_handletable reached\");\n-        return nullptr;\n+        \/\/ No place in array anymore.\n+        if (max_handletable == 0) {\n+          \/\/ First time we allocate memory for 128 Entries\n+          char* ptmp = (char*)::malloc(128 * sizeof(struct handletableentry));\n+          assert(ptmp != 0, \"no more memory for handletable\");\n+          if (ptmp == nullptr) {\n+            *error_report = \"dlopen: no more memory for handletable\";\n+            return nullptr;\n+          }\n+          max_handletable = 128;\n+          p_handletable = (struct handletableentry*)ptmp;\n+        } else {\n+          \/\/ we already use malloced memory, just double the size\n+          char* ptmp = (char*)::realloc(p_handletable, 2 * max_handletable * sizeof(struct handletableentry));\n+          assert(ptmp != 0, \"no more memory for handletable\");\n+          if (ptmp == nullptr) {\n+            *error_report = \"dlopen: no more memory for handletable\";\n+            return nullptr;\n+          }\n+          max_handletable *= 2;\n+          p_handletable = (struct handletableentry*)ptmp;\n+        }\n@@ -1073,4 +1095,4 @@\n-        g_handletable[i].handle = result;\n-        g_handletable[i].inode = libstat.st_ino;\n-        g_handletable[i].devid = libstat.st_dev;\n-        g_handletable[i].refcount = 1;\n+        (p_handletable + i)->handle = result;\n+        (p_handletable + i)->inode = libstat.st_ino;\n+        (p_handletable + i)->devid = libstat.st_dev;\n+        (p_handletable + i)->refcount = 1;\n@@ -1103,1 +1125,1 @@\n-      if (g_handletable[i].handle == libhandle) {\n+      if ((p_handletable + i)->handle == libhandle) {\n@@ -1105,3 +1127,3 @@\n-        assert(g_handletable[i].refcount > 0, \"Sanity\");\n-        g_handletable[i].refcount--;\n-        if (g_handletable[i].refcount > 0) {\n+        assert((p_handletable + i)->refcount > 0, \"Sanity\");\n+        (p_handletable + i)->refcount--;\n+        if ((p_handletable + i)->refcount > 0) {\n@@ -1143,2 +1165,2 @@\n-          g_handletable[i] = g_handletable[g_handletable_used];\n-          g_handletable[g_handletable_used].handle = nullptr;\n+          *(p_handletable + i) = *(p_handletable + g_handletable_used);\n+          (p_handletable + g_handletable_used)->handle = nullptr;\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":44,"deletions":22,"binary":false,"changes":66,"status":"modified"}]}