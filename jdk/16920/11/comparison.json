{"files":[{"patch":"@@ -1121,1 +1121,3 @@\n-    ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    }\n@@ -1136,0 +1138,1 @@\n+  const char* error_report = nullptr;\n@@ -1137,1 +1140,1 @@\n-  result = ::dlopen(filename, dflags);\n+  result = Aix_dlopen(filename, dflags, &error_report);\n@@ -1146,1 +1149,0 @@\n-    const char* error_report = ::dlerror();\n@@ -3034,28 +3036,0 @@\n-\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-int os::Aix::stat64x_via_LIBPATH(const char* path, struct stat64x* stat) {\n-  if (path[0] == '\/' ||\n-      (path[0] == '.' && (path[1] == '\/' ||\n-                          (path[1] == '.' && path[2] == '\/')))) {\n-    return stat64x(path, stat);\n-  }\n-\n-  const char* env = getenv(\"LIBPATH\");\n-  if (env == nullptr || *env == 0)\n-    return -1;\n-\n-  int ret = -1;\n-  size_t libpathlen = strlen(env);\n-  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n-  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) + 1, mtServiceability);\n-  char *saveptr, *token;\n-  strcpy(libpath, env);\n-  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n-    sprintf(combined, \"%s\/%s\", token, path);\n-    if (0 == (ret = stat64x(combined, stat)))\n-      break;\n-  }\n-\n-  FREE_C_HEAP_ARRAY(char*, combined);\n-  FREE_C_HEAP_ARRAY(char*, libpath);\n-  return ret;\n-}\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -178,2 +178,0 @@\n-  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-  static int stat64x_via_LIBPATH(const char* path, struct stat64x* stat);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/\/ needs to be defined first, so that the implicit loaded xcoff.h header defines\n+\/\/ the right structures to analyze the loader header of 64 Bit executable files\n+\/\/ this is needed for rtv_linkedin_libpath() to get the linked (burned) in library\n+\/\/ search path of an XCOFF executable\n+#define __XCOFF64__\n+#include <xcoff.h>\n@@ -894,0 +900,272 @@\n+\n+\/\/ variables needed to emulate linux behavior in os::dll_load() if library is loaded twice\n+static pthread_mutex_t g_handletable_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+struct TableLocker {\n+  TableLocker() { pthread_mutex_lock(&g_handletable_mutex); }\n+  ~TableLocker() { pthread_mutex_unlock(&g_handletable_mutex); }\n+};\n+struct handletableentry{\n+    void*   handle;\n+    ino64_t inode;\n+    dev64_t devid;\n+    uint    refcount;\n+};\n+constexpr unsigned init_num_handles = 128;\n+static unsigned max_handletable = 0;\n+static unsigned g_handletable_used = 0;\n+\/\/ We start with an empty array. At first use we will dynamically allocate memory for 128 entries.\n+\/\/ If this table is full we dynamically reallocate a memory reagion of double size, and so on.\n+static struct handletableentry* p_handletable = nullptr;\n+\n+\/\/ get the library search path burned in to the executable file during linking\n+\/\/ If the libpath cannot be retrieved return an empty path\n+static const char* rtv_linkedin_libpath() {\n+  constexpr int bufsize = 4096;\n+  static char buffer[bufsize];\n+  static const char* libpath = 0;\n+\n+  \/\/ we only try to retrieve the libpath once. After that try we\n+  \/\/ let libpath point to buffer, which then contains a valid libpath\n+  \/\/ or an empty string\n+  if (libpath != nullptr) {\n+    return libpath;\n+  }\n+\n+  \/\/ retrieve the path to the currently running executable binary\n+  \/\/ to open it\n+  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  FILE* f = nullptr;\n+  struct xcoffhdr the_xcoff;\n+  struct scnhdr the_scn;\n+  struct ldhdr the_ldr;\n+  constexpr size_t xcoffsz = FILHSZ + _AOUTHSZ_EXEC;\n+  STATIC_ASSERT(sizeof(the_xcoff) == xcoffsz);\n+  STATIC_ASSERT(sizeof(the_scn) == SCNHSZ);\n+  STATIC_ASSERT(sizeof(the_ldr) == LDHDRSZ);\n+  \/\/ read the generic XCOFF header and analyze the substructures\n+  \/\/ to find the burned in libpath. In any case of error perform the assert\n+  if (nullptr == (f = fopen(buffer, \"r\")) ||\n+      xcoffsz != fread(&the_xcoff, 1, xcoffsz, f) ||\n+      the_xcoff.filehdr.f_magic != U64_TOCMAGIC ||\n+      0 != fseek(f, (FILHSZ + the_xcoff.filehdr.f_opthdr + (the_xcoff.aouthdr.o_snloader -1)*SCNHSZ), SEEK_SET) ||\n+      SCNHSZ != fread(&the_scn, 1, SCNHSZ, f) ||\n+      0 != strcmp(the_scn.s_name, \".loader\") ||\n+      0 != fseek(f, the_scn.s_scnptr, SEEK_SET) ||\n+      LDHDRSZ != fread(&the_ldr, 1, LDHDRSZ, f) ||\n+      0 != fseek(f, the_scn.s_scnptr + the_ldr.l_impoff, SEEK_SET) ||\n+      0 == fread(buffer, 1, bufsize, f)) {\n+    buffer[0] = 0;\n+    assert(false, \"could not retrieve burned in library path from executables loader section\");\n+  }\n+\n+  if (f) {\n+    fclose(f);\n+  }\n+  libpath = buffer;\n+\n+  return libpath;\n+}\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+static bool search_file_in_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path == nullptr)\n+    return false;\n+\n+  char* path2 = os::strdup(path);\n+  \/\/ if exist, strip off trailing (shr_64.o) or similar\n+  char* substr;\n+  if (path2[strlen(path2) - 1] == ')' && (substr = strrchr(path2, '('))) {\n+    *substr = 0;\n+  }\n+\n+  bool ret = false;\n+  \/\/ If FilePath contains a slash character, FilePath is used directly,\n+  \/\/ and no directories are searched.\n+  \/\/ But if FilePath does not start with \/ or . we have to prepend it with .\/\n+  if (strchr(path2, '\/')) {\n+    stringStream combined;\n+    if (*path2 == '\/' || *path2 == '.') {\n+      combined.print(\"%s\", path2);\n+    } else {\n+      combined.print(\".\/%s\", path2);\n+    }\n+    ret = (0 == stat64x(combined.base(), stat));\n+    os::free(path2);\n+    return ret;\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH, try with LD_LIBRARY_PATH\n+    env = getenv(\"LD_LIBRARY_PATH\");\n+  }\n+\n+  stringStream Libpath;\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH or LD_LIBRARY_PATH given -> try only with burned in libpath\n+    Libpath.print(\"%s\", rtv_linkedin_libpath());\n+  } else if (*env == 0) {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given but empty -> try first with burned\n+    \/\/  in libpath and with current working directory second\n+    Libpath.print(\"%s:.\", rtv_linkedin_libpath());\n+  } else {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given with content -> try first with\n+    \/\/ LIBPATH or LD_LIBRARY_PATH and second with burned in libpath.\n+    \/\/ No check against current working directory\n+    Libpath.print(\"%s:%s\", env, rtv_linkedin_libpath());\n+  }\n+\n+  char* libpath = os::strdup(Libpath.base());\n+\n+  char *saveptr, *token;\n+  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n+    stringStream combined;\n+    combined.print(\"%s\/%s\", token, path2);\n+    if ((ret = (0 == stat64x(combined.base(), stat))))\n+      break;\n+  }\n+\n+  os::free(libpath);\n+  os::free(path2);\n+  return ret;\n+}\n+\n+\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+\/\/ This way we mimic dl handle equality for a library\n+\/\/ opened a second time, as it is implemented on other platforms.\n+void* Aix_dlopen(const char* filename, int Flags, const char** error_report) {\n+  assert(error_report != nullptr, \"error_report is nullptr\");\n+  void* result;\n+  struct stat64x libstat;\n+\n+  if (false == search_file_in_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+  #ifdef ASSERT\n+    result = ::dlopen(filename, Flags);\n+    assert(result == nullptr, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+  #endif\n+    *error_report = \"Could not load module .\\nSystem error: No such file or directory\";\n+    return nullptr;\n+  }\n+  else {\n+    unsigned i = 0;\n+    TableLocker lock;\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if ((p_handletable + i)->handle &&\n+          (p_handletable + i)->inode == libstat.st_ino &&\n+          (p_handletable + i)->devid == libstat.st_dev) {\n+        (p_handletable + i)->refcount++;\n+        result = (p_handletable + i)->handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not yet loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ No place in array anymore; increase array.\n+        unsigned new_max = MAX2(max_handletable * 2, init_num_handles);\n+        struct handletableentry* new_tab = (struct handletableentry*)::realloc(p_handletable, new_max * sizeof(struct handletableentry));\n+        assert(new_tab != nullptr, \"no more memory for handletable\");\n+        if (new_tab == nullptr) {\n+          *error_report = \"dlopen: no more memory for handletable\";\n+          return nullptr;\n+        }\n+        max_handletable = new_max;\n+        p_handletable = new_tab;\n+      }\n+      \/\/ Library not yet loaded; load it, then store its handle in handle table\n+      result = ::dlopen(filename, Flags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        (p_handletable + i)->handle = result;\n+        (p_handletable + i)->inode = libstat.st_ino;\n+        (p_handletable + i)->devid = libstat.st_dev;\n+        (p_handletable + i)->refcount = 1;\n+      }\n+      else {\n+        \/\/ error analysis when dlopen fails\n+        *error_report = ::dlerror();\n+        if (*error_report == nullptr) {\n+          *error_report = \"dlerror returned no error description\";\n+        }\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+  unsigned i = 0;\n+  bool res = false;\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  {\n+    TableLocker lock;\n+    \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if ((p_handletable + i)->handle == libhandle) {\n+        \/\/ handle found, decrease refcount\n+        assert((p_handletable + i)->refcount > 0, \"Sanity\");\n+        (p_handletable + i)->refcount--;\n+        if ((p_handletable + i)->refcount > 0) {\n+          \/\/ if refcount is still >0 then we have to keep library and just return true\n+          return true;\n+        }\n+        \/\/ refcount == 0, so we have to ::dlclose() the lib\n+        \/\/ and delete the entry from the array.\n+        break;\n+      }\n+    }\n+\n+    \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n+    \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n+    \/\/ the error handling. In the first case we then also have to delete the entry from the array\n+    \/\/ while in the second case we simply have to nag.\n+    res = (0 == ::dlclose(libhandle));\n+    if (!res) {\n+      \/\/ error analysis when dlopen fails\n+      const char* error_report = ::dlerror();\n+      if (error_report == nullptr) {\n+        error_report = \"dlerror returned no error description\";\n+      }\n+      if (ebuf != nullptr && ebuflen > 0) {\n+        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      }\n+      assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n+    }\n+\n+    if (i < g_handletable_used) {\n+      if (res) {\n+        \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n+        \/\/ so delete entry from array\n+        g_handletable_used--;\n+        \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+        \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+        \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+        if (i < g_handletable_used) {\n+          *(p_handletable + i) = *(p_handletable + g_handletable_used);\n+          (p_handletable + g_handletable_used)->handle = nullptr;\n+        }\n+      }\n+    }\n+    else {\n+      \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n+      \/\/ therefore nag\n+      assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n+    }\n+  }\n+\n+  \/\/ Update the dll cache\n+  LoadedLibraries::reload();\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":278,"deletions":0,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+void* Aix_dlopen(const char* filename, int Flags, const char** error_report);\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2558,0 +2558,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -5411,0 +5411,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"os_aix.hpp\"\n@@ -734,1 +735,0 @@\n-  int res = ::dlclose(lib);\n@@ -736,1 +736,4 @@\n-  if (res == 0) {\n+  char ebuf[1024];\n+  bool res = os::pd_dll_unload(lib, ebuf, sizeof(ebuf));\n+\n+  if (res) {\n@@ -742,5 +745,0 @@\n-    const char* error_report = ::dlerror();\n-    if (error_report == nullptr) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-\n@@ -748,1 +746,1 @@\n-                            l_path, p2i(lib), error_report);\n+                            l_path, p2i(lib), ebuf);\n@@ -750,2 +748,2 @@\n-                  l_path, p2i(lib), error_report);\n-    JFR_ONLY(unload_event.set_error_msg(error_report);)\n+                  l_path, p2i(lib), ebuf);\n+    JFR_ONLY(unload_event.set_error_msg(ebuf);)\n@@ -753,2 +751,0 @@\n-  \/\/ Update the dll cache\n-  AIX_ONLY(LoadedLibraries::reload());\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -78,4 +78,0 @@\n-#ifdef AIX\n-  _inode(0),\n-  _device(0),\n-#endif\n@@ -126,18 +122,0 @@\n-#ifdef AIX\n-void JvmtiAgent::set_inode(ino64_t inode) {\n-  _inode = inode;\n-}\n-\n-void JvmtiAgent::set_device(dev64_t device) {\n-  _device = device;\n-}\n-\n-ino64_t JvmtiAgent::inode() const {\n-  return _inode;\n-}\n-\n-dev64_t JvmtiAgent::device() const {\n-  return _device;\n-}\n-#endif\n-\n@@ -298,14 +276,0 @@\n-#ifdef AIX\n-\/\/ save the inode and device of the library's file as a signature. This signature can be used\n-\/\/ in the same way as the library handle as a signature on other platforms.\n-static void save_library_signature(JvmtiAgent* agent, const char* name) {\n-  struct stat64x libstat;\n-  if (0 == os::Aix::stat64x_via_LIBPATH(name, &libstat)) {\n-    agent->set_inode(libstat.st_ino);\n-    agent->set_device(libstat.st_dev);\n-  } else {\n-    assert(false, \"stat64x failed\");\n-  }\n-}\n-#endif\n-\n@@ -321,1 +285,0 @@\n-  AIX_ONLY(if (library != nullptr) save_library_signature(agent, agent->name());)\n@@ -334,1 +297,0 @@\n-    AIX_ONLY(if (library != nullptr) save_library_signature(agent, &buffer[0]);)\n@@ -340,1 +302,0 @@\n-      AIX_ONLY(save_library_signature(agent, &buffer[0]);)\n@@ -558,3 +519,0 @@\n-  #ifdef AIX\n-    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(agent->device(), agent->inode());\n-  #else\n@@ -562,1 +520,0 @@\n-  #endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -46,4 +46,0 @@\n-#ifdef AIX\n-  ino64_t _inode;\n-  dev64_t _device;\n-#endif\n@@ -87,6 +83,0 @@\n-#ifdef AIX\n-  void set_inode(ino64_t inode);\n-  void set_device(dev64_t device);\n-  unsigned long inode() const;\n-  unsigned long device() const;\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,13 +246,0 @@\n-#ifdef AIX\n-bool JvmtiAgentList::is_dynamic_lib_loaded(dev64_t device, ino64_t inode) {\n-  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n-  while (it.has_next()) {\n-    JvmtiAgent* const agent = it.next();\n-    if (!agent->is_static_lib() && device != 0 && inode != 0 &&\n-        agent->device() == device && agent->inode() == inode) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,3 +81,0 @@\n-#ifdef AIX\n-  static bool is_dynamic_lib_loaded(dev64_t device, ino64_t inode);\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1066,0 +1066,1 @@\n+  static bool pd_dll_unload(void* libhandle, char* ebuf, int ebuflen);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}