{"files":[{"patch":"@@ -30,2 +30,0 @@\n-#define __XCOFF32__\n-#define __XCOFF64__\n@@ -195,13 +193,0 @@\n-\/\/ variables needed to emulate linux behavior in os::dll_load() if library is loaded twice\n-static pthread_mutex_t g_handletable_mutex = PTHREAD_MUTEX_INITIALIZER;\n-\n-struct handletableentry{\n-    void*   handle;\n-    ino64_t inode;\n-    dev64_t devid;\n-    uint    refcount;\n-};\n-constexpr int max_handletable = 1024;\n-static int g_handletable_used = 0;\n-static struct handletableentry g_handletable[max_handletable] = {{0, 0, 0, 0}};\n-\n@@ -1128,275 +1113,0 @@\n-\/\/ get the library search path burned in to the executable file during linking\n-\/\/ If the libpath cannot be retrieved return an empty path\n-static const char* rtv_linkedin_libpath() {\n-  static char buffer[4096];\n-  static const char* libpath = 0;\n-\n-  if (libpath)\n-    return libpath;\n-\n-  char pgmpath[32+1];\n-  \/\/ retrieve the path to the currently running executable binary\n-  snprintf(pgmpath, 32, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n-  \/\/ open the currently running executable binary\n-  FILE *f = fopen(pgmpath, \"r\");\n-  \/\/ read the generic XCOFF header and analyze the substructures\n-  \/\/ to find the burned in libpath\n-  fread(buffer, 1, FILHSZ_64 + _AOUTHSZ_EXEC_64, f);\n-\n-  if (((struct filehdr*)buffer)->f_magic == U802TOCMAGIC ) {\n-    \/\/ __XCOFF32__\n-    struct xcoffhdr xcoff;\n-    struct scnhdr scn;\n-    struct ldhdr ldr;\n-    memcpy((char*)&xcoff, buffer, FILHSZ + _AOUTHSZ_EXEC);\n-    int ldroffset = FILHSZ + xcoff.filehdr.f_opthdr + (xcoff.aouthdr.o_snloader -1)*SCNHSZ;\n-    fseek (f, ldroffset, SEEK_SET);\n-    fread(buffer, 1, SCNHSZ, f);\n-    memcpy((char*)&scn, buffer, SCNHSZ);\n-    if (strcmp(scn.s_name, \".loader\")) {\n-      buffer[0] = 0;\n-      libpath = buffer;\n-      fclose(f);\n-      return libpath;\n-    }\n-    fseek (f, scn.s_scnptr, SEEK_SET);\n-    fread(buffer, 1, LDHDRSZ, f);\n-    memcpy((char*)&ldr, buffer, LDHDRSZ);\n-    fseek (f, scn.s_scnptr + ldr.l_impoff, SEEK_SET);\n-    fread(buffer, 1, 4096, f);\n-  }\n-  else if (((struct filehdr*)buffer)->f_magic == U64_TOCMAGIC ) {\n-    \/\/ __XCOFF64__\n-    struct _S_(xcoffhdr) xcoff64;\n-    struct _S_(scnhdr) scn64;\n-    struct _S_(ldhdr) ldr64;\n-    memcpy((char*)&xcoff64, buffer, FILHSZ_64 + _AOUTHSZ_EXEC_64);\n-    int ldroffset = FILHSZ_64 + xcoff64.filehdr.f_opthdr + (xcoff64.aouthdr.o_snloader -1)*SCNHSZ_64;\n-    fseek (f, ldroffset, SEEK_SET);\n-    fread(buffer, 1, SCNHSZ_64, f);\n-    memcpy((char*)&scn64, buffer, SCNHSZ_64);\n-    if (strcmp(scn64.s_name, \".loader\")) {\n-      buffer[0] = 0;\n-      libpath = buffer;\n-      fclose(f);\n-      return libpath;\n-    }\n-    fseek (f, scn64.s_scnptr, SEEK_SET);\n-    fread(buffer, 1, LDHDRSZ_64, f);\n-    memcpy((char*)&ldr64, buffer, LDHDRSZ_64);\n-    fseek (f, scn64.s_scnptr + ldr64.l_impoff, SEEK_SET);\n-    fread(buffer, 1, 4096, f);\n-  }\n-  else\n-    buffer[0] = 0;\n-\n-  fclose(f);\n-  libpath = buffer;\n-\n-  return libpath;\n-\n-}\n-\n-\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n-static bool search_file_in_LIBPATH(const char* path, struct stat64x* stat) {\n-  if (path == nullptr)\n-    return false;\n-\n-  char* path2 = os::strdup (path);\n-  \/\/ if exist, strip off trailing (shr_64.o) or similar\n-  char* substr;\n-  if (path2[strlen(path2) - 1] == ')' && (substr = strrchr(path2, '('))) {\n-    *substr = 0;\n-  }\n-\n-  bool ret = false;\n-  \/\/ If FilePath contains a slash character, FilePath is used directly,\n-  \/\/ and no directories are searched.\n-  \/\/ But if FilePath does not start with \/ or . we have to prepend it with .\/\n-  if (strchr(path2, '\/')) {\n-    stringStream combined;\n-    if (*path2 == '\/' || *path2 == '.')\n-      combined.print(\"%s\", path2);\n-    else\n-      combined.print(\".\/%s\", path2);\n-    ret = (0 == stat64x(combined.base(), stat));\n-    os::free (path2);\n-    return ret;\n-  }\n-\n-  const char* env = getenv(\"LIBPATH\");\n-  if (env == nullptr) {\n-    \/\/ no LIBPATH, try with LD_LIBRARY_PATH\n-    env = getenv(\"LD_LIBRARY_PATH\");\n-  }\n-\n-  stringStream Libpath;\n-  if (env == nullptr) {\n-    \/\/ no LIBPATH or LD_LIBRARY_PATH given -> try only with burned in libpath\n-    Libpath.print(\"%s\", rtv_linkedin_libpath());\n-  } else if (*env == 0) {\n-    \/\/ LIBPATH or LD_LIBRARY_PATH given but empty -> try first with burned\n-    \/\/  in libpath and with current working directory second\n-    Libpath.print(\"%s:.\", rtv_linkedin_libpath());\n-  } else {\n-    \/\/ LIBPATH or LD_LIBRARY_PATH given with content -> try first with\n-    \/\/ LIBPATH or LD_LIBRARY_PATH and second with burned in libpath.\n-    \/\/ No check against current working directory\n-    Libpath.print(\"%s:%s\", env, rtv_linkedin_libpath());\n-  }\n-\n-  char* libpath = os::strdup (Libpath.base());\n-\n-  char *saveptr, *token;\n-  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n-    stringStream combined;\n-    combined.print(\"%s\/%s\", token, path2);\n-    if ((ret = (0 == stat64x(combined.base(), stat))))\n-      break;\n-  }\n-\n-  os::free (libpath);\n-  os::free (path2);\n-  return ret;\n-}\n-\n-\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n-\/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n-\/\/ opened a second time, as it is implemented on other platforms.\n-void* Aix_dlopen(const char* filename, int Flags, char *ebuf, int ebuflen) {\n-  void* result;\n-  struct stat64x libstat;\n-\n-  if (false == search_file_in_LIBPATH(filename, &libstat)) {\n-    \/\/ file with filename does not exist\n-  #ifdef ASSERT\n-    result = ::dlopen(filename, Flags);\n-    assert(result == nullptr, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n-  #endif\n-  }\n-  else {\n-    int i = 0;\n-    pthread_mutex_lock(&g_handletable_mutex);\n-    \/\/ check if library belonging to filename is already loaded.\n-    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n-    for (i = 0; i < g_handletable_used; i++) {\n-      if (g_handletable[i].handle &&\n-          g_handletable[i].inode == libstat.st_ino &&\n-          g_handletable[i].devid == libstat.st_dev) {\n-        g_handletable[i].refcount++;\n-        result = g_handletable[i].handle;\n-        break;\n-      }\n-    }\n-    if (i == g_handletable_used) {\n-      \/\/ library not yet loaded. Check if there is space left in array\n-      \/\/ to store new ::dlopen() handle\n-      if (g_handletable_used == max_handletable) {\n-        \/\/ Array is already full. No place for new handle. Cry and give up.\n-        pthread_mutex_unlock(&g_handletable_mutex);\n-        if (ebuf != nullptr && ebuflen > 0) {\n-          ::strncpy(ebuf, \"dlopen: too many libraries loaded\", ebuflen - 1);\n-        }\n-        assert(false, \"max_handletable reached\");\n-        return nullptr;\n-      }\n-      \/\/ Library not yet loaded; load it, then store its handle in handle table\n-      result = ::dlopen(filename, Flags);\n-      if (result != nullptr) {\n-        g_handletable_used++;\n-        g_handletable[i].handle = result;\n-        g_handletable[i].inode = libstat.st_ino;\n-        g_handletable[i].devid = libstat.st_dev;\n-        g_handletable[i].refcount = 1;\n-      }\n-      else {\n-        \/\/ error analysis when dlopen fails\n-        const char* error_report = ::dlerror();\n-        if (error_report == nullptr) {\n-          error_report = \"dlerror returned no error description\";\n-        }\n-        if (ebuf != nullptr && ebuflen > 0) {\n-          snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n-        }\n-      }\n-    }\n-    pthread_mutex_unlock(&g_handletable_mutex);\n-  }\n-  return result;\n-}\n-\n-bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n-  int i = 0;\n-  bool res = false;\n-\n-  if (ebuf && ebuflen > 0) {\n-    ebuf[0] = '\\0';\n-    ebuf[ebuflen - 1] = '\\0';\n-  }\n-\n-  pthread_mutex_lock(&g_handletable_mutex);\n-  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n-  for (i = 0; i < g_handletable_used; i++) {\n-    if (g_handletable[i].handle == libhandle) {\n-      \/\/ handle found, decrease refcount\n-      g_handletable[i].refcount--;\n-      if (g_handletable[i].refcount > 0) {\n-        \/\/ if refcount is still >0 then we have to keep library and just return true\n-        pthread_mutex_unlock(&g_handletable_mutex);\n-        return true;\n-      }\n-      \/\/ refcount == 0, so we have to ::dlclose() the lib\n-      \/\/ and delete the entry from the array.\n-      break;\n-    }\n-  }\n-\n-  \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n-  \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n-  \/\/ the error handling. In the first case we then also have to delete the entry from the array\n-  \/\/ while in the second case we simply have to nag.\n-  res = (0 == ::dlclose(libhandle));\n-  if (!res) {\n-    \/\/ error analysis when dlopen fails\n-    const char* error_report = ::dlerror();\n-    if (error_report == nullptr) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-    if (ebuf != nullptr && ebuflen > 0) {\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n-    }\n-  #ifdef ASSERT\n-    pthread_mutex_unlock(&g_handletable_mutex);\n-  #endif\n-    assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n-  }\n-\n-  if (i < g_handletable_used) {\n-    if (res) {\n-      \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n-      \/\/ so delete entry from array\n-      g_handletable_used--;\n-      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n-      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n-      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n-      if (i < g_handletable_used) {\n-        g_handletable[i] = g_handletable[g_handletable_used];\n-      }\n-    }\n-  }\n-  else {\n-  #ifdef ASSERT\n-    pthread_mutex_unlock(&g_handletable_mutex);\n-  #endif\n-    \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n-    \/\/ therefore nag\n-    assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n-  }\n-\n-  pthread_mutex_unlock(&g_handletable_mutex);\n-\n-  \/\/ Update the dll cache\n-  LoadedLibraries::reload();\n-\n-  return res;\n-} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":290,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/\/ needs to be defined first, so that the implicit loaded xcoff.h header defines\n+\/\/ the right structures to analyze the loader header of 32 and 64 Bit executable files\n+\/\/ this is needed for rtv_linkedin_libpath() to get the linked (burned) in library\n+\/\/ search path of an XCOFF executable\n+#define __XCOFF64__\n+#include <xcoff.h>\n@@ -894,0 +900,264 @@\n+\n+\/\/ variables needed to emulate linux behavior in os::dll_load() if library is loaded twice\n+static pthread_mutex_t g_handletable_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+struct handletableentry{\n+    void*   handle;\n+    ino64_t inode;\n+    dev64_t devid;\n+    uint    refcount;\n+};\n+constexpr int max_handletable = 1024;\n+static int g_handletable_used = 0;\n+static struct handletableentry g_handletable[max_handletable] = {{0, 0, 0, 0}};\n+\n+\/\/ get the library search path burned in to the executable file during linking\n+\/\/ If the libpath cannot be retrieved return an empty path\n+static const char* rtv_linkedin_libpath() {\n+  static char buffer[4096];\n+  static const char* libpath = 0;\n+\n+  \/\/ we only try to retrieve the libpath once. After that try we\n+  \/\/ let libpath point to buffer, which then contains a valid libpath\n+  \/\/ or an empty string\n+  if (libpath) {\n+    return libpath;\n+  }\n+\n+  \/\/ retrieve the path to the currently running executable binary\n+  \/\/ to open it\n+  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  FILE* f = 0;\n+  struct xcoffhdr the_xcoff;\n+  struct scnhdr the_scn;\n+  struct ldhdr the_ldr;\n+  size_t sz = FILHSZ + _AOUTHSZ_EXEC;\n+  \/\/ read the generic XCOFF header and analyze the substructures\n+  \/\/ to find the burned in libpath. In any case of error perform the assert\n+  if (nullptr == (f = fopen(buffer, \"r\")) ||\n+      sz != fread(&the_xcoff, 1, sz, f) ||\n+      the_xcoff.filehdr.f_magic != U64_TOCMAGIC ||\n+      0 != fseek(f, (FILHSZ + the_xcoff.filehdr.f_opthdr + (the_xcoff.aouthdr.o_snloader -1)*SCNHSZ), SEEK_SET) ||\n+      SCNHSZ != fread(&the_scn, 1, SCNHSZ, f) ||\n+      0 != strcmp(the_scn.s_name, \".loader\") ||\n+      0 != fseek(f, the_scn.s_scnptr, SEEK_SET) ||\n+      LDHDRSZ != fread(&the_ldr, 1, LDHDRSZ, f) ||\n+      0 != fseek(f, the_scn.s_scnptr + the_ldr.l_impoff, SEEK_SET) ||\n+      0 == fread(buffer, 1, 4096, f)) {\n+    buffer[0] = 0;\n+    assert(false, \"could not retrieve burned in library path from executables loader section\");\n+  }\n+\n+  if (f) {\n+    fclose(f);\n+  }\n+  libpath = buffer;\n+\n+  return libpath;\n+\n+}\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+static bool search_file_in_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path == nullptr)\n+    return false;\n+\n+  char* path2 = os::strdup (path);\n+  \/\/ if exist, strip off trailing (shr_64.o) or similar\n+  char* substr;\n+  if (path2[strlen(path2) - 1] == ')' && (substr = strrchr(path2, '('))) {\n+    *substr = 0;\n+  }\n+\n+  bool ret = false;\n+  \/\/ If FilePath contains a slash character, FilePath is used directly,\n+  \/\/ and no directories are searched.\n+  \/\/ But if FilePath does not start with \/ or . we have to prepend it with .\/\n+  if (strchr(path2, '\/')) {\n+    stringStream combined;\n+    if (*path2 == '\/' || *path2 == '.')\n+      combined.print(\"%s\", path2);\n+    else\n+      combined.print(\".\/%s\", path2);\n+    ret = (0 == stat64x(combined.base(), stat));\n+    os::free (path2);\n+    return ret;\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH, try with LD_LIBRARY_PATH\n+    env = getenv(\"LD_LIBRARY_PATH\");\n+  }\n+\n+  stringStream Libpath;\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH or LD_LIBRARY_PATH given -> try only with burned in libpath\n+    Libpath.print(\"%s\", rtv_linkedin_libpath());\n+  } else if (*env == 0) {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given but empty -> try first with burned\n+    \/\/  in libpath and with current working directory second\n+    Libpath.print(\"%s:.\", rtv_linkedin_libpath());\n+  } else {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given with content -> try first with\n+    \/\/ LIBPATH or LD_LIBRARY_PATH and second with burned in libpath.\n+    \/\/ No check against current working directory\n+    Libpath.print(\"%s:%s\", env, rtv_linkedin_libpath());\n+  }\n+\n+  char* libpath = os::strdup (Libpath.base());\n+\n+  char *saveptr, *token;\n+  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n+    stringStream combined;\n+    combined.print(\"%s\/%s\", token, path2);\n+    if ((ret = (0 == stat64x(combined.base(), stat))))\n+      break;\n+  }\n+\n+  os::free (libpath);\n+  os::free (path2);\n+  return ret;\n+}\n+\n+\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+\/\/ filled by os::dll_load(). This way we mimic dl handle equality for a library\n+\/\/ opened a second time, as it is implemented on other platforms.\n+void* Aix_dlopen(const char* filename, int Flags, char *ebuf, int ebuflen) {\n+  void* result;\n+  struct stat64x libstat;\n+\n+  if (false == search_file_in_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+  #ifdef ASSERT\n+    result = ::dlopen(filename, Flags);\n+    assert(result == nullptr, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+  #endif\n+  }\n+  else {\n+    int i = 0;\n+    pthread_mutex_lock(&g_handletable_mutex);\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if (g_handletable[i].handle &&\n+          g_handletable[i].inode == libstat.st_ino &&\n+          g_handletable[i].devid == libstat.st_dev) {\n+        g_handletable[i].refcount++;\n+        result = g_handletable[i].handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not yet loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ Array is already full. No place for new handle. Cry and give up.\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        if (ebuf != nullptr && ebuflen > 0) {\n+          ::strncpy(ebuf, \"dlopen: too many libraries loaded\", ebuflen - 1);\n+        }\n+        assert(false, \"max_handletable reached\");\n+        return nullptr;\n+      }\n+      \/\/ Library not yet loaded; load it, then store its handle in handle table\n+      result = ::dlopen(filename, Flags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        g_handletable[i].handle = result;\n+        g_handletable[i].inode = libstat.st_ino;\n+        g_handletable[i].devid = libstat.st_dev;\n+        g_handletable[i].refcount = 1;\n+      }\n+      else {\n+        \/\/ error analysis when dlopen fails\n+        const char* error_report = ::dlerror();\n+        if (error_report == nullptr) {\n+          error_report = \"dlerror returned no error description\";\n+        }\n+        if (ebuf != nullptr && ebuflen > 0) {\n+          snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+        }\n+      }\n+    }\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  }\n+  return result;\n+}\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+  int i = 0;\n+  bool res = false;\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  pthread_mutex_lock(&g_handletable_mutex);\n+  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+  for (i = 0; i < g_handletable_used; i++) {\n+    if (g_handletable[i].handle == libhandle) {\n+      \/\/ handle found, decrease refcount\n+      g_handletable[i].refcount--;\n+      if (g_handletable[i].refcount > 0) {\n+        \/\/ if refcount is still >0 then we have to keep library and just return true\n+        pthread_mutex_unlock(&g_handletable_mutex);\n+        return true;\n+      }\n+      \/\/ refcount == 0, so we have to ::dlclose() the lib\n+      \/\/ and delete the entry from the array.\n+      break;\n+    }\n+  }\n+\n+  \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n+  \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n+  \/\/ the error handling. In the first case we then also have to delete the entry from the array\n+  \/\/ while in the second case we simply have to nag.\n+  res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  #ifdef ASSERT\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  #endif\n+    assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n+  }\n+\n+  if (i < g_handletable_used) {\n+    if (res) {\n+      \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n+      \/\/ so delete entry from array\n+      g_handletable_used--;\n+      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+      if (i < g_handletable_used) {\n+        g_handletable[i] = g_handletable[g_handletable_used];\n+      }\n+    }\n+  }\n+  else {\n+  #ifdef ASSERT\n+    pthread_mutex_unlock(&g_handletable_mutex);\n+  #endif\n+    \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n+    \/\/ therefore nag\n+    assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n+  }\n+\n+  pthread_mutex_unlock(&g_handletable_mutex);\n+\n+  \/\/ Update the dll cache\n+  LoadedLibraries::reload();\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":270,"deletions":0,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+void* Aix_dlopen(const char* filename, int Flags, char *ebuf, int ebuflen);\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}