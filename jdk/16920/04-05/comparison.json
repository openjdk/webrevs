{"files":[{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -193,1 +192,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -904,0 +904,4 @@\n+struct TableLocker {\n+  TableLocker() { pthread_mutex_lock(&g_handletable_mutex); }\n+  ~TableLocker() { pthread_mutex_unlock(&g_handletable_mutex); }\n+};\n@@ -934,1 +938,4 @@\n-  size_t sz = FILHSZ + _AOUTHSZ_EXEC;\n+  constexpr size_t xcoffsz = FILHSZ + _AOUTHSZ_EXEC;\n+  STATIC_ASSERT(sizeof(the_xcoff) == xcoffsz);\n+  STATIC_ASSERT(sizeof(the_scn) == SCNHSZ);\n+  STATIC_ASSERT(sizeof(the_ldr) == LDHDRSZ);\n@@ -938,1 +945,1 @@\n-      sz != fread(&the_xcoff, 1, sz, f) ||\n+      xcoffsz != fread(&the_xcoff, 1, xcoffsz, f) ||\n@@ -1039,1 +1046,1 @@\n-    pthread_mutex_lock(&g_handletable_mutex);\n+    TableLocker lock;\n@@ -1056,1 +1063,0 @@\n-        pthread_mutex_unlock(&g_handletable_mutex);\n@@ -1083,1 +1089,0 @@\n-    pthread_mutex_unlock(&g_handletable_mutex);\n@@ -1097,10 +1102,15 @@\n-  pthread_mutex_lock(&g_handletable_mutex);\n-  \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n-  for (i = 0; i < g_handletable_used; i++) {\n-    if (g_handletable[i].handle == libhandle) {\n-      \/\/ handle found, decrease refcount\n-      g_handletable[i].refcount--;\n-      if (g_handletable[i].refcount > 0) {\n-        \/\/ if refcount is still >0 then we have to keep library and just return true\n-        pthread_mutex_unlock(&g_handletable_mutex);\n-        return true;\n+  {\n+    TableLocker lock;\n+    \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if (g_handletable[i].handle == libhandle) {\n+        \/\/ handle found, decrease refcount\n+        assert(g_handletable[i].refcount > 0, \"Sanity\");\n+        g_handletable[i].refcount--;\n+        if (g_handletable[i].refcount > 0) {\n+          \/\/ if refcount is still >0 then we have to keep library and just return true\n+          return true;\n+        }\n+        \/\/ refcount == 0, so we have to ::dlclose() the lib\n+        \/\/ and delete the entry from the array.\n+        break;\n@@ -1108,3 +1118,0 @@\n-      \/\/ refcount == 0, so we have to ::dlclose() the lib\n-      \/\/ and delete the entry from the array.\n-      break;\n@@ -1112,1 +1119,0 @@\n-  }\n@@ -1114,13 +1120,15 @@\n-  \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n-  \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n-  \/\/ the error handling. In the first case we then also have to delete the entry from the array\n-  \/\/ while in the second case we simply have to nag.\n-  res = (0 == ::dlclose(libhandle));\n-  if (!res) {\n-    \/\/ error analysis when dlopen fails\n-    const char* error_report = ::dlerror();\n-    if (error_report == nullptr) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-    if (ebuf != nullptr && ebuflen > 0) {\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n+    \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n+    \/\/ the error handling. In the first case we then also have to delete the entry from the array\n+    \/\/ while in the second case we simply have to nag.\n+    res = (0 == ::dlclose(libhandle));\n+    if (!res) {\n+      \/\/ error analysis when dlopen fails\n+      const char* error_report = ::dlerror();\n+      if (error_report == nullptr) {\n+        error_report = \"dlerror returned no error description\";\n+      }\n+      if (ebuf != nullptr && ebuflen > 0) {\n+        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      }\n+      assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n@@ -1128,16 +1136,13 @@\n-  #ifdef ASSERT\n-    pthread_mutex_unlock(&g_handletable_mutex);\n-  #endif\n-    assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n-  }\n-\n-  if (i < g_handletable_used) {\n-    if (res) {\n-      \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n-      \/\/ so delete entry from array\n-      g_handletable_used--;\n-      \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n-      \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n-      \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n-      if (i < g_handletable_used) {\n-        g_handletable[i] = g_handletable[g_handletable_used];\n+\n+    if (i < g_handletable_used) {\n+      if (res) {\n+        \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n+        \/\/ so delete entry from array\n+        g_handletable_used--;\n+        \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+        \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+        \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+        if (i < g_handletable_used) {\n+          g_handletable[i] = g_handletable[g_handletable_used];\n+          g_handletable[g_handletable_used].handle = nullptr;\n+        }\n@@ -1146,0 +1151,5 @@\n+    else {\n+      \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n+      \/\/ therefore nag\n+      assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n+    }\n@@ -1147,10 +1157,0 @@\n-  else {\n-  #ifdef ASSERT\n-    pthread_mutex_unlock(&g_handletable_mutex);\n-  #endif\n-    \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n-    \/\/ therefore nag\n-    assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n-  }\n-\n-  pthread_mutex_unlock(&g_handletable_mutex);\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"}]}