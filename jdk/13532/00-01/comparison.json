{"files":[{"patch":"","filename":"make\/data\/cldr\/LICENSE.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/cldr\/unicode-license.txt","status":"renamed"},{"patch":"@@ -1750,6 +1750,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n@@ -1971,6 +1965,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1603,6 +1603,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n@@ -1857,6 +1851,0 @@\n-  \/\/ We might be moving to a safepoint.  The thread which calls\n-  \/\/ Interpreter::notice_safepoints() will effectively flush its cache\n-  \/\/ when it makes a system call, but we need to do something to\n-  \/\/ ensure that we see the changed dispatch table.\n-  __ membar(MacroAssembler::LoadLoad);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3158,1 +3158,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2428,1 +2428,1 @@\n-  \/\/ The invokedynamic is unresolved iff method is NULL\n+  \/\/ The invokedynamic is unresolved iff method is null\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4073,1 +4073,1 @@\n-  const Klass* const super = ik->super();\n+  const InstanceKlass* const super = ik->java_super();\n@@ -4352,1 +4352,1 @@\n-      const Klass* k = this_klass->super();\n+      const InstanceKlass* k = this_klass->java_super();\n@@ -4384,1 +4384,1 @@\n-          k = super_m->method_holder()->super();\n+          k = super_m->method_holder()->java_super();\n@@ -4388,1 +4388,1 @@\n-        k = k->super();\n+        k = k->java_super();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -759,0 +759,2 @@\n+  template(encodeAnnotations_name,                     \"encodeAnnotations\")                                       \\\n+  template(encodeAnnotations_signature,                \"([BLjava\/lang\/Class;Ljdk\/internal\/reflect\/ConstantPool;Z[Ljava\/lang\/Class;)[B\")\\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) {\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) {\n@@ -413,1 +413,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) {\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) {\n@@ -433,1 +433,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) {}\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) {}\n@@ -918,2 +918,2 @@\n-void DerivedPointerTable::add(derived_pointer* derived_loc, oop *base_loc) {\n-  assert(Universe::heap()->is_in_or_null(*base_loc), \"not an oop\");\n+void DerivedPointerTable::add(derived_pointer* derived_loc, derived_base* base_loc) {\n+  assert(Universe::heap()->is_in_or_null((void*)*base_loc), \"not an oop\");\n@@ -936,1 +936,1 @@\n-      p2i(derived_loc), derived_pointer_value(*derived_loc), p2i(*base_loc), p2i(base_loc), offset\n+      p2i(derived_loc), derived_pointer_value(*derived_loc), intptr_t(*base_loc), p2i(base_loc), offset\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+enum class derived_base : intptr_t {};\n@@ -484,1 +485,1 @@\n-  static bool _active;                                  \/\/ do not record pointers for verify pass etc.\n+  static bool _active;                                           \/\/ do not record pointers for verify pass etc.\n@@ -487,3 +488,3 @@\n-  static void clear();                                  \/\/ Called before scavenge\/GC\n-  static void add(derived_pointer* derived, oop *base); \/\/ Called during scavenge\/GC\n-  static void update_pointers();                        \/\/ Called after  scavenge\/GC\n+  static void clear();                                           \/\/ Called before scavenge\/GC\n+  static void add(derived_pointer* derived, derived_base* base); \/\/ Called during scavenge\/GC\n+  static void update_pointers();                                 \/\/ Called after  scavenge\/GC\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-      void** base_loc = (void**) fr->oopmapreg_to_location(omv.content_reg(), reg_map);\n+      derived_base* base_loc = (derived_base*) fr->oopmapreg_to_location(omv.content_reg(), reg_map);\n@@ -94,2 +94,2 @@\n-      if (base_loc != nullptr && !SkipNullValue::should_skip(*base_loc)) {\n-        _derived_oop_fn->do_derived_oop((oop*)base_loc, derived_loc);\n+      if (base_loc != nullptr && !SkipNullValue::should_skip((void*)*base_loc)) {\n+        _derived_oop_fn->do_derived_oop(base_loc, derived_loc);\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    _num_initial_optional_regions(optional_cset_length),\n+    _max_num_optional_regions(optional_cset_length),\n@@ -109,1 +109,1 @@\n-  _oops_into_optional_regions = new G1OopStarChunkedList[_num_initial_optional_regions];\n+  _oops_into_optional_regions = new G1OopStarChunkedList[_max_num_optional_regions];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-  \/\/ Number of optional regions at start of gc.\n-  size_t _num_initial_optional_regions;\n+  \/\/ Maximum number of optional regions at start of gc.\n+  size_t _max_num_optional_regions;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  assert(index < _num_initial_optional_regions,\n-         \"Trying to access optional region idx %u beyond \" SIZE_FORMAT, index, _num_initial_optional_regions);\n+  assert(index < _max_num_optional_regions,\n+         \"Trying to access optional region idx %u beyond \" SIZE_FORMAT, index, _max_num_optional_regions);\n@@ -86,2 +86,2 @@\n-  assert(index < _num_initial_optional_regions,\n-         \"Trying to access optional region idx %u beyond \" SIZE_FORMAT, index, _num_initial_optional_regions);\n+  assert(index < _max_num_optional_regions,\n+         \"Trying to access optional region idx %u beyond \" SIZE_FORMAT, index, _max_num_optional_regions);\n@@ -93,1 +93,1 @@\n-  assert(hr->index_in_opt_cset() < _num_initial_optional_regions,\n+  assert(hr->index_in_opt_cset() < _max_num_optional_regions,\n@@ -95,1 +95,1 @@\n-         hr->index_in_opt_cset(), _num_initial_optional_regions, HR_FORMAT_PARAMS(hr));\n+         hr->index_in_opt_cset(), _max_num_optional_regions, HR_FORMAT_PARAMS(hr));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -552,5 +552,0 @@\n-#ifdef ASSERT\n-    HeapRegion* hr = _g1h->region_at_or_null(region_idx);\n-    assert(hr == NULL || hr->is_in_reserved(card_start),\n-             \"Card start \" PTR_FORMAT \" to scan outside of region %u\", p2i(card_start), _g1h->region_at(region_idx)->hrm_index());\n-#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,4 @@\n+\n+  HeapWord* top() const {\n+    return _top;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2675,3 +2675,1 @@\n-C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n-  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n-  Klass* klass = UNPACK_PAIR(Klass, klass);\n+static InstanceKlass* check_field(Klass* klass, jint index, JVMCI_TRAPS) {\n@@ -2687,0 +2685,7 @@\n+  return iklass;\n+}\n+\n+C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index))\n+  requireInHotSpot(\"asReflectionField\", JVMCI_CHECK_NULL);\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  InstanceKlass* iklass = check_field(klass, index, JVMCIENV);\n@@ -2692,0 +2697,82 @@\n+static jbyteArray get_encoded_annotation_data(InstanceKlass* holder, AnnotationArray* annotations_array, bool for_class,\n+                                              jint filter_length, jlong filter_klass_pointers,\n+                                              JavaThread* THREAD, JVMCIEnv* JVMCIENV) {\n+  \/\/ Get a ConstantPool object for annotation parsing\n+  Handle jcp = reflect_ConstantPool::create(CHECK_NULL);\n+  reflect_ConstantPool::set_cp(jcp(), holder->constants());\n+\n+  \/\/ load VMSupport\n+  Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();\n+  Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK_NULL);\n+\n+  InstanceKlass* vm_support = InstanceKlass::cast(k);\n+  if (vm_support->should_be_initialized()) {\n+    vm_support->initialize(CHECK_NULL);\n+  }\n+\n+  typeArrayOop annotations_oop = Annotations::make_java_array(annotations_array, CHECK_NULL);\n+  typeArrayHandle annotations = typeArrayHandle(THREAD, annotations_oop);\n+\n+  InstanceKlass** filter = filter_length == 1 ?\n+      (InstanceKlass**) &filter_klass_pointers:\n+      (InstanceKlass**) filter_klass_pointers;\n+  objArrayOop filter_oop = oopFactory::new_objArray(vmClasses::Class_klass(), filter_length, CHECK_NULL);\n+  objArrayHandle filter_classes(THREAD, filter_oop);\n+  for (int i = 0; i < filter_length; i++) {\n+    filter_classes->obj_at_put(i, filter[i]->java_mirror());\n+  }\n+\n+  \/\/ invoke VMSupport.encodeAnnotations\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_oop(annotations);\n+  args.push_oop(Handle(THREAD, holder->java_mirror()));\n+  args.push_oop(jcp);\n+  args.push_int(for_class);\n+  args.push_oop(filter_classes);\n+  Symbol* signature = vmSymbols::encodeAnnotations_signature();\n+  JavaCalls::call_static(&result,\n+                         vm_support,\n+                         vmSymbols::encodeAnnotations_name(),\n+                         signature,\n+                         &args,\n+                         CHECK_NULL);\n+\n+  oop res = result.get_oop();\n+  if (JVMCIENV->is_hotspot()) {\n+    return (jbyteArray) JNIHandles::make_local(THREAD, res);\n+  }\n+\n+  typeArrayOop ba = typeArrayOop(res);\n+  int ba_len = ba->length();\n+  jbyte* ba_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jbyte, ba_len);\n+  if (ba_buf == nullptr) {\n+    JVMCI_THROW_MSG_NULL(InternalError,\n+              err_msg(\"could not allocate %d bytes\", ba_len));\n+\n+  }\n+  memcpy(ba_buf, ba->byte_at_addr(0), ba_len);\n+  JVMCIPrimitiveArray ba_dest = JVMCIENV->new_byteArray(ba_len, JVMCI_CHECK_NULL);\n+  JVMCIENV->copy_bytes_from(ba_buf, ba_dest, 0, ba_len);\n+  return JVMCIENV->get_jbyteArray(ba_dest);\n+}\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedClassAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = InstanceKlass::cast(UNPACK_PAIR(Klass, klass));\n+  return get_encoded_annotation_data(holder, holder->class_annotations(), true, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedExecutableAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  return get_encoded_annotation_data(method->method_holder(), method->annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n+C2V_VMENTRY_NULL(jbyteArray, getEncodedFieldAnnotationData, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass), jint index,\n+                 jobject filter, jint filter_length, jlong filter_klass_pointers))\n+  InstanceKlass* holder = check_field(InstanceKlass::cast(UNPACK_PAIR(Klass, klass)), index, JVMCIENV);\n+  fieldDescriptor fd(holder, index);\n+  return get_encoded_annotation_data(holder, fd.annotations(), false, filter_length, filter_klass_pointers, THREAD, JVMCIENV);\n+C2V_END\n+\n@@ -2972,0 +3059,3 @@\n+  {CC \"getEncodedClassAnnotationData\",                CC \"(\" HS_KLASS2 OBJECT \"IJ)[B\",                                                      FN_PTR(getEncodedClassAnnotationData)},\n+  {CC \"getEncodedExecutableAnnotationData\",           CC \"(\" HS_METHOD2 OBJECT \"IJ)[B\",                                                     FN_PTR(getEncodedExecutableAnnotationData)},\n+  {CC \"getEncodedFieldAnnotationData\",                CC \"(\" HS_KLASS2 \"I\" OBJECT \"IJ)[B\",                                                  FN_PTR(getEncodedFieldAnnotationData)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":93,"deletions":3,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  nonstatic_field(Annotations,                 _class_annotations,                     AnnotationArray*)                             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+enum class derived_base : intptr_t;\n@@ -136,1 +137,1 @@\n-  virtual void do_derived_oop(oop* base, derived_pointer* derived) = 0;\n+  virtual void do_derived_oop(derived_base* base, derived_pointer* derived) = 0;\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2136,1 +2136,0 @@\n-  if (k->has_final_method()) buf[i++] = 'f';\n@@ -2139,0 +2138,1 @@\n+    if (ik->has_final_method()) buf[i++] = 'f';\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,4 +226,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags right now.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n@@ -234,1 +230,1 @@\n-  \/\/ State is set while executing, eventually atomically to not disturb other state\n+  \/\/ State is set either at parse time or while executing, atomically to not disturb other state\n@@ -534,2 +530,2 @@\n-  bool is_marked_dependent() const         { return _is_marked_dependent; }\n-  void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }\n+  bool is_marked_dependent() const         { return _misc_flags.is_marked_dependent(); }\n+  void set_is_marked_dependent(bool value) { _misc_flags.set_is_marked_dependent(value); }\n@@ -684,10 +680,2 @@\n-  bool is_being_redefined() const          {\n-    return _access_flags.is_being_redefined();\n-  }\n-  void set_is_being_redefined(bool value)  {\n-    if (value) {\n-      _access_flags.set_is_being_redefined();\n-    } else {\n-      _access_flags.clear_is_being_redefined();\n-    }\n-  }\n+  bool is_being_redefined() const          { return _misc_flags.is_being_redefined(); }\n+  void set_is_being_redefined(bool value)  { _misc_flags.set_is_being_redefined(value); }\n@@ -719,7 +707,2 @@\n-  bool has_resolved_methods() const {\n-    return _access_flags.has_resolved_methods();\n-  }\n-\n-  void set_has_resolved_methods() {\n-    _access_flags.set_has_resolved_methods();\n-  }\n+  bool has_resolved_methods() const { return _misc_flags.has_resolved_methods(); }\n+  void set_has_resolved_methods()   { _misc_flags.set_has_resolved_methods(true); }\n@@ -779,0 +762,7 @@\n+  bool has_vanilla_constructor() const  { return _misc_flags.has_vanilla_constructor(); }\n+  void set_has_vanilla_constructor()    { _misc_flags.set_has_vanilla_constructor(true); }\n+  bool has_miranda_methods () const     { return _misc_flags.has_miranda_methods(); }\n+  void set_has_miranda_methods()        { _misc_flags.set_has_miranda_methods(true); }\n+  bool has_final_method() const         { return _misc_flags.has_final_method(); }\n+  void set_has_final_method()           { _misc_flags.set_has_final_method(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -32,0 +33,21 @@\n+\/\/ This can be removed for the atomic bitset functions, when available.\n+void InstanceKlassFlags::atomic_set_bits(u1 bits) {\n+  \/\/ Atomically update the status with the bits given\n+  u1 old_status, new_status, f;\n+  do {\n+    old_status = _status;\n+    new_status = old_status | bits;\n+    f = Atomic::cmpxchg(&_status, old_status, new_status);\n+  } while(f != old_status);\n+}\n+\n+void InstanceKlassFlags::atomic_clear_bits(u1 bits) {\n+  \/\/ Atomically update the status with the bits given\n+  u1 old_status, new_status, f;\n+  do {\n+    old_status = _status;\n+    new_status = old_status & ~bits;\n+    f = Atomic::cmpxchg(&_status, old_status, new_status);\n+  } while(f != old_status);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,0 +30,6 @@\n+\/\/ The InstanceKlassFlags class contains the parse-time and writeable flags associated with\n+\/\/ an InstanceKlass, and their associated accessors.\n+\/\/ _flags are parse-time and constant in the InstanceKlass after that.  _status are set at runtime and\n+\/\/ require atomic access.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n@@ -38,12 +44,13 @@\n-    flag(unused                             , 1 << 3) \/* not currently used *\/ \\\n-    flag(is_contended                       , 1 << 4) \/* marked with contended annotation *\/ \\\n-    flag(has_nonstatic_concrete_methods     , 1 << 5) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n-    flag(declares_nonstatic_concrete_methods, 1 << 6) \/* directly declares non-static, concrete methods *\/ \\\n-    flag(has_been_redefined                 , 1 << 7) \/* class has been redefined *\/ \\\n-    flag(shared_loading_failed              , 1 << 8) \/* class has been loaded from shared archive *\/ \\\n-    flag(is_scratch_class                   , 1 << 9) \/* class is the redefined scratch class *\/ \\\n-    flag(is_shared_boot_class               , 1 << 10) \/* defining class loader is boot class loader *\/ \\\n-    flag(is_shared_platform_class           , 1 << 11) \/* defining class loader is platform class loader *\/ \\\n-    flag(is_shared_app_class                , 1 << 12) \/* defining class loader is app class loader *\/ \\\n-    flag(has_contended_annotations          , 1 << 13) \/* has @Contended annotation *\/ \\\n-    flag(has_localvariable_table            , 1 << 14) \/* has localvariable information *\/\n+    flag(is_contended                       , 1 << 3) \/* marked with contended annotation *\/ \\\n+    flag(has_nonstatic_concrete_methods     , 1 << 4) \/* class\/superclass\/implemented interfaces has non-static, concrete methods *\/ \\\n+    flag(declares_nonstatic_concrete_methods, 1 << 5) \/* directly declares non-static, concrete methods *\/ \\\n+    flag(shared_loading_failed              , 1 << 6) \/* class has been loaded from shared archive *\/ \\\n+    flag(is_shared_boot_class               , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n+    flag(is_shared_platform_class           , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n+    flag(is_shared_app_class                , 1 << 9) \/* defining class loader is app class loader *\/ \\\n+    flag(has_contended_annotations          , 1 << 10) \/* has @Contended annotation *\/ \\\n+    flag(has_localvariable_table            , 1 << 11) \/* has localvariable information *\/ \\\n+    flag(has_miranda_methods                , 1 << 12) \/* True if this class has miranda methods in it's vtable *\/ \\\n+    flag(has_vanilla_constructor            , 1 << 13) \/* True if klass has a vanilla default constructor *\/ \\\n+    flag(has_final_method                   , 1 << 14) \/* True if klass has final method *\/ \\\n+    \/* end of list *\/\n@@ -57,0 +64,13 @@\n+#define IK_STATUS_DO(status)  \\\n+    status(is_being_redefined                , 1 << 0) \/* True if the klass is being redefined *\/ \\\n+    status(has_resolved_methods              , 1 << 1) \/* True if the klass has resolved MethodHandle methods *\/ \\\n+    status(has_been_redefined                , 1 << 2) \/* class has been redefined *\/ \\\n+    status(is_scratch_class                  , 1 << 3) \/* class is the redefined scratch class *\/ \\\n+    status(is_marked_dependent               , 1 << 4) \/* class is the redefined scratch class *\/\n+\n+#define IK_STATUS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    IK_STATUS_DO(IK_STATUS_ENUM_NAME)\n+  };\n+#undef IK_STATUS_ENUM_NAME\n+\n@@ -64,0 +84,3 @@\n+  \/\/ These flags are written during execution so require atomic stores\n+  u1 _status;\n+\n@@ -66,1 +89,1 @@\n-  InstanceKlassFlags() : _flags(0) {}\n+  InstanceKlassFlags() : _flags(0), _status(0) {}\n@@ -90,0 +113,20 @@\n+\n+  \/\/ Create getters and setters for the status values.\n+#define IK_STATUS_GET(name, ignore)          \\\n+  bool name() const { return (_status & _misc_##name) != 0; }\n+  IK_STATUS_DO(IK_STATUS_GET)\n+#undef IK_STATUS_GET\n+\n+#define IK_STATUS_SET(name, ignore)   \\\n+  void set_##name(bool b) {         \\\n+    if (b) { \\\n+      atomic_set_bits(_misc_##name); \\\n+    } else { \\\n+      atomic_clear_bits(_misc_##name); \\\n+    } \\\n+  }\n+  IK_STATUS_DO(IK_STATUS_SET)\n+#undef IK_STATUS_SET\n+\n+  void atomic_set_bits(u1 bits);\n+  void atomic_clear_bits(u1 bits);\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":56,"deletions":13,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+    _is_shared_class                       = 1 << 0,  \/\/ shadows MetaspaceObj::is_shared\n@@ -366,0 +367,9 @@\n+  bool is_shared() const                { \/\/ shadows MetaspaceObj::is_shared)()\n+    CDS_ONLY(return (_shared_class_flags & _is_shared_class) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  void set_is_shared() {\n+    CDS_ONLY(_shared_class_flags |= _is_shared_class;)\n+  }\n+\n@@ -652,1 +662,0 @@\n-  bool has_final_method() const         { return _access_flags.has_final_method(); }\n@@ -654,7 +663,0 @@\n-  void set_has_final_method()           { _access_flags.set_has_final_method(); }\n-  bool has_vanilla_constructor() const  { return _access_flags.has_vanilla_constructor(); }\n-  void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }\n-  bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }\n-  void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }\n-  bool is_shared() const                { return access_flags().is_shared_class(); } \/\/ shadows MetaspaceObj::is_shared)()\n-  void set_is_shared()                  { _access_flags.set_is_shared_class(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,0 +41,5 @@\n+\/\/ Note: Some functions in this file work with stale object pointers, e.g.\n+\/\/       DerivedPointerSupport. Be extra careful to not put those pointers into\n+\/\/       variables of the 'oop' type. There's extra GC verification around oops\n+\/\/       that may fail when stale oops are being used.\n+\n@@ -156,3 +161,5 @@\n-  static void relativize(oop* base_loc, derived_pointer* derived_loc) {\n-    oop base = *base_loc;\n-    if (base == nullptr) {\n+  static void relativize(derived_base* base_loc, derived_pointer* derived_loc) {\n+    \/\/ The base oop could be stale from the GC's point-of-view. Treat it as an\n+    \/\/ uintptr_t to stay clear of the oop verification code in oopsHierarcy.hpp.\n+    uintptr_t base = *(uintptr_t*)base_loc;\n+    if (base == 0) {\n@@ -161,1 +168,1 @@\n-    assert(!UseCompressedOops || !CompressedOops::is_base(base), \"\");\n+    assert(!UseCompressedOops || !CompressedOops::is_base((void*)base), \"\");\n@@ -167,1 +174,1 @@\n-    uintptr_t offset = derived_int_val - cast_from_oop<uintptr_t>(base);\n+    uintptr_t offset = derived_int_val - base;\n@@ -171,3 +178,3 @@\n-  static void derelativize(oop* base_loc, derived_pointer* derived_loc) {\n-    oop base = *base_loc;\n-    if (base == nullptr) {\n+  static void derelativize(derived_base* base_loc, derived_pointer* derived_loc) {\n+    uintptr_t base = *(uintptr_t*)base_loc;\n+    if (base == 0) {\n@@ -176,1 +183,1 @@\n-    assert(!UseCompressedOops || !CompressedOops::is_base(base), \"\");\n+    assert(!UseCompressedOops || !CompressedOops::is_base((void*)base), \"\");\n@@ -182,1 +189,1 @@\n-    *(uintptr_t*)derived_loc = cast_from_oop<uintptr_t>(base) + offset;\n+    *(uintptr_t*)derived_loc = base + offset;\n@@ -186,1 +193,1 @@\n-    virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+    virtual void do_derived_oop(derived_base* base_loc, derived_pointer* derived_loc) override {\n@@ -192,1 +199,1 @@\n-    virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+    virtual void do_derived_oop(derived_base* base_loc, derived_pointer* derived_loc) override {\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  void set_os_lib(void* os_lib);\n+  void set_os_lib(void* os_lib) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-  assert(offset >= 0, \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-bool   Arguments::_java_compiler                = false;\n@@ -1269,2 +1268,8 @@\n-    process_java_compiler_argument(value);\n-    \/\/ Record value in Arguments, but let it get passed to Java.\n+    \/\/ we no longer support java.compiler system property, log a warning and let it get\n+    \/\/ passed to Java, like any other system property\n+    if (strlen(value) == 0 || strcasecmp(value, \"NONE\") == 0) {\n+        \/\/ for applications using NONE or empty value, log a more informative message\n+        warning(\"The java.compiler system property is obsolete and no longer supported, use -Xint\");\n+    } else {\n+        warning(\"The java.compiler system property is obsolete and no longer supported.\");\n+    }\n@@ -1375,1 +1380,0 @@\n-  set_java_compiler(false);\n@@ -1865,10 +1869,0 @@\n-\/\/ Parsing of java.compiler property\n-\n-void Arguments::process_java_compiler_argument(const char* arg) {\n-  \/\/ For backwards compatibility, Djava.compiler=NONE or \"\"\n-  \/\/ causes us to switch to -Xint mode UNLESS -Xdebug\n-  \/\/ is also specified.\n-  if (strlen(arg) == 0 || strcasecmp(arg, \"NONE\") == 0) {\n-    set_java_compiler(true);    \/\/ \"-Djava.compiler[=...]\" most recently seen.\n-  }\n-}\n@@ -3007,9 +3001,0 @@\n-  \/\/ This must be done after all arguments have been processed.\n-  \/\/ java_compiler() true means set to \"NONE\" or empty.\n-  if (java_compiler() && !xdebug_mode()) {\n-    \/\/ For backwards compatibility, we switch to interpreted mode if\n-    \/\/ -Djava.compiler=\"NONE\" or \"\" is specified AND \"-Xdebug\" was\n-    \/\/ not specified.\n-    set_mode_flags(_int);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -245,3 +245,0 @@\n-  static bool _java_compiler;\n-  static void set_java_compiler(bool arg) { _java_compiler = arg; }\n-  static bool java_compiler()   { return _java_compiler; }\n@@ -305,1 +302,0 @@\n-  static void process_java_compiler_argument(const char* arg);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,4 +95,2 @@\n-      if (_cont._tail != nullptr) {\n-        _cont._tail = jdk_internal_vm_Continuation::tail(_cont._continuation);\n-       }\n-       _cont.disallow_safepoint();\n+      _cont._tail = jdk_internal_vm_Continuation::tail(_cont._continuation);\n+      _cont.disallow_safepoint();\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1244,1 +1244,1 @@\n-  GrowableArray<oop*>* _base;\n+  GrowableArray<derived_base*>* _base;\n@@ -1252,1 +1252,1 @@\n-    _base = new (mtThread) GrowableArray<oop*>(100, mtThread);\n+    _base = new (mtThread) GrowableArray<derived_base*>(100, mtThread);\n@@ -1264,1 +1264,1 @@\n-  virtual void do_derived_oop(oop* base_loc, derived_pointer* derived_loc) override {\n+  virtual void do_derived_oop(derived_base* base_loc, derived_pointer* derived_loc) override {\n@@ -1284,1 +1284,1 @@\n-      oop* base = _base->at(i);\n+      derived_base* base = _base->at(i);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-    Devirtualizer::do_derived_oop(closure, (oop*)base_loc, (derived_pointer*)derived_loc);\n+    Devirtualizer::do_derived_oop(closure, (derived_base*)base_loc, (derived_pointer*)derived_loc);\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -2093,2 +2092,0 @@\n-  declare_constant(JVM_ACC_HAS_LINE_NUMBER_TABLE)                         \\\n-  declare_constant(JVM_ACC_HAS_CHECKED_EXCEPTIONS)                        \\\n@@ -2099,2 +2096,0 @@\n-  declare_constant(JVM_ACC_HAS_MIRANDA_METHODS)                           \\\n-  declare_constant(JVM_ACC_HAS_VANILLA_CONSTRUCTOR)                       \\\n@@ -2103,1 +2098,0 @@\n-  declare_constant(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-  JVM_ACC_HAS_LINE_NUMBER_TABLE   = 0x00100000,\n-  JVM_ACC_HAS_CHECKED_EXCEPTIONS  = 0x00400000,\n@@ -64,2 +62,0 @@\n-  JVM_ACC_HAS_MIRANDA_METHODS     = 0x10000000,     \/\/ True if this class has miranda methods in it's vtable\n-  JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000,     \/\/ True if klass has a vanilla default constructor\n@@ -68,2 +64,0 @@\n-  JVM_ACC_HAS_FINAL_METHOD        = 0x01000000,     \/\/ True if klass has final method\n-  JVM_ACC_IS_SHARED_CLASS         = 0x02000000,     \/\/ True if klass is shared\n@@ -72,5 +66,0 @@\n-  JVM_ACC_IS_BEING_REDEFINED      = 0x00100000,     \/\/ True if the klass is being redefined.\n-  JVM_ACC_HAS_RESOLVED_METHODS    = 0x00200000,     \/\/ True if the klass has resolved methods\n-\n-  \/\/ Method* flags\n-  JVM_ACC_HAS_LOCAL_VARIABLE_TABLE= 0x00400000,\n@@ -115,2 +104,0 @@\n-  bool has_linenumber_table    () const { return (_flags & JVM_ACC_HAS_LINE_NUMBER_TABLE  ) != 0; }\n-  bool has_checked_exceptions  () const { return (_flags & JVM_ACC_HAS_CHECKED_EXCEPTIONS ) != 0; }\n@@ -124,2 +111,0 @@\n-  bool has_miranda_methods     () const { return (_flags & JVM_ACC_HAS_MIRANDA_METHODS    ) != 0; }\n-  bool has_vanilla_constructor () const { return (_flags & JVM_ACC_HAS_VANILLA_CONSTRUCTOR) != 0; }\n@@ -127,1 +112,0 @@\n-  bool has_final_method        () const { return (_flags & JVM_ACC_HAS_FINAL_METHOD       ) != 0; }\n@@ -129,1 +113,0 @@\n-  bool is_shared_class         () const { return (_flags & JVM_ACC_IS_SHARED_CLASS        ) != 0; }\n@@ -133,12 +116,0 @@\n-  \/\/ Method* flags\n-  bool has_localvariable_table () const { return (_flags & JVM_ACC_HAS_LOCAL_VARIABLE_TABLE) != 0; }\n-  void set_has_localvariable_table()    { atomic_set_bits(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE); }\n-  void clear_has_localvariable_table()  { atomic_clear_bits(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE); }\n-\n-  bool is_being_redefined() const       { return (_flags & JVM_ACC_IS_BEING_REDEFINED) != 0; }\n-  void set_is_being_redefined()         { atomic_set_bits(JVM_ACC_IS_BEING_REDEFINED); }\n-  void clear_is_being_redefined()       { atomic_clear_bits(JVM_ACC_IS_BEING_REDEFINED); }\n-\n-  bool has_resolved_methods() const     { return (_flags & JVM_ACC_HAS_RESOLVED_METHODS) != 0; }\n-  void set_has_resolved_methods()       { atomic_set_bits(JVM_ACC_HAS_RESOLVED_METHODS); }\n-\n@@ -182,2 +153,0 @@\n-  void set_has_linenumber_table()      { atomic_set_bits(JVM_ACC_HAS_LINE_NUMBER_TABLE);   }\n-  void set_has_checked_exceptions()    { atomic_set_bits(JVM_ACC_HAS_CHECKED_EXCEPTIONS);  }\n@@ -194,1 +163,0 @@\n-  void set_has_vanilla_constructor()   { atomic_set_bits(JVM_ACC_HAS_VANILLA_CONSTRUCTOR); }\n@@ -196,1 +164,0 @@\n-  void set_has_final_method()          { atomic_set_bits(JVM_ACC_HAS_FINAL_METHOD);        }\n@@ -198,2 +165,0 @@\n-  void set_has_miranda_methods()       { atomic_set_bits(JVM_ACC_HAS_MIRANDA_METHODS);     }\n-  void set_is_shared_class()           { atomic_set_bits(JVM_ACC_IS_SHARED_CLASS);         }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  template <typename DerivedOopClosureType>      static void do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived);\n+  template <typename DerivedOopClosureType>      static void do_derived_oop(DerivedOopClosureType* closure, derived_base* base, derived_pointer* derived);\n","filename":"src\/hotspot\/share\/utilities\/devirtualizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+call_do_derived_oop(void (Receiver::*)(derived_base*, derived_pointer*), void (Base::*)(derived_base*, derived_pointer*), DerivedOopClosureType* closure, derived_base* base, derived_pointer* derived) {\n@@ -163,1 +163,1 @@\n-call_do_derived_oop(void (Receiver::*)(oop*, derived_pointer*), void (Base::*)(oop*, derived_pointer*), DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+call_do_derived_oop(void (Receiver::*)(derived_base*, derived_pointer*), void (Base::*)(derived_base*, derived_pointer*), DerivedOopClosureType* closure, derived_base* base, derived_pointer* derived) {\n@@ -168,1 +168,1 @@\n-inline void Devirtualizer::do_derived_oop(DerivedOopClosureType* closure, oop* base, derived_pointer* derived) {\n+inline void Devirtualizer::do_derived_oop(DerivedOopClosureType* closure, derived_base* base, derived_pointer* derived) {\n","filename":"src\/hotspot\/share\/utilities\/devirtualizer.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -763,2 +763,0 @@\n-     * <tr><th scope=\"row\">{@systemProperty java.compiler}<\/th>\n-     *     <td>Name of JIT compiler to use<\/td><\/tr>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -493,1 +493,1 @@\n-     *     Channels.newReader(ch, Charset.forName(csName).newDecoder(), -1)\n+     *     Channels.newReader(ch, charset.newDecoder(), -1)\n@@ -593,1 +593,1 @@\n-     *     Channels.newWriter(ch, Charset.forName(csName).newEncoder(), -1)\n+     *     Channels.newWriter(ch, charset.newEncoder(), -1)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+ * Unless otherwise specified, any {@code Calendar} method containing the\n+ * parameter {@code int field} will throw an {@code ArrayIndexOutOfBoundsException}\n+ * if the specified field is out of range ({@code field} &lt; 0 ||\n+ * {@code field} &gt;= {@link #FIELD_COUNT}).\n@@ -1847,2 +1851,2 @@\n-     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range\n-     *             (<code>field &lt; 0 || field &gt;= FIELD_COUNT<\/code>).\n+     * @throws IllegalArgumentException if this {@code Calendar} is non-lenient and any\n+     * of the calendar fields have invalid values.\n@@ -1876,2 +1880,0 @@\n-     * @throws IndexOutOfBoundsException if the specified field is out of range\n-     *             (<code>field &lt; 0 || field &gt;= FIELD_COUNT<\/code>).\n@@ -1894,3 +1896,0 @@\n-     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range\n-     *             (<code>field &lt; 0 || field &gt;= FIELD_COUNT<\/code>).\n-     * in non-lenient mode.\n@@ -2634,1 +2633,1 @@\n-        return (stamp_a > stamp_b) ? stamp_a : stamp_b;\n+        return Math.max(stamp_a, stamp_b);\n@@ -2819,0 +2818,3 @@\n+     * @throws IllegalArgumentException if this {@code Calendar} is non-lenient\n+     * and any of the calendar fields have invalid values or if {@code field} is\n+     * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown.\n@@ -2841,0 +2843,3 @@\n+     * @throws IllegalArgumentException if this {@code Calendar} is non-lenient\n+     * and any of the calendar fields have invalid values or if {@code field} is\n+     * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown.\n@@ -2860,0 +2865,3 @@\n+     * @throws IllegalArgumentException if this {@code Calendar} is non-lenient\n+     * and any of the calendar fields have invalid values or if {@code field} is\n+     * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Calendar.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,10 @@\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.reflect.ConstantPool;\n+import sun.reflect.annotation.AnnotationParser;\n+import sun.reflect.annotation.AnnotationSupport;\n+import sun.reflect.annotation.AnnotationType;\n+\n+import java.io.ByteArrayInputStream;\n@@ -28,0 +38,2 @@\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n@@ -29,0 +41,5 @@\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.IncompleteAnnotationException;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n@@ -31,6 +48,1 @@\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import java.util.jar.Attributes;\n-\n-import jdk.internal.misc.VM;\n-import jdk.internal.misc.Unsafe;\n+import java.util.List;\n@@ -170,0 +182,400 @@\n+\n+    \/**\n+     * Parses {@code rawAnnotations} into a list of {@link Annotation}s and then\n+     * serializes them to a byte array with {@link #encodeAnnotations(Collection)}.\n+     *\/\n+    public static byte[] encodeAnnotations(byte[] rawAnnotations,\n+                                           Class<?> declaringClass,\n+                                           ConstantPool cp,\n+                                           boolean forClass,\n+                                           Class<? extends Annotation>[] selectAnnotationClasses)\n+    {\n+        for (Class<?> c : selectAnnotationClasses) {\n+            if (!c.isAnnotation()) {\n+                throw new IllegalArgumentException(c + \" is not an annotation interface\");\n+            }\n+        }\n+        Map<Class<? extends Annotation>, Annotation> annotations =\n+                AnnotationParser.parseSelectAnnotations(rawAnnotations, cp, declaringClass, selectAnnotationClasses);\n+        if (forClass && annotations.size() != selectAnnotationClasses.length) {\n+            Class<?> superClass = declaringClass.getSuperclass();\n+            nextSuperClass:\n+            while (superClass != null) {\n+                JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+                Map<Class<? extends Annotation>, Annotation> superAnnotations =\n+                    AnnotationParser.parseSelectAnnotations(\n+                            jla.getRawClassAnnotations(superClass),\n+                            jla.getConstantPool(superClass),\n+                            superClass,\n+                            selectAnnotationClasses);\n+\n+                for (Map.Entry<Class<? extends Annotation>, Annotation> e : superAnnotations.entrySet()) {\n+                    Class<? extends Annotation> annotationClass = e.getKey();\n+                    if (!annotations.containsKey(annotationClass) && AnnotationType.getInstance(annotationClass).isInherited()) {\n+                        if (annotations.isEmpty()) {\n+                            \/\/ An empty map might be unmodifiable (e.g. Collections.emptyMap()).\n+                            annotations = new LinkedHashMap<Class<? extends Annotation>, Annotation>();\n+                        }\n+                        annotations.put(annotationClass, e.getValue());\n+                        if (annotations.size() == selectAnnotationClasses.length) {\n+                            break nextSuperClass;\n+                        }\n+                    }\n+                }\n+                superClass = superClass.getSuperclass();\n+            }\n+        }\n+        return encodeAnnotations(annotations.values());\n+    }\n+\n+    \/**\n+     * Encodes annotations to a byte array. The byte array can be decoded with {@link #decodeAnnotations(byte[], AnnotationDecoder)}.\n+     *\/\n+    public static byte[] encodeAnnotations(Collection<Annotation> annotations) {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream(128);\n+            try (DataOutputStream dos = new DataOutputStream(baos)) {\n+                writeLength(dos, annotations.size());\n+                for (Annotation a : annotations) {\n+                    encodeAnnotation(dos, a);\n+                }\n+            }\n+            return baos.toByteArray();\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static void encodeAnnotation(DataOutputStream dos, Annotation a) throws Exception {\n+        Class<? extends Annotation> type = a.annotationType();\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        dos.writeUTF(type.getName());\n+        writeLength(dos, values.size());\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            Object value = e.getValue();\n+            if (value == null) {\n+                \/\/ IncompleteAnnotationException\n+                dos.writeByte('x');\n+                dos.writeUTF(new IncompleteAnnotationException(type, e.getKey()).toString());\n+                continue;\n+            }\n+            Class<?> valueType = value.getClass();\n+            dos.writeUTF(e.getKey());\n+            if (valueType == Byte.class) {\n+                dos.writeByte('B');\n+                dos.writeByte((byte) value);\n+            } else if (valueType == Character.class) {\n+                dos.writeByte('C');\n+                dos.writeChar((char) value);\n+            } else if (valueType == Double.class) {\n+                dos.writeByte('D');\n+                dos.writeDouble((double) value);\n+            } else if (valueType == Float.class) {\n+                dos.writeByte('F');\n+                dos.writeFloat((float) value);\n+            } else if (valueType == Integer.class) {\n+                dos.writeByte('I');\n+                dos.writeInt((int) value);\n+            } else if (valueType == Long.class) {\n+                dos.writeByte('J');\n+                dos.writeLong((long) value);\n+            } else if (valueType == Short.class) {\n+                dos.writeByte('S');\n+                dos.writeShort((short) value);\n+            } else if (valueType == Boolean.class) {\n+                dos.writeByte('Z');\n+                dos.writeBoolean((boolean) value);\n+            } else if (valueType == String.class) {\n+                dos.writeByte('s');\n+                dos.writeUTF((String) value);\n+            } else if (valueType == Class.class) {\n+                dos.writeByte('c');\n+                dos.writeUTF(((Class<?>) value).getName());\n+            } else if (valueType.isEnum()) {\n+                dos.writeByte('e');\n+                dos.writeUTF(valueType.getName());\n+                dos.writeUTF(((Enum<?>) value).name());\n+            } else if (value instanceof Annotation) {\n+                dos.writeByte('@');\n+                encodeAnnotation(dos, (Annotation) value);\n+            } else if (valueType.isArray()) {\n+                Class<?> componentType = valueType.getComponentType();\n+                if (componentType == byte.class) {\n+                    byte[] array = (byte[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('B');\n+                    writeLength(dos, array.length);\n+                    dos.write(array);\n+                } else if (componentType == char.class) {\n+                    char[] array = (char[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('C');\n+                    writeLength(dos, array.length);\n+                    for (char c : array) {\n+                        dos.writeChar(c);\n+                    }\n+                } else if (componentType == double.class) {\n+                    double[] array = (double[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('D');\n+                    writeLength(dos, array.length);\n+                    for (double v : array) {\n+                        dos.writeDouble(v);\n+                    }\n+                } else if (componentType == float.class) {\n+                    float[] array = (float[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('F');\n+                    writeLength(dos, array.length);\n+                    for (float v : array) {\n+                        dos.writeFloat(v);\n+                    }\n+                } else if (componentType == int.class) {\n+                    int[] array = (int[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('I');\n+                    writeLength(dos, array.length);\n+                    for (int j : array) {\n+                        dos.writeInt(j);\n+                    }\n+                } else if (componentType == long.class) {\n+                    long[] array = (long[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('J');\n+                    writeLength(dos, array.length);\n+                    for (long l : array) {\n+                        dos.writeLong(l);\n+                    }\n+                } else if (componentType == short.class) {\n+                    short[] array = (short[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('S');\n+                    writeLength(dos, array.length);\n+                    for (short item : array) {\n+                        dos.writeShort(item);\n+                    }\n+                } else if (componentType == boolean.class) {\n+                    boolean[] array = (boolean[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('Z');\n+                    writeLength(dos, array.length);\n+                    for (boolean b : array) {\n+                        dos.writeBoolean(b);\n+                    }\n+                } else if (componentType == String.class) {\n+                    String[] array = (String[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('s');\n+                    writeLength(dos, array.length);\n+                    for (String s : array) {\n+                        dos.writeUTF(s);\n+                    }\n+                } else if (componentType == Class.class) {\n+                    Class<?>[] array = (Class<?>[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('c');\n+                    writeLength(dos, array.length);\n+                    for (Class<?> aClass : array) {\n+                        dos.writeUTF(aClass.getName());\n+                    }\n+                } else if (componentType.isEnum()) {\n+                    Enum<?>[] array = (Enum<?>[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('e');\n+                    dos.writeUTF(componentType.getName());\n+                    writeLength(dos, array.length);\n+                    for (Enum<?> anEnum : array) {\n+                        dos.writeUTF(anEnum.name());\n+                    }\n+                } else if (componentType.isAnnotation()) {\n+                    Annotation[] array = (Annotation[]) value;\n+                    dos.writeByte('[');\n+                    dos.writeByte('@');\n+                    writeLength(dos, array.length);\n+                    for (Annotation annotation : array) {\n+                        encodeAnnotation(dos, annotation);\n+                    }\n+                } else {\n+                    dos.writeByte('x');\n+                    dos.writeUTF(value.toString());\n+                }\n+\n+            } else {\n+                dos.writeByte('x');\n+                dos.writeUTF(value.toString());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Helper for {@link #decodeAnnotations(byte[], AnnotationDecoder)} to convert a byte\n+     * array (ostensibly produced by {@link VMSupport#encodeAnnotations}) into objects.\n+     *\n+     * @param <T> type to which a type name is {@linkplain #resolveType(String) resolved}\n+     * @param <A> type of the object representing a decoded annotation\n+     * @param <E> type of the object representing a decoded enum constant\n+     * @param <X> type of the object representing a decoded error\n+     *\/\n+    public interface AnnotationDecoder<T, A, E, X> {\n+        \/**\n+         * Resolves a name in {@link Class#getName()} format to an object of type {@code T}.\n+         *\/\n+        T resolveType(String name);\n+\n+        \/**\n+         * Creates an object representing a decoded annotation.\n+         *\n+         * @param type the annotation interface of the annotation\n+         * @param elements elements of the annotation\n+         *\/\n+        A newAnnotation(T type, Map.Entry<String, Object>[] elements);\n+\n+        \/**\n+         * Creates an object representing a decoded enum constant.\n+         *\n+         * @param enumType the enum type\n+         * @param name the name of the enum constant\n+         *\/\n+        E newEnumValue(T enumType, String name);\n+\n+        \/**\n+         * Creates an object representing a decoded error value.\n+         *\n+         * @param description of the error\n+         *\/\n+        X newErrorValue(String description);\n+    }\n+\n+    \/**\n+     * Decodes annotations serialized in {@code encoded} to objects.\n+     *\n+     * @param <T> type to which a type name is resolved\n+     * @param <A> type of the object representing a decoded annotation\n+     * @param <E> type of the object representing a decoded enum constant\n+     * @param <X> type of the object representing a decoded error\n+     * @return an immutable list of {@code A} objects\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public static <T, A, E, X> List<A> decodeAnnotations(byte[] encoded, AnnotationDecoder<T, A, E, X> decoder) {\n+        try {\n+            ByteArrayInputStream bais = new ByteArrayInputStream(encoded);\n+            DataInputStream dis = new DataInputStream(bais);\n+            return (List<A>) readArray(dis, () -> decodeAnnotation(dis, decoder));\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private static <T, A, E, X> A decodeAnnotation(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        String typeName = dis.readUTF();\n+        T type = decoder.resolveType(typeName);\n+        int n = readLength(dis);\n+        Map.Entry[] elements = new Map.Entry[n];\n+        for (int i = 0; i < n; i++) {\n+            String name = dis.readUTF();\n+            byte tag = dis.readByte();\n+            elements[i] = Map.entry(name, switch (tag) {\n+                case 'B' -> dis.readByte();\n+                case 'C' -> dis.readChar();\n+                case 'D' -> dis.readDouble();\n+                case 'F' -> dis.readFloat();\n+                case 'I' -> dis.readInt();\n+                case 'J' -> dis.readLong();\n+                case 'S' -> dis.readShort();\n+                case 'Z' -> dis.readBoolean();\n+                case 's' -> dis.readUTF();\n+                case 'c' -> decoder.resolveType(dis.readUTF());\n+                case 'e' -> decoder.newEnumValue(decoder.resolveType(dis.readUTF()), dis.readUTF());\n+                case '@' -> decodeAnnotation(dis, decoder);\n+                case '[' -> decodeArray(dis, decoder);\n+                case 'x' -> decoder.newErrorValue(dis.readUTF());\n+                default -> throw new InternalError(\"Unsupported tag: \" + tag);\n+            });\n+        }\n+        return decoder.newAnnotation(type, (Map.Entry<String, Object>[]) elements);\n+    }\n+    @FunctionalInterface\n+    interface IOReader {\n+        Object read() throws IOException;\n+    }\n+\n+    private static <T, A, E, X> Object decodeArray(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        byte componentTag = dis.readByte();\n+        return switch (componentTag) {\n+            case 'B' -> readArray(dis, dis::readByte);\n+            case 'C' -> readArray(dis, dis::readChar);\n+            case 'D' -> readArray(dis, dis::readDouble);\n+            case 'F' -> readArray(dis, dis::readFloat);\n+            case 'I' -> readArray(dis, dis::readInt);\n+            case 'J' -> readArray(dis, dis::readLong);\n+            case 'S' -> readArray(dis, dis::readShort);\n+            case 'Z' -> readArray(dis, dis::readBoolean);\n+            case 's' -> readArray(dis, dis::readUTF);\n+            case 'c' -> readArray(dis, () -> readClass(dis, decoder));\n+            case 'e' -> {\n+                T enumType = decoder.resolveType(dis.readUTF());\n+                yield readArray(dis, () -> readEnum(dis, decoder, enumType));\n+            }\n+            case '@' -> readArray(dis, () -> decodeAnnotation(dis, decoder));\n+            default -> throw new InternalError(\"Unsupported component tag: \" + componentTag);\n+        };\n+    }\n+\n+    \/**\n+     * Reads an enum encoded at the current read position of {@code dis} and\n+     * returns it as an object of type {@code E}.\n+     *\/\n+    private static <T, A, E, X> E readEnum(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder, T enumType) throws IOException {\n+        return decoder.newEnumValue(enumType, dis.readUTF());\n+    }\n+\n+    \/**\n+     * Reads a class encoded at the current read position of {@code dis} and\n+     * returns it as an object of type {@code T}.\n+     *\/\n+    private static <T, A, E, X> T readClass(DataInputStream dis, AnnotationDecoder<T, A, E, X> decoder) throws IOException {\n+        return decoder.resolveType(dis.readUTF());\n+    }\n+\n+    \/**\n+     * Reads an array encoded at the current read position of {@code dis} and\n+     * returns it in an immutable list.\n+     *\n+     * @param reader reads array elements from {@code dis}\n+     * @return an immutable list of {@code A} objects\n+     *\/\n+    private static List<Object> readArray(DataInputStream dis, IOReader reader) throws IOException {\n+        Object[] array = new Object[readLength(dis)];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = reader.read();\n+        }\n+        return List.of(array);\n+    }\n+\n+    \/**\n+     * Encodes {@code length} in 1 byte if it is less than 128.\n+     *\/\n+    private static void writeLength(DataOutputStream dos, int length) throws IOException {\n+        if (length < 0) {\n+            throw new NegativeArraySizeException();\n+        } else if (length <= 127) {\n+            dos.writeByte((byte) (0x80 | length));\n+        } else {\n+            dos.writeInt(length);\n+        }\n+    }\n+\n+    private static int readLength(DataInputStream dis) throws IOException {\n+        int ch1 = dis.readByte();\n+        int length;\n+        if (ch1 < 0) {\n+            length = ch1 & 0x7F;\n+        } else {\n+            int ch2 = dis.read();\n+            int ch3 = dis.read();\n+            int ch4 = dis.read();\n+            length = (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0);\n+        }\n+        return length;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":418,"deletions":6,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -262,1 +262,2 @@\n-        jdk.management.agent;\n+        jdk.management.agent,\n+        jdk.internal.vm.ci;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -680,0 +680,7 @@\n+    \/**\n+     * Gets an unmodifiable view on the member values.\n+     *\/\n+    Map<String, Object> memberValues() {\n+        return Collections.unmodifiableMap(memberValues);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationInvocationHandler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-     * This method is only used to parse select meta annotations in the construction\n+     * This method is used to parse select meta annotations in the construction\n@@ -93,1 +93,1 @@\n-    static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(\n+    public static Map<Class<? extends Annotation>, Annotation> parseSelectAnnotations(\n@@ -339,0 +339,2 @@\n+        \/\/ Note that VMSupport.encodeAnnotation (used by JVMCI) may need to\n+        \/\/ be updated if new annotation member types are added.\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -284,0 +284,9 @@\n+\n+    \/**\n+     * Gets an unmodifiable view of {@code a}'s elements.\n+     *\n+     * @return a map from element names to element values\n+     *\/\n+    public static Map<String, Object> memberValues(Annotation a) {\n+        return ((AnnotationInvocationHandler) Proxy.getInvocationHandler(a)).memberValues();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationSupport.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -9,2 +9,2 @@\n-See Terms of Use for definitions of Unicode Inc.'s\n-Data Files and Software.\n+See Terms of Use <https:\/\/www.unicode.org\/copyright.html>\n+for definitions of Unicode Inc.s Data Files and Software.\n@@ -55,1 +55,0 @@\n------------------------------------------------------------- Terms of Use ---------------------------------------------------------------\n@@ -57,2 +56,1 @@\n-Unicode Copyright and Terms of Use\n-For the general privacy policy governing access to this site, see the  Unicode Privacy Policy.\n+------------------------------------------------------------ Terms of Use ---------------------------------------------------------------\n@@ -60,43 +58,0 @@\n-Unicode Copyright\n-Copyright  1991-2022 Unicode, Inc. All rights reserved.\n-Definitions\n-Unicode Data Files (\"DATA FILES\") include all data files under the directories:\n-https:\/\/www.unicode.org\/Public\/\n-https:\/\/www.unicode.org\/reports\/\n-https:\/\/www.unicode.org\/ivd\/data\/\n-\n-Unicode Data Files do not include PDF online code charts under the directory:\n-https:\/\/www.unicode.org\/Public\/\n-\n-Unicode Software (\"SOFTWARE\") includes any source code published in the Unicode Standard\n-or any source code or compiled code under the directories:\n-https:\/\/www.unicode.org\/Public\/PROGRAMS\/\n-https:\/\/www.unicode.org\/Public\/cldr\/\n-http:\/\/site.icu-project.org\/download\/\n-Terms of Use\n-Certain documents and files on this website contain a legend indicating that \"Modification is permitted.\" Any person is hereby authorized, without fee, to modify such documents and files to create derivative works conforming to the Unicode Standard, subject to Terms and Conditions herein.\n-Any person is hereby authorized, without fee, to view, use, reproduce, and distribute all documents and files, subject to the Terms and Conditions herein.\n-Further specifications of rights and restrictions pertaining to the use of the Unicode DATA FILES and SOFTWARE can be found in the Unicode Data Files and Software License.\n-Each version of the Unicode Standard has further specifications of rights and restrictions of use. For the book editions (Unicode 5.0 and earlier), these are found on the back of the title page.\n-The Unicode PDF online code charts carry specific restrictions. Those restrictions are incorporated as the first page of each PDF code chart.\n-All other files, including online documentation of the core specification for Unicode 6.0 and later, are covered under these general Terms of Use.\n-No license is granted to \"mirror\" the Unicode website where a fee is charged for access to the \"mirror\" site.\n-Modification is not permitted with respect to this document. All copies of this document must be verbatim.\n-Restricted Rights Legend\n-Any technical data or software which is licensed to the United States of America, its agencies and\/or instrumentalities under this Agreement is commercial technical data or commercial computer software developed exclusively at private expense as defined in FAR 2.101, or DFARS 252.227-7014 (June 1995), as applicable. For technical data, use, duplication, or disclosure by the Government is subject to restrictions as set forth in DFARS 202.227-7015 Technical Data, Commercial and Items (Nov 1995) and this Agreement. For Software, in accordance with FAR 12-212 or DFARS 227-7202, as applicable, use, duplication or disclosure by the Government is subject to the restrictions set forth in this Agreement.\n-Warranties and Disclaimers\n-This publication and\/or website may include technical or typographical errors or other inaccuracies. Changes are periodically added to the information herein; these changes will be incorporated in new editions of the publication and\/or website. Unicode, Inc. may make improvements and\/or changes in the product(s) and\/or program(s) described in this publication and\/or website at any time.\n-If this file has been purchased on magnetic or optical media from Unicode, Inc. the sole and exclusive remedy for any claim will be exchange of the defective media within ninety (90) days of original purchase.\n-EXCEPT AS PROVIDED IN SECTION E.2, THIS PUBLICATION AND\/OR SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND EITHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. UNICODE, INC. AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR ERRORS OR OMISSIONS IN THIS PUBLICATION AND\/OR SOFTWARE OR OTHER DOCUMENTS WHICH ARE REFERENCED BY OR LINKED TO THIS PUBLICATION OR THE UNICODE WEBSITE.\n-Waiver of Damages\n-In no event shall Unicode, Inc. or its licensors be liable for any special, incidental, indirect or consequential damages of any kind, or any damages whatsoever, whether or not Unicode, Inc. was advised of the possibility of the damage, including, without limitation, those resulting from the following: loss of use, data or profits, in connection with the use, modification or distribution of this information or its derivatives.\n-Trademarks & Logos\n-The Unicode Word Mark and the Unicode Logo are trademarks of Unicode, Inc. The Unicode Consortium and Unicode, Inc. are trade names of Unicode, Inc. Use of the information and materials found on this website indicates your acknowledgement of Unicode, Inc.s exclusive worldwide rights in the Unicode Word Mark, the Unicode Logo, and the Unicode trade names.\n-The Unicode Consortium Name and Trademark Usage Policy (Trademark Policy) are incorporated herein by reference and you agree to abide by the provisions of the Trademark Policy, which may be changed from time to time in the sole discretion of Unicode, Inc.\n-All third party trademarks referenced herein are the property of their respective owners.\n-Miscellaneous\n-Jurisdiction and Venue. This website is operated from a location in the State of California, United States of America. Unicode, Inc. makes no representation that the materials are appropriate for use in other locations. If you access this website from other locations, you are responsible for compliance with local laws. This Agreement, all use of this website and any claims and damages resulting from use of this website are governed solely by the laws of the State of California without regard to any principles which would apply the laws of a different jurisdiction. The user agrees that any disputes regarding this website shall be resolved solely in the courts located in Santa Clara County, California. The user agrees said courts have personal jurisdiction and agree to waive any right to transfer the dispute to any other forum.\n-Modification by Unicode, Inc. Unicode, Inc. shall have the right to modify this Agreement at any time by posting it to this website. The user may not assign any part of this Agreement without Unicode, Inc.s prior written consent.\n-Taxes. The user agrees to pay any taxes arising from access to this website or use of the information herein, except for those based on Unicodes net income.\n-Severability.  If any provision of this Agreement is declared invalid or unenforceable, the remaining provisions of this Agreement shall remain in effect.\n-Entire Agreement. This Agreement constitutes the entire agreement between the parties.\n@@ -104,0 +59,49 @@\n+    Unicode Copyright and Terms of Use\n+\n+    For the general privacy policy governing access to this site, see the  Unicode Privacy Policy.\n+\n+        Unicode Copyright\n+            Copyright  1991-2023 Unicode, Inc. All rights reserved.\n+        Definitions\n+\n+        Unicode Data Files (\"DATA FILES\") include all data files under the directories:\n+        https:\/\/www.unicode.org\/Public\/\n+        https:\/\/www.unicode.org\/reports\/\n+        https:\/\/www.unicode.org\/ivd\/data\/\n+\n+        Unicode Data Files do not include PDF online code charts under the directory:\n+        https:\/\/www.unicode.org\/Public\/\n+\n+        Unicode Software (\"SOFTWARE\") includes any source code published in the Unicode Standard\n+        or any source code or compiled code under the directories:\n+        https:\/\/www.unicode.org\/Public\/PROGRAMS\/\n+        https:\/\/www.unicode.org\/Public\/cldr\/\n+        http:\/\/site.icu-project.org\/download\/\n+\n+        Terms of Use\n+            Certain documents and files on this website contain a legend indicating that \"Modification is permitted.\" Any person is hereby authorized, without fee, to modify such documents and files to create derivative works conforming to the Unicode Standard, subject to Terms and Conditions herein.\n+            Any person is hereby authorized, without fee, to view, use, reproduce, and distribute all documents and files, subject to the Terms and Conditions herein.\n+            Further specifications of rights and restrictions pertaining to the use of the Unicode DATA FILES and SOFTWARE can be found in the Unicode Data Files and Software License.\n+            Each version of the Unicode Standard has further specifications of rights and restrictions of use. For the book editions (Unicode 5.0 and earlier), these are found on the back of the title page.\n+            The Unicode PDF online code charts carry specific restrictions. Those restrictions are incorporated as the first page of each PDF code chart.\n+            All other files, including online documentation of the core specification for Unicode 6.0 and later, are covered under these general Terms of Use.\n+            No license is granted to \"mirror\" the Unicode website where a fee is charged for access to the \"mirror\" site.\n+            Modification is not permitted with respect to this document. All copies of this document must be verbatim.\n+        Restricted Rights Legend\n+            Any technical data or software which is licensed to the United States of America, its agencies and\/or instrumentalities under this Agreement is commercial technical data or commercial computer software developed exclusively at private expense as defined in FAR 2.101, or DFARS 252.227-7014 (June 1995), as applicable. For technical data, use, duplication, or disclosure by the Government is subject to restrictions as set forth in DFARS 202.227-7015 Technical Data, Commercial and Items (Nov 1995) and this Agreement. For Software, in accordance with FAR 12-212 or DFARS 227-7202, as applicable, use, duplication or disclosure by the Government is subject to the restrictions set forth in this Agreement.\n+        Warranties and Disclaimers\n+            This publication and\/or website may include technical or typographical errors or other inaccuracies. Changes are periodically added to the information herein; these changes will be incorporated in new editions of the publication and\/or website. Unicode, Inc. may make improvements and\/or changes in the product(s) and\/or program(s) described in this publication and\/or website at any time.\n+            If this file has been purchased on magnetic or optical media from Unicode, Inc. the sole and exclusive remedy for any claim will be exchange of the defective media within ninety (90) days of original purchase.\n+            EXCEPT AS PROVIDED IN SECTION E.2, THIS PUBLICATION AND\/OR SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND EITHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. UNICODE, INC. AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR ERRORS OR OMISSIONS IN THIS PUBLICATION AND\/OR SOFTWARE OR OTHER DOCUMENTS WHICH ARE REFERENCED BY OR LINKED TO THIS PUBLICATION OR THE UNICODE WEBSITE.\n+        Waiver of Damages\n+            In no event shall Unicode, Inc. or its licensors be liable for any special, incidental, indirect or consequential damages of any kind, or any damages whatsoever, whether or not Unicode, Inc. was advised of the possibility of the damage, including, without limitation, those resulting from the following: loss of use, data or profits, in connection with the use, modification or distribution of this information or its derivatives.\n+        Trademarks & Logos\n+            The Unicode Word Mark and the Unicode Logo are trademarks of Unicode, Inc. The Unicode Consortium and Unicode, Inc. are trade names of Unicode, Inc. Use of the information and materials found on this website indicates your acknowledgement of Unicode, Inc.s exclusive worldwide rights in the Unicode Word Mark, the Unicode Logo, and the Unicode trade names.\n+            The Unicode Consortium Name and Trademark Usage Policy (Trademark Policy) are incorporated herein by reference and you agree to abide by the provisions of the Trademark Policy, which may be changed from time to time in the sole discretion of Unicode, Inc.\n+            All third party trademarks referenced herein are the property of their respective owners.\n+        Miscellaneous\n+            Jurisdiction and Venue. This website is operated from a location in the State of California, United States of America. Unicode, Inc. makes no representation that the materials are appropriate for use in other locations. If you access this website from other locations, you are responsible for compliance with local laws. This Agreement, all use of this website and any claims and damages resulting from use of this website are governed solely by the laws of the State of California without regard to any principles which would apply the laws of a different jurisdiction. The user agrees that any disputes regarding this website shall be resolved solely in the courts located in Santa Clara County, California. The user agrees said courts have personal jurisdiction and agree to waive any right to transfer the dispute to any other forum.\n+            Modification by Unicode, Inc. Unicode, Inc. shall have the right to modify this Agreement at any time by posting it to this website. The user may not assign any part of this Agreement without Unicode, Inc.s prior written consent.\n+            Taxes. The user agrees to pay any taxes arising from access to this website or use of the information herein, except for those based on Unicodes net income.\n+            Severability.  If any provision of this Agreement is declared invalid or unenforceable, the remaining provisions of this Agreement shall remain in effect.\n+            Entire Agreement. This Agreement constitutes the entire agreement between the parties.\n","filename":"src\/java.base\/share\/legal\/cldr.md","additions":52,"deletions":48,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -633,1 +633,1 @@\n-static jstring jnuEncoding = NULL;\n+static jobject jnuCharset = NULL;\n@@ -636,2 +636,2 @@\n-static jmethodID String_init_ID;        \/* String(byte[], enc) *\/\n-static jmethodID String_getBytes_ID;    \/* String.getBytes(enc) *\/\n+static jmethodID String_init_ID;        \/* String(byte[], Charset) *\/\n+static jmethodID String_getBytes_ID;    \/* String.getBytes(Charset) *\/\n@@ -661,1 +661,1 @@\n-                                   String_init_ID, bytes, jnuEncoding);\n+                                   String_init_ID, bytes, jnuCharset);\n@@ -720,0 +720,1 @@\n+        const char *charsetname = NULL;\n@@ -726,3 +727,1 @@\n-            jstring enc = (*env)->NewStringUTF(env, encname);\n-            if (enc == NULL)\n-                return;\n+            charsetname = encname;\n@@ -730,2 +729,0 @@\n-            jnuEncoding = (jstring)(*env)->NewGlobalRef(env, enc);\n-            (*env)->DeleteLocalRef(env, enc);\n@@ -741,3 +738,7 @@\n-            jboolean exe;\n-            jstring enc = (*env)->NewStringUTF(env, encname);\n-            if (enc == NULL)\n+            charsetname = encname;\n+            fastEncoding = NO_FAST_ENCODING;\n+        }\n+        while (charsetname != NULL) {\n+            jstring enc = (*env)->NewStringUTF(env, charsetname);\n+            if (enc == NULL) {\n+                fastEncoding = NO_ENCODING_YET;\n@@ -745,0 +746,12 @@\n+            }\n+            jboolean exc;\n+            jvalue charset = JNU_CallStaticMethodByName(\n+                    env, &exc,\n+                    \"java\/nio\/charset\/Charset\",\n+                    \"forName\",\n+                    \"(Ljava\/lang\/String;)Ljava\/nio\/charset\/Charset;\",\n+                    enc);\n+            if (exc) {\n+                (*env)->ExceptionClear(env);\n+            }\n+            (*env)->DeleteLocalRef(env, enc);\n@@ -746,15 +759,6 @@\n-            if ((jboolean) JNU_CallStaticMethodByName (\n-                                            env, &exe,\n-                                            \"java\/nio\/charset\/Charset\",\n-                                            \"isSupported\",\n-                                            \"(Ljava\/lang\/String;)Z\",\n-                                            enc).z == JNI_TRUE) {\n-                fastEncoding = NO_FAST_ENCODING;\n-                jnuEncoding = (jstring)(*env)->NewGlobalRef(env, enc);\n-            } else {\n-                \/\/ jnuEncoding falls back to UTF-8\n-                jstring utf8 = (*env)->NewStringUTF(env, \"UTF-8\");\n-                if (utf8 == NULL) {\n-                    (*env)->DeleteLocalRef(env, enc);\n-                    return;\n-                }\n+            if (!exc && charset.l != NULL) {\n+                jnuCharset = (*env)->NewGlobalRef(env, charset.l);\n+                (*env)->DeleteLocalRef(env, charset.l);\n+                break; \/\/ success, continue below\n+            } else if (strcmp(charsetname, \"UTF-8\") != 0) { \/\/ fall back\n+                charsetname = \"UTF-8\";\n@@ -762,2 +766,3 @@\n-                jnuEncoding = (jstring)(*env)->NewGlobalRef(env, utf8);\n-                (*env)->DeleteLocalRef(env, utf8);\n+            } else { \/\/ give up\n+                fastEncoding = NO_ENCODING_YET;\n+                return;\n@@ -765,1 +770,0 @@\n-            (*env)->DeleteLocalRef(env, enc);\n@@ -774,1 +778,1 @@\n-                                             \"getBytes\", \"(Ljava\/lang\/String;)[B\");\n+                                             \"getBytes\", \"(Ljava\/nio\/charset\/Charset;)[B\");\n@@ -777,1 +781,1 @@\n-                                         \"<init>\", \"([BLjava\/lang\/String;)V\");\n+                                         \"<init>\", \"([BLjava\/nio\/charset\/Charset;)V\");\n@@ -816,1 +820,1 @@\n-    hab = (*env)->CallObjectMethod(env, jstr, String_getBytes_ID, jnuEncoding);\n+    hab = (*env)->CallObjectMethod(env, jstr, String_getBytes_ID, jnuCharset);\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -878,1 +878,2 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && (__clang_major__ >= 8))\n+\/* avoid with xlc16 clang on AIX; it sets the gcc macros *\/\n+#if (defined(__GNUC__) && !defined(AIX) && (__GNUC__ >= 4)) || (defined(__clang__) && (__clang_major__ >= 8))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-algs.hh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+\n+#if !defined(AIX)\n@@ -47,0 +49,2 @@\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n-  public boolean hasLineNumberTable  () { return (flags & JVM_ACC_HAS_LINE_NUMBER_TABLE  ) != 0; }\n-  public boolean hasCheckedExceptions() { return (flags & JVM_ACC_HAS_CHECKED_EXCEPTIONS ) != 0; }\n@@ -73,2 +71,0 @@\n-  public boolean hasMirandaMethods    () { return (flags & JVM_ACC_HAS_MIRANDA_METHODS    ) != 0; }\n-  public boolean hasVanillaConstructor() { return (flags & JVM_ACC_HAS_VANILLA_CONSTRUCTOR) != 0; }\n@@ -78,3 +74,0 @@\n-  \/\/ Klass* and Method* flags\n-  public boolean hasLocalVariableTable() { return (flags & JVM_ACC_HAS_LOCAL_VARIABLE_TABLE ) != 0; }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-    isMarkedDependent    = new CIntField(type.getCIntegerField(\"_is_marked_dependent\"), 0);\n@@ -148,1 +147,0 @@\n-  private static CIntField isMarkedDependent;\n@@ -376,1 +374,0 @@\n-  public boolean   getIsMarkedDependent()   { return                isMarkedDependent.getValue(this) != 0; }\n@@ -574,1 +571,0 @@\n-      visitor.doCInt(isMarkedDependent, true);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,2 +235,0 @@\n-  public boolean hasVanillaConstructor()    { return getAccessFlagsObj().hasVanillaConstructor(); }\n-  public boolean hasMirandaMethods ()       { return getAccessFlagsObj().hasMirandaMethods(); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,2 +121,0 @@\n-    public static final long JVM_ACC_HAS_LINE_NUMBER_TABLE  = 0x00100000;\n-    public static final long JVM_ACC_HAS_CHECKED_EXCEPTIONS = 0x00400000;\n@@ -128,4 +126,0 @@\n-    \/\/ True if this class has miranda methods in it's vtable\n-    public static final long JVM_ACC_HAS_MIRANDA_METHODS      = 0x10000000;\n-    \/\/ True if klass has a vanilla default constructor\n-    public static final long JVM_ACC_HAS_VANILLA_CONSTRUCTOR  = 0x20000000;\n@@ -137,3 +131,0 @@\n-    \/\/ Method* flags\n-    public static final long JVM_ACC_HAS_LOCAL_VARIABLE_TABLE = 0x00200000;\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot;\n+\n+import java.util.Map;\n+\n+import jdk.internal.vm.VMSupport.AnnotationDecoder;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n+import jdk.vm.ci.meta.ErrorData;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaUtil;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n+\n+\/**\n+ * Implementation of {@link AnnotationDecoder} that resolves type names to {@link JavaType} values\n+ * and employs {@link AnnotationData} and {@link EnumData} to represent decoded annotations and enum\n+ * constants respectively.\n+ *\/\n+final class AnnotationDataDecoder implements AnnotationDecoder<JavaType, AnnotationData, EnumData, ErrorData> {\n+\n+    static final AnnotationDataDecoder INSTANCE = new AnnotationDataDecoder();\n+\n+    @Override\n+    public JavaType resolveType(String name) {\n+        String internalName = MetaUtil.toInternalName(name);\n+        return UnresolvedJavaType.create(internalName);\n+    }\n+\n+    @Override\n+    public AnnotationData newAnnotation(JavaType type, Map.Entry<String, Object>[] elements) {\n+        return new AnnotationData(type, elements);\n+    }\n+\n+    @Override\n+    public EnumData newEnumValue(JavaType enumType, String name) {\n+        return new EnumData(enumType, name);\n+    }\n+\n+    @Override\n+    public ErrorData newErrorValue(String description) {\n+        return new ErrorData(description);\n+    }\n+\n+    static ResolvedJavaType[] asArray(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        ResolvedJavaType[] filter = new ResolvedJavaType[2 + types.length];\n+        filter[0] = type1;\n+        filter[1] = type2;\n+        System.arraycopy(types, 0, filter, 2, types.length);\n+        return filter;\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/AnnotationDataDecoder.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -51,0 +52,6 @@\n+ *\n+ * Note also that some calls pass a raw VM value to avoid a JNI upcall. For example,\n+ * {@link #getBytecode(HotSpotResolvedJavaMethodImpl, long)} needs the raw {@code Method*} value\n+ * (stored in {@link HotSpotResolvedJavaMethodImpl#methodHandle}) in the C++ implementation. The\n+ * {@link HotSpotResolvedJavaMethodImpl} wrapper is still passed as well as it may be the last\n+ * reference keeping the raw value alive.\n@@ -1306,0 +1313,85 @@\n+\n+    \/**\n+     * Gets the serialized annotation info for {@code type} by calling\n+     * {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedClassAnnotationData(HotSpotResolvedObjectTypeImpl type, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedClassAnnotationData(type, type.getKlassPointer(),\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedClassAnnotationData(HotSpotResolvedObjectTypeImpl type, long klassPointer,\n+                    Object filter, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Gets the serialized annotation info for {@code method} by calling\n+     * {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedExecutableAnnotationData(HotSpotResolvedJavaMethodImpl method, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedExecutableAnnotationData(method, method.getMethodPointer(),\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedExecutableAnnotationData(HotSpotResolvedJavaMethodImpl method, long methodPointer,\n+                    Object filter, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Gets the serialized annotation info for the field denoted by {@code holder} and\n+     * {@code fieldIndex} by calling {@code VMSupport.encodeAnnotations} in the HotSpot heap.\n+     *\/\n+    byte[] getEncodedFieldAnnotationData(HotSpotResolvedObjectTypeImpl holder, int fieldIndex, ResolvedJavaType[] filter) {\n+        try (KlassPointers a = new KlassPointers(filter)) {\n+            return getEncodedFieldAnnotationData(holder, holder.getKlassPointer(), fieldIndex,\n+                            a.types, a.types.length, a.buffer());\n+        }\n+    }\n+\n+    native byte[] getEncodedFieldAnnotationData(HotSpotResolvedObjectTypeImpl holder, long klassPointer, int fieldIndex,\n+                    Object filterTypes, int filterLength, long filterKlassPointers);\n+\n+    \/**\n+     * Helper for passing {@Klass*} values to native code.\n+     *\/\n+    static final class KlassPointers implements AutoCloseable {\n+        final ResolvedJavaType[] types;\n+        long pointersArray;\n+        final Unsafe unsafe = UnsafeAccess.UNSAFE;\n+\n+        KlassPointers(ResolvedJavaType[] types) {\n+            this.types = types;\n+        }\n+\n+        \/**\n+         * Gets the buffer in which to pass the {@Klass*} values to JNI.\n+         *\n+         * @return a {@Klass*} value if {@code types.length == 1} otherwise the address of a native\n+         *         buffer holding an array of {@Klass*} values\n+         *\/\n+        long buffer() {\n+            int length = types.length;\n+            if (length == 1) {\n+                return ((HotSpotResolvedObjectTypeImpl) types[0]).getKlassPointer();\n+            } else {\n+                pointersArray = unsafe.allocateMemory(length * Long.BYTES);\n+                long pos = pointersArray;\n+                for (int i = 0; i < types.length; i++) {\n+                    HotSpotResolvedObjectTypeImpl hsType = (HotSpotResolvedObjectTypeImpl) types[i];\n+                    unsafe.putLong(pos, hsType.getKlassPointer());\n+                    pos += Long.BYTES;\n+                }\n+            }\n+            return pointersArray;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (types.length != 1 && pointersArray != 0) {\n+                unsafe.freeMemory(pointersArray);\n+                pointersArray = 0;\n+            }\n+        }\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n@@ -31,0 +32,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -32,2 +35,2 @@\n-import jdk.internal.vm.annotation.Stable;\n-\n+import jdk.internal.vm.VMSupport;\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -230,0 +233,21 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType annotationType) {\n+        if (!hasAnnotations()) {\n+            return null;\n+        }\n+        return getAnnotationData0(annotationType).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!hasAnnotations()) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n+        byte[] encoded = compilerToVM().getEncodedFieldAnnotationData(holder, index, filter);\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -40,0 +42,1 @@\n+import jdk.internal.vm.VMSupport;\n@@ -42,0 +45,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -526,1 +530,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -534,1 +538,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -542,1 +546,1 @@\n-        if ((getConstMethodFlags() & config().constMethodHasMethodAnnotations) == 0 || isClassInitializer()) {\n+        if (!hasAnnotations()) {\n@@ -548,0 +552,7 @@\n+    \/**\n+     * Returns whether this method has annotations.\n+     *\/\n+    private boolean hasAnnotations() {\n+        return (getConstMethodFlags() & config().constMethodHasMethodAnnotations) != 0 && !isClassInitializer();\n+    }\n+\n@@ -755,0 +766,21 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        if (!hasAnnotations()) {\n+            return null;\n+        }\n+        return getAnnotationData0(type).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!hasAnnotations()) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n+        byte[] encoded = compilerToVM().getEncodedExecutableAnnotationData(this, filter);\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Collections;\n@@ -40,0 +41,1 @@\n+import java.util.List;\n@@ -41,0 +43,1 @@\n+import jdk.internal.vm.VMSupport;\n@@ -42,0 +45,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -874,0 +878,29 @@\n+    \/**\n+     * Determines if this type may have annotations. A positive result does not mean this type has\n+     * annotations but a negative result guarantees this type has no annotations.\n+     *\n+     * @param includingInherited if true, expand this query to include superclasses of this type\n+     *\/\n+    private boolean mayHaveAnnotations(boolean includingInherited) {\n+        if (isArray()) {\n+            return false;\n+        }\n+        HotSpotVMConfig config = config();\n+        final long metaspaceAnnotations = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassAnnotationsOffset);\n+        if (metaspaceAnnotations != 0) {\n+            long classAnnotations = UNSAFE.getAddress(metaspaceAnnotations + config.annotationsClassAnnotationsOffset);\n+            if (classAnnotations != 0) {\n+                return true;\n+            }\n+        }\n+        if (includingInherited) {\n+            HotSpotResolvedObjectTypeImpl superClass = getSuperclass();\n+            if (superClass != null) {\n+                return superClass.mayHaveAnnotations(true);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static final Annotation[] NO_ANNOTATIONS = {};\n+\n@@ -876,0 +909,3 @@\n+        if (!mayHaveAnnotations(true)) {\n+            return NO_ANNOTATIONS;\n+        }\n@@ -881,0 +917,3 @@\n+        if (!mayHaveAnnotations(false)) {\n+            return NO_ANNOTATIONS;\n+        }\n@@ -886,0 +925,3 @@\n+        if (!mayHaveAnnotations(true)) {\n+            return null;\n+        }\n@@ -1065,0 +1107,21 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType annotationType) {\n+        if (!mayHaveAnnotations(true)) {\n+            return null;\n+        }\n+        return getAnnotationData0(annotationType).get(0);\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        if (!mayHaveAnnotations(true)) {\n+            return Collections.emptyList();\n+        }\n+        return getAnnotationData0(AnnotationDataDecoder.asArray(type1, type2, types));\n+    }\n+\n+    private List<AnnotationData> getAnnotationData0(ResolvedJavaType... filter) {\n+        byte[] encoded = compilerToVM().getEncodedClassAnnotationData(this, filter);\n+        return VMSupport.decodeAnnotations(encoded, AnnotationDataDecoder.INSTANCE);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.Collections;\n+import java.util.List;\n@@ -33,0 +35,1 @@\n+import jdk.vm.ci.meta.AnnotationData;\n@@ -320,0 +323,11 @@\n+\n+    @Override\n+    public AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        return Collections.emptyList();\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedPrimitiveType.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    final int annotationsClassAnnotationsOffset = getFieldOffset(\"Annotations::_class_annotations\", Integer.class, \"AnnotationArray*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * An object handle in {@code JVMCI::_object_handles}.\n+     * An object handle in {@code JVMCIRuntime::_oop_handles}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/IndirectHotSpotObjectConstantImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+import java.lang.annotation.Inherited;\n+import java.util.List;\n+\n+\/**\n+ * Represents a program element such as a method, constructor, field or class for which annotations\n+ * may be present.\n+ *\/\n+public interface Annotated {\n+\n+    \/**\n+     * Constructs the annotations present on this element whose types are in the set composed of {@code type1},\n+     * {@code type2} and {@code types}. All enum types referenced by the returned annotation are\n+     * initialized. Class initialization is not triggered for enum types referenced by other\n+     * annotations of this element.\n+     *\n+     * If this element is a class, then {@link Inherited} annotations are included in the set of\n+     * annotations considered.\n+     *\n+     * See {@link java.lang.reflect.AnnotatedElement} for the definition of <em>present<\/em>.\n+     *\n+     * @param type1 an annotation type\n+     * @param type2 an annotation type\n+     * @param types more annotation types\n+     * @return an immutable list of the annotations present on this element that match one of the\n+     *         given types\n+     * @throws IllegalArgumentException if any type in the set composed of {@code type1},\n+     *             {@code type2} and {@code types} is not an annotation interface type\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default List<AnnotationData> getAnnotationData(ResolvedJavaType type1, ResolvedJavaType type2, ResolvedJavaType... types) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Constructs the annotation present on this element of type {@code type}.\n+     *\n+     * See {@link java.lang.reflect.AnnotatedElement} for the definition of <em>present<\/em>.\n+     *\n+     * @param type the type object corresponding to the annotation interface type\n+     * @return this element's annotation for the specified annotation type if present on this\n+     *         element, else null\n+     * @throws IllegalArgumentException if {@code type} is not an annotation interface type\n+     * @throws UnsupportedOperationException if this operation is not supported\n+     *\/\n+    default AnnotationData getAnnotationData(ResolvedJavaType type) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/Annotated.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * Represents an annotation where element values are represented with the types described\n+ * {@linkplain #get here}.\n+ *\n+ * In contrast to the standard annotation API based on {@link Annotation}, use of\n+ * {@link AnnotationData} allows annotations to be queried without the JVMCI runtime having to\n+ * support dynamic loading of arbitrary {@link Annotation} classes. Such support is impossible in a\n+ * closed world, ahead-of-time compiled environment such as libgraal.\n+ *\/\n+public final class AnnotationData {\n+\n+    private final JavaType type;\n+    private final Map<String, Object> elements;\n+\n+    private static final Set<Class<?>> ELEMENT_TYPES = Set.of(\n+                    Boolean.class,\n+                    Byte.class,\n+                    Character.class,\n+                    Short.class,\n+                    Integer.class,\n+                    Float.class,\n+                    Long.class,\n+                    Double.class,\n+                    String.class,\n+                    EnumData.class,\n+                    AnnotationData.class);\n+\n+    \/**\n+     * Creates an annotation.\n+     *\n+     * @param type the annotation interface of this annotation, represented as a {@link JavaType}\n+     * @param elements the names and values of this annotation's element values. Each value's type\n+     *            must be one of the {@code AnnotationData} types described {@linkplain #get here}\n+     *            or it must be a {@link ErrorData} object whose {@code toString()} value describes\n+     *            the error raised while parsing the element. There is no distinction between a\n+     *            value explicitly present in the annotation and an element's default value.\n+     * @throws IllegalArgumentException if the value of an entry in {@code elements} is not of an\n+     *             accepted type\n+     * @throws NullPointerException if any of the above parameters is null or any entry in\n+     *             {@code elements} is null\n+     *\/\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public AnnotationData(JavaType type, Map.Entry<String, Object>[] elements) {\n+        this.type = Objects.requireNonNull(type);\n+        for (Map.Entry<String, Object> e : elements) {\n+            Object value = e.getValue();\n+            if (!(value instanceof ErrorData) &&\n+                            !(value instanceof JavaType) &&\n+                            !(value instanceof List) &&\n+                            !ELEMENT_TYPES.contains(value.getClass())) {\n+                throw new IllegalArgumentException(\"illegal type for element \" + e.getKey() + \": \" + value.getClass().getName());\n+            }\n+        }\n+        this.elements = Map.ofEntries(elements);\n+    }\n+\n+    \/**\n+     * @return the annotation interface of this annotation, represented as a {@link JavaType}\n+     *\/\n+    public JavaType getAnnotationType() {\n+        return type;\n+    }\n+\n+    \/\/ @formatter:off\n+    \/**\n+     * Gets the annotation element denoted by {@code name}. The following table shows the\n+     * correspondence between the type of an element as declared by a method in the annotation\n+     * interface and the type of value returned by this method:\n+     * <table>\n+     * <thead>\n+     * <tr><th>Annotation<\/th> <th>AnnotationData<\/th><\/tr>\n+     * <\/thead><tbody>\n+     * <tr><td>boolean<\/td>    <td>Boolean<\/td><\/tr>\n+     * <tr><td>byte<\/td>       <td>Byte<\/td><\/tr>\n+     * <tr><td>char<\/td>       <td>Character<\/td><\/tr>\n+     * <tr><td>short<\/td>      <td>Short<\/td><\/tr>\n+     * <tr><td>int<\/td>        <td>Integer<\/td><\/tr>\n+     * <tr><td>float<\/td>      <td>Float<\/td><\/tr>\n+     * <tr><td>long<\/td>       <td>Long<\/td><\/tr>\n+     * <tr><td>double<\/td>     <td>Double<\/td><\/tr>\n+     * <tr><td>String<\/td>     <td>String<\/td><\/tr>\n+     * <tr><td>Class<\/td>      <td>JavaType<\/td><\/tr>\n+     * <tr><td>Enum<\/td>       <td>EnumData<\/td><\/tr>\n+     * <tr><td>Annotation<\/td> <td>AnnotationData<\/td><\/tr>\n+     * <tr><td>[]<\/td><td>immutable List&lt;T&gt; where T is one of the above types<\/td><\/tr>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * @param <V> the type of the element as per the {@code AnnotationData} column in the above\n+     *            table or {@link Object}\n+     * @param elementType the class for the type of the element\n+     * @return the annotation element denoted by {@code name}\n+     * @throws ClassCastException if the element is not of type {@code V}\n+     * @throws IllegalArgumentException if this annotation has no element named {@code name} or if\n+     *             there was an error parsing or creating the element value\n+     *\/\n+    \/\/ @formatter:on\n+    @SuppressWarnings(\"unchecked\")\n+    public <V> V get(String name, Class<V> elementType) {\n+        Object val = elements.get(name);\n+        if (val == null) {\n+            throw new IllegalArgumentException(\"no element named \" + name);\n+        }\n+        Class<? extends Object> valClass = val.getClass();\n+        if (valClass == ErrorData.class) {\n+            throw new IllegalArgumentException(val.toString());\n+        }\n+        return elementType.cast(val);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"@\" + type.getName() + \"(\" + elements + \")\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof AnnotationData) {\n+            AnnotationData that = (AnnotationData) obj;\n+            return this.type.equals(that.type) && this.elements.equals(that.elements);\n+\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return type.hashCode() ^ elements.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/AnnotationData.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents an enum constant within {@link AnnotationData}.\n+ *\/\n+public final class EnumData {\n+    private final JavaType type;\n+    private final String name;\n+\n+    \/**\n+     * Creates an enum constant.\n+     *\n+     * @param type the {@linkplain Enum enum type}\n+     * @param name the {@linkplain Enum#name() name} of the enum\n+     *\/\n+    public EnumData(JavaType type, String name) {\n+        this.type = type;\n+        this.name = name;\n+    }\n+\n+    \/**\n+     * Gets the {@linkplain Enum enum type}.\n+     *\/\n+    public JavaType getEnumType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * Gets the {@linkplain Enum#name() name} of the enum.\n+     *\/\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof EnumData) {\n+            EnumData that = (EnumData) obj;\n+            return this.type.equals(that.type) && this.name.equals(that.name);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return this.type.hashCode() ^ this.name.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/EnumData.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.meta;\n+\n+\/**\n+ * Represents an error constant within {@link AnnotationData}.\n+ *\n+ * Similar to {@code sun.reflect.annotation.ExceptionProxy}.\n+ *\/\n+public final class ErrorData {\n+    private final String description;\n+\n+    \/**\n+     * Creates an error constant.\n+     *\n+     * @param description description of the error\n+     *\/\n+    public ErrorData(String description) {\n+        this.description = description;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return description;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj instanceof ErrorData) {\n+            ErrorData that = (ErrorData) obj;\n+            return this.description.equals(that.description);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return description.hashCode();\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ErrorData.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-public interface ResolvedJavaField extends JavaField, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaField extends JavaField, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaMethod extends JavaMethod, InvokeTarget, ModifiersProvider, AnnotatedElement, Annotated {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement {\n+public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement, Annotated {\n@@ -140,2 +140,2 @@\n-     * Returns {@code null} since support for VM anonymous class was removed by JDK-8243287.\n-     * This method is preserved for JVMCI backwards compatibility.\n+     * Returns {@code null} since support for VM anonymous class was removed by JDK-8243287. This\n+     * method is preserved for JVMCI backwards compatibility.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1088,1 +1088,2 @@\n-                                  MTD_REQUIRES_ARRAY);\n+                                  MTD_REQUIRES_ARRAY)\n+                    .pop();\n@@ -1132,1 +1133,2 @@\n-                                  MTD_EXPORTS_ARRAY);\n+                                  MTD_EXPORTS_ARRAY)\n+                    .pop();\n@@ -1188,1 +1190,2 @@\n-                                  MTD_OPENS_ARRAY);\n+                                  MTD_OPENS_ARRAY)\n+                    .pop();\n@@ -1257,1 +1260,2 @@\n-                                  MTD_PROVIDES_ARRAY);\n+                                  MTD_PROVIDES_ARRAY)\n+                    .pop();\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -9,2 +9,2 @@\n-See Terms of Use for definitions of Unicode Inc.'s\n-Data Files and Software.\n+See Terms of Use <https:\/\/www.unicode.org\/copyright.html>\n+for definitions of Unicode Inc.s Data Files and Software.\n@@ -55,1 +55,0 @@\n------------------------------------------------------------- Terms of Use ---------------------------------------------------------------\n@@ -57,2 +56,1 @@\n-Unicode Copyright and Terms of Use\n-For the general privacy policy governing access to this site, see the  Unicode Privacy Policy.\n+------------------------------------------------------------ Terms of Use ---------------------------------------------------------------\n@@ -60,43 +58,0 @@\n-Unicode Copyright\n-Copyright  1991-2022 Unicode, Inc. All rights reserved.\n-Definitions\n-Unicode Data Files (\"DATA FILES\") include all data files under the directories:\n-https:\/\/www.unicode.org\/Public\/\n-https:\/\/www.unicode.org\/reports\/\n-https:\/\/www.unicode.org\/ivd\/data\/\n-\n-Unicode Data Files do not include PDF online code charts under the directory:\n-https:\/\/www.unicode.org\/Public\/\n-\n-Unicode Software (\"SOFTWARE\") includes any source code published in the Unicode Standard\n-or any source code or compiled code under the directories:\n-https:\/\/www.unicode.org\/Public\/PROGRAMS\/\n-https:\/\/www.unicode.org\/Public\/cldr\/\n-http:\/\/site.icu-project.org\/download\/\n-Terms of Use\n-Certain documents and files on this website contain a legend indicating that \"Modification is permitted.\" Any person is hereby authorized, without fee, to modify such documents and files to create derivative works conforming to the Unicode Standard, subject to Terms and Conditions herein.\n-Any person is hereby authorized, without fee, to view, use, reproduce, and distribute all documents and files, subject to the Terms and Conditions herein.\n-Further specifications of rights and restrictions pertaining to the use of the Unicode DATA FILES and SOFTWARE can be found in the Unicode Data Files and Software License.\n-Each version of the Unicode Standard has further specifications of rights and restrictions of use. For the book editions (Unicode 5.0 and earlier), these are found on the back of the title page.\n-The Unicode PDF online code charts carry specific restrictions. Those restrictions are incorporated as the first page of each PDF code chart.\n-All other files, including online documentation of the core specification for Unicode 6.0 and later, are covered under these general Terms of Use.\n-No license is granted to \"mirror\" the Unicode website where a fee is charged for access to the \"mirror\" site.\n-Modification is not permitted with respect to this document. All copies of this document must be verbatim.\n-Restricted Rights Legend\n-Any technical data or software which is licensed to the United States of America, its agencies and\/or instrumentalities under this Agreement is commercial technical data or commercial computer software developed exclusively at private expense as defined in FAR 2.101, or DFARS 252.227-7014 (June 1995), as applicable. For technical data, use, duplication, or disclosure by the Government is subject to restrictions as set forth in DFARS 202.227-7015 Technical Data, Commercial and Items (Nov 1995) and this Agreement. For Software, in accordance with FAR 12-212 or DFARS 227-7202, as applicable, use, duplication or disclosure by the Government is subject to the restrictions set forth in this Agreement.\n-Warranties and Disclaimers\n-This publication and\/or website may include technical or typographical errors or other inaccuracies. Changes are periodically added to the information herein; these changes will be incorporated in new editions of the publication and\/or website. Unicode, Inc. may make improvements and\/or changes in the product(s) and\/or program(s) described in this publication and\/or website at any time.\n-If this file has been purchased on magnetic or optical media from Unicode, Inc. the sole and exclusive remedy for any claim will be exchange of the defective media within ninety (90) days of original purchase.\n-EXCEPT AS PROVIDED IN SECTION E.2, THIS PUBLICATION AND\/OR SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND EITHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. UNICODE, INC. AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR ERRORS OR OMISSIONS IN THIS PUBLICATION AND\/OR SOFTWARE OR OTHER DOCUMENTS WHICH ARE REFERENCED BY OR LINKED TO THIS PUBLICATION OR THE UNICODE WEBSITE.\n-Waiver of Damages\n-In no event shall Unicode, Inc. or its licensors be liable for any special, incidental, indirect or consequential damages of any kind, or any damages whatsoever, whether or not Unicode, Inc. was advised of the possibility of the damage, including, without limitation, those resulting from the following: loss of use, data or profits, in connection with the use, modification or distribution of this information or its derivatives.\n-Trademarks & Logos\n-The Unicode Word Mark and the Unicode Logo are trademarks of Unicode, Inc. The Unicode Consortium and Unicode, Inc. are trade names of Unicode, Inc. Use of the information and materials found on this website indicates your acknowledgement of Unicode, Inc.s exclusive worldwide rights in the Unicode Word Mark, the Unicode Logo, and the Unicode trade names.\n-The Unicode Consortium Name and Trademark Usage Policy (Trademark Policy) are incorporated herein by reference and you agree to abide by the provisions of the Trademark Policy, which may be changed from time to time in the sole discretion of Unicode, Inc.\n-All third party trademarks referenced herein are the property of their respective owners.\n-Miscellaneous\n-Jurisdiction and Venue. This website is operated from a location in the State of California, United States of America. Unicode, Inc. makes no representation that the materials are appropriate for use in other locations. If you access this website from other locations, you are responsible for compliance with local laws. This Agreement, all use of this website and any claims and damages resulting from use of this website are governed solely by the laws of the State of California without regard to any principles which would apply the laws of a different jurisdiction. The user agrees that any disputes regarding this website shall be resolved solely in the courts located in Santa Clara County, California. The user agrees said courts have personal jurisdiction and agree to waive any right to transfer the dispute to any other forum.\n-Modification by Unicode, Inc. Unicode, Inc. shall have the right to modify this Agreement at any time by posting it to this website. The user may not assign any part of this Agreement without Unicode, Inc.s prior written consent.\n-Taxes. The user agrees to pay any taxes arising from access to this website or use of the information herein, except for those based on Unicodes net income.\n-Severability.  If any provision of this Agreement is declared invalid or unenforceable, the remaining provisions of this Agreement shall remain in effect.\n-Entire Agreement. This Agreement constitutes the entire agreement between the parties.\n@@ -104,0 +59,49 @@\n+    Unicode Copyright and Terms of Use\n+\n+    For the general privacy policy governing access to this site, see the  Unicode Privacy Policy.\n+\n+        Unicode Copyright\n+            Copyright  1991-2023 Unicode, Inc. All rights reserved.\n+        Definitions\n+\n+        Unicode Data Files (\"DATA FILES\") include all data files under the directories:\n+        https:\/\/www.unicode.org\/Public\/\n+        https:\/\/www.unicode.org\/reports\/\n+        https:\/\/www.unicode.org\/ivd\/data\/\n+\n+        Unicode Data Files do not include PDF online code charts under the directory:\n+        https:\/\/www.unicode.org\/Public\/\n+\n+        Unicode Software (\"SOFTWARE\") includes any source code published in the Unicode Standard\n+        or any source code or compiled code under the directories:\n+        https:\/\/www.unicode.org\/Public\/PROGRAMS\/\n+        https:\/\/www.unicode.org\/Public\/cldr\/\n+        http:\/\/site.icu-project.org\/download\/\n+\n+        Terms of Use\n+            Certain documents and files on this website contain a legend indicating that \"Modification is permitted.\" Any person is hereby authorized, without fee, to modify such documents and files to create derivative works conforming to the Unicode Standard, subject to Terms and Conditions herein.\n+            Any person is hereby authorized, without fee, to view, use, reproduce, and distribute all documents and files, subject to the Terms and Conditions herein.\n+            Further specifications of rights and restrictions pertaining to the use of the Unicode DATA FILES and SOFTWARE can be found in the Unicode Data Files and Software License.\n+            Each version of the Unicode Standard has further specifications of rights and restrictions of use. For the book editions (Unicode 5.0 and earlier), these are found on the back of the title page.\n+            The Unicode PDF online code charts carry specific restrictions. Those restrictions are incorporated as the first page of each PDF code chart.\n+            All other files, including online documentation of the core specification for Unicode 6.0 and later, are covered under these general Terms of Use.\n+            No license is granted to \"mirror\" the Unicode website where a fee is charged for access to the \"mirror\" site.\n+            Modification is not permitted with respect to this document. All copies of this document must be verbatim.\n+        Restricted Rights Legend\n+            Any technical data or software which is licensed to the United States of America, its agencies and\/or instrumentalities under this Agreement is commercial technical data or commercial computer software developed exclusively at private expense as defined in FAR 2.101, or DFARS 252.227-7014 (June 1995), as applicable. For technical data, use, duplication, or disclosure by the Government is subject to restrictions as set forth in DFARS 202.227-7015 Technical Data, Commercial and Items (Nov 1995) and this Agreement. For Software, in accordance with FAR 12-212 or DFARS 227-7202, as applicable, use, duplication or disclosure by the Government is subject to the restrictions set forth in this Agreement.\n+        Warranties and Disclaimers\n+            This publication and\/or website may include technical or typographical errors or other inaccuracies. Changes are periodically added to the information herein; these changes will be incorporated in new editions of the publication and\/or website. Unicode, Inc. may make improvements and\/or changes in the product(s) and\/or program(s) described in this publication and\/or website at any time.\n+            If this file has been purchased on magnetic or optical media from Unicode, Inc. the sole and exclusive remedy for any claim will be exchange of the defective media within ninety (90) days of original purchase.\n+            EXCEPT AS PROVIDED IN SECTION E.2, THIS PUBLICATION AND\/OR SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND EITHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. UNICODE, INC. AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR ERRORS OR OMISSIONS IN THIS PUBLICATION AND\/OR SOFTWARE OR OTHER DOCUMENTS WHICH ARE REFERENCED BY OR LINKED TO THIS PUBLICATION OR THE UNICODE WEBSITE.\n+        Waiver of Damages\n+            In no event shall Unicode, Inc. or its licensors be liable for any special, incidental, indirect or consequential damages of any kind, or any damages whatsoever, whether or not Unicode, Inc. was advised of the possibility of the damage, including, without limitation, those resulting from the following: loss of use, data or profits, in connection with the use, modification or distribution of this information or its derivatives.\n+        Trademarks & Logos\n+            The Unicode Word Mark and the Unicode Logo are trademarks of Unicode, Inc. The Unicode Consortium and Unicode, Inc. are trade names of Unicode, Inc. Use of the information and materials found on this website indicates your acknowledgement of Unicode, Inc.s exclusive worldwide rights in the Unicode Word Mark, the Unicode Logo, and the Unicode trade names.\n+            The Unicode Consortium Name and Trademark Usage Policy (Trademark Policy) are incorporated herein by reference and you agree to abide by the provisions of the Trademark Policy, which may be changed from time to time in the sole discretion of Unicode, Inc.\n+            All third party trademarks referenced herein are the property of their respective owners.\n+        Miscellaneous\n+            Jurisdiction and Venue. This website is operated from a location in the State of California, United States of America. Unicode, Inc. makes no representation that the materials are appropriate for use in other locations. If you access this website from other locations, you are responsible for compliance with local laws. This Agreement, all use of this website and any claims and damages resulting from use of this website are governed solely by the laws of the State of California without regard to any principles which would apply the laws of a different jurisdiction. The user agrees that any disputes regarding this website shall be resolved solely in the courts located in Santa Clara County, California. The user agrees said courts have personal jurisdiction and agree to waive any right to transfer the dispute to any other forum.\n+            Modification by Unicode, Inc. Unicode, Inc. shall have the right to modify this Agreement at any time by posting it to this website. The user may not assign any part of this Agreement without Unicode, Inc.s prior written consent.\n+            Taxes. The user agrees to pay any taxes arising from access to this website or use of the information herein, except for those based on Unicodes net income.\n+            Severability.  If any provision of this Agreement is declared invalid or unenforceable, the remaining provisions of this Agreement shall remain in effect.\n+            Entire Agreement. This Agreement constitutes the entire agreement between the parties.\n","filename":"src\/jdk.localedata\/share\/legal\/cldr.md","additions":52,"deletions":48,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -863,1 +863,1 @@\n-                throw new FileSystemException(getString(path), \"is a directory\", null);\n+                throw new FileSystemException(getString(path), null, \"is a directory\");\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,4 +96,2 @@\n-\n-      if (written == sz * sizeof(char)) {\n-        return fclose(f) == 0;\n-      }\n+      \/\/ at least see \"header\"\n+      return fclose(f) == 0 && sz == written && sz >= 6;\n@@ -260,0 +258,1 @@\n+  fprintf(stdout, \"header\");\n@@ -266,1 +265,1 @@\n-  EXPECT_TRUE(write_to_file(testing::internal::GetCapturedStdout()));\n+  fflush(nullptr);\n@@ -268,3 +267,5 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+  if (write_to_file(testing::internal::GetCapturedStdout())) {\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"header\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n@@ -272,2 +273,3 @@\n-  if (AsyncLogWriter::instance() != nullptr) {\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+    if (AsyncLogWriter::instance() != nullptr) {\n+      EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+    }\n@@ -279,0 +281,1 @@\n+  fprintf(stderr, \"header\");\n@@ -285,1 +288,1 @@\n-  EXPECT_TRUE(write_to_file(testing::internal::GetCapturedStderr()));\n+  fflush(nullptr);\n@@ -287,3 +290,5 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+  if (write_to_file(testing::internal::GetCapturedStderr())) {\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"header\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n@@ -291,2 +296,3 @@\n-  if (AsyncLogWriter::instance() != nullptr) {\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+    if (AsyncLogWriter::instance() != nullptr) {\n+      EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+    }\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ *          TestResolvedJavaType.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -31,0 +38,1 @@\n+ *          java.base\/jdk.internal.reflect\n@@ -32,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +70,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -184,0 +195,8 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredField(\"annotatedField\"));\n+        for (Field f : fields.keySet()) {\n+            TestResolvedJavaType.getAnnotationDataTest(f);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaField.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ *          TestResolvedJavaType.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -30,0 +37,2 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.common\n+ *          java.base\/jdk.internal.reflect\n@@ -31,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -64,0 +75,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -69,0 +81,4 @@\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation1;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation2;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.Annotation3;\n+import jdk.vm.ci.runtime.test.TestResolvedJavaMethod.AnnotationDataTest.NumbersDE;\n@@ -477,0 +493,77 @@\n+    \/**\n+     * Encapsulates input for {@link TestResolvedJavaMethod#getAnnotationDataTest}.\n+     *\/\n+    static class AnnotationDataTest {\n+\n+        public enum NumbersEN {\n+            One,\n+            Two;\n+        }\n+\n+        public enum NumbersDE {\n+            Eins,\n+            Zwei;\n+        }\n+\n+        public enum NumbersUA {\n+            Odyn,\n+            Dva;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation1 {\n+            NumbersEN value() default NumbersEN.One;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation2 {\n+            NumbersDE value() default NumbersDE.Eins;\n+        }\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        public @interface Annotation3 {\n+            NumbersUA value() default NumbersUA.Odyn;\n+        }\n+\n+        @Annotation1\n+        @Annotation2\n+        @Annotation3(NumbersUA.Dva)\n+        static void methodWithThreeAnnotations() {\n+\n+        }\n+    }\n+\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"annotatedMethod\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingAnnotation\"));\n+        try {\n+            TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"));\n+            throw new AssertionError(\"expected \" + NoClassDefFoundError.class.getName());\n+        } catch (NoClassDefFoundError e) {\n+            Assert.assertEquals(\"jdk\/internal\/vm\/test\/AnnotationTestInput$Missing\", e.getMessage());\n+        }\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"missingMember\"));\n+        TestResolvedJavaType.getAnnotationDataTest(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"));\n+\n+        for (Method m : methods.keySet()) {\n+            TestResolvedJavaType.getAnnotationDataTest(m);\n+        }\n+\n+        ResolvedJavaMethod m = metaAccess.lookupJavaMethod(AnnotationDataTest.class.getDeclaredMethod(\"methodWithThreeAnnotations\"));\n+        ResolvedJavaType a1 = metaAccess.lookupJavaType(Annotation1.class);\n+        ResolvedJavaType a2 = metaAccess.lookupJavaType(Annotation2.class);\n+        ResolvedJavaType a3 = metaAccess.lookupJavaType(Annotation3.class);\n+        ResolvedJavaType a4 = metaAccess.lookupJavaType(AnnotationDataTest.class);\n+        ResolvedJavaType numbersDEType = metaAccess.lookupJavaType(NumbersDE.class);\n+\n+        \/\/ Ensure NumbersDE is not initialized before Annotation2 is requested\n+        Assert.assertFalse(numbersDEType.isInitialized());\n+        Assert.assertEquals(2, m.getAnnotationData(a1, a3).size());\n+\n+        \/\/ Ensure NumbersDE is initialized after Annotation2 is requested\n+        Assert.assertNotNull(m.getAnnotationData(a2));\n+        Assert.assertTrue(numbersDEType.isInitialized());\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java\n+ *          ..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/..\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java\n@@ -34,0 +40,2 @@\n+ *          java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n@@ -60,0 +68,2 @@\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n@@ -66,0 +76,1 @@\n+import java.util.function.BiConsumer;\n@@ -69,0 +80,1 @@\n+import java.util.List;\n@@ -71,0 +83,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -75,1 +89,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -77,0 +90,1 @@\n+import jdk.internal.vm.test.AnnotationTestInput;\n@@ -78,0 +92,3 @@\n+import jdk.vm.ci.meta.Annotated;\n+import jdk.vm.ci.meta.AnnotationData;\n+import jdk.vm.ci.meta.EnumData;\n@@ -81,0 +98,2 @@\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.MetaUtil;\n@@ -84,0 +103,2 @@\n+import jdk.vm.ci.meta.UnresolvedJavaType;\n+import sun.reflect.annotation.AnnotationSupport;\n@@ -180,1 +201,2 @@\n-        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from\n+        \/\/ internal name to java\n@@ -906,5 +928,5 @@\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n-            f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(AccessibleObject.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Constructor.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Field.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Method.class)) ||\n+                        f.getDeclaringClass().equals(metaAccess.lookupJavaType(Module.class))) {\n@@ -1134,0 +1156,34 @@\n+    @Test\n+    public void getAnnotationDataTest() throws Exception {\n+        getAnnotationDataTest(AnnotationTestInput.AnnotatedClass.class);\n+        getAnnotationDataTest(int.class);\n+        getAnnotationDataTest(void.class);\n+        for (Class<?> c : classes) {\n+            getAnnotationDataTest(c);\n+        }\n+\n+        \/\/ Primitive classes have no annotations but we cannot directly\n+        \/\/ test absence of annotations. Instead, just ensure empty answers\n+        \/\/ are returned when looking up an arbitrary annotation type.\n+        Class<?>[] prims = {void.class, byte.class, int.class, double.class, float.class, short.class, char.class, long.class};\n+        ResolvedJavaType overrideType = metaAccess.lookupJavaType(Override.class);\n+        for (Class<?> c : prims) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            AnnotationData ad = type.getAnnotationData(overrideType);\n+            Assert.assertNull(String.valueOf(ad), ad);\n+            List<AnnotationData> adArray = type.getAnnotationData(overrideType, overrideType);\n+            Assert.assertEquals(0, adArray.size());\n+        }\n+\n+        \/\/ Test that inherited annotations are handled properly.\n+        ResolvedJavaType namedType = metaAccess.lookupJavaType(AnnotationTestInput.Named.class);\n+        AnnotationData ad = metaAccess.lookupJavaType(AnnotationTestInput.OwnName.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"NonInheritedValue\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName1.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName2.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super2\", ad.get(\"value\", String.class));\n+        ad = metaAccess.lookupJavaType(AnnotationTestInput.InheritedName3.class).getAnnotationData(namedType);\n+        Assert.assertEquals(\"Super1\", ad.get(\"value\", String.class));\n+    }\n+\n@@ -1177,0 +1233,125 @@\n+\n+    \/**\n+     * Tests that {@link AnnotationData} obtained from a {@link Class}, {@link Method} or\n+     * {@link Field} matches {@link AnnotatedElement#getAnnotations()} for the corresponding JVMCI\n+     * object.\n+     *\n+     * @param annotated a {@link Class}, {@link Method} or {@link Field} object\n+     *\/\n+    public static void getAnnotationDataTest(AnnotatedElement annotated) throws Exception {\n+        testGetAnnotationData(annotated, List.of(annotated.getAnnotations()));\n+    }\n+\n+    private static void testGetAnnotationData(AnnotatedElement annotated, List<Annotation> annotations) throws AssertionError {\n+        for (Annotation a : annotations) {\n+            AnnotationData ad = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertAnnotationsEquals(a, ad);\n+\n+            \/\/ Check that encoding\/decoding produces a stable result\n+            AnnotationData ad2 = toAnnotated(annotated).getAnnotationData(metaAccess.lookupJavaType(a.annotationType()));\n+            assertEquals(ad, ad2);\n+        }\n+        if (annotations.size() < 2) {\n+            return;\n+        }\n+        ResolvedJavaType type1 = metaAccess.lookupJavaType(annotations.get(0).annotationType());\n+        ResolvedJavaType type2 = metaAccess.lookupJavaType(annotations.get(1).annotationType());\n+        for (int i = 2; i < annotations.size(); i++) {\n+\n+            ResolvedJavaType[] types = annotations.\/\/\n+                            subList(2, i + 1).\/\/\n+                            stream().map(a -> metaAccess.lookupJavaType(a.annotationType())).\/\/\n+                            toArray(ResolvedJavaType[]::new);\n+            List<AnnotationData> annotationData = toAnnotated(annotated).getAnnotationData(type1, type2, types);\n+            assertEquals(2 + types.length, annotationData.size());\n+\n+            for (int j = 0; j < annotationData.size(); j++) {\n+                Annotation a = annotations.get(j);\n+                AnnotationData ad = annotationData.get(j);\n+                assertAnnotationsEquals(a, ad);\n+            }\n+        }\n+    }\n+\n+    private static Annotated toAnnotated(AnnotatedElement element) {\n+        if (element instanceof Class<?> t) {\n+            return metaAccess.lookupJavaType(t);\n+        } else if (element instanceof Method m) {\n+            return metaAccess.lookupJavaMethod(m);\n+        } else {\n+            Field f = (Field) element;\n+            return metaAccess.lookupJavaField(f);\n+        }\n+    }\n+\n+    private static UnresolvedJavaType asType(Class<?> valueType) {\n+        return UnresolvedJavaType.create(MetaUtil.toInternalName(valueType.getName()));\n+    }\n+\n+    private static void assertAnnotationsEquals(Annotation a, AnnotationData ad) {\n+        Map<String, Object> values = AnnotationSupport.memberValues(a);\n+        for (Map.Entry<String, Object> e : values.entrySet()) {\n+            String name = e.getKey();\n+            Object aValue = e.getValue();\n+            Object adValue;\n+            try {\n+                adValue = ad.get(name, Object.class);\n+            } catch (IllegalArgumentException ex) {\n+                assertEquals(aValue.toString(), ex.getMessage());\n+                continue;\n+            }\n+            try {\n+                assertAnnotationElementsEqual(aValue, adValue);\n+            } catch (ClassCastException ex) {\n+                throw new AssertionError(a.getClass().getName() + \".\" + name + \" has wrong type: \" + adValue.getClass().getName(), ex);\n+            }\n+        }\n+    }\n+\n+    private static void assertAnnotationElementsEqual(Object aValue, Object adValue) {\n+        Class<?> valueType = aValue.getClass();\n+        if (valueType.isEnum()) {\n+            assertEnumObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Class) {\n+            assertClassObjectsEquals(aValue, adValue);\n+        } else if (aValue instanceof Annotation) {\n+            assertAnnotationObjectsEquals(aValue, adValue);\n+        } else if (valueType.isArray()) {\n+            List<?> adList = (List<?>) adValue;\n+            int length = Array.getLength(aValue);\n+            assertEquals(length, adList.size());\n+            for (int i = 0; i < length; i++) {\n+                assertAnnotationElementsEqual(Array.get(aValue, i), adList.get(i));\n+            }\n+        } else {\n+            assertEquals(aValue.getClass(), adValue.getClass());\n+            assertEquals(aValue, adValue);\n+        }\n+    }\n+\n+    private static void assertClassObjectsEquals(Object aValue, Object adValue) {\n+        String aName = ((Class<?>) aValue).getName();\n+        String adName = ((JavaType) adValue).toClassName();\n+        assertEquals(aName, adName);\n+    }\n+\n+    private static void assertEnumObjectsEquals(Object aValue, Object adValue) {\n+        EnumData adEnum = (EnumData) adValue;\n+        String adEnumName = adEnum.getName();\n+        String aEnumName = ((Enum<?>) aValue).name();\n+        assertEquals(adEnumName, aEnumName);\n+    }\n+\n+    private static void assertAnnotationObjectsEquals(Object aValue, Object adValue) {\n+        Annotation aAnnotation = (Annotation) aValue;\n+        AnnotationData adAnnotation = (AnnotationData) adValue;\n+        assertAnnotationsEquals(aAnnotation, adAnnotation);\n+    }\n+\n+    private static void assertArraysEqual(Object aValue, Object adValue, int length, BiConsumer<Object, Object> assertEqualty) {\n+        Object[] aArray = (Object[]) aValue;\n+        Object[] adArray = (Object[]) adValue;\n+        for (int i = 0; i < length; i++) {\n+            assertEqualty.accept(aArray[i], adArray[i]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":189,"deletions":8,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -25,8 +25,2 @@\n-import jdk.internal.misc.Unsafe;\n-import jdk.vm.ci.meta.ConstantReflectionProvider;\n-import jdk.vm.ci.meta.JavaConstant;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.ResolvedJavaField;\n-import jdk.vm.ci.meta.ResolvedJavaType;\n-import jdk.vm.ci.runtime.JVMCI;\n-import org.junit.Test;\n+import static java.lang.reflect.Modifier.isFinal;\n+import static java.lang.reflect.Modifier.isStatic;\n@@ -57,2 +51,9 @@\n-import static java.lang.reflect.Modifier.isFinal;\n-import static java.lang.reflect.Modifier.isStatic;\n+import org.junit.Test;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.meta.JavaConstant;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.runtime.JVMCI;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TypeUniverse.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,2 @@\n+                \"java.lang.Thread.beforeSleep\",\n+                \"java.lang.Thread.afterSleep\",\n@@ -148,0 +150,1 @@\n+                \"java.util.concurrent.TimeUnit.toNanos\",\n@@ -204,1 +207,6 @@\n-        int expectedLength = depth + 5;\n+        \/\/ The length of the trace must not be greater than\n+        \/\/ expectedLength.  Number of recursionJava() or\n+        \/\/ recursionNative() methods must not be greater than depth,\n+        \/\/ also one run() and one waitForSign(), plus whatever can be\n+        \/\/ reached from Thread.yield or Thread.sleep.\n+        int expectedLength = depth + 6;\n@@ -207,4 +215,1 @@\n-        \/\/ Check the length of the trace. It must not be greater than\n-        \/\/ expectedLength. Number of recursionJava() or recursionNative()\n-        \/\/ methods must not ne greater than depth, also one Object.wait() or\n-        \/\/ Thread.yield() method, one run( ) and one waitForSign().\n+        \/\/ Check the length of the trace\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace001.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace001\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace002\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace003\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace004\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace005\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace006\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace007\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace008\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,3 @@\n- *         2. The length of a trace must not be greater than (depth + 3). Number\n- *            of recursionJava() or recursionNative() methods must not be greater\n- *            than depth, also one Object.wait() or Thread.yield() method, one\n- *            run(), and one waitForSign().\n+ *         2. Number of recursionJava() or recursionNative() methods must not be\n+ *            greater than depth + X, where X is implementation dependent.\n+ *            See strace001.java for more info.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace009\/TestDescription.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4513402\n+  @summary AWTEventMulticaster.getListeners throws unexpected ArrayStoreException\n+*\/\n+\n+import java.awt.AWTEventMulticaster;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.FocusListener;\n+\n+public class ArrayStoreException {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ComponentListener mc =\n+            AWTEventMulticaster.add(\n+                new ComponentAdapter() {},\n+                new ComponentAdapter() {});\n+\n+        if (AWTEventMulticaster.getListeners(mc, FocusListener.class).length == 0) {\n+            System.out.println(\"OKAY\");\n+        } else {\n+            System.out.println(\"empty array expected\");\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/AWTEventMulticaster\/ArrayStoreException.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4370733\n+  @summary AWTKeyStroke's getAWTKeyStroke(String) and toString() method aren't symmetric\n+*\/\n+\n+import java.awt.AWTKeyStroke;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.KeyStroke;\n+\n+public class ToStringTest {\n+\n+    \/* Note this test is deliberately testing the deprecated constants\n+     * as well as their replacements.\n+     *\/\n+    @SuppressWarnings(\"deprecation\")\n+    public static final int[] modifiers = {\n+        0,\n+        InputEvent.SHIFT_MASK,\n+        InputEvent.CTRL_MASK,\n+        InputEvent.META_MASK,\n+        InputEvent.ALT_MASK,\n+        InputEvent.ALT_GRAPH_MASK,\n+        InputEvent.BUTTON1_MASK,\n+        InputEvent.BUTTON2_MASK,\n+        InputEvent.BUTTON3_MASK,\n+        InputEvent.SHIFT_DOWN_MASK,\n+        InputEvent.CTRL_DOWN_MASK,\n+        InputEvent.META_DOWN_MASK,\n+        InputEvent.ALT_DOWN_MASK,\n+        InputEvent.BUTTON1_DOWN_MASK,\n+        InputEvent.BUTTON2_DOWN_MASK,\n+        InputEvent.BUTTON3_DOWN_MASK,\n+        InputEvent.ALT_GRAPH_DOWN_MASK\n+    };\n+\n+    public static final int[] keys = {\n+        KeyEvent.VK_A,\n+        KeyEvent.VK_B,\n+        KeyEvent.VK_C,\n+        KeyEvent.VK_D,\n+        KeyEvent.VK_E,\n+        KeyEvent.VK_F,\n+        KeyEvent.VK_G,\n+        KeyEvent.VK_H,\n+        KeyEvent.VK_I,\n+        KeyEvent.VK_J,\n+        KeyEvent.VK_K,\n+        KeyEvent.VK_L,\n+        KeyEvent.VK_M,\n+        KeyEvent.VK_N,\n+        KeyEvent.VK_O,\n+        KeyEvent.VK_P,\n+        KeyEvent.VK_Q,\n+        KeyEvent.VK_R,\n+        KeyEvent.VK_S,\n+        KeyEvent.VK_T,\n+        KeyEvent.VK_U,\n+        KeyEvent.VK_V,\n+        KeyEvent.VK_W,\n+        KeyEvent.VK_X,\n+        KeyEvent.VK_Y,\n+        KeyEvent.VK_Z,\n+        KeyEvent.VK_0,\n+        KeyEvent.VK_1,\n+        KeyEvent.VK_2,\n+        KeyEvent.VK_3,\n+        KeyEvent.VK_4,\n+        KeyEvent.VK_5,\n+        KeyEvent.VK_6,\n+        KeyEvent.VK_7,\n+        KeyEvent.VK_8,\n+        KeyEvent.VK_9,\n+\n+        KeyEvent.VK_COMMA,\n+        KeyEvent.VK_PERIOD,\n+        KeyEvent.VK_SLASH,\n+        KeyEvent.VK_SEMICOLON,\n+        KeyEvent.VK_EQUALS,\n+        KeyEvent.VK_OPEN_BRACKET,\n+        KeyEvent.VK_BACK_SLASH,\n+        KeyEvent.VK_CLOSE_BRACKET,\n+\n+        KeyEvent.VK_ENTER,\n+        KeyEvent.VK_BACK_SPACE,\n+        KeyEvent.VK_TAB,\n+        KeyEvent.VK_CANCEL,\n+        KeyEvent.VK_CLEAR,\n+        KeyEvent.VK_SHIFT,\n+        KeyEvent.VK_CONTROL,\n+        KeyEvent.VK_ALT,\n+        KeyEvent.VK_PAUSE,\n+        KeyEvent.VK_CAPS_LOCK,\n+        KeyEvent.VK_ESCAPE,\n+        KeyEvent.VK_SPACE,\n+        KeyEvent.VK_PAGE_UP,\n+        KeyEvent.VK_PAGE_DOWN,\n+        KeyEvent.VK_END,\n+        KeyEvent.VK_HOME,\n+        KeyEvent.VK_LEFT,\n+        KeyEvent.VK_UP,\n+        KeyEvent.VK_RIGHT,\n+        KeyEvent.VK_DOWN,\n+        KeyEvent.VK_ADD,\n+        KeyEvent.VK_SEPARATOR,\n+        KeyEvent.VK_SUBTRACT,\n+        KeyEvent.VK_DECIMAL,\n+        KeyEvent.VK_DIVIDE,\n+        KeyEvent.VK_DELETE,\n+        KeyEvent.VK_NUM_LOCK,\n+        KeyEvent.VK_SCROLL_LOCK,\n+\n+        KeyEvent.VK_WINDOWS,\n+        KeyEvent.VK_CONTEXT_MENU,\n+\n+        KeyEvent.VK_F1,\n+        KeyEvent.VK_F2,\n+        KeyEvent.VK_F3,\n+        KeyEvent.VK_F4,\n+        KeyEvent.VK_F5,\n+        KeyEvent.VK_F6,\n+        KeyEvent.VK_F7,\n+        KeyEvent.VK_F8,\n+        KeyEvent.VK_F9,\n+        KeyEvent.VK_F10,\n+        KeyEvent.VK_F11,\n+        KeyEvent.VK_F12,\n+        KeyEvent.VK_F13,\n+        KeyEvent.VK_F14,\n+        KeyEvent.VK_F15,\n+        KeyEvent.VK_F16,\n+        KeyEvent.VK_F17,\n+        KeyEvent.VK_F18,\n+        KeyEvent.VK_F19,\n+        KeyEvent.VK_F20,\n+        KeyEvent.VK_F21,\n+        KeyEvent.VK_F22,\n+        KeyEvent.VK_F23,\n+        KeyEvent.VK_F24,\n+\n+        KeyEvent.VK_PRINTSCREEN,\n+        KeyEvent.VK_INSERT,\n+        KeyEvent.VK_HELP,\n+        KeyEvent.VK_META,\n+        KeyEvent.VK_BACK_QUOTE,\n+        KeyEvent.VK_QUOTE,\n+\n+        KeyEvent.VK_KP_UP,\n+        KeyEvent.VK_KP_DOWN,\n+        KeyEvent.VK_KP_LEFT,\n+        KeyEvent.VK_KP_RIGHT,\n+\n+        KeyEvent.VK_DEAD_GRAVE,\n+        KeyEvent.VK_DEAD_ACUTE,\n+        KeyEvent.VK_DEAD_CIRCUMFLEX,\n+        KeyEvent.VK_DEAD_TILDE,\n+        KeyEvent.VK_DEAD_MACRON,\n+        KeyEvent.VK_DEAD_BREVE,\n+        KeyEvent.VK_DEAD_ABOVEDOT,\n+        KeyEvent.VK_DEAD_DIAERESIS,\n+        KeyEvent.VK_DEAD_ABOVERING,\n+        KeyEvent.VK_DEAD_DOUBLEACUTE,\n+        KeyEvent.VK_DEAD_CARON,\n+        KeyEvent.VK_DEAD_CEDILLA,\n+        KeyEvent.VK_DEAD_OGONEK,\n+        KeyEvent.VK_DEAD_IOTA,\n+        KeyEvent.VK_DEAD_VOICED_SOUND,\n+        KeyEvent.VK_DEAD_SEMIVOICED_SOUND,\n+\n+        KeyEvent.VK_AMPERSAND,\n+        KeyEvent.VK_ASTERISK,\n+        KeyEvent.VK_QUOTEDBL,\n+        KeyEvent.VK_LESS,\n+        KeyEvent.VK_GREATER,\n+        KeyEvent.VK_BRACELEFT,\n+        KeyEvent.VK_BRACERIGHT,\n+        KeyEvent.VK_AT,\n+        KeyEvent.VK_COLON,\n+        KeyEvent.VK_CIRCUMFLEX,\n+        KeyEvent.VK_DOLLAR,\n+        KeyEvent.VK_EURO_SIGN,\n+        KeyEvent.VK_EXCLAMATION_MARK,\n+        KeyEvent.VK_INVERTED_EXCLAMATION_MARK,\n+        KeyEvent.VK_LEFT_PARENTHESIS,\n+        KeyEvent.VK_NUMBER_SIGN,\n+        KeyEvent.VK_MINUS,\n+        KeyEvent.VK_PLUS,\n+        KeyEvent.VK_RIGHT_PARENTHESIS,\n+        KeyEvent.VK_UNDERSCORE,\n+\n+        KeyEvent.VK_FINAL,\n+        KeyEvent.VK_CONVERT,\n+        KeyEvent.VK_NONCONVERT,\n+        KeyEvent.VK_ACCEPT,\n+        KeyEvent.VK_MODECHANGE,\n+        KeyEvent.VK_KANA,\n+        KeyEvent.VK_KANJI,\n+        KeyEvent.VK_ALPHANUMERIC,\n+        KeyEvent.VK_KATAKANA,\n+        KeyEvent.VK_HIRAGANA,\n+        KeyEvent.VK_FULL_WIDTH,\n+        KeyEvent.VK_HALF_WIDTH,\n+        KeyEvent.VK_ROMAN_CHARACTERS,\n+        KeyEvent.VK_ALL_CANDIDATES,\n+        KeyEvent.VK_PREVIOUS_CANDIDATE,\n+        KeyEvent.VK_CODE_INPUT,\n+        KeyEvent.VK_JAPANESE_KATAKANA,\n+        KeyEvent.VK_JAPANESE_HIRAGANA,\n+        KeyEvent.VK_JAPANESE_ROMAN,\n+        KeyEvent.VK_KANA_LOCK,\n+        KeyEvent.VK_INPUT_METHOD_ON_OFF,\n+\n+        KeyEvent.VK_AGAIN,\n+        KeyEvent.VK_UNDO,\n+        KeyEvent.VK_COPY,\n+        KeyEvent.VK_PASTE,\n+        KeyEvent.VK_CUT,\n+        KeyEvent.VK_FIND,\n+        KeyEvent.VK_PROPS,\n+        KeyEvent.VK_STOP,\n+\n+        KeyEvent.VK_COMPOSE,\n+        KeyEvent.VK_ALT_GRAPH,\n+        KeyEvent.VK_BEGIN,\n+\n+        KeyEvent.VK_NUMPAD0,\n+        KeyEvent.VK_NUMPAD1,\n+        KeyEvent.VK_NUMPAD2,\n+        KeyEvent.VK_NUMPAD3,\n+        KeyEvent.VK_NUMPAD4,\n+        KeyEvent.VK_NUMPAD5,\n+        KeyEvent.VK_NUMPAD6,\n+        KeyEvent.VK_NUMPAD7,\n+        KeyEvent.VK_NUMPAD8,\n+        KeyEvent.VK_NUMPAD9\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        System.err.println(\"**** Testing AWTKeyStrokes\");\n+        for (int n_key=0; n_key < keys.length; n_key++) {\n+            for (int n_mod=0; n_mod < modifiers.length; n_mod++) {\n+                checkStroke(AWTKeyStroke.getAWTKeyStroke(keys[n_key],\n+                                                         modifiers[n_mod],\n+                                                         true));\n+                checkStroke(AWTKeyStroke.getAWTKeyStroke(keys[n_key],\n+                                                         modifiers[n_mod],\n+                                                         false));\n+            }\n+        }\n+\n+        System.err.println(\"**** Testing Swing KeyStrokes\");\n+        for (int n_key=0; n_key < keys.length; n_key++) {\n+            for (int n_mod=0; n_mod < modifiers.length; n_mod++) {\n+                checkStroke(KeyStroke.getKeyStroke(keys[n_key],\n+                                                         modifiers[n_mod],\n+                                                         true));\n+                checkStroke(KeyStroke.getKeyStroke(keys[n_key],\n+                                                         modifiers[n_mod],\n+                                                         false));\n+            }\n+        }\n+\n+        Character a = Character.valueOf('a');\n+        System.err.println(\"**** Testing KEY_TYPED AWTKeyStrokes\");\n+        for (int n_mod = 0; n_mod < modifiers.length; n_mod++) {\n+            checkStroke(AWTKeyStroke.getAWTKeyStroke(a, modifiers[n_mod]));\n+        }\n+        System.err.println(\"**** Testing KEY_TYPED Swing KeyStrokes\");\n+        for (int n_mod = 0; n_mod < modifiers.length; n_mod++) {\n+            checkStroke(KeyStroke.getKeyStroke(a, modifiers[n_mod]));\n+        }\n+\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    public static void checkStroke(AWTKeyStroke original) {\n+        System.err.println(\"AWT Original >> \" + original);\n+        AWTKeyStroke copy = AWTKeyStroke.getAWTKeyStroke(original.toString());\n+        \/\/ System.err.println(\"AWT Copy >> \" + copy);\n+        if (!original.equals(copy)) {\n+            System.out.println(\"AWT bad copy for VK= 0x\" +\n+                           Integer.toString(original.getKeyCode(), 16));\n+            throw new RuntimeException(\"Test Failed: for \" + original);\n+        }\n+    }\n+\n+    public static void checkStroke(KeyStroke original) {\n+        System.err.println(\"Swing Original >> \" + original);\n+        KeyStroke copy = KeyStroke.getKeyStroke(original.toString());\n+        \/\/ System.err.println(\"Swing Copy >> \" + copy);\n+        if (!original.equals(copy)) {\n+            System.out.println(\"Swing bad copy for VK= 0x\" +\n+                           Integer.toString(original.getKeyCode(), 16));\n+            throw new RuntimeException(\"Test Failed: for \" + original);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/AWTKeyStroke\/ToStringTest.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6242148\n+  @summary API method java.awt.BorderLayout.getConstraints(null) should return null\n+*\/\n+\n+import java.awt.BorderLayout;\n+\n+public class NullConstraintsReturns {\n+\n+    public static void main(String[] args) {\n+        BorderLayout bl = new BorderLayout();\n+        Object constraints = bl.getConstraints(null);\n+        if (constraints != null) {\n+            throw new RuntimeException(\"Test failed. Constraints is not null: \" + constraints);\n+        }\n+        System.out.println(\"Test Passed.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/BorderLayout\/NullConstraintsReturns.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4245382\n+  @summary Tests that Button.setLabel(null) does not cause NPE in Java code or VM crash\n+  @key headful\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class ButtonNullLabelTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        EventQueue.invokeAndWait(() -> runTest());\n+    }\n+\n+   static void runTest() {\n+        \/\/ Native code test\n+        Frame frame = new Frame(\"Test null in native\");\n+        Button button = new Button();\n+        try {\n+            button.setLabel(null);\n+            System.out.println(\"Set to null - test native\");\n+            frame.add(button);\n+            frame.pack();\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+            System.out.println(\"Test null in native **successful**\");\n+        } catch (NullPointerException npe) {\n+            System.out.println(\"Test failed - test native\");\n+            throw new RuntimeException(\"Test failed - test native\");\n+        } finally {\n+            frame.dispose();\n+        }\n+\n+        \/\/ Peer code test\n+        frame = new Frame(\"Test null in peer before show\");\n+        button = new Button();\n+        try {\n+            System.out.println(\"Set to null - test native before show\");\n+            frame.add(button);\n+            frame.pack();\n+            button.setLabel(null);\n+            frame.setVisible(true);\n+            System.out.println(\"Set null in peer before show **successful**\");\n+        } catch (NullPointerException npe) {\n+            System.out.println(\"Test failed - test peer before show\");\n+            throw new RuntimeException(\"Test failed - test peer before show\");\n+        } finally {\n+            frame.dispose();\n+        }\n+\n+        \/\/ Peer code test\n+        frame = new Frame(\"Test null in peer after show\");\n+        button = new Button();\n+        try {\n+            System.out.println(\"Set to null - test peer after show\");\n+            frame.add(button);\n+            frame.pack();\n+            frame.setVisible(true);\n+            button.setLabel(null);\n+            System.out.println(\"Test null in peer after show **successful**\");\n+        } catch (NullPointerException npe) {\n+            System.out.println(\"Test failed - peer after show\");\n+            throw new RuntimeException(\"Test failed - peer after show\");\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Button\/ButtonNullLabelTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 5044469\n+  @summary REG: Disabled component gains focus and receives keyevents on win32\n+  @key headful\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.KeyEvent;\n+\n+public class DisabledButtonPress implements ActionListener, FocusListener {\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            DisabledButtonPress test = new DisabledButtonPress();\n+            EventQueue.invokeAndWait(() -> test.createUI());\n+            runTest();\n+        } finally {\n+            if (f != null) {\n+               f.dispose();\n+            }\n+        }\n+        if (!testPassed) {\n+            throw new RuntimeException(\"Test Failed.\");\n+        }\n+    }\n+\n+    final static Object FOCUS_LOCK = new Object();\n+    final static Object ACTION_LOCK = new Object();\n+    static volatile Frame f;\n+    static volatile Button b2;\n+    static volatile boolean testPassed = true;\n+\n+    public void createUI() {\n+        f = new Frame(\"DisabledButtonPress\");\n+        b2 = new Button(\"Click Me\");\n+        b2.addActionListener(this);\n+        b2.addFocusListener(this);\n+        f.add(b2);\n+        f.pack();\n+        f.setVisible(true);\n+    }\n+\n+    static void runTest() throws Exception {\n+\n+        Robot robot = new Robot();\n+        robot.delay(500);\n+        System.out.println(\"Requesting focus\");\n+        System.out.println(\" b2.requestFocusInWindow()=\"+  b2.requestFocusInWindow());\n+        b2.setEnabled(false);\n+        synchronized(FOCUS_LOCK) {\n+            FOCUS_LOCK.wait(3000);\n+        }\n+        if (!b2.isFocusOwner()) {\n+            throw new RuntimeException(\"Test failed. Button doesn't have a focus.\");\n+        }\n+        System.out.println(\"Button disabling\");\n+        robot.delay(1000);\n+        robot.keyPress(KeyEvent.VK_SPACE);\n+        robot.delay(10);\n+        robot.keyRelease(KeyEvent.VK_SPACE);\n+        synchronized(ACTION_LOCK) {\n+            ACTION_LOCK.wait(2000); \/\/give time to handle\n+                                    \/\/ ACTION_PERFORMED event from the Button if it was generated\n+        }\n+    }\n+\n+    public void focusGained(FocusEvent ae) {\n+        System.out.println(\"Button got focus\");\n+        synchronized(FOCUS_LOCK) {\n+            FOCUS_LOCK.notify();\n+        }\n+    }\n+\n+    public void focusLost(FocusEvent ae) {}\n+\n+    public void actionPerformed(ActionEvent evt) {\n+        System.out.println(\"Button: \" + evt.getActionCommand() + \" Clicked. Event is \" +evt);\n+        if (evt.getSource() == b2) {\n+            testPassed = false;\n+            synchronized(ACTION_LOCK) {\n+                ACTION_LOCK.notify();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Button\/DisabledButtonPress.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4531849\n+  @summary Test that double action event no longer sent\n+  @key headful\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowListener;\n+\n+public class DoubleActionEventTest implements ActionListener, WindowListener {\n+\n+    static class Lock {\n+        boolean go = false;\n+        public synchronized boolean getGo() {return go;}\n+        public synchronized void setGo(boolean newGo) {go = newGo;}\n+    }\n+\n+    static volatile Frame f;\n+    static volatile int numActionEvents = 0;\n+    static volatile Lock lock = new Lock();\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            DoubleActionEventTest test = new DoubleActionEventTest();\n+            EventQueue.invokeAndWait(() -> test.createUI());\n+            runTest();\n+        } finally {\n+            if (f != null) {\n+                f.dispose();\n+            }\n+        }\n+    }\n+\n+    public void createUI() {\n+        f = new Frame(\"DoubleActionEventTest\");\n+        f.setLayout (new BorderLayout());\n+        f.addWindowListener(this);\n+        Button b = new Button(\"Action Listening Button\");\n+        b.addActionListener(this);\n+        f.add(b);\n+        f.setBounds(100, 100, 200, 200);\n+        f.setVisible(true);\n+    }\n+\n+    static void runTest() throws Exception {\n+\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(250);\n+        robot.setAutoWaitForIdle(true);\n+        robot.mouseMove(200, 200);\n+\n+        while (!lock.getGo()) {}\n+\n+        robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);\n+\n+        if (numActionEvents != 1) {\n+            System.out.println(\"Wrong number of ActionEvents.  Test FAILS.\");\n+            throw new RuntimeException(\"TEST FAILS\");\n+        }\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        numActionEvents++;\n+        System.out.println(\"Number of ActionEvents: \" + numActionEvents);\n+    }\n+\n+    public void windowActivated(WindowEvent e) {\n+        lock.setGo(true);\n+    }\n+    public void windowClosed(WindowEvent e) {}\n+    public void windowClosing(WindowEvent e) {}\n+    public void windowDeactivated(WindowEvent e) {}\n+    public void windowDeiconified(WindowEvent e) {}\n+    public void windowIconified(WindowEvent e) {}\n+    public void windowOpened(WindowEvent e) {}\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Button\/DoubleActionEventTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4689398\n+  @summary Inserting items in a Container with CardLayout does not work since Merlin\n+*\/\n+\n+import java.awt.CardLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+\n+public class CardsOrderTest {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        CardLayout layout = new CardLayout();\n+        Container cont = new Container();\n+        Component comp1 = new Component() {};\n+        Component comp2 = new Component() {};\n+        Component comp3 = new Component() {};\n+        cont.setLayout(layout);\n+        cont.add(comp1, \"1\", 0);\n+        cont.add(comp2, \"2\", 0);\n+        cont.add(comp3, \"3\", 0);\n+\n+        \/\/ Testing visibility \"state\" - not actually if its visible on screen\n+        \/\/ since this test does not require a UI.\n+        System.out.println(\"comp1.isVisible() = \" + comp1.isVisible());\n+        System.out.println(\"comp2.isVisible() = \" + comp2.isVisible());\n+        System.out.println(\"comp3.isVisible() = \" + comp3.isVisible());\n+\n+        if (!comp1.isVisible() || comp2.isVisible() || comp3.isVisible()) {\n+            throw new RuntimeException(\"first added component must be visible\");\n+        }\n+\n+        System.out.println(\"CardLayout.next()\");\n+        layout.next(cont);\n+\n+        System.out.println(\"comp1.isVisible() = \" + comp1.isVisible());\n+        System.out.println(\"comp2.isVisible() = \" + comp2.isVisible());\n+        System.out.println(\"comp3.isVisible() = \" + comp3.isVisible());\n+\n+        if (!comp3.isVisible() ||comp1.isVisible() || comp2.isVisible()) {\n+            throw new RuntimeException(\"the wrong component is visible after CardLayout.next() (must be comp3)\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/CardLayout\/CardsOrderTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4690266\n+  @summary REGRESSION: Wizard Page does not move to the next page\n+*\/\n+\n+import java.awt.CardLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+\n+public class ObedienceTest {\n+\n+    public static void main(String[] args) {\n+        Container cont = new Container();\n+        Component comp1 = new Component() {};\n+        Component comp2 = new Component() {};\n+        CardLayout layout = new CardLayout();\n+        cont.setLayout(layout);\n+        cont.add(comp1, \"first\");\n+        cont.add(comp2, \"second\");\n+\n+        if (!comp1.isVisible()) {\n+            throw new RuntimeException(\"first component must be visible\");\n+        }\n+\n+        comp1.setVisible(false);\n+        comp2.setVisible(true);\n+        layout.layoutContainer(cont);\n+\n+        if (!comp2.isVisible() || comp1.isVisible()) {\n+            System.out.println(\"comp1.isVisible() = \" + comp1.isVisible());\n+            System.out.println(\"comp2.isVisible() = \" + comp2.isVisible());\n+            throw new RuntimeException(\"manually shown component must be visible after layoutContainer()\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/CardLayout\/ObedienceTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4378378\n+  @summary Tests that checkbox.setLabel(null) doesn't crash the VM.\n+  @key headful\n+*\/\n+\n+import java.awt.Checkbox;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class CheckboxCrashTest  {\n+\n+    static Frame f;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> runTest());\n+            Thread.sleep(1000);\n+        } finally {\n+           f.dispose();\n+        }\n+    }\n+\n+    static void runTest() {\n+        f = new Frame(\"CheckboxCrashTest\");\n+        Checkbox cb = new Checkbox();\n+        f.add(cb);\n+        f.pack();\n+        cb.setLabel(null);\n+        f.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Checkbox\/CheckboxCrashTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4136496\n+  @key headful\n+  @summary Checkbox.setCheckboxGroup(CheckboxGroup) works wrong on some Checkbox states\n+*\/\n+\n+import java.awt.Checkbox;\n+import java.awt.CheckboxGroup;\n+\n+public class MultiCheckedCheckboxGroupTest {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        CheckboxGroup gr = new CheckboxGroup();\n+        Checkbox chb1 = new Checkbox(\"Box 1\", true, gr);\n+        Checkbox chb2 = new Checkbox(\"Box 2\", true, null);\n+\n+        chb2.setCheckboxGroup(gr);\n+\n+        System.out.println(\"chb1=\"+chb1);\n+        System.out.println(\"chb2=\"+chb2);\n+        System.out.println(\"gr.getSelectedCheckbox=\"+gr.getSelectedCheckbox());\n+\n+        if(chb1.getState()\n+          && !chb2.getState()\n+          && chb1.getCheckboxGroup() == gr\n+          && chb2.getCheckboxGroup() == gr\n+          && gr.getSelectedCheckbox() == chb1) {\n+            System.out.println(\"PASSED\");\n+        } else {\n+            System.out.println(\"FAILED\");\n+            throw new RuntimeException(\"Test FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Checkbox\/MultiCheckedCheckboxGroupTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4114268\n+  @key headful\n+  @summary Checkbox.setCheckboxGroup(null) alters selection for CB's previous CBGroup\n+*\/\n+\n+import java.awt.Checkbox;\n+import java.awt.CheckboxGroup;\n+\n+public class NullCheckboxGroupTest {\n+\n+\n+    public static void main(String[] args) {\n+        CheckboxGroup cbg = new CheckboxGroup();\n+        Checkbox chbox1 = new Checkbox(\"First\", cbg, true);\n+        Checkbox chbox2 = new Checkbox(\"Second\", cbg, false);\n+\n+        chbox2.setCheckboxGroup(null);\n+\n+        System.out.println(\"chbox1=\"+chbox1);\n+        System.out.println(\"chbox2=\"+chbox2);\n+        System.out.println(\"cbg=\"+cbg);\n+\n+        if (cbg.getSelectedCheckbox() != chbox1) {\n+            System.out.println(\"FAILED\");\n+            throw new RuntimeException(\"Test FAILED\");\n+        } else {\n+            System.out.println(\"PASSED\");\n+        }\n+    }\n+ }\n","filename":"test\/jdk\/java\/awt\/Checkbox\/NullCheckboxGroupTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4726853\n+  @key headful\n+  @summary Checkbox is changing it's state after removing from CheckboxGroup\n+*\/\n+\n+import java.awt.Checkbox;\n+import java.awt.CheckboxGroup;\n+\n+public class SetCheckboxGroupNull {\n+\n+    public static void main(String[] args) {\n+        boolean passed = true;\n+\n+        \/\/ 1 step\n+        {\n+            CheckboxGroup g = new CheckboxGroup();\n+            Checkbox cb1 = new Checkbox(\"Label\", true, g);\n+            System.out.println(\"1. (should be true) \"+cb1.getState());\n+            passed = passed && (cb1.getState() == true);\n+            cb1.setCheckboxGroup(null);\n+            System.out.println(\"2. (should be true) \"+cb1.getState());\n+            passed = passed && (cb1.getState() == true);\n+        }\n+\n+        \/\/ 2 step\n+        {\n+            CheckboxGroup g = new CheckboxGroup();\n+            Checkbox cb1 = new Checkbox(\"CB1\", true, g);\n+            System.out.println(\"3. (should be true) \" + cb1.getState());\n+            passed = passed && (cb1.getState() == true);\n+            g.setSelectedCheckbox(null);\n+            System.out.println(\"4. (should be false) \" + cb1.getState());\n+            passed = passed && (cb1.getState() == false);\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"SetCheckboxGroupNull FAILED\");\n+        }\n+        System.out.println(\"SetCheckboxGroupNull PASSED\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Checkbox\/SetCheckboxGroupNull.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ @test\n+ @bug 4908468\n+ @summary Linux Empty Choice throws NPE\n+ @key headful\n+ @run main EmptyChoiceTest\n+*\/\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class EmptyChoiceTest\n+{\n+    Frame frame;\n+    Choice choice = null;\n+\n+    public static void main(String[] args) throws\n+            InterruptedException,\n+            InvocationTargetException {\n+        EventQueue.invokeAndWait(() -> {\n+            EmptyChoiceTest emptyChoiceTest = new EmptyChoiceTest();\n+            emptyChoiceTest.init();\n+            emptyChoiceTest.test();\n+        });\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+        frame.setLayout(new BorderLayout());\n+        choice = new Choice();\n+        frame.add(choice, BorderLayout.NORTH);\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        frame.validate();\n+    }\n+\n+    public void test () {\n+        try {\n+            int iWidth = choice.getWidth();\n+            int iHeight = choice.getHeight();\n+            Image componentImage =\n+                choice.createImage(iWidth, iHeight);\n+            Graphics graphics =\n+                componentImage.getGraphics();\n+            graphics.setClip(0, 0, iWidth, iHeight);\n+            choice.printAll(graphics);\n+            System.out.println(\"PrintAll successful!\");\n+        } catch (NullPointerException exp) {\n+            throw new RuntimeException(\"Test failed. \" +\n+                    \"Empty Choice printAll throws NullPointerException\");\n+        } catch (Exception exc){\n+            throw new RuntimeException(\"Test failed.\", exc);\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/EmptyChoiceTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ @test\n+ @bug 4115130\n+ @summary Tests Inserting\/Removing items doesn't cause crash.\n+ @key headful\n+ @run main InsertRemoveTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class InsertRemoveTest {\n+    Choice choice1;\n+    Choice choice2;\n+    Choice choice3;\n+    Frame f;\n+    int itemCount = 0;\n+    int iterCount = 0;\n+\n+    public static void main(String[] args)\n+            throws InterruptedException, InvocationTargetException {\n+        EventQueue.invokeAndWait(() -> new InsertRemoveTest().start());\n+    }\n+\n+    public void start() {\n+        f = new Frame(\"Check Choice\");\n+        f.setLayout(new BorderLayout());\n+\n+        choice1 = new Choice();\n+        choice2 = new Choice();\n+        choice3 = new Choice();\n+\n+        f.add(choice1, BorderLayout.NORTH);\n+        f.add(choice3, BorderLayout.CENTER);\n+        f.add(choice2, BorderLayout.SOUTH);\n+\n+        f.pack();\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+\n+        try {\n+            for (int i = 0; i < 50; i++) {\n+                if (choice1 != null && itemCount < 40) {\n+                    choice1.insert(\"I am Choice, yes I am : \" + iterCount,\n+                            0);\n+                    choice2.add(\"I am the same, yes I am : \" + iterCount);\n+                    choice3.insert(\"I am the same, yes I am : \" + iterCount,\n+                            10);\n+                    itemCount++;\n+                    iterCount++;\n+                }\n+                if (itemCount >= 20 && choice1 != null\n+                        && choice1.getItemCount() > 0) {\n+                    choice1.remove(0);\n+                    choice2.remove(10);\n+                    choice3.remove(19);\n+                    itemCount--;\n+                }\n+                f.validate();\n+            }\n+        } finally {\n+            f.dispose();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/InsertRemoveTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6246503\n+  @summary Disabling a choice after selection locks keyboard, \\\n+           mouse and makes the system unusable\n+  @key headful\n+  @run main OpenedChoiceHangs\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class OpenedChoiceHangs implements ItemListener {\n+    static final Object FOCUS_LOCK = new Object();\n+\n+    Frame frame;\n+    Choice ch = new Choice();\n+    Button b = new Button(\"A button\");\n+    Robot robot;\n+\n+    public static void main(String[] args)\n+            throws InterruptedException, InvocationTargetException {\n+        OpenedChoiceHangs openedChoiceHangs = new OpenedChoiceHangs();\n+        EventQueue.invokeAndWait(openedChoiceHangs::init);\n+        openedChoiceHangs.test();\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+\n+        frame.setLayout(new FlowLayout());\n+        for (int i = 1; i < 10; i++) {\n+            ch.add(\"item \" + i);\n+        }\n+        frame.add(ch);\n+        frame.add(b);\n+        ch.setBackground(new Color(255, 0, 0));\n+        ch.setForeground(new Color(255, 0, 0));\n+        ch.addItemListener(this);\n+\n+        frame.setSize(200, 200);\n+        frame.setVisible(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.validate();\n+    }\n+\n+    public void test() {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+            robot.delay(1000);\n+            robot.mouseMove(ch.getLocationOnScreen().x + ch.getWidth() \/ 2,\n+                    ch.getLocationOnScreen().y + ch.getHeight() \/ 2);\n+\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(1000);\n+            if (!ch.isFocusOwner()) {\n+                synchronized (FOCUS_LOCK) {\n+                    FOCUS_LOCK.wait(3000);\n+                }\n+            }\n+            if (!ch.isFocusOwner()){\n+                throw new RuntimeException(\n+                        \"Test failed. Choice has no focus after mouse press.\");\n+            }\n+            robot.keyPress(KeyEvent.VK_DOWN);\n+            robot.keyRelease(KeyEvent.VK_DOWN);\n+            robot.delay(1000);\n+\n+            robot.keyPress(KeyEvent.VK_UP);\n+            robot.keyRelease(KeyEvent.VK_UP);\n+            robot.delay(1000);\n+\n+            Color color = robot.getPixelColor(\n+                    ch.getLocationOnScreen().x + ch.getWidth() \/ 2,\n+                    ch.getLocationOnScreen().y + ch.getHeight() * 4);\n+            System.out.println(\"Color is \" + color);\n+            if (color.equals(new Color(255, 0,0))){\n+                throw new RuntimeException(\n+                        \"Test failed. Choice is disabled and still opened. \");\n+            }\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\n+                    \"Test interrupted due to AWTException. Robot=\" + robot, e);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Test interrupted. Robot=\" + robot, e);\n+        } finally {\n+            EventQueue.invokeLater(frame::dispose);\n+        }\n+\n+        System.out.println(\"Test passed: Choice became closed after disabling.\");\n+    }\n+\n+    public void itemStateChanged (ItemEvent ie) {\n+        System.out.println(\"Choice Item has changed: \"+ie);\n+        ch.setEnabled(false);\n+    }\n+    public void focusGained(FocusEvent fEvent){\n+        System.out.println(\"focusGained\"+fEvent);\n+        synchronized(FOCUS_LOCK){\n+            FOCUS_LOCK.notify();\n+        }\n+    }\n+\n+    public void focusLost(FocusEvent fEvent){\n+        System.out.println(\"focusLost\"+fEvent);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/OpenedChoiceHangs.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 6259328\n+  @summary Choice scrolls when dragging the parent frame while drop-down \\\n+            is active\n+  @key headful\n+  @run main PressOutsideOpenedChoice\n+*\/\n+\n+\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class PressOutsideOpenedChoice extends Frame {\n+    Robot robot;\n+    Choice choice1 = new Choice();\n+    Point pt;\n+\n+    public static void main(String[] args)\n+            throws InterruptedException, InvocationTargetException {\n+        PressOutsideOpenedChoice pressOutsideOpenedChoice =\n+                new PressOutsideOpenedChoice();\n+        EventQueue.invokeAndWait(pressOutsideOpenedChoice::init);\n+        pressOutsideOpenedChoice.start();\n+    }\n+\n+    public void init() {\n+        for (int i = 1; i < 50; i++) {\n+            choice1.add(\"item-\" + i);\n+        }\n+        choice1.setForeground(Color.red);\n+        choice1.setBackground(Color.red);\n+        add(choice1);\n+        setLayout(new FlowLayout());\n+        setSize (200,200);\n+        setLocationRelativeTo(null);\n+        setVisible(true);\n+        validate();\n+    }\n+\n+    public void start() {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(50);\n+            robot.delay(1000);\n+            testPressOutsideOpenedChoice(InputEvent.BUTTON1_DOWN_MASK);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(\"Test failed. Exception thrown: \" + e);\n+        } finally {\n+            EventQueue.invokeLater(this::dispose);\n+        }\n+    }\n+\n+    public void testPressOutsideOpenedChoice(int button) {\n+        pt = choice1.getLocationOnScreen();\n+        robot.mouseMove(pt.x + choice1.getWidth() - choice1.getHeight() \/ 4,\n+                pt.y + choice1.getHeight() \/ 2);\n+        robot.delay(100);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        \/\/move mouse outside of the choice\n+        robot.mouseMove(pt.x - choice1.getWidth() \/ 2,\n+                pt.y + choice1.getHeight() \/ 2);\n+        robot.delay(400);\n+        robot.mousePress(button);\n+        robot.mouseRelease(button);\n+        robot.delay(200);\n+        Color color = robot.getPixelColor(pt.x + choice1.getWidth() \/ 2,\n+                pt.y + 3 * choice1.getHeight());\n+        System.out.println(\"color got \" +\n+                robot.getPixelColor(pt.x + choice1.getWidth() \/ 2,\n+                        pt.y + 3 * choice1.getHeight()));\n+        if (color.equals(Color.red)) {\n+            throw new RuntimeException(\"Test failed. Choice didn't close \" +\n+                    \"after mouse press outside of Choice \" + button);\n+        } else {\n+            System.out.println(\"Test passed. \" +\n+                    \"Choice closed with MousePress outside\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/PressOutsideOpenedChoice.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4653170\n+  @summary Make sure setCursor does not produce Arithmetic Exception.\n+  @key headful\n+  @run main SingleColorCursorTest\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Cursor;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class SingleColorCursorTest extends Panel {\n+    public void init() {\n+        setLayout (new BorderLayout());\n+        setSize (200,200);\n+        add(new Button(\"JButton\"));\n+    }\n+\n+    public void start () {\n+        Cursor singleColorCursor = Toolkit.getDefaultToolkit()\n+                .createCustomCursor(new BufferedImage(1, 1, BufferedImage.TYPE_BYTE_BINARY),\n+                                    new Point(0,0), \"Single Color Cursor\");\n+        try {\n+            setCursor(singleColorCursor);\n+        } catch (ArithmeticException ae) {\n+            throw new RuntimeException(\"Setting a 1x1 custom cursor causes arithmetic exception\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n+        EventQueue.invokeAndWait(() -> {\n+            Frame frame = new Frame(\"Test window\");\n+            try {\n+                SingleColorCursorTest test = new SingleColorCursorTest();\n+                test.init();\n+                frame.add(test);\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+                test.start();\n+                frame.setVisible(false);\n+            } finally {\n+                frame.dispose();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Cursor\/SingleColorCursorTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4274360\n+  @summary Ensures that Dialogs receive COMPONENT_SHOWN events\n+  @key headful\n+  @run main ComponentShownEvent\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ComponentShownEvent {\n+\n+    volatile boolean componentShown = false;\n+    Frame f;\n+    Dialog d;\n+\n+    public void start() throws InterruptedException,\n+                        InvocationTargetException, AWTException {\n+        Robot robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                f = new Frame();\n+                d = new Dialog(f);\n+\n+                d.addComponentListener(new ComponentAdapter() {\n+                    public void componentShown(ComponentEvent e) {\n+                        componentShown = true;\n+                    }\n+                });\n+\n+                f.setSize(100, 100);\n+                f.setLocationRelativeTo(null);\n+                f.setVisible(true);\n+                d.setVisible(true);\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            if (!componentShown) {\n+                throw new RuntimeException(\"test failed\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (d != null) {\n+                    d.setVisible(false);\n+                    d.dispose();\n+                }\n+                if (f != null) {\n+                    f.setVisible(false);\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+                               InvocationTargetException, AWTException {\n+        ComponentShownEvent test = new ComponentShownEvent();\n+        test.start();\n+        System.out.println(\"test passed\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ComponentShownEvent.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4221123\n+  @summary Why Dialog can't be an owner of FileDialog?\n+  @key headful\n+  @run main DialogAsParentOfFileDialog\n+*\/\n+\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class DialogAsParentOfFileDialog {\n+    FileDialog fdialog;\n+\n+    public void start () {\n+        StringBuilder errors = new StringBuilder();\n+        String nl = System.lineSeparator();\n+        Dialog dlg;\n+        String title;\n+        int mode;\n+        boolean passed;\n+\n+        System.out.println(\"DialogAsParentOfFileDialog\");\n+\n+        \/*\n+         * public FileDialog(Dialog parent),\n+         * checks owner and default settings.\n+         *\/\n+        System.out.print(\"\\ttest 01: \");\n+        dlg = new Dialog(new Frame());\n+        fdialog = new FileDialog(dlg);\n+        passed =\n+            fdialog.getOwner() == dlg\n+            && fdialog.isModal()\n+            && fdialog.getTitle().equals(\"\")\n+            && fdialog.getMode() == FileDialog.LOAD\n+            && fdialog.getFile() == null\n+            && fdialog.getDirectory() == null\n+            && fdialog.getFilenameFilter() == null;\n+        System.out.println(passed ? \"passed\" : \"FAILED\");\n+        if (!passed) {\n+            errors.append(nl);\n+            errors.append(\"DialogAsParentOfFileDialog FAILED\");\n+        }\n+\n+        \/*\n+         * public FileDialog(Dialog parent, String title),\n+         * checks owner, title and default settings.\n+         *\/\n+        System.out.print(\"\\ttest 02: \");\n+        dlg = new Dialog(new Frame());\n+        title = \"Title\";\n+        fdialog = new FileDialog(dlg, title);\n+        passed =\n+            fdialog.getOwner() == dlg\n+            && fdialog.isModal()\n+            && fdialog.getTitle().equals(title)\n+            && fdialog.getMode() == FileDialog.LOAD\n+            && fdialog.getFile() == null\n+            && fdialog.getDirectory() == null\n+            && fdialog.getFilenameFilter() == null;\n+        System.out.println(passed ? \"passed\" : \"FAILED\");\n+        if (!passed) {\n+            errors.append(nl);\n+            errors.append(\"DialogAsParentOfFileDialog FAILED\");\n+        }\n+\n+        \/*\n+         * public FileDialog(Dialog parent, String title),\n+         * title: null.\n+         * expected results: FileDialog object with a null title\n+         *\/\n+        System.out.print(\"\\ttest 03: \");\n+        dlg = new Dialog(new Frame());\n+        title = null;\n+        fdialog = new FileDialog(dlg, title);\n+        passed =\n+            fdialog.getOwner() == dlg\n+            && (fdialog.getTitle() == null\n+                || fdialog.getTitle().equals(\"\"));\n+        System.out.println(passed ? \"passed\" : \"FAILED\");\n+        if (!passed) {\n+            errors.append(nl);\n+            errors.append(\"DialogAsParentOfFileDialog FAILED\");\n+        }\n+\n+        \/*\n+         * public FileDialog(Dialog parent, String title, int mode),\n+         * checks owner, title and mode.\n+         *\/\n+        dlg = new Dialog(new Frame());\n+        title = \"Title\";\n+\n+        System.out.print(\"\\ttest 04: \");\n+        mode = FileDialog.SAVE;\n+        fdialog = new FileDialog(dlg, title, mode);\n+        passed =\n+            fdialog.getOwner() == dlg\n+            && fdialog.isModal()\n+            && fdialog.getTitle().equals(title)\n+            && fdialog.getMode() == mode\n+            && fdialog.getFile() == null\n+            && fdialog.getDirectory() == null\n+            && fdialog.getFilenameFilter() == null;\n+        System.out.println(passed ? \"passed\" : \"FAILED\");\n+        if (!passed) {\n+            errors.append(nl);\n+            errors.append(\"DialogAsParentOfFileDialog FAILED\");\n+        }\n+\n+        System.out.print(\"\\ttest 05: \");\n+        mode = FileDialog.LOAD;\n+        fdialog = new FileDialog(dlg, title, mode);\n+        passed =\n+            fdialog.getOwner() == dlg\n+            && fdialog.isModal()\n+            && fdialog.getTitle().equals(title)\n+            && fdialog.getMode() == mode\n+            && fdialog.getFile() == null\n+            && fdialog.getDirectory() == null\n+            && fdialog.getFilenameFilter() == null;\n+        System.out.println(passed ? \"passed\" : \"FAILED\");\n+        if (!passed) {\n+            errors.append(nl);\n+            errors.append(\"DialogAsParentOfFileDialog FAILED\");\n+        }\n+\n+        \/*\n+         * public FileDialog(Dialog parent, String title, int mode),\n+         * mode: Integer.MIN_VALUE, Integer.MIN_VALUE+1,\n+         *       Integer.MAX_VALUE-1, Integer.MAX_VALUE\n+         * expected results: IllegalArgumentException should be thrown\n+         *\/\n+        System.out.print(\"\\ttest 06: \");\n+        dlg = new Dialog(new Frame());\n+        title = \"Title\";\n+        int[] modes = {Integer.MIN_VALUE, Integer.MIN_VALUE+1,\n+                       Integer.MAX_VALUE-1, Integer.MAX_VALUE};\n+        passed = true;\n+        for (int i = 0; i < modes.length; i++) {\n+            try {\n+                fdialog = new FileDialog(dlg, title, modes[i]);\n+                passed = false;\n+            } catch (IllegalArgumentException e) {}\n+        }\n+        System.out.println(passed ? \"passed\" : \"FAILED\");\n+        if (!passed) {\n+            errors.append(nl);\n+            errors.append(\"DialogAsParentOfFileDialog FAILED\");\n+        }\n+\n+        if (!errors.isEmpty()) {\n+            throw new RuntimeException(\"Following tests failed:\" + errors);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+                                           InvocationTargetException {\n+        EventQueue.invokeAndWait(() -> {\n+            new DialogAsParentOfFileDialog().start();\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogAsParentOfFileDialog.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4390019\n+  @summary REGRESSION: Alt-F4 keybinding no longer shuts down java application on Windows\n+  @key headful\n+  @requires (os.family == \"windows\")\n+  @run main NoFocusOwnerAWTTest\n+*\/\n+import java.awt.Frame;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Label;\n+import java.awt.MenuBar;\n+import java.awt.Menu;\n+import java.awt.MenuItem;\n+import java.awt.MenuShortcut;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowAdapter;\n+\n+public class NoFocusOwnerAWTTest {\n+\n+    static boolean actionFired = false;\n+    static boolean closingWindowCalled = false;\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+                \/\/ this test is Win32 test only\n+                return;\n+            }\n+            EventQueue.invokeAndWait(() -> {\n+\n+                frame = new Frame(\"No Focus Owner AWT Test\");\n+                frame.addWindowListener(new WindowAdapter() {\n+                    public void windowClosing(WindowEvent e) {\n+                        System.out.println(\"windowClosing() is called.\");\n+                        closingWindowCalled = true;\n+                    }\n+                });\n+                frame.addFocusListener(new FocusListener() {\n+                    public void focusGained(FocusEvent fe) {\n+                        System.out.println(\"focus gained on frame\");\n+                    }\n+                    public void focusLost(FocusEvent fe) {\n+                        System.out.println(\"focus lost on frame\");\n+                    }\n+                });\n+                MenuBar mb = new MenuBar();\n+                Menu m = new Menu(\"This is Menu\");\n+                MenuItem mi = new MenuItem(\"Menu Item\");\n+                mi.setShortcut(new MenuShortcut(KeyEvent.VK_A));\n+                mi.addActionListener( new ActionListener() {\n+                    public void actionPerformed(ActionEvent ae) {\n+                        System.out.println(\"action\");\n+                        actionFired = true;\n+                    }\n+                });\n+                m.add(mi);\n+                mb.add(m);\n+                frame.setMenuBar(mb);\n+                Label lb;\n+                frame.add(lb = new Label(\"press\"));\n+                lb.addFocusListener(new FocusListener() {\n+                    public void focusGained(FocusEvent fe) {\n+                        System.out.println(\"focus gained on label\");\n+                    }\n+                    public void focusLost(FocusEvent fe) {\n+                        System.out.println(\"focus lost on label\");\n+                    }\n+                });\n+                frame.pack();\n+                frame.toFront();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.waitForIdle();\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_F4);\n+            robot.waitForIdle();\n+            robot.keyRelease(KeyEvent.VK_F4);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            if (!actionFired || !closingWindowCalled) {\n+                throw new RuntimeException(\"Test FAILED(actionFired=\"+actionFired+\n+                                       \";closingWindowCalled=\"+closingWindowCalled+\")\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+ }\/\/ class NoFocusOwnerAWTTest\n","filename":"test\/jdk\/java\/awt\/Focus\/NoFocusOwnerAWTTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4390019\n+  @summary REGRESSION: Alt-F4 keybinding no longer shuts down java application on Windows\n+  @key headful\n+  @requires (os.family == \"windows\")\n+  @run main NoFocusOwnerSwingTest\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.Label;\n+import java.awt.MenuBar;\n+import java.awt.Menu;\n+import java.awt.MenuItem;\n+import java.awt.MenuShortcut;\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowAdapter;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+public class NoFocusOwnerSwingTest {\n+    static boolean closingWindowCalled = false;\n+    static JFrame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+                \/\/ this test is Win32 test only\n+                return;\n+            }\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame(\"No Focus Owner Swing Test\");\n+                JButton btn;\n+                frame.getContentPane().add(btn = new JButton(\"press\"));\n+                frame.addWindowListener(new WindowAdapter() {\n+                    public void windowClosing(WindowEvent e) {\n+                        System.out.println(\"windowClosing is called\");\n+                        closingWindowCalled = true;\n+                    }\n+                });\n+                frame.pack();\n+                frame.toFront();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_F4);\n+            robot.waitForIdle();\n+            robot.keyRelease(KeyEvent.VK_F4);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            robot.waitForIdle();\n+\n+            if (!closingWindowCalled) {\n+                throw new RuntimeException(\"Test FAILED(closingWindowCalled=\" +\n+                                         closingWindowCalled + \")\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\/\/ class NoFocusOwnerSwingTest\n","filename":"test\/jdk\/java\/awt\/Focus\/NoFocusOwnerSwingTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4423838\n+  @summary KEY_TYPED and KEY_PRESSED generated by the same key are notified to\n+           different TextFields\n+  @key headful\n+  @run main QuickTypeTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.EventQueue;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+\n+import java.util.Properties;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTextField;\n+\n+public class QuickTypeTest {\n+    static final int TEST_TIMEOUT=10000;\n+    static JFrame frame1;\n+    static JFrame frame2;\n+    static JTextField tf1;\n+    static JTextField tf2;\n+    static SmartKeyAdapter ska;\n+    static Object keyMonitor;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame1 = new JFrame(\"First Frame\");\n+                frame2 = new JFrame(\"Second Frame\");\n+                tf1 = new JTextField(\"\", 10);\n+                tf2 = new JTextField(\"\", 10);\n+                frame1.getContentPane().add(tf1);\n+                frame2.getContentPane().add(tf2);\n+                frame1.setLocation(200,220);\n+                frame2.setLocation(220,300);\n+                frame1.pack();\n+                frame2.pack();\n+                keyMonitor = new Object();\n+                ska = new SmartKeyAdapter(frame2, keyMonitor);\n+                tf1.addKeyListener(ska);\n+                frame1.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            Object tf1Monitor = new Object();\n+            MonitoredFocusListener monitorer = new MonitoredFocusListener(tf1Monitor);\n+            tf1.addFocusListener(monitorer);\n+            Point origin = tf1.getLocationOnScreen();\n+            Dimension dim = tf1.getSize();\n+            robot.mouseMove((int)origin.getX() + (int)dim.getWidth()\/2,\n+                            (int)origin.getY() + (int)dim.getHeight()\/2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            if (!tf1.isFocusOwner()) {\n+                synchronized (tf1Monitor) {\n+                    tf1Monitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+            if (!tf1.isFocusOwner()) {\n+                throw new RuntimeException(\"TEST FAILED. tf1 doesn't receive focus.\");\n+            }\n+\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.keyPress(KeyEvent.VK_B);\n+            robot.keyRelease(KeyEvent.VK_B);\n+            if (!ska.isFrameShown) {\n+                synchronized (keyMonitor) {\n+                    keyMonitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+            if (!ska.isFrameShown) {\n+                throw new RuntimeException(\"TEST FAILED. Second frame is not shown.\");\n+            }\n+\n+            Object waitMonitor = new Object();\n+            ReleaseWaiter waiter = new ReleaseWaiter(waitMonitor, KeyEvent.VK_C);\n+            tf1.addKeyListener(waiter);\n+            tf2.addKeyListener(waiter);\n+            robot.keyPress(KeyEvent.VK_C);\n+            robot.keyRelease(KeyEvent.VK_C);\n+\n+            synchronized (waitMonitor) {\n+                waitMonitor.wait(2000);\n+            }\n+\n+            if ((tf1.getText().length() > 2) || (tf2.getText().length() < 1)) {\n+                System.out.println(\"tf1's text = \\\"\" + tf1.getText() + \"\\\"\");\n+                System.out.println(\"tf2's text = \\\"\" + tf2.getText() + \"\\\"\");\n+                System.out.println(\"l1 = \" + tf1.getText().length());\n+                System.out.println(\"l2 = \" + tf2.getText().length());\n+                throw new RuntimeException(\"TEST FAILED.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame1 != null) {\n+                    frame1.dispose();\n+                }\n+                if (frame2 != null) {\n+                    frame2.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+ }\/\/ class QuickTypeTest\n+\n+class ReleaseWaiter extends KeyAdapter {\n+    Object monitor;\n+    int keycode;\n+    public ReleaseWaiter(Object monitor, int keycode) {\n+        this.monitor = monitor;\n+        this.keycode = keycode;\n+    }\n+\n+    public void keyReleased(KeyEvent ke) {\n+        System.out.println(\"keyReleased \" + ke.getKeyCode());\n+        if (ke.getKeyCode() == keycode) {\n+            synchronized (monitor) {\n+                monitor.notify();\n+            }\n+        }\n+    }\n+}\n+\n+class SmartKeyAdapter implements KeyListener {\n+    JFrame frame;\n+    int charCounter = 0;\n+    boolean isFrameShown = false;\n+    Object monitor;\n+\n+    public SmartKeyAdapter(JFrame frame, Object monitor) {\n+        this.frame = frame;\n+        this.monitor = monitor;\n+    }\n+\n+    public void keyReleased(KeyEvent ke) {\n+        System.out.println(ke.toString());\n+    }\n+    public void keyPressed(KeyEvent ke) {\n+        System.out.println(ke.toString());\n+        charCounter++;\n+        if (charCounter == 2) {\n+            frame.setVisible(true);\n+            isFrameShown = true;\n+            synchronized (monitor) {\n+                monitor.notify();\n+            }\n+        }\n+    }\n+    public void keyTyped(KeyEvent ke) {\n+        System.out.println(ke.toString());\n+    }\n+}\n+\n+class MonitoredFocusListener extends FocusAdapter {\n+    Object monitor;\n+\n+    public MonitoredFocusListener(Object monitor) {\n+        this.monitor = monitor;\n+    }\n+\n+    public void focusLost(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+    }\n+    public void focusGained(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+        synchronized (monitor) {\n+            monitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/QuickTypeTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4504665\n+  @summary MerlinBeta2 - vetoing a focus change causes infinite loop\n+  @key headful\n+  @run main RestoreFocusInfiniteLoopTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyVetoException;\n+import java.beans.VetoableChangeListener;\n+\n+public class RestoreFocusInfiniteLoopTest {\n+    static final int TEST_TIMEOUT = 1000;\n+    static final int DELAY = 100;\n+    static Button b1;\n+    static Frame frame;\n+    static Object b1Monitor;\n+    static Point origin;\n+    static Dimension dim;\n+    static MonitoredFocusListener monitorer;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+\n+                b1Monitor = new Object();\n+                frame = new Frame();\n+                b1 = new Button(\"1\");\n+                Button b2 = new Button(\"2\");\n+                b1.setName(\"b1\");\n+                b2.setName(\"b2\");\n+\n+                frame.setLayout(new FlowLayout());\n+                frame.add(b1);\n+                frame.add(b2);\n+                frame.pack();\n+                frame.setSize(100, 100);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+                FocusVetoableChangeListener vetoer = new FocusVetoableChangeListener(b2);\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                    addVetoableChangeListener(\"focusOwner\", vetoer);\n+\n+            });\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(DELAY);\n+            robot.setAutoWaitForIdle(true);\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(() -> {\n+                monitorer = new MonitoredFocusListener(b1Monitor);\n+                b1.addFocusListener(monitorer);\n+                origin = b1.getLocationOnScreen();\n+                dim = b1.getSize();\n+            });\n+            robot.mouseMove((int)origin.getX() + (int)dim.getWidth()\/2,\n+                            (int)origin.getY() + (int)dim.getHeight()\/2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            if (!b1.isFocusOwner()) {\n+                synchronized (b1Monitor) {\n+                    b1Monitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+\n+            monitorer.resetFocusLost();\n+            robot.keyPress(KeyEvent.VK_TAB);\n+            robot.keyRelease(KeyEvent.VK_TAB);\n+\n+            if (!monitorer.isFocusLostReceived() || !b1.isFocusOwner()) {\n+               synchronized (b1Monitor) {\n+                    b1Monitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+            if (!b1.isFocusOwner()) {\n+                throw new RuntimeException(\"Test is FAILED\");\n+            } else {\n+                System.out.println(\"Test is PASSED\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+\n+ }\/\/ class RestoreFocusInfiniteLoopTest\n+\n+class FocusVetoableChangeListener implements VetoableChangeListener {\n+    Component vetoedComponent;\n+    public FocusVetoableChangeListener(Component vetoedComponent) {\n+        this.vetoedComponent = vetoedComponent;\n+    }\n+    public void vetoableChange(PropertyChangeEvent evt)\n+        throws PropertyVetoException\n+    {\n+        Component oldComp = (Component)evt.getOldValue();\n+        Component newComp = (Component)evt.getNewValue();\n+\n+        boolean vetoFocusChange = (newComp == vetoedComponent);\n+        process(evt.getPropertyName(), oldComp, newComp);\n+\n+        if (vetoFocusChange) {\n+            throw new PropertyVetoException(\"message\", evt);\n+        }\n+    }\n+    boolean process(String propName, Component o1, Component o2) {\n+        System.out.println(propName +\n+                           \" old=\" + (o1 != null ? o1.getName() : \"null\") +\n+                           \" new=\" + (o2 != null ? o2.getName() : \"null\"));\n+            return true;\n+        }\n+    }\n+\n+class MonitoredFocusListener extends FocusAdapter {\n+    Object monitor;\n+    boolean focuslost = false;\n+\n+    public void resetFocusLost() {\n+        focuslost = false;\n+    }\n+    public boolean isFocusLostReceived() {\n+        return focuslost;\n+    }\n+    public MonitoredFocusListener(Object monitor) {\n+        this.monitor = monitor;\n+    }\n+\n+    public void focusLost(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+        focuslost = true;\n+    }\n+    public void focusGained(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+        synchronized (monitor) {\n+            monitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/RestoreFocusInfiniteLoopTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug       5070991\n+  @key headful\n+  @summary   Tests for a transitivity problem with ROW_TOLERANCE in SortingFTP.\n+  @run       main RowToleranceTransitivityTest\n+*\/\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JCheckBox;\n+import javax.swing.JFrame;\n+import javax.swing.JFormattedTextField;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class RowToleranceTransitivityTest {\n+    static JFrame frame;\n+    static JPanel panel;\n+    static JFormattedTextField ft;\n+    static JCheckBox cb;\n+    static GridBagConstraints gc;\n+    static Robot robot;\n+\n+    static AtomicBoolean focusGained = new AtomicBoolean(false);\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        robot.setAutoWaitForIdle(true);\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                gc = new GridBagConstraints();\n+                frame = new JFrame(\"JFrame\");\n+                JPanel panel = new JPanel(new GridBagLayout());\n+                ft = new JFormattedTextField();\n+                cb = new JCheckBox(\"JCheckBox\");\n+                Dimension dim = new Dimension(100, ft.getPreferredSize().height);\n+                ft.setPreferredSize(dim);\n+                ft.setMinimumSize(dim);\n+                gc.gridx = 5;\n+                gc.gridy = 1;\n+                gc.gridwidth = 10;\n+                panel.add(ft, gc);\n+\n+                gc.gridy = 3;\n+                panel.add(cb, gc);\n+\n+                cb.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent e) {\n+                        System.out.println(e.toString());\n+                        synchronized (focusGained) {\n+                            focusGained.set(true);\n+                            focusGained.notifyAll();\n+                        }\n+                    }\n+                });\n+\n+                gc.weightx = 1.0;\n+                gc.gridwidth = 1;\n+                gc.gridy = 0;\n+                gc.gridx = 0;\n+                for (int n = 0; n < 7; n++) {\n+                    panel.add(getlabel(), gc);\n+                    gc.gridy++;\n+                }\n+\n+                gc.gridx = 0;\n+                gc.gridy = 0;\n+                for (int n = 0; n < 7; n++) {\n+                    panel.add(getlabel(), gc);\n+                    gc.gridx++;\n+                }\n+\n+                frame.getContentPane().add(panel);\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+                frame.setAlwaysOnTop(true);\n+\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            test();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+\n+    static void test() throws Exception {\n+        robot.delay(500);\n+\n+        \/\/ Set focus on the first component to start traversal\n+        if (!setFocusOn(ft, new Runnable() {\n+            public void run() {\n+                clickOn(ft);\n+            }\n+            })) {\n+            System.out.println(\"Couldn't set focus on \" + ft);\n+            throw new RuntimeException(\"Test couldn't be performed.\");\n+        }\n+\n+        robot.delay(500);\n+\n+        \/\/ Try to traverse\n+        if (!setFocusOn(cb, new Runnable() {\n+            public void run() {\n+                robot.keyPress(KeyEvent.VK_TAB);\n+            }\n+            })) {\n+            System.out.println(\"Focus got stuck while traversing.\");\n+            throw new RuntimeException(\"Test failed!\");\n+        }\n+\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    static boolean setFocusOn(Component comp, Runnable action) {\n+\n+        if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() == comp) {\n+            System.out.println(\"Already focus owner: \" + comp);\n+            return true;\n+        }\n+\n+        focusGained.set(false);\n+\n+        System.out.println(\"Setting focus on \" + comp);\n+\n+        comp.addFocusListener(new FocusAdapter() {\n+                public void focusGained(FocusEvent e) {\n+                    System.out.println(e.toString());\n+                    synchronized (focusGained) {\n+                        focusGained.set(true);\n+                        focusGained.notifyAll();\n+                    }\n+                }\n+            });\n+\n+        action.run();\n+\n+        synchronized (focusGained) {\n+            if (!focusGained.get()) {\n+                try {\n+                    focusGained.wait(3000);\n+                } catch (InterruptedException e) {\n+                    System.out.println(\"Unexpected exception caught!\");\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        return focusGained.get();\n+    }\n+\n+    static JLabel getlabel(){\n+        Dimension dim = new Dimension(5, 9); \/\/ LayoutComparator.ROW_TOLERANCE = 10;\n+        JLabel l = new JLabel(\"*\");\n+        l.setMinimumSize(dim);\n+        l.setMaximumSize(dim);\n+        l.setPreferredSize(dim);\n+        return l;\n+    }\n+\n+    static void clickOn(Component c) {\n+        Point p = c.getLocationOnScreen();\n+        Dimension d = c.getSize();\n+\n+        System.out.println(\"Clicking \" + c);\n+\n+        if (c instanceof Frame) {\n+            robot.mouseMove(p.x + (int)(d.getWidth()\/2), p.y + ((Frame)c).getInsets().top\/2);\n+        } else {\n+            robot.mouseMove(p.x + (int)(d.getWidth()\/2), p.y + (int)(d.getHeight()\/2));\n+        }\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/RowToleranceTransitivityTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4648816\n+  @summary Sometimes focus requests on LW components are delayed\n+  @key headful\n+  @run main SequencedLightweightRequestsTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+\n+public class SequencedLightweightRequestsTest implements FocusListener {\n+    final int WAIT_TIME = 5000;\n+\n+    JFrame testFrame;\n+    JButton testButton1;\n+    JButton testButton2;\n+    JTextField testField;\n+\n+    public void focusGained(FocusEvent fe) {\n+        System.err.println(\"FocusGained on \" + fe.getComponent().getName());\n+    }\n+\n+    public void focusLost(FocusEvent fe) {\n+        System.err.println(\"FocusLost on \" + fe.getComponent().getName());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SequencedLightweightRequestsTest test =\n+            new SequencedLightweightRequestsTest();\n+        test.start();\n+    }\n+\n+    public void start() throws Exception {\n+        try {\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                testFrame = new JFrame(\"See my components!\");\n+                testButton1 = new JButton(\"Click me!\");\n+                testButton2 = new JButton(\"Do I have focus?\");\n+                testField = new JTextField(\"Do I have focus?\");\n+                testFrame.getContentPane().setLayout(new FlowLayout());\n+                testFrame.getContentPane().add(testButton1);\n+                testFrame.getContentPane().add(testField);\n+                testFrame.getContentPane().add(testButton2);\n+\n+                testButton1.setName(\"Button1\");\n+                testButton2.setName(\"Button2\");\n+                testField.setName(\"textField\");\n+                testButton1.addFocusListener(this);\n+                testButton2.addFocusListener(this);\n+                testField.addFocusListener(this);\n+                testFrame.addFocusListener(this);\n+\n+                testFrame.setSize(300, 100);\n+                testFrame.setLocationRelativeTo(null);\n+                testFrame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+\n+            \/\/ wait to give to frame time for showing\n+            robot.delay(1000);\n+\n+            \/\/ make sure that first button has focus\n+            Object monitor = new Object();\n+            MonitoredFocusListener monitorer =\n+                          new MonitoredFocusListener(monitor);\n+            Point origin = testButton1.getLocationOnScreen();\n+            Dimension dim = testButton1.getSize();\n+            robot.mouseMove((int)origin.getX() + (int)dim.getWidth()\/2,\n+                            (int)origin.getY() + (int)dim.getHeight()\/2);\n+            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+\n+            if (!testButton1.isFocusOwner()) {\n+                synchronized (monitor) {\n+                    testButton1.addFocusListener(monitorer);\n+                    monitor.wait(WAIT_TIME);\n+                    testButton1.removeFocusListener(monitorer);\n+                }\n+            }\n+\n+            \/\/ if first button still doesn't have focus, test fails\n+            if (!testButton1.isFocusOwner()) {\n+                throw new RuntimeException(\"First button doesn't receive focus\");\n+            }\n+\n+            \/\/ two lightweight requests\n+            java.awt.EventQueue.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    testButton2.requestFocus();\n+                    testField.requestFocus();\n+                }\n+            });\n+\n+            \/\/ make sure third button receives focus\n+            if (!testField.isFocusOwner()) {\n+                synchronized (monitor) {\n+                    testField.addFocusListener(monitorer);\n+                    monitor.wait(WAIT_TIME);\n+                    testField.removeFocusListener(monitorer);\n+                }\n+            }\n+\n+            \/\/ if the text field still doesn't have focus, test fails\n+            if (!testField.isFocusOwner()) {\n+                throw new RuntimeException(\"Text field doesn't receive focus\");\n+            }\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (testFrame != null) {\n+                    testFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\/\/ class SequencedLightweightRequestsTest\n+\n+class MonitoredFocusListener extends FocusAdapter {\n+    Object monitor;\n+\n+    public MonitoredFocusListener(Object monitor) {\n+        this.monitor = monitor;\n+    }\n+\n+    public void focusGained(FocusEvent fe) {\n+        synchronized (monitor) {\n+            monitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/SequencedLightweightRequestsTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4597455\n+  @summary setFocusable(false) is not moving the focus to next Focusable Component\n+  @key headful\n+  @run main SetFocusableTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+\n+public class SetFocusableTest implements KeyListener {\n+    static Object buttonMonitor;\n+    Object tfMonitor;\n+    static final int TEST_TIMEOUT = 5000;\n+    Button button;\n+    Frame frame;\n+    TextField textfield;\n+\n+    public static void main(String[] args) throws Exception {\n+        SetFocusableTest test = new SetFocusableTest();\n+        test.start();\n+    }\n+\n+    public void start() throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                buttonMonitor = new Object();\n+                tfMonitor = new Object();\n+                frame = new Frame();\n+                frame.setTitle(\"Test Frame\");\n+                frame.setLocation(100, 100);\n+                frame.setLayout(new FlowLayout());\n+\n+                button = new Button(\"BUTTON\");\n+                textfield = new TextField(\"First\");\n+\n+                button.addKeyListener(this);\n+                textfield.addKeyListener(this);\n+\n+                frame.add(button);\n+                frame.add(textfield);\n+\n+                frame.setBackground(Color.red);\n+                frame.setSize(500,200);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+                frame.toFront();\n+                button.addFocusListener(new MonitoredFocusListener(buttonMonitor));\n+                textfield.addFocusListener(new MonitoredFocusListener(tfMonitor));\n+            });\n+\n+            Robot robot;\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.setAutoWaitForIdle(true);\n+            robot.delay(1000);\n+\n+            Point buttonOrigin = button.getLocationOnScreen();\n+            Dimension buttonSize = button.getSize();\n+            robot.mouseMove(\n+                (int)buttonOrigin.getX() + (int)buttonSize.getWidth() \/ 2,\n+                (int)buttonOrigin.getY() + (int)buttonSize.getHeight() \/ 2);\n+\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+            if (!button.isFocusOwner()) {\n+                synchronized (buttonMonitor) {\n+                    buttonMonitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+            System.out.println(\"\\n\\nBefore calling the method button.setFocusable(false)\");\n+            System.out.println(\"====================================================\");\n+            System.out.println(\"Button is Focusable(button.isFocusable()) :\"+button.isFocusable());\n+            System.out.println(\"Button is Focus owner(button.isFocusOwner()) :\"+button.isFocusOwner());\n+            System.out.println(\"Button has Focus (button.hasFocus) :\"+button.hasFocus());\n+            System.out.println(\"====================================================\");\n+\n+            button.setFocusable(false);\n+\n+            if (!textfield.isFocusOwner()) {\n+                synchronized (tfMonitor) {\n+                    tfMonitor.wait(TEST_TIMEOUT);\n+                }\n+            }\n+\n+            System.out.println(\"\\nAfter Calling button.setFocusable(false)\");\n+            System.out.println(\"====================================================\");\n+            System.out.println(\"Button is Focusable(button.isFocusable()) :\"+button.isFocusable());\n+            System.out.println(\"Button is Focus owner(button.isFocusOwner()) :\"+button.isFocusOwner());\n+            System.out.println(\"Button has Focus (button.hasFocus()) :\"+button.hasFocus());\n+            System.out.println(\"TextField is Focusable(textfield.isFocusable()) :\"+textfield.isFocusable());\n+            System.out.println(\"TextField is Focus owner(textfield.isFocusOwner()) :\"+textfield.isFocusOwner());\n+            System.out.println(\"TextField has Focus (textfield.hasFocus()) :\"+textfield.hasFocus());\n+            System.out.println(\"====================================================n\\n\\n\\n\");\n+\n+            if (!button.hasFocus() && !button.isFocusOwner() &&\n+                textfield.hasFocus() && textfield.isFocusOwner()){\n+                System.out.println(\"\\n\\n\\nASSERTION :PASSED\");\n+                System.out.println(\"=========================\");\n+                System.out.println(\"Textfield is having the Focus.Transfer of Focus has happend.\");\n+            } else {\n+                System.out.println(\"\\n\\n\\nASSERTION :FAILED\");\n+                System.out.println(\"==========================\");\n+                System.out.println(\"Button is still having the Focus instead of TextField\");\n+                throw new RuntimeException(\"Test FIALED\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\/\/ start()\n+\n+    public void keyPressed(KeyEvent e) {\n+        System.out.println(\"Key Pressed \");\n+    }\n+    public void keyReleased(KeyEvent ke) {\n+        System.out.println(\"keyReleased called \");\n+    }\n+    public void keyTyped(KeyEvent ke) {\n+        System.out.println(\"keyTyped called \");\n+    }\n+}\/\/ class SetFocusableTest\n+\n+class MonitoredFocusListener extends FocusAdapter {\n+    Object monitor;\n+    public MonitoredFocusListener(Object monitor) {\n+        this.monitor = monitor;\n+    }\n+\n+    public void focusGained(FocusEvent fe) {\n+        System.out.println(fe.toString());\n+        synchronized (monitor) {\n+            monitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/SetFocusableTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4794413\n+ * @summary Tests that access to temporaryLostComponent from two different threads doesn't cause a deadlock\n+ * @key headful\n+ * @run main TemporaryLostComponentDeadlock\n+*\/\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class TemporaryLostComponentDeadlock {\n+    static Dialog frame1;\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            frame = new Frame(\"frame\");\n+            frame1 = new Dialog(frame, \"Frame 1\", false);\n+            frame1.add(new Button(\"focus owner\"));\n+            frame1.pack();\n+            frame1.setLocationRelativeTo(null);\n+            frame1.setVisible(true);\n+        });\n+\n+        Thread t1 = new Thread() {\n+            public void run() {\n+                synchronized(frame1) {\n+                    frame1.dispose();\n+                    synchronized(frame1) {\n+                        frame1.notify();\n+                    }\n+                }\n+            }\n+        };\n+        try {\n+            synchronized(frame1) {\n+                t1.start();\n+                frame1.wait();\n+            }\n+        } catch( InterruptedException ie) {\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+\n+}\/\/ class TemporaryLostComponentDeadlock\n","filename":"test\/jdk\/java\/awt\/Focus\/TemporaryLostComponentDeadlock.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4457455\n+  @summary Component and KeyboardFocusManager use wrong names of the properties\n+  @run main TraversalKeysPropertyNamesTest\n+*\/\n+\n+import java.awt.AWTKeyStroke;\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.EventQueue;\n+import java.awt.KeyboardFocusManager;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.HashSet;\n+\n+public class TraversalKeysPropertyNamesTest implements PropertyChangeListener {\n+    final String[] properties = {\n+        \"forwardDefaultFocusTraversalKeys\",\n+        \"backwardDefaultFocusTraversalKeys\",\n+        \"upCycleDefaultFocusTraversalKeys\",\n+        \"downCycleDefaultFocusTraversalKeys\",\n+        \"forwardFocusTraversalKeys\",\n+        \"backwardFocusTraversalKeys\",\n+        \"upCycleFocusTraversalKeys\",\n+        \"downCycleFocusTraversalKeys\"\n+    };\n+    final int PROPERTIES_COUNT = properties.length;\n+    boolean[] flags = new boolean[PROPERTIES_COUNT];\n+\n+    public static void main(String[] args) throws Exception {\n+        TraversalKeysPropertyNamesTest test = new TraversalKeysPropertyNamesTest();\n+        test.start();\n+    }\n+\n+    public void start() throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            Container cont = new Container() {};\n+            HashSet forwardKeys = new HashSet();\n+            forwardKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl A\"));\n+            HashSet backwardKeys = new HashSet();\n+            backwardKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl B\"));\n+            HashSet upKeys = new HashSet();\n+            upKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl C\"));\n+            HashSet downKeys = new HashSet();\n+            downKeys.add(AWTKeyStroke.getAWTKeyStroke(\"ctrl D\"));\n+\n+            KeyboardFocusManager manager =\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager();\n+            manager.addPropertyChangeListener(this);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, backwardKeys);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, forwardKeys);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, downKeys);\n+            manager.setDefaultFocusTraversalKeys(\n+                   KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, upKeys);\n+\n+            cont.addPropertyChangeListener(this);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, backwardKeys);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, forwardKeys);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, downKeys);\n+            cont.setFocusTraversalKeys(KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, upKeys);\n+\n+            for (int i = 0; i < PROPERTIES_COUNT; i++) {\n+                if (!flags[i]) {\n+                    throw new RuntimeException(\n+                        \"Notification on \"+properties[i]+\" change was not received\");\n+                }\n+            }\n+        });\n+    }\/\/ start()\n+\n+    public void propertyChange(PropertyChangeEvent pce) {\n+        String property = pce.getPropertyName();\n+        System.err.println(property);\n+        int index;\n+        for (index = 0; index < PROPERTIES_COUNT; index++) {\n+            if (property.equals(properties[index])) {\n+                break;\n+            }\n+        }\n+\n+        if (index < PROPERTIES_COUNT) {\n+            flags[index] = true;\n+        }\n+    }\n+ }\/\/ class TraversalKeysPropertyNamesTest\n","filename":"test\/jdk\/java\/awt\/Focus\/TraversalKeysPropertyNamesTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4394789\n+  @summary KeyboardFocusManager.upFocusCycle is not working for Swing properly\n+  @key headful\n+  @run main UpFocusCycleTest\n+*\/\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.Color;\n+import java.awt.DefaultKeyboardFocusManager;\n+import java.awt.EventQueue;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.Robot;\n+import javax.swing.DefaultFocusManager;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+\n+public class UpFocusCycleTest {\n+    static boolean isFailed = true;\n+    static Object sema = new Object();\n+    static JFrame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            EventQueue.invokeAndWait(() -> {\n+\n+                frame = new JFrame(\"Test frame\");\n+\n+                Container container1 = frame.getContentPane();\n+                container1.setBackground(Color.yellow);\n+\n+                JButton button = new JButton(\"Button\");\n+                button.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent fe) {\n+                        DefaultKeyboardFocusManager manager = new DefaultFocusManager();\n+                        manager.upFocusCycle(button);\n+                        System.out.println(\"Button receive focus\");\n+                        frame.addFocusListener(new FocusAdapter() {\n+                            public void focusGained(FocusEvent fe) {\n+                                System.out.println(\"Frame receive focus\");\n+                                synchronized (sema) {\n+                                    isFailed = false;\n+                                    sema.notifyAll();\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+                container1.add(button,BorderLayout.WEST);\n+                button.requestFocus();\n+                frame.setSize(300,300);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (isFailed) {\n+                System.out.println(\"Test FAILED\");\n+                throw new RuntimeException(\"Test FAILED\");\n+            } else {\n+                System.out.println(\"Test PASSED\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+ }\/\/ class UpFocusCycleTest\n","filename":"test\/jdk\/java\/awt\/Focus\/UpFocusCycleTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug        5074189\n+  @summary    Tests that VetoableChangeListener doesn't initiate infinite loop.\n+  @key headful\n+  @run main VetoableChangeListenerLoopTest\n+*\/\n+import java.awt.AWTEvent;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.WindowEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyVetoException;\n+import java.beans.VetoableChangeListener;\n+\n+public class VetoableChangeListenerLoopTest {\n+    static Button b1;\n+    static Button b2;\n+    static Frame frame;\n+    static Robot robot;\n+\n+    static int counter = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            EventQueue.invokeAndWait(() -> {\n+                KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                    addVetoableChangeListener(new VetoableChangeListener () {\n+                        public void vetoableChange(PropertyChangeEvent evt)\n+                                               throws PropertyVetoException {\n+                            if (b1.equals(evt.getNewValue())) {\n+                                System.out.println(\"VETOING: \" + (counter++));\n+                                if (counter > 2) {\n+                                    throw new RuntimeException(\"Test failed!\");\n+                                }\n+                                throw new PropertyVetoException(\"Change in property\", evt);\n+                            }\n+                        }\n+                    });\n+\n+                Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {\n+                    public void eventDispatched(AWTEvent e) {\n+                        System.out.println(e.toString());\n+                    }\n+                }, FocusEvent.FOCUS_EVENT_MASK | WindowEvent.WINDOW_FOCUS_EVENT_MASK);\n+\n+                b1 = new Button(\"Button 1\");\n+                b2 = new Button(\"Button 2\");\n+                Frame frame = new Frame();\n+                frame.add(b1);\n+                frame.add(b2);\n+                frame.setSize(200, 100);\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+\n+            robot.delay(1000);\n+            test();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+\n+    static void test() {\n+        b2.requestFocusInWindow();\n+        waitTillFocus(b2);\n+        b2.setVisible(false);\n+    }\n+\n+\n+    static void waitTillFocus(Component comp) {\n+        while (!checkFocusOwner(comp)) {\n+            robot.delay(100);\n+        }\n+    }\n+\n+    static boolean checkFocusOwner(Component comp) {\n+        return (comp == KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner());\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/VetoableChangeListenerLoopTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4198994\n+  @summary getInsets should return Insets object that is safe to modify\n+  @key headful\n+  @run main ClobberSharedInsetsObjectTest\n+*\/\n+\n+\/**\n+ * ClobberSharedInsetsObjectTest.java\n+ *\n+ * summary: The bug is that getInsets directly returns Insets object\n+ * obtained from peer getInsets.  The latter always return the\n+ * reference to the same object, so modifying this object will affect\n+ * other code that calls getInsets.  The test checks that it's safe to\n+ * modify the Insets object returned by getInsets.  If the change to\n+ * this object is not visible on the next invocation, the bug is\n+ * considered to be fixed.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Panel;\n+\n+public class ClobberSharedInsetsObjectTest {\n+    static Panel p;\n+\n+    \/\/ Impossible inset value to use for the test\n+    final static int SENTINEL_INSET_VALUE = -10;\n+    static Frame f;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            try {\n+                \/\/ Need a peer anyway, so let the bug manifest visuially, even\n+                \/\/ though we can detect it automatically.\n+                f = new Frame();\n+                p = new Panel();\n+                p.setBackground(Color.red);\n+                f.setLayout (new BorderLayout ());\n+                f.add(p, \"Center\");\n+\n+                Insets insetsBefore = p.getInsets();\n+                insetsBefore.top = SENTINEL_INSET_VALUE;\n+\n+                Insets insetsAfter = p.getInsets();\n+                if (insetsAfter.top == SENTINEL_INSET_VALUE) { \/\/ OOPS!\n+                    throw new Error(\"4198994: getInsets returns the same object on subsequent invocations\");\n+                }\n+\n+                f.setSize (200,200);\n+                f.setLocationRelativeTo(null);\n+                f.setVisible(true);\n+\n+                System.out.println(\"getInsets is ok.  The object it returns is safe to modify.\");\n+            } finally {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Insets\/ClobberSharedInsetsObjectTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 6353381\n+  @summary REG: Container.getInsets() returns an incorrect value after removal of menubar, Win32\n+  @key headful\n+  @run main RemoveMenuBarTest\n+*\/\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+\n+public class RemoveMenuBarTest {\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            try {\n+                \/\/ old insets: top>0 | left>0\n+                \/\/ new insets: top=0 & left=0\n+                \/\/ the bug is that updating doesn't happen\n+                frame = new Frame();\n+                MenuBar menubar = new MenuBar();\n+                frame.setBounds(100,100,100,100);\n+                frame.setUndecorated(true);\n+                frame.pack();\n+                menubar.add(new Menu());\n+                frame.setMenuBar(menubar);\n+                System.out.println(frame.getInsets());\n+\n+                frame.setMenuBar(null);\n+                Insets insets = frame.getInsets();\n+                System.out.println(insets);\n+                if (insets.top != 0 || insets.left != 0 ||\n+                    insets.bottom !=0 || insets.right != 0) {\n+                    throw new RuntimeException(\"Test failed: the incorrect insets\");\n+                }\n+            } finally {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Insets\/RemoveMenuBarTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 4704042\n+  @summary Unit tests for Insets.set()\n+  @run main SetInsetsTest\n+*\/\n+import java.awt.Insets;\n+import java.awt.EventQueue;\n+\n+public class SetInsetsTest {\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            Insets insets = new Insets(0,0,0,0);\n+            insets.set(100,100,100,100);\n+            if (insets.top != 100 ||\n+                insets.bottom != 100 ||\n+                insets.left != 100 ||\n+                insets.right != 100) {\n+                throw new RuntimeException(\"Test Failed!  Insets=\" + insets);\n+            }\n+        });\n+    }\n+}\/\/ class SetInsetsTest\n","filename":"test\/jdk\/java\/awt\/Insets\/SetInsetsTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+  @test\n+  @bug 5089312\n+  @summary Bottom inset must not change after a second pack call.\n+  @key headful\n+  @run main WindowInsetsTest\n+*\/\n+import java.awt.EventQueue;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JWindow;\n+\n+public class WindowInsetsTest {\n+    static JFrame frame;\n+    static JWindow window;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            try {\n+                frame = new JFrame(\"Window Test\");\n+                frame.setBounds(100, 100, 400, 300);\n+                frame.setVisible(true);\n+\n+                JButton button = new JButton(\"A Button\");\n+                window = new JWindow(frame);\n+                window.getContentPane().add(button);\n+                window.pack();\n+                window.setLocation(200, 200);\n+                window.show();\n+                double h0 = window.getSize().getHeight();\n+                window.pack();\n+                double h1 = window.getSize().getHeight();\n+                if( Math.abs(h1 - h0) > 0.5 ) {\n+                    throw new RuntimeException(\"Test failed: Bad insets.\");\n+                }\n+                System.out.println(\"Test Passed.\");\n+            } finally {\n+                if (window != null) {\n+                    window.dispose();\n+                }\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Insets\/WindowInsetsTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4257143\n+  @summary RFE: Cannot set some AWT properties until peer has been created\n+  @key headful\n+*\/\n+\n+import java.awt.EventQueue;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+\n+public class PeerlessSetCaret {\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            TextField tf = new TextField(\"Hello, World!\");\n+            TextArea ta = new TextArea(\"Hello, World!\");\n+\n+            \/\/ without the fix these will throw IllegalComponentStateException\n+            tf.setCaretPosition(1);\n+            ta.setCaretPosition(1);\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TextComponent\/PeerlessSetCaret\/PeerlessSetCaret.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4118247\n+  @summary Make sure bounds are enforced correctly on\n+           TextComponent.Select(int, int)\n+  @key headful\n+*\/\n+\n+import java.awt.EventQueue;\n+import java.awt.TextArea;\n+import java.awt.TextComponent;\n+\n+public class SelectionBounds {\n+    public static TextComponent tc;\n+\n+    public static int[][] index = {\n+        {0, 0},     \/\/ 0 = selectionStart = selectionEnd\n+        {5, 5},     \/\/ selectionStart = selectionEnd\n+        {5, 7},     \/\/ 0 < selectionStart < selectionEnd < textLength\n+        {-50, 7},   \/\/ selectionStart < 0 < selectionEnd < textLength\n+        {-50, 50},  \/\/ selectionStart < 0 < textLength < selectionEnd\n+        {5, 50},    \/\/ 0 < selectionStart < textLength < selectionEnd\n+        {40, 50},   \/\/ 0 < textLength < selectionStart < selectionEnd\n+        {-50, -40}, \/\/ selectionStart < selectionEnd < 0 < textLength\n+        {7, 5},     \/\/ 0 < selectionEnd < selectionStart < textLength\n+        {7, -50},   \/\/ selectionEnd < 0 < selectionStart < textLength\n+        {50, -50},  \/\/ selectionEnd < 0 < textLength < selectionStart\n+        {50, 5},    \/\/ 0 < selectionEnd < textLength < selectionStart\n+        {50, 40},   \/\/ 0 < textLength < selectionEnd < selectionStart\n+        {-40, -50}  \/\/ selectionEnd < selectionStart < 0 < textLength\n+    };\n+\n+    public static String[] selections = {\n+        \"\",\n+        \"\",\n+        \"56\",\n+        \"0123456\",\n+        \"0123456789\",\n+        \"56789\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\",\n+        \"\"\n+    };\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            tc = new TextArea(\"0123456789\");\n+            runTheTest();\n+        });\n+    }\n+\n+    private static void runTheTest() {\n+        int i;\n+        String str1;\n+\n+        for (i=0; i<index.length; i++) {\n+            tc.select(index[i][0], index[i][1]);\n+            str1 = tc.getSelectedText();\n+\n+            if (!str1.equals(selections[i])) {\n+                System.out.println(\"Test \" + i + \" FAILED:  \" + str1 +\n+                    \" != \" + selections[i]);\n+                System.out.println(\"Test \" + i + \" FAILED:  \" + str1 +\n+                    \" != \" + selections[i]);\n+                throw new RuntimeException(\"Test \" + i + \" FAILED:  \" + str1 +\n+                    \" != \" + selections[i]);\n+            }\n+            else {\n+                System.out.println(\"Test \" + i + \" PASSED:  \" + str1 +\n+                    \" = \" + selections[i]);\n+                System.out.println(\"Test \" + i + \" PASSED:  \" + str1 +\n+                    \" = \" + selections[i]);\n+            }\n+        }\n+\n+        System.out.println(\"\\nAll tests PASSED.\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TextComponent\/SelectionBounds\/SelectionBounds.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4701398 4652358 4659958 4697796 4666876\n+  @summary REGRESSION: TextArea.append does not work consistently with \\r.\n+  @key headful\n+*\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+\n+public class TextAreaCRLFTest {\n+    private static final char[] DIGITS = {\n+        '0', '1', '2', '3', '4', '5', '6', '7',\n+        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+    };\n+\n+    public static Dialog aDialog;\n+    public static TextArea area;\n+    public static boolean passed = true;\n+    public static boolean res;\n+    public static String atext = \"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String atextCRLF = \"row1\\r\\nrow2\\r\\nrow3\";\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                aDialog = new Dialog(new Frame());\n+                aDialog.setTitle(\"ADialog\");\n+                aDialog.setBackground(Color.lightGray);\n+                aDialog.setLayout(new BorderLayout());\n+                Panel mainPanel = new Panel();\n+                mainPanel.setLayout(new BorderLayout(6, 6));\n+                area = new TextArea(atextCRLF, 25, 68,\n+                    TextArea.SCROLLBARS_VERTICAL_ONLY);\n+                area.setFont(new Font(\"Monospaced\", Font.PLAIN, 11));\n+                mainPanel.add(area, \"Center\");\n+                aDialog.add(mainPanel, \"Center\");\n+                aDialog.pack();\n+                System.out.println(\"before: \"+hexEncode(atextCRLF));\n+                System.out.println(\" after: \"+hexEncode(area.getText()));\n+                res = area.getText().equals(atextCRLF);\n+                System.out.println(\"01: \" + res + \"\\n\");\n+                passed = passed && res;\n+                area.setText(atextCRLF);\n+                System.out.println(\"before: \"+hexEncode(atextCRLF));\n+                System.out.println(\" after: \"+hexEncode(area.getText()));\n+                res = area.getText().equals(atextCRLF);\n+                System.out.println(\"02: \" + res + \"\\n\");\n+                passed = passed && res;\n+\n+                area.setText(\"\");\n+                atext = \"row1\";\n+                area.append(atext+\"\\r\");\n+                area.append(atext+\"\\r\");\n+                System.out.println(\"before: \"\n+                    +hexEncode(atext+\"\\r\" + atext+\"\\r\"));\n+                System.out.println(\" after: \"+hexEncode(area.getText()));\n+                res = area.getText().equals(atext + atext);\n+                System.out.println(\"03: \" + res + \"\\n\");\n+                passed = passed && res;\n+\n+                area.setText(\"\");\n+                String atext1 = \"fine.\";\n+                String atext2 = \"messed up.\";\n+                atext = atext1 +\"\\r\\n\"+ atext2;\n+                for (int i = 0; i < atext.length(); i++) {\n+                    area.append(atext.substring(i, i+1));\n+                }\n+                System.out.println(\"before: \"\n+                    +hexEncode(atext1 +\"\\r\\n\"+ atext2));\n+                System.out.println(\" after: \"+hexEncode(area.getText()));\n+                String s = area.getText();\n+                String t = s.substring(s.length()-atext2.length());\n+                res = t.equals(atext2);\n+                System.out.println(\"04: \" + res);\n+                passed = passed && res;\n+\n+                area.setText(\"\");\n+                atext = \"\\r\";\n+                area.append(atext);\n+                System.out.println(\"before: \"+hexEncode(atext));\n+                System.out.println(\" after: \"+hexEncode(area.getText()));\n+                res = area.getText().equals(\"\");\n+                System.out.println(\"05: \" + res + \"\\n\");\n+                passed = passed && res;\n+\n+                if (System.getProperty(\"os.name\").toUpperCase().\n+                    startsWith(\"WIN\")) {\n+                    if (!passed) {\n+                        throw new RuntimeException(\"TextAreaCRLFTest FAILED.\");\n+                    } else {\n+                        System.out.println(\"TextAreaCRLFTest PASSED\");\n+                    }\n+                } else {\n+                    System.out.println(\"This is a Windows oriented testcase.\");\n+                }\n+            });\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (aDialog != null) {\n+                    aDialog.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static String hexEncode(String str) {\n+        return hexEncode(str.getBytes());\n+    }\n+\n+    private static String hexEncode(byte[] bytes) {\n+        StringBuffer buffer = new StringBuffer(bytes.length * 2);\n+        for (int i = 0; i < bytes.length; i++) {\n+            byte b = bytes[i];\n+            buffer.append(DIGITS[(b & 0xF0) >> 4]);\n+            buffer.append(DIGITS[b & 0x0F]);\n+        }\n+        return buffer.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/TextComponent\/TextAreaCRLFTest\/TextAreaCRLFTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4290704\n+  @summary Test use of AWTEventListenerProxyTest class\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.EventQueue;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.AWTEventListenerProxy;\n+import java.util.EventListener;\n+\n+public class AWTEventListenerProxyTest {\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            Toolkit tk = Toolkit.getDefaultToolkit();\n+            if (\"sun.awt.X11.XToolkit\".equals(tk.getClass().getName())) {\n+                System.out.println(\"Do not test for XAWT Toolkit.\");\n+                System.out.println(\"Passing automatically.\");\n+                return;\n+            }\n+\n+            \/\/ check that if no listeners added, returns a 0-length array,\n+            \/\/ not null\n+            AWTEventListener[] array1 = tk.getAWTEventListeners();\n+            if (array1 == null || array1.length != 0) {\n+                System.out.println(\"[Empty array test failed!!]\");\n+                throw new RuntimeException(\"Test failed -\" +\n+                    \" didn't return 0-sized array\");\n+            }\n+            System.out.println(\"[Empty array test passed]\");\n+\n+            \/\/ simple add\/get test\n+            DumbListener dl1 = new DumbListener();\n+            final long dl1MASK = AWTEvent.ACTION_EVENT_MASK;\n+            tk.addAWTEventListener(dl1, dl1MASK);\n+\n+            array1 = tk.getAWTEventListeners();\n+            if (array1 == null || array1.length != 1) {\n+                System.out.println(\"[Simple add\/get test failed!!]\");\n+                throw new RuntimeException(\"Test failed - didn't \" +\n+                    \"return array of 1\");\n+            }\n+            AWTEventListenerProxy dp1 = (AWTEventListenerProxy) array1[0];\n+            EventListener getdl1 = dp1.getListener();\n+            if (getdl1 != dl1) {\n+                System.out.println(\"[Simple add\/get test failed - \" +\n+                    \"wrong listener!!]\");\n+                throw new RuntimeException(\"Test failed - wrong \" +\n+                    \"listener in proxy\");\n+            }\n+\n+            long getmask = dp1.getEventMask();\n+            if (getmask != dl1MASK) {\n+                System.out.println(\"[Simple add\/get test failed - \" +\n+                    \"wrong mask!!]\");\n+                throw new RuntimeException(\"Test failed - wrong mask in proxy\");\n+            }\n+            System.out.println(\"[Simple add\/get test passed]\");\n+\n+            \/\/ add the same listener inside a proxy, with a different mask\n+            \/\/ should get back one listener, with the ORed mask\n+            final long dl2MASK = AWTEvent.CONTAINER_EVENT_MASK;\n+            AWTEventListenerProxy newp = new AWTEventListenerProxy(dl2MASK,\n+                dl1);\n+            tk.addAWTEventListener(newp, dl2MASK);\n+            array1 = tk.getAWTEventListeners();\n+            if (array1.length != 1) {\n+                System.out.println(\"[Proxy add\/get test failed!!]\");\n+                throw new RuntimeException(\"Test failed - added proxy, \" +\n+                    \"but didn't return array of 1\");\n+            }\n+            dp1 = (AWTEventListenerProxy) array1[0];\n+            getdl1 = dp1.getListener();\n+            if (getdl1 != dl1) {\n+                System.out.println(\"[Proxy add\/get test \" +\n+                    \"failed - wrong listener!!]\");\n+                throw new RuntimeException(\"Test failed - added proxy, \" +\n+                    \"wrong listener in proxy\");\n+            }\n+            getmask = dp1.getEventMask();\n+            if (getmask != (dl1MASK | dl2MASK)) {\n+                System.out.println(\"[Proxy add\/get test failed - \" +\n+                    \"wrong mask!!]\");\n+                throw new RuntimeException(\"Test failed - added proxy, \" +\n+                    \"wrong mask in proxy\");\n+            }\n+            System.out.println(\"[Proxy add\/get test passed]\");\n+\n+            \/\/ add some other listener\n+            DumbListener dl3 = new DumbListener();\n+            final long dl3MASK = AWTEvent.FOCUS_EVENT_MASK;\n+            tk.addAWTEventListener(dl3, dl3MASK);\n+\n+            \/\/ test getting with a mask for a listener already added\n+            array1 = tk.getAWTEventListeners(dl1MASK);\n+            if (array1.length != 1) {\n+                System.out.println(\"[Get w\/ mask test failed!! - \" +\n+                    \"not 1 listener!]\");\n+                throw new RuntimeException(\"Test failed - tried to \" +\n+                    \"get w\/ mask\");\n+            }\n+            dp1 = (AWTEventListenerProxy) array1[0];\n+            getdl1 = dp1.getListener();\n+            if (getdl1 != dl1) {\n+                System.out.println(\"[Get w\/ mask test failed!! - \" +\n+                    \"wrong listener]\");\n+                throw new RuntimeException(\"Test failed - tried to get \" +\n+                    \"w\/ mask, wrong listener in proxy\");\n+            }\n+            System.out.println(\"[Get w\/ mask test passed]\");\n+\n+            \/\/ test getting with a mask for a listener not added\n+            array1 = tk.getAWTEventListeners(AWTEvent.MOUSE_EVENT_MASK);\n+            if (array1.length != 0) {\n+                System.out.println(\"[Get w\/ mask test 2 failed!! - \" +\n+                    \"not 0 listeners!]\");\n+                throw new RuntimeException(\"Test failed - tried to get \" +\n+                    \"w\/ mask 2\");\n+            }\n+            System.out.println(\"[Get w\/ mask test 2 passed]\");\n+\n+\n+            \/\/ test getting with a compound mask for a listener already added\n+            array1 = tk.getAWTEventListeners(dl1MASK | dl2MASK);\n+            if (array1.length != 1) {\n+                System.out.println(\"[Get w\/ compound mask test failed!! - \" +\n+                    \"not 1 listeners!]\");\n+                throw new RuntimeException(\"Test failed - tried to get w\/ 2 \" +\n+                    \"ORed masks\");\n+            }\n+            dp1 = (AWTEventListenerProxy) array1[0];\n+            getdl1 = dp1.getListener();\n+            if (getdl1 != dl1) {\n+                System.out.println(\"[Get w\/ compound mask test failed!! - \" +\n+                    \"wrong listener]\");\n+                throw new RuntimeException(\"Test failed - tried to get w\/ \" +\n+                    \"compound mask, wrong listener in proxy\");\n+            }\n+            System.out.println(\"[Get w\/ compound mask test passed]\");\n+        });\n+    }\n+\n+    public static class DumbListener implements AWTEventListener {\n+        public DumbListener() {}\n+        public void eventDispatched(AWTEvent e) {}\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Toolkit\/AWTEventListenerProxyTest\/AWTEventListenerProxyTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4338463\n+  @summary excessive synchronization in notifyAWTEventListeners leads to\n+  deadlock\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.EventQueue;\n+import java.awt.Panel;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.ActionEvent;\n+\n+public class ListenerDeadlockTest {\n+    public static final Object lock = new Object();\n+\n+    public static final Toolkit toolkit = Toolkit.getDefaultToolkit();\n+\n+    public static Panel panel = new Panel();\n+\n+    public static final AWTEventListener listener = new AWTEventListener() {\n+        public void eventDispatched(AWTEvent e) {\n+            if (e.getSource() == panel) {\n+                System.out.println(e);\n+                System.out.println(\"No deadlock\");\n+                synchronized(lock) {\n+                    lock.notifyAll();\n+                }\n+            }\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            toolkit.addAWTEventListener(listener, -1);\n+\n+            Thread thread = new Thread(new Runnable() {\n+                public void run() {\n+                    synchronized (toolkit) {\n+                        synchronized (lock) {\n+                            try {\n+                                lock.notifyAll();\n+                                lock.wait();\n+                            } catch (InterruptedException ex) {\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+\n+            synchronized (lock) {\n+                thread.start();\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException ex) {\n+                }\n+            }\n+\n+            panel.dispatchEvent(new ActionEvent(panel,\n+                ActionEvent.ACTION_PERFORMED, \"Try\"));\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Toolkit\/ListenersDeadlockTest\/ListenerDeadlockTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+\n+\/*\n+ * @test\n+ * @bug 4724007\n+ * @key headful\n+ * @summary Tests that KeyTyped events are fired for the Delete key\n+ *          and that no extraneous characters are entered as a result.\n+ *\/\n+\n+public class DeleteKeyTyped {\n+    private static Frame frame;\n+    private static TextField tf;\n+\n+    private static boolean deleteKeyTypedReceived = false;\n+    private static final String ORIGINAL = \"0123456789\";\n+    private static final String SUCCESS = \"123456789\";\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(100);\n+\n+            EventQueue.invokeAndWait(DeleteKeyTyped::createTestUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            \/\/ Move cursor to start of TextField\n+            robot.keyPress(KeyEvent.VK_HOME);\n+            robot.keyRelease(KeyEvent.VK_HOME);\n+            robot.waitForIdle();\n+            robot.delay(50);\n+\n+            \/\/ Press and release Delete\n+            robot.keyPress(KeyEvent.VK_DELETE);\n+            robot.keyRelease(KeyEvent.VK_DELETE);\n+            robot.waitForIdle();\n+            robot.delay(50);\n+\n+            EventQueue.invokeAndWait(DeleteKeyTyped::testDeleteKeyEvent);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createTestUI() {\n+        frame = new Frame();\n+        tf = new TextField(ORIGINAL, 20);\n+        frame.add(tf);\n+        frame.setSize(300, 100);\n+        frame.setVisible(true);\n+        tf.requestFocusInWindow();\n+\n+        tf.addKeyListener(new KeyListener() {\n+            @Override\n+            public void keyPressed(KeyEvent evt) {\n+                printKey(evt);\n+            }\n+\n+            @Override\n+            public void keyTyped(KeyEvent evt) {\n+                printKey(evt);\n+                int keychar = evt.getKeyChar();\n+                if (keychar == 127) { \/\/ Delete character is 127 or \\u007F\n+                    deleteKeyTypedReceived = true;\n+                }\n+            }\n+\n+            @Override\n+            public void keyReleased(KeyEvent evt) {\n+                printKey(evt);\n+            }\n+\n+            private void printKey(KeyEvent evt) {\n+                switch(evt.getID()) {\n+                    case KeyEvent.KEY_TYPED:\n+                    case KeyEvent.KEY_PRESSED:\n+                    case KeyEvent.KEY_RELEASED:\n+                        break;\n+                    default:\n+                        System.out.println(\"Other Event\");\n+                        return;\n+                }\n+\n+                System.out.println(\"params= \" + evt.paramString() + \"  \\n\" +\n+                        \"KeyChar: \" + evt.getKeyChar() + \" = \" + (int) evt.getKeyChar() +\n+                        \"   KeyCode: \" + evt.getKeyCode() +\n+                        \"   Modifiers: \" + evt.getModifiersEx());\n+\n+                if (evt.isActionKey()) {\n+                    System.out.println(\"Action Key\");\n+                }\n+\n+                System.out.println(\"keyText= \" + KeyEvent.getKeyText(evt.getKeyCode()) + \"\\n\");\n+            }\n+        });\n+    }\n+\n+    private static void testDeleteKeyEvent() {\n+        if (deleteKeyTypedReceived) {\n+            if (tf.getText().equals(SUCCESS)) {\n+                System.out.println(\"Test PASSED\");\n+            } else {\n+                System.out.println(\"Test FAILED: wrong string\");\n+                throw new RuntimeException(\"The test failed: wrong string:  \" +\n+                        tf.getText());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/KeyTyped\/DeleteKeyTyped.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4734408\n+ * @summary Tests that KeyTyped events are fired for the Escape key\n+ *          and that no extraneous characters are entered as a result.\n+ *\/\n+\n+public class EscapeKeyTyped {\n+    private static Frame frame;\n+    private static TextField tf;\n+\n+    private static final String ORIGINAL = \"0123456789\";\n+    private static boolean escapeKeyTypedReceived = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(30);\n+\n+            EventQueue.invokeAndWait(EscapeKeyTyped::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            \/\/ Press and release Escape\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n+            robot.delay(20);\n+\n+            EventQueue.invokeAndWait(EscapeKeyTyped::testEscKeyEvent);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new Frame();\n+        tf = new TextField(ORIGINAL, 20);\n+        frame.add(tf);\n+        frame.setSize(300, 100);\n+        frame.setVisible(true);\n+        tf.requestFocusInWindow();\n+\n+        tf.addKeyListener(new KeyListener() {\n+            @Override\n+            public void keyTyped(KeyEvent e) {\n+                printKey(e);\n+            }\n+\n+            @Override\n+            public void keyPressed(KeyEvent e) {\n+                printKey(e);\n+                int keychar = e.getKeyChar();\n+                if (keychar == 27) { \/\/ Escape character is 27 or \\u0021\n+                    escapeKeyTypedReceived = true;\n+                }\n+            }\n+\n+            @Override\n+            public void keyReleased(KeyEvent e) {\n+                printKey(e);\n+            }\n+\n+            private void printKey(KeyEvent evt) {\n+                switch (evt.getID()) {\n+                    case KeyEvent.KEY_TYPED:\n+                    case KeyEvent.KEY_PRESSED:\n+                    case KeyEvent.KEY_RELEASED:\n+                        break;\n+                    default:\n+                        System.out.println(\"Other Event\");\n+                        return;\n+                }\n+\n+                System.out.println(\"params= \" + evt.paramString() + \"  \\n\" +\n+                        \"KeyChar: \" + evt.getKeyChar() + \" = \" + (int) evt.getKeyChar() +\n+                        \"   KeyCode: \" + evt.getKeyCode() +\n+                        \"   Modifiers: \" + evt.getModifiersEx());\n+\n+                if (evt.isActionKey()) {\n+                    System.out.println(\"Action Key\");\n+                }\n+\n+                System.out.println(\"keyText= \" + KeyEvent.getKeyText(evt.getKeyCode()) + \"\\n\");\n+            }\n+        });\n+    }\n+\n+    private static void testEscKeyEvent() {\n+        if (escapeKeyTypedReceived) {\n+            if (tf.getText().equals(ORIGINAL)) {\n+                System.out.println(\"Test PASSED\");\n+            } else {\n+                System.out.println(\"Test FAILED: wrong string\");\n+                throw new RuntimeException(\"The test failed: wrong string:  \" +\n+                        tf.getText());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/KeyTyped\/EscapeKeyTyped.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4965227\n+ * @requires (os.family == \"linux\")\n+ * @summary tests that Shift+F10 during Window show doesn't cause deadlock- Linux only\n+ *\/\n+\n+public class ShiftF10Test {\n+    private static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(10);\n+\n+            EventQueue.invokeLater(() -> {\n+                frame = new Frame(\"Deadlocking one\");\n+                frame.setSize(100, 100);\n+                frame.setVisible(true);\n+            });\n+\n+            for (int i = 0; i < 250; i++) {\n+                robot.keyPress(KeyEvent.VK_SHIFT);\n+                robot.keyPress(KeyEvent.VK_F10);\n+                robot.keyRelease(KeyEvent.VK_F10);\n+                robot.keyRelease(KeyEvent.VK_SHIFT);\n+                robot.delay(10);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Test Failed due to following error: \", e);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/ShiftF10Test.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.event.ContainerAdapter;\n+import java.awt.event.ContainerEvent;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4028904\n+ * @summary Tests whether System.out.println(ContainerEvent e)\n+ *          yields incorrect display or not.\n+ *\/\n+\n+public class ContainerEventChildTest {\n+    private static Frame frame;\n+    private static String com1, com2;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame();\n+                Panel outerPanel = new Panel();\n+                Panel innerPanel = new Panel();\n+                Button b = new Button(\"Panel Button\");\n+\n+                innerPanel.addContainerListener(new ContainerAdapter() {\n+                    public void componentAdded(ContainerEvent e) {\n+                        String str1 = e.toString();\n+                        String str2 = (e.getChild()).toString();\n+\n+                        \/\/ extracting child values from ContainerEvent i.e., \"e\" and \"e.getChild()\"\n+                        com1 = str1.substring(str1.indexOf(\"child\") + 6, str1.indexOf(\"]\"));\n+                        com2 = str2.substring(str2.indexOf(\"[\") + 1, str2.indexOf(\",\"));\n+\n+                        System.out.println(\"e : \" + com1);\n+                        System.out.println(\"e.getChild() : \" + com2);\n+\n+                        \/\/ comparing the child values between \"e\" and \"e.getChild()\"\n+                        \/\/ if child value of \"e\" equals null and child values between\n+                        \/\/ \"e\" and \"e.getChild()\" are not equal then throws exception\n+                        if (com1.equals(\"null\") && !(com1.equals(com2))) {\n+                            System.out.println(\"unequal\");\n+                            throw new RuntimeException(\"Test Failed e.toString returns false value\");\n+                        } else {\n+                            System.out.println(\"Test Passed - e and e.getChild() are same\");\n+                        }\n+                    }\n+                });\n+                innerPanel.add(b);\n+                outerPanel.add(innerPanel);\n+                frame.add(outerPanel);\n+                frame.setVisible(true);\n+            });\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/OtherEvents\/ContainerEventChildTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.IllegalComponentStateException;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.event.TextEvent;\n+import java.awt.event.TextListener;\n+\n+\/*\n+ * @test\n+ * @bug 4503516\n+ * @key headful\n+ * @summary TextEvent behaves differently across platforms, especially Solaris.\n+ *          Following testcase is used to test whether an initial TextEvent\n+ *          is triggered when a TextArea or TextField is initially added to UI.\n+ *\/\n+\n+public class InitialTextEventTest implements TextListener {\n+    private static Frame frame;\n+    private static TextField textField;\n+    private static TextArea textArea;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+\n+            InitialTextEventTest textEventObj = new InitialTextEventTest();\n+            EventQueue.invokeAndWait(textEventObj::createUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(textEventObj::testInitialTextEvent);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private void createUI() {\n+        frame = new Frame();\n+        frame.setTitle(\"Text Event Test\");\n+        frame.setLayout(new FlowLayout());\n+\n+        textField = new TextField(\"TextField\");\n+        textArea = new TextArea(\"TextArea\", 5, 10);\n+\n+        textField.addTextListener(this);\n+        textArea.addTextListener(this);\n+\n+        frame.add(textField);\n+        frame.add(textArea);\n+\n+        frame.setBackground(Color.red);\n+        frame.setSize(500,200);\n+        frame.setVisible(true);\n+    }\n+\n+    private void testInitialTextEvent() {\n+        Point pt;\n+        boolean drawn = false;\n+        while (!drawn) {\n+            try {\n+                pt = textArea.getLocationOnScreen();\n+                System.out.println(\"On-Screen Location on Text Area: \" + pt);\n+                pt = textField.getLocationOnScreen();\n+                System.out.println(\"On-Screen Location on Text Field: \" + pt);\n+            } catch (IllegalComponentStateException icse) {\n+                try {\n+                    Thread.sleep(50);\n+                } catch (InterruptedException ignored) {}\n+                continue;\n+            }\n+            drawn = true;\n+        }\n+    }\n+\n+    @Override\n+    public void textValueChanged(TextEvent e) {\n+        System.out.println(\"text event paramString: \" + e.paramString());\n+        System.out.println(\"text event changed on: \" + e.getSource().getClass().getName());\n+        throw new RuntimeException(\"InitialTextEventTest FAILED\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/event\/TextEvent\/InitialTextEventTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright 2023, Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n","filename":"test\/jdk\/java\/lang\/Thread\/IsAlive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class AnnotationTestInput {\n+\n+    enum Mood {\n+        HAPPY,\n+        SAD,\n+        CONFUSED;\n+    }\n+\n+    private class PrivateClass {}\n+\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                         Character.MIN_VALUE, Character.MAX_VALUE,\n+                         '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                           Double.MIN_VALUE, Double.MAX_VALUE,\n+                           Double.NaN,\n+                           Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                          Float.MIN_VALUE, Float.MAX_VALUE,\n+                          Float.NaN,\n+                          Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested1\"),\n+            nestedArray = {@NestedAnno(\"nested2\"), @NestedAnno(\"nested3\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested4\"),\n+            nestedArray = {@NestedAnno(\"nested5\"), @NestedAnno(\"nested6\")})\n+    @SingleWithDefaults\n+    @Deprecated\n+    @SuppressWarnings(\"unchecked\")\n+    public void annotatedMethod() {\n+    }\n+\n+    @Named(\"Super1\")\n+    public static class Super1 {}\n+    @Named(\"Super2\")\n+    public static class Super2 extends Super1 {}\n+    public static class Super3 extends Super1 {}\n+\n+    @Named(\"NonInheritedValue\")\n+    public static class OwnName extends Super1 {}\n+\n+    public static class InheritedName1 extends Super1 {}\n+    public static class InheritedName2 extends Super2 {}\n+    public static class InheritedName3 extends Super3 {}\n+\n+    @Named(\"AnnotatedClass\")\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                    Character.MIN_VALUE, Character.MAX_VALUE,\n+                    '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                    Double.MIN_VALUE, Double.MAX_VALUE,\n+                    Double.NaN,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                    Float.MIN_VALUE, Float.MAX_VALUE,\n+                    Float.NaN,\n+                    Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested7\"),\n+            nestedArray = {@NestedAnno(\"nested8\"), @NestedAnno(\"nested9\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested10\"),\n+            nestedArray = {@NestedAnno(\"nested11\"), @NestedAnno(\"nested12\")})\n+    @Deprecated\n+    @SuppressWarnings({\"rawtypes\", \"all\"})\n+    public static class AnnotatedClass {}\n+\n+    @Single(string = \"a\",\n+            stringArray = {\"a\", \"b\"},\n+            classValue = String.class,\n+            classArray = {String.class, Exception.class},\n+            byteValue = 1,\n+            byteArray = {1, 2, Byte.MIN_VALUE, Byte.MAX_VALUE},\n+            charValue = 'a',\n+            charArray = {'a', 'b',\n+                    Character.MIN_VALUE, Character.MAX_VALUE,\n+                    '\\b', '\\f', '\\n', '\\r', '\\t', '\\\\', '\\'', '\\\"', '\\u012A'},\n+            doubleValue = 3.3D,\n+            doubleArray = {3.3D, 4.4D,\n+                    Double.MIN_VALUE, Double.MAX_VALUE,\n+                    Double.NaN,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY},\n+            floatValue = 4.4F,\n+            floatArray = {4.4F, 5.5F,\n+                    Float.MIN_VALUE, Float.MAX_VALUE,\n+                    Float.NaN,\n+                    Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY},\n+            intValue = 5,\n+            intArray = {5, 6, Integer.MIN_VALUE, Integer.MAX_VALUE},\n+            longValue = 6L,\n+            longArray = {6L, 7L, Long.MIN_VALUE, Long.MAX_VALUE},\n+            shortValue = 7,\n+            shortArray = {7, 8, Short.MIN_VALUE, Short.MAX_VALUE},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.SAD,\n+            moodArray = {Mood.CONFUSED, Mood.HAPPY},\n+            nested = @NestedAnno(\"nested12\"),\n+            nestedArray = {@NestedAnno(\"nested13\"), @NestedAnno(\"nested14\")})\n+    @Single(string = \"A\",\n+            stringArray = {\"A\", \"B\"},\n+            classValue = Thread.class,\n+            classArray = {Thread.class, PrivateClass.class},\n+            byteValue = -1,\n+            byteArray = {-1, -2},\n+            charValue = 'A',\n+            charArray = {'a', 'b'},\n+            doubleValue = -3.3D,\n+            doubleArray = {3.3D, 4.4D},\n+            floatValue = -4.4F,\n+            floatArray = {4.4F, 5.5F},\n+            intValue = -5,\n+            intArray = {5, 6},\n+            longValue = -6L,\n+            longArray = {6L, 7L},\n+            shortValue = -7,\n+            shortArray = {7, 8},\n+            booleanValue = true,\n+            booleanArray = {true, false},\n+            mood = Mood.CONFUSED,\n+            moodArray = {Mood.SAD, Mood.CONFUSED},\n+            nested = @NestedAnno(\"nested15\"),\n+            nestedArray = {@NestedAnno(\"nested16\"), @NestedAnno(\"nested17\")})\n+    private static final int annotatedField = 45;\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NestedAnno {\n+        String value();\n+    }\n+\n+    @Inherited\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Named {\n+        String value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Repeatable(SingleList.class)\n+    public @interface Single {\n+        Class<?> classValue();\n+        Class<?>[] classArray();\n+\n+        String string();\n+        String[] stringArray();\n+\n+        byte byteValue();\n+        byte[] byteArray();\n+\n+        char charValue();\n+        char[] charArray();\n+\n+        double doubleValue();\n+        double[] doubleArray();\n+\n+        float floatValue();\n+        float[] floatArray();\n+\n+        int intValue();\n+        int[] intArray();\n+\n+        long longValue();\n+        long[] longArray();\n+\n+        short shortValue();\n+        short[] shortArray();\n+\n+        boolean booleanValue();\n+        boolean[] booleanArray();\n+\n+        Mood mood();\n+        Mood[] moodArray();\n+\n+        NestedAnno nested();\n+        NestedAnno[] nestedArray();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface SingleWithDefaults {\n+        Class<?> classValue() default SingleWithDefaults.class;\n+        Class<?>[] classArray() default {};\n+\n+        String string() default \"anonymous\";\n+        String[] stringArray() default {};\n+\n+        byte byteValue() default 101;\n+        byte[] byteArray() default {};\n+\n+        char charValue() default 'Z';\n+        char[] charArray() default {};\n+\n+        double doubleValue() default 102.102D;\n+        double[] doubleArray() default {};\n+\n+        float floatValue() default 103.103F;\n+        float[] floatArray() default {};\n+\n+        int intValue() default 104;\n+        int[] intArray() default {};\n+\n+        long longValue() default 105L;\n+        long[] longArray() default {};\n+\n+        short shortValue() default 105;\n+        short[] shortArray() default {};\n+\n+        boolean booleanValue() default true;\n+        boolean[] booleanArray() default {};\n+\n+        Mood mood() default Mood.HAPPY;\n+        Mood[] moodArray() default {};\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface SingleList {\n+        Single[] value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Missing {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MissingWrapper {\n+        Missing value();\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MissingContainer {\n+        Class<?> value();\n+    }\n+\n+    \/**\n+     * Method with a directly missing annotation.\n+     *\/\n+    @Missing\n+    public void missingAnnotation() {}\n+\n+    \/**\n+     * Method with an indirectly missing nested annotation.\n+     *\/\n+    @MissingWrapper(@Missing)\n+    public void missingNestedAnnotation() {}\n+\n+    \/**\n+     * Method with an annotation that has a Class member\n+     * that cannot be resolved.\n+     *\/\n+    @MissingContainer(Missing.class)\n+    public void missingTypeOfClassMember() {}\n+\n+    \/**\n+     * Method with an annotation that has a member\n+     * that is deleted in a newer version of the annotation.\n+     *\/\n+    @MemberDeleted(value = \"evolving\", retained = -34, deleted = 56)\n+    public void missingMember() {}\n+\n+    \/**\n+     * Method with an annotation that has a member named \"any\"\n+     * whose type is changed from int to String in a newer version\n+     * of the annotation.\n+     *\/\n+    @MemberTypeChanged(value = \"evolving\", retained = -34, any = 56)\n+    public void changeTypeOfMember() {}\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/AnnotationTestInput.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberDeleted {\n+    String value();\n+    int retained();\n+    int deleted();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberDeleted.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberTypeChanged {\n+    String value();\n+    int retained();\n+    int any();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/MemberTypeChanged.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @compile AnnotationTestInput.java MemberDeleted.java MemberTypeChanged.java\n+ * @modules java.base\/jdk.internal.vm\n+ *          java.base\/sun.reflect.annotation\n+ * @clean jdk.internal.vm.test.AnnotationTestInput$Missing\n+ * @compile alt\/MemberDeleted.java alt\/MemberTypeChanged.java\n+ * @run testng\/othervm\n+ *      jdk.internal.vm.test.TestAnnotationEncodingDecoding\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.util.LinkedHashMap;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import sun.reflect.annotation.AnnotationSupport;\n+import sun.reflect.annotation.AnnotationParser;\n+import sun.reflect.annotation.ExceptionProxy;\n+\n+import jdk.internal.vm.VMSupport;\n+import jdk.internal.vm.VMSupport.AnnotationDecoder;\n+\n+public class TestAnnotationEncodingDecoding {\n+\n+    @Test\n+    public void encodeDecodeTest() throws Exception {\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredField(\"annotatedField\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"annotatedMethod\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.AnnotatedClass.class);\n+\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingAnnotation\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingNestedAnnotation\"), true);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingTypeOfClassMember\"), false);\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"missingMember\"));\n+        checkDecodedEqualsEncoded(AnnotationTestInput.class.getDeclaredMethod(\"changeTypeOfMember\"), false);\n+    }\n+\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated) {\n+        checkDecodedEqualsEncoded(annotated, false);\n+    }\n+\n+    private void checkDecodedEqualsEncoded(AnnotatedElement annotated, boolean expectNCDFE) {\n+        Annotation[] annotations = getAnnotations(annotated, expectNCDFE);\n+        if (annotations == null) {\n+            return;\n+        }\n+\n+        byte[] encoded = VMSupport.encodeAnnotations(List.of(annotations));\n+        MyDecoder decoder = new MyDecoder();\n+        List<AnnotationConst> decoded = VMSupport.decodeAnnotations(encoded, decoder);\n+        int i = 0;\n+        for (AnnotationConst actual : decoded) {\n+            AnnotationConst expect = new AnnotationConst(annotations[i]);\n+            checkEquals(actual, expect);\n+            checkEquals(actual.toString(), expect.toString());\n+            i++;\n+        }\n+    }\n+\n+    private static Annotation[] getAnnotations(AnnotatedElement annotated, boolean expectNCDFE) throws AssertionError {\n+        try {\n+            Annotation[] annotations = annotated.getAnnotations();\n+            Assert.assertFalse(expectNCDFE, annotated.toString());\n+            return annotations;\n+        } catch (NoClassDefFoundError e) {\n+            if (!expectNCDFE) {\n+                throw new AssertionError(annotated.toString(), e);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static void checkEquals(Object actual, Object expect) {\n+        if (!actual.equals(expect)) {\n+            throw new AssertionError(String.format(\"actual != expect%nactual: %s%n%nexpect: %s\", actual, expect));\n+        }\n+    }\n+\n+    public static final class AnnotationConst {\n+        final Class<?> type;\n+        final Map<String, Object> elements;\n+\n+        AnnotationConst(Class<?> type, Map.Entry<String, Object>[] elements) {\n+            this.type = type;\n+            this.elements = Map.ofEntries(elements);\n+        }\n+\n+        AnnotationConst(Annotation a) {\n+            Map<String, Object> values = AnnotationSupport.memberValues(a);\n+            this.type = a.annotationType();\n+            Map.Entry[] elements = new Map.Entry[values.size()];\n+            int i = 0;\n+            for (Map.Entry<String, Object> e : values.entrySet()) {\n+                elements[i++] = Map.entry(e.getKey(), decodeValue(e.getValue()));\n+            }\n+            this.elements = Map.ofEntries(elements);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof AnnotationConst) {\n+                AnnotationConst that = (AnnotationConst) obj;\n+                return this.type.equals(that.type) &&\n+                        this.elements.equals(that.elements);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"@\" + type.getName() + \"(\" + elements + \")\";\n+        }\n+\n+        private Object decodeValue(Object value) {\n+            Class<?> valueType = value.getClass();\n+            if (value instanceof Enum) {\n+                return new EnumConst(valueType, ((Enum<?>) value).name());\n+            } else if (value instanceof Annotation) {\n+                return new AnnotationConst((Annotation) value);\n+            } else if (valueType.isArray()) {\n+                int len = Array.getLength(value);\n+                Object[] arr = new Object[len];\n+                for (int i = 0; i < len; i++) {\n+                    arr[i] = decodeValue(Array.get(value, i));\n+                }\n+                return List.of(arr);\n+            } else if (value instanceof ExceptionProxy) {\n+                return new ErrorConst(value.toString());\n+            } else {\n+                return value;\n+            }\n+        }\n+\n+        public Class<?> getType() {\n+            return type;\n+        }\n+    }\n+\n+    public static final class ErrorConst {\n+        final String desc;\n+        public ErrorConst(String desc) {\n+            this.desc = Objects.requireNonNull(desc);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return desc;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return desc.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof ErrorConst) {\n+                return ((ErrorConst) obj).desc.equals(desc);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static final class EnumConst {\n+        final Class<?> type;\n+        final String name;\n+\n+        public EnumConst(Class<?> type, String name) {\n+            this.type = type;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof EnumConst) {\n+                EnumConst that = (EnumConst) obj;\n+                return this.type.equals(that.type) &&\n+                        this.name.equals(that.name);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type.getName() + \".\" + name;\n+        }\n+\n+        public Class<?> getEnumType() {\n+            return type;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }\n+\n+    static class MyDecoder implements AnnotationDecoder<Class<?>, AnnotationConst, EnumConst, ErrorConst> {\n+        @Override\n+        public Class<?> resolveType(String name) {\n+            try {\n+                return Class.forName(name);\n+            } catch (ClassNotFoundException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public AnnotationConst newAnnotation(Class<?> type, Map.Entry<String, Object>[] elements) {\n+            return new AnnotationConst(type, elements);\n+        }\n+\n+        @Override\n+        public EnumConst newEnumValue(Class<?> enumType, String name) {\n+            return new EnumConst(enumType, name);\n+        }\n+\n+        @Override\n+        public ErrorConst newErrorValue(String description) {\n+            return new ErrorConst(description);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/TestAnnotationEncodingDecoding.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberDeleted {\n+    String value();\n+    int retained();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberDeleted.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.test;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface MemberTypeChanged {\n+    String value();\n+    int retained();\n+    String any();\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/AnnotationEncodingDecoding\/alt\/MemberTypeChanged.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -61,9 +61,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void encodeDecodeTest2() throws Exception {\n-        Throwable throwable = new ExceptionInInitializerError(new InvocationTargetException(new Untranslatable(\"test exception\", new NullPointerException()), \"invoke\"));\n-        for (int i = 0; i < 10; i++) {\n-            throwable = new ExceptionInInitializerError(new InvocationTargetException(new RuntimeException(String.valueOf(i), throwable), \"invoke\"));\n-        }\n-        encodeDecode(throwable);\n-    }\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * @test\n+ * @bug 8305945\n+ * @summary Validate that Zip FS provides the correct exception message when an\n+ * attempt is made to obtain an InputStream from a directory entry\n+ * @modules jdk.zipfs\n+ * @run junit ZipFSDirectoryExceptionMessageTest\n+ *\/\n+public class ZipFSDirectoryExceptionMessageTest {\n+    \/**\n+     * Name of Directory created within the Zip file\n+     *\/\n+    public static final String DIRECTORY_NAME = \"folder\/\";\n+    \/**\n+     * The expected error message\n+     *\/\n+    public static final String DIR_EXCEPTION_MESSAGE = \"\/folder: is a directory\";\n+    \/**\n+     * Zip file to create\n+     *\/\n+    public static final Path ZIP_FILE = Path.of(\"directoryExceptionTest.zip\");\n+\n+    \/**\n+     * Create a Zip file which contains a single directory entry\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        var ze = new ZipEntry(DIRECTORY_NAME);\n+        ze.setMethod(ZipEntry.STORED);\n+        ze.setCompressedSize(0);\n+        ze.setSize(0);\n+        ze.setCrc(0);\n+        try (ZipOutputStream zos = new ZipOutputStream(\n+                Files.newOutputStream(ZIP_FILE))) {\n+            zos.putNextEntry(ze);\n+        }\n+    }\n+\n+    \/**\n+     * Delete the Zip file used by the test\n+     * @throws IOException If an error occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n+\n+    \/**\n+     * Validate that Zip FS returns the correct Exception message when\n+     * attempting to obtain an InputStream from a path representing a directory\n+     * and the FileSystemException::getOtherfile returns null\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void testException() throws IOException {\n+        try (FileSystem zipfs = FileSystems.newFileSystem(ZIP_FILE)) {\n+            var file = zipfs.getPath(DIRECTORY_NAME);\n+            var x = assertThrows(FileSystemException.class, () -> Files.newInputStream(file));\n+            \/\/ validate that other file should be null\n+            assertNull(x.getOtherFile());\n+            assertEquals(DIR_EXCEPTION_MESSAGE, x.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSDirectoryExceptionMessageTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}