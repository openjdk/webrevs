{"files":[{"patch":"@@ -2309,1 +2309,1 @@\n-  return EnableVectorSupport && UseVectorStubs;\n+  return EnableVectorSupport;\n@@ -2313,1 +2313,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9772,73 +9772,0 @@\n-  void generate_vector_math_stubs() {\n-    \/\/ Get native vector math stub routine addresses\n-    void* libsleef = nullptr;\n-    char ebuf[1024];\n-    char dll_name[JVM_MAXPATHLEN];\n-    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n-      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-    }\n-    if (libsleef == nullptr) {\n-      log_info(library)(\"Failed to load native vector math library, %s!\", ebuf);\n-      return;\n-    }\n-    \/\/ Method naming convention\n-    \/\/   All the methods are named as <OP><T><N>_<U><suffix>\n-    \/\/   Where:\n-    \/\/     <OP>     is the operation name, e.g. sin\n-    \/\/     <T>      is optional to indicate float\/double\n-    \/\/              \"f\/d\" for vector float\/double operation\n-    \/\/     <N>      is the number of elements in the vector\n-    \/\/              \"2\/4\" for neon, and \"x\" for sve\n-    \/\/     <U>      is the precision level\n-    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n-    \/\/               We use \"u10\" for all operations by default\n-    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n-    \/\/     <suffix> indicates neon\/sve\n-    \/\/              \"sve\/advsimd\" for sve\/neon implementations\n-    \/\/     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n-    \/\/          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n-    \/\/\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n-\n-    \/\/ Math vector stubs implemented with SVE for scalable vector size.\n-    if (UseSVE > 0) {\n-      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-        \/\/ Skip \"tanh\" because there is performance regression\n-        if (vop == VectorSupport::VECTOR_OP_TANH) {\n-          continue;\n-        }\n-\n-        \/\/ The native library does not support u10 level of \"hypot\".\n-        const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-        snprintf(ebuf, sizeof(ebuf), \"%sfx_%ssve\", VectorSupport::mathname[op], ulf);\n-        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-        snprintf(ebuf, sizeof(ebuf), \"%sdx_%ssve\", VectorSupport::mathname[op], ulf);\n-        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-      }\n-    }\n-\n-    \/\/ Math vector stubs implemented with NEON for 64\/128 bits vector size.\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      \/\/ Skip \"tanh\" because there is performance regression\n-      if (vop == VectorSupport::VECTOR_OP_TANH) {\n-        continue;\n-      }\n-\n-      \/\/ The native library does not support u10 level of \"hypot\".\n-      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sd2_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n-    }\n-  }\n-\n@@ -9998,2 +9925,0 @@\n-    generate_vector_math_stubs();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -631,0 +631,1 @@\n+  size_t features_offset = strnlen(buf, sizeof(buf));\n@@ -638,1 +639,5 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = extract_features_string(_cpu_info_string,\n+                                             strnlen(_cpu_info_string, sizeof(buf)),\n+                                             features_offset);\n@@ -705,1 +710,1 @@\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _features_string);\n+  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n@@ -366,1 +366,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n@@ -522,1 +522,1 @@\n-  tty->print_cr(\"Version: %s L1_data_cache_line_size=%d\", features_string(), L1_data_cache_line_size());\n+  tty->print_cr(\"Version: %s L1_data_cache_line_size=%d\", cpu_info_string(), L1_data_cache_line_size());\n@@ -729,1 +729,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", features_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1947,1 +1947,1 @@\n-  return EnableVectorSupport && UseVectorStubs;\n+  return EnableVectorSupport;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6461,52 +6461,0 @@\n-  void generate_vector_math_stubs() {\n-    if (!UseRVV) {\n-      log_info(library)(\"vector is not supported, skip loading vector math (sleef) library!\");\n-      return;\n-    }\n-\n-    \/\/ Get native vector math stub routine addresses\n-    void* libsleef = nullptr;\n-    char ebuf[1024];\n-    char dll_name[JVM_MAXPATHLEN];\n-    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n-      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-    }\n-    if (libsleef == nullptr) {\n-      log_info(library)(\"Failed to load native vector math (sleef) library, %s!\", ebuf);\n-      return;\n-    }\n-\n-    \/\/ Method naming convention\n-    \/\/   All the methods are named as <OP><T>_<U><suffix>\n-    \/\/\n-    \/\/   Where:\n-    \/\/     <OP>     is the operation name, e.g. sin, cos\n-    \/\/     <T>      is to indicate float\/double\n-    \/\/              \"fx\/dx\" for vector float\/double operation\n-    \/\/     <U>      is the precision level\n-    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n-    \/\/               We use \"u10\" for all operations by default\n-    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n-    \/\/     <suffix> rvv, indicates riscv vector extension\n-    \/\/\n-    \/\/   e.g. sinfx_u10rvv is the method for computing vector float sin using rvv instructions\n-    \/\/\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n-\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      if (vop == VectorSupport::VECTOR_OP_TANH) { \/\/ skip tanh because of performance regression\n-        continue;\n-      }\n-\n-      \/\/ The native library does not support u10 level of \"hypot\".\n-      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sfx_%srvv\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sdx_%srvv\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-    }\n-  }\n-\n@@ -6744,2 +6692,0 @@\n-    generate_vector_math_stubs();\n-\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", features_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  set_features_string();     \/\/ Set a descriptive feature indication.\n+  set_cpu_info_string();     \/\/ Set a descriptive feature indication.\n@@ -391,3 +391,3 @@\n-void VM_Version::set_features_string() {\n-  \/\/ A note on the _features_string format:\n-  \/\/   There are jtreg tests checking the _features_string for various properties.\n+void VM_Version::set_cpu_info_string() {\n+  \/\/ A note on the _cpu_info_string format:\n+  \/\/   There are jtreg tests checking the _cpu_info_string for various properties.\n@@ -415,1 +415,1 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n@@ -418,1 +418,1 @@\n-    assert(strlen(_features_string) + 3*8 < sizeof(buf), \"increase buffer size\");\n+    assert(strlen(_cpu_info_string) + 3*8 < sizeof(buf), \"increase buffer size\");\n@@ -420,1 +420,1 @@\n-                 _features_string,\n+                 _cpu_info_string,\n@@ -424,2 +424,2 @@\n-    os::free((void *)_features_string);\n-    _features_string = os::strdup(buf);\n+    os::free((void *)_cpu_info_string);\n+    _cpu_info_string = os::strdup(buf);\n@@ -429,1 +429,1 @@\n-    assert(strlen(_features_string) + 6 + 2*8 + 7 < sizeof(buf), \"increase buffer size\");\n+    assert(strlen(_cpu_info_string) + 6 + 2*8 + 7 < sizeof(buf), \"increase buffer size\");\n@@ -431,1 +431,1 @@\n-                 _features_string,\n+                 _cpu_info_string,\n@@ -436,2 +436,2 @@\n-    os::free((void *)_features_string);\n-    _features_string = os::strdup(buf);\n+    os::free((void *)_cpu_info_string);\n+    _cpu_info_string = os::strdup(buf);\n@@ -467,1 +467,1 @@\n-  tty->print_cr(\"%s %s\", text, features_string());\n+  tty->print_cr(\"%s %s\", text, cpu_info_string());\n@@ -909,1 +909,1 @@\n-      set_features_string();\n+      set_cpu_info_string();\n@@ -1545,1 +1545,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", features_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  static void set_features_string();\n+  static void set_cpu_info_string();\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4336,64 +4336,0 @@\n-  \/\/ Get svml stub routine addresses\n-  void *libjsvml = nullptr;\n-  char ebuf[1024];\n-  char dll_name[JVM_MAXPATHLEN];\n-  if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"jsvml\")) {\n-    libjsvml = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-  }\n-  if (libjsvml != nullptr) {\n-    \/\/ SVML method naming convention\n-    \/\/   All the methods are named as __jsvml_op<T><N>_ha_<VV>\n-    \/\/   Where:\n-    \/\/      ha stands for high accuracy\n-    \/\/      <T> is optional to indicate float\/double\n-    \/\/              Set to f for vector float operation\n-    \/\/              Omitted for vector double operation\n-    \/\/      <N> is the number of elements in the vector\n-    \/\/              1, 2, 4, 8, 16\n-    \/\/              e.g. 128 bit float vector has 4 float elements\n-    \/\/      <VV> indicates the avx\/sse level:\n-    \/\/              z0 is AVX512, l9 is AVX2, e9 is AVX1 and ex is for SSE2\n-    \/\/      e.g. __jsvml_expf16_ha_z0 is the method for computing 16 element vector float exp using AVX 512 insns\n-    \/\/           __jsvml_exp8_ha_z0 is the method for computing 8 element vector double exp using AVX 512 insns\n-\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"jsvml\" JNI_LIB_SUFFIX, p2i(libjsvml));\n-    if (UseAVX > 2) {\n-      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-        if ((!VM_Version::supports_avx512dq()) &&\n-            (vop == VectorSupport::VECTOR_OP_LOG || vop == VectorSupport::VECTOR_OP_LOG10 || vop == VectorSupport::VECTOR_OP_POW)) {\n-          continue;\n-        }\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n-        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n-        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-      }\n-    }\n-    const char* avx_sse_str = (UseAVX >= 2) ? \"l9\" : ((UseAVX == 1) ? \"e9\" : \"ex\");\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      if (vop == VectorSupport::VECTOR_OP_POW) {\n-        continue;\n-      }\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-  int res = jio_snprintf(\n+  int cpu_info_size = jio_snprintf(\n@@ -1098,2 +1098,2 @@\n-  assert(res > 0, \"not enough temporary space allocated\");\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size, _features_names);\n@@ -1101,1 +1101,5 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = extract_features_string(_cpu_info_string,\n+                                             strnlen(_cpu_info_string, sizeof(buf)),\n+                                             cpu_info_size);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1587,4 +1587,1 @@\n-  if (EnableVectorSupport && UseVectorStubs) {\n-    return true;\n-  }\n-  return false;\n+  return EnableVectorSupport;\n@@ -1594,1 +1591,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+\n+  int features_offset = strnlen(buf, sizeof(buf));\n+\n@@ -194,1 +197,5 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = extract_features_string(_cpu_info_string,\n+                                             strnlen(_cpu_info_string, sizeof(buf)),\n+                                             features_offset);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -141,0 +141,6 @@\n+\n+char* ciInstance::java_lang_String_str(char* buf, size_t buflen) {\n+  VM_ENTRY_MARK;\n+  assert(get_oop()->is_a(vmClasses::String_klass()), \"not a String\");\n+  return java_lang_String::as_utf8_string(get_oop(), buf, buflen);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  char* java_lang_String_str(char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -469,3 +469,0 @@\n-    if (EnableVectorSupport && FLAG_IS_DEFAULT(UseVectorStubs)) {\n-      FLAG_SET_DEFAULT(UseVectorStubs, true);\n-    }\n@@ -475,1 +472,0 @@\n-    log_info(compilation)(\"UseVectorStubs=%s\",                 (UseVectorStubs                 ? \"true\" : \"false\"));\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -983,1 +983,2 @@\n-                                      \"Ljava\/lang\/Class;Ljava\/lang\/Class;\"                                                                     \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n@@ -1004,0 +1005,23 @@\n+  do_intrinsic(_VectorUnaryLibOp, jdk_internal_vm_vector_VectorSupport, vector_unary_lib_op_name, vector_unary_lib_op_sig, F_S)                \\\n+   do_signature(vector_unary_lib_op_sig,\"(J\"                                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"I\"                                                                                                   \\\n+                                         \"Ljava\/lang\/String;\"                                                                                  \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                       \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$UnaryOperation;)\"                                              \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                      \\\n+   do_name(vector_unary_lib_op_name, \"libraryUnaryOp\")                                                                                         \\\n+                                                                                                                                               \\\n+  do_intrinsic(_VectorBinaryLibOp, jdk_internal_vm_vector_VectorSupport, vector_binary_lib_op_name, vector_binary_lib_op_sig, F_S)             \\\n+   do_signature(vector_binary_lib_op_sig,\"(J\"                                                                                                  \\\n+                                          \"Ljava\/lang\/Class;\"                                                                                  \\\n+                                          \"Ljava\/lang\/Class;\"                                                                                  \\\n+                                          \"I\"                                                                                                  \\\n+                                          \"Ljava\/lang\/String;\"                                                                                 \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                               \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                               \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryOperation;)\"                                            \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\")                                              \\\n+   do_name(vector_binary_lib_op_name, \"libraryBinaryOp\")                                                                                       \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-  JVMCI_FLAG_CHECKED(UseVectorStubs)\n@@ -149,0 +148,2 @@\n+       \/\/\n+  JVMCI_FLAG_CHECKED(UseVectorStubs)\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -187,2 +187,2 @@\n-  NOT_COMPILER2(product(bool, UseVectorStubs, false, EXPERIMENTAL,          \\\n-          \"Use stubs for vector transcendental operations\"))                \\\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -753,3 +753,0 @@\n-  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n-          \"Use stubs for vector transcendental operations\")                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -844,0 +844,3 @@\n+  case vmIntrinsics::_VectorUnaryLibOp:\n+  case vmIntrinsics::_VectorBinaryLibOp:\n+    return EnableVectorSupport && Matcher::supports_vector_calling_convention();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -710,0 +710,4 @@\n+  case vmIntrinsics::_VectorUnaryLibOp:\n+    return inline_vector_call(1);\n+  case vmIntrinsics::_VectorBinaryLibOp:\n+    return inline_vector_call(2);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -365,0 +365,1 @@\n+  bool inline_vector_call(int arity);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -369,2 +369,3 @@\n-  if ((opc != Op_CallLeafVector) && (sopc == 0)) {\n-    log_if_needed(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n+  if (sopc == 0 || num_elem == 1) {\n+    log_if_needed(\"  ** operation not supported: arity=%d opc=%s[%d] vlen=%d etype=%s\",\n+                    n, NodeClassNames[opc], opc, num_elem, type2name(elem_bt));\n@@ -373,7 +374,0 @@\n-  if (num_elem == 1) {\n-    if (opc != Op_CallLeafVector || elem_bt != T_DOUBLE) {\n-      log_if_needed(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n-                      n, opc, num_elem, type2name(elem_bt));\n-      return false;\n-    }\n-  }\n@@ -387,16 +381,0 @@\n-  if (opc == Op_CallLeafVector) {\n-    if (!UseVectorStubs) {\n-      log_if_needed(\"  ** vector stubs support is disabled\");\n-      return false;\n-    }\n-    if (!Matcher::supports_vector_calling_convention()) {\n-      log_if_needed(\"  ** no vector calling conventions supported\");\n-      return false;\n-    }\n-    if (!Matcher::vector_size_supported(elem_bt, num_elem)) {\n-      log_if_needed(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n-                      num_elem, type2name(elem_bt));\n-      return false;\n-    }\n-  }\n-\n@@ -467,23 +445,10 @@\n-  if (opc == Op_CallLeafVector) {\n-    assert(UseVectorStubs, \"sanity\");\n-    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n-    if (operation == nullptr) {\n-      log_if_needed(\"  ** Vector math call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n-                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n-                         num_elem * type2aelembytes(elem_bt));\n-      return false;\n-     }\n-  } else {\n-    const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n-    switch (n) {\n-      case 1:\n-      case 2: {\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned);\n-        break;\n-      }\n-      case 3: {\n-        operation = VectorNode::make(sopc, opd1, opd2, opd3, vt);\n-        break;\n-      }\n-      default: fatal(\"unsupported arity: %d\", n);\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+  switch (n) {\n+    case 1:\n+    case 2: {\n+      operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned);\n+      break;\n+    }\n+    case 3: {\n+      operation = VectorNode::make(sopc, opd1, opd2, opd3, vt);\n+      break;\n@@ -491,0 +456,1 @@\n+    default: fatal(\"unsupported arity: %d\", n);\n@@ -513,0 +479,101 @@\n+\/\/ <V extends Vector<E>, E>\n+\/\/ V libraryUnaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n+\/\/                  V v,\n+\/\/                  UnaryOperation<V, ?> defaultImpl)\n+\/\/\n+\/\/ public static\n+\/\/ <V extends VectorPayload, E>\n+\/\/ V libraryBinaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n+\/\/            V v1, V v2,\n+\/\/            BinaryOperation<V, ?> defaultImpl)\n+bool LibraryCallKit::inline_vector_call(int arity) {\n+  assert(Matcher::supports_vector_calling_convention(), \"required\");\n+\n+  const TypeLong*    entry          = gvn().type(argument(0))->isa_long();\n+  const TypeInstPtr* vector_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass     = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen           = gvn().type(argument(4))->isa_int();\n+  const TypeInstPtr* debug_name_oop = gvn().type(argument(5))->isa_instptr();\n+\n+  if (entry        == nullptr   || !entry->is_con() ||\n+      vector_klass == nullptr   || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr   || elem_klass->const_oop() == nullptr ||\n+      vlen         == nullptr   || !vlen->is_con() ||\n+      debug_name_oop == nullptr || debug_name_oop->const_oop() == nullptr) {\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s debug_name=%s\",\n+                  NodeClassNames[argument(0)->Opcode()],\n+                  NodeClassNames[argument(2)->Opcode()],\n+                  NodeClassNames[argument(3)->Opcode()],\n+                  NodeClassNames[argument(4)->Opcode()],\n+                  NodeClassNames[argument(5)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (entry->get_con() == 0) {\n+    log_if_needed(\"  ** missing entry point\");\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+\n+  BasicType elem_bt = elem_type->basic_type();\n+  int num_elem = vlen->get_con();\n+  if (!Matcher::vector_size_supported(elem_bt, num_elem)) {\n+    log_if_needed(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n+                  num_elem, type2name(elem_bt));\n+    return false;\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  if (opd1 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(6)->Opcode()]);\n+    return false;\n+  }\n+\n+  Node* opd2 = nullptr;\n+  if (arity > 1) {\n+    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    if (opd2 == nullptr) {\n+      log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(7)->Opcode()]);\n+      return false;\n+    }\n+  }\n+  assert(arity == 1 || arity == 2, \"arity %d not supported\", arity);\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(arity, vt, vt);\n+  address entry_addr = (address)entry->get_con();\n+\n+  const char* debug_name = \"<unknown>\";\n+  if (!debug_name_oop->const_oop()->is_null_object()) {\n+    size_t buflen = 100;\n+    char* buf = NEW_ARENA_ARRAY(C->comp_arena(), char, buflen);\n+    debug_name = debug_name_oop->const_oop()->as_instance()->java_lang_String_str(buf, buflen);\n+  }\n+  Node* vcall = make_runtime_call(RC_VECTOR,\n+                                  call_type,\n+                                  entry_addr,\n+                                  debug_name,\n+                                  TypePtr::BOTTOM,\n+                                  opd1,\n+                                  opd2);\n+\n+  vcall = gvn().transform(new ProjNode(gvn().transform(vcall), TypeFunc::Parms));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  Node* vbox = box_vector(vcall, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -1847,44 +1914,0 @@\n-static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n-  address addr = nullptr;\n-  assert(UseVectorStubs, \"sanity\");\n-  assert(name_ptr != nullptr, \"unexpected\");\n-  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n-\n-  switch(bits) {\n-    case 64:  \/\/fallthough\n-    case 128: \/\/fallthough\n-    case 256: \/\/fallthough\n-    case 512:\n-      if (bt == T_FLOAT) {\n-        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_fixed\", VectorSupport::mathname[op], bits);\n-        addr = StubRoutines::_vector_f_math[exact_log2(bits\/64)][op];\n-      } else {\n-        assert(bt == T_DOUBLE, \"must be FP type only\");\n-        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_fixed\", VectorSupport::mathname[op], bits);\n-        addr = StubRoutines::_vector_d_math[exact_log2(bits\/64)][op];\n-      }\n-      break;\n-    default:\n-      if (!Matcher::supports_scalable_vector() || !Matcher::vector_size_supported(bt, bits\/type2aelembytes(bt)) ) {\n-        snprintf(name_ptr, name_len, \"invalid\");\n-        addr = nullptr;\n-        Unimplemented();\n-      }\n-      break;\n-  }\n-\n-  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n-    if (bt == T_FLOAT) {\n-      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_scalable\", VectorSupport::mathname[op], bits);\n-      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n-    } else {\n-      assert(bt == T_DOUBLE, \"must be FP type only\");\n-      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_scalable\", VectorSupport::mathname[op], bits);\n-      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n-    }\n-  }\n-\n-  return addr;\n-}\n-\n@@ -2047,26 +2070,0 @@\n-Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n-  assert(UseVectorStubs, \"sanity\");\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n-  assert(opd1 != nullptr, \"must not be null\");\n-  const TypeVect* vt = TypeVect::make(bt, num_elem);\n-  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != nullptr ? 2 : 1, vt, vt);\n-  char name[100] = \"\";\n-\n-  \/\/ Get address for vector math method.\n-  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n-\n-  if (addr == nullptr) {\n-    return nullptr;\n-  }\n-\n-  assert(name[0] != '\\0', \"name must not be null\");\n-  Node* operation = make_runtime_call(RC_VECTOR,\n-                                      call_type,\n-                                      addr,\n-                                      name,\n-                                      TypePtr::BOTTOM,\n-                                      opd1,\n-                                      opd2);\n-  return gvn().transform(new ProjNode(gvn().transform(operation), TypeFunc::Parms));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":115,"deletions":118,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -44,23 +45,0 @@\n-#ifdef COMPILER2\n-const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n-    \"tan\",\n-    \"tanh\",\n-    \"sin\",\n-    \"sinh\",\n-    \"cos\",\n-    \"cosh\",\n-    \"asin\",\n-    \"acos\",\n-    \"atan\",\n-    \"atan2\",\n-    \"cbrt\",\n-    \"log\",\n-    \"log10\",\n-    \"log1p\",\n-    \"pow\",\n-    \"exp\",\n-    \"expm1\",\n-    \"hypot\",\n-};\n-#endif\n-\n@@ -618,19 +596,0 @@\n-    case VECTOR_OP_TAN:\n-    case VECTOR_OP_TANH:\n-    case VECTOR_OP_SIN:\n-    case VECTOR_OP_SINH:\n-    case VECTOR_OP_COS:\n-    case VECTOR_OP_COSH:\n-    case VECTOR_OP_ASIN:\n-    case VECTOR_OP_ACOS:\n-    case VECTOR_OP_ATAN:\n-    case VECTOR_OP_ATAN2:\n-    case VECTOR_OP_CBRT:\n-    case VECTOR_OP_LOG:\n-    case VECTOR_OP_LOG10:\n-    case VECTOR_OP_LOG1P:\n-    case VECTOR_OP_POW:\n-    case VECTOR_OP_EXP:\n-    case VECTOR_OP_EXPM1:\n-    case VECTOR_OP_HYPOT:\n-      return Op_CallLeafVector;\n@@ -658,0 +617,8 @@\n+JVM_ENTRY(jstring, VectorSupport_GetCPUFeatures(JNIEnv* env, jclass ignored))\n+  const char* features_string = VM_Version::features_string();\n+  assert(features_string != nullptr, \"missing cpu features info\");\n+\n+  ThreadToNativeFromVM ttn(thread);\n+  return env->NewStringUTF(features_string);\n+JVM_END\n+\n@@ -662,0 +629,1 @@\n+#define LSTR LANG \"String;\"\n@@ -667,1 +635,2 @@\n-    {CC \"getMaxLaneCount\",   CC \"(\" CLS \")I\", FN_PTR(VectorSupport_GetMaxLaneCount)}\n+    {CC \"getMaxLaneCount\", CC \"(\" CLS \")I\", FN_PTR(VectorSupport_GetMaxLaneCount)},\n+    {CC \"getCPUFeatures\",  CC \"()\" LSTR,    FN_PTR(VectorSupport_GetCPUFeatures)}\n@@ -675,0 +644,1 @@\n+#undef LSTR\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":13,"deletions":43,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -104,20 +104,0 @@\n-    \/\/ Vector Math Library\n-    VECTOR_OP_TAN   = 101,\n-    VECTOR_OP_TANH  = 102,\n-    VECTOR_OP_SIN   = 103,\n-    VECTOR_OP_SINH  = 104,\n-    VECTOR_OP_COS   = 105,\n-    VECTOR_OP_COSH  = 106,\n-    VECTOR_OP_ASIN  = 107,\n-    VECTOR_OP_ACOS  = 108,\n-    VECTOR_OP_ATAN  = 109,\n-    VECTOR_OP_ATAN2 = 110,\n-    VECTOR_OP_CBRT  = 111,\n-    VECTOR_OP_LOG   = 112,\n-    VECTOR_OP_LOG10 = 113,\n-    VECTOR_OP_LOG1P = 114,\n-    VECTOR_OP_POW   = 115,\n-    VECTOR_OP_EXP   = 116,\n-    VECTOR_OP_EXPM1 = 117,\n-    VECTOR_OP_HYPOT = 118,\n-\n@@ -130,4 +110,0 @@\n-\n-    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n-    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n-    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -150,2 +126,0 @@\n-  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n-\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1536,1 +1536,1 @@\n-  const char* features = VM_Version::features_string();\n+  const char* features = VM_Version::cpu_info_string();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+const char* Abstract_VM_Version::_cpu_info_string = \"\";\n@@ -343,0 +344,13 @@\n+const char* Abstract_VM_Version::extract_features_string(const char* cpu_info_string,\n+                                                         size_t cpu_info_string_len,\n+                                                         size_t features_offset) {\n+  assert(features_offset <= cpu_info_string_len, \"\");\n+  if (features_offset < cpu_info_string_len) {\n+    assert(cpu_info_string[features_offset + 0] == ',', \"\");\n+    assert(cpu_info_string[features_offset + 1] == ' ', \"\");\n+    return cpu_info_string + features_offset + 2; \/\/ skip initial \", \"\n+  } else {\n+    return \"\"; \/\/ empty\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+  static const char* _cpu_info_string;\n+\n@@ -131,0 +133,1 @@\n+  static const char* cpu_info_string() { return _cpu_info_string; }\n@@ -132,0 +135,3 @@\n+  static const char* extract_features_string(const char* cpu_info_string,\n+                                             size_t cpu_info_string_len,\n+                                             size_t features_offset);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3786,5 +3786,0 @@\n-\n-    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n-      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1169,1 +1169,1 @@\n-  st->print(\" %s\", VM_Version::features_string());\n+  st->print(\" %s\", VM_Version::cpu_info_string());\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,2 +104,0 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,4 +308,0 @@\n-  \/\/ Vector Math Routines\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+     static_field(Abstract_VM_Version,         _cpu_info_string,                              const char*)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.vector;\n+\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+\/**\n+ * Miscellaneous utility methods.\n+ *\/\n+public class Utils {\n+    public static final boolean DEBUG = Boolean.getBoolean(\"jdk.incubator.vector.DEBUG\");\n+\n+    public static boolean isNonCapturingLambda(Object o) {\n+        return o.getClass().getDeclaredFields().length == 0;\n+    }\n+\n+    @CallerSensitive\n+    public static void debug(String format, Object... args) {\n+        if (DEBUG) {\n+            Class<?> caller = Reflection.getCallerClass();\n+            System.out.printf(\"DEBUG: %s: \", caller.getSimpleName());\n+            System.out.printf(format, args);\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/Utils.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import static jdk.internal.vm.vector.Utils.isNonCapturingLambda;\n+\n@@ -117,0 +119,3 @@\n+    public static final int VECTOR_OP_MATHLIB_FIRST = VECTOR_OP_TAN;\n+    public static final int VECTOR_OP_MATHLIB_LAST  = VECTOR_OP_HYPOT;\n+\n@@ -337,0 +342,17 @@\n+\/\/    public interface LibraryUnaryOperation<V extends Vector<?>,\n+\/\/            M extends VectorMask<?>> {\n+\/\/        V apply(MemorySegment entry, V v, M m);\n+\/\/    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>, E>\n+    V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<E> eClass, int length, String debugName,\n+                     V v,\n+                     UnaryOperation<V,?> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v, null);\n+    }\n+\n+    \/* ============================================================================ *\/\n+\n@@ -355,0 +377,18 @@\n+\n+    \/* ============================================================================ *\/\n+\n+\/\/    public interface LibraryBinaryOperation<V extends VectorPayload,\n+\/\/            M extends VectorMask<?>> {\n+\/\/        V apply(MemorySegment entry, V v1, V v2, M m);\n+\/\/    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends VectorPayload, E>\n+    V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<E> eClass, int length, String debugName,\n+                      V v1, V v2,\n+                      BinaryOperation<V,?> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, null);\n+    }\n+\n@@ -732,0 +772,5 @@\n+    \/\/ Returns a string containing a list of CPU features VM detected.\n+    public static native String getCPUFeatures();\n+\n+    \/* ============================================================================ *\/\n+\n@@ -737,2 +782,3 @@\n-    public static boolean isNonCapturingLambda(Object o) {\n-        return o.getClass().getDeclaredFields().length == 0;\n+    @SuppressWarnings({\"restricted\"})\n+    public static void loadNativeLibrary(String name) {\n+        System.loadLibrary(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+        jdk.incubator.vector,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -720,1 +720,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -731,0 +731,1 @@\n+\n@@ -827,0 +828,1 @@\n+\n@@ -853,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static jdk.incubator.vector.Util.requires;\n+import static jdk.internal.util.Architecture.isX64;\n+import static jdk.internal.vm.vector.Utils.debug;\n+\n+\/**\n+ * Enumerates CPU ISA extensions supported by the JVM on the current hardware.\n+ *\/\n+\/*package-private*\/ class CPUFeatures {\n+    private static final Set<String> features = getCPUFeatures();\n+\n+    private static Set<String> getCPUFeatures() {\n+        String featuresString = VectorSupport.getCPUFeatures();\n+        debug(featuresString);\n+        String[] features = featuresString.toLowerCase(Locale.ROOT).split(\", \"); \/\/ \", \" is used as a delimiter\n+        assert validateFeatures(features);\n+        return Set.of(features);\n+    }\n+\n+    private static boolean validateFeatures(String[] features) {\n+        for (String s : features) {\n+            assert s != null && s.matches(\"[a-z0-9._]+\") : String.format(\"Invalid CPU feature name: '%s'\", s);\n+        }\n+        return true;\n+    }\n+\n+    private static boolean hasFeature(String feature) {\n+        return features.contains(feature.toLowerCase(Locale.ROOT));\n+    }\n+\n+    public static class X64 {\n+        public static boolean SUPPORTS_AVX      = hasFeature(\"avx\");\n+        public static boolean SUPPORTS_AVX2     = hasFeature(\"avx2\");\n+        public static boolean SUPPORTS_AVX512F  = hasFeature(\"avx512f\");\n+        public static boolean SUPPORTS_AVX512DQ = hasFeature(\"avx512dq\");\n+\n+        static {\n+            requires(isX64(), \"unsupported platform\");\n+\n+            debug(\"AVX=%b; AVX2=%b; AVX512F=%b; AVX512DQ=%b\",\n+                  SUPPORTS_AVX, SUPPORTS_AVX2, SUPPORTS_AVX512F, SUPPORTS_AVX512DQ);\n+\n+            assert SUPPORTS_AVX512F == (VectorShape.getMaxVectorBitSize(int.class)   == 512);\n+            assert SUPPORTS_AVX2    == (VectorShape.getMaxVectorBitSize(byte.class)  >= 256);\n+            assert SUPPORTS_AVX     == (VectorShape.getMaxVectorBitSize(float.class) >= 256);\n+        }\n+    }\n+\n+    public static Set<String> features() {\n+        return features;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/CPUFeatures.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -681,0 +681,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n@@ -706,0 +709,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n@@ -714,0 +720,7 @@\n+    @ForceInline\n+    final\n+    DoubleVector unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), DoubleVector::unaryOperations,\n+                                             this);\n+    }\n+\n@@ -784,0 +797,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n@@ -818,0 +834,4 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+\n@@ -827,0 +847,7 @@\n+    @ForceInline\n+    final\n+    DoubleVector binaryMathOp(VectorOperators.Binary op, DoubleVector that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), DoubleVector::binaryOperations,\n+                                              this, that);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -681,0 +681,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n@@ -706,0 +709,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n@@ -714,0 +720,7 @@\n+    @ForceInline\n+    final\n+    FloatVector unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), FloatVector::unaryOperations,\n+                                             this);\n+    }\n+\n@@ -784,0 +797,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n@@ -818,0 +834,4 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+\n@@ -827,0 +847,7 @@\n+    @ForceInline\n+    final\n+    FloatVector binaryMathOp(VectorOperators.Binary op, FloatVector that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), FloatVector::binaryOperations,\n+                                              this, that);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -720,1 +720,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -731,0 +731,1 @@\n+\n@@ -827,0 +828,1 @@\n+\n@@ -853,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -650,1 +650,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -678,1 +678,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -689,0 +689,1 @@\n+\n@@ -785,0 +786,1 @@\n+\n@@ -811,0 +813,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -720,1 +720,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -731,0 +731,1 @@\n+\n@@ -827,0 +828,1 @@\n+\n@@ -853,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+\/*package-private*\/ class Util {\n+    public static void requires(boolean cond, String message) {\n+        if (!cond) {\n+            throw new InternalError(message);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Util.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import jdk.internal.util.StaticProperty;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.util.function.IntFunction;\n+\n+import static jdk.incubator.vector.Util.requires;\n+import static jdk.incubator.vector.VectorOperators.*;\n+import static jdk.internal.util.Architecture.*;\n+import static jdk.internal.vm.vector.Utils.debug;\n+\n+\/**\n+ * A wrapper for native vector math libraries bundled with the JDK (SVML and SLEEF).\n+ * Binds vector operations to native implementations provided by the libraries.\n+ *\/\n+\/*package-private*\/ class VectorMathLibrary {\n+    private static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n+\n+    interface Library {\n+        String symbolName(Operator op, VectorSpecies<?> vspecies);\n+        boolean isSupported(Operator op, VectorSpecies<?> vspecies);\n+\n+        String SVML  = \"svml\";\n+        String SLEEF = \"sleef\";\n+        String JAVA  = \"java\";\n+\n+        static Library getInstance() {\n+            String libraryName = System.getProperty(\"jdk.incubator.vector.VectorMathLibrary\", getDefaultName());\n+            try {\n+                return switch (libraryName) {\n+                    case SVML  -> new SVML();\n+                    case SLEEF -> new SLEEF();\n+                    case JAVA  -> new Java();\n+                    default    -> throw new IllegalArgumentException(\"Unsupported vector math library: \" + libraryName);\n+                };\n+            } catch (Throwable e) {\n+                debug(\"Error during initialization of %s library: %s\", libraryName, e);\n+                return new Java(); \/\/ fallback\n+            }\n+        }\n+\n+        static String getDefaultName() {\n+            return switch (StaticProperty.osArch()) {\n+                case \"amd64\", \"x86_64\" -> SVML;\n+                case \"aarch64\" -> SLEEF;\n+                default -> JAVA;\n+            };\n+        }\n+    }\n+\n+    private static final Library LIBRARY = Library.getInstance();\n+\n+    static {\n+        debug(\"%s library is used (cpu features: %s)\", LIBRARY.getClass().getSimpleName(), CPUFeatures.features());\n+    }\n+\n+    private static class Java implements Library {\n+        @Override\n+        public String symbolName(Operator op, VectorSpecies<?> vspecies) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean isSupported(Operator op, VectorSpecies<?> vspecies) {\n+            return false; \/\/ always use default implementation\n+        }\n+    }\n+\n+    \/**\n+     * Naming convention in SVML vector math library.\n+     * All the methods are named as __jsvml_<op><T><N>_ha_<VV> where:\n+     *      ha stands for high accuracy\n+     *      <T> is optional to indicate float\/double\n+     *              Set to f for vector float operation\n+     *              Omitted for vector double operation\n+     *      <N> is the number of elements in the vector\n+     *              1, 2, 4, 8, 16\n+     *              e.g. 128 bit float vector has 4 float elements\n+     *      <VV> indicates the avx\/sse level:\n+     *              z0 is AVX512, l9 is AVX2, e9 is AVX1 and ex is for SSE2\n+     *      e.g. __jsvml_expf16_ha_z0 is the method for computing 16 element vector float exp using AVX 512 insns\n+     *           __jsvml_exp8_ha_z0 is the method for computing 8 element vector double exp using AVX 512 insns\n+     *\/\n+    private static class SVML implements Library {\n+        static {\n+            loadNativeLibrary();\n+        }\n+\n+        private static void loadNativeLibrary() {\n+            requires(isX64(), \"SVML library is x64-specific\");\n+            VectorSupport.loadNativeLibrary(\"jsvml\");\n+        }\n+\n+        private static String suffix(VectorSpecies<?> vspecies) {\n+            assert vspecies.vectorBitSize() <= VectorShape.getMaxVectorBitSize(vspecies.elementType());\n+\n+            if (vspecies.vectorBitSize() == 512) {\n+                assert CPUFeatures.X64.SUPPORTS_AVX512F;\n+                return \"z0\";\n+            } else if (CPUFeatures.X64.SUPPORTS_AVX2) {\n+                return \"l9\";\n+            } else if (CPUFeatures.X64.SUPPORTS_AVX) {\n+                return \"e9\";\n+            } else {\n+                return \"ex\";\n+            }\n+        }\n+\n+        @Override\n+        public String symbolName(Operator op, VectorSpecies<?> vspecies) {\n+            String suffix = suffix(vspecies);\n+            String elemType = (vspecies.elementType() == float.class ? \"f\" : \"\");\n+            int vlen = (vspecies == FloatVector.SPECIES_64 ? 4 : vspecies.length()); \/\/ reuse 128-bit variant for 64-bit float vectors\n+            return String.format(\"__jsvml_%s%s%d_ha_%s\", op.operatorName(), elemType, vlen, suffix);\n+        }\n+\n+        @Override\n+        public boolean isSupported(Operator op, VectorSpecies<?> vspecies) {\n+            Class<?> etype = vspecies.elementType();\n+            if (etype != float.class && etype != double.class) {\n+                return false; \/\/ only FP types are supported\n+            }\n+            int maxLaneCount = VectorSupport.getMaxLaneCount(vspecies.elementType());\n+            if (vspecies.length() > maxLaneCount) {\n+                return false; \/\/ lacking vector support\n+            }\n+            if (vspecies == DoubleVector.SPECIES_64) {\n+                return false; \/\/ 64-bit double vectors are not supported\n+            }\n+            if (vspecies.vectorBitSize() == 512) {\n+                if (op == LOG || op == LOG10 || op == POW) {\n+                    return CPUFeatures.X64.SUPPORTS_AVX512DQ; \/\/ requires AVX512DQ CPU support\n+                }\n+            } else if (op == POW) {\n+                return false; \/\/ not supported\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Naming convention in SLEEF-based vector math library .\n+     * All the methods are named as <OP><T><N>_<U><suffix> where:\n+     *     <OP>     is the operation name, e.g. sin\n+     *     <T>      is optional to indicate float\/double\n+     *              \"f\/d\" for vector float\/double operation\n+     *     <N>      is the number of elements in the vector\n+     *              \"2\/4\" for neon, and \"x\" for sve\/rvv\n+     *     <U>      is the precision level\n+     *              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+     *               We use \"u10\" for all operations by default\n+     *               But for those functions do not have u10 support, we use \"u05\" instead\n+     *     <suffix> indicates neon\/sve\/rvv\n+     *              \"sve\/advsimd\/rvv\" for sve\/neon\/rvv implementations\n+     *     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n+     *          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n+     *\/\n+    private static class SLEEF implements Library {\n+        static {\n+            VectorSupport.loadNativeLibrary(\"sleef\");\n+        }\n+\n+        private static String suffix(VectorShape vshape) {\n+            if (isAARCH64()) {\n+                if (vshape.vectorBitSize() <= 128) {\n+                    return \"advsimd\";\n+                } else {\n+                    assert (vshape == VectorShape.S_Max_BIT) : \"not supported: \" + vshape;\n+                    return \"sve\";\n+                }\n+            } else if (isRISCV64()) {\n+                assert (vshape == VectorShape.S_Max_BIT) : \"not supported: \" + vshape;\n+                return \"rvv\";\n+            } else {\n+                throw new InternalError(\"unsupported platform\");\n+            }\n+        }\n+\n+        private static String precisionLevel(Operator op) {\n+            return (op == HYPOT ? \"u05\" : \"u10\");\n+        }\n+\n+        @Override\n+        public String symbolName(Operator op, VectorSpecies<?> vspecies) {\n+            int vlen = (vspecies == FloatVector.SPECIES_64 ? 4 : vspecies.length()); \/\/ reuse 128-bit variant for 64-bit float vectors\n+            boolean isShapeAgnostic = isRISCV64() || (isAARCH64() && vspecies.vectorBitSize() > 128);\n+            return String.format(\"%s%s%s_%s%s\", op.operatorName(),\n+                                 (vspecies.elementType() == float.class ? \"f\" : \"d\"),\n+                                 (isShapeAgnostic ? \"x\" : Integer.toString(vlen)),\n+                                 precisionLevel(op),\n+                                 suffix(vspecies.vectorShape()));\n+        }\n+\n+        @Override\n+        public boolean isSupported(Operator op, VectorSpecies<?> vspecies) {\n+            Class<?> etype = vspecies.elementType();\n+            if (etype != float.class && etype != double.class) {\n+                return false; \/\/ only FP element types are supported\n+            }\n+            int maxLaneCount = VectorSupport.getMaxLaneCount(vspecies.elementType());\n+            if (vspecies.length() > maxLaneCount) {\n+                return false; \/\/ lacking vector support\n+            }\n+            if (vspecies.vectorShape() != VectorShape.S_Max_BIT) {\n+                if (isRISCV64()) {\n+                    return false; \/\/ FIXME: only MAX shapes are supported on RISC-V\n+                }\n+                if (isAARCH64() && vspecies.vectorBitSize() > 128) {\n+                    return false; \/\/ FIXME: SVE support only for MAX shapes\n+                }\n+                if (vspecies == DoubleVector.SPECIES_64) {\n+                    return false; \/\/ 64-bit double vectors are not supported\n+                }\n+            }\n+            if (op == TANH) {\n+                return false; \/\/ skip due to performance considerations\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private static final int SIZE = VectorSupport.VECTOR_OP_MATHLIB_LAST - VectorSupport.VECTOR_OP_MATHLIB_FIRST + 1;\n+\n+    private record Entry<T> (String name, MemorySegment entry, T impl) {}\n+\n+    private static final @Stable Entry<?>[][][] LIBRARY_ENTRIES = new Entry<?>[SIZE][LaneType.SK_LIMIT][VectorShape.SK_LIMIT]; \/\/ OP x SHAPE x TYPE\n+\n+    @ForceInline\n+    private static <T> Entry<T> lookup(Operator op, int opc, VectorSpecies<?> vspecies, IntFunction<T> implSupplier) {\n+        int idx = opc - VectorSupport.VECTOR_OP_MATHLIB_FIRST;\n+        int elem_idx = ((AbstractSpecies<?>)vspecies).laneType.switchKey;\n+        int shape_idx = vspecies.vectorShape().switchKey;\n+        @SuppressWarnings({\"unchecked\"})\n+        Entry<T> entry = (Entry<T>)LIBRARY_ENTRIES[idx][elem_idx][shape_idx];\n+        if (entry == null) {\n+            entry = constructEntry(op, opc, vspecies, implSupplier);\n+            LIBRARY_ENTRIES[idx][elem_idx][shape_idx] = entry;\n+        }\n+        return entry;\n+    }\n+\n+    @DontInline\n+    private static\n+    <E,T>\n+    Entry<T> constructEntry(Operator op, int opc, VectorSpecies<E> vspecies, IntFunction<T> implSupplier) {\n+        if (LIBRARY.isSupported(op, vspecies)) {\n+            String symbol = LIBRARY.symbolName(op, vspecies);\n+            try {\n+                MemorySegment addr = LOOKUP.findOrThrow(symbol);\n+                debug(\"%s %s => 0x%016x\\n\", op, symbol, addr.address());\n+                T impl = implSupplier.apply(opc); \/\/ TODO: should call the very same native implementation eventually (once FFM API supports vectors)\n+                return new Entry<>(symbol, addr, impl);\n+            } catch (RuntimeException e) {\n+              throw new InternalError(\"not supported: \" + op + \" \" + vspecies + \" \" + symbol, e);\n+            }\n+        } else {\n+            return new Entry<>(null, MemorySegment.NULL, implSupplier.apply(opc));\n+        }\n+    }\n+\n+    @ForceInline\n+    \/*package-private*\/ static\n+    <E, V extends Vector<E>>\n+    V unaryMathOp(Unary op, int opc, VectorSpecies<E> vspecies,\n+                  IntFunction<VectorSupport.UnaryOperation<V,?>> implSupplier,\n+                  V v) {\n+        var entry = lookup(op, opc, vspecies, implSupplier);\n+\n+        long entryAddress = entry.entry.address();\n+        if (entryAddress != 0) {\n+            @SuppressWarnings({\"unchecked\"})\n+            Class<V> vt = (Class<V>)vspecies.vectorType();\n+            return VectorSupport.libraryUnaryOp(\n+                    entry.entry.address(), vt, vspecies.elementType(), vspecies.length(), entry.name,\n+                    v,\n+                    entry.impl);\n+        } else {\n+            return entry.impl.apply(v, null);\n+        }\n+    }\n+\n+    @ForceInline\n+    \/*package-private*\/ static\n+    <E, V extends Vector<E>>\n+    V binaryMathOp(Binary op, int opc, VectorSpecies<E> vspecies,\n+                   IntFunction<VectorSupport.BinaryOperation<V,?>> implSupplier,\n+                   V v1, V v2) {\n+        var entry = lookup(op, opc, vspecies, implSupplier);\n+\n+        long entryAddress = entry.entry.address();\n+        if (entryAddress != 0) {\n+            @SuppressWarnings({\"unchecked\"})\n+            Class<V> vt = (Class<V>)vspecies.vectorType();\n+            return VectorSupport.libraryBinaryOp(\n+                    entry.entry.address(), vt, vspecies.elementType(), vspecies.length(), entry.name,\n+                    v1, v2,\n+                    entry.impl);\n+        } else {\n+            return entry.impl.apply(v1, v2, null);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMathLibrary.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -36,0 +36,2 @@\n+import static jdk.internal.vm.vector.Utils.isNonCapturingLambda;\n+\n@@ -429,0 +431,1 @@\n+        VO_MATHLIB                 = 0x400,\n@@ -479,1 +482,1 @@\n-    public static final \/*float*\/ Unary SIN = unary(\"SIN\", \"sin\", VectorSupport.VECTOR_OP_SIN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary SIN = unary(\"SIN\", \"sin\", VectorSupport.VECTOR_OP_SIN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -483,1 +486,1 @@\n-    public static final \/*float*\/ Unary COS = unary(\"COS\", \"cos\", VectorSupport.VECTOR_OP_COS, VO_ONLYFP);\n+    public static final \/*float*\/ Unary COS = unary(\"COS\", \"cos\", VectorSupport.VECTOR_OP_COS, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -487,1 +490,1 @@\n-    public static final \/*float*\/ Unary TAN = unary(\"TAN\", \"tan\", VectorSupport.VECTOR_OP_TAN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary TAN = unary(\"TAN\", \"tan\", VectorSupport.VECTOR_OP_TAN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -491,1 +494,1 @@\n-    public static final \/*float*\/ Unary ASIN = unary(\"ASIN\", \"asin\", VectorSupport.VECTOR_OP_ASIN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary ASIN = unary(\"ASIN\", \"asin\", VectorSupport.VECTOR_OP_ASIN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -495,1 +498,1 @@\n-    public static final \/*float*\/ Unary ACOS = unary(\"ACOS\", \"acos\", VectorSupport.VECTOR_OP_ACOS, VO_ONLYFP);\n+    public static final \/*float*\/ Unary ACOS = unary(\"ACOS\", \"acos\", VectorSupport.VECTOR_OP_ACOS, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -499,1 +502,1 @@\n-    public static final \/*float*\/ Unary ATAN = unary(\"ATAN\", \"atan\", VectorSupport.VECTOR_OP_ATAN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary ATAN = unary(\"ATAN\", \"atan\", VectorSupport.VECTOR_OP_ATAN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -504,1 +507,1 @@\n-    public static final \/*float*\/ Unary EXP = unary(\"EXP\", \"exp\", VectorSupport.VECTOR_OP_EXP, VO_ONLYFP);\n+    public static final \/*float*\/ Unary EXP = unary(\"EXP\", \"exp\", VectorSupport.VECTOR_OP_EXP, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -508,1 +511,1 @@\n-    public static final \/*float*\/ Unary LOG = unary(\"LOG\", \"log\", VectorSupport.VECTOR_OP_LOG, VO_ONLYFP);\n+    public static final \/*float*\/ Unary LOG = unary(\"LOG\", \"log\", VectorSupport.VECTOR_OP_LOG, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -512,1 +515,1 @@\n-    public static final \/*float*\/ Unary LOG10 = unary(\"LOG10\", \"log10\", VectorSupport.VECTOR_OP_LOG10, VO_ONLYFP);\n+    public static final \/*float*\/ Unary LOG10 = unary(\"LOG10\", \"log10\", VectorSupport.VECTOR_OP_LOG10, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -518,1 +521,1 @@\n-    public static final \/*float*\/ Unary CBRT = unary(\"CBRT\", \"cbrt\", VectorSupport.VECTOR_OP_CBRT, VO_ONLYFP);\n+    public static final \/*float*\/ Unary CBRT = unary(\"CBRT\", \"cbrt\", VectorSupport.VECTOR_OP_CBRT, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -523,1 +526,1 @@\n-    public static final \/*float*\/ Unary SINH = unary(\"SINH\", \"sinh\", VectorSupport.VECTOR_OP_SINH, VO_ONLYFP);\n+    public static final \/*float*\/ Unary SINH = unary(\"SINH\", \"sinh\", VectorSupport.VECTOR_OP_SINH, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -527,1 +530,1 @@\n-    public static final \/*float*\/ Unary COSH = unary(\"COSH\", \"cosh\", VectorSupport.VECTOR_OP_COSH, VO_ONLYFP);\n+    public static final \/*float*\/ Unary COSH = unary(\"COSH\", \"cosh\", VectorSupport.VECTOR_OP_COSH, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -531,1 +534,1 @@\n-    public static final \/*float*\/ Unary TANH = unary(\"TANH\", \"tanh\", VectorSupport.VECTOR_OP_TANH, VO_ONLYFP);\n+    public static final \/*float*\/ Unary TANH = unary(\"TANH\", \"tanh\", VectorSupport.VECTOR_OP_TANH, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -535,1 +538,1 @@\n-    public static final \/*float*\/ Unary EXPM1 = unary(\"EXPM1\", \"expm1\", VectorSupport.VECTOR_OP_EXPM1, VO_ONLYFP);\n+    public static final \/*float*\/ Unary EXPM1 = unary(\"EXPM1\", \"expm1\", VectorSupport.VECTOR_OP_EXPM1, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -539,1 +542,1 @@\n-    public static final \/*float*\/ Unary LOG1P = unary(\"LOG1P\", \"log1p\", VectorSupport.VECTOR_OP_LOG1P, VO_ONLYFP);\n+    public static final \/*float*\/ Unary LOG1P = unary(\"LOG1P\", \"log1p\", VectorSupport.VECTOR_OP_LOG1P, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -618,1 +621,1 @@\n-    public static final \/*float*\/ Binary ATAN2 = binary(\"ATAN2\", \"atan2\", VectorSupport.VECTOR_OP_ATAN2, VO_ONLYFP);\n+    public static final \/*float*\/ Binary ATAN2 = binary(\"ATAN2\", \"atan2\", VectorSupport.VECTOR_OP_ATAN2, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -622,1 +625,1 @@\n-    public static final \/*float*\/ Binary POW = binary(\"POW\", \"pow\", VectorSupport.VECTOR_OP_POW, VO_ONLYFP);\n+    public static final \/*float*\/ Binary POW = binary(\"POW\", \"pow\", VectorSupport.VECTOR_OP_POW, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -626,1 +629,1 @@\n-    public static final \/*float*\/ Binary HYPOT = binary(\"HYPOT\", \"hypot\", VectorSupport.VECTOR_OP_HYPOT, VO_ONLYFP);\n+    public static final \/*float*\/ Binary HYPOT = binary(\"HYPOT\", \"hypot\", VectorSupport.VECTOR_OP_HYPOT, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -1376,1 +1379,1 @@\n-            assert(VectorSupport.isNonCapturingLambda(fn)) : fn;\n+            assert(isNonCapturingLambda(fn)) : fn;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -715,1 +715,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -719,0 +719,5 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n+#end[FP]\n@@ -745,1 +750,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -749,0 +754,5 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n+#end[FP]\n@@ -757,0 +767,9 @@\n+#if[FP]\n+    @ForceInline\n+    final\n+    $abstractvectortype$ unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), $abstractvectortype$::unaryOperations,\n+                                             this);\n+    }\n+#end[FP]\n+\n@@ -859,0 +878,5 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n+#end[FP]\n@@ -918,0 +942,6 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+#end[FP]\n+\n@@ -948,0 +978,9 @@\n+#if[FP]\n+    @ForceInline\n+    final\n+    $abstractvectortype$ binaryMathOp(VectorOperators.Binary op, $abstractvectortype$ that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), $abstractvectortype$::binaryOperations,\n+                                              this, that);\n+    }\n+#end[FP]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"}]}